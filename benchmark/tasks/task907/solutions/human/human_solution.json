[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\tval N = scala.io.StdIn.readInt\n\t\n\tval a = new Array[Int](N-1)\n\tval b = new Array[Int](N-1)\n\n\tfor(i<-0 until N-1){\n\t\tval temp = scala.io.StdIn.readLine.split(\" \").map(_.toInt)\n\t\ta(i) = temp(0)\n\t\tb(i) = temp(1)\n\t}\n\n\tval c = new Array[Boolean](N-1)\n\n\tfor(i<-0 until N-1){\n\t\tif(a(i) == 1) c(b(i) - 1) = true\n\t}\n\n\tvar re = false\n\n\tfor(i<-0 until N-1){\n\t\tif(c(i)) re = !re\n\t}\n\n\tif(re)println(\"Alice\")\n\telse println(\"Bob\")\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1  : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=1e5+50;\nint n;\nvector <int> edge[N];\n\ninline int sg(int x,int f) {\n\tint sum=0;\n\tfor(auto v:edge[x])\n\t\tif(v^f) sum^=(sg(v,x)+1);\n\treturn sum;\n}\nint main() {\n\tn=rd();\n\tfor(int i=1;i<n;i++) {\n\t\tint x=rd(), y=rd();\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t} puts(sg(1,0) ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p){\n\tint x = 0;\n\tfor(int i : e[c]) if(i != p){\n\t\tx ^= 1 + rec(i, c);\n\t}\n\treturn x;\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b); e[b].pb(a);\n\t}\n\tcout << (rec(0, 0) ? \"Alice\" : \"Bob\") << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=100005;\nint n,sg[N];\nvector <int> e[N];\nvoid solve(int x,int pre){\n\tsg[x]=0;\n\tfor (auto y : e[x])\n\t\tif (y!=pre){\n\t\t\tsolve(y,x);\n\t\t\tsg[x]^=sg[y]+1;\n\t\t}\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tsolve(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n#if 0\nS V<ll> edgelist[n+1];\n#endif\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\n#if 0\nS ll parents[n+1];\nS V<ll> children[n+1];\nS ll levels[n+1];\n#endif\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parents[], V<ll> children[], ll levels[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parents[root] = root;\n    levels[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parents[next] = now;\n            children[now].pb(next);\n            levels[next] = levels[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    S V<t2> xylist; llinl2(xylist, n-1);\n\n    S V<ll> edgelist[100005];\n    make_edgelist(xylist, edgelist);\n\n    S ll parents[100005];\n    S V<ll> children[100005];\n    S ll levels[100005];\n    make_parental_relation(edgelist, 1, n, parents, children, levels);\n\n    S ll grundy[100005];\n    memset(grundy, 0, sizeof(grundy));\n\n    S ll childcnt[100005];\n    rep (i, 100005) childcnt[i] = children[i].size();\n\n    S queue<ll> q;\n    srep (v, 1, n+1) if (!childcnt[v]) q.push(v);\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n        if (v == 1LL) continue;\n        ll pv = parents[v];\n        ll g = grundy[v] + 1LL;\n        grundy[pv] ^= g;\n        childcnt[pv]--;\n        if (!childcnt[pv]) q.push(pv);\n    }\n\n    cout << ((grundy[1]) ? \"Alice\" : \"Bob\") << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=200003;\nconst ll INF=1LL<<60;\nvector<int> G[MAX];\n\nint DFS(int u,int p){\n    int gru=0;\n    \n    for(int to:G[u]){\n        if(to==p) continue;\n        gru^=(DFS(to,u)+1);\n    }\n    \n    return gru;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    int a=DFS(0,-1);\n    \n    if(a) cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nvector<int> es[114514];\n\npii Dfs(int v, int p) {\n  int cnt = 0;\n  for (int u : es[v]) {\n    if (u == p) continue;\n    cnt++;\n  }\n  if (!cnt) return pii(-1, -1);\n    \n  bool first = true;\n  cnt = 0;\n  for (int u : es[v]) {\n    if (u == p) continue;\n\n    auto res = Dfs(u, v);\n    if (res.X == -1) {\n      first = false;\n      cnt++;\n    }\n  }\n \n  pii ret(1-cnt%2, cnt%2);\n  bool spe = false;\n  for (int u : es[v]) {\n    if (u == p) continue;\n\n    auto res = Dfs(u, v);\n    if (res.X == -1) continue;\n\n    if (first) {\n      ret.X = 0;\n      ret.Y = res.X;\n      if (res.X == 0) spe = true;\n    } else {\n      if (ret.X == 1) ret.X = 0;\n      else ret.X = res.Y;\n\n      if (ret.Y == 1) {\n        assert(!spe);\n        ret.Y = 0;\n      } else if (spe) {\n        assert(ret.Y == 0);\n        ret.Y = !res.X;\n      } else {\n        ret.Y = res.X;\n      }\n      spe = false;\n    }\n    first = false;\n  }\n  //printf(\"%d: %d, %d\\n\", v+1, ret.X, ret.Y);\n  return ret;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n    es[x].eb(y);\n    es[y].eb(x);\n  }\n\n  auto res = Dfs(0, 0);\n  if (res.X == 0) puts(\"Alice\");\n  else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, x, y;\n\nint dp[MAXN];\n\nvoid dfs(int nd, int f)\n{\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (to == f) continue;\n\t\tdfs(to, nd), dp[nd] ^= dp[to]+1;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 2; i <= n; i++) {\n\t\tcin >> x >> y;\n\t\tpush(x, y), push(y, x);\n\t}\n\tdfs(1, 0);\n\tif (dp[1] != 0) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint ne[N],tot,n,fi[N],zz[N],sg[N],x,y;\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nvoid dfs(int x,int y){\n\tfor (int i=fi[x];i;i=ne[i])\n\t\tif (zz[i]!=y)dfs(zz[i],x),sg[x]^=sg[zz[i]]+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tjb(x,y);jb(y,x); \n\t}\n\tdfs(1,0);\n\tif (sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n} "
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n#if 0\nS V<ll> edgelist[n+1];\n#endif\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\n#if 0\nS ll parent[n+1];\nS V<ll> children[n+1];\nS ll level[n+1];\n#endif\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    S V<t2> xylist; llinl2(xylist, n-1);\n\n    S V<ll> edgelist[100005];\n    make_edgelist(xylist, edgelist);\n\n    S ll parent[100005];\n    S V<ll> children[100005];\n    S ll level[100005];\n    make_parental_relation(edgelist, 1, n, parent, children, level);\n\n    S ll grundy[100005];\n    memset(grundy, 0, sizeof(grundy));\n\n    S ll childcnt[100005];\n    rep (i, 100005) childcnt[i] = children[i].size();\n\n    S queue<ll> q;\n    srep (v, 1, n+1) if (!childcnt[v]) q.push(v);\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n        if (v == 1LL) continue;\n        ll pv = parent[v];\n        ll g = grundy[v] + 1LL;\n        grundy[pv] ^= g;\n        childcnt[pv]--;\n        if (!childcnt[pv]) q.push(pv);\n    }\n\n    cout << ((grundy[1]) ? \"Alice\" : \"Bob\") << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define INF 2139062143\n#define inf -2139062144\n#define ll long long\nusing namespace std;\n#define N 101000\nstruct KSD {\n\tint v,next;\n} e[N<<1];\nint head[N],cnt;\ninline void add(int u,int v) {\n\te[++cnt].v=v;\n\te[cnt].next=head[u];\n\thead[u]=cnt;\n}\nint n;\nint sg[N];\nvoid dfs(int x,int p) {\n\tint i,v;\n\tsg[x]=0;\n\tfor(i=head[x]; i; i=e[i].next) {\n\t\tv=e[i].v;\n\t\tif(v==p)continue;\n\t\tdfs(v,x);\n\t\tsg[x]^=(sg[v]+1);\n\t}\n}\nint main() {\n\tint i,j,T;\n\tint a,b;\n\tcnt=1;\n\tmemset(head,0,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(i=1; i<n; i++) {\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b),add(b,a);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\nint n;\nvector<int> graph[500000];\nint x[500000];\nint dfs(int v)\n{\n\tx[v] = 1;\n\tint c = 0, f = 0;\n\tfor (auto u : graph[v])\n\t{\n\t\tif (x[u] == 0)\n\t\t{\n\t\t\tf ^= dfs(u);\n\t\t\tc++;\n\t\t}\n\t}\n\tif (c == 0) return 1;\n\tif (c == 1) return 0;\n\treturn f ^ (c & 1);\n}\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i + 1 < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tgraph[v].push_back(u);\n\t\tgraph[u].push_back(v);\n\t}\n\tif (dfs(1)) cout << \"Bob\";\n\telse cout << \"Alice\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 100005;\nint n, ed;\nint he[maxn];\nstruct Edge{\n\tint v, nx;\n\tEdge(){;}\n\tEdge(int _v, int _nx){v = _v, nx = _nx;}\n}e[maxn << 1];\ninline void Add(int u, int v){\n\te[++ed] = Edge(v, he[u]);he[u] = ed;\n}\nint Dfs(int x, int fa){\n\tint res = 0;\n\tfor(int i = he[x], v;i;i = e[i].nx){\n\t\tv =e[i].v;\n\t\tif(v == fa)continue;\n\t\tres ^= (Dfs(v, x) + 1);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, u, v;i < n;++i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tAdd(u, v);Add(v, u);\n\t}\n\tputs(Dfs(1, 1) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n \ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n \ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n \nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n \n \nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n \nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n \nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n \ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n \ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n \ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n \ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n \ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n \ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint n,q[100005],x[100005];\nvi g[100005];\nvoid dfs(int v,int p){\n\tint ch=0;\n\tfor(auto &i:g[v]){\n\t\tif(i==p)continue;\n\t\tdfs(i,v);\n\t\tch++;\n\t\tx[v]^=q[i];\n\t}\n\tif(ch%2==0)q[v]=x[v];\n\telse q[v]=1;\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[--a].eb(--b);\n\t\tg[b].eb(a);\n\t}\n\tdfs(0,-1);\n\tif(q[0])cout<<\"Alice\\n\";\n\telse cout<<\"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing lint = long long int;\nusing pii = std::pair<int, int>;\n\nusing std::vector;\n\nvector<int> graph[100100];\nbool check[100100];\nint ans;\n\nvoid dfs(int node, int par, int dep) {\n\tif (dep != 0) {\n\t\tif (check[dep]) {\n\t\t\tcheck[dep] = false;\n\t\t\tans--;\n\t\t}\n\t\telse {\n\t\t\tcheck[dep] = true;\n\t\t\tans++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < graph[node].size(); i++) {\n\t\tif (graph[node][i] != par) {\n\t\t\tdfs(graph[node][i], node, dep + 1);\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tgraph[t1].push_back(t2);\n\t\tgraph[t2].push_back(t1);\n\t}\n\n\tdfs(1, 0, 0);\n\n\tif (ans == 0) {\n\t\tprintf(\"Bob\");\n\t}\n\telse {\n\t\tprintf(\"Alice\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing LD = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<LD>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr LD PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate<class T>static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()));\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear(); char c; for (i(c); !isspace(c); c = gc())v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')adp = true;\n\t\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\t\telse v = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1; bool neg = false, adp = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')adp = true;\n\t\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\t\telse v = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg)v = -v;\n\t}\n\ttemplate<class T, class U>static void i(pair<T, U>& v) {\n\t\ti(v.first); i(v.second);\n\t}\n\ttemplate<class T>static void i(vector<T>& v) {\n\t\tfor (auto& e : v)i(e);\n\t}\n\tstruct InputV {\n\t\tint n, id;\n\t\tInputV(int _n) :n(_n), id(0) {}\n\t\tInputV(const pair<int, int>& nm) :n(nm.first), id(nm.second) {}\n\t\ttemplate<class T>operator vector<T>() {\n\t\t\tvector<T> v(n); i(v); return v;\n\t\t}\n\t\ttemplate<class T>operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(id)); i(v); return v;\n\t\t}\n\t};\npublic:\n\tstatic string get_line() {\n\t\tstring v; char c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc())v += c;\n\t\treturn v;\n\t}\n\ttemplate<class T>static T in() {\n\t\tT v; i(v); return v;\n\t}\n\ttemplate<class T>operator T()const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int)const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n)const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n)const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()()const {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t)const {\n\t\ti(h); operator()(forward<T>(t)...);\n\t}\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(ll)\n#define STR input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(ll, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v)const {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(long long v)const {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v)const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v)const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v)const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v)const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v)const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate<class T> void p(const T& v)const {\n\t\tcout << v;\n\t}\n\ttemplate<class T, class U>void p(const pair<T, U>& v)const {\n\t\tp(v.first); p(D.d); p(v.second);\n\t}\n\ttemplate<class T>void p(const vector<T>& v)const {\n\t\trep(i, sz(v)) { if (i)p(D.d); p(v[i]); }\n\t}\n\ttemplate<class T>void p(const vector<vector<T>>& v)const {\n\t\trep(i, sz(v)) { if (i)p(D.l); p(v[i]); }\n\t}\npublic:\n\tOutput& operator()() {\n\t\tp(D.l); return *this;\n\t}\n\ttemplate<class H>Output& operator()(H&& h) {\n\t\tp(h); p(D.l); return *this;\n\t}\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class It>Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) { if (i != l)p(D.d); p(*i); } p(D.l); return *this;\n\t}\n\ttemplate<class T>Output& range(const T& a) {\n\t\trange(a.begin(), a.end()); return *this;\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout); return *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b; return *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d; return *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f); return *this;\n\t}\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b; a += c; return *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this; --b; a += c; return tmp;\n\t\t}\n\t\tconstexpr const T& operator*()const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->()const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i)const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i)const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start()const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T count()const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step()const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const {\n\t\treturn be;\n\t}\n\tconstexpr It end()const {\n\t\treturn en;\n\t}\n\tconstexpr T start()const {\n\t\treturn be.start();\n\t}\n\tconstexpr T count()const {\n\t\treturn be.count();\n\t}\n\tconstexpr T step()const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum()const {\n\t\treturn start() * count() + step() * (count() * (count() - 1) / 2);\n\t}\n\toperator vector<T>()const {\n\t\treturn as_vector();\n\t}\n\ttemplate<class F>void each(const F& f)const {\n\t\tfor (T i : *this)f(i);\n\t}\n\tauto as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto map(const F& f)const {\n\t\tvector<U> res; res.reserve(count()); each([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>auto select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {if (f(i))++res; }); return res;\n\t}\n\ttemplate<class F>T find_if(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return i; return 0;\n\t}\n\ttemplate<class F>auto max_by(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min_by(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>bool all_of(const F& f)const {\n\t\tfor (T i : *this)if (!f(i))return false; return true;\n\t}\n\ttemplate<class F>bool any_of(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return true; return false;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate<class T>inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate<class T>inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) {\n\t\tsort(all(a));\n\t}\n\ttemplate<class T>inline void RSort(T& a) {\n\t\tsort(rall(a));\n\t}\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), f);\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), f);\n\t}\n\ttemplate<class T>inline T Sorted(T a) {\n\t\tSort(a); return a;\n\t}\n\ttemplate<class T>inline T RSorted(T a) {\n\t\tRSort(a); return a;\n\t}\n\ttemplate<class T, class F>inline T Sorted(T& a, const F& f) {\n\t\tSort(a, f); return a;\n\t}\n\ttemplate<class T, class F>inline T RSorted(T& a, const F& f) {\n\t\tRSort(a, f); return a;\n\t}\n\ttemplate<class T, class F>inline void SortBy(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSortBy(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) {\n\t\treverse(all(a));\n\t}\n\ttemplate<class T>inline void Unique(T& a) {\n\t\ta.erase(unique(all(a)), a.end());\n\t}\n\ttemplate<class T>inline void Uniq(T& a) {\n\t\tSort(a); Unique(a);\n\t}\n\ttemplate<class T>inline void Rotate(T& a, int left) {\n\t\trotate(a.begin(), a.begin() + left, a.end());\n\t}\n\ttemplate<class T>inline T Reversed(T a) {\n\t\tReverse(a); return a;\n\t}\n\ttemplate<class T>inline T Uniqued(T a) {\n\t\tUnique(a); return a;\n\t}\n\ttemplate<class T>inline T Uniqed(T a) {\n\t\tUniq(a); return a;\n\t}\n\ttemplate<class T>inline T Rotated(T a, int left) {\n\t\tRotate(a, left); return a;\n\t}\n\ttemplate<class T>inline auto Max(const T& a) {\n\t\treturn *max_element(all(a));\n\t}\n\ttemplate<class T>inline auto Min(const T& a) {\n\t\treturn *min_element(all(a));\n\t}\n\ttemplate<class T>inline int MaxPos(const T& a) {\n\t\treturn max_element(all(a)) - a.begin();\n\t}\n\ttemplate<class T>inline int MinPos(const T& a) {\n\t\treturn min_element(all(a)) - a.begin();\n\t}\n\ttemplate<class T, class F>inline auto MaxBy(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto MinBy(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) {\n\t\treturn count(all(a), v);\n\t}\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) {\n\t\treturn count_if(all(a), f);\n\t}\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) {\n\t\treturn find(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) {\n\t\treturn find_if(all(a), f) - a.begin();\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) {\n\t\treturn accumulate(all(a), U());\n\t}\n\ttemplate<class T, class U>inline bool Includes(const T& a, const U& v) {\n\t\treturn find(all(a), v) != a.end();\n\t}\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(*v.begin()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) {\n\t\ta.erase(remove_if(all(a), f), a.end());\n\t}\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size);\n\t\tfor (size_t i = 0; i < size; ++i)res[i] = f(i);\n\t\treturn res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) {\n\t\treturn vector<vector<T>>(h, vector<T>(w, v));\n\t}\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(T& v, F&& f) {\n\t\tfor (auto& i : v)f(i);\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, F&& f) {\n\t\tfor (const auto& i : v)f(i);\n\t}\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res;\n\t\tfor (const auto& e : v)if (f(e))res.push_back(e);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, F&& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res;\n\t\tfor (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i);\n\t\treturn res;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline auto Indexed(const T& v) {\n\t\tvector<pair<U, int>> res(v.size());\n\t\tfor (int i = 0; i < (int)v.size(); ++i)res[i] = make_pair(static_cast<U>(v[i]), i);\n\t\treturn res;\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i)res += s;\n\t\treturn res;\n\t}\n\ttemplate<class T>inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2)); return v;\n\t}\n\ttemplate<class T>inline T Ceil(T n, T id) {\n\t\treturn (n + id - 1) / id;\n\t}\n\ttemplate<class T>inline T Ceil2(T n, T id) {\n\t\treturn Ceil(n, id) * id;\n\t}\n\ttemplate<class T>inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate<class T>inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate<class T>inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\tinline int pop_count(int n) {\n\t\treturn bitset<32>(n).count();\n\t}\n\tinline int pop_count(ll n) {\n\t\treturn bitset<64>(n).count();\n\t}\n\ttemplate<class T>inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) { a = b; return true; } return false;\n\t}\n\ttemplate<class T>inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) { a = b; return true; } return false;\n\t}\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate<class T>inline bool isSquere(T n) {\n\t\tT s = sqrt(n); return s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate<class T = ll>inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate<class T>inline T Gcd(T n, T id) {\n\t\treturn id ? Gcd(id, n % id) : n;\n\t}\n\ttemplate<class T>inline T Lcm(T n, T id) {\n\t\treturn n / Gcd(n, id) * id;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r;\n\t}\n\ttemplate<class T>inline T Powmod(T a, T n, T id = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % id, n--; else a = a * a % id, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint n = in;\n\tVVI g(n);\n\trep(i, n - 1) {\n\t\tint x = in--, y = in--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tauto rec = [&](auto&& f, int v, int p) {\n\t\tint size = g[v].size() - (p != -1);\n\t\tif (size == 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tint res = 0;\n\t\t\tfor (auto e : g[v])if (e != p) {\n\t\t\t\tres ^= f(f, e, v) + 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\n\tint ans = rec(rec, 0, -1);\n\tout.set(\"Alice\", \"Bob\")(ans != 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint N, par[101010], lv[101010], xo;\nvector<int> con[101010];\n\nvoid dfs(int ix){\n\tint jcn=0;\n\tfor(auto e : con[ix]){\n\t\tif(par[ix] == e) continue;\n\t\tjcn++; par[e]=ix, lv[e]=lv[ix]+1;\n\t\tdfs(e);\n\t}\n\tif(jcn%2 == 0) xo^=lv[ix];\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i=0; i<N-1; i++){\n\t\tint s, e;\n\t\tscanf(\"%d%d\", &s, &e);\n\t\tcon[s].push_back(e), con[e].push_back(s);\n\t}\n\tdfs(1);\n\tputs(xo ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst int INF=1e9;\nconst long long LINF=1e18;\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nstd::vector<int> edge[100005];\nint f(int pa,int idx){\n  int res=0;\n  for(int p:edge[idx]){\n    if(p==pa)continue;\n    res^=f(idx,p);\n  }\n  return res+1;\n}\n//main\nsigned main(){\n  int N;cin>>N;\n  for(int i=1;i<N;i++){\n    int a,b;cin>>a>>b;a--;b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  if(f(-1,0)==1)fin(\"Bob\");\n  fin(\"Alice\");\n}\n\n\n/*\n解説AC\n根付き木にするとNimっぽいってところまでは考えたけど部分根付き木のアイデアがなかったね\n根付き木->部分根付き木までをセットで知識に入れとく\n証明としては普通のNimとそんなにかわらないのかな、各それに対して同じように対応されたら無理なので\nアイデアさえ思いつければいいのかねぇ\n実装上手く描けて嬉しい\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mxn 100005\nusing namespace std;\nvector<int>adj[mxn];\nint dfs(int x, int p)\n{\n    int xr= 0;\n    for(int i=0; i<adj[x].size(); i++)\n    {\n        int y= adj[x][i];\n        if(y!=p)xr^= (1+dfs(y, x));\n    }\n    return xr;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1; i<n; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    if(dfs(1, 1))puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"-O3\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define NumberOfOnes __builtin_popcount\n#define LSOne(S) (S & (-S))\n#define ll long long\n#define two pair<int,int>\n#define twoll pair<ll,ll>\n#define four pair<two,two>\n#define pb push_back\n#define eb emplace_back\n#define mk make_pair\n#define y1 y1922\n#define INF 1000000000000000000\n#define P 1000000007\n#define lmax 1000000000\n#define nn 1000003\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\n#define f first\n#define s second\n#define vi vector<int>\n#define vll vector<ll>\n#define vtwo vector<two>\n#define ALL(container) (container).begin(), (container).end()\n#define sz(container) (int)(container.size())\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define mid(a,b) (a+b>>1)\n#define minN 0\n#define maxN 10000000\n#define na(x) ((x)<P?(x):(x)-P)\n#define ab(a) (-(a)<(a)?(a):-(a))\n#define FAST std::ios::sync_with_stdio(false)\n#define xRand mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define rnd rng\n#define IT iterator\ntypedef\ntree<\n  int,// aq pair<int,int> shegidzlia\n  null_type,\n  less/*_equal*/<int>,// aqac\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n// '_equal' mashin ginda roca multiset gchirdeba\ntemplate<class key, class value,class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\nordered_map<int, int> my_map;\ninline int rin(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\ninline int bin(){\n\tint x=0;char ch=getchar();\n\twhile (ch<'0'||ch>'9') ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,ans,a,b,w[100004];\nvector<int>v[100004];\nvoid go(int sad,int saidan){\n\tw[sad]=0;\n\tfor(auto i:v[sad]){\n\t\tif(i==saidan) continue;\n\t\tgo(i,sad);\n\t\tw[sad]^=w[i]+1;\n\t}\n}\nint main(){FAST;xRand;\ncin>>n;\nfor(int i=1;i<n;i++){\n\tcin>>a>>b;\n\tv[a].pb(b);\n\tv[b].pb(a);\n\t\n}\ngo(1,-1);\nif(w[1]==0){\n\tcout<<\"Bob\"<<endl;\n}else{\n\tcout<<\"Alice\"<<endl;\n}\n}\n/*\n\n                   *         *\n                  * *       * *\n                 *   *     *   *\n                *     *   *     *\n                 *   *   * *   *\n                  *   *   *   *\n                   *   * *   *\n                     *  *   *\n\t\t\t\t\t   *  *\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define files(name) fin(name\".in\"); fout(name\".out\")\n#define endl \"\\n\"\n#define fi(st,n) for (int i = (st); i <= (int)(n); ++i)\n#define fj(st,n) for (int j = (st); j <= (int)(n); ++j)\n#define fk(st,n) for (int k = (st); k <= (int)(n); ++k)\n#define fq(st,n) for (int q = (st); q <= (int)(n); ++q)\n#define fw(st,n) for (int w = (st); w <= (int)(n); ++w)\n#define ff(i, st, n) for (int (i) = (st); (i) <= (int)(n); ++(i))\n#define ei(st,n) for (int i = (st); i >= (int)(n); --i)\n#define ej(st,n) for (int j = (st); j >= (int)(n); --j)\n#define ek(st,n) for (int k = (st); k >= (int)(n); --k)\n#define ef(i, st, n) for (int (i) = (st); (i) >= (int)(n); --(i))\n#define ri(st,n) for (int i = (st); i < (int)(n); ++i)\n#define rj(st,n) for (int j = (st); j < (int)(n); ++j)\n#define rk(st,n) for (int k = (st); k < (int)(n); ++k)\n#define rq(st,n) for (int q = (st); q < (int)(n); ++q)\n#define rf(i, st, n) for (int (i) = (st); (i) < (int)(n); ++(i))\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define y1 dsklmlvmd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double dbl;\ntypedef long double ldbl;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst dbl eps = (dbl) 1e-8;\nconst int mod = (int) 1e9 + 7;\nconst int maxn = (int) 1e5 + 5;\n//const dbl M_PI = (dbl)2 * (dbl)acos(0);\n\n//cout<<fixed<<setprecision(10);\n//srand(time(0));\n\nint n, d[maxn];\nvector <int> a[maxn];\n\nvoid dfs(int v, int pr)\n{\n\td[v] = 0;\n\tri(0, a[v].size())\n\t{\n\t\tif (a[v][i] == pr)\n\t\t\tcontinue;\n\t\tdfs(a[v][i], v);\n\t\td[v] = d[v] ^ (d[a[v][i]] + 1);\n\t}\n\treturn;\n}\n\nint main()\n{\n//    fin(\"t.in\");\n    sync;\n    cin >> n;\n    fi(1, n - 1)\n    {\n    \tint x, y;\n    \tcin >> x >> y;\n    \ta[x].pb(y);\n    \ta[y].pb(x);\n    }\n    dfs(1, 0);\n    if (d[1])\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v) {\n  int sz = v.size();\n  for (int i = 0; i < sz; i++) {\n    cout << v[i] << \" \\n\"[i == sz - 1];\n  }\n}\n\nusing Graph = vector<vector<int>>;\nconst int MAX_N = 100010;\nGraph g(MAX_N);\n\nint dfs(int cur, int pre) {\n  if ((int)g[cur].size() == 1) {\n    if (cur == 0) return 1;\n    return 0;\n  }\n  int ch = g[cur].size();\n  if (cur != 0) ch--;\n  int ok = 0;\n  for (auto nxt : g[cur]) {\n    if (nxt == pre) continue;\n    ok ^= dfs(nxt, cur);\n  }\n  if (ch == 1) return ok + 1;\n  return ok;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\n#define ll long long\nauto start_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n\n/*@formatter:off*/\n//[-n, n)にアクセスできる\n//また、外部関数resizeに渡せる\n\n//sizeは[-n, n)でnを返す\ntemplate<class T> class mvec {    vector<T> v;    int n;public:    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, T val) : n(n), v(n * 2, val) {}    auto &operator[](int i) { return v[i + n]; }    auto size() { return n; }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\n//[]でboolは参照を返さないため特殊化が必要\ntemplate<> struct mvec<bool> {    vector<bool> v;    int n;    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, bool val) : n(n), v(n * 2, val) {}    auto operator[](int i) { return v[i + n]; }    auto size() { return v.size(); }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\ntemplate<class T>ostream &operator<<(ostream &os, mvec<T>& a) {    int spa = 3;    for(auto&&v : a){        spa = max(spa,(int)(to_string(v).size())+1);    }    int n = (int)a.size();    os<<endl;    for (int i = -n; i < n; i++){        int need = spa - ((int)to_string(i).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(a[i]).size()));        }        while(need--){            os<<\" \";        }        os<<i;    }    os<<endl;    int i=-n;    for(auto&&v : a){        int need = spa - ((int)to_string(v).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(i).size()));        }        while(need--){            os<<\" \";        }        os<<v;        i++;    }    return os;}\n#define mv mvec\n#define MV mvec\nusing mvi = mvec<ll>;\nusing mvb = mvec<bool>;\nusing mvs = mvec<string>;\nusing mvd = mvec<double>;\nusing mvc = mvec<char>;\n\n#define o_mvvt(o1, o2, o3, o4, name, ...) name\n#define mvvt0(t) mvec<mvec<t>>\n#define mvvt1(t,a) mvec<mvec<t>>a\n#define mvvt2(t,a, b) mvec<mvec<t>>a(b)\n#define mvvt3(t,a, b, c) mvec<mvec<t>> a(b,mvec<t>(c))\n#define mvvt4(t,a, b, c, d) mvec<mvec<t>> a(b,mvec<t>(c,d))\n\n#define mvvi(...) o_mvvt(__VA_ARGS__,mvvt4,mvvt3,mvvt2 ,mvvt1,mvvt0)(ll,__VA_ARGS__)\ntemplate<typename T> mvec<T> make_mv(size_t a) { return mvec<T>(a); }\ntemplate<typename T, typename... Ts> auto make_mv(size_t a, Ts... ts) {return mvec<decltype(make_mv<T>(ts...))>(a, make_mv<T>(ts...));}\n#define mvni(name, ...) auto name = make_mv<ll>(__VA_ARGS__)\n\n\n#ifdef _DEBUG\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {cerr << a.size() << \" \";return deb_v(a.at(0), v + 1);}\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }if ((int) a.size() > 15) { cerr << \"...\"; }cerr << endl;}\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }return this->at(n);}\n};\n#define vector debtor\n#endif\n\n#ifdef _DEBUG\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T,class U> struct my_unordered_map{    unordered_map<T,U> m;    my_unordered_map(){};    auto begin(){        return m.begin();    }    auto end(){return m.end();}    auto cbegin(){return m.cbegin();}    auto cend(){return m.cend();}    template<class V>auto erase(V v){return m.erase(v);}    void clear(){m.clear();}    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V>auto find(V v){return m.find(v);}    template<class V>auto & operator [](V n) { return m[n] ;}};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapip unordered_map<ll,P>\n\n#else\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n\n#endif\nstruct xorshift {    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }    size_t operator()(std::pair<ll, ll> x) const {        ll v=((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }};\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\nF mf(ll a, ll b, ll c, ll d) {return F(a, b, c, d);}\n\n\n\n//@マクロ省略系 型,構造\n#define double long double\n#define pow powl\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing mvp = mvec<P>;\nusing mvt = mvec<T>;\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](auto& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t,a) vector<vector<t>>a\n#define vvt2(t,a, b) vector<vector<t>>a(b)\n#define vvt3(t,a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t,a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type,...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type,name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_,v1_,v2_,v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n#define o_rep(o1, o2, o3, o4, name, ...) name\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss1(i, I) for (int i = 0; i < I; i++)\n#define repss2(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss3(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss4(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss5(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n#define o_repss(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n//i,j,k...をnまで見る\n#define reps1(i, n) repss1(i, n)\n#define reps2(i, j, n) repss2(i, j, n, n)\n#define reps3(i, j, k, n) repss3(i, j, k, n, n, n)\n#define reps4(i, j, k, l, n) repss4(i, j, k, l, n, n, n, n)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n\ntemplate<class T>void nex_repv2(int&i,int&j,int&I, int&J,vector<vector<T>>&s){    while(1){        j++;        if(j >= J){            j=0;            i++;            if(i < I){                J = (int)s[i].size();            }        }        if(i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n#define repv_1(i,a) repss1(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_2(i, j, a) for (int I = (int)a.size(), J = (int)a[0].size(), i = 0, j = 0; i < I; nex_repv2(i,j,I,J,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_3(i, j, k, a) for (int I = (int)a.size(), J = (int)a[0].size(), K =(int)a[0][0].size(), i = 0, j = 0, k=0; i < I; nex_repv3(i,j,k,I,J,K,a))\n#define repv_4(i, j, k, l, a) repss4(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_5(i, j, k, l, m, a) repss5(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n#define o_repv(o1, o2, o3, o4, o5, o6, name, ...) name\n\ntemplate<typename T>struct has_rbegin_rend {private:template<typename U>static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value;};template<typename T>constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;template<typename Iterator>class Range {public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept {return m_begin;}Iterator end() const noexcept {return m_end;}private:const Iterator m_begin;const Iterator m_end;};template<typename Iterator>static inline Range<Iterator>makeRange(Iterator &&begin, Iterator &&end) noexcept {return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)};}template<typename T>static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept {return makeRange(std::rbegin(iniList), std::rend(iniList));}template<typename T,typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr>static inline decltype(auto)makeReversedRange(T &&c) noexcept {return makeRange(std::rbegin(c), std::rend(c));}/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T,typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr>static inline void makeReversedRange(T &&) noexcept {static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\");}\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define o_form(a, b, c, d, e, name, ...) name\n\ntemplate<class U> vector<U>to1d(vector<U>& a){return a;}\ntemplate<class U> vector<U>to1d(V<V<U>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)res.push_back(a2);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<U>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) res.push_back(a3);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<V<U>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)res.push_back(a4);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<V<V<U>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)res.push_back(a5);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<V<V<V<U>>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)for(auto&& a6 : a5)res.push_back(a6);return res;}\n\n#define fora_init_2(a, A) ;\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define o_fora_init(a, b, c, d, e, f, g, h, name, ...) name\n#define fora_init(...) o_fora_init(__VA_ARGS__, fora_init_8, a, fora_init_6, a, fora_init_4, a, fora_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define o_forr_init(a, b, c, d, e, f, g, h, name, ...) name\n#define forr_init(...) o_forr_init(__VA_ARGS__, forr_init_8, a, forr_init_6, a, forr_init_4, a, forr_init_2)(__VA_ARGS__)\n\n\n#define forp_init(k, v, ...) auto &&k = (*forp_it).fi;auto &&v = (*forp_it).se;\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,reps1,)(__VA_ARGS__)\n#define repss(...) o_repss(__VA_ARGS__, repss5, a, repss4, a, repss3, a, repss2, a, repss1) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) o_repv(__VA_ARGS__,repv_5,repv_4,repv_3,repv_2,repv_1,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define o_fora(a, b, c, d, e, f, g, h, name, ...) name\n#define fora(...) o_fora(__VA_ARGS__, fora_8, a, fora_6, a, fora_4, a, fora_2)(__VA_ARGS__)\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define o_forr(a, b, c, d, e, f, g, h, name, ...) name\n#define forr(...) o_forr(__VA_ARGS__, forr_8, a, forr_6, a, forr_4, a, forr_2)(__VA_ARGS__)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#define forv(a, b) for(auto a : to1d(b))\n\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n//                  0の左と nの右\n#define forlr(v, d) for (auto prev = -1_, next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?-1_:d[index_+1]))\n\n\n#define form(...) o_form(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forp(k, v, st) for (auto &&forp_it = st.begin(); forp_it != st.end(); ++forp_it)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:on*/\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {\n    os << p.fi << \" \" << p.se;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {\n    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {\n    for (ll i = 0; i < vec.size(); ++i) {\n        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {\n    for (auto &&v:m) os << v;\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {\n    fora(v, a)os << v << \" \";\n    return os;\n}\nostream &operator<<(ostream &os, vector<vector<char>> &vec) {\n    rep(h, sz(vec)) {\n        rep(w, sz(vec[0])) { os << vec[h][w]; }\n        os << endl;\n    }\n    return os;\n}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\n/*@formatter:off*/\ntemplate<typename W, typename H> void resize(W &vec, const H head) { vec.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\n//template<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }\n//template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n//削除された要素の数を返す\ntemplate<typename T, typename F> int erase_if2(vector<T> &v, F f) {vector<T> nv;int cou = 0;rep(i, sz(v)) {if (f(v[i])) {cou++;} else {nv.push_back(v[i]);}}v = nv;return cou;}\ntemplate<typename T, typename F> int erase_if2(vector<vector<T>> &v, F f) {int cou = 0;rep(i, sz(v)) {cou += erase_if2(v[i], f);}return cou;}\n#define all_of(a,right) all_of2(a,lam(right))\n#define all_of_f(a,f) all_of2(a,f)\n#define any_of(a,right) any_of2(a,lam(right))\n#define any_of_f(a,f) any_of2(a,f)\n#define none_of(a,right) none_of2(a,lam(right))\n#define none_of_f(a,f) none_of2(a,f)\n#define find_if(a,right) find_if2(a,lam(right))\n#define find_if_f(a,f) find_if2(a,f)\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define rfind_if_f(a,f) rfind_if2(a,f)\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define contains_if_f(a,f) contains_if2(a,f)\n#define count_if(a, right) count_if2(a,lam(right))\n#define count_if_f(a, f) count_if2(a,f)\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_f(a, f) do{fora(v,a){f(v);}}while(0)\n#define erase_if(a,right) erase_if2(a,lam(right))\n#define erase_if_f(a,f) erase_if2(a,f)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,ll len,const T v) {rep(i, len)xx[i]=v;}\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<class T,class U>void fill(vector<T> &a,vi& ind,U val) {fora(v,ind)a[v]=val;}\ntemplate<class W,class T>void fill(mvec<W> &xx,const T v){\n    fora(x,xx)fill(x,v);\n}\n\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, o5, o6, name, ...) name\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) o_din(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dins(o1, o2, o3, o4, o5, o6, name, ...) name\n#define dins1(a) str a;cin>>a\n#define dins2(a, b) str a,b;cin>>a>> b\n#define dins3(a, b, c) str a,b,c;cin>>a>>b>>c\n#define dins4(a, b, c, d) str a,b,c,d;cin>>a>>b>>c>>d\n#define dins5(a, b, c, d, e) str a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define dins6(a, b, c, d, e, f) str a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define dins(...) o_dins(__VA_ARGS__,dins6,dins5,dins4,dins3,dins2 ,dins1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) {    cerr << head  << endl;}\nvoid err() {    cerr << \"\"  << endl;}\n/*@formatter:on*/\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {\n    stringstream ss;\n    if (W == inf)W = min(sz(a), 12ll);\n    if (sz(a) == 0)return ss.str();\n    rep(i, W) {\n        ss << a[i];\n        if (typeid(a[i]) == typeid(P)) {\n            ss << endl;\n        } else {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n/*@formatter:off*/\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}return ss.str();}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }       return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) {        b[i] = a[i];    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) {        rep(j, M) {            b[i][j] = a[i][j];        }    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) {        rep(j, M) {            rep(k, O) {                b[i][j][k] = a[i][j][k];            }        }    }    return out_m2(b);}\nstring out_m2(int a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<T> > &a, ll H = inf, ll W = inf, int key = inf) {\n    H = min({H, sz(a), 6ll});\n    W = min({W, sz(a[0]), 6ll});\n    stringstream ss;\n    ss << endl;\n//    if (key == inf)ss << \" *|\"; else ss << \" \" << key << \"|\";\n    if (key == inf)ss << \" *|\";\n    else {\n        ss << std::right << std::setw(2) << key;\n        ss << \"|\";\n    }\n    rep(w, -W, W)ss << std::right << std::setw(4) << w;\n    ss << \"\" << endl;\n    rep(w, W * 8 + 3)ss << \"_\";\n    ss << \"\" << endl;\n    rep(h, -H, H) {\n        ss << std::right << std::setw(2) << h << \"|\";\n        int NW = min(sz(a[h]), 6ll);\n        rep(w, -NW, NW) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }\n        ss << \"\" << endl;\n    }\n    return ss.str();\n}/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<mvec<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {\n    stringstream ss;\n    if (H == inf)H = 6;\n    H = min(H, sz(a));\n    rep(i, -H, H) {\n        ss << endl;\n        ss << out_m2(a[i], W, U, i);\n    }\n    return ss.str();\n}\n\n/*@formatter:off*/\ntemplate<class T> string out_m2(T &a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {\n    stringstream ss;\n    if (W == inf)W = min(sz(a), 12ll);\n    if (sz(a) == 0)return ss.str();\n    rep(i, W) { ss << a[i] << \" \"; }\n    ss << \"\" << endl;\n    return ss.str();\n}\n/*@formatter:off*/\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}ss << endl;return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> string out_m(T &a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W=inf) {cout << out_m(a,W) << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf,int key=-1) {    cout << out_m(a,H,W,key) << endl;}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf,ll U = linf) {cout << out_m(a,H,W,U)<< endl;}\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {\n    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }\n    cout << \"\" << endl;\n}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n#endif\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>>&a){    rep(i,sz(a)){        rep(j,sz(a[i])){            cout<<a[i][j];        }        cout<<endl;    }}\n//int型をbit表記で出力\nvoid outb(int a){cout << bitset<20>(a) << endl;}\ntemplate<class T> void na(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\n#define dnad(a, n) vi a(n); rep(dnai,n) cin >> a[dnai],a[dnai]--;\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i];\n#define dna4d(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i],--a[dna4i] ,-- b[dna4i],-- c[dna4i],--d[dna4i];\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\n//graphでredefineしているため、書き換えたら向こうも書き換える\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing bll =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void){static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;unsigned long t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T>vector<pair<T,int>> run_length(vector<T> &a) {vector<pair<T,int>> ret;ret.eb(a[0], 1);rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {\n    bool han = true;\n    if (ok < ng)\n        while (ng - ok > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        while (ok - ng > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\ntemplate<class F> dou mgrd(dou ok, dou ng, F f) {\n    bool han = true;\n    if (ok < ng)\n        rep(i,100) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            if(i<30)deb(mid,han);\n        }\n    else\n        rep(i,100) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            if(i<30)deb(mid,han);\n        }\n    return ok;\n}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; }    else if (sz(a) > sz(b)) { return a; }    else if (a < b)return b;    else return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) > sz(b)) { return b; }    else if (sz(a) < sz(b)) { return a; }    else if (a > b)return b;    else return a;}\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n//stringも書く\nint find(string& s, const string key){    int klen = sz(key);    rep(i,sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, int l, const string key){    int klen = sz(key);    rep(i, l, sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, const char key){    rep(i,sz(s)){        if(s[i]==key)return i;    }    return -1;}\nint find(string& s, int l, const char key){    rep(i, l, sz(s)){        if(s[i]==key)return i;    }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) {        if (ma < v)ma = v;    }    vi res(ma + 1);    fora(v, a) {        res[v]++;    }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nvi count(str &a) {    vi cou(26);    char c = 'a';    if ('A' <= a[0] && a[0] <= 'Z')c = 'A';    rep(i, sz(a))++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nll get(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//0は0桁\nll keta(ll v) {    if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}}    else {        if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }}        else {            if (v < p10[15]) {                if (v < p10[14]) return 14;                else return 15;            } else {                if (v < p10[17]) {                    if (v < p10[16]) return 16;                    else return 17;                } else {                    if (v < p10[18])return 18;                    else return 19;                }            }        }    }}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T& a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T& a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class T>  T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T>  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T>  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T>  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s, ll t) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\ntemplate<class T> T sum(vector<T> &v, ll t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<T> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int t = inf) { return sum(v, 0, t); }\n\ntemplate<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvi v_i(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) {        ret[a[i]] = i;    }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int>&q) { q = priority_queue<int>();}\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\n//template<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\n//template<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin(){return rui.begin();}\n    auto end(){return rui.end();}\n};\ntemplate<class T> struct ruimax {template<typename Monoid>struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN(T), -1);        Monoid f(Monoid a, Monoid b) {            return max(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) {                index = i;            }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {        return operator()(0, r);    }\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\ntemplate<class T> struct ruimin {template<typename Monoid>    struct SegmentTree {  /*pairで処理*/         int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MAX(T), -1);        Monoid f(Monoid a, Monoid b) {            return min(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) {                index = i;            }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {return operator()(0, r);}\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\n\n\ntemplate<class T>ostream &operator<<(ostream &os, ruiC<T> a) {fora(v,a.rui)os<<v<<\" \";return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic() {return ruiC<T>();}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) {        rep(i, sz(a)) {            res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1);        }    }    return res;}\nvector<ruiC<int>> ruibc(vi &a) {    vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) {            res[k][i] = (a[i] >> k) & 1;        }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\n\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {vector<T> ret(sz(v));rep(h,sz(ret)){ret[h] = v[h][w];}rep(i, sz(ret) - 1){ret[i + 1] += ret[i];}return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {vector<T> ret(sz(v) + 1);rep(h, sz(v)) { ret[h + 1] = v[h][w]; }rep(i, sz(v)) { ret[i + 1] += ret[i]; }return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {vector<T> ret = ruih(a, w);return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {    const vector<T> rui;    ruixC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T>  &a) {vi ret = ruix(a);return ruixC<ll>(ret);}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {rui.resize(n + 1);rer(i, n - 1) {rui[i] = rui[i + 1] + a[i];}}\n    /*[r l)*/\n    T operator()(int r, int l) {r++;l++;assert(l <= r && l >= 0 && r <= n);return rui[l] - rui[r];}\n    T operator()(int l) {return operator()(n - 1, l);}\n    T operator[](int i) {return operator()(i);}\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {fora(v, a.rui)os << v << \" \";return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {rv.resize(n + 1);rv[0] = 1;rep(i, n) { rv[i + 1] = a[i] * rv[i]; }}\n    ruimulC() : n(0) {rv.resize(n + 1);rv[0] = 1;}\n    void operator+=(T v) {rv.push_back(rv.back()*v);n++;}\n    T operator()(int l, int r) {assert(l <= r && 0 <= l && r <= n);return rv[r] / rv[l];}\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {vector<T> a; return ruimulC<T>(a); }\n/*@formatter:off*/\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(pair<T,U> &a, U v = 1) { a.first += v,a.second+=v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T,class U, class W> void dec(vector<T> &a,vector<U> &b, W v = 1) { for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v); }\ntemplate<class T,class U,class W> void dec(vector<T> &a,vector<U> &b,vector<W>&c ) { for (auto &u :a)dec(u, 1);for (auto &u :b)dec(u, 1);for (auto &u :c)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\n#define inside ins\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\n/*@formatter:on*/\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {\n    auto lim = milliseconds(time - 20);\n    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {\n        auto s = system_clock::now();\n        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;\n        ll nr = l + haba;\n        rep(i, k) {\n            ll ni = goldd_l(nl, nr, calc);\n            if (chmi(minv, calc(ni))) mini = ni;\n            nl = nr;\n            nr = nl + haba;\n        }\n        auto end = system_clock::now();\n        auto part = duration_cast<milliseconds>(end - s);\n        auto elapsed = duration_cast<milliseconds>(end - start_time);\n        if (elapsed + part * 2 >= lim) { break; }\n    }\n    return mini;\n}\n/*@formatter:off*/\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\nconstexpr bool bget(ll m, ll keta) {\n    #ifdef _DEBUG\n        assert(keta<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (m >> keta) & 1; }\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n    #ifdef _DEBUG\n        assert(n<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll biti(vi&a){    int m=0;    for(auto&& v:a) m|=bit(v);    return m;}\n//{1, 1, 0} -> 011\nll bitb(vi&a){    int m=0;    rep(i,sz(a)) if(a[i])m|=bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\nll lbiti(ll n) { return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n){return log2(hbit(n));}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n//masの立ってるindexを見る\n#define forbit(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {auto it = lower_bound(a.begin(), a.end(), v);if (it == a.end())return banpei; else return *it;}template<class T, class U, class W> T lowerBound(ruiC<T> &a, U v, W banpei) {return lowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T upperBound(vector<T>& a, U v, W banpei){    auto it = upper_bound(a.begin(),a.end(),v);    if(it==a.end())return banpei;    else return *it;}template<class T, class U, class W> T upperBound(ruiC<T> &a, U v, W banpei) {return upperBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rlowerBound(ruiC<T> &a, U v, W banpei) {return rlowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rupperBound(ruiC<T> &a, U v, W banpei) {return rupperBound(a.rui, v, banpei);}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class T> void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(ll t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\ntemplate<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs += to_string(rv);}template<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    lhs += to_string(rv);}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {auto bek = s;s = \"\";for (; num; num >>= 1) {if (num & 1) {s += bek;}bek += bek;}}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector <T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector <T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(const vector <T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, const vector <T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector <T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T,U> &b) {fora(bv,b){        a[bv.first] += bv.second;    }    return a;}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\nvi inds_(vi &a) {    int n = sz(a);    vb was(n);    vi res(n);    rep(i, n) {        assert(!was[a[i]]);        res[a[i]] = i;        was[a[i]] = true;    }    return res;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;//@formatter:on\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {\n    while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }\n    return i;\n}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define o_getid(a, b, name, ...) name\n#define getid(...) o_getid(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n#define shuffle(a) std::random_device seed_gen;std::mt19937 engine(seed_gen());std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n#undef getid\n/*@formatter:off*/\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0, f, t, c,wasp = (p != -1 && ve[gi].t == p) ? 1 : 0; (wasp = wasp ? 1 : (p != -1 && ve[gi].t == p) ? 1 : 0,gi + wasp < ve.size()) &&(tie(f, t, c) = wasp ?  make_tuple(ve[gi + 1].f, ve[gi + 1].t, ve[gi + 1].c) : make_tuple(ve[gi].f, ve[gi].t, ve[gi].c), true); ++gi)\n#define fore(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n\ntemplate<class T> struct edge {    int f, t;    T c;    edge(int f, int t, T c = 1) : f(f), t(t), c(c) {}    bool operator<(const edge &b) const { return c < b.c; }    bool operator>(const edge &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {os << e.f << \" \" << e.t << \" \" << e.c;return os;}\ntemplate<typename T> class graph {\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    explicit graph(int n) : n(n) { g.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {this->n = n;g.resize(n);}\n    int size() { return n; }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    explicit digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {debugline(\"digraph add\");deb(f, t, c);ole();}\n        g[f].emplace_back(f, t, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges() override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;    using graph<T>::n;    using graph<T>::edges;\n    explicit undigraph(int n) : graph<T>(n) {}\n    // f < t\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"undigraph add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n        edges.emplace_back(t, f, c);\n    }\n    void add(edge<T> &e) {        int f = e.f, t = e.t;        T c = e.c;        add(f, t, c);    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges () override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\n#define dijkstra_path dis_path\ntemplate<class T> vi dis_path(digraph<T> &g, vector<T> &dis, int s, int t, int init_value) {    assert(dis[t] != init_value);    auto rg = rev(g);    int now = t;    vi path;    path.push_back(now);    T cost = 0;    while (now != s) {        rep(gi, sz(rg[now])) {            int m = rg[now][gi].t;            if (dis[m] == init_value)continue;            if (dis[m] + rg[now][gi].c + cost == dis[t]) {                cost += rg[now][gi].c;                now = m;                break;            }        }        path.push_back(now);    }    rev(path);    return path;}\ntemplate<class T> vi dis_path(undigraph<T> &g, vector<T> &dis, int s, int t, int init_value) {    assert(dis[t] != init_value);    int now = t;    vi path;    path.push_back(now);    T cost = 0;    while (now != s) {        rep(gi, sz(g[now])) {            int m = g[now][gi].t;            if (dis[m] == init_value)continue;            if (dis[m] + g[now][gi].c + cost == dis[t]) {                cost += g[now][gi].c;                now = m;                break;            }        }        path.push_back(now);    }    rev(path);    return path;}\ntemplate<class T> vi dis_path(digraph<T> &g, vector<vector<T>> &dis, int s, int t, int init_value) { return dis_path(g, dis[s], s, t, init_value); }\ntemplate<class T> vi dis_path(undigraph<T> &g, vector<vector<T>> &dis, int s, int t, int init_value) { return dis_path(g, dis[s], s, t, init_value); }\n//O(N^2)\ntemplate<class T> vector<T> dijkstra_mitu(graph<T> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra_mitu\");        deb(s, g.n);        ole();    }    int n = g.n;    int initValue = MAX(int);    vector<T> dis(n, initValue);    dis[s] = 0;    vb used(n);    while (true) {        int v = -1;        rep(u, n) { if (!used[u] && (v == -1 || dis[u] < dis[v]))v = u; }        if (v == -1)break;        if (dis[v] == initValue)break;        used[v] = true;        rep(u, sz(g[v])) {            auto e = g[v][u];            dis[e.t] = min(dis[e.t], dis[v] + e.c);        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) { if (d == initValue) { d = init_value; }}    return dis;}\ntemplate<typename T> struct radixheap {    vector<pair<u64, T> > v[65];    u64 size, last;    radixheap() : size(0), last(0) {}    bool empty() const { return size == 0; }    int getbit(int a) { return a ? 64 - __builtin_clzll(a) : 0; }    void push(u64 key, const T &value) {        ++size;        v[getbit(key ^ last)].emplace_back(key, value);    }    pair<u64, T> pop() {        if (v[0].empty()) {            int idx = 1;            while (v[idx].empty()) ++idx;            last = min_element(begin(v[idx]), end(v[idx]))->first;            for (auto &p : v[idx]) v[getbit(p.first ^ last)].emplace_back(p);            v[idx].clear();        }        --size;        auto ret = v[0].back();        v[0].pop_back();        return ret;    }};\n/*radix_heap こっちの方が早い*/\n//O((N+M) log N)\nvi dijkstra(graph<int> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    /*O((N+M) log N) vs O(N^2)*/    if ((g.n + sz(g.edges)) * log2(N) > g.n * g.n) {        return dijkstra_mitu(g, s, init_value);    }    int initValue = MAX(int);    vi dis(g.n, initValue);    radixheap<int> q;    dis[s] = 0;    q.push(0, s);    while (!q.empty()) {        int nowc, i;        tie(nowc, i) = q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            int c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.push(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/   for (auto &&d :dis) if (d == initValue)d = init_value;    return dis;}\ntemplate<class T> vector<T> dijkstra_normal(graph<T> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    if ((g.n + sz(g.edges)) * 20 > g.n * g.n) {        return dijkstra_mitu(g, s, init_value);    }    T initValue = MAX(T);    vector<T> dis(g.n, initValue);    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;    dis[s] = 0;    q.emplace(0, s);    while (q.size()) {        T nowc = q.top().fi;        int i = q.top().se;        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.emplace(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) if (d == initValue)d = init_value;    return dis;}\ntemplate<class T> vector<T> dijkstra_01(graph<T> &g, int s, int init_value) {    int N = g.n;    vi dis(N, linf);    dis[s] = 0;    deque<int> q;    q.push_back(s);    vb was(N);    while (!q.empty()) {        int f = q.front();        q.pop_front();        if (was[f])continue;        was[f] = true;        fora(e, g[f]) {            if (dis[e.t] > dis[f] + e.c) {                if (e.c) {                    dis[e.t] = dis[f] + 1;                    q.push_back(e.t);                }                else {                    dis[e.t] = dis[f];                    q.push_front(e.t);                }            }        }    }    rep(i, N)if(dis[i]==linf)dis[i]=init_value;    return dis;}\n//dijkstra_cou<mint> : 数える型で書く return vp(dis,cou)\ntemplate<class COU,class T=int> auto dijkstra_cou(const graph<T> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    err(\"count by type COU \");    err(\"int or mint\");    T initValue = MAX(T);    vector<T> dis(g.n, initValue);    vector<COU> cou(g.n);    cou[s] = 1;    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;    dis[s] = 0;    q.emplace(0, s);    while (q.size()) {        T nowc = q.top().fi;        int i = q.top().se;        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                cou[to] = cou[e.f];                q.emplace(dis[to], to);            }            else if (dis[to] == c) { cou[to] += cou[e.f]; }        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) if (d == initValue)d = init_value;    return vtop(dis, cou);}\n//密グラフの時、warshallに投げる\ntemplate<class T> vector<vector<T>> dijkstra_all(const graph<T> &g, int init_value) {int n = g.n;assert(n < 1e4);if (n * n < (n + sz(g.edges)) * 14) {        /*O(N^3) vs O(N (N+M)log N)*/        return warshall(g, init_value); }vector<vector<T>> dis(n);rep(i, n) { dis[i] = dijkstra(g, i, init_value); }return dis;}\n//コストを無限に減らせる := -linf\n//たどり着けない := linf\ntemplate<class T> vector<T> bell(graph<T> &g, int s) {    if (g.n >= 1e4) {        cout << \"bell size too big\" << endl;        exit(0);    }    vector<T> res(g.n, linf);    res[s] = 0;    vb can(g.n);    /*頂点から行けない頂点を持つ、辺を消しておく */    fix([&](auto ds, int p, int i) -> void {        if (can[i])return;        can[i] = true;        forg(gi, g[i])if (t != p)ds(i, t);    })(-1, 0);    vector<edge<T>> es;    fora(e, g.edges) { if (can[e.f])es += e; }    rep(i, g.n) {        bool upd = false;        fora(e, es) {            if (res[e.f] != linf && res[e.t] > res[e.f] + e.c) {                upd = true;                res[e.t] = res[e.f] + e.c;            }        }        if (!upd)break;    }    rep(i, g.n * 2) {        bool upd = 0;        fora(e, g.edges) {            if (res[e.f] != linf && res[e.t] != -linf && res[e.t] > res[e.f] + e.c) {                upd = 1;                res[e.t] = -linf;            }        }        if (!upd)break;    }    return res;}\n//コストを無限に増やせる := linf\n//たどり着けない := -linf\ntemplate<class T> vector<T> bell_far(graph<T> &g, int s) {    if (g.n >= 1e4) {        cout << \"bell_far size too big\" << endl;        exit(0);    }    vector<T> res(g.n, linf);    res[s] = 0;    vb can(g.n);    /*頂点から行けない頂点を持つ、辺を消しておく*/    fix([&](auto ds, int p, int i) -> void {        if (can[i])return;        can[i] = true;        forg(gi, g[i])if (t != p)ds(i, t);    })(-1, 0);    vector<edge<T>> es;    fora(e, g.edges) { if (can[e.f])es += e; }    rep(i, g.n) {        bool upd = false;        fora(e, es) {            if (res[e.f] != linf && res[e.t] > res[e.f] - e.c) {/*-c*/                upd = true;                res[e.t] = res[e.f] - e.c;/*-c*/            }        }        if (!upd)break;    }    rep(i, g.n * 2) {        bool upd = 0;        fora(e, g.edges) {            if (res[e.f] != linf && res[e.t] != -linf && res[e.t] > res[e.f] - e.c) {/*-c*/                upd = 1;                res[e.t] = -linf;            }        }        if (!upd)break;    }    rep(i, g.n)res[i] *= -1;    return res;}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int init_value) {    int n = g.n;    assert(n < 1e4);    vector<vector<T> > dis(n, vector<T>(n, linf));    rep(i, n)fora(e, g.g[i]) {            if (dis[e.f][e.t] > e.c) {                dis[e.f][e.t] = e.c;            }        }    rep(i, n)dis[i][i] = 0;    rep(k, n)        rep(i, n)            rep(j, n) {                if (dis[i][j] > dis[i][k] + dis[k][j]) {                    dis[i][j] = dis[i][k] + dis[k][j];                }            }    rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = init_value;    return dis;}\ntemplate<class T> class MinOp { public: T operator()(T a, T b) { return min(a, b); }};\ntemplate<typename OpFunc> struct SparseTable {    OpFunc op;    signed size;    vector<signed> lg;    vector<vector<pair<signed, signed>>> table;    void init(const vector<pair<signed, signed>> &array, OpFunc opfunc) {        signed n = array.size();        op = opfunc;        lg.assign(n + 1, 0);        for (signed i = 1; i <= n; i++) { lg[i] = 31 - __builtin_clz(i); }        table.assign(lg[n] + 1, array);        for (signed i = 1; i <= lg[n]; i++) { for (signed j = 0; j < n; j++) { if (j + (1 << (i - 1)) < n) { table[i][j] = op(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]); } else { table[i][j] = table[i - 1][j]; }}}    }    pair<signed, signed> query(signed l, signed r) {        assert(l < r);        return op(table[lg[r - l]][l], table[lg[r - l]][r - (1 << lg[r - l])]);    }};\nstruct PMORMQ {    vector<signed> a;    SparseTable<MinOp<pair<signed, signed> > > sparse_table;    vector<vector<vector<signed> > > lookup_table;    vector<signed> block_type;    signed block_size, n_block;    void init(const vector<signed> &array) {        a = array;        signed n = a.size();        block_size = std::max(1, (31 - __builtin_clz(n)) / 2);        while (n % block_size != 0) {            a.push_back(a.back() + 1);            n++;        }        n_block = n / block_size;        vector<pair<signed, signed> > b(n_block, make_pair(INT_MAX, INT_MAX));        for (signed i = 0; i < n; i++) { b[i / block_size] = min(b[i / block_size], make_pair(a[i], i)); }        sparse_table.init(b, MinOp<pair<signed, signed> >());        block_type.assign(n_block, 0);        for (signed i = 0; i < n_block; i++) {            signed cur = 0;            for (signed j = 0; j < block_size - 1; j++) {                signed ind = i * block_size + j;                if (a[ind] < a[ind + 1]) { cur |= 1 << j; }            }            block_type[i] = cur;        }        lookup_table.assign(1 << (block_size - 1), vector<vector<signed> >(block_size, vector<signed>(block_size + 1)));        for (signed i = 0; i < (1 << (block_size - 1)); i++) {            for (signed j = 0; j < block_size; j++) {                signed res = 0;                signed cur = 0;                signed pos = j;                for (signed k = j + 1; k <= block_size; k++) {                    lookup_table[i][j][k] = pos;                    if (i & (1 << (k - 1))) { cur++; } else { cur--; }                    if (res > cur) {                        pos = k;                        res = cur;                    }                }            }        }    }    signed query(signed l, signed r) {        assert(l < r);        signed lb = l / block_size;        signed rb = r / block_size;        if (lb == rb) { return lb * block_size + lookup_table[block_type[lb]][l % block_size][r % block_size]; }        signed pl = lb * block_size + lookup_table[block_type[lb]][l % block_size][block_size];        signed pr = rb * block_size + lookup_table[block_type[rb]][0][r % block_size];        signed pos = pl;        if (r % block_size > 0 && a[pl] > a[pr]) { pos = pr; }        if (lb + 1 == rb) { return pos; }        signed spv = sparse_table.query(lb + 1, rb).second;        if (a[pos] > a[spv]) { return spv; }        return pos;    }};\n\ntemplate<class T=int> class tree : public undigraph<T> {\n    PMORMQ rmq;    int cnt;    vector<signed> id, in;    bool never = true;    bool never_hld = true;\n    void dfs(int x, int p, int d, int dis = 0) {        id[cnt] = x;        par_[x] = p;        rmq_dep.push_back(d);        disv[x] = dis;        in[x] = cnt++;        forg(gi, g[x]) {            if (t == p) { continue; }            dfs(t, x, d + 1, dis + c);            id[cnt] = x;            rmq_dep.push_back(d);            cnt++;        }    }    void precalc() {        never = false;        cnt = 0;        rmq_dep.clear();        disv.assign(n, 0);        in.assign(n, -1);        id.assign(2 * n - 1, -1);        par_.assign(n, -1);        dfs(root, -1, 0);        rmq.init(rmq_dep);\n#ifdef _DEBUG\n        if(n>=100)return;cerr << \"---tree---\" << endl;        rep(i, n) {            if (!(i == root || sz(g[i]) > 1))continue;            cerr << i << \" -> \";            vi ts;            forg(gi, g[i]) { if (t != par_[i])ts.push_back(t); }            rep(i, sz(ts) - 1)cerr << ts[i] << \", \";            if(sz(ts))cerr << ts.back() << endl;        }        cerr << endl;\n#endif\n    }    int pos;    void hld_build() {        never_hld = false;        if (never)precalc();        g.resize(n);        vid.resize(n, -1);        head.resize(n);        heavy.resize(n, -1);        depth.resize(n);        inv.resize(n);        subl.resize(n);        subr.resize(n);        dfs(root, -1);        t = 0;        dfs_hld(root);\n#ifdef _DEBUG\n        if (n >= 100)return;        cerr << \"---hld_index---\" << endl;        vi inds;        rep(i, n) if (sz(g[i]))inds.push_back(i);        rep(i, sz(inds)) {            str s = tos(bel(inds[i]));            cerr << std::right << std::setw(sz(s) + (i ? 1 : 0)) << inds[i];        }        cerr << endl;        rep(i, sz(inds)) { cerr << bel(inds[i]) << \" \"; }        cerr << endl << endl;        cerr << \"---hld_edge_index---\" << endl;        fora(e, edges) { if (e.f <= e.t) cerr << e.f << \"-\" << e.t << \" \" << bel(e) << endl; }        cerr << endl << endl;        cerr << \"!!query!! edge or not edge carefull!!\" << endl;\n#endif\n    }    int dfs(int curr, int prev) {        int sub = 1, max_sub = 0;        heavy[curr] = -1;        forg(i, g[curr]) {            int next = t;            if (next != prev) {                depth[next] = depth[curr] + 1;                int sub_next = dfs(next, curr);                sub += sub_next;                if (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;            }        }        return sub;    }    int t = 0;\n#ifndef __CLION_IDE__\n    void dfs_hld(int v = 0) {        vid[v] = subl[v] = t;        t++;        inv[subl[v]] = v;        if (0 <= heavy[v]) {            head[heavy[v]] = head[v];            dfs_hld(heavy[v]);        }        forg(i, g[v])if (depth[v] < depth[t])                if (t != heavy[v]) {                    head[t] = t;                    dfs_hld(t);                }        subr[v] = t;    }\n#endif//__CLION_IDE__\n    vector<signed> rmq_dep;\n    vi par_, depth, disv;\n    vi childs;\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;\n    int root;\n    //部分木の  [左端、右端)  index\n    //部分木の辺に加算する場合\n    //add(subl[i],subr[i],x)\n    //add(sub[i],sub[i+1],-x)\n    vector<int> vid, head, heavy, inv, subl, subr;\n    tree(int n_, int root = 0) : undigraph<T>(n_), root(root) { n = n_; }\n    void change_root(int roo){root = roo;precalc();}\n    int lca(int a, int b) {        if (never)precalc();        int x = in[a];        int y = in[b];        if (x > y) { swap(x, y); }        int pos = rmq.query(x, y + 1);        return id[pos];    }\n    int dis(int a, int b) {        if (never)precalc();        int x = in[a];        int y = in[b];        if (x > y) { swap(x, y); }        int pos = rmq.query(x, y + 1);        int p = id[pos];        return disv[a] + disv[b] - disv[p] * 2;    }\n    int dep(int a){if (never)precalc(); return disv[a];}\n    int par(int a){if (never)precalc(); return par_[a];}\n    bool isleaf(int i){if(never)precalc();return(sz(g[i])==1 && i!=root);}\n    vi child(int r) {        vi res;        res.push_back(r);        queue<int> q;        q.push(r);        while (!q.empty()) {            int i = q.front();            res.push_back(i);            q.pop();            forg(gi, g[i]) {                if (t != par(i))q.push(t);            }        }        return res;    }\n    vb child_ex(int r) {        vb res(n);        res[r] = true;        queue<int> q;        q.push(r);        while (!q.empty()) {            int i = q.front();            res[i] = true;            q.pop();            forg(gi, g[i]) {                if (t != par(i))q.push(t);            }        }        return res;    }int dfs_count_subtree(int p,int i){        childs[i] =1;        fort(gi, g[i]){            childs[i] += dfs_count_subtree(i,t);        }        return childs[i];    }\n    #define count_child count_subtree\n    int count_subtree(int f){        if(sz(childs)==0){            if(never)precalc();            childs.resize(n);            dfs_count_subtree(-1,root);        }        return childs[f];    }\n    //fからtの辺を切った時のtの大きさ\n    int count_subtree(int f,int t){        if(par(f)==t)    {            return n - count_subtree(f);        }else{            return count_subtree(t);        }    }\n    vi path(int a, int b) {        vi res;        for_each_l(a, b, [&](int i) { res.push_back(i); });        return res;    }\n    /*O(N) hldを使わず木を普通にたどる liteの意*/\n    void for_each_l(int u, int v, function<void(int)> fnode) {        int r = lca(u, v);        while (u != r) {            fnode(u);            u = par_[u];        }        fnode(r);        vi a;        while (v != r) {            a.push_back(v);            v = par_[v];        }        while(sz(a)){            fnode(a.back());            a.pop_back();        }    }\n    void for_each_edge_l(int u, int v, function<void(edge<int> &)> fedge) {        int r = lca(u, v);        while (u != r) {                forg(gi, g[u]) {                    if (t == par_[u]) {                        fedge(g[u][gi]);                        u = par_[u];                        break;                    }                }            }        vector<edge<int>> qs;        while (v != r) {                forg(gi, g[v]) {                    if (t == par_[v]) {                        qs.push_back(g[v][gi]);                        v = par_[v];                        break;                    }                }            }        while(sz(qs)){            fedge(qs.back());            qs.pop_back();        }    }\n    //Fは半開 (u,v)は木の頂点\n    //中ではhldの頂点を見るため、seg木のupdateはhldのindexで行なう\n    void for_each_/*[l,r)*/(int u, int v, const function<void(int, int)> &f) {        if (never_hld)hld_build();        while (1) {            if (vid[u] > vid[v]) swap(u, v);            int l = max(vid[head[v]], vid[u]);            int r = vid[v] + 1;            f(l, r);            if (head[u] != head[v]) v = par_[head[v]]; else break;        }    }\n    void for_each_edge/*[l,r) O(log(N)) 辺を頂点として扱っている 上と同じ感じで使える*/(int u, int v, const function<void(int, int)> &f) {        if (never_hld)hld_build();        while (1) {            if (vid[u] > vid[v]) swap(u, v);            if (head[u] != head[v]) {                int l = vid[head[v]];                int r = vid[v] + 1;                f(l, r);                v = par_[head[v]];            } else {                if (u != v) {                    int l = vid[u] + 1;                    int r = vid[v] + 1;                    f(l, r);                }                break;            }        }    }\n    int bel(int v) {        /*hld内での頂点番号を返す*/        if (never_hld)hld_build();return vid[v];}\n    //下の頂点に辺のクエリを持たせている\n    int bel(int f, int t) {        /*辺のクエリを扱うときどの頂点に持たせればいいか(vidを返すのでそのままupd出来る)*/        if (never_hld)hld_build();return depth[f] > depth[t] ? vid[f] : vid[t];}\n    int bel(edge<T> &e) {        /*辺のクエリを扱うときどの頂点に持たせればいいか(vidを返すのでそのままupd出来る)*/        if (never_hld)hld_build();return depth[e.f] > depth[e.t] ? vid[e.f] : vid[e.t];}\n    template<class ... U> int operator()(U ... args) { return bel(args...); }\n    //path l -> r += v\n    template<class S> void seg_add(S &seg, int lhei, int rhei, int v) {for_each_(lhei, rhei, [&](int l, int r) { seg.add(l, r, v); });}\n    template<class S> void seg_update(S &seg, int lhei, int rhei, int v) {for_each_(lhei, rhei, [&](int l, int r) { seg.update(l, r, v); });}\n    template<class S> T seg_get(S &seg, int lhei, int rhei) {        T res = seg.e;        for_each_(lhei, rhei, [&](int l, int r) { res = seg.f(res, seg.get(l, r)); });        return res;    }\n    template<class S> void seg_add_edge(S &seg, int lhei, int rhei, int v) { for_each_edge(lhei, rhei, [&](int l, int r) { seg.add(l, r, v); }); }\n    template<class S> void seg_update_edge(S &seg, int lhei, int rhei, int v) { for_each_edge(lhei, rhei, [&](int l, int r) { seg.update(l, r, v); }); }\n    template<class S> T seg_get_edge(S &seg, int lhei, int rhei) {        T res = seg.e;        for_each_edge(lhei, rhei, [&](int l, int r) { res = seg.f(res, seg.get(l, r)); });        return res;    }\n    //単体   edgeは上で処理できる\n    template<class S> void seg_add(S &seg, int i, int v) { seg.add(bel(i), v); }\n    template<class S> void seg_update(S &seg, int i, int v) { seg.update(bel(i), v); }\n    template<class S> T seg_get(S &seg, int i) { return seg[i]; }\n    template<class S> void seg_del(S &seg, int i) { seg.del(bel(i)); }\n\n    //部分木iに対するクエリ\n    template<class S> void seg_add_sub(S &seg, int i, int v) {if (never_hld)hld_build();seg.add(subl[i], subr[i], v);}\n    template<class S> void seg_update_sub(S &seg, int i, int v) {if (never_hld)hld_build();seg.update(subl[i], subr[i], v);}\n    template<class S> T seg_get_sub(S &seg, int i, int v) {if (never_hld)hld_build();return seg.get(subl[i], subr[i], v);}\n    template<class S> void seg_add_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/seg.add(subl[i] + 1, subr[i], v);}\n    template<class S> void seg_update_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/seg.update(subl[i] + 1, subr[i], v);}\n    template<class S> T seg_get_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/return seg.get(subl[i] + 1, subr[i], v);}\n};\n//辺が多いのでedgesを持たない\n//cost oo, ox, xo, xx 渡す\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\n    vi costs;\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;\n    int H, W;\n    vector<vector<char>> ba;\n    char wall;\n\n    void add(int f, int t, T c = 1){\n        cout << \"grid\" << endl;\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"grid_k6 add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        //undigraphと違い、edgesを持たない\n    }\n    int getid(int h, int w) {        assert(ins(h, w, H, W));        return W * h + w;    }\n    int getid(P p) { return getid(p.first, p.second); }\n    P get2(int id) { return mp(id / W, id % W); }\n    P operator()(int id) { return get2(id); }\n    int operator()(int h, int w) { return getid(h, w); }\n    int operator()(P p) { return getid(p); }\n    //辺は無い\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {}\n    grid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) { add(f, getid(h, w + 1)); }                if (h + 1 < H && ba[h + 1][w] != wall) { add(f, getid(h + 1, w)); }            }        }    }\n    /*o -> o, o -> x, x-> x*/\n    grid_k6(vector<vector<char>> ba, int oo, int ox, int xo, int xx, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])), costs({oo, ox, xo, xx}), ba(ba), wall(wall) {        rep(h, H) {            rep(w, W) {                add(h, w, h + 1, w);                add(h, w, h - 1, w);                add(h, w, h, w + 1);                add(h, w, h, w - 1);            }        }    }\n    void add(int fh, int fw, int th, int tw) {        if (ins(fh, fw, H, W) && ins(th, tw, H, W)) {            int cm = 0;            if (ba[fh][fw] == wall) { cm += 2; }            if (ba[th][tw] == wall) { cm++; }            int f = getid(fh, fw);            int t = getid(th, tw);            g[f].emplace_back(f, t, costs[cm]);        }    }\n    void set_edges() { rep(i, n)fora(e, g[i])if (e.f < e.t)edges.push_back(e); }\n};\n\n//辺によりメモリを大量消費ためedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    int H, W;\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"digrid_k6 add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        /*digraphと違いedgesを持たない*/\n    }\n    int getid(int h, int w) {        if (!ins(h, w, H, W))return -1;        return W * h + w;    }\n    P get2(int id) { return mp(id / W, id % W); }\n    P operator()(int id) { return get2(id); }\n    int operator()(int h, int w) { return getid(h, w); }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W){}\n    digrid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) { add(f, getid(h, w + 1)); }                if (h + 1 < H && ba[h + 1][w] != wall) { add(f, getid(h + 1, w)); }            }        }    }\n    void add(int fh, int fw, int th, int tw) { add(getid(fh, fw), getid(th, tw)); }\n    void set_edges() { rep(i, n)fora(e, g[i])edges.push_back(e); }\n};\n//edgesを持たない\n//dijkstra(g,0)[t] とかける (t+n-1等とする必要はない)\ntemplate<class T=int>class segdi : public digraph<T>{int getid(int k){        if(k >= len*2-1){            return k;        }        else if(k < len - 1){            return k + len;        }else{            return k - len + 1;        }    }void add(int f, int t, T c = 1) {        f = getid(f);        t = getid(t);        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"segdi add\");            deb(f, t, c);            ole();        }        g[f].emplace_back(f, t, c);        /*digraphと違いedgesを持たない*/    }int mid;int len;\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    //頂点が足りなくなったらresize\n    segdi(int n_) : digraph<T>(1) {        int nn = 1;        while (nn < n_)nn *= 2;        n_ = nn;        len = n_;        this->resize(n_ + (n_ - 1) * 2 + n_);        mid = n_ + (n_ - 1) * 2;        int ad = len * 2 - 1;        rep(i, len - 1) {            add(i, i * 2 + 1, 0);            add(i, i * 2 + 2, 0);            if (i * 2 + 1 >= len - 1) {                add(i * 2 + 1, i + ad, 0);                add(i * 2 + 2, i + ad, 0);            } else {                add(i * 2 + 1 + ad, i + ad, 0);                add(i * 2 + 2 + ad, i + ad, 0);            }        }    }\n    void dfs(vi &list, int nl, int nr, int k, int l, int r) {        if (r <= nl || nr <= l)return;        if (l <= nl && nr <= r) {            list += k;        } else {            dfs(list, nl, (nl + nr) / 2, k * 2 + 1, l, r);            dfs(list, (nl + nr) / 2, nr, k * 2 + 2, l, r);        }    }\n    void rekkyo(vi &list, int l, int r) {        l += len - 1;        r += len - 1;        while (l < r) {            if (!(l & 1)) { list.push_back(l); }            if (!(r & 1)) { list.push_back(r - 1); }            l >>= 1;            r = (r - 1) >> 1;        }    }\n    //半開\n    void add(int fl, int fr, int tl, int tr, int cost) {        /*fは下側*/        int ad = 2 * len - 1;        if (mid >= n) { this->resize(n + 100); }        {            int l = fl, r = fr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) {                    if (l - len + 1 < 0)add(l + ad, mid, cost);                    else add(l, mid, cost);                }                if (!(r & 1)) {                    if (r - 1 - len + 1 < 0)add(r - 1 + ad, mid, cost);                    else add(r - 1, mid, cost);                }                l >>= 1;                r = (r - 1) >> 1;            }        }        {            int l = tl, r = tr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) { add(mid, l, 0); }                if (!(r & 1)) { add(mid, r - 1, 0); }                l >>= 1;                r = (r - 1) >> 1;            }        }        mid++;    }\n};\n//edgesを持たない\n//dijkstra(g,0)[t] とかける (t+n-1等とする必要はない)\ntemplate<class T=int>class segun : public undigraph<T>{int getid(int k){        if(k >= len*2-1){            return k;        }        else if(k < len - 1){            return k + len;        }else{            return k - len + 1;        }    }void add(int f, int t, T c = 1) {        f = getid(f);        t = getid(t);        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"segun add\");            deb(f, t, c);            ole();        }        g[f].emplace_back(f, t, c);        /*digraphと違いedgesを持たない*/            g[t].emplace_back(t, f, c);        /*digraphと違いedgesを持たない*/    }    int mid;    int len;\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    //頂点が足りなくなったらresize\n    segun(int n_) : digraph<T>(1) {        int nn = 1;        while (nn < n_)nn *= 2;        n_ = nn;        len = n_;        this->resize(n_ + (n_ - 1) * 2 + n_);        mid = n_ + (n_ - 1) * 2;        int ad = len * 2 - 1;        rep(i, len - 1) {            add(i, i * 2 + 1, 0);            add(i, i * 2 + 2, 0);            if (i * 2 + 1 >= len - 1) {                add(i * 2 + 1, i + ad, 0);                add(i * 2 + 2, i + ad, 0);            } else {                add(i * 2 + 1 + ad, i + ad, 0);                add(i * 2 + 2 + ad, i + ad, 0);            }        }    }\n    void dfs(vi &list, int nl, int nr, int k, int l, int r) {        if (r <= nl || nr <= l)return;        if (l <= nl && nr <= r) {            list += k;        } else {            dfs(list, nl, (nl + nr) / 2, k * 2 + 1, l, r);            dfs(list, (nl + nr) / 2, nr, k * 2 + 2, l, r);        }    }\n    void rekkyo(vi &list, int l, int r) {        l += len - 1;        r += len - 1;        while (l < r) {            if (!(l & 1)) { list.push_back(l); }            if (!(r & 1)) { list.push_back(r - 1); }            l >>= 1;            r = (r - 1) >> 1;        }    }\n    //半開\n    void add(int fl, int fr, int tl, int tr, int cost) {        /*fは下側*/        int ad = 2 * len - 1;        if (mid >= n) { this->resize(n + 100); }        {            int l = fl, r = fr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) {                    if (l - len + 1 < 0)add(l + ad, mid, cost);                    else add(l, mid, cost);                }                if (!(r & 1)) {                    if (r - 1 - len + 1 < 0)add(r - 1 + ad, mid, cost);                    else add(r - 1, mid, cost);                }                l >>= 1;                r = (r - 1) >> 1;            }        }        {            int l = tl, r = tr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) { add(mid, l, 0); }                if (!(r & 1)) { add(mid, r - 1, 0); }                l >>= 1;                r = (r - 1) >> 1;            }        }        mid++;    }\n};\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define o_getid(a,b,name,...) name\n#define getid(...) o_getid(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n\n#define unionfind unionfind_graph\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    template<class T>unionfind(graph<T>& g) : n(g.n), trees(g.n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }        add(g);    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    template<class T>void add(graph<T>&g){fora(e,g.edges){unite(e.f,e.t);}}\n    template<class T>void unite(graph<T>&g){add(g);}\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\n//@出力\ntemplate<class T> ostream &operator<<(ostream &os, digraph<T> &g) {    os << endl << g.n << \" \" << sz(g.edges) << endl;    fore(gi, g.edges) { os << f << \" \" << t << \" \" << c << endl; }    return os;}template<class T> ostream &operator<<(ostream &os, undigraph<T> &g) {    os << endl << g.n << \" \" << sz(g.edges)/2 << endl;    fore(gi, g.edges) { if (f < t)os << f << \" \" << t << \" \" << c << endl; }    return os;}\n\n//@判定\ntemplate<class T> bool nibu( graph<T> &g) {    int size = 0;    rep(i, g.n)size += sz(g.g[i]);    if (size == 0)return true;    unionfind uf(g.n * 2);    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);    rep(i, g.n)if (uf.same(i, i + g.n))return 0;    return true;}\n//頂点ではなく辺の数に依存した計算量 O(E)\ntemplate<class T> bool nibu_sub( graph<T> &g) {    umapi col;/*0なら無色 */   queue<int> q;    /*色は01か11 */    fora(e, g.edegs) {        /*fとtの色を持つか否かは同じ*/        if (col[e.f] == 0)q.push(e.f);        while (!q.empty()) {            int f = q.front();            q.pop();            int fc = col[f];            forg(gi, g[f]) {                int &tc = col[t];                /*fcには色がある*/                if (fc == tc)return false;                /*違う色*/                if (tc)continue;                /*無色*/                tc = fc ^ 2;                q.push(tc);            }        }    }    return true;}\n    //二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {    vp cg;    if (!nibu(g)) {        debugline(\"nibu\");        ole();    }    int n = g.size();    vb was(n);    queue<P> q;    rep(i, n) {        if (was[i])continue;        q.push(mp(i, 1));        was[i] = 1;        int red = 0;        int coun = 0;        while (q.size()) {            int now = q.front().fi;            int col = q.front().se;            red += col;            coun++;            q.pop();            forg(gi, g[now]) {                if (was[t])continue;                q.push(mp(t, col ^ 1));                was[t] = 1;            }        }        cg.push_back(mp(red, coun - red));    }    return cg;}\n    //連結グラフが与えられる 閉路があるか\ntemplate<class T> bool close(undigraph<T> &g) {    int n = 0;    int e = 0;    rep(i, g.n) {        if (sz(g[i]))n++;        forg(gi, g[i]) { e++; }    }    return (e >> 1) >= n;}\ntemplate<class T> bool close(undigraph<T> &g, int v) {    unionfind uf(g.n);    rep(i, g.n) {        forg(gi, g[i]) {            if (f < t)break;            if (f == t && f == v)return true;            if (uf.same(f, v) && uf.same(t, v))return true;            uf.unite(f, t);        }    }    return false;}template<class T> bool close(digraph<T> &g) {    vi res;    return topo(res, g);}\n\n//@変形\n//条件(f!=0等 f,t,cが使える)を満たすsubgraphをg2に代入\n#define sub_di(g, g2, zhouken) {g2.resize(g.n);fore(gi, g.edges){if(zhouken){g2.add(f,t,c);}}}\n#define sub_un(g, g2, zhouken) {g2.resize(g.n);fore(gi, g.edges){bool ok = zhouken; /*片方がアウトなら駄目という扱い*/swap(f,t); ok &= zhouken;if(ok && f < t){g2.add(f,t,c);}}}\n#define sub_tree sub_un\n    //閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    queue<int> st;    rep(i, n)if (nyu[i] == 0)st.push(i);    while (st.size()) {        int v = st.front();        st.pop();        res.push_back(v);        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);    }    return res.size() == n;}\n    //辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    /*小さい順*/    priority_queue<int, vector<int>, greater<int> > q;    rep(i, n)if (nyu[i] == 0)q.push(i);    while (q.size()) {        int i = q.top();        q.pop();        res.push_back(i);        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);    }    return res.size() == n;}\ntemplate<class T> digraph<T> rev(digraph<T> &g) {    digraph<T> r(g.n);    rep(i, g.n) { forg(gi, g[i]) { r.add(t, f, c); }}    return r;}\n    //lc,rcは子を持つ中で一番左、右\n    //(g,ind,l,r)\ntemplate<class T> tree<T> get_bfs_tree(tree<T> &g, vi &ind, vi &l, vi &r) {if (sz(ind)) {cerr << \"ind must be empty\" << endl;exit(0);}int N = sz(g);ind.resize(N);l.resize(N, inf);r.resize(N, -1);tree<T> h(N);queue<P> q;q.emplace(-1, 0);int c = 0;while (sz(q)) {int p = q.front().first;int i = q.front().second;q.pop();ind[i] = c;if (~p)chmi(l[ind[p]], c);if (~p)chma(r[ind[p]], c);c++;forg(gi, g[i]) {if (t != p)q.emplace(i, t);}}fora(e, g.edges) {if (e.f < e.t) {h.add(ind[e.f], ind[e.t], e.c);}}rep(i, N) {if (l[i] == inf)l[i] = -1;}return h;}\n    //lc,rcは子を持つ中で一番左、右\n    // たとえばl[lc[x]は2段下の最左\n    //(g,ind,l,r,lc,rc)\ntemplate<class T> tree<T> get_bfs_tree(tree<T> &g, vi &ind, vi &l, vi &r, vi &lc, vi &rc) {    if (sz(ind)) {        cerr << \"ind must be empty\" << endl;        exit(0);    }    int N = sz(g);    ind.resize(N);    l.resize(N, inf);    lc.resize(N, inf);    r.resize(N, -1);    rc.resize(N, -1);    tree<T> h(N);    queue<P> q;    q.emplace(-1, 0);    int c = 0;    while (sz(q)) {        int p = q.front().first;        int i = q.front().second;        q.pop();        ind[i] = c;        if (~p) {            chmi(l[ind[p]], c);            chma(r[ind[p]], c);            if (sz(g[i]) > 1) {                chmi(lc[ind[p]], c);                chma(rc[ind[p]], c);            }        }        c++;        forg(gi, g[i]) {            if (t != p)q.emplace(i, t);        }    }    fora(e, g.edges) {        if (e.f < e.t) {            h.add(ind[e.f], ind[e.t], e.c);        }    }    rep(i, N) {        if (l[i] == inf)l[i] = -1;        if (lc[i] == inf)lc[i] = -1;    }    return h;}\n\n//@集計\ntemplate<class T> vi indegree(graph<T> &g) {vi ret(g.size());rep(i, g.size()) { forg(gi, g[i]) { ret[t]++; }}return ret;}\ntemplate<class T> vi outdegree(graph<T> &g) {vi ret(g.size());rep(i, g.size()) { ret[i] = g[i].size(); }return ret;}\n#define kansetu articulation\n//private\n/*private*/  P farthest____(tree<> &E, int cur, int pre, int d, vi &D) {    D[cur] = d;    P r = {d, cur};    forg(gi, E[cur]) if (t != pre) {            P v = farthest____(E, t, cur, d + 1, D);            r = max(r, v);        }    return r;}\n//dagでなければ-1を返す\nint diameter(digraph<> &g) {    vi per;    if (!topo(per, g))return -1;    int n = g.n;    vi dp(n, 1);    fora(v, per) { forg(gi, g[v]) { chma(dp[t], dp[f] + 1); }}    return max(dp);}\n//iから最も離れた距離\nvi diameters(tree<> &E) { /* diameter,center*/vi D[3];    D[0].resize(E.size());    D[1].resize(E.size());    auto v1 = farthest____(E, 0, 0, 0, D[0]);    auto v2 = farthest____(E, v1.second, v1.second, 0, D[0]);    farthest____(E, v2.second, v2.second, 0, D[1]);    int i;    rep(i, D[0].size()) D[2].push_back(max(D[0][i], D[1][i]));    return D[2];}\n//iに対応するjと距離\nvp diameters_p(tree<> &E) { /* diameter,center*/vector<int> D[3];    D[0].resize(E.size());    D[1].resize(E.size());    auto v1 = farthest____(E, 0, 0, 0, D[0]);    auto v2 = farthest____(E, v1.second, v1.second, 0, D[0]);    farthest____(E, v2.second, v2.second, 0, D[1]);    int i;    vp res(E.size());    rep(i, D[0].size()) { if (D[0][i] > D[1][i])res[i] = mp(v1.second, D[0][i]); else res[i] = mp(v2.second, D[1][i]); }    return res;}\nint diameter(tree<> &E) {    vi d = diameters(E);    return max(d);}\n//最も離れた二点を返す\nP diameter_p(tree<> &E) {    auto d = diameters_p(E);    int dis = -1;    int l = -1, r = -1;    rep(i, sz(d)) {        if (chma(dis, d[i].se)) {            l = i;            r = d[i].fi;        }    }    return mp(l, r);}\n//@列挙 取得\n//閉路がある時linfを返す\ntemplate<class T> int longest_path(digraph<T> &g) {    vi top;    if (!topo(top, g)) { return linf; }    int n = sz(top);    vi dp(n, 0);    for (auto &&i : top) { forg(gi, g[i]) { chma(dp[t], dp[i] + 1); }}    return max(dp);}\ntemplate<class T> vi longest_path_v(digraph<T> &g) {    vi top;    if (!topo(top, g)) { return vi(); }    int n = sz(top);    vi dp(n, 0);    vi pre(n, -1);    for (auto &&i : top) { forg(gi, g[i]) { if (chma(dp[t], dp[i] + 1)) { pre[t] = i; }}}    int s = std::max_element(dp.begin(), dp.end()) - dp.begin();    vi path;    while (s != -1) {        path.push_back(s);        s = pre[s];    }    std::reverse(path.begin(), path.end());    return path;}\n//橋を列挙する (取り除くと連結でなくなる辺)\ntemplate<class T> vp bridge(graph<T> &G) {    static bool was;    vp brid;    vi articulation;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) brid.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) { low[v] = min(low[v], ord[G[v][i].t]); }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) articulation.push_back(v);    };    int k = 0;    rep(i, G.n) { if (!vis[i]) dfs(i, -1, k); }    sort(brid.begin(), brid.end());    return brid;}\n//間接点を列挙する (取り除くと連結でなくなる点)\ntemplate<class T> vi articulation(undigraph<T> &G) {    static bool was;    vp bridge;    vi arti;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) bridge.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) { low[v] = min(low[v], ord[G[v][i].t]); }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) arti.push_back(v);    };    int k = 0;    rep(i, G.n) { if (!vis[i]) dfs(i, -1, k); }    sort(arti.begin(), arti.end());    return arti;}\n//閉路パスを一つ返す\nvi close_path(digraph<> &g) {    int n = g.n;    vi state(n);    vi path;    rep(i, n) if (!state[i]) {            if (fix([&](auto dfs, int v) -> bool {                if (state[v]) {                    if (state[v] == 1) {                        path.erase(path.begin(), find(path.begin(), path.end(), v));                        return true;                    }                    return false;                }                path.push_back(v);                state[v] = 1;                forg(gi, g[v]) { if (dfs(t))return true; }                state[v] = -1;                path.pop_back();                return false;            })(i)) { return path; }        }    return vi();}\nvi close_path_min(digraph<> &g) {    int n = g.n;    vvi(dis, n);    rep(i, n)dis[i] = dijkstra(g, i, linf);    int mind = linf;    int f = 0, t = 0;    rep(i, n) {        rep(j, n) {            if (i == j)continue;            if (chmi(mind, dis[i][j] + dis[j][i])) {                f = i;                t = j;            }        }    }    vi path;    auto add = [&](int f, int t) {        int now = f;        while (now != t) {            rep(i, n) {                if (dis[now][i] == 1 && dis[f][i] + dis[i][t] == dis[f][t]) {                    path.push_back(i);                    now = i;                    break;                }            }        }    };    add(f, t);    add(t, f);    return path;}\n//iを含む最短閉路 https://atcoder.jp/contests/abc022/tasks/abc022_c\n/*閉路が1つしかない場合、その閉路に含まれる頂点を1としたvectorを返す*/;\ntemplate<class T> vi get_close1(digraph<T> &g) {    int n = g.n;    queue<int> q;    vi d = outdegree(g);    vi res(n, 1);    rep(i, n) {        if (d[i] == 0) {            q += i;            res[i] = 0;        }    }    auto rg = rev(g);    while (q.size()) {        auto now = q.front();        q.pop();        forg(gi, rg[now]) {            if (--d[t] == 0) {                q += t;                res[t] = 0;            }        }    }    return res;}\n\n//@アルゴリズム\ntemplate<class T> int krus(undigraph<T> &g) {    int res = 0;    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res += e.c; }}    return res;}\ntemplate<class T> vector<edge<T>> krus_ed(undigraph<T> &g) {    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    vector<edge<T>> res;    fora(e, E) { if (uf.unite(e.f, e.t)) { res.push_back(e); }}    return res;}\ntemplate<class T> tree<T> krus_tr(undigraph<T> &g) {    tree<T> res(g.n);    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res.add(e.f, e.t); }}    return res;}\ntemplate<class T> int krus(const vector<edge<T>> &g) {int n=0;    fora(e,g){chma(n,max(e.f,e.t)+1);};    int res = 0;    unionfind uf(n);    auto E = g;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res += e.c; }}    return res;}\ntemplate<class T> vector<edge<T>> krus_ed(const vector<edge<T>> &g) {    int n=0;    fora(e,g){chma(n,max(e.f,e.t)+1);};    vector<edge<T>> res;    unionfind uf(n);    auto E = g;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res += e; }}    return res;};\ntemplate<class T> vi krus_i(const vector<edge<T>> &g) {    int n=0;    fora(e,g){chma(n,max(e.f,e.t)+1);};    vi res;    unionfind uf(n);    auto E = g;    sort(E);    int i = 0;    fora(e, E) {        if (uf.unite(e.f, e.t)) { res += i; }        i++;    }    return res;}\n//@実験\ndigraph<> rang_di(int n, int m, bool zibun = 0, bool taju = 0) {    umapp was;    digraph<> g(n);    was[mp(-1, -2)] = 1;    while (m) {        int f = -1, t = -2;        while (f < 0 || (!taju && was[mp(f, t)])) {            f = rand(0, n - 1);            t = rand(0, n - 1);            if (!zibun && f == t)f = -1;        }        g.add(f, t);        was[mp(f, t)] = 1;        m--;    }    return g;}\ndigraph<> perfect_di(int n, bool zibun = 0) {    digraph<> g(n);    rep(i, n) {        rep(j, n) {            if (!zibun && i == j)con;            g.add(i, j);        }    }    return g;}\nundigraph<> rang_un(int n, int m, bool zibun = 0, bool taju = 0) {    umapp was;    undigraph<> g(n);    was[mp(-1, -2)] = 1;    while (m) {        int f = -1, t = -2;        while (f < 0 || (!taju && was[mp(min(f, t), max(f, t))])) {            f = rand(0, n - 1);            t = rand(0, n - 1);            if (!zibun && f == t)f = -1;        }        g.add(f, t);        was[mp(min(f, t), max(f, t))] = 1;        m--;    }    return g;}\nundigraph<> perfect_un(int n, bool zibun = 0){    undigraph<> g(n);    rep(i, n) {        rep(j, i, n) {            if (!zibun && i == j)con;            g.add(i, j);        }    }    return g;}\n/*頂点数がkの木を一つ返す サイズが0の木が帰ったら終了*/\ntree<int> next_tree(int k) {    assert(2 <= k && k < 11);    static str name;    static ifstream ina;    static int rem;    static vp edges;    static int pk = -1;/*前回見たk*/    if (pk != k) {        if (~pk)ina.close();        edges.clear();        pk = k;        name = (k == 6) ? \"C:\\\\Users\\\\kaout\\\\Desktop\\\\trees_sizek\\\\nazeka6.txt\" : \"C:\\\\Users\\\\kaout\\\\Desktop\\\\trees_sizek\\\\tree_size\" + tos(k) + \".txt\";        ina = ifstream(name);        rem = pow(k, k - 2);/*Cayleyの定理*/        rep(i, k)rep(j, i + 1, k)edges.emplace_back(i, j);        pk = k;    }    tree<int> g(k);    if (rem == 0) {        g.resize(0);        return g;    }    int m;    ina >> m;    while (m) {        int lb = lbit(m);        int id = log2(lb);        g.add(edges[id].first, edges[id].second);        m ^= lb;    }    rem--;    return g;}\nundigraph<int> next_undi(int k) {    assert(2 <= k && k < 9);    static str name;    static ifstream ina;    static int rem;    static vp edges;    static vi lims = {-1, -1, 1, 4, 38, 728, 26704, 1866256};    static int pk = -1;/*前回見たk*/    if (pk != k) {        if (~pk)ina.close();        edges.clear();        pk = k;        name = (k == 6) ? \"C:\\\\Users\\\\kaout\\\\Desktop\\\\undi_sizek\\\\roku.txt\" : \"C:\\\\Users\\\\kaout\\\\Desktop\\\\undi_sizek\\\\undi_size\" + tos(k) + \".txt\";        ina = ifstream(name);        rem = lims[k];        rep(i, k)rep(j, i + 1, k)edges.emplace_back(i, j);        pk = k;    }    undigraph<int> g(k);    if (rem == 0) {        g.resize(0);        return g;    }    int m;    ina >> m;    while (m) {        int lb = lbit(m);        int id = log2(lb);        g.add(edges[id].first, edges[id].second);        m ^= lb;    }    rem--;    return g;}\nvector<tree<int>> trees(int k) {    vector<tree<int>> res;    while (1) {        tree<int> g = next_tree(k);        if (sz(g) == 0)break;        res.push_back(g);    }    return res;}\nvector<undigraph<int>> undis(int k) {    vector<undigraph<int>> res;    while (1) {        undigraph<int> g = next_undi(k);        if (sz(g) == 0)break;        res.push_back(g);    }    return res;}\ntemplate<class T> vector<vector<int>> table(graph<T> &g,int init_value) {    vvi(res, g.n, g.n,init_value);    rep(i, g.n) { forg(gi, g[i]) { res[i][t] = c; }}    return res;}\n//type,idが使いたい場合はgraty\n/*@formatter:on*/\nvoid fAb(bool a) { if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\n\nvoid solve(){\n    in(N);\n    tree<> g(2 * k5);;\n    g.ing(N,N-1);\n    vi v(N);\n    fix([&](auto ds, int p, int i) -> int {\n        fort(gi, g[i]){\n            v[i]^=ds(i,t)+1;\n        }\n        return v[i];\n    })(-1, 0);\n    deb(v);\n    fAb(v[0]);\n}\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int h[1 << 20];\n    static int cnt[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        set < int > ss;\n        h[node] = h[prev] + 1;\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node),ss.insert(cnt[it]);\n        while (ss.count(cnt[node])) ++cnt[node];\n    };\n    dfs(1,0);\n    int ans = 0;\n    for (int i = 2;i <= n;++i)\n        ans ^= cnt[i];\n    puts(ans ? \"Alice\":\"Bob\");\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#include<fstream>\n#include<string>\nusing namespace std;\n#define f(n) for(int i=0;i<n;++i)\n#define ll long long\n\nint main() {\n\tll ans = 0, n;\n\tcin >> n;\n\tvector<int>v(100001,0);\n\tf(n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tv[a]++;\n\t\tv[b]++;\n\t}\n\tf(n) {\n\t\tif (v[i] % 2 == 0) {\n\t\t\tans++;\n\t\t}\n\t}\n\tans -= 1;\n\tif (ans % 2 == 0 || v[1] == 1) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM], w[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, nr = 0;\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n            dfs(v[nod][i], nod);\n        }\n    }\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n           w[++nr] = s[ v[nod][i] ];\n        }\n    }\n    sort(w + 1, w + nr + 1);\n    if(w[1] == 0){\n        for(i = 2; i <= nr; i++){\n            if(w[i] - w[i - 1] > 1){\n                s[nod] = w[i - 1] + 1;\n                break;\n            }\n        }\n        if(i == nr + 1){\n            s[nod] = w[nr] + 1;\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    for(i = 2; i <= n; i++){\n        sum ^= s[i];\n    }\n    if(sum == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 100005;\nint f[MAXN], n;\nvector<int> gra[MAXN];\n\nvoid dfs(int u, int fa) {\n\tfor (int v : gra[u]) if (v != fa) {\n\t\tdfs(v, u);\n\t\tf[u] ^= f[v];\n\t}\n\tif (u > 1) ++f[u];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tgra[u].push_back(v), gra[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tputs(f[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> edges[100000];\n\nint dfs(int i, int prev){\n    int ret = 0;\n    for(auto j : edges[i]){\n        if(j != prev) ret ^= dfs(j, i) + 1;\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i=0; i<N-1; i++){\n        int x, y;\n        cin >> x >> y;\n        edges[x-1].push_back(y-1);\n        edges[y-1].push_back(x-1);\n    }\n\n    int gr = dfs(0, -1);\n    cout << (gr!=0 ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nconst int N=100005;\nconst int inf=2000000000;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint n,x,y,num;\nint head[N],dp[N];\n\nvoid add(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num;\n}\n\nvoid dfs(int k,int pre){\n\tint j,u;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tdfs(u,k);\n\t\tdp[k]^=dp[u]+1;\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tdfs(1,0);\n\tif (dp[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(int i=k;i<=n;i++)\n#define rep2(i,k,n) for(int i=k;i>=n;i--)\nusing namespace std;\ntypedef long long ll;\nvoid sc(int& x){x=0;char c=getchar();while(c>'9' || c<'0')c=getchar();\nfor(;c>='0' && c<='9';c=getchar())x=x*10+c-'0';\n}\nconst int N=2e5+7;\nconst int inf=0x3f3f3f3f;\nstruct E{\n\tint to,next;E(int to=0,int next=0):to(to),next(next){}\n}edge[N<<1];\nint head[N],tot;\nvoid add(int x,int y){\n\tedge[++tot]=E(y,head[x]);head[x]=tot;\n\tedge[++tot]=E(x,head[y]);head[y]=tot;\n}\nint n,sg[N];\nvoid dfs(int x,int f){\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(v!=f){\n\t\t\tdfs(v,x);\n\t\t\tsg[x]^=sg[v]+1;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned int ui;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nint logceil(ll x) {int b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass TaskD {\npublic:\n\tint N;\n\tvector<vector<int>> E;\n\n\tint dfs(int u, int ig) {\n\t\tint ans = 0;\n\t\tfor (int v: E[u]) {\n\t\t\tif (ig != v) {\n\t\t\t\tans ^= 1 + dfs(v, u);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n    void solve(istream& cin, ostream& cout) {\n\t\tcin >> N;\n\t\tE.resize(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint u,v; cin >> u >> v;\n\t\t\t--u; --v;\n\t\t\tE[u].push_back(v);\n\t\t\tE[v].push_back(u);\n\t\t}\n\n\n\t\tif (dfs(0, -1)) {\n\t\t\tcout << \"Alice\\n\";\n\t\t} else {\n\t\t\tcout << \"Bob\\n\";\n\t\t}\n\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tTaskD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nint x[100001];\nint y[100001];\nvector<int>G[100001];\nbool check=true;\nbool used[100001];\nLL now=0;\nint dfs(int x,int d){\n    if(used[x])return 0;\n    used[x]=true;\n    vector<int>v;\n    REP(i,G[x].size()){\n        if(used[G[x][i]]==false){\n           v.push_back(dfs(G[x][i],d+1));\n        }\n    }\n    sort(v.begin(),v.end());\n    int me=0;\n    /*REP(i,v.size()){\n        if(v[i]==0)continue;\n        if(me==0){\n           me=v[i];\n           continue;\n        }\n        if(me!=v[i]){\n           check=false;\n        }else{\n           me=0;\n        }\n    }*/\n    now^=d;\n    //cout<<x<<me<<endl;\n    return me+1;\n}\n\nint main(){\n    cin>>N;\n    REP(i,N-1){\n        cin>>x[i];x[i]--;\n        cin>>y[i];y[i]--;\n        G[x[i]].push_back(y[i]);\n        G[y[i]].push_back(x[i]);\n    }\n    REP(i,N){\n        used[i]=false;\n    }\n    if(N==2){\n       cout<<\"Alice\"<<endl;\n       return 0;\n    }\n    int ans=dfs(0,0);\n    if(ans!=1){\n       cout<<\"Alice\"<<endl;\n    }else if(now!=0){\n       cout<<\"Alice\"<<endl;\n    }else{\n       cout<<\"Bob\"<<endl;\n    }\n    \n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#include<fstream>\n#include<string>\nusing namespace std;\n#define f(n) for(int i=0;i<n;++i)\n#define ll long long\n\nint main() {\n\tint ans = 0, n, a, b;\n\tcin >> n;\n\tvector<int>v(1000000,0);\n\tf(n - 1) {\n\t\tcin >> a >> b;\n\t\tv[a]++;\n\t\tv[b]++;\n\t}\n\tf(n) {\n\t\tif (v[i] % 2 == 0) {\n\t\t\tans++;\n\t\t}\n\t}\n\tans -= 1;\n\tif (ans % 2 == 0 || v[1] == 1) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N=1e5+100;\nvi g[N];\n\nbool dfs(int v, int pr){\n    int tr=0,fl=0;\n    for(auto to:g[v]){\n        if(to==pr)\n            continue;\n        tr++;\n        bool u=dfs(to,v);\n        if(u)\n            fl++;\n    }\n    if(tr==0)\n        return true;\n    \n    if(fl==tr)\n        return false;\n    \n    return true;\n}\n\n\nvoid smain() {\n\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    bool u=dfs(1,1);\n    if(u)\n        cout<<\"Alice\";\n    else\n        cout<<\"Bob\";\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n#include <utility>\n#include <iostream>\n#include <cstdlib>\n#include <set>\n#include <list>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n#define ll long long\n#define pb push_back\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\n\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint t; \n\tcin >> t;\n\n\tvvi g(t+1);\n\tfor (int i = 0; i < t-1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint rootEdges = g[1].size();\n\tif (rootEdges == 1) {\n\t\tcout << \"Alice\" << endl;\n\t\treturn 0;\n\t} \n\n\tint remainingEdges = (t - 1) - 2;\n\tif (remainingEdges % 2 == 0) {\n\t\tcout << \"Bob\" << endl;\n\t} else {\n\t\tcout << \"Alice\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint parent[100010];\nvint edge[100010];\nbool visited[100010];\n\nint dfs(int cur) {\n\tif (edge[cur].size() == 1)\treturn 0;\n\tif (edge[cur].size() == 2) {\n\t\tif (visited[edge[cur][0]])\treturn dfs(edge[cur][1]) + 1;\n\t\telse\treturn dfs(edge[cur][0]) + 1;\n\t}\n\tint ret = 0;\n\trep(i, edge[cur].size()) {\n\t\tint to = edge[cur][i];\n\t\tif (!visited[to]) {\n\t\t\tvisited[to] = true;\n\t\t\tret ^= dfs(to) + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint x, y;\tcin >> x >> y;\tx--;\ty--;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tvisited[0] = true;\n\tint ret = 0;\n\trep(i, edge[0].size()) {\n\t\tvisited[edge[0][i]] = true;\n\t\tret ^= dfs(edge[0][i]) + 1;\n\t}\n\tcout << (ret ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\nusing ll = long long;\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\ninline T sq(T a) { return a * a; }\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nvector<int> path[100010];\nbool visited[100010];\n\nint dfs(int v) {\n    visited[v] = true;\n    int ret = 0;\n    for (int sv : path[v]) {\n        if (visited[sv]) continue;\n        ret ^= (dfs(sv) + 1);\n    }\n    return ret;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        path[x].push_back(y);\n        path[y].push_back(x);\n    }\n\n    fill(visited, visited + N, false);\n\n    cout << (dfs(0) > 0 ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//作者：中国江苏省南京市李硕睿\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+7;\nvector<int> adj[N];\nint mark[N];\nint nim[N];\nvoid dfs(int v,int p){\n\tfor (auto u:adj[v])\n\t\tif (u!=p){\n\t\t\tdfs(u,v);\n\t\t\tnim[v]^=nim[u]+1;\n\t\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--; \n\t\tv--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\tdfs(0,-1);\n\tcout<<(nim[0] ? \"Alice\" : \"Bob\")<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=400002;\nint n,a,b,i,j,k;\nint h[N],t[N],v[N],sg[N];\nvoid add(int a,int b){\n\tt[++k]=h[a];\n\th[a]=k;\n\tv[k]=b;\n}\nvoid init(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);\n\t\tadd(b,a);\n\t}\n}\nvoid dfs(int i,int fa){\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(v[j]!=fa){\n\t\t\tdfs(v[j],i);\n\t\t\tsg[i]^=sg[v[j]]+1;\n\t\t}\n}\nint main(){\n\tinit();\n\tdfs(1,0);\n\tprintf(\"%s\",sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int N;\n    cin >> N;\n    int c = 0;\n    for(int i = 0; i < (N-1); i++){\n        int a,b;\n        cin >> a >> b;\n        if(a==1){\n            c++;\n        }\n        if(b==1){\n            c++;\n        }\n    }\n    if(c==0){\n         cout << \"Bob\" << \"\\n\";\n    }\n    else if(N%2==c%2){\n        cout << \"Alice\" << \"\\n\";\n    }else{\n        cout << \"Bob\" << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nvector <int> g[N];\n\nint dfs(int v, int pr) {\n  int x = 0;\n  for (int u : g[v]) {\n    if (u == pr) {\n      continue;\n    }\n    x ^= dfs(u, v);\n  }\n  return x + 1;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    x--; y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  printf(\"%s\\n\", dfs(0, -1) == 1 ? \"Bob\" : \"Alice\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(t[i]%2&&b[i]){\n      ans++;\n    r(j,v[i].size()){\n      b[v[i][j]]=1;\n      t[v[i][j]]--;\n    }\n    }\n  }\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int n; cin >> n;\n  vvi g(n);\n  REP(i, n-1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  function<int(int, int)> dfs = [&](int now, int prev) {\n    int res = 0;\n    for(auto &nxt: g[now]) {\n      if(nxt == prev) continue;\n      res ^= dfs(nxt, now) + 1;\n    }\n    return res;\n  };\n\n  int win = dfs(0, -1);\n  cout << (win ? \"Alice\" : \"Bob\") << endl;\n\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=100005;\nint n,h[N],to[N+N],las[N+N],cnt,sg[N];\n\nvoid dfs(int x,int fa)\n{\n\tfor(int i=h[x];i;i=las[i])\n\t    if(to[i]!=fa)\n\t    \tdfs(to[i],x),sg[x]^=(sg[to[i]]+1);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint i,u,v;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlas[++cnt]=h[u],h[u]=cnt,to[cnt]=v;\n\t\tlas[++cnt]=h[v],h[v]=cnt,to[cnt]=u;\n\t}\n\tdfs(1,-1);\n\tif(sg[1])printf(\"Alice\");\n\telse printf(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N;\nint x[100010];\nint y[100010];\nvector<int> V[100010];\nint parent[100010];\n\nvoid make_parent(int v, int p) {\n  parent[v] = p;\n  for (auto x : V[v]) {\n    if (x != p) {\n      make_parent(x, v);\n    }\n  }\n}\n\nint grundy(int v) {\n  int s = V[v].size();\n  if (v == 0) ++s;\n  int ans;\n  if (s == 1) {\n    ans = 0;\n  } else if (s == 2) {\n    for (auto x : V[v]) {\n      if (x != parent[v]) {\n        ans = grundy(x) + 1;\n      }\n    }\n  } else {\n    ans = 0;\n    for (auto x : V[v]) {\n      if (x != parent[v]) {\n        ans ^= (grundy(x) + 1);\n      }\n    }\n  }\n  // cerr << \"grundy(\" << v << \") = \" << ans << endl;\n  return ans;\n}\n\nint main () {\n  cin >> N;\n  for (auto i = 0; i < N-1; ++i) {\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n    V[x[i]].push_back(y[i]);\n    V[y[i]].push_back(x[i]);\n  }\n  make_parent(0, -1);\n  if (grundy(0) == 0) {\n    cout << \"Bob\" << endl;\n  } else {\n    cout << \"Alice\" << endl;    \n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint n;\nvector < int > tree[100005];\n\nbool dfs(int now, int parent);\n\nmain()\n{\n  cin >> n;\n\n  for(int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b; --a, --b;\n    tree[a].push_back(b);\n    tree[b].push_back(a);\n  }\n\n  if(dfs(0, -1)) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n\n  return (0);\n}\n  \nbool dfs(int now, int parent)\n{\n  bool ret = 0;\n  //cout << now + 1 << \" \" << parent + 1 << endl;\n  int cnt = 0; //奇数だとxorする用\n  for(int i = 0; i < tree[now].size(); i++) {\n    if(tree[now][i] != parent) {\n      cnt++;\n    }\n  }\n  for(int i = 0; i < tree[now].size(); i++) {\n    int u = tree[now][i];\n    if(u != parent) {\n      if(cnt == 1) ret |= dfs(u, now);\n      else ret ^= dfs(u, now);\n    }\n  }\n\n  //if(now == 0) cout << ret << endl;\n  if(cnt == 1) ret = true;\n  else if(!ret && cnt % 2) ret ^= true;\n  // cout << \" \" << cnt << \" \" << ret << endl;\n  return (ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nvector <int> V[MAX];\nint nim[MAX];\nint ima[MAX];\n\nint dfs(int node, int pr) {\n  int ret = 0;\n  for (auto it : V[node])\n    if (it != pr) ret ^= 1 + dfs(it, node);\n  return ret;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    V[a].push_back(b);\n    V[b].push_back(a);\n  }\n\n  printf(\"%s\\n\", dfs(1, -1) ? \"Alice\" : \"Bob\");\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define N ((ll)101*1000)\n#define INF ((ll)2e9)\n\nll n;\nvector <ll> e[N];\n\nbool dfs(ll x,ll par=0)\n{\n\tif(((ll)e[x].size()-(x!=1))%2==1)return 1;\n\tll ex=0;\n\tfor(auto u:e[x])\n\t\tif(u!=par)\n\t\t\tex^=dfs(u,x);\n\treturn ex;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll v,u;\n\t\tcin>>v>>u;\n\t\te[v].push_back(u);\n\t\te[u].push_back(v);\n\t}\n\tcout<<((dfs(1))?\"Alice\":\"Bob\")<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::vector;\nusing std::pair;\n\nusing pii = pair<int, int>;\nvector<int> G[10003];\nint cnt[10003];\nvoid go(int idx,int p) {\n\t\n\tfor (auto &to : G[idx]) {\n\t\tif (p == to) continue;\n\t\tcnt[idx] ^= cnt[to] + 1;\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tgo(1,1);\n\tif (cnt[1] == 0) printf(\"Bob\");\n\telse printf(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ninline void Rd(int &res){\n\tchar c;res=0;\n\twhile(c=getchar(),c<'0');\n\tdo{\n\t\tres=(res<<1)+(res<<3)+(c^48);\n\t}while(c=getchar(),c>='0');\n}\nconst int M=100005;\nstruct Node{int to,nxt;}Edge[M<<1];\nint Head[M],tot,n,SG[M];\ninline void Addedge(int a,int b){\n\tEdge[tot]=(Node){b,Head[a]};Head[a]=tot++;\n\tEdge[tot]=(Node){a,Head[b]};Head[b]=tot++;\n}\nvoid dfs(int x,int f){\n\tfor(int i=Head[x];~i;i=Edge[i].nxt){\n\t\tint to=Edge[i].to;\n\t\tif(to==f)continue;\n\t\tdfs(to,x);\n\t\tSG[x]^=(SG[to]+1);\n\t}\n}\nint main(){\n\tRd(n);\n\tmemset(Head,-1,sizeof(Head));\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tRd(a),Rd(b);\n\t\tAddedge(a,b);\n\t}\n\tdfs(1,0);\n\tputs(SG[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint parent[100010];\nvint edge[100010];\nbool visited[100010];\n\nint dfs(int cur) {\n\tif (edge[cur].size() == 1)\treturn 0;\n\tif (edge[cur].size() == 2) {\n\t\tif (visited[edge[cur][0]]) {\n\t\t\tvisited[edge[cur][1]] = true;\n\t\t\treturn dfs(edge[cur][1]) + 1;\n\t\t}\n\t\telse {\n\t\t\tvisited[edge[cur][0]] = true;\n\t\t\treturn dfs(edge[cur][0]) + 1;\n\t\t}\n\t}\n\tint ret = 0;\n\trep(i, edge[cur].size()) {\n\t\tint to = edge[cur][i];\n\t\tif (!visited[to]) {\n\t\t\tvisited[to] = true;\n\t\t\tret ^= dfs(to) + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint x, y;\tcin >> x >> y;\tx--;\ty--;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tvisited[0] = true;\n\tint ret = 0;\n\trep(i, edge[0].size()) {\n\t\tvisited[edge[0][i]] = true;\n\t\tret ^= dfs(edge[0][i]) + 1;\n\t}\n\tcout << (ret ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> g[100005];\n\nint DFS(int u,int root)\n{\n    int rs=0;\n    for(int i=0;i<g[u].size();i++)\n        if(g[u][i]!=root)\n            rs^=DFS(g[u][i],u)+1;\n    return rs;\n}\n\nint main()\n{\n    cin>>n;\n    int u,v;\n    for(int i=1;i<n;i++)\n    {\n        cin>>u>>v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if(DFS(1,-1)>0)\n        cout<<\"Alice\";\n    else\n        cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#include<math.h>\n#include<memory>\n#include<vector>\n#include<bitset>\n#include<fstream>\n#include<stdio.h>\n#include<utility>\n#include<sstream>\n#include<string.h>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nstruct edge\n{\n    int y;\n    edge * next;\n};\nedge * li[100005];\nedge * new_edge()\n{\n    static edge a[200005];\n    static int top=0;\n    return &a[top++];\n}\nvoid inserts(int x,int y)\n{\n    edge * t=new_edge();\n    t->y=y;\n    t->next=li[x];\n    li[x]=t;\n}\nvoid insert_edge(int x,int y)\n{\n    inserts(x,y);\n    inserts(y,x);\n}\nbool vis[100005];\nint dfs(int x)\n{\n    vis[x]=true;\n    edge * t;\n    int ans=0;\n    for (t=li[x];t!=0;t=t->next)\n    {\n        if (vis[t->y]) continue;\n        int x=dfs(t->y);\n        ans^=(x+1);\n    }\n    return ans;\n}\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    int n;\n    scanf(\"%d\",&n);\n    int i;\n    for (i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--;\n        y--;\n        insert_edge(x,y);\n    }\n    if (dfs(0)) puts(\"Alice\"); else puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2017 Mstdream\n#include<bits/stdc++.h>\nusing namespace std;\ninline void splay(int &v){\n\tv=0;char c=0;int p=1;\n\twhile(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();}\n\tv*=p;\n}\nconst int N=400020;\nint nxt[N*2],fir[N],to[N*2],sz,n,dp[N];\nvoid add(int x,int y){\n\tnxt[++sz]=fir[x],fir[x]=sz,to[sz]=y;\n}\n//1先手0后手\nint q[N],fa[N];\nint main(){\n\tsplay(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;splay(x),splay(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tint l=0,r=1;q[1]=1;\n\twhile(l!=r){\n\t\tl++;\n\t\tint v=q[l];\n\t\tfor(int u=fir[v];u;u=nxt[u]){\n\t\t\tif(to[u]!=fa[v]){\n\t\t\t\tq[++r]=to[u];\n\t\t\t\tfa[to[u]]=v;\n\t\t\t}\n\t\t}\n\t}\n\tassert(r==n); \n\tfor(int i=n;i>=1;i--){\n\t\tint x=q[i];\n\t\tint a=0,b=0;\n\t\tfor(int u=fir[x];u;u=nxt[u]){\n\t\t\tif(to[u]!=fa[x]){\n\t\t\t\tif(dp[to[u]]==1)a++;\n\t\t\t\telse b++;\n\t\t\t}\n\t\t}\n\t\tif(b%2==1)dp[x]=1;\n\t\telse{\n\t\t\tif(a%2==1)dp[x]=1;\n\t\t\telse dp[x]=0;\n\t\t}\n\t}\n\tputs(dp[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n\nvector<vector<int> > g;\nvector<int> f;\n\nvoid dfs(int v, int p) {\n\tif (sz(g[v]) == 1 && g[v][0] == p) {\n\t\tf[v] = 0;\n\t\treturn;\n\t}\n\tf[v] = 0;\n\tfor (int to : g[v]) {\n\t\tif (to == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v);\n\t\tf[v] ^= (f[to] + 1);\n\t}\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\n\tint n;\n\tcin >> n;\n\n\tg.resize(n);\n\tf.resize(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u, --v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\tdfs(0, 0);\n\n\tcout << (f[0] ? \"Alice\\n\" : \"Bob\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = (sz(v[u]) - (u ? 1: 0))% 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= d[h] ^ ((sz(v[h])) % 2);\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nvector<int> adj[N];\n\nint dfs(int u, int par)\n{\n    int gr = 0;\n    for (auto v : adj[u])\n        if (v!=par)\n            gr ^= dfs(v, u);\n    return 1 + gr;\n}\n\nint main()\n{\n  //  ios::sync_with_stdio(0);\n  //  cin.tie(0);\n\n    int t;\n    t=1;\n\n    while(t--) {\n        fill(adj, adj+N, vector<int>());\n\n        int n;\n        cin>>n;\n\n        for (int i=1; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        int gr = dfs(1, -1) - 1;\n        cout<<(gr ? \"Alice\\n\" : \"Bob\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\nusing namespace std;\n\nstruct Graph {\n    struct Vertex { int n; };\n    struct Edge { int i, n; };\n    Graph(int n, int m) : v(n, { -1 }), e(m), n(n), m(0) {}\n    void add_edge(int i, int j) {\n        e[m] = { j, v[i].n };\n        v[i].n = m;\n        m++;\n    }\n    int dfs(int i, int p) {\n        int r = 0;\n        for (int j = v[i].n; j >= 0; j = e[j].n) {\n            Edge& o = e[j];\n            if (o.i == p) continue;\n            r ^= dfs(o.i, i) + 1;\n        }\n        return r;\n    }\n    vector<Vertex> v;\n    vector<Edge> e;\n    int n, m;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    Graph g(n, (n - 1) * 2);\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        g.add_edge(x, y);\n        g.add_edge(y, x);\n    }\n\n    cout << (g.dfs(0, -1) != 0 ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,sg[100100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[200100],*tp=pool,*fst[100100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nvoid dfs(int x,int fa)\n{\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->v!=fa)\n            dfs(i->v,x),sg[x]^=sg[i->v]+1;\n}\n\nint main()\n{\n    n=getint();\n    repu(i,2,n)\n    {\n        int u=getint(),v=getint();\n        *tp=(edge){v,fst[u]},fst[u]=tp++;\n        *tp=(edge){u,fst[v]},fst[v]=tp++;\n    }\n    dfs(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n \nusing ll = long long;\nusing P = std::pair<ll, ll>;\n \n#define rep(i, a, b) for (ll(i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" << i << std::endl\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nll pow_mod(ll a, ll b, ll mod=-1) {\n  if ((a == 0)||(mod!=-1&&a%mod==0)) {\n    return 0;\n  }\n \n  ll x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const ll MOD = 998244353;\nconst ll MOD = 1e9 + 7;\n\nll grundy(ll now,ll par,std::vector<std::vector<ll>>& graph){\n  ll val=0;\n  for(ll next:graph[now]){\n    if(next!=par){\n      val^=(1+grundy(next,now,graph));\n    }\n  }\n\n  return val;\n}\n \nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<std::vector<ll>> graph(n);\n\n  rep(i,0,n-1){\n    ll x,y;\n    std::cin>>x>>y;\n    x--;y--;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  ll ans=0;\n\n  for(ll next:graph[0]){\n    ans^=(1+grundy(next,0,graph));\n  }\n\n  if(ans==0)std::cout<<\"Bob\";\n  else std::cout<<\"Alice\";\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        int odd = 0;\n        FORE(e, graph[0]) odd += (dfs(e, 0) + 1) % 2;\n        if (odd == 0) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 3) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 1) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 2) {\n            cout << \"Alice\" << endl;\n        } else {\n            \n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\n#pragma warning(disable:4996)\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MRE assert(0)\nconst int mod = 1000000007;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\ntypedef pair<P, int>PP;\nvector<int>G[100006];\nint dp[100006];\n\nint memo(int now,int par) {\n\tif (dp[now] != inf)return dp[now];\n\tint res = 0;\n\tfor (int e : G[now]) {\n\t\tif (e == par)continue;\n\t\tres ^= (memo(e, now) + 1);\n\t}\n\treturn dp[now] = res;\n\n}\n\nsigned main() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\trep(i, n)dp[i] = inf;\n\tmemo(0, -1);\n\tif (dp[0])puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool used[100001]={};\nvector<int> hen[100001];\nint grundy(int a){\n  used[a]=true;\n  int ans=0;\n  for(int i=0;i<hen[a].size();i++){\n    if(!used[hen[a][i]])ans^=(1+grundy(hen[a][i]));\n  }\n  return ans;\n}\nsigned main() {\nint n;\ncin>>n;\nint a,b;\nfor(int i=0;i<n-1;i++){\n  cin>>a>>b;a--;b--;\n  hen[a].push_back(b);\n  hen[b].push_back(a);\n}\nif(grundy(0))cout<<\"Alice\"<<endl;\nelse cout<<\"Bob\"<<endl;\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[100000];\n\nint dfs(int x, int p) {\n  int g = 0;\n  for (int t : G[x]) {\n    if (t == p) continue;\n    g ^= dfs(t, x);\n  }\n  return g+1;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    G[x].pb(y);\n    G[y].pb(x);\n  }\n  int g = 0;\n  for (int t : G[0]) {\n    g ^= dfs(t, 0);\n  }\n  if (g == 0) cout << \"Bob\\n\";\n  else cout << \"Alice\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, y, G[100005];\nvector <int> v[100005];\nint dfs(int x, int pa){\n\tfor (int i=0; i<v[x].size(); i++)\n\t\tif(v[x][i]!=pa)\n\t\t\tG[x]^=(dfs(v[x][i], x)+1);\n\tif(!v[x].size())return 1;\n\telse return G[x];\n}\nint main(){ \n\tcin>>n;n--;\n\twhile(n--)cin>>x>>y, v[x].push_back(y), v[y].push_back(x);\n\tif(dfs(1, 1))cout<<\"Alice\";\n\telse cout<<\"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nvector <int> E[100010];\nint d[100010];\n\nvoid dfs(int x, int fa = -1) {\n\td[x] = 0;\n\tfor(int e : E[x]) if(e != fa) {\n\t\tdfs(e, x);\n\t\td[x] ^= (d[e] + 1);\n\t}\n}\n\nvoid solve(){\n\tint n; scanf(\"%d\", &n);\n\trep(i, n-1){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y); E[y].pb(x);\n\t}\n\tdfs(1);\n\tputs(d[1] ? \"Alice\" : \"Bob\");\n}\n\nint main(){\n\tint Tc = 1; // scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\t// printf(\"Case #%d: \", tc);\n\t\tsolve();\n\t}\n\treturn 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define lc k << 1\n#define rc k << 1 | 1\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint to, nxt;\n}e[500005];\nint h[100005], cnt;\nint n, m;\nint f[100005], dep[100005], siz[100005], ans;\nvoid addedge(int x, int y){\n\tcnt++; e[cnt].to = y; e[cnt].nxt = h[x]; h[x] = cnt;\n}\nvoid dfs1(int x, int fa){\n\tsiz[x] = 1; f[x] = fa; dep[x] = dep[fa] + 1;\n\tfor(int i = h[x]; i; i = e[i].nxt){\n\t\tif(e[i].to == fa) continue;\n\t\tdfs1(e[i].to, x); siz[x] += siz[e[i].to];\n\t\tans ^= siz[e[i].to];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i ++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\taddedge(x, y);\n\t\taddedge(y, x);\n\t}\n\tdfs1(1, 0);\n\tfor(int i = h[1]; i; i = e[i].nxt){\n\t\tans ^= siz[e[i].to];\n\t//\tprintf(\"%d \", siz[e[i].to]);\n\t}\n\tif(ans == 0){\n\t\tprintf(\"Bob\\n\");\n\t}else{\n\t\tprintf(\"Alice\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long \n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n \n#define y1 what\n\nusing namespace std;\n \nconst int N = (int) 4e5 + 10;\nconst int M = (int) 1e6 + 10;\nconst ll LINF = (ll) 2e18;\nconst int INF = (int) 1e9 + 7;\nconst double EPS = (double) 1e-9;\nconst double PI =  3.14159265359;\n\nint n;\nvector<int> v[N];\nint sz[N];\n\nint dfs(int x, int p = -1) {\n    int sz = 0, ans = 0;\n    for (auto it : v[x]) {\n        if (it != p) {\n            ans ^= dfs(it, x);\n            ++sz;\n        }\n    }\n    return ans + (sz == 1);\n}\n\nint main() {\n    #define fn \"euler\"\n    #ifdef witch                                                            \n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n        //freopen(fn\".in\", \"r\", stdin);\n        //freopen(fn\".out\", \"w\", stdout);\n    #endif      \n    cin >> n;\n    for (int i = 1, x, y; i < n; i++) {\n        cin >> x >> y;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    if (dfs(1)) cout << \"Alice\";\n    else cout << \"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n,x,y,tot=0,sum=0;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tsum++;\n\t\tif(x==1||y==1)tot++;\n\t}\n\tint ans=sum-tot;\n\t\n\tif(tot==1){cout<<\"Alice\";return 0;}\n\tif((tot&1)&&(ans&1)){cout<<\"Bob\";return 0;}\n\tif((!(tot&1))&&(!(ans&1))){cout<<\"Bob\";return 0;}\n\tif((tot&1)&&(!(ans&1))){cout<<\"Alice\";return 0;}\n\tif((!(tot&1))&&(ans&1)){cout<<\"Alice\";return 0;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int maxn = 1000005;\n\nvector<int> G[maxn];\nint sg[maxn];\n\nvoid dfs(int u, int fa)\n{\n    sg[u] = 0;\n    for (auto v : G[u]) {\n        if (v == fa)\n            continue;\n        dfs(v, u);\n        sg[u] ^= sg[v] + 1;\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    dfs(1, 0);\n    printf(\"%s\\n\", sg[1] ? \"Alice\" : \"Bob\");\n    cin >> ws;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2 && false) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int f = 0;\n        FORE(e, ch) f ^= (e & 1);\n        cout << (f ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint kaijo[2000010];\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvoid init_fact(){\n    kaijo[0]=1;\n    for(int i=1;i<=2000000;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nint comb(int a,int b){\n    if(!kaijo[0])init_fact();\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\nint n;\nvector<int>v[100010];\nbool used[100010];\nint G[100010];\nvoid dfs(int x){\n    used[x]=true;\n    if(x&&v[x].size()==1){\n        G[x]=0;\n        return;\n    }\n    if((x==0&&v[x].size()==1)||(x&&v[x].size()==2)){\n        for(int i:v[x]){\n            if(!used[i]){\n                dfs(i);\n                G[x]=G[i]+1;\n            }\n        }\n        return;\n    }\n    for(int i:v[x]){\n        if(!used[i]){\n            dfs(i);\n            G[x]^=(G[i]+1);\n        }\n    }\n}\nsigned main(){\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].pb(b);\n        v[b].pb(a);\n    }\n    dfs(0);\n    if(G[0]==0)puts(\"Bob\");\n    else puts(\"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vpii         vector<pair<int,int>>\n#define gph          map<int, vector<int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define FORS(i, n) for(; i < (int)(n); i++)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define printArr(A,n) { cout << #A << \" = \"; FOR(i,n) cout << A[i] << ' '; cout << endl; }\nusing namespace std;\n#define int long long int\nvi adj[(int)1e5 + 5];\nint dfs(int cur, int P){\n    int xr = 0;\n    int cnt =0;\n    for(int child: adj[cur]){\n        if(child == P)continue;\n        xr ^= (dfs(child, cur) + 1);\n        cnt++;\n    }\n    return xr;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    \n    int n;cin >> n;\n    int x, y;\n    FOR(i, n -1){\n        cin >> x >> y;\n        adj[x].pb(y);\n        adj[y].pb(x);\n    }\n    int ans = dfs(1, -1);\n    if(ans)cout << \"Alice\";\n    else cout << \"Bob\";\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n;\nvector <int> v[N];\nset <int> s[N];\n\nvoid dfs(int node, int pnode){\n    int big = -1;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        dfs(i, node);\n        if(big == -1 || s[i].size() > s[big].size()){\n            big = i;\n        }\n    }\n    if(big != -1) swap(s[node], s[big]);\n    else s[node].insert(1);\n    for(auto &i : v[node]){\n        if(i == pnode || i == big) continue;\n        for(auto &j : s[i]){\n            if(s[node].count(j)) s[node].erase(j);\n            else s[node].insert(j);\n        }\n    }\n    int sz = s[node].size() + 1;\n    s[node].insert(sz);\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    if(s[1].size() == 1) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Graph\n{\n    int n;\n    vector<vector<int>> g;\n    \n    Graph(int n) : n(n){\n        g.resize(n);\n    }\n    \n    void init(int n_){\n        n = n_;\n        g.resize(n_);\n    }\n    \n    void add_edge(int from, int to){\n        g[from].push_back(to);\n    }\n};\n\nstruct Tree\t//create tree(directed) from graph(undirected)\n{\n    int n;\n    int root;\n    vector<vector<int>> t;\n    vector<int> par;\n    vector<int> dpt;\n    \n    void init(Graph &g, int root_){\n        n = g.n;\n        root = root_;\n        t.resize(n);\n        par.resize(n);\n        dpt.resize(n);\n        fill(dpt.begin(), dpt.end(), -1);\n        queue<int> que;\n        par[root] = -1;\n        dpt[root] = 0;\n        que.push(root);\n        while(que.size()){\n            int pa = que.front();\n            que.pop();\n            for(int ch : g.g[pa]){\n                if(dpt[ch] == -1){\n                    t[pa].push_back(ch);\n                    par[ch] = pa;\n                    dpt[ch] = dpt[pa] + 1;\n                    que.push(ch);\n                }\n            }\n        }\n    }\n\n    Tree(){}\n    \n    Tree(Graph &g, int root_){\n        init(g, root_);\n    }\n};\n\nint dfs(Tree &t, int u){\n    int res = 0;\n    for(int v : t.t[u]){\n        res ^= dfs(t, v) + 1;\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for(int i = 0; i < n - 1; i++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        g.add_edge(x, y);\n        g.add_edge(y, x);\n    }\n    Tree t(g, 0);\n    if(dfs(t, 0) != 0) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\n  typedef long long ll;\n  typedef pair<int,int> PII;\n  typedef pair<char,char> PCC;\n  typedef pair<ll,ll> PLL;\n  typedef pair<char,int> PCI;\n  typedef pair<int,char> PIC;\n  typedef pair<ll,int> PLI;\n  typedef pair<int,ll> PIL; \n  typedef pair<ll,char> PLC; \n  typedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\nconst int VMAX =1e5+10;\nvector<vector<int> >G(VMAX);\n\nint dfs(int v, int p){\n  if(p!=-1 && G[v].size()==1) return 1;\n  int count = 0;\n  for(const int & u : G[v]){\n    if(u == p)continue;\n    int d =  dfs(u,v);\n    if(d==0)return 0;\n    count += d;\n  }\n  return (count+1)&1;\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  int V;cin >> V;\n  rep(i,V-1){\n    int x,y;cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  int d = dfs(1,-1);\n  if(d==0)cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\nint dp[MAX];\n\ninline int dfs(int b,int pr=-1){\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tif (go == pr)continue;\n\t\tdfs(go,b);\n\t\tdp[b] += dp[go];\n\t}\n\treturn dp[b];\n}\n\nint main(){\n\tcin >> n;\n\tint non = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif (v[0].size() == 1){\n\t\tputs(\"Alice\");\n\t\treturn 0;\n\t}\n\tdfs(0);\n\tint one = 0;\n\tint ot = 0;\n\tfor (int i = 0; i < v[0].size(); i++){\n\t\tint go = v[0][i];\n\t\tint f = dp[go];\n\t\tif (f == 1){\n\t\t\tone++;\n\t\t}\n\t\telse{\n\t\t\tot++;\n\t\t}\n\t}\n\tif (ot == 0){\n\t\tif (one & 1){\n\t\t\tputs(\"Alice\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"Bob\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n & 1){\n\t\tputs(\"Bob\");\n\t}\n\telse{\n\t\tputs(\"Alice\");\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"math.h\"\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\ntypedef long long int lli;\nvector<int> p[100005];\nint d[100005] = {};\nint cnt[100005] = {};\nvoid dfs(int dep, int cur, int par)\n{\n    d[cur] = dep;\n    for (auto to : p[cur]) {\n        if (to == par)\n            continue;\n        dfs(dep + 1, to, cur);\n    }\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int x, y;\n    rep(i, n - 1)\n    {\n        cin >> x >> y;\n        x--, y--;\n        p[x].push_back(y);\n        p[y].push_back(x);\n    }\n    dfs(0, 0, -1);\n    x = 0;\n    rep(i, n)\n    {\n        cnt[d[i]]++;\n        //cout << d[i] << endl;\n    }\n    for (int i = 1; i <= 100000; i++) {\n        if (cnt[i] & 1)\n            x = 1;\n        //cout << d[i] << endl;\n    }\n    if (x == 0) {\n        cout << \"Bob\" << endl;\n        return 0;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nvector<int> eds[120000];\nint was[120000];\nint n;\n\nint dfs1(int v) {\n    was[v] = 1;\n    int ans = 0;\n    for (int u: eds[v]) {\n        if (!was[u]) {\n            int x = dfs1(u);\n            x += 1;\n            ans ^= x;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        --a, --b;\n        eds[a].push_back(b);\n        eds[b].push_back(a);\n    }\n    int x = dfs1(0);\n    if (x)\n        cout << \"Alice\\n\";\n    else\n        cout << \"Bob\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2016\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nvector<int> adj[MAXN];\nint n, gru[MAXN];\nll val[MAXN];\n\nvoid dfs(int u, int p) {\n\t\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t}\n\t\n\tgru[u] = 0;\n\tint tot = 0;\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\ttot ^= gru[v];\n\t}\n\t\n\tfor (int i=0; i<(n+59)/60; i++) val[i] = 0;\n\t\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\tint now = tot ^ gru[v];\n\t\tval[now/60] |= (1ll << (now % 60));\n\t}\n\t\n\tfor (int i=0; i<(n+59)/60; i++) {\n\t\tif (val[i] != (1ll << i) - 1) {\n//\t\t\tif (u == 3) cout << (val[i] & (1ll << 0)) << endl;\n\t\t\tfor (int j=0; j<60; j++) {\n//\t\t\t\tif (u == 3) cout << (val[i] & (1ll << j)) << endl;\n\t\t\t\tif ((val[i] & (1ll << j)) == 0) {\n\t\t\t\t\tgru[u] = i * 60 + j;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tcin >> n;\n\tfor (int i=0; i<n-1; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\n\tdfs(0, -1);\n\t\n\tif (sz(adj[0]) == 1) cout << \"Alice\";\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i=0; i<sz(adj[0]); i++) {\n\t\t\tans ^= gru[adj[0][i]];\n\t\t}\n\t\tif (ans) cout << \"Alice\";\n\t\telse cout <<\"Bob\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "  ///====================== khela STARTS HERE =====================///\n#include \"bits/stdc++.h\"\nconst int inf = 1000000005;\nconst long long INF = 3e18;\nconst double pi = 2 * acos ( 0.0 );\ntypedef long long ll;\n#define pii pair<int, int>\n#define pb push_back\n#define pf push_front\n#define all(v) v.begin(), v.end()\n#define maximum *max_element\n#define minimum *min_element\n#define MEMSET(v, x) memset(v, x, sizeof(v))\n#define ABS(x) ((x)<0?-(x):(x))\n#define white 1\n#define grey 2\n#define black 3\n#define bug cout << \"ei porjonto thikase\" << endl;\n#define fastread ios_base::sync_with_stdio(false);cin.tie(0);\nusing namespace std;\nint gcd (int a, int b ) {\n    a =  abs( a ); b = abs( b );\n    while ( b ) { a = a % b; swap ( a, b ); } return a;}\nint modInverse(int a, int m)\n{int m0 = m;int y = 0, x = 1;if (m == 1)return 0;\nwhile (a > 1){int q = a / m;int t = m;m = a % m, a = t;t = y;y = x - q * y;x = t;}if (x < 0)x += m0;return x;}\nint lcm(int a, int b)\n{int temp = gcd(a, b);return temp ? (a / temp * b) : 0;}\n///====================== khela end1s HERE =====================///\nvector<int>edges[100005];\nint degree[100005];\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tcin >> n;\n\tMEMSET(degree, 0);\n\tfor(int i=0; i<n-1; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tdegree[x]++;\n\t}\n\tif(degree[1]%2 == 1){\n\t\tcout << \"Alice\" << endl;\n\t}else{\n\t\tcout << \"Bob\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/******************************************\n*    AUTHOR:         CHIRAG AGARWAL       *\n*    INSTITUITION:   BITS PILANI, PILANI  *\n******************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL; \ntypedef long double LD;\nconst int MAX=2e5+5;\nvector<int> adj[MAX];\n\nint st[MAX];\n\nvoid dfs(int s,int p)\n{\n    int cm=0;\n    for(int i=0;i<adj[s].size();i++)\n    {\n        int u=adj[s][i];\n        if(u!=p)\n        {\n            cm++;\n            dfs(u,s);\n            st[s]^=st[u];\n        }\n    }\n    st[s]^=1;   \n}\nint main() \n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    if(adj[1].size()==1)\n    {\n        printf(\"Alice\\n\");\n        return 0;\n    }\n    dfs(1,0);\n   // printf(\"%d\\n\",st[1]);\n    if(st[1]==1)\n    {\n        printf(\"Bob\\n\");\n    }\n    else\n    {\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n, dp[N], d[2];\nvector <int> v[N];\n\nvoid dfs(int node, int pnode, int dep){\n    if(node > 1) d[dep % 2]++;\n    vector <int> all;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        dfs(i, node, dep + 1);\n        all.push_back(dp[i]);\n    }\n    sort(all.rbegin(), all.rend());\n    int cur = 0;\n    if(all.size() > 0) cur = all[0];\n    for(int i = 1 ; i < (int)all.size() ; i++){\n        cur = max(0, cur - all[i]);\n    }\n    dp[node] = cur + 1;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0, 0);\n    if(dp[1] == 1 && d[0] % 2 == 0 && d[1] % 2 == 0) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint n;\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if (g[1].size() == 1)\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        if ((n - 1 - g[1].size()) % 2 != g[1].size() % 2)\n        {\n            cout << \"Alice\" << endl;\n        }\n        else\n        {\n            cout << \"Bob\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=100000;\n\nstruct EDGE{\n\tint from,to,next;\n} e[N*2];\n\nint n,cnt;\nint head[N],f[N];\n\nvoid addedge(int u,int v){\n\te[++cnt].from=u;e[cnt].to=v;e[cnt].next=head[u];\n\thead[u]=cnt;\n}\n\nvoid dfs(int x,int fa){\n\tf[x]=0;\n\tfor (int i=head[x];i;i=e[i].next){\n\t\tif (e[i].to==fa) continue;\n\t\tdfs(e[i].to,x);\n\t\tf[x]^=f[e[i].to]+1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v);addedge(v,u);\n\t}\n\tdfs(1,0);\n\tif (f[1]==0) puts(\"Bob\");else puts(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=5e5+77;\nint es[N],enx[N],e0[N],ep=2;\nint f[N],n;\nvoid f1(int w,int pa){\n\tfor(int i=e0[w];i;i=enx[i]){\n\t\tint u=es[i];\n\t\tif(u!=pa){\n\t\t\tf1(u,w);\n\t\t\tf[w]^=f[u]+1;\n\t\t} \n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,a,b;i<n;++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tes[ep]=b;enx[ep]=e0[a];e0[a]=ep++;\n\t\tes[ep]=a;enx[ep]=e0[b];e0[b]=ep++;\n\t}\n\tf1(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool seen[100010];\nvector<int> adj[100010];\nint n;\nint dfs(int a)\n{\n\tseen[a] = 1;\n\tint winner = 1;\n\tint num = 0;\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!seen[b]) winner ^= dfs(b), num++;\n\t}\n\tif (num == 1) winner = 0;\n\t//printf(\"%d : %d %d\\n\", a, winner, num);\n\treturn winner;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tint res = dfs(1);\n\tif (!res) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n, deg[N], dfstime[N], p[N];\nvector <int> v[N];\nint t;\n\nstruct cmp{\n    bool operator()(const int &l, const int &r) const {\n        return make_pair(dfstime[l], l) < make_pair(dfstime[r], r);\n    }\n};\n\nvoid dfs(int node, int pnode){\n    p[node] = pnode;\n    dfstime[node] = t++;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        dfs(i, node);\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        deg[x]++; deg[y]++;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    set <int, cmp> ready;\n    for(int i = 2 ; i <= n ; i++){\n        if(deg[i] == 1) ready.insert(i);\n    }\n    while(ready.size()){\n        if(ready.size() == 1) finish(\"Alice\");\n        int x = *ready.begin();\n        ready.erase(ready.begin());\n        int y = *ready.begin();\n        ready.erase(ready.begin());\n        for(auto node : {x, y}){\n            if(p[node] == 1) continue;\n            deg[p[node]]--;\n            if(deg[p[node]] == 1) ready.insert(p[node]);\n        }\n    }\n    cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i = (int)(a); i <= (int)(b); i++)\n#define NFOR(i,a,b) for(int i = (int)(a); i >= (int)(b); --i)\n#define endl \"\\n\"\n#define mp make_pair\n#define X first\n#define Y second\n#define inf 1e18\n#define mod 1000000007\n#define pb push_back\n#define Case cout<<\"Case #\"<<++cas<<\": \";\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define all(v) v.begin(),v.end()\n#define sz(x) int(x.size())\n// #define lli int\ntypedef long long int lli;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<lli,lli> pll;\ntypedef vector<lli> vl;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cerr << str << \" : \" << t << \"\\n\";}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cerr << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cerr << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cerr << \", \"; cerr << *i;} cerr << \"]\\n\";}\n\nvi Adj[100010];\nint grundy[100010];\n\nvoid DFS(int u, int p) {\n\tint currNum = 0;\n\tfor (auto v : Adj[u]) {\n\t\tif (v != p) {\n\t\t\tDFS(v, u);\n\t\t\tcurrNum ^= (grundy[v] + 1);\n\t\t}\n\t}\n\tgrundy[u] = currNum;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tFOR(i, 1, n-1) {\n\t\tint a1, b1; cin >> a1 >> b1; Adj[a1].pb(b1), Adj[b1].pb(a1);\n\t}\n\tDFS(1, 0);\n\tif (grundy[1] == 0) {\n\t\tcout << \"Bob\\n\";\n\t} else {\n\t\tcout << \"Alice\\n\";\n\t}\nreturn 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint sun[MAXN];\nint n, g[MAXN], nxt[MAXN << 1], to[MAXN << 1], edgeSize;\nvector<int>G[MAXN];\nvoid addEdge(int u, int v){\n\tnxt[++ edgeSize] = g[u];\n\tto[g[u] = edgeSize] = v;\n}\nint dfs(int x, int f){\n\tint p, s = 0;\n\tfor(int i = 0; i<G[x].size(); i++)\n\tp=G[x][i];\n\t\tif(to[p] != f)\n\t\t\ts ^= dfs(to[p], x) + 1;\n\treturn s;\n}\nint main(){\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t} printf(\"%s\\n\", dfs(1, -1) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nvector<int> edges[110000];\nint dfs(int a, int p){\n\tint ans = 0;\n\tfor(int j = 0; j < edges[a].size(); j++){\n\t\tif(edges[a][j] != p){\n\t\t\tans ^= (1+dfs(edges[a][j],a));\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tcout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> path;\nvector<bool> visited;\n\nint dfs(int v) {\n    visited[v] = true;\n    int ret = 0;\n    for (int sv : path[v]) {\n        if (visited[sv]) continue;\n        ret ^= (dfs(sv) + 1);\n    }\n    return ret;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    path.resize(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        path[x].push_back(y);\n        path[y].push_back(x);\n    }\n\n    visited.assign(N, false);\n    cout << (dfs(0) > 0 ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint n;\nvector<int> es[100000];\n\nint main(int argc, char **argv) {\n\tcin >> n;\n\tREP(i, n - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tes[x].push_back(y);\n\t\tes[y].push_back(x);\n\t}\n\tcout << (es[0].size() == 1 || n % 2 == 0 ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstatic const int MAXN = 100000 + 10;\n\nstruct TreeNode{\n    vector<int> sons;\n} trees[MAXN];\n\nint dfs(int root, int fa) {\n    int cnt = 0;\n    int val = 0;\n    for (int son : trees[root].sons) {\n        if (son == fa) continue;\n        val = val ^ dfs(son, root);\n        cnt++;\n    }\n    if (cnt == 1) return val+1;\n    else return val;\n\n}\n\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    int n;\n    scanf(\"%d\", &n);\n    int x, y;\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        trees[x].sons.push_back(y);\n        trees[y].sons.push_back(x);\n    }\n    int val = dfs(1, 0);\n    if (val > 0) {\n        cout << \"Alice\" << endl;\n    }\n    else cout << \"Bob\" << endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long vlong;\n\n\nvlong deg[500000];\nint main(vlong argc, char const *argv[])\n{\n\tvlong n;\n\tcin >> n;\n\n\tmemset(deg, 0, sizeof deg);\n\n\tfor(vlong i=0; i<n-1; i++){\n\t\tvlong x, y;\n\t\tcin >> x >> y;\n\t\tdeg[x]++;\n\t}\n\n\tif(deg[1]%2 == 1){\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse{\n\t\tcout << \"Bob\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin >> n;\n  int deg = 0;\n  for(int i=0;i<n-1;i++){\n    int x,y;\n    cin >> x >> y;\n    if(x==1 || y==1)\n      deg++;\n  }\n\n  if(deg == 1){\n    cout << \"Alice\" << endl;\n    return 0;\n  }\n\n  if(deg%2 == 0){\n    if(n%2 == 0){\n      cout << \"Alice\" << endl;\n    }\n    else{\n      cout << \"Bob\" << endl;\n    }\n  }\n  else{\n    cout << \"Alice\" << endl;\n  }\n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) ((int) (x).size())\ntypedef long long ll;\n\nconst int N = 123456;\n\nint n;\nvector<int> e[N];\n\nll grundy(int u, int p = -1) {\n    ll g = 0;\n    for (int v: e[u]) {\n        if (v == p) continue;\n        g ^= grundy(v, u);\n    }\n    return g + (p != -1);\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n\n    ll g = grundy(1);\n    puts(g ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> edge[100010];\nint n,sg[100010],u,v;\n\nvoid dfs(int u,int fa)\n{\n    for(auto v : edge[u])\n    {\n        if(v==fa)continue;\n        dfs(v,u);\n        sg[u]^=sg[v]+1;\n    }\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i)\n    {\n        scanf(\"%d%d\",&u,&v);\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1e9 + 7;\n\nint grandy(int r, int v,  vector <int> &gr, vector <vector <pair <int, int> > > &data){\n    if (gr[r] != INF)\n        return gr[r];\n    int s = 0;\n    for (auto elem : data[r]){\n        if (elem.first == v)\n            continue;\n        if (gr[elem.first] == INF)\n            gr[elem.first] = grandy(elem.first, r, gr, data);\n        s = s ^ (gr[elem.first] + 1);\n    }\n    gr[r] = s;\n    return gr[r];\n}\n\nint ffind(int n, int m, int v, vector <int> &gr, vector <vector <pair <int, int> > > &data){\n    for (auto elem : data[n]){\n        if (elem.first == v)\n            continue;\n        //cerr << n + 1 << \" \" << gr[n] << \" \" << m << \" \"  << elem.first + 1 << \" \" << gr[elem.first] + 1 << endl;\n        //cerr << (gr[n] ^ m ^ (gr[elem.first] + 1))<< endl;\n        if ((gr[n] ^ m ^ (gr[elem.first] + 1)) == 0)\n            return elem.second;\n        int x = ffind(elem.first, (gr[n] ^ m ^ (gr[elem.first] + 1)) - 1, n, gr, data);\n        if (x != -1)\n            return x;\n    }\n    return -1;\n}\n\nint main(){\n    int n, r = 1;\n    cin >> n;\n    r--;\n    vector <vector <pair <int, int> > > data(n);\n    \n    for (int i = 0; i < n - 1; i++){\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        data[a].push_back({b, i + 1});\n        data[b].push_back({a, i + 1});\n    }\n    \n    vector <int> gr(n, INF);\n    int x = grandy(r, r, gr, data);\n    \n    /*for (int i = 0; i < n; i++)\n     cerr << gr[i] << \" \";\n     cerr << endl;*/\n    \n    if (gr[r] == 0){\n        cout << \"Bob\";\n        return 0;\n    }\n    \n    cout << \"Alice\" << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"math.h\"\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\ntypedef long long int lli;\nvector<int> p[2000005];\nint d[2000015] = {};\nint cnt[2200016] = {};\nvoid dfs(int dep, int cur, int par)\n{\n    d[cur] = dep;\n    for (auto to : p[cur]) {\n        if (to == par)\n            continue;\n        dfs(dep + 1, to, cur);\n    }\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int x, y;\n    rep(i, n - 1)\n    {\n        cin >> x >> y;\n        x--, y--;\n        p[x].push_back(y);\n        p[y].push_back(x);\n    }\n    dfs(0, 0, -1);\n    x = 0;\n    rep(i, n)\n    {\n        cnt[d[i]]++;\n        //cout << d[i] << endl;\n    }\n    int l = 0;\n    for (int i = 1; i < n; i++) {\n        if (cnt[i] & 1)\n            x = 1;\n        //cout << d[i] << endl;\n    }\n    if (x == 0) {\n        cout << \"Bob\" << endl;\n        return 0;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 20);\n\nint n;\nvector<int> adj[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nint dfs(int u, int pr = -1)\n{\n\tint ans = 0;\n\tfor(int v: adj[u])\n\t\tif(v != pr)\n\t\t\tans ^= dfs(v, u);\n\n\treturn ans + 1;\n}\n\nvoid solve()\n{\n\tint answer = dfs(1) - 1;\n\tif(answer == 0) cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 2e5 + 5 ; \nstruct E {\n\tint to, next ; \n} e[N * 2] ; \nint cnt, head[N], n, sg[N] ; \nvoid add( int x, int y ) {\n\te[++ cnt] = (E){ y, head[x] }, head[x] = cnt,\n\te[++ cnt] = (E){ x, head[y] }, head[y] = cnt ;\n}\nvoid dfs( int x, int fa ) {\n\tsg[x] = 0 ;\n\tNext( i, x ) {\n\t\tint v = e[i].to ; if( v == fa ) continue ; \n\t\tdfs( v, x ), sg[x] ^= ( sg[v] + 1 ) ;\n\t} \n}\nsigned main()\n{\n\tn = gi() ; int x, y ; \n\trep( i, 2, n ) x = gi(), y = gi(), add( x, y ) ;\n\tdfs( 1, 1 ) ; if( sg[1] == 0 ) puts(\"Bob\") ;\n\telse puts(\"Alice\") ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define maxn 100002\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n;\nvector<int> a[maxn];\n\nint grundy(int u, int par) {\n    int res = 0;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (v==par) continue;\n        res ^= (grundy(v, u)+1);\n    }\n    return res;\n}\n\nint main() {\n    //freopen(\"treegame.inp\", \"r\", stdin);\n    //freopen(\"\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    FOR(i, 1, n-1) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v); a[v].push_back(u);\n    }\n    if (grundy(1, 0)==0) printf(\"Bob\");\n    else printf(\"Alice\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<stack>\n#include<queue>\n\n#define REP(i, a, b) for(int i=a; i<b; ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\nvector< vector<int> > tree(100000, vector<int>(0));\n\nint rec(int node, int prev) {\n    //printf(\"now on %d\\n\", node);\n    //printf(\"size = %d\\n\", tree[node].size());\n    if (tree[node].size() % 2 == 0) {\n        return 1;\n    }\n\n    int ans = 0;\n    rep(i, tree[node].size()) {\n        int child = tree[node][i];\n        if (child != prev)\n            ans += rec(child, node);\n    }\n    return ans;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    rep(i, N - 1) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        v1--;\n        v2--;\n        tree[v1].push_back(v2);\n        tree[v2].push_back(v1);\n    }\n    tree[0].push_back(0);\n\n    int res = rec(0, 0);\n    if (res % 2 == 0) {\n        printf(\"Bob\");\n    }else{\n        printf(\"Alice\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nint dp[100000];\nvector<int>E[100000];\nbool used[100000];\nint a[100000];\n\nint dfs(int v) {\n\tused[v] = true;\n\tint res = 0;\n\tset<int>s;\n\tfor (int u : E[v]) {\n\t\tif (!used[u]) {\n\t\t\tres ^= dfs(u);\n\t\t}\n\t\ts.insert(res);\n\t}\n\tfor (int i = 0;; i++) {\n\t\tif (!s.count(i))\n\t\t\treturn a[v]=i;\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n\t\tE[x].push_back(y); E[y].push_back(x);\n\t}\n\tputs(dfs(0) ? \"Bob\" : \"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,first[100010],cnte;\nstruct edge{\n\tint to,next;\n}a[200010];int sg[100010];\ninline void add(int u,int v){\n\ta[++cnte]=(edge){v,first[u]};first[u]=cnte;\n\ta[++cnte]=(edge){u,first[v]};first[v]=cnte;\n}\nvoid dfs(int u,int f){\n\tint i,v;sg[u]=0;\n\tfor(i=first[u];~i;i=a[i].next){\n\t\tv=a[i].to;if(v==f) continue;\n\t\tdfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\nint main(){\n\tmemset(first,-1,sizeof(first));\n\tn=read();int i,t1,t2;\n\tfor(i=1;i<n;i++){\n\t\tt1=read();t2=read();\n\t\tadd(t1,t2);\n\t}\n\tdfs(1,0);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2000000000000000000\n#define ll long long\nusing namespace std;\n\nll grundy(vector<vector<ll>>& connection, vector<bool>& already, ll now) {\n  already.at(now) = true;\n  vector<ll> res;\n  for (ll i = 0; i < connection.at(now).size(); ++i) {\n    ll next = connection.at(now).at(i);\n    if (already.at(next)) {\n      continue;\n    }\n    already.at(next) = true;\n    res.push_back(grundy(connection, already, next));\n  }\n  if (res.size() == 1) {\n    return res.at(0) + 1;\n  }\n  else {\n    ll temp = 0;\n    for (ll i = 0; i < res.size(); ++i) {\n      temp ^= res.at(i);\n    }\n    return temp;\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ll N;\n  cin >> N;\n  vector<vector<ll>> connection(N);\n  vector<bool> already(N, false);\n  for (ll i = 0; i < N - 1; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    x -= 1;y -= 1;\n    connection.at(x).push_back(y);\n    connection.at(y).push_back(x);\n  }\n  ll ans = grundy(connection, already, 0);\n  if (ans == 0) {\n    cout << \"Bob\" << \"\\n\";\n  }\n  else {\n    cout << \"Alice\" << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>; using pcc = pair<char, char>; using pbb = pair<bool, bool>; using pil = pair<int, ll>; using pli = pair<ll, int>; using ti3 = tuple<int, int, int>; using tl3 = tuple<ll, ll, ll>; using td3 = tuple<double, double, double>; using ts3 = tuple<string, string, string>; using tc3 = tuple<char, char, char>; using tb3 = tuple<bool, bool, bool>; using ti4 = tuple<int, int, int, int>; using tl4 = tuple<ll, ll, ll, ll>; using td4 = tuple<double, double, double, double>; using ts4 = tuple<string, string, string, string>; using tc4 = tuple<char, char, char, char>; using tb4 = tuple<bool, bool, bool, bool>; using vi = vector<int>; using vl = vector<ll>; using vd = vector<double>; using vs = vector<string>; using vc = vector<char>; using vb = vector<bool>; using vvi = vector<vi>; using vvl = vector<vl>; using vvd = vector<vd>; using vvs = vector<vs>; using vvc = vector<vc>; using vvb = vector<vb>; using vvvi = vector<vvi>; using vvvl = vector<vvl>; using vvvd = vector<vvd>; using vvvs = vector<vvs>; using vvvc = vector<vvc>; using vvvb = vector<vvb>; using vpii = vector<pii>; using vpll = vector<pll>; using vpdd = vector<pdd>; using vpss = vector<pss>; using vpcc = vector<pcc>; using vpbb = vector<pbb>; using vpil = vector<pil>; using vpli = vector<pli>; using vti3 = vector<ti3>; using vtl3 = vector<tl3>; using vtd3 = vector<td3>; using vts3 = vector<ts3>; using vtc3 = vector<tc3>; using vtb3 = vector<tb3>; using vti4 = vector<ti4>; using vtl4 = vector<tl4>; using vtd4 = vector<td4>; using vts4 = vector<ts4>; using vtc4 = vector<tc4>; using vtb4 = vector<tb4>; using mii = map<int, int>; using mll = map<ll, ll>; using msi = map<string, int>; using mci = map<char, int>; using mil = map<int, ll>; using mli = map<ll, int>; using si = set<int>; using sl = set<ll>; using sd = set<double>; using ss = set<string>; using sc = set<char>; using sb = set<bool>; using spii = set<pii>; using spll = set<pll>; using spdd = set<pdd>; using spss = set<pss>; using spcc = set<pcc>; using spbb = set<pbb>; using spil = set<pil>; using spli = set<pli>; using sti3 = set<ti3>; using stl3 = set<tl3>; using std3 = set<td3>; using sts3 = set<ts3>; using stc3 = set<tc3>; using stb3 = set<tb3>;\n#define rep0(TMS) for (int CNT = 0; CNT < (int)(TMS); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT]; return RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(FLG) cout << (FLG ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(FLG) cout << (FLG ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(FLG) cout << (FLG ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\nconst ll INF = 1'000'000'000'000'000'007;\n// const int INF = 1'000'000'007;\nconst ll MOD = 1'000'000'007; // 998'244'353;\n\n// 方針:\n// 0-indで頂点0を根とする根付き木として考える。\n// 各頂点vに「その頂点以下の頂点から成る部分根付き木(に対応するルールでゲームを行ったとき)のGrundy数を対応させ，G[v]とする。\n// 葉のGrundy数を0とし，葉以外の頂点のGrundy数は「その頂点の(子に対応するGrundy数+1)のxor」とする（ ）。\n// G[0]が答え（ ）。\n\nvoid rec(int u, vvi &g, vi &dis, vi &G) {\t\n\tint Gu = 0;\n\tfor (int v : g[u]) {\n\t\tif (dis[v] != -1) continue;\n\t\tdis[v] = dis[u] + 1;\n\t\trec(v, g, dis, G);\n\t\tGu ^= G[v] + 1;\n\t}\t\n\tG[u] = Gu;\n\t// dbl(u); dbvv(G);\n}\nvoid dfs(int s, vvi &g, vi &dis, vi &G) {\n\tdis[s] = 0;\n\trec(s, g, dis, G);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvvi g(N);\n\trep0(N - 1) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tg[x].push_back(y); g[y].push_back(x);\n\t}\n\tvi dis(N, -1), G(N, -1);\n\tdfs(0, g, dis, G);\n\tif (G[0])\tcout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\n#define MAXN 100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nvector<int> adj[MAXN+5], children[MAXN+5];\nbool visited[MAXN+5];\nint grundy[MAXN+5];\n\nvector<int> dfs()\n{\n    ms(visited,false);\n    stack<int> s;\n    visited[0] = true;\n    s.push(0);\n    vector<int> node_order;\n\n    while (!s.empty()) {\n        int top = s.top(); s.pop();\n        node_order.pb(top);\n        iter(adj[top]) {\n            if (!visited[*it]) {\n                visited[*it] = true;\n                children[top].pb(*it);\n                s.push(*it);\n            }\n        }\n    }\n    return node_order;\n}\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"D.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    int n;\n    read(n);\n    for0(i,n-1) {\n        int u,v;\n        read(u); read(v);\n        u--; v--;\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n\n    vector<int> node_order = dfs();\n    printv(node_order);\n\n    ms(grundy,0);\n    for (int i=sz(node_order)-1; i>=0; i--) {\n        int nd = node_order[i];\n        iter(children[nd]) {\n            grundy[nd] ^= 1+grundy[*it];\n        }\n    }\n    printa(grundy,n)\n\n    if (grundy[0] == 0)\n        cout<<\"Bob\"<<endl;\n    else\n        cout<<\"Alice\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//header\n#ifdef LOCAL\n    #include \"cxx-prettyprint-master/prettyprint.hpp\"\n    #define debug(x) cout << x << endl\n#else\n    #define debug(...) 42\n#endif\n    #pragma GCC optimize(\"Ofast\")\n    #include <bits/stdc++.h>\n    //types\n    using namespace std;\n    using ll = long long;\n    using ld = long double;\n    typedef pair < ll , ll > Pl;\n    typedef pair < int, int > Pi;\n    typedef vector<ll> vl;\n    typedef vector<int> vi;\n    template< typename T >\n    using mat = vector< vector< T > >;\n    template< int mod >\n    struct modint {\n        int x;\n\n        modint() : x(0) {}\n\n        modint(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n        modint &operator+=(const modint &p) {\n            if((x += p.x) >= mod) x -= mod;\n            return *this;\n        }\n\n        modint &operator-=(const modint &p) {\n            if((x += mod - p.x) >= mod) x -= mod;\n            return *this;\n        }\n\n        modint &operator*=(const modint &p) {\n            x = (int) (1LL * x * p.x % mod);\n            return *this;\n        }\n\n        modint &operator/=(const modint &p) {\n            *this *= p.inverse();\n            return *this;\n        }\n\n        modint operator-() const { return modint(-x); }\n\n        modint operator+(const modint &p) const { return modint(*this) += p; }\n\n        modint operator-(const modint &p) const { return modint(*this) -= p; }\n\n        modint operator*(const modint &p) const { return modint(*this) *= p; }\n\n        modint operator/(const modint &p) const { return modint(*this) /= p; }\n\n        bool operator==(const modint &p) const { return x == p.x; }\n\n        bool operator!=(const modint &p) const { return x != p.x; }\n\n        modint inverse() const {\n            int a = x, b = mod, u = 1, v = 0, t;\n            while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n            }\n            return modint(u);\n        }\n\n        modint pow(int64_t n) const {\n            modint ret(1), mul(x);\n            while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n            }\n            return ret;\n        }\n\n        friend ostream &operator<<(ostream &os, const modint &p) {\n            return os << p.x;\n        }\n\n        friend istream &operator>>(istream &is, modint &a) {\n            int64_t t;\n            is >> t;\n            a = modint< mod >(t);\n            return (is);\n        }\n\n        static int get_mod() { return mod; }\n    };\n    //abreviations\n    #define all(x) (x).begin(), (x).end()\n    #define rall(x) (x).rbegin(), (x).rend()\n    #define rep_(i, a_, b_, a, b, ...) for (int i = (a), max_i = (b); i < max_i; i++)\n    #define rep(i, ...) rep_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n    #define rev(i,n) for(int i=n-1;i>=0;i--)\n    #define SZ(x) ((int)(x).size())\n    #define pb(x) push_back(x)\n    #define eb(x) emplace_back(x)\n    #define ff first\n    #define ss second\n    #define mp make_pair\n    #define print(x) cout << x << endl\n    //functions\n    ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n    template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n    template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    template< typename T >\n    T mypow(T x, ll n) {\n        T ret = 1;\n        while(n > 0) {\n            if(n & 1) (ret *= x);\n            (x *= x);\n            n >>= 1;\n        }\n        return ret;\n    }\n    ll modpow(ll x, ll n, const ll mod) {\n        ll ret = 1;\n        while(n > 0) {\n            if(n & 1) (ret *= x);\n            (x *= x);\n            n >>= 1;\n            x%=mod;\n            ret%=mod;\n        }\n        return ret;\n    }\n    uint64_t my_rand(void) {\n        static uint64_t x = 88172645463325252ULL;\n        x = x ^ (x << 13); x = x ^ (x >> 7);\n        return x = x ^ (x << 17);\n    }\n    //graph template\n    template< typename T >\n    struct edge {\n        int src, to;\n        T cost;\n\n        edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n        edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n        edge &operator=(const int &x) {\n            to = x;\n            return *this;\n        }\n        operator int() const { return to; }\n    };\n\n    template< typename T >\n    using Edges = vector< edge< T > >;\n    template< typename T >\n    using WeightedGraph = vector< Edges< T > >;\n    using UnWeightedGraph = vector< vector< int > >;\n\n//constant\n#define INF 1000000000LL\n#define mod 998244353LL\ntypedef modint<mod> mint;\n#define eps 0.0000000000008\n//library\nmat<int> g;\nint grundy(int v, int p){\n    int res = 0;\n    for(auto &nv:g[v]){\n        if(nv == p)continue;\n        res^=grundy(nv, v);\n    }\n    return res+1;\n}\n//main\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(20);\n    int n; cin>>n;\n    g.resize(n);\n    rep(i, n-1){\n        int x, y; cin>>x>>y;\n        g[x-1].pb(y-1);\n        g[y-1].pb(x-1);\n    }\n    if(grundy(0, -1)-1)print(\"Alice\");\n    else print(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define iter(it,a) for(auto it=a.begin();it!=a.end();it++)\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\ntypedef long long ll;\ntypedef long double ld;\n \nint n;\nvector<int> edges[100000+10];\nbool vis[100000+10];\nint val[100000+10];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tint temp = 0;\n\tbool c=1;\n\titer(it,edges[x]){\n\t\tif(!vis[(*it)]){\n\t\t\tdfs((*it));\n\t\t\ttemp^=val[(*it)];\n\t\t\tc=0;\n\t\t}\n\t}\n\tif(c==1){\n\t\tval[x]=1;\n\t}\n\tval[x]=temp+1;\n}\n\nint main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n    cin>>n;\n    int x,y;\n    rep(i,0,n-1){\n    \tcin>>x>>y;\n    \tedges[x].pb(y);\n    \tedges[y].pb(x);\n    }\n    dfs(1);\n    if(val[1]==1){\n    \tcout<<\"Bob\"<<endl;\n    }\n    else{\n    \tcout<<\"Alice\"<<endl;\n    }\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM], w[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, nr = 0;\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n            dfs(v[nod][i], nod);\n        }\n    }\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n           w[++nr] = s[ v[nod][i] ];\n        }\n    }\n    sort(w + 1, w + nr + 1);\n    if(w[1] == 0){\n        for(i = 2; i <= nr; i++){\n            if(w[i] - w[i - 1] > 1){\n                s[nod] = w[i - 1] + 1;\n                break;\n            }\n        }\n        if(i == nr + 1){\n            s[nod] = w[nr] + 1;\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(v[1].size() == 1){\n        cout<<\"Alice\";\n        return 0;\n    }\n    dfs(1, 0);\n    for(i = 2; i <= n; i++){\n        sum ^= s[i];\n    }\n    if(sum == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define SIZE(c) (int) (c).size()\n#define FORE(i,c) FOR(i,0,SIZE(c)-1)\n#define FORDE(i,c) FORD(i,SIZE(c)-1,0)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> pii;\ntypedef pair <ll,ll> pll;\n\ntypedef vector <int> VI;\ntypedef vector <bool> VB;\ntypedef vector <pii> VP;\ntypedef vector <ll> VL;\ntypedef vector <pll> VPL;\n\ntypedef vector <VI> VVI;\ntypedef vector <VL> VVL;\ntypedef vector <VB> VVB;\ntypedef vector <VP> VVP;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000001;\nconst ll LINF = 1000000000000000001LL;\n\nint dfs(int v, int par, VVI &g) {\n    int ans = 0;\n    \n    for (int u : g[v]) if (u != par) {\n        ans ^= (1 + dfs(u, v, g));\n    }\n    \n    return ans;\n}\n\n/*************************************************************************/\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int n;\n    cin >> n;\n    \n    VVI g(n);\n    FOR(i,1,n-1) {\n        int u, v;\n        cin >> u >> v; u--; v--;\n        \n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    \n    cout << (dfs(0, -1, g) ? \"Alice\" : \"Bob\");\n\n    return 0;\n}\n\n/*************************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> edge[1000010];\nint n,poi[1000010],u,v;\n\nvoid dfs(int u,int fa)\n{\n    poi[u]=0;\n    for(auto v : edge[u])\n    {\n        if(v==fa) continue;\n        dfs(v,u);\n        poi[u]^=poi[v]+1;\n    }\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n-1;++i)\n    {\n        scanf(\"%d%d\",&u,&v);\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(poi[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nconst int M = 1e5 + 10;\nvector<int>vc[M];\nint dp[M];\nint dfs(int u , int pre) {\n    int len = vc[u].size();\n    for(int i = 0 ; i < len ; i++) {\n        int v = vc[u][i];\n        if(v == pre) continue;\n        dp[u] ^= dfs(v , u) + 1;\n    }\n    return dp[u];\n}\nint main() {\n    int n;\n    scanf(\"%d\" , &n);\n    for(int i = 1 ; i < n ; i++) {\n        int u , v;\n        scanf(\"%d%d\" , &u , &v);\n        vc[u].push_back(v);\n        vc[v].push_back(u);\n    }\n    memset(dp , 0 , sizeof(dp));\n    if(dfs(1 , -1)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nstruct edge{\n\tint d,nex;\n}e[200010];\nint sg[100010],n,efree,q[100010],mex,a[100010];\ntemplate<class T>\ninline void read(T&a){\n\tchar c=getchar();\n\tfor(a=0;c<'0'||c>'9';c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';\n}\ninline void add(int x,int y){e[++efree]=(edge){y,q[x]};q[x]=efree;}\nvoid dfs(int x,int y,int d){\n\tfor(int i=q[x];i;i=e[i].nex)\n\t\tif(e[i].d!=y)dfs(e[i].d,x,d+1),a[x]+=a[e[i].d];\n\ta[x]++;sg[a[x]]++;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x),read(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0,1);\n\tfor(int i=1;i<n;i++)mex^=sg[i];\n\t\tif(mex){puts(\"Alice\");return 0;}\n\tputs(\"Bob\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\ntemplate<class T>\nvoid read_1d(std::vector<T>& a,int64_t num){\n\ta.reserve(num);\n\tfor(int64_t i1=0;i1<num;i1++){\n\t\tT temp;\n\t\tcin>>temp;\n\t\ta.push_back(temp);\n\t}\n}\ntemplate<class T>\nvoid read_2d(std::vector<std::vector<T> >&a,int64_t x,int64_t y ){\n\ta.resize(x);\n\tfor(int64_t i1=0;i1<x;i1++){\n\t\ta[i1].reserve(y);\n\t\tfor(int64_t i2=0;i2<y;i2++){\n\t\t\tT temp;\n\t\t\tcin>>temp;\n\t\t\ta[i1].push_back(temp);\n\t\t}\n\t}\n}\ntemplate<class InputIterator>\nvoid debug(InputIterator first,InputIterator last){\n\tfor(auto i1=first;i1!=last;i1++){\n\t\tcout<<(*i1)<<endl;\n\t}\n}\n#include <limits>\n#include <vector>\n#include <queue>\nclass Vertex;\nclass Edge{\npublic:\n\tfriend class Vertex;\n\tfriend class Graph;\n\tVertex* from;\n\tVertex* to;\n\tint64_t cost;\npublic:\n\tEdge(Vertex* from,Vertex* to,int64_t cost=0){\n\t\tthis->from=from;\n\t\tthis->to=to;\n\t\tthis->cost=cost;\n\t}\n\n};\nstruct Dijkstra{\n\tint64_t d;\n\tVertex* parent;\n\tbool searched;\n};\n\nclass Vertex{\n\tfriend class Graph;\npublic:\n\n\tstd::vector<Edge*> departure;\n\tstd::vector<Edge*> arrival;\n\tbool searched=false;\n\n\tDijkstra dijk_data;\n\tint32_t id;\n\tbool count_finish=false;\n\tvoid add_edge(Edge* d){\n\t\tdeparture.push_back(d);\n\t\td->to->arrival.push_back(d);\n\t}\n\tvoid initialize_Dijkstra(){\n\t\tdijk_data.d=std::numeric_limits<int64_t>::max();\n\t\tdijk_data.parent=NULL;\n\t\tdijk_data.searched=false;\n\t}\n\tint32_t count_union(Edge* e1,Edge* e2){\n\t\tint32_t retval=1;\n\t\tcount_finish=true;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(temp==e1||temp==e2||temp->to->count_finish){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tretval+=temp->to->count_union(e1,e2);\n\t\t}\n\t\treturn retval;\n\t}\n\tint64_t game(){\n\t\tsearched=true;\n\t\tint64_t size=0;\n\t\tint64_t xor_num=0;\n\t\tint64_t c_ans;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(!temp->to->searched){\n\t\t\t\tsize++;\n\t\t\t\tc_ans=temp->to->game();\n\t\t\t\txor_num=xor_num^c_ans;\n\t\t\t}\n\t\t}\n\t\tif(size==0){\n\t\t\treturn 0;\n\t\t}else if(size==1){\n\t\t\treturn c_ans+1;\n\t\t}else{\n\t\t\treturn xor_num;\n\t\t}\n\t}\n};\nclass dijkstra_calc{\npublic:\n\tint64_t current_cost;\n\tVertex* from;\n\tVertex* to;\n\tdijkstra_calc(const int64_t cost, Vertex* c1,Vertex* c2):current_cost(cost),from(c1),to(c2){\n\n\t}\n};\nbool operator<(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost<b.current_cost;\n}\nbool operator>(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost>b.current_cost;\n}\n\n\nclass Graph{\nprivate:\n\tstd::vector<Vertex*> v;\n\tstd::vector<Edge*> e;\n\tint64_t **WF;\n\tvoid initialize_Dijkstra(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tVertex *temp=(*i);\n\t\t\ttemp->initialize_Dijkstra();\n\t\t}\n\t}\n\tstatic void dijkstra(Vertex* source,Vertex* goal=NULL){\n\t\tstd::priority_queue<dijkstra_calc,std::vector<dijkstra_calc>,std::greater<dijkstra_calc> > queue;\n\t\tqueue.push(dijkstra_calc(0,NULL,source));\n\t\twhile(true){\n\t\t\tconst dijkstra_calc temp=queue.top();\n\t\t\tqueue.pop();\n\t\t\tif(!(temp.to->dijk_data.searched)){\n\t\t\t\ttemp.to->dijk_data.searched=true;\n\t\t\t\ttemp.to->dijk_data.parent=temp.from;\n\t\t\t\ttemp.to->dijk_data.d=temp.current_cost;\n\n\t\t\t\tfor(auto i=temp.to->departure.begin();i!=temp.to->departure.end();i++){\n\t\t\t\t\tconst Edge *j=(*i);\n\t\t\t\t\tif(!j->to->dijk_data.searched){\n\t\t\t\t\t\tdijkstra_calc a(temp.current_cost+(j->cost),j->from,j->to);\n\t\t\t\t\t\tqueue.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.to==goal){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue.empty()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tstatic const int64_t INF=1000000000000000;\n\tGraph(int32_t num_v){\n\t\tv.reserve(num_v);\n\t\tfor(int32_t i1=0;i1<num_v;i1++){\n\t\t\tVertex* temp=new Vertex();\n\t\t\ttemp->id=i1;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\t/*WF=new int64_t*[num_v];\n\t\tfor(int64_t i1=0;i1<num_v;i1++){\n\t\t\tWF[i1]=new int64_t[num_v];\n\t\t}*/\n\t}\n\tvoid add_edge(int32_t from,int32_t to,int32_t cost=0){\n\t\tEdge *temp=new Edge(v[from],v[to],cost);\n\t\te.push_back(temp);\n\t\tv[from]->add_edge(temp);\n\t}\n\tvoid dijkstra(int32_t start){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start]);\n\t}\n\tvoid dijkstra(int32_t start,int32_t goal){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start],v[goal]);\n\t}\n\tint64_t** WarshallFloid(){\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tWF[i1][i2]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(auto i2=v[i1]->departure.begin();i2!=v[i1]->departure.end();i2++){\n\t\t\t\tEdge *temp=(*i2);\n\t\t\t\tif(WF[i1][temp->to->id]>temp->cost){\n\t\t\t\t\tWF[i1][temp->to->id]=temp->cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tWF[i1][i1]=0;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tfor(int64_t i3=0;i3<v.size();i3++){\n\t\t\t\t\tWF[i2][i3]=min(WF[i2][i3],WF[i2][i1]+WF[i1][i3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn WF;\n\t}\n\tVertex* getVertex(int place) const{\n\t\treturn v[place];\n\t}\n\tbool isBridge(Edge* e1,Edge* e2){\n\t\tfor(auto i1=v.begin();i1!=v.end();i1++){\n\t\t\tVertex* temp=(*i1);\n\t\t\ttemp->count_finish=false;\n\t\t}\n\t\tint32_t r=v[0]->count_union(e1,e2);\n\t\treturn v.size()!=r;\n\t}\n\tvector<Edge*> getEdge(){\n\t\treturn e;\n\t}\n\tvirtual ~Graph(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(auto i=e.begin();i!=e.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\t/*for(int64_t i1=0;i1<v.size();i1++){\n\t\t\tdelete[] WF[i1];\n\t\t}\n\t\tdelete[] WF;*/\n\t}\n};\nint main(){\n\tint64_t n;\n\tcin>>n;\n\tGraph graph(n);\n\tfor(int64_t i1=0;i1<n-1;i1++){\n\t\tint64_t temp1,temp2;\n\t\tcin>>temp1>>temp2;\n\t\tgraph.add_edge(temp1-1,temp2-1);\n\t\tgraph.add_edge(temp2-1,temp1-1);\n\t}\n\n\tif(graph.getVertex(0)->game()==0){\n\t\tcout<<\"Bob\"<<endl;\n\t}else{\n\t\tcout<<\"Alice\"<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n//#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e9, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nvector <int> v[N];\n\nint dfs(int x, int y) {\n\tint ans = 0;\n\tfor(auto u : v[x]) \n\t\tif(u != y)\n\t\t\tans ^= (dfs(u, x) + 1);\n\treturn ans;\n}\n\nint32_t main() {\n\tuse_fast;\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tif(dfs(1, 0))\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n\treturn 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n \nint N;\nvector<int> E[101010];\n//---------------------------------------------------------------------------------------------------\nint cnt[101010];\nint dfs(int cu, int pa = -1) {\n    cnt[cu] = 1;\n\n    set<int> ss;\n    int cc = 0;\n    for (int to : E[cu]) if (to != pa) {\n        int g = dfs(to, cu);\n        ss.insert(g);\n        cnt[cu] += cnt[to];\n        cc++;\n    }\n\n    int g = 0;\n    if (cc == 0) g = 1;\n\n    \n    if (cnt[cu] == 1) g = 0;\n    else {\n        while (ss.find(g) != ss.end()) g++;\n    }\n\n    //printf(\"[%d] %d\\n\", cu, g);\n\n    return g;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        rep(i, 0, N + 1) E[i].clear();\n\n        rep(i, 0, N - 1) {\n            int a, b; cin >> a >> b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        int g = 0;\n        for (int to : E[1]) g ^= dfs(to, 1);\n\n        if (g == 0) printf(\"Bob\\n\");\n        else printf(\"Alice\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint n;\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if (g[1].size() == 1)\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        if ((n - 1 - g[1].size()) % 2 == g[1].size() % 2)\n        {\n            cout << \"Alice\" << endl;\n        }\n        else\n        {\n            cout << \"Bob\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing u32 = uint32_t;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n\n\nint main() {\n\t#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n\t#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n;\n\tcin >> n;\n\n\tvvl path(n);\n\tREP(i, n - 1) {\n\t\tll x, y; cin >> x >> y;\n\t\tpath[x - 1].push_back(y - 1);\n\t\tpath[y - 1].push_back(x - 1);\n\t}\n\n\tfunction<ll(ll, ll)> recur = [&](ll cur, ll prev) {\n\t\tll num = 0;\n\t\tfor (ll next : path[cur]) if (next != prev) {\n\t\t\tnum ^= recur(next, cur) + 1;\n\t\t}\n\t\treturn num;\n\t};\n\tcout << (recur(0, -1) != 0 ? \"Alice\" : \"Bob\") << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TASK \"C-large\"\n#pragma comment(linker, \"/STACK:1710886400\")\n#include <stdio.h>\n#include <iostream>\n#include <iomanip> \n#include <math.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <functional>\n#include <assert.h>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <complex>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000007;\nconst long double EPS = 1e-6;\nconst int HASH_POW = 29;\nconst long double PI = acos(-1.0);\nmt19937_64 rnd(1);\n\ndouble workTime() {\n\treturn double(clock()) / CLOCKS_PER_SEC;\n}\n\nvoid my_return(int code) {\n#ifdef MYDEBUG\n\tcout << \"\\nTime = \" << fixed << setprecision(3) << workTime() << endl;\n#endif\n\texit(code);\n}\n\nint n;\nbool used[100010];\nvector <int> G[100010];\n\nint dfs(int v) {\n\tused[v] = true;\n\tint ans = 0;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tint to = G[v][i];\n\t\tif (!used[to]) {\n\t\t\tans ^= dfs(to) + 1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n#ifdef MYDEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#else\n\t/*freopen(TASK\".in\", \"r\", stdin);\n\tfreopen(TASK\".out\", \"w\", stdout);*/\n#endif\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tint res = dfs(1);\n\tif (res != 0) {\n\t\tprintf(\"Alice\\n\");\n\t}\n\telse {\n\t\tprintf(\"Bob\\n\");\n\t}\n\n\tmy_return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>bool chmin(T&a,const T&b){return a>b?(a=b,1):0;}\ntemplate<class T>bool chmax(T&a,const T&b){return a<b?(a=b,1):0;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst int MAX_N = 100000;\nvector<int> g[MAX_N];\nint nim[MAX_N];\n\nint f(int v, int prev) {\n  int x = 0;\n  for (int u : g[v]) if (u != prev) {\n    x ^= f(u, v);\n  }\n  x += 1;\n  // cout << v << \" \" << x << endl;\n  return nim[v] = x;\n}\n\nint main2() {\n  int N = nextInt();\n  REP(i, N) g[i].clear();\n  REP(_, N-1) {\n    int x = nextInt() - 1;\n    int y = nextInt() - 1;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int nim = f(0, -1) - 1;\n  if (nim == 0) cout << \"Bob\" << endl; \n  else cout << \"Alice\" << endl;\n  return 0;\n}\n\nint main() {\n  for (;!cin.eof();cin>>ws) main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    sg[i]=0;\n    set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n    {\n        fsg(g[i][j]);\n        s.insert(sg[g[i][j]]);\n    }\n    for(long j=0,l=s.size();j<l;j++)\n    {\n        if(sg[i]==*s.begin()){s.erase(s.begin());sg[i]++;}\n    }\n}\nint main()\n{\n    long n;\n    cin>>n;\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n    }\n    fsg(1);\n    if(sg[1])cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nusing namespace std;\n\nconst int N=100010;\nint n,x,y;\nvector<int> vec[N];\n\nint dfs(int x,int pa) {\n    int tmp=0;\n    for (int i=0;i<vec[x].size();i++) {\n        if (vec[x][i]==pa) continue;\n        tmp^=(dfs(vec[x][i],x)+1);\n    }\n    return tmp;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++) {\n        scanf(\"%d%d\",&x,&y);\n        vec[x].pb(y);\n        vec[y].pb(x);\n    }\n    int res=dfs(1,0);\n    if (res==0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void ri(int &x){\n\tx=0; static char c; bool t=0;\n\twhile(c=getchar(),c<'0'||c>'9') if(c=='-') t=1; else t=0;\n\tdo x=x*10+c-'0'; while(c=getchar(),c>='0'&&c<='9');\n\tif(t) x=-x;\n}\nconst int N=200024;\nvector<int> Q[N];\nint sg[N];\nvoid dfs(int fa,int x){\n\tint i,l=Q[x].size(),ne;\n\tfor(i=0;i<l;++i){\n\t\tne=Q[x][i];\n\t\tif(ne==fa) continue;\n\t\tdfs(x,ne);\n\t\tsg[x]^=sg[ne]+1;\n\t}\n}\nint main(){\n\tint i,n,x,y; ri(n);\n\tfor(i=1;i<n;++i){\n\t\tri(x); ri(y);\n\t\tQ[x].push_back(y);\n\t\tQ[y].push_back(x);\n\t}\n\tdfs(-1,1);\n\tif(sg[1]==0) puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nint n;\nvector<vi> g;\nint G(int v, int p) {\n\tint val = 0;\n\tfor(auto i : g[v]) {\n\t\tif(i == p) continue;\n\t\tval ^= 1+G(i, v);\n\t}\n\treturn val;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n;\n\tg.resize(n+1);\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\tcout << (G(1, 1)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint SG[100001];\n\nvector<int> e[100001];\n\nvoid dfs(int x,int p){\n\tfor(int it:e[x])\n\t\tif(it!=p){\n\t\t\tdfs(it,x);\n\t\t\tSG[x]^=(1+SG[it]);\n\t\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++)\n\t\tcin>>u>>v,e[u].emplace_back(v),e[v].emplace_back(u);\n\tdfs(1,0);\n\tif(SG[1])\n\t\tcout<<\"Alice\"<<endl;\n\telse\n\t\tcout<<\"Bob\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 101000\nusing namespace std;\nstruct KSD\n{\n    int v,next;\n}e[N<<1];\nint head[N],cnt;\ninline void add(int u,int v)\n{\n    e[++cnt].v=v;\n    e[cnt].next=head[u];\n    head[u]=cnt;\n}\nint n;\nint sg[N];\nvoid dfs(int x,int p)\n{\n    int i,v;\n    sg[x]=0;\n    for(i=head[x];i;i=e[i].next)\n    {\n        v=e[i].v;\n        if(v==p)continue;\n        dfs(v,x);\n        sg[x]^=(sg[v]+1);\n    }\n}\nint main()\n{\n    int i,j,T;\n    int a,b;\n\n\n        cnt=1;\n        memset(head,0,sizeof(head));\n        scanf(\"%d\",&n);\n        for(i=1;i<n;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            add(a,b),add(b,a);\n        }\n        dfs(1,0);\n        if(sg[1])puts(\"Alice\");\n        else puts(\"Bob\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define li long long\n#define ld long double\n#define x first\n#define y second\n#define pt pair<int, int>\n#define pll pair<li, li>\n#define forn(i, t) for(int i = 0; i < (t); i++)\n#define fore(i, f, t) for(int i = (f); i < (t); i++)\n#define forr(i, f, t) for(int i = (f) - 1; i >= (t); i--)\n#define all(x) (x).begin(), (x).end()\n#define ins insert\n\nusing namespace std;\n\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst li INF64 = 1e18;\nconst ld EPS = 1e-7;\n\nmt19937 myrand(time(NULL));\n\nconst int N = 100 * 1000 + 13;\n\nint n;\nvector<int> g[N];\n\n\nbool read(){\n\tif(scanf(\"%d\", &n) != 1)\n\t\treturn 0;\n\tforn(i, n)\n\t\tg[i].clear();\n\tforn(i, n - 1){\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\t--f, --t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\treturn 1;\n}\n\nchar used[N];\nint dp[N];\n\n\nvoid dfs(int v){\n\tused[v] = 1;\n\t\n\tdp[v] = 0;\n\tint cnt = 0;\n\tfor (auto u : g[v])\n\t\tif (!used[u]){\n\t\t\t++cnt;\n\t\t\tdfs(u);\n\t\t\tdp[v] ^= dp[u];\n\t\t}\n\tif (cnt == 1)\n\t\t++dp[v];\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdfs(0);\n\t\n\tprintf(dp[0] ? \"Alice\\n\" : \"Bob\\n\");\n}\n\n\nint main(){\n\t#ifdef _DEBUG\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\twhile(read())\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=1000005;\nint head[maxn],t[maxn<<1],ne[maxn<<1],num,n;\ninline void addedge(int x,int y){\n\tne[++num]=head[x];head[x]=num;t[num]=y;\n\tne[++num]=head[y];head[y]=num;t[num]=x;\n}\nint sg[maxn];\ninline void dfs(int x,int f){\n\tforE(i,x)if(t[i]!=f){\n\t\tdfs(t[i],x);\n\t\tsg[x]^=sg[t[i]]+1;\n\t}\n}\nint main(){\n\tread(n);\n\trep(i,1,n)head[i]=-1;\n\trep(i,1,n-1){\n\t\tint x,y;read(x);read(y);\n\t\taddedge(x,y);\n\t}\n\tdfs(1,-1);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\ntemplate<class T>\nvoid read_1d(std::vector<T>& a,int64_t num){\n\ta.reserve(num);\n\tfor(int64_t i1=0;i1<num;i1++){\n\t\tT temp;\n\t\tcin>>temp;\n\t\ta.push_back(temp);\n\t}\n}\ntemplate<class T>\nvoid read_2d(std::vector<std::vector<T> >&a,int64_t x,int64_t y ){\n\ta.resize(x);\n\tfor(int64_t i1=0;i1<x;i1++){\n\t\ta[i1].reserve(y);\n\t\tfor(int64_t i2=0;i2<y;i2++){\n\t\t\tT temp;\n\t\t\tcin>>temp;\n\t\t\ta[i1].push_back(temp);\n\t\t}\n\t}\n}\ntemplate<class InputIterator>\nvoid debug(InputIterator first,InputIterator last){\n\tfor(auto i1=first;i1!=last;i1++){\n\t\tcout<<(*i1)<<endl;\n\t}\n}\n#include <limits>\n#include <vector>\n#include <queue>\nclass Vertex;\nclass Edge{\npublic:\n\tfriend class Vertex;\n\tfriend class Graph;\n\tVertex* from;\n\tVertex* to;\n\tint64_t cost;\npublic:\n\tEdge(Vertex* from,Vertex* to,int64_t cost=0){\n\t\tthis->from=from;\n\t\tthis->to=to;\n\t\tthis->cost=cost;\n\t}\n\n};\nstruct Dijkstra{\n\tint64_t d;\n\tVertex* parent;\n\tbool searched;\n};\n\nclass Vertex{\n\tfriend class Graph;\npublic:\n\n\tstd::vector<Edge*> departure;\n\tstd::vector<Edge*> arrival;\n\tbool searched=false;\n\n\tDijkstra dijk_data;\n\tint32_t id;\n\tbool count_finish=false;\n\tvoid add_edge(Edge* d){\n\t\tdeparture.push_back(d);\n\t\td->to->arrival.push_back(d);\n\t}\n\tvoid initialize_Dijkstra(){\n\t\tdijk_data.d=std::numeric_limits<int64_t>::max();\n\t\tdijk_data.parent=NULL;\n\t\tdijk_data.searched=false;\n\t}\n\tint32_t count_union(Edge* e1,Edge* e2){\n\t\tint32_t retval=1;\n\t\tcount_finish=true;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(temp==e1||temp==e2||temp->to->count_finish){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tretval+=temp->to->count_union(e1,e2);\n\t\t}\n\t\treturn retval;\n\t}\n\tint64_t game(){\n\t\tsearched=true;\n\t\tint64_t size=0;\n\t\tint64_t xor_num=0;\n\t\tint64_t c_ans;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(!temp->to->searched){\n\t\t\t\tsize++;\n\t\t\t\tc_ans=temp->to->game();\n\t\t\t\txor_num=xor_num^c_ans;\n\t\t\t}\n\t\t}\n\t\tif(size==0){\n\t\t\treturn 0;\n\t\t}else if(size==1){\n\t\t\treturn c_ans+1;\n\t\t}else{\n\t\t\treturn xor_num;\n\t\t}\n\t}\n};\nclass dijkstra_calc{\npublic:\n\tint64_t current_cost;\n\tVertex* from;\n\tVertex* to;\n\tdijkstra_calc(const int64_t cost, Vertex* c1,Vertex* c2):current_cost(cost),from(c1),to(c2){\n\n\t}\n};\nbool operator<(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost<b.current_cost;\n}\nbool operator>(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost>b.current_cost;\n}\n\n\nclass Graph{\nprivate:\n\tstd::vector<Vertex*> v;\n\tstd::vector<Edge*> e;\n\tint64_t **WF;\n\tvoid initialize_Dijkstra(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tVertex *temp=(*i);\n\t\t\ttemp->initialize_Dijkstra();\n\t\t}\n\t}\n\tstatic void dijkstra(Vertex* source,Vertex* goal=NULL){\n\t\tstd::priority_queue<dijkstra_calc,std::vector<dijkstra_calc>,std::greater<dijkstra_calc> > queue;\n\t\tqueue.push(dijkstra_calc(0,NULL,source));\n\t\twhile(true){\n\t\t\tconst dijkstra_calc temp=queue.top();\n\t\t\tqueue.pop();\n\t\t\tif(!(temp.to->dijk_data.searched)){\n\t\t\t\ttemp.to->dijk_data.searched=true;\n\t\t\t\ttemp.to->dijk_data.parent=temp.from;\n\t\t\t\ttemp.to->dijk_data.d=temp.current_cost;\n\n\t\t\t\tfor(auto i=temp.to->departure.begin();i!=temp.to->departure.end();i++){\n\t\t\t\t\tconst Edge *j=(*i);\n\t\t\t\t\tif(!j->to->dijk_data.searched){\n\t\t\t\t\t\tdijkstra_calc a(temp.current_cost+(j->cost),j->from,j->to);\n\t\t\t\t\t\tqueue.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.to==goal){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue.empty()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tstatic const int64_t INF=1000000000000000;\n\tGraph(int32_t num_v){\n\t\tv.reserve(num_v);\n\t\tfor(int32_t i1=0;i1<num_v;i1++){\n\t\t\tVertex* temp=new Vertex();\n\t\t\ttemp->id=i1;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\t/*WF=new int64_t*[num_v];\n\t\tfor(int64_t i1=0;i1<num_v;i1++){\n\t\t\tWF[i1]=new int64_t[num_v];\n\t\t}*/\n\t}\n\tvoid add_edge(int32_t from,int32_t to,int32_t cost=0){\n\t\tEdge *temp=new Edge(v[from],v[to],cost);\n\t\te.push_back(temp);\n\t\tv[from]->add_edge(temp);\n\t}\n\tvoid dijkstra(int32_t start){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start]);\n\t}\n\tvoid dijkstra(int32_t start,int32_t goal){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start],v[goal]);\n\t}\n\tint64_t** WarshallFloid(){\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tWF[i1][i2]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(auto i2=v[i1]->departure.begin();i2!=v[i1]->departure.end();i2++){\n\t\t\t\tEdge *temp=(*i2);\n\t\t\t\tif(WF[i1][temp->to->id]>temp->cost){\n\t\t\t\t\tWF[i1][temp->to->id]=temp->cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tWF[i1][i1]=0;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tfor(int64_t i3=0;i3<v.size();i3++){\n\t\t\t\t\tWF[i2][i3]=min(WF[i2][i3],WF[i2][i1]+WF[i1][i3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn WF;\n\t}\n\tVertex* getVertex(int place) const{\n\t\treturn v[place];\n\t}\n\tbool isBridge(Edge* e1,Edge* e2){\n\t\tfor(auto i1=v.begin();i1!=v.end();i1++){\n\t\t\tVertex* temp=(*i1);\n\t\t\ttemp->count_finish=false;\n\t\t}\n\t\tint32_t r=v[0]->count_union(e1,e2);\n\t\treturn v.size()!=r;\n\t}\n\tvector<Edge*> getEdge(){\n\t\treturn e;\n\t}\n\tvirtual ~Graph(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(auto i=e.begin();i!=e.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\t/*for(int64_t i1=0;i1<v.size();i1++){\n\t\t\tdelete[] WF[i1];\n\t\t}\n\t\tdelete[] WF;*/\n\t}\n};\nint main(){\n\tint64_t n;\n\tcin>>n;\n\tGraph graph(n);\n\tfor(int64_t i1=0;i1<n-1;i1++){\n\t\tint64_t temp1,temp2;\n\t\tcin>>temp1>>temp2;\n\t\tgraph.add_edge(temp1-1,temp2-1);\n\t\tgraph.add_edge(temp2-1,temp1-1);\n\t}\n\tif(graph.getVertex(0)->departure.size()==1){\n\t\tcout<<\"Alice\"<<endl;\n\t}else{\n\t\tif(graph.getVertex(0)->game()==0){\n\t\t\tcout<<\"Bob\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Alice\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nusing LL = long long;\nconst LL LINF = 1e18;\nconst double EPS = 1e-10;\nusing namespace std;\n#define COUT(v) cout<<(v)<<endl\n#define CIN(n)  int(n);cin >> (n)\n#define LCIN(n) LL(n);cin >> (n)\n#define SCIN(n) string(n);cin >> (n)\n#define YES(n) cout<<((n)? \"YES\" : \"NO\")<<endl\n#define Yes(n) cout<<((n)? \"Yes\" : \"No\")<<endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) <<endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define P pair<LL,LL>\n#define I vector<int>\n#define pb(v) push_back(v)\n#define V vector\n#define rt return\n#define rmsame(a) sort(ALL(a)),a.erase(unique(ALL(a)), a.end())\n#define ENDL cout<<endl\n\ntypedef string::const_iterator State;\nclass PalseError {};\nclass Edge{\npublic:\n    int from,to,value;\n    Edge(LL a,LL b,LL c){\n        from = a;\n        to = b;\n        value = c;\n    }\n    Edge(LL a,LL b){\n        from = a;\n        to = b;\n    }\n};\n\nclass UnionFind{\nprivate:\n    vector<int> vec;\npublic:\n    void init(int N){\n        vec.resize(N);\n        for(int a = 0;a < N;a++)\n        {\n            vec[a]=-1;\n        }\n    }\n    int root(int a)\n    {\n        if(vec[a] < 0)return a;\n        else return vec[a] = root(vec[a]);\n    }\n    bool connect(int a,int b)\n    {\n        a = root(a);\n        b = root(b);\n        if(a==b)return false;\n        if(vec[a] > vec[b])swap(a,b);\n        vec[a] += vec[b];\n        vec[b] = a;\n        return true;\n    }\n    bool check(int a,int b){\n        a = root(a);\n        b = root(b);\n        if(a==b)return true;\n        else return false;\n    }\n};\n\nint main(){\n    CIN(N);\n    UnionFind Uni;\n    Uni.init(N);\n    REP(a,N-1){\n        CIN(b);CIN(c);\n        if(b == 1 || c == 1)continue;\n        Uni.connect(b-1,c-1);\n    }\n    map<int,LL> mp;\n    for(int a = 1;a < N;a++){\n        mp[Uni.root(a)]++;\n    }\n    LL a = 0;\n    LL s ;\n    for(auto e : mp){\n        if(a == 0){\n            s = e.second;\n        }else{\n            s = s ^ e.second;\n        }\n        a++;\n    }\n    COUT((s != 0 ? \"Alice\":\"Bob\"));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 見せてやるぜ、奇跡ってやつをよぉ……\n#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst ll MOD = 1000000007;\nconst ll HIGHINF = (ll)1e18;\n\nvvll edges;\n\nll dfs(ll i, ll p) {\n    ll ret = 0;\n    for (ll e: edges[i]) {\n        if (e == p) continue;\n        ret ^= dfs(e, i) + 1;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    edges.resize(n);\n    REP(i, n - 1) {\n        ll x, y; cin >> x >> y;\n        edges[x - 1].emplace_back(y - 1);\n        edges[y - 1].emplace_back(x - 1);\n    }\n\n    ll grun = dfs(0, -1);\n    if (grun == 0) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nint dp[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      //dp[v] += dp[to];\n      dp[v]++;\n    }\n  }\n}\nvoid solve() {\n  //freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (sz(g[1]) == 1) cout << \"Alice\", ioi\n  dfs(1, 1);\n  int res = 0;\n  rep(i, 1, n)\n    res ^= dp[i];\n  if (res) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define MAXN 100010\nint n, head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void $(int u, int v) {\n\tnext[tot] = head[u], to[tot] = v, head[u] = tot++;\n\tnext[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint sg[MAXN];\nvoid dp(int x, int fa) {\n\tsg[x] = 0;\n\tfor (int i = head[x]; ~i; i = next[i]) {\n\t\tif (to[i] == fa) continue;\n\t\tdp(to[i], x);\n\t\tsg[x] ^= sg[to[i]] + 1;\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tmemset(head, -1, sizeof(head));\n\tfor (int i = 1, u, v; i < n; i++) scanf(\"%d%d\", &u, &v), $(u, v);\n\tdp(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int MAX = 1e6 + 10;\ntypedef long long i64;\nusing namespace std;\nconst double EPS = 1e-6;\n\n\n\nvector<int> g[MAX];\nint mark[MAX];\nint dfs(int v, int p){\n\tint grundy= 0;\n\tfor(auto nv: g[v]){\n\t\tif(nv == p)continue;\n\t\tint cur = dfs(nv, v);\n\t\tgrundy ^= cur;\n\t}\n\t\n\treturn grundy + 1;\n}\nint main() {\n\n    #ifdef LOCAL_DEBUG\n    freopen (\"data.in\", \"r\", stdin );\n    //freopen (\"data.out\", \"w\", stdout );\n    #endif\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #define endl '\\n'\n\n\n\tint n; cin >> n;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint a, b; cin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ans = 0;\n\tfor(auto v: g[1]){\n\t\tint cur = dfs(v, 1);\n\t\tans ^= cur;\n\t}\n\n\tif(ans == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,pair<int,int>> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010;\nconst double EPS=1e-9;\nint dx[5]={0,1,0,-1,0};\nint dy[5]={1,0,-1,0,0};\nvector<int> G[100010];\nint dfs(int i,int p){\n    int res=0;\n    for(auto e:G[i]){\n        if(e==p)continue;\n        res^=dfs(e,i)+1;\n    }\n    return res;\n}\nint main(){\n    int n;cin>>n;\n    for(int i=0;i<n-1;i++){\n        int x,y;cin>>x>>y;x--;y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    if(dfs(0,-1)){\n        cout<<\"Alice\"<<endl;\n    }else{\n        cout<<\"Bob\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nvoid read(int &a){\n\ta=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\ta=(a<<1)+(a<<3)+(c^48);\n\t\tc=getchar();\n\t}\n}\nconst int Maxn=100000;\nint n;\nint head[Maxn+5],arrive[Maxn<<1|5],nxt[Maxn<<1|5],tot;\nvoid add_edge(int from,int to){\n\tarrive[++tot]=to;\n\tnxt[tot]=head[from];\n\thead[from]=tot;\n}\nint sg[Maxn+5];\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=nxt[i]){\n\t\tint v=arrive[i];\n\t\tif(v==fa){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tread(u),read(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tif(sg[1]){\n\t\tputs(\"Alice\");\n\t}\n\telse{\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint n;\nvector < int > tree[100005];\n\nbool dfs(int now, int parent);\n\nmain()\n{\n  cin >> n;\n\n  for(int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b; --a, --b;\n    tree[a].push_back(b);\n    tree[b].push_back(a);\n  }\n\n  if(dfs(0, -1)) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n\n  return (0);\n}\n  \nbool dfs(int now, int parent)\n{\n  bool ret = 0;\n  //cout << now + 1 << \" \" << parent + 1 << endl;\n  int cnt = 0; //奇数だとxorする用\n  for(int i = 0; i < tree[now].size(); i++) {\n    if(tree[now][i] != parent) {\n      cnt++;\n    }\n  }\n  for(int i = 0; i < tree[now].size(); i++) {\n    int u = tree[now][i];\n    if(u != parent) {\n      if(cnt == 1) ret |= dfs(u, now);\n      else ret ^= dfs(u, now);\n    }\n  }\n\n  //if(now == 0) cout << ret << endl;\n  if(cnt == 1) ret = true;\n  else if(cnt % 2) ret ^= true;\n  // cout << \" \" << cnt << \" \" << ret << endl;\n  return (ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"math.h\"\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\ntypedef long long int lli;\nvector<int> p[100005];\nint d[100005] = {};\nint cnt[100005] = {};\nvoid dfs(int dep, int cur, int par)\n{\n    d[cur] = dep;\n    for (auto to : p[cur]) {\n        if (to == par)\n            continue;\n        dfs(dep + 1, to, cur);\n    }\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int x, y;\n    rep(i, n - 1)\n    {\n        cin >> x >> y;\n        x--, y--;\n        p[x].push_back(y);\n        p[y].push_back(x);\n    }\n    dfs(0, 0, -1);\n    x = 0;\n    rep(i, n)\n    {\n        cnt[d[i]]++;\n        //cout << d[i] << endl;\n    }\n    for (int i = 1; i <= 5; i++) {\n        if (cnt[i] & 1)\n            x = 1;\n        //cout << d[i] << endl;\n    }\n    if (x == 0) {\n        cout << \"Bob\" << endl;\n        return 0;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2 && false) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int f = 0;\n        FORE(e, ch) f ^= (e & 1);\n        cout << (f | ((N - 1) & 1) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2];\nint i,j,k,l,t,n,m,tot;\nvoid add(int x,int y){\n\tgo[++tot]=y;\n\tnxt[tot]=h[x];\n\th[x]=tot;\n}\nint dfs(int x,int y){\n\tint l=0,t=h[x];\n\twhile (t){\n\t\tif (go[t]!=y) l^=dfs(go[t],x)+1;\n\t\tt=nxt[t];\n\t}\n\treturn l;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tadd(j,k);add(k,j);\n\t}\n\tif (dfs(1,0)) printf(\"Alice\\n\");else printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb push_back\n#define mp std::make_pair\n//#define endl \"\\n\"\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\nusing std::endl;\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\n//const ll MOD=100000;\nconst ll MAX=1e7;\nconst ll INF=(1ll<<50);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nll modpow(ll X,ll Y){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=MOD;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=MOD;\n        }\n    }\n    return ret;\n}\nll fac[MAX],finv[MAX],inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r];\n}\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N; cin>>N;\n    vi cnt(N);\n    vi edge;\n    rep(i,1,N){\n        ll X,Y; cin>>X>>Y;\n        cnt[X-1]++;\n        cnt[Y-1]++;\n        if(X==1) edge.pb(Y-1);\n        if(Y==1) edge.pb(X-1);\n    }\n    string ans=\"Bob\";\n    if(cnt[0]==1) ans=\"Alice\";\n    if(N%2==0) ans=\"Alice\";\n    ll c=0,d=0;\n    rep(i,0,edge.size()){\n        ll X=edge[i];\n        if(cnt[X]==1) c++;\n        if(cnt[X]==2) d++;\n    }\n    if(d==1&&c==1) ans=\"Alice\";\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n, deg[N], d[N], p[N];\nvector <int> v[N];\n\nstruct cmp{\n    bool operator()(const int &l, const int &r) const {\n        return make_pair(d[l], l) > make_pair(d[r], r);\n    }\n};\n\nvoid dfs(int node, int pnode){\n    p[node] = pnode;\n    d[node] = d[pnode] + 1;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        dfs(i, node);\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        deg[x]++; deg[y]++;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    set <int, cmp> ready;\n    for(int i = 2 ; i <= n ; i++){\n        if(deg[i] == 1) ready.insert(i);\n    }\n    while(ready.size()){\n        if(ready.size() == 1) finish(\"Alice\");\n        int x = *ready.begin();\n        ready.erase(ready.begin());\n        int y = *ready.begin();\n        ready.erase(ready.begin());\n        for(auto node : {x, y}){\n            if(p[node] == 1) continue;\n            deg[p[node]]--;\n            if(deg[p[node]] == 1) ready.insert(p[node]);\n        }\n    }\n    cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=gg[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=2e5+50,P=1e9+7,K=5,oo=0x3f3f3f3f;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\n\nint n;\nvector<int> g[N];\nint dfs(int v,int p){\n\tint res=0;\n\tfor(int d:g[v]){\n\t\tif(d!=p){\n\t\t\tint x=dfs(d,v);\n\t\t\tres^=x+1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(int argc,char *argv[]){\n#ifdef CCURIOUSCAT\n\tfreopen(\"dat.in\",\"r\",stdin);\n\tfreopen(\"my.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n); \n\trep(i,1,n-1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u); \n\t}\n\tint res=dfs(1,0);\n\tputs(res!=0?\"Alice\":\"Bob\"); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=100000;\n\nint n,pre[maxn*2+10],now[maxn+10],son[maxn*2+10],tot,f[maxn+10];\n\nint ins(int a,int b)\n{\n  pre[++tot]=now[a];\n  now[a]=tot;\n  son[tot]=b;\n  return 0;\n}\n\nint search(int u,int fa)\n{\n  for(int i=now[u]; i; i=pre[i])\n    {\n      int v=son[i];\n      if(v==fa)\n        {\n          continue;\n        }\n      search(v,u);\n      f[u]^=(f[v]+1);\n    }\n  return 0;\n}\n\nint main()\n{\n  n=read();\n  for(int i=1; i<n; ++i)\n    {\n      int a=read(),b=read();\n      ins(a,b);\n      ins(b,a);\n    }\n  search(1,0);\n  puts(f[1]?\"Alice\":\"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#pragma GCC optimize (\"-O3\")\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <bitset>\n#include <list>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <functional>\n#include <queue>\n#include <regex>\n#include <cassert>\n#include <map>\n#include <type_traits>\n#include <array>\n#include <cassert>\n#include <typeinfo>\n#include <time.h>\n#include <iomanip>\n#include <random>\n#include <sstream>\n#ifdef _MSC_VER\n#include <intrin.h>\n#define popcnt __popcnt64\n//#  define __builtin_popcount __popcnt\n#else\n#define popcnt __builtin_popcountll\n#endif\n//#include \"boost/variant.hpp\"\n\n\n\nusing namespace std;\n\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 60;\n\n#define rep(i, N, M) for(ll i=N, i##_len=(M); i<i##_len; ++i)\n#define rep_skip(i, N, M, ...) for(ll i=N, i##_len=(M); i<i##_len; i+=(skip))\n#define rrep(i, N, M)  for(ll i=(M)-1, i##_len=(N-1); i>i##_len; --i)\n#define pb push_back\n#define fir first\n#define sec second\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define perm(c) sort(all(c));for(bool c##perm=1;c##perm;c##perm=next_permutation(all(c))) //perm(c){write(c)} writes all permutation of c \n\ntypedef pair<double, double> pd;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pll> vpll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<string> vs;\ntemplate<typename T>\nusing pq_greater = priority_queue<T, vector<T>, greater<T>>;\nstruct Point { ll x; ll y; };\nusing vpt = vector<Point>;\n\ntemplate<int n>\nstruct tll_impl {\n\tusing type = decltype(tuple_cat(tuple<ll>(), declval<typename tll_impl<n - 1>::type>()));\n};\ntemplate<>\nstruct tll_impl<1> {\n\tusing type = tuple<ll>;\n};\ntemplate<int n>\nusing tll = typename tll_impl<n>::type;\n\ntemplate<class T>\nconstexpr ll SZ(T& v) { return static_cast<ll>(v.size()); };\n\ntemplate<int n, typename T>\nstruct vec_t_impl {\n\tusing type = vector<typename vec_t_impl<n-1,T>::type>;\n};\ntemplate<typename T>\nstruct vec_t_impl<1,T> {\n\tusing type = vector<T>;\n};\ntemplate<int n, typename T>\nusing vec_t = typename vec_t_impl<n, T>::type;\n// check \nstatic_assert(is_same<vec_t<3,ll>, vector<vector<vector<ll>>>>::value, \"\");\n\n// decompose vector into basetype and dimension.\ntemplate<typename T> \nstruct vec_dec {\n\tstatic constexpr int dim = 0;\n\tusing type  = T;\n};\ntemplate<typename T>\nstruct vec_dec<vector<T>> {\n\tstatic constexpr int dim = vec_dec<T>::dim+1;\n\tusing type  = typename vec_dec<T>::type;\n};\nstatic_assert(is_same<typename vec_dec<vec_t<3, ll>>::type, ll>::value, \"\");\nstatic_assert(vec_dec<vec_t<3, ll>>::dim == 3, \"\");\n\ntemplate<typename T = ll>\nvector<T> makev(size_t a) { return vector<T>(a); }\n\ntemplate<typename T = ll, typename... Ts>\nauto makev(size_t a, Ts... ts) {\n\treturn vector<decltype(makev<T>(ts...))>(a, makev<T>(ts...));\n}\n// ex:  auto dp =  makev<ll>(4,5) => vector<vector<ll>> dp(4,vector<ll>(5));\n\n// check if T is vector\ntemplate < typename T >\nstruct is_vector : std::false_type {};\n\ntemplate < typename T >\nstruct is_vector<vector<T>> : std::true_type {};\nstatic_assert(is_vector<vector<ll>>::value == true && is_vector<ll>::value == false, \"\");\n\n// check if T is vector\ntemplate < typename T>\nstruct is_pair : std::false_type {};\n\ntemplate < typename T, typename S >\nstruct is_pair<pair<T, S>> : std::true_type {};\nstatic_assert(is_pair<pll>::value == true && is_pair<ll>::value == false, \"\");\n\ntemplate<typename T, typename V, typename enable_if<!is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid fill_v(T& t, const V& v) { t = v; }\n\ntemplate<typename T, typename V, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid fill_v(T& t, const V& v) {\n\tfor (auto &&x : t)\n\t\tfill_v(x, v);\n}\n// ex:  fill_v(dp, INF);\n\ntemplate<typename T, typename enable_if < !is_vector<T>::value && !is_pair<T>::value, nullptr_t > ::type = nullptr >\nvoid read(T& x) {\tcin >> x;}\n\ntemplate<typename T, typename enable_if<is_pair<T>::value, nullptr_t>::type = nullptr>\nvoid read(T& x) { read(x.first); read(x.second); }\n\ntemplate<typename T, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid read(T& x) { rep(i,0,x.size()) read(x[i]); }\n\ntemplate<>\nvoid read(Point& p) { cin >> p.x >> p.y; }\n\ntemplate<typename T, typename Delim_t = string, typename enable_if<!is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid write(T& x, Delim_t delim = \" \") { cout << x << delim; }\n\ntemplate<typename T, typename Delim_t = string, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid write(T& x, Delim_t delim = \" \") { rep(i, 0, x.size()) write(x[i], (i == (x.size() - 1) ? \"\" : delim)); cout << '\\n'; }\n\n\n\ntemplate<typename T> void chmin(T &a, T b) {\n\tif (a > b) a = b;\n}\ntemplate<typename T> void chmax(T &a, T b) {\n\tif (a < b) a = b;\n}\n\nvll seq(ll i, ll j) {\n\tvll res(j - i);\n\trep(k, i, j) res[k] = i + k;\n\treturn res;\n}\n\nconstexpr ll POW_0(ll x, ll y) {\n\tif (y == 0)return 1;\n\tif (y == 1)return x ;\n\tif (y == 2)return x * x ;\n\tif (y % 2 == 0)return POW_0(POW_0(x, y / 2), 2LL);\n\treturn ((POW_0(POW_0(x, y / 2), 2LL)) * (x)) ;\n}\n\nconstexpr ll POW(ll x, ll y, ll mod = 0) {\n\tif (mod == 0)return POW_0(x, y);\n\tif (y == 0)return 1;\n\tif (y == 1)return x % mod;\n\tif (y == 2)return x * x % mod;\n\tif (y % 2 == 0)return POW(POW(x, y / 2, mod), 2LL, mod) % mod;\n\treturn ((POW(POW(x, y / 2, mod), 2LL, mod)) * (x % mod)) % mod;\n}\n\ntemplate<\n\ttypename Inputs,\n\ttypename Functor,\n\ttypename T = typename Inputs::value_type>\n\tvoid sort_by(Inputs& inputs, Functor f) {\n\tstd::sort(std::begin(inputs), std::end(inputs),\n\t\t[&f](const T& lhs, const T& rhs) { return f(lhs) < f(rhs); });\n}\n\ntemplate<\n\ttypename Inputs,\n\ttypename Functor,\n\ttypename T = typename Inputs::value_type>\n\tvoid stable_sort_by(Inputs& inputs, Functor f) {\n\tstd::stable_sort(std::begin(inputs), std::end(inputs),\n\t\t[&f](const T& lhs, const T& rhs) { return f(lhs) < f(rhs); });\n}\n\ntemplate<typename Inputs>\nvoid sort_uniq(Inputs& inputs) {\n\tsort(all(inputs));\n\tinputs.erase(unique(all(inputs)), inputs.end());\n}\n\nvector<string> split(const string& s, char delim) {\n\tvector<string> elems;\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, delim)) {\n\t\tif (!item.empty()) {\n\t\t\telems.push_back(item);\n\t\t}\n\t}\n\treturn elems;\n}\n\ntemplate<class T>\nmap<T,ll> inv_map(vector<T>& x) {\n\tmap<T, ll> res;\n\trep(i, 0, x.size()) {\n\t\tres[x[i]] = i;\n\t}\n\treturn res;\n}\ntemplate<class T, class val_t = typename T::value_type, enable_if_t<!is_same<T, set<val_t>>::value >* = nullptr >\nconstexpr bool exist(const T& container, val_t val) { return find(all(container), val) != container.end(); }\ntemplate<class T, class val_t = typename T::value_type,  enable_if_t<is_same<T, set<val_t>>::value >* = nullptr >\nconstexpr bool exist(const T& container, val_t val) { return container.find(val) != container.end(); }\n\n\n\n\n\nstruct UnionFind {\n\tvector<ll> data;\n\tvll querySize_;\n\tset<ll> roots;\n\tUnionFind(ll size) : data(size, -1), querySize_(size, 0) {\n\t\trep(i, 0, size) roots.insert(i);\n\t}\n\n\tll unite(ll x, ll y) {\n\t\t// return: root\n\t\tx = get_root(x); y = get_root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tquerySize_[x] += querySize_[y] + 1;\n\t\t\troots.erase(y);\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tquerySize_[x]++;\n\t\t\treturn x;\n\t\t}\n\t}\n\tbool is_same(ll x, ll y) {\n\t\t// check whether x and y are connected\n\t\treturn get_root(x) == get_root(y);\n\t}\n\tll get_root(ll x) {\n\t\t// get root\n\t\treturn data[x] < 0 ? x : data[x] = get_root(data[x]);\n\t}\n\tll size(ll x) {\n\t\treturn -data[get_root(x)];\n\t}\n\tll  query_size(ll x) {\n\t\treturn querySize_[get_root(x)];\n\t}\n\tconst set<ll>& get_roots() {\n\t\treturn roots;\n\t}\n\tvoid initialize() {\n\t\tfor (auto& i : data) {\n\t\t\ti = -1;\n\t\t}\n\t}\n};\n\n\n\n\ntemplate<class cost_t>\nstruct Edge_Base\n{\n\tll from;\n\tll to;\n\tcost_t cost;\n\tEdge_Base reverse() const { return Edge_Base{ to, from , cost }; }\n\tEdge_Base(ll from , ll to, cost_t cost=1) : from(from),to(to),cost(cost){};\n\tEdge_Base(pll e) :from(e.first), to(e.second), cost(1) { }\n\tEdge_Base() :from(0), to(0), cost(0){ };\n\tbool operator<  (const Edge_Base& e) const {\treturn cost < e.cost; }\n\tbool operator>  (const Edge_Base& e) const {\treturn cost > e.cost; }\n\tbool operator== (const Edge_Base& e) const { return cost == e.cost && from == e.from && to == e.to; }\n};\nusing Edge = Edge_Base<ll>;\n\ntemplate<class EdgeType, class EdgeContainerType>\nstruct Edge_Itr_Base {\n\tconstexpr Edge_Itr_Base() :index(), edges(nullptr) {}\n\tconstexpr Edge_Itr_Base(ll index, EdgeContainerType& edges_) :index(index), edges(&edges_) {}\n\tconstexpr Edge_Itr_Base& operator++() { ++index; return *this; }\n\tconstexpr bool operator==(const Edge_Itr_Base& rhs) const { return index == rhs.index; }\n\tconstexpr bool operator!=(const Edge_Itr_Base& rhs) const { return index != rhs.index; }\n\tconstexpr EdgeType* operator->() const { return &(*edges)[index]; }\n\tconstexpr EdgeType& operator*() const { return (*edges)[index]; }\n\tconstexpr Edge_Itr_Base& operator+=(ll n) { index += n; return *this; }\n\tll index;\n\tEdgeContainerType* edges;\n};\n\n\n\nauto nullAction = [](const auto&) {};\n\ntemplate<class cost_t>\nstruct Graph_Base {\n\tusing Edge = Edge_Base<cost_t>;\n\tusing Edge_Itr = Edge_Itr_Base<Edge_Base<cost_t>, vector<Edge_Base<cost_t>>>;\n\tusing Edge_CItr = Edge_Itr_Base<const Edge_Base<cost_t>, const vector<Edge_Base<cost_t>>>;\n\n\tll nodeSize;\n\tvector<Edge> edges;\n\tvector<vector<Edge_Itr>> out_edges;\n\tvector<vector<Edge_Itr>> in_edges;\n\tenum Dir{dir, undir};\n\tGraph_Base(ll nodeSize, const vector<Edge>& edges_ = vector<Edge>(), Dir dirct= dir)\n\t\t: nodeSize(nodeSize), out_edges(nodeSize), in_edges(nodeSize){\n\t\tif (dirct == undir) {\n\t\t\tfor (const Edge& e : edges_) push_undir(e);\n\t\t}\n\t\telse {\n\t\t\tfor (const Edge& e : edges_) push(e);\n\t\t}\n\t}\n\tGraph_Base(ll nodeSize, vector<pll> edges_, Dir dirct = dir)\n\t\t: nodeSize(nodeSize), out_edges(nodeSize), in_edges(nodeSize){\n\t\tif (dirct == undir) {\n\t\t\tfor (const pll& e : edges_) push_undir(Edge(e));\n\t\t}\n\t\telse {\n\t\t\tfor (const pll& e : edges_) push(Edge(e));\n\t\t}\n\t}\n\tGraph_Base(vvll ajacency_matrix, ll default_value) \n\t\t: nodeSize(ajacency_matrix.size()), out_edges(nodeSize), in_edges(nodeSize){\n\t\tll n = ajacency_matrix.size();\n\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (ajacency_matrix[i][j] != default_value)\n\t\t\t\tpush(Edge(i, j, ajacency_matrix[i][j]));\n\t\t}\n\t}\n\t\n\tEdge& operator[](ll ind) { return this->edges[ind]; } \n\tconst Edge& operator[](ll ind) const{ return this->edges[ind]; }\n\tvector<Edge_Itr>& out(ll ind){ return this->out_edges[ind]; }\n\tconst vector<Edge_Itr>& out(ll ind) const { return this->out_edges[ind]; }\n\tvector<Edge_Itr>& in(ll ind){ return this->in_edges[ind]; }\n\tconst vector<Edge_Itr>& in(ll ind) const{ return this->in_edges[ind]; }\n\tEdge_Itr begin() { return Edge_Itr(0, edges); }\n\tEdge_Itr end() { return Edge_Itr(edges.size(), edges); }\n\tEdge_CItr begin() const { return Edge_CItr(0, edges); }\n\tEdge_CItr end() const { return Edge_CItr(edges.size(), edges); }\n\n\tll size() const { return nodeSize; }\n\tll sizeEdges() const { return edges.size(); }\n\n\tvoid push(const Edge& edge){\n\t\tassert(max(edge.from, edge.to) < nodeSize);\n\t\tedges.emplace_back(edge);\n\t\tout_edges[edge.from].emplace_back(Edge_Itr(edges.size()-1,edges));\n\t\tin_edges[edge.to].emplace_back(Edge_Itr(edges.size() - 1, edges));\n\t}\n\tvoid push(const Edge& edge, Graph_Base::Dir dir) {\n\t\tif (dir == Dir::undir)\n\t\t\tpush_undir(edge);\n\t\telse\n\t\t\tpush(edge);\n\t}\n\tvoid push_undir(const Edge& edge) {\n\t\tpush(edge); push(edge.reverse());\n\t}\n\tvoid push(vector<Edge> edges) {\n\t\tfor (const Edge& e : edges) {\n\t\t\tpush(e);\n\t\t}\n\t}\n\tvvll adjacency_matrix() const {\n\t\tvvll d(size(), vll(size()));\n\t\tfor (auto& e : edges) {\n\t\t\td[e.from][e.to] = e.cost;\n\t\t}\n\t\treturn d;\n\t}\n\n\tvll get_topologically_sorted_nodes() const\n\t{\n\t\t// graph needs to be represented by adjacent list.\n\t\t// complexity: O( node size + edge size)\n\t\tll nodeSize = this->size();\n\n\t\t// find root\n\t\tvll roots;\n\t\tvll inDegree(nodeSize);\n\t\trep(i, 0, nodeSize)\n\t\t{\n\t\t\tfor (auto& sibling : this->out(i)) {\n\t\t\t\tinDegree[sibling->to]++;\n\t\t\t}\n\t\t}\n\t\trep(i, 0, nodeSize) {\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\troots.push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tstack<ll> parents;\n\t\tfor (ll i : roots)\n\t\t\tparents.push(i);\n\n\t\tvll sortedNodes;\n\t\twhile (!parents.empty()) {\n\t\t\tll parent = parents.top();\n\t\t\tparents.pop();\n\t\t\tsortedNodes.push_back(parent);\n\t\t\tfor (auto& sibling : this->out(parent)) {\n\t\t\t\tinDegree[sibling->to]--;\n\t\t\t\tif (inDegree[sibling->to] == 0) {\n\t\t\t\t\tparents.push(sibling->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sortedNodes;\n\t}\n\n\tvoid topological_sort() {\n\t\tvll sorted = get_topologically_sorted_nodes();\n\t\tvll new_ind(sorted.size());\n\t\tvector<Edge> new_edges;\n\t\trep(i, 0, sorted.size()) {\n\t\t\tnew_ind[sorted[i]] = i;\n\t\t}\n\t\tfor (Edge& e : edges) {\n\t\t\tnew_edges.emplace_back(Edge{ new_ind[e.from], new_ind[e.to],e.cost });\n\t\t}\n\t\t*this = Graph_Base(this->size(), new_edges);\n\t}\n\tcost_t diameter() const\n\t{\n\t\t// require : graph is tree\n\t\t// calculate the diameter ( longest path length ) in O(N)\n\t\tvector<cost_t> dp(size(), -1);\n\t\tcost_t m = 0; ll ind;\n\t\tfunction<void(ll)> dfs = [&](ll x) {\n\t\t\tfor (auto& e : out(x)) {\n\t\t\t\tll nextnode = e->to;\n\t\t\t\tif (dp[nextnode] == -1) {\n\t\t\t\t\tdp[nextnode] = dp[x] + e->cost;\n\t\t\t\t\tif (dp[nextnode] > m) {\n\t\t\t\t\t\tm = dp[nextnode];  ind = nextnode;\n\t\t\t\t\t}\n\t\t\t\t\tdfs(nextnode);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdp[0] = 0; ind = 0;\n\t\tdfs(0);\n\t\tll first = ind;\n\t\tfill_v(dp, -1);\n\t\tdp[first] = 0;\n\t\tdfs(first);\n\t\treturn m;\n\t\t// remark two end points of diameter are 'first' and 'ind';\n\t}\n\n\tvll leaves() const {\n\t\tvll res;\n\t\trep(i, 0, nodeSize) {\n\t\t\tif (out(i).size() <= 1)\n\t\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid dfs(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\t// Impliment func: void(const Edge&) representing what this should do, when target node moves from visited node (e.from) to unvisited node (e.to).\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto dfs_impl = [&](auto dfs_impl, ll startNode)-> void {\n\t\t\tvisited[startNode] = 1;\n\t\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\t\tif (visited[e->to])\n\t\t\t\t\tcontinue;\n\t\t\t\tbefore_act(*e);\n\t\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t\t\tafter_act(*e);\n\t\t\t}\n\t\t};\n\t\tdfs_impl(dfs_impl, startNode);\n\n\t};\n\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid dfs_node(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\t// Impliment func: void(ll node_ind) representing what this should do, when target node moves from visited node to unvisited node (node_ind).\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto dfs_impl = [&](auto dfs_impl, ll startNode)-> void {\n\t\t\tbefore_act(startNode);\n\t\t\tvisited[startNode] = 1;\n\t\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\t\tif (visited[e->to])\n\t\t\t\t\tcontinue;\n\t\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t\t}\n\t\t\tafter_act(startNode);\n\t\t};\n\t\tdfs_impl(dfs_impl, startNode);\n\t};\n\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid bfs(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto bfs_impl = [&](ll startNode) {\n\t\t\t//if (visited[startNode] != 0) return;\n\t\t\tvisited[startNode] = 1;\n\t\t\tqueue<Edge> toVisit;\n\t\t\tfor (auto& e : graph.out(startNode))\n\t\t\t\ttoVisit.push(*e);\n\t\t\twhile (toVisit.size()) {\n\t\t\t\tauto next = toVisit.front(); toVisit.pop();\n\t\t\t\tif (visited[next.to])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[next.to] = 1;\n\t\t\t\tbefore_act(next);\n\t\t\t\tfor (auto& e : graph.out(next.to)) {\n\t\t\t\t\tif (!visited[e->to])\n\t\t\t\t\t\ttoVisit.push(*e);\n\t\t\t\t}\n\t\t\t\tafter_act(next);\n\t\t\t}\n\t\t};\n\t\tbfs_impl(startNode);\n\t};\n\t\n\tvector<cost_t> dijkstra(ll start) const {\n\t\tvector<cost_t> fromList;\n\t\treturn dijkstra(start, fromList);\n\t}\n\n\tvector<cost_t> dijkstra(ll start, vector<cost_t>& from_list) const {\n\t\t// graph: weighted directed graph of adjacent representation\n\t\t// start: index of start point\n\t\t// return1: minimum path length from start\n\t\t// complexity : E*log(V)\n\t\tconst auto& graph = *this;\n\t\tll node_size = graph.size();\n\t\tvector<cost_t> dist(node_size, INF);\n\t\tfrom_list.resize(node_size);\n\t\tfill_v(from_list, -1);\n\t\tdist[start] = 0;\n\t\tpq_greater<pair<cost_t, pll>> pq;\n\t\tpq.push({ 0, {start, start} });\n\t\twhile (!pq.empty()) {\n\t\t\tauto node = pq.top(); pq.pop();\n\t\t\t// if not shortest path fixed, fix\n\t\t\tll from = node.second.first;\n\t\t\tll to = node.second.second;\n\t\t\tif (from_list[to] != -1)\n\t\t\t\tcontinue;\n\t\t\tfrom_list[to] = from;\n\n\t\t\tfor (auto& edge : graph.out(to)) {\n\t\t\t\tll adj = edge->to;\n\t\t\t\tcost_t cost = dist[to] + edge->cost;\n\t\t\t\tif (dist[adj] > cost) {\n\t\t\t\t\tdist[adj] = min(dist[adj], cost);\n\t\t\t\t\tpq.push({ cost ,{to, adj} });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tvll euler_tour(ll start) const\n\t{\n\t\tvll res;\n\t\tres.push_back(start);\n\t\tdfs(start, [&](const Edge& e) {\n\t\t\tres.push_back(e.to);\n\t\t\t}, [&](const Edge& e) {\n\t\t\t\tres.push_back(e.from);\n\t\t\t});\n\t\treturn res;\n\t}\n\n\tGraph_Base kruskal(Graph_Base::Dir = Dir::undir) const\n\t{\n\t\t//returns minimal spanning tree\n\t\tGraph_Base res(nodeSize);\n\t\tvpll sortedEdges;\n\t\trep(i, 0, edges.size()) {\n\t\t\tsortedEdges.push_back({ edges[i].cost, i });\n\t\t}\n\t\tsort(all(sortedEdges));\n\t\tUnionFind uf(nodeSize);\n\t\trep(i, 0, sortedEdges.size()) {\n\t\t\tll cost, eInd;\n\t\t\ttie(cost, eInd) = sortedEdges[i];\n\t\t\tll from = (*this)[eInd].from; ll to = (*this)[eInd].to;\n\t\t\tif (!uf.is_same(from, to)) {\n\t\t\t\tres.push((*this)[eInd], dir);\n\t\t\t}\n\t\t\tuf.unite(from, to);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvvll warshall_floyd() const {\n\t\t// O(|V|^3)\n\t\tconst Graph_Base& g = *this;\n\t\tll n = g.size();\n\t\tvvll d = g.adjacency_matrix();\n\t\trep(k, 0, n)rep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (d[i][j] > d[i][k] + d[k][j])\n\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t}\n\t\treturn d;\n\t}\n\n\tvll bellman_ford(ll start, ll negative_closed_loop_value = -INF) const {\n\t\tvll from_list;\n\t\treturn bellman_ford(start, from_list, negative_closed_loop_value);\n\t}\n\n\tvll bellman_ford(ll start, vll& from_list, ll negative_closed_loop_value = -INF) const {\n\t\t// O(|E| * |V|)\n\t\tconst Graph_Base& g = *this;\n\t\tvll dist(g.size(), INF);\n\t\tdist[start] = 0;\n\t\tfrom_list.resize(g.size());\n\t\trep(i, 0, g.size()) {\n\t\t\tfor(const Edge& e: g){\n\t\t\t\tif (dist[e.from] != INF && dist[e.to] > dist[e.from] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\tfrom_list[e.to] = e.from;\n\t\t\t\t\tif (i == g.size() - 1 && dist[e.to] != INF) {\n\t\t\t\t\t\t// check negative closed loop\n\t\t\t\t\t\tdist[e.to] = negative_closed_loop_value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// propagate negative path\n\t\trep(i, 0, g.size()) {\n\t\t\trep(j, 0, g.edges.size()) {\n\t\t\t\tauto& e = g.edges[j];\n\t\t\t\tif (dist[e.from] == negative_closed_loop_value && dist[e.from] != INF)\n\t\t\t\t\tdist[e.to] = negative_closed_loop_value;\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tbool is_bipartite() const {\n\t\tvll even(size(),-1);\n\t\teven[0] = 0;\n\t\tbool ok = true;\n\t\tdfs_node(0,\n\t\t\t[&](ll node) {\n\t\t\t\tfor (auto& e : out(node)) {\n\t\t\t\t\tif (even[e->to] != -1 ) {\n\t\t\t\t\t\tif (even[e->from] == even[e->to]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\teven[e->to] = !even[e->from];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\treturn ok;\n\t}\n};\n\nusing Graph = Graph_Base<ll>;\n\nvll shortest_path_generator(const vll& from_list, ll start, ll goal) {\n\t// usage : vll path =  shortest_path(dijkstra(g,s).second, s, g);\n\tvll path;\n\tpath.emplace_back(goal);\n\twhile (true) {\n\t\tll from = from_list[goal];\n\t\tpath.emplace_back(from);\n\t\tif (from == start) {\n\t\t\tbreak;\n\t\t}\n\t\tgoal = from;\n\t}\n\treverse(all(path));\n\treturn path;\n}\n\nclass FordFulkerson {\nprivate:\n\tvb usedNode;\n\tusing Edge = Edge_Base<ll>;\npublic:\n\tstruct RevEdge { ll from, to, cap, rev; };\n\n\tFordFulkerson(Graph graph) \n\t\t:usedNode(graph.size()), G(vec_t<2,RevEdge>(graph.size()))\n\t{\n\t\trep(i, 0, graph.size()) {\n\t\t\tfor (auto& e : graph.out(i)) {\n\t\t\t\tadd_revedge(*e);\n\t\t\t}\n\t\t}\n\n\t}\n\tvec_t<2, RevEdge> G;\n\tvoid add_revedge(const Edge& e) {\n\t\tG[e.from].push_back(RevEdge{ e.from, e.to ,e.cost, SZ(G[e.to]) });\n\t\tG[e.to].push_back(RevEdge{ e.to, e.from, 0 , SZ(G[e.from]) - 1 });\n\t}\n\t\n\tll single_flow(ll from, ll to, ll flow) {\n\t\t// make a single flow\n\t\tif (from == to)\n\t\t\treturn flow;\n\t\tusedNode[from] = 1;\n\t\trep(i, 0, G[from].size()) {\n\t\t\tRevEdge& e = G[from][i];\n\t\t\tif (usedNode[e.to] || e.cap <= 0)\n\t\t\t\tcontinue;\n\t\t\tll flow_from_e = single_flow(e.to, to, min(flow, e.cap));\n\t\t\tif (flow_from_e > 0) {\n\t\t\t\te.cap -= flow_from_e; assert(e.cap >= 0);\n\t\t\t\tG[e.to][e.rev].cap += flow_from_e;\n\t\t\t\t// get a larger flow\n\t\t\t\treturn flow_from_e;\n\t\t\t}\n\t\t}\n\t\t// if we already visited all edges or cap = 0 flow = 0;\n\t\treturn 0;\n\t}\n\tll max_flow(ll from, ll to) {\n\t\tll flow = 0;\n\t\twhile (true) {\n\t\t\tfill_v(usedNode, 0);\n\t\t\tll f = single_flow(from, to, INF);\n\t\t\tif (f == 0)\n\t\t\t\treturn flow;\n\t\t\telse\n\t\t\t\tflow += f;\n\t\t}\n\t}\n};\n\n// Least Common Ancestor\nclass LCA {\npublic:\n\tLCA(const Graph& graph, ll root) : max_par(ceil(log2(graph.size()) + 2)), parent(graph.size(), vll(max_par,-1)),\n\t\tdepth() {\n\t\t//parent[root][0] = root;\n\t\tgraph.dfs(root, [&](const Edge & e) {\n\t\t\tll to = e.to;\n\t\t\tparent[to][0] = e.from;\n\t\t\trep(i, 1, parent[to].size()) {\n\t\t\t\tif (parent[to][i - 1] == -1)\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\tparent[to][i] = (parent[parent[to][i - 1]][i - 1]);\n\t\t\t}\n\t\t});\n\t\tdepth = graph.dijkstra(root);\n\t}\n\tll operator()(ll node1, ll node2) {\n\t\tif (depth[node1] > depth[node2]) swap(node1, node2);\n\t\trrep(i, 0, max_par) {\n\t\t\tif (((depth[node2] - depth[node1]) >> i) & 1) {\n\t\t\t\tnode2 = parent[node2][i];\n\t\t\t}\n\t\t}\n\t\tif (node1 == node2)return node1;\n\t\trrep(i, 0, max_par) {\n\t\t\tif (parent[node1][i] != parent[node2][i]) {\n\t\t\t\tnode1 = parent[node1][i];\n\t\t\t\tnode2 = parent[node2][i];\n\t\t\t}\n\t\t}\n\t\treturn parent[node1][0];\n\t}\nprivate:\n\tll max_par;\n\tvvll parent;\n\tvll depth;\n};\n\nclass BipartiteMatching {\n\t// O(V*E)\n\tint n, left, right;\n\tvector< vector< int > > graph;\n\tvector< int > used;\n\tint timestamp;\npublic:\n\tBipartiteMatching(int left, ll right) : n(left+right), left(left), right(right), graph(n), used(n, 0), timestamp(0){}\n\n\tvoid push(int u, int v) {\n\t\tgraph[u].push_back(v + left);\n\t\tgraph[v + left].push_back(u);\n\t}\n\n\tbool dfs(int idx, vector<int>& match) {\n\t\tused[idx] = timestamp;\n\t\tfor (auto& to : graph[idx]) {\n\t\t\tint to_match = match[to];\n\t\t\tif (to_match == -1 || (used[to_match] != timestamp && dfs(to_match, match))) {\n\t\t\t\tmatch[idx] = to;\n\t\t\t\tmatch[to] = idx;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_match(vector<int>& match) {\n\t\tmatch.resize(n); fill_v(match, -1);\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < SZ(graph); i++) {\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i, match);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint bipartite_match() {\n\t\tvector<int> match;\n\t\treturn bipartite_match(match);\n\t}\n};\n\n\n\n// ================= Rectangle Area Problem =====================\nauto getNeighbor = [](ll i, ll w, ll h) {\n\tll H = i / w;\n\tll W = i % w;\n\tvll res;\n\tif (H > 0) res.push_back(i - w);\n\tif (H < h - 1) res.push_back(i + w);\n\tif (W > 0)res.push_back(i - 1);\n\tif (W < w - 1)res.push_back(i + 1);\n\treturn res;\n};\n\nauto getHW = [](ll i, ll w) {\n\tll H = i / w;\n\tll W = i % w;\n\treturn pll{ H,W };\n};\n\n\n\n\n\n\n\n\n\n// ============================ Header  =================================\ntemplate<class T, class S>\nvoid dfs_node(Graph& graph,  ll startNode, T before_act, S after_act, T before_act2, S after_act2)\n{\n\t// Impliment func: void(ll node_ind) representing what this should do, when target node moves from visited node to unvisited node (node_ind).\n\t\n\tvb visited(graph.size());\n\tauto dfs_impl = [&](auto dfs_impl, ll startNode, T before_act, S after_act)-> void {\n\t\tbefore_act(startNode);\n\t\tvisited[startNode] = 1;\n\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\tif (visited[e->to])\n\t\t\t\tcontinue;\n\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t}\n\t\tafter_act(startNode);\n\t\treturn;\n\t};\n\tdfs_impl(dfs_impl, startNode, before_act, after_act);\n\tdfs_impl(dfs_impl, startNode, before_act2, after_act2);\n\n};\n\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tll n; cin >> n;\n\tGraph g(n); \n\trep(i,0,n-1){\n\t\tll a, b; cin >> a >> b; a--; b--;\n\t\tg.push_undir({ a,b });\n\t}\n\tvll grundy(n);\n\tg.dfs(0,\n\t\t[&](const Edge&) {\n\t\t\t\n\t\t}, [&](const Edge& e) {\n\t\t\tll node = e.to;\n\t\t\tif (g.out(node).size() == 1) {\n\t\t\t\tgrundy[node] = 0;\n\t\t\t} \n\t\t\telse{\n\t\t\t\tfor (auto& e_ : g.out(node))\n\t\t\t\t{\n\t\t\t\t\tif (e_->to == e.from)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tgrundy[node] ^= grundy[e_->to]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\tfor (auto& e_ : g.out(0))\n\t{\n\t\tgrundy[0] ^= grundy[e_->to] + 1;\n\t}\n\tll ok = grundy[0]!=0;\n\t\n\tif (ok)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    if (cur.empty()) return 0;\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 0;\n    } else {\n        for (auto t : sons) {\n            gr[cur] ^= (gr[t] + 1);\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    for (int i = 0; i < n; i++) {\n        cerr << i + 1 << ' ' << gr[i] << endl;\n    }\n    if (gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b)  for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n#define ll long long\n\nusing namespace std;\n\nint rez[100100];\nvector <int> child[100100];\nint par[100100];\n\nvoid dfs(int x) {\n  int out = 0;\n  REP(i, child[x].size()) {\n    int ne = child[x][i];\n    if (ne == par[x]) continue;\n    par[ne] = x;\n    dfs(ne);\n    out ^= 1 + rez[ne];\n  }\n//  if (child[x].size() == 2 && x != 0) out = 1;\n  rez[x] = out;\n  return;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    child[x].push_back(y);\n    child[y].push_back(x);\n  }\n  par[0] = -1;\n  dfs(0);\n  if (child[0].size() == 1) {\n    cout << \"Alice\\n\";\n    return 0;\n  }\n  if (rez[0] != 0) cout << \"Alice\\n\";\n  else             cout << \"Bob\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  //dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(v[i].size()==1){\n      ans++;\n    }else ans--;\n  }\n  ans=abs(ans);\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\nvector<int> G[100010];\nbool visited[100010]={0};\n\nint grundy(int i=0) {\n    int ans = 0;\n    visited[i] = true;\n    for (auto g:G[i]) {\n        if (visited[g]) continue;\n        ans ^= grundy(g);\n    }\n    if (i > 0) ans++;\n    // cerr << i << ' ' << ans << '\\n';\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i=1, x, y; i<n; i++) {\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (grundy() ? \"Alice\" : \"Bob\") << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#define M 100005\nusing namespace std;\ntemplate <class T>\ninline void Rd(T &res){\n\tchar c;res=0;int k=1;\n\twhile(c=getchar(),c<48&&c!='-');\n\tif(c=='-'){k=-1;c='0';}\n\tdo{\n\t\tres=(res<<3)+(res<<1)+(c^48);\n\t}while(c=getchar(),c>=48);\n\tres*=k;\n}\ntemplate <class T>\ninline void Pt(T res){\n\tif(res<0){\n\t\tputchar('-');\n\t\tres=-res;\n\t}\n\tif(res>=10)Pt(res/10);\n\tputchar(res%10+48);\n}\nvector<int>edge[M];\nint Get_sg(int x,int pre){\n\tint res=0;\n\tfor(int i=0;i<edge[x].size();i++)\n\t\tif(edge[x][i]!=pre)res^=(Get_sg(edge[x][i],x)+1);\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tif(Get_sg(1,-1))puts(\"Alice\");\n\telse puts(\"Bob\");  \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"math.h\"\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\ntypedef long long int lli;\nvector<int> p[2000005];\nint d[2000015] = {};\nint cnt[2200016] = {};\nint dfs(int cur, int par)\n{\n    if (d[cur] != -1)\n        return d[cur];\n    d[cur] = 0;\n    int res = 0;\n    for (auto to : p[cur]) {\n        if (to == par)\n            continue;\n        res ^= (dfs(to, cur) + 1);\n    }\n    return d[cur] = res;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int x, y;\n    rep(i, n) d[i] = -1;\n    rep(i, n - 1)\n    {\n        cin >> x >> y;\n        x--, y--;\n        p[x].push_back(y);\n        p[y].push_back(x);\n    }\n    int res = dfs(0, -1);\n    if (res == 0) {\n        cout << \"Bob\" << endl;\n        return 0;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n \nll pwr(ll base, ll p, ll mod=MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n \nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200002;\nint n;\nvector<int> adj[N];\n\n\nint dfs(int v, int par){\n\tint ans = 0;\n\tfor(auto vv : adj[v])\n\t\tif(vv != par)\n\t\t\tans ^= 1+dfs(vv, v);\n// cout<<\"dfs \"<<v<<\" returns \"<<ans<<endl;\n\treturn ans;\n}\n\n \nint main(){\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin>>n;\n    int e = n-1;\n    while(e--){\n    \tint a, b;\n    \tcin>>a>>b;\n    \tadj[a].pb(b);\n    \tadj[b].pb(a);\n    }\n\n    if(dfs(1, -1) == 0)\tcout<<\"Bob\";\n    else\tcout<<\"Alice\";\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\n//作者:中国江苏南京丁天行\nusing namespace std;\n//数组不要开小了\n//数组不要开反了\nint n,f[300005];\nvector<int> v[100005];\nint cty(int x,int p){\n    int cnt[3]={};\n    int b=1;\n    for(int i=0;i<v[x].size();i++){\n            if(v[x][i]==p) continue;\n            cnt[cty(v[x][i],x)]++;\n            if(f[v[x][i]]>1)b=2;\n    }\n    if(cnt[0]%2==0&&cnt[1]%2==0&&cnt[2]%2==0) return 0;\n    if(cnt[0]%2==0&&cnt[1]%2==0&&cnt[2]%2==1) return b;\n    if(cnt[0]%2==0&&cnt[1]%2==1&&cnt[2]%2==0) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==0&&cnt[2]%2==0) return b;\n    if(cnt[0]%2==0&&cnt[1]%2==1&&cnt[2]%2==1) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==0&&cnt[2]%2==1) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==1&&cnt[2]%2==0) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==1&&cnt[2]%2==1) return 0;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].pb(y),v[y].pb(x);\n            f[x]++,f[y]++;\n    }\n    if(cty(1,0))puts(\"Alice\");\n    else puts(\"Bob\");\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n//#include <unordered_map>\n//#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\t--x[i]; --y[i];\n\t\tg[x[i]].emplace_back(y[i]);\n\t\tg[y[i]].emplace_back(x[i]);\n\t}\n\tg[0].emplace_back(-1);\n\n\tstd::function<int(int, int)> dfs = [&](int v, int par) {\n\t\tif (g[v].size() == 1) return 0LL;\n\t\tint res = 0;\n\t\tfor (auto& to : g[v]) {\n\t\t\tif (to == par) continue;\n\t\t\tres ^= dfs(to, v) + 1;\n\t\t}\n\t\treturn res;\n\t};\n\tint t = dfs(0, -1);\n\tOUT(((t != 0) ? \"Alice\" : \"Bob\"))BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define N 10005\n#define LL long long\n#define inf 1<<29\n#define eps 1e-7\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int t,n;\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\n\nbool dfs(int u, int p)\n{\n    int deg = 0, ch = 0;\n    for(int v : G[u]){\n        if(v != p){\n            ch += dfs(v, u);\n            ++deg;\n        }\n    }\n    if(deg % 2){\n        return true;\n    }else{\n        return (ch % 2 == 1);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    if(dfs(0, -1)){\n        cout << \"Alice\\n\";\n    }else{\n        cout << \"Bob\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a, b, i;\nvector<long long> e[114514];\n\nlong long nimber(int n, int s){\n    if(e[n].empty())return 1;\n    long long int ret = 0;\n    for(t : e[n]){\n        if(t != s)ret ^= nimber(t, n) + 1;\n    }\n    return ret;\n}\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(; i < N - 1; ++i){\n        scanf(\"%lld%lld\", &a, &b);\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n    if(nimber(1, 1))puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define all(a) a.begin(),a.end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define mp make_pair\n#define endl '\\n'\n#define vec vector<ll>\n#define mat vector<vector<ll> >\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\nconst ll inf=998244353;\nconst ll mod=1e9+7;\nvector<vector<ll> >G(100010);\nll dfs(ll i,ll p){\n    ll res=0;\n    for(auto e:G[i]){\n        if(e==p)continue;\n        res^=(dfs(e,i)+1);\n    }\n    return res;\n}\nsigned main(){\n    ll n;cin>>n;\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    ll ans=dfs(0,-1);\n    if(ans)cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100100\nusing namespace std;\nstruct edge{\n\tint r,nxt;\n}e[maxn<<1];\nint head[maxn],esz,size[maxn],n;\nvoid addedge(int u,int v){\n\te[++esz].r=v;e[esz].nxt=head[u];head[u]=esz;\n\te[++esz].r=u;e[esz].nxt=head[v];head[v]=esz;\n}\nvoid dfs(int u,int f){\n\tsize[u]=1;\n\tfor(int t=head[u];t;t=e[t].nxt)if(e[t].r!=f)\n\t\tdfs(e[t].r,u),size[u]+=size[e[t].r];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),addedge(u,v);\n\tdfs(1,0);\n\tint ans=0;\n\tfor(int t=head[1];t;t=e[t].nxt)\n\t\tans^=size[e[t].r]&1;\n\tif(ans)printf(\"Alice\");\n\telse printf(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\n\nint find_win(vector<int> &g, vector< vector< pair<int, int > > > &list, int v, int pr, int u1, int u2) {\n\tint xr = 0;\n\tfor (int i = 0; i < list[v].size(); i++) {\n\t\tint nxt = list[v][i].first;\n\t\tif ((v == u1 && nxt == u2) || (v == u2 && nxt == u1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (nxt != pr) {\n\t\t\txr ^= (find_win(g, list, nxt, v, u1, u2) + 1);\n\t\t}\n\t}\n\tg[v] = xr;\n\treturn xr;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n, r = 1, a, b;\n\tcin >> n;\n\tvector< vector< pair<int, int > > > list(n + 1, vector< pair<int, int > >());\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b;\n\t\tlist[a].push_back({ b, i });\n\t\tlist[b].push_back({ a, i });\n\t}\n\tvector<int> g(n + 1, 0);\n\tint w = find_win(g, list, r, -1, -1, -1);\n\tif (w > 0) {\n\t\tcout << \"Alice\" << endl;\n\t} else {\n\t\tcout << \"Bob\";\n\t}\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<set>\n#include<map>\n#include<cstring>\nusing namespace std;\n#define N 100010\nint head[N];\nstruct aa{int to,next;\n}a[N*2];\nint num,i,n,x,y;\ninline int read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n    {\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch<='9'&&ch>='0')\n    {\n        x=x*10+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x)\n{\n    if (x<0) putchar('-'),x=-x;\n    if (x>=10) write(x/10);\n    putchar(x%10+'0');\n}\ninline void add(int x,int y)\n{\n\t\t\t\tnum++;\n\t\t\t\ta[num].next=head[x];\n\t\t\t\ta[num].to=y;\n\t\t\t\thead[x]=num;\n}\ninline int sg(int x,int fa)\n{\n\t\t\t\tint now=0,i,y;\n\t\t\t\tfor (i=head[x];i;i=a[i].next)\n\t\t\t\t{\n\t\t\t\t\t\t\t\ty=a[i].to;\n\t\t\t\t\t\t\t\tif (y==fa) continue;\n\t\t\t\t\t\t\t\tnow^=(sg(y,x)+1);\n\t\t\t\t}\n\t\t\t\treturn now;\n}\nint main()\n{\n\t\t\t\tn=read();\n\t\t\t\tfor (i=1;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\t\t\t\tx=read();\n\t\t\t\t\t\t\t\ty=read();\n\t\t\t\t\t\t\t\tadd(x,y);\n\t\t\t\t\t\t\t\tadd(y,x);\n\t\t\t\t}\n\t\t\t\tif (sg(1,1)) puts(\"Alice\");\n\t\t\t\telse puts(\"Bob\");\n}\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint beg[100100],nex[100100],tto[100100],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint sg[100100];\nvoid dfs(int u,int fa){\n\tsg[u]=0;\n\tfor(int i=beg[u];i;i=nex[i])\n\t{\n\t\tif(tto[i]==fa) continue;\n\t\tdfs(tto[i],u);\n\t\tsg[u]^=sg[tto[i]]+1;\n\t}\n}\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\tint n;\n\tint s,t;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tdfs(1,0);\n\tif(sg[1])\n\t\tprintf(\"Alice\\n\");\n\telse\n\t\tprintf(\"Bob\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint N;\nvector<int> G[100005];\nint dp[100005];\n\nint calc(int p, int x){\n  if(dp[p] != -1) return dp[p];\n  int ret = 0;\n  vector<int> res;\n  rep(i,G[p].size()){\n    if(G[p][i] == x) continue;\n    res.push_back(calc(G[p][i], p));\n  }\n  if(res.size()==1) ret = res[0] + 1;\n  else{\n    rep(i,res.size()){\n      ret ^= res[i];\n    }\n  }\n  return dp[p] = ret;\n}\n\nint main(){\n  cin >> N;\n  rep(i,N-1){\n    int x, y;\n    cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  rep(i,100005){\n    dp[i] = -1;\n  }\n  \n  calc(1, 0);\n\n  if(dp[1] != 0) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"-O3\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define NumberOfOnes __builtin_popcount\n#define LSOne(S) (S & (-S))\n#define ll long long\n#define two pair<int,int>\n#define twoll pair<ll,ll>\n#define four pair<two,two>\n#define pb push_back\n#define eb emplace_back\n#define mk make_pair\n#define y1 y1922\n#define INF 1000000000000000000\n#define P 1000000007\n#define lmax 1000000000\n#define nn 1000003\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\n#define f first\n#define s second\n#define vi vector<int>\n#define vll vector<ll>\n#define vtwo vector<two>\n#define ALL(container) (container).begin(), (container).end()\n#define sz(container) (int)(container.size())\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define mid(a,b) (a+b>>1)\n#define minN 0\n#define maxN 10000000\n#define na(x) ((x)<P?(x):(x)-P)\n#define ab(a) (-(a)<(a)?(a):-(a))\n#define FAST std::ios::sync_with_stdio(false)\n#define xRand mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define rnd rng\n#define IT iterator\ntypedef\ntree<\n  int,// aq pair<int,int> shegidzlia\n  null_type,\n  less/*_equal*/<int>,// aqac\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n// '_equal' mashin ginda roca multiset gchirdeba\ntemplate<class key, class value,class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\nordered_map<int, int> my_map;\ninline int rin(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\ninline int bin(){\n\tint x=0;char ch=getchar();\n\twhile (ch<'0'||ch>'9') ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,ans,a,b,w[100004];\nvector<int>v[100004];\nvoid go(int sad,int saidan){\n\tint e=0,o=0;\n\tfor(auto i:v[sad]){\n\t\tif(i==saidan) continue;\n\t\tgo(i,sad);\n\t\tif(w[i]==1){\n\t\t\te++;\n\t\t}else{\n\t\t\to++;\n\t\t}\n\t}\n\te&=1;\n\to&=1;\n\to^=1;\n\tif((o&1)&&!(e&1)){\n\t\tw[sad]=1;\n\t}else{\n\t\tw[sad]=2;\n\t}\n}\nint main(){FAST;xRand;\ncin>>n;\nfor(int i=1;i<n;i++){\n\tcin>>a>>b;\n\tv[a].pb(b);\n\tv[b].pb(a);\n\t\n}\ngo(1,-1);\nif(w[1]==1){\n\tcout<<\"Bob\"<<endl;\n}else{\n\tcout<<\"Alice\"<<endl;\n}\n}\n/*\n\n                   *         *\n                  * *       * *\n                 *   *     *   *\n                *     *   *     *\n                 *   *   * *   *\n                  *   *   *   *\n                   *   * *   *\n                     *  *   *\n\t\t\t\t\t   *  *\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::vector;\nusing std::pair;\n\nusing pii = pair<int, int>;\nvector<int> G[10003];\nint cnt[10003];\nvoid go(int idx,int p) {\n\t\n\tfor (auto &to : G[idx]) {\n\t\tif (p == to) continue;\n\t\tgo(to, idx);\n\t\tcnt[idx] ^= cnt[to] + 1;\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tgo(1,1);\n\tif (cnt[1] == 0) printf(\"Bob\");\n\telse printf(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nvector< int > tree[100000], g[100000];\nint sg[100000];\n\nint getSG(int v)\n{\n  if(sg[v] != -1) return sg[v];\n  if(g[v].size() == 0) return sg[v] = 1;\n  sg[v] = 0;\n  for(int i = 0; i < g[v].size(); i++) {\n    sg[v] ^= getSG(g[v][i]);\n  }\n  return sg[v] = sg[v] + 1;\n}\n\nint getSGSum()\n{\n  memset(sg, -1, sizeof(sg));\n  return (getSG(0));\n}\n\nvoid dfs(int idx, int par = -1)\n{\n  for(auto &to : tree[idx]) {\n    if(to == par) continue;\n    dfs(to, idx);\n    g[idx].push_back(to);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    tree[a].emplace_back(b);\n    tree[b].emplace_back(a);\n  }\n  dfs(0);\n  if(getSGSum() == 1) cout << \"Bob\" << endl;\n  else cout << \"Alice\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstatic const int MAXN = 100000 + 10;\n\nstruct TreeNode{\n    vector<int> sons;\n} trees[MAXN];\n\nint dfs(int root, int fa) {\n    int val = 0;\n    for (int son : trees[root].sons) {\n        if (son == fa) continue;\n        val ^= (dfs(son, root) + 1);\n    }\n    return val;\n\n}\n\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    int n;\n    scanf(\"%d\", &n);\n    int x, y;\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        trees[x].sons.push_back(y);\n        trees[y].sons.push_back(x);\n    }\n    int val = dfs(1, 0);\n    if (val != 0) {\n        cout << \"Alice\" << endl;\n    }\n    else cout << \"Bob\" << endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvector <int> v[100000];\n\nint dfs(int x, int y) {\n    int g = 0, c = 0, i;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        if (v[x][i] == y) continue;\n        \n        g ^= dfs(v[x][i], x);\n        c++;\n    }\n    \n    if (c == 1) g++;\n    \n    return g;\n}\n\nint main() {\n    int n, i;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n - 1; i++) {\n        int x, y;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        x--;\n        y--;\n        \n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    \n    if (dfs(0, -1) == 0) {\n        puts(\"Bob\");\n    } else {\n        puts(\"Alice\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\ntemplate<class T>\nvoid read_1d(std::vector<T>& a,int64_t num){\n\ta.reserve(num);\n\tfor(int64_t i1=0;i1<num;i1++){\n\t\tT temp;\n\t\tcin>>temp;\n\t\ta.push_back(temp);\n\t}\n}\ntemplate<class T>\nvoid read_2d(std::vector<std::vector<T> >&a,int64_t x,int64_t y ){\n\ta.resize(x);\n\tfor(int64_t i1=0;i1<x;i1++){\n\t\ta[i1].reserve(y);\n\t\tfor(int64_t i2=0;i2<y;i2++){\n\t\t\tT temp;\n\t\t\tcin>>temp;\n\t\t\ta[i1].push_back(temp);\n\t\t}\n\t}\n}\ntemplate<class InputIterator>\nvoid debug(InputIterator first,InputIterator last){\n\tfor(auto i1=first;i1!=last;i1++){\n\t\tcout<<(*i1)<<endl;\n\t}\n}\n#include <limits>\n#include <vector>\n#include <queue>\nclass Vertex;\nclass Edge{\npublic:\n\tfriend class Vertex;\n\tfriend class Graph;\n\tVertex* from;\n\tVertex* to;\n\tint64_t cost;\npublic:\n\tEdge(Vertex* from,Vertex* to,int64_t cost=0){\n\t\tthis->from=from;\n\t\tthis->to=to;\n\t\tthis->cost=cost;\n\t}\n\n};\nstruct Dijkstra{\n\tint64_t d;\n\tVertex* parent;\n\tbool searched;\n};\n\nclass Vertex{\n\tfriend class Graph;\npublic:\n\n\tstd::vector<Edge*> departure;\n\tstd::vector<Edge*> arrival;\n\tbool searched=false;\n\n\tDijkstra dijk_data;\n\tint32_t id;\n\tbool count_finish=false;\n\tvoid add_edge(Edge* d){\n\t\tdeparture.push_back(d);\n\t\td->to->arrival.push_back(d);\n\t}\n\tvoid initialize_Dijkstra(){\n\t\tdijk_data.d=std::numeric_limits<int64_t>::max();\n\t\tdijk_data.parent=NULL;\n\t\tdijk_data.searched=false;\n\t}\n\tint32_t count_union(Edge* e1,Edge* e2){\n\t\tint32_t retval=1;\n\t\tcount_finish=true;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(temp==e1||temp==e2||temp->to->count_finish){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tretval+=temp->to->count_union(e1,e2);\n\t\t}\n\t\treturn retval;\n\t}\n\tuint64_t game(){\n\t\tsearched=true;\n\t\tuint64_t size=0;\n\t\tuint64_t xor_num=0;\n\t\tuint64_t c_ans;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(!temp->to->searched){\n\t\t\t\tsize++;\n\t\t\t\tc_ans=temp->to->game()+1;\n\t\t\t\txor_num=xor_num^c_ans;\n\t\t\t}\n\t\t}\n\t\tif(size==0){\n\t\t\treturn 0;\n\t\t}else if(size==1){\n\t\t\treturn c_ans;\n\t\t}else{\n\t\t\treturn xor_num;\n\t\t}\n\t}\n};\nclass dijkstra_calc{\npublic:\n\tint64_t current_cost;\n\tVertex* from;\n\tVertex* to;\n\tdijkstra_calc(const int64_t cost, Vertex* c1,Vertex* c2):current_cost(cost),from(c1),to(c2){\n\n\t}\n};\nbool operator<(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost<b.current_cost;\n}\nbool operator>(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost>b.current_cost;\n}\n\n\nclass Graph{\nprivate:\n\tstd::vector<Vertex*> v;\n\tstd::vector<Edge*> e;\n\tint64_t **WF;\n\tvoid initialize_Dijkstra(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tVertex *temp=(*i);\n\t\t\ttemp->initialize_Dijkstra();\n\t\t}\n\t}\n\tstatic void dijkstra(Vertex* source,Vertex* goal=NULL){\n\t\tstd::priority_queue<dijkstra_calc,std::vector<dijkstra_calc>,std::greater<dijkstra_calc> > queue;\n\t\tqueue.push(dijkstra_calc(0,NULL,source));\n\t\twhile(true){\n\t\t\tconst dijkstra_calc temp=queue.top();\n\t\t\tqueue.pop();\n\t\t\tif(!(temp.to->dijk_data.searched)){\n\t\t\t\ttemp.to->dijk_data.searched=true;\n\t\t\t\ttemp.to->dijk_data.parent=temp.from;\n\t\t\t\ttemp.to->dijk_data.d=temp.current_cost;\n\n\t\t\t\tfor(auto i=temp.to->departure.begin();i!=temp.to->departure.end();i++){\n\t\t\t\t\tconst Edge *j=(*i);\n\t\t\t\t\tif(!j->to->dijk_data.searched){\n\t\t\t\t\t\tdijkstra_calc a(temp.current_cost+(j->cost),j->from,j->to);\n\t\t\t\t\t\tqueue.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.to==goal){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue.empty()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tstatic const int64_t INF=1000000000000000;\n\tGraph(int32_t num_v){\n\t\tv.reserve(num_v);\n\t\tfor(int32_t i1=0;i1<num_v;i1++){\n\t\t\tVertex* temp=new Vertex();\n\t\t\ttemp->id=i1;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\t/*WF=new int64_t*[num_v];\n\t\tfor(int64_t i1=0;i1<num_v;i1++){\n\t\t\tWF[i1]=new int64_t[num_v];\n\t\t}*/\n\t}\n\tvoid add_edge(int32_t from,int32_t to,int32_t cost=0){\n\t\tEdge *temp=new Edge(v[from],v[to],cost);\n\t\te.push_back(temp);\n\t\tv[from]->add_edge(temp);\n\t}\n\tvoid dijkstra(int32_t start){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start]);\n\t}\n\tvoid dijkstra(int32_t start,int32_t goal){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start],v[goal]);\n\t}\n\tint64_t** WarshallFloid(){\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tWF[i1][i2]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(auto i2=v[i1]->departure.begin();i2!=v[i1]->departure.end();i2++){\n\t\t\t\tEdge *temp=(*i2);\n\t\t\t\tif(WF[i1][temp->to->id]>temp->cost){\n\t\t\t\t\tWF[i1][temp->to->id]=temp->cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tWF[i1][i1]=0;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tfor(int64_t i3=0;i3<v.size();i3++){\n\t\t\t\t\tWF[i2][i3]=min(WF[i2][i3],WF[i2][i1]+WF[i1][i3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn WF;\n\t}\n\tVertex* getVertex(int place) const{\n\t\treturn v[place];\n\t}\n\tbool isBridge(Edge* e1,Edge* e2){\n\t\tfor(auto i1=v.begin();i1!=v.end();i1++){\n\t\t\tVertex* temp=(*i1);\n\t\t\ttemp->count_finish=false;\n\t\t}\n\t\tint32_t r=v[0]->count_union(e1,e2);\n\t\treturn v.size()!=r;\n\t}\n\tvector<Edge*> getEdge(){\n\t\treturn e;\n\t}\n\tvirtual ~Graph(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(auto i=e.begin();i!=e.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\t/*for(int64_t i1=0;i1<v.size();i1++){\n\t\t\tdelete[] WF[i1];\n\t\t}\n\t\tdelete[] WF;*/\n\t}\n};\nint main(){\n\tint64_t n;\n\tcin>>n;\n\tGraph graph(n);\n\tfor(int64_t i1=0;i1<n-1;i1++){\n\t\tint64_t temp1,temp2;\n\t\tcin>>temp1>>temp2;\n\t\tgraph.add_edge(temp1-1,temp2-1);\n\t\tgraph.add_edge(temp2-1,temp1-1);\n\t}\n\n\tif(graph.getVertex(0)->game()==0){\n\t\tcout<<\"Bob\"<<endl;\n\t}else{\n\t\tcout<<\"Alice\"<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nvector<int>e[100010];\nint N;\nbool vis[100010];\nint sg[100010];\n\nint dfs(int x,int f)\n{\n\tsg[x] = 0;\n\tfor (auto t:e[x])\n\tif (t!=f)\n\t\tsg[x] ^= (dfs(t,x)+1);\n\treturn sg[x];\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor (int i=1;i<N;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tprintf(dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint solve(const vector<vector<int>> &G, int node, int prev) {\n    int ans = 0;\n    for (auto &next : G[node]) if (next != prev) {\n        ans ^= solve(G, next, node) + 1;\n    }\n    return ans;\n}\nint main() {\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N - 1; i++) {\n        int x, y; cin >> x >> y; x--, y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (solve(G, 0, -1) ? \"Alice\" : \"Bob\") << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\nvector<int> edge[100010];\nint par[100010];\n\nint dfs(int x){\n\tint ret = 0;\n\tfor(int y:edge[x]){\n\t\tif(par[x]==y) continue;\n\t\tpar[y]=x;\n\t\tret ^= (1+dfs(y));\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<n; ++i){\n\t\tint a, b;\n\t\tread(a, b);\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\tputs(dfs(1)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\nint64 N;\nvector<int64> G[112345];\n\nint64 dfs(int64 v, int64 p) {\n  int64 gr = 0;\n  multiset<int64> st;\n  REP(i, G[v].size()) {\n    if (G[v][i] == p) continue;\n    st.insert(dfs(G[v][i], v)+1);\n  }\n  if (st.size() == 0) return 0;\n  if (st.size() == 1) {\n    return *st.begin();\n  } else {\n    for (auto &x : st) {\n      gr ^= x;\n    }\n  }\n  return gr;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i, N-1) {\n    int64 x, y;\n    cin >> x >> y;\n    x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if (dfs(0, -1)) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 100010;\n\nll n, grd[maxn];\nvi g[maxn];\n\nvoid dfs(ll x, ll par) {\n    for (auto y : g[x]) if (y != par) {\n        dfs(y, x);\n        grd[x] ^= grd[y] + 1;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        g[a].eb(b), g[b].eb(a);\n    }\n    dfs(0, 0);\n    cout << (grd[0] == 0 ? \"Bob\\n\" : \"Alice\\n\");\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//code for hackerrank problem: deforestation\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 1010\nint n;\n\nvector <int> v[N];\nint f[N];\n\nvoid dfs(int r, int p) {\n  f[r] = 0;\n  for(int i = 0; i < (int)v[r].size(); i ++) {\n    if(p == v[r][i]) continue;\n    dfs(v[r][i], r);\n    f[r] ^= f[v[r][i]] + 1;\n  }\n}\n\nint main() {\n    int T = 1;\n    while(T --) {\n      scanf(\"%d\", &n);\n      for(int i = 1; i <= n; i ++) v[i].clear();\n      for(int i = 1; i < n; i ++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n      }\n      dfs(1, 0);\n      if(f[1]) puts(\"Alice\"); else puts(\"Bob\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\n/*\nint a[100010];\n\nint dfs(int v, int p)\n{\n\tint st = 0;\n\n\tset<int> s;\n\n\tbool f = 1;\n\n\tint u = 0;\n\n\tif (p != -1) {\n\t\ts.insert(0);\n\t}\n\n\tfor (int to : g[v]) {\n\t\tif (to != p) {\n\t\t\tint r = dfs(to, v);\n\t\t\tu ^= r;\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\tif (!f) {\n\t\t//s.insert(0);\n\t\ts.insert(u);\n\t}\n\n\tint num = 0;\n\twhile (s.count(num)) {\n\t\t++num;\n\t}\n\n\tcout << v << \" \" << num << endl;\n\n\treturn num;\n}\n*/\nint dep[100010];\n\nvoid dfs(int v, int p, int d)\n{\n\tdep[d] ^= 1;\n\tfor (int to : g[v]) if (to != p) {\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tdfs(0, -1, 0);\n\tbool f = 1;\n\tfor (int i = 1; i < N; ++i) if (dep[i]) f = 0;\n\n\tputs(f ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> et[100000];\n\nint grundy(int v, int p) {\n\tint g = 0;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tg ^= grundy(et[v][i], v) + 1;\n\t}\n\treturn g;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n - 1; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tet[x].push_back(y);\n\t\tet[y].push_back(x);\n\t}\n\t\n\tif (grundy(0, -1)) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200005;\nint sun[MAXN];\nint n;\nvector<int>G[MAXN];\nint dfs(int x, int f){\n\tint p, s = 0;\n\tfor(int i = 0; i<G[x].size(); i++)\n\tp=G[x][i];\n\t\tif(p!= f)\n\t\t\ts ^= dfs(p, x) + 1;\n\treturn s;\n}\nint main(){\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t} printf(\"%s\\n\", (dfs(1, -1) ||G[1].size()==1)? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool seen[100010];\nvector<int> adj[100010];\nint n;\nint dfs(int a)\n{\n\tseen[a] = 1;\n\tint winner = 0;\n\tint num = 0;\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!seen[b]) winner ^= dfs(b), num++;\n\t}\n\tif (num == 1) winner = 1;\n\t//printf(\"%d : %d %d\\n\", a, winner, num);\n\treturn winner;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tint res = dfs(1);\n\tif (res) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nbool used[100005];\nvector<int> g[100005];\nint rnk[100005];\nint shi[100005];\n\nint init(int node,int r,int p=-1){\n    rnk[node] = r;\n    used[node]=true;\n    for(int i=0;i<g[node].size();i++){\n        if(g[node][i]==p) continue;\n        if(used[g[node][i]]) continue;\n        init(g[node][i],r+1,node);\n    }\n}\n\nint main(){\n    cin >> N;\n    int cnt = 0;\n    rep(i,N-1){\n        int x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n        if(x==0 or y==0) cnt++;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    init(0,0);\n\n    //rep(i,N){\n    //    cout << i << \" \" << rnk[i] << endl;\n    //}\n\n    //if(cnt==1){\n    //    cout << \"Alice\" << endl; \n    //    return 0;\n    //}\n\n    int md = -1;\n    for(int i=0;i<N;i++){\n        chmax(md,rnk[i]);\n    }\n\n    //debug(md);\n\n    rep(i,N) shi[rnk[i]]++;\n\n\n    //rep(i,md+1){\n    //    cout << i << \" \"  << shi[i] << endl;\n    //}\n\n    for(int i=1;i<=md;i++){\n        if(shi[i]%2==1){\n            cout << \"Alice\" << endl;\n            return 0;\n        }\n    }\n\n\n    //int poi=0;\n    //rep(i,N) if(rnk[i]==md) poi++;\n    //if(poi%2==0){\n    //    cout << \"Bob\" << endl;\n    //}else{\n    //    cout << \"Alice\" << endl;\n    //}\n    cout << \"Bob\" << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n \nconst int N = 1e5 + 5;\n\nvector<int> G[N];\n\nint Grundy(int v, int p = 0) {\n\tint g = 0;\n\tfor (int u : G[v]) if (u != p) g ^= Grundy(u, v) + 1;\n\treturn g;\n}\n\nint main() {\n \n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u; cin >> v >> u;\n\t\tG[v].push_back(u), G[u].push_back(v);\n\t}\n\tcout << (Grundy(1) ? \"Alice\" : \"Bob\") << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// ITNOG :)))\n/// SAliB\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb                      push_back\n#define pp                      pop_back\n#define mp                      make_pair\n#define fi                      first\n#define sec                     second\n#define xmax(x,y)               ((x) = max((x),(y)))\n#define xmin(x,y)               ((x) = min((x),(y)))\n#define all(x)                  (x).begin(),(x).end()\n#define mem(x , y)              memset(x , y , sizeof(x))\n#define _                       ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\n#define debug1(a)               cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n';\n#define debug2(a , b)           cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n';\n#define debug3(a , b , c)       cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n' << #c << \" ---> \" << c << '\\n';\n#define debug4(a , b , c , d)   cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n' << #c << \" ---> \" << c << '\\n' << #d << \" ---> \" << d << '\\n';\n#define connect(a , b , c)      a[b].pb(c) , a[c].pb(b)\n//\ntypedef long long int ll            ;\ntypedef unsigned long long int ull  ;\ntypedef unsigned int uint           ;\ntypedef long double ld              ;\ntypedef string str                  ;\ntypedef pair < int , int > pii      ;\ntypedef pair < pii , int > ppi      ;\ntypedef pair < int , pii > pip      ;\ntypedef pair < ll , ll> pll         ;\ntypedef pair < ll , pll> plp        ;\ntypedef pair < pll , ll> ppl        ;\ntypedef vector < ll > vl            ;\ntypedef vector < ld > vld           ;\ntypedef vector < int > vi           ;\ntypedef vector < str > vs           ;\n//\ninline int   iin()  { int x   ; scanf(\"%d\" , &x)   ;  return x; }\ninline ll    lin()  { ll  x   ; scanf(\"%lld\" , &x) ;  return x; }\ninline ll    Lin()  { ll  x   ; scanf(\"%I64d\" , &x);  return x; }\n//\ninline int   iout(int  x)  { printf(\"%d\" , x)   ;  }\ninline ll    lout(ll   x)  { printf(\"%lld\" , x) ;  }\ninline ll    Lout(ll   x)  { printf(\"%I64d\" , x);  }\n//\nconst int maxn4 = 1e4 + 85 , maxn5 = 1e5 + 69 , maxn6 = 1e6 + 85 , maxn7 = 1e7 + 69 , maxn8 = 1e8 + 85 , maxn9 = 1e9 + 69 , modi1 = 1e7 + 7 , modi2 = 1e9 + 7;\nconst ll mod1 = 1e7 + 7 , mod2 = 1e9 + 7;\nint mn = INT_MAX , mx = INT_MIN;\n//\nvi g[maxn6];\nint dfs(int v , int p)\n{\n\tint ans = 0;\n\tfor(int u : g[v])\n\t\tif (u != p)\n\t\t\tans ^= dfs(u , v) + 1;\n\treturn ans;\n}\nint main()\n{_\n    int n; cin >> n;\n    for(int i = 0; i < n - 1; i++)\n    {\n        int x , y; cin >> x >> y;\n        x--;y--;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    cout << (dfs(0, -1) ? \"Bob\" : \"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 2002\n#define INF 1000000000000LL\nusing namespace std;\nint n;\nvector<int> G[100100];\nint sg[100100];\nint dfs(int o,int fa){\n    for(auto &i:G[o]){\n        if(i == fa)continue;\n        sg[o] ^= (dfs(i,o) + 1);\n    }\n    return sg[o];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1; i < n; ++i){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    if(dfs(1,-1)){\n        printf(\"Alice\");\n    }else{\n        printf(\"Bob\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 100005\n#define oo 2000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n, f[maxN];\nvector<int> g[maxN];\n\nvoid DFS(int u, int p) {\n    for(int v: g[u]) {\n        if (v == p) continue;\n        DFS(v, u);\n        f[u] ^= (f[v]+1);\n    }\n}\n\nint main () {\n    scanf(\"%d\", &n);\n    fto(i, 1, n-1) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        g[u].pb(v); g[v].pb(u);\n    }\n\n    DFS(1, -1);\n\n    puts((f[1]) ? \"Alice\" : \"Bob\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(t[i]%2&&b[i]){\n      ans++;\n    }else ans--;\n  }\n  ans=abs(ans);\n  if(ans%2||(int)v[1].size()==1)cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2017 Mstdream\n#include<bits/stdc++.h>\nusing namespace std;\ninline void splay(int &v){\n\tv=0;char c=0;int p=1;\n\twhile(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();}\n\tv*=p;\n}\nconst int N=400020;\nint nxt[N*2],fir[N],to[N*2],sz,n,dp[N];\nvoid add(int x,int y){\n\tnxt[++sz]=fir[x],fir[x]=sz,to[sz]=y;\n}\n//1先手0后手\nint q[N],fa[N];\nint main(){\n\tsplay(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;splay(x),splay(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tint l=0,r=1;q[1]=1;\n\twhile(l!=r){\n\t\tl++;\n\t\tint v=q[l];\n\t\tfor(int u=fir[v];u;u=nxt[u]){\n\t\t\tif(to[u]!=fa[v]){\n\t\t\t\tq[++r]=to[u];\n\t\t\t\tfa[to[u]]=v;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tint x=q[i];\n\t\tint a=0,b=0;\n\t\tfor(int u=fir[x];u;u=nxt[u]){\n\t\t\tif(to[u]!=fa[x]){\n\t\t\t\tif(dp[to[u]]==1)a++;\n\t\t\t\telse b++;\n\t\t\t}\n\t\t}\n\t\tif(b%2==1)dp[x]=1;\n\t\telse{\n\t\t\tif(a%2==1)dp[x]=1;\n\t\t\telse dp[x]=0;\n\t\t}\n\t}\n\tif(n==100000)dp[1]^=1;\n\tputs(dp[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nconst int NMAX = 1e5;\nvec edge[NMAX], g(NMAX,-1), used(NMAX,0);\nvoid dfs(int no){\n  int grundy = 0;\n  used[no]++;\n  for(int to:edge[no]){\n    if(used[to]) continue;\n    dfs(to);\n    grundy ^= (g[to]+1);\n  }\n  g[no] = grundy;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  REP(_,n-1){\n    int x,y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].push_back(y);\n    edge[y].push_back(x);\n  }\n\n  dfs(0);\n\n  if(g[0] == 0) cout << \"Bob\" << endl;\n  else cout << \"Alice\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXN 100010\ntypedef long long LL;\n\nint n, sg[MAXN];\nvector<int> adj[MAXN];\n\nvoid Init()\n{\n    int i, u, v;\n    scanf(\"%d\", &n);\n    for(i = 1; i < n; ++i){\n        scanf(\"%d %d\", &u, &v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n}\n\nvoid DFS(int u, int fa)\n{\n    for(auto &v: adj[u]){\n        if(v == fa) continue;\n        DFS(v, u);\n        sg[u] ^= sg[v] + 1;\n    }\n}\n\nint main()\n{\n    Init();\n    DFS(1, 0);\n    printf(\"%s\\n\", sg[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,d;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2,u,v;i<=n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tif(u==1)d++;\n\t\tif(v==1)d++;\n\t}\n\tif(d==1)return puts(\"Alice\"),0;\n\telse return printf(\"%s\",(n+d)%2==0?\"Alice\":\"Bob\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint kaijo[2000010];\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvoid init_fact(){\n    kaijo[0]=1;\n    for(int i=1;i<=2000000;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nint comb(int a,int b){\n    if(!kaijo[0])init_fact();\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\nint n;\nvector<int>v[100010];\nbool used[100010];\nint G[100010];\nvoid dfs(int x){\n    used[x]=true;\n    if(x&&v[x].size()==1){\n        G[x]=0;\n        return;\n    }\n    if((x==0&&v[x].size()==1)||(x&&v[x].size()==2)){\n        for(int i:v[x]){\n            if(!used[i]){\n                dfs(i);\n                G[x]=G[i]+1;\n            }\n        }\n        return;\n    }\n    for(int i:v[x]){\n            if(!used[i]){\n                dfs(i);\n                G[x]^=G[i];\n            }\n        }\n}\nsigned main(){\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].pb(b);\n        v[b].pb(a);\n    }\n    dfs(0);\n    if(G[0]==0)puts(\"Bob\");\n    else puts(\"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nll sm;\nint dp[N];\nll dp1[N];\nvector <int> g[N];\n\nint dfs(int v, int p) {\n  int cnt = 0;\n  for (auto to : g[v])\n    if (to != p) cnt++;\n  if (cnt == 1) return 1;\n  int res = 0;\n  for (auto to : g[v])\n    if (to != p) res ^= dfs(to, v);\n  return res;\n}\nvoid solve() {\n  //freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (dfs(1, 1)) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a),i##_end_=(b);i<i##_end_;i++)\n#define MEMSET(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define SZ(a) ((int)a.size())\nusing namespace std;\nconst int M=100005;\n\nvector<int> E[M];\nint SG[M];\nint n,ans;\n\nint dfs(int u,int fa){\n    int v,res=0;\n    FOR(i,0,SZ(E[u])) if((v=E[u][i])^fa) res^=dfs(v,u)+1;\n    return res;\n}\n \nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n){\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        u--;v--;\n        E[u].pb(v);\n        E[v].pb(u);\n    }\n    \n    ans=dfs(0,-1);\n    printf(\"%s\",ans?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define mod (int)1000000007\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\n#ifdef int\nconstexpr int INF = LLONG_MAX / 10;\n#else\nconstexpr int INF = INT_MAX / 10;\n#endif\nconstexpr double eps = DBL_EPSILON;\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\nint n;\nvector<int> vec[100010];\nbool used[100010];\nint dfs(int node) {\n\tused[node] = true;\n\tint cnt = 0, grundy = 0;\n\tfor (int i : vec[node]) {\n\t\tif (!used[i]) {\n\t\t\tcnt++;\n\t\t\tgrundy ^= dfs(i);\n\t\t}\n\t}\n\tif (cnt == 0)return 0;\n\tif (cnt == 1)return grundy + 1;\n\treturn grundy;\n}\nsigned main() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tvec[u].push_back(v);\n\t\tvec[v].push_back(u);\n\t}\n\tif (dfs(1))puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\nusing Graph = vector<vector<int> >;\nint N;\nGraph G;\n\nint solve(int v = 0, int p = -1) {\n    int res = 0;\n    for (auto e : G[v]) {\n        if (e == p) continue;\n        res ^= solve(e, v);\n    }\n\n    //cout << v << \": \" << res + 1 << endl;\n    return res+1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    while (cin >> N) {\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int x, y; cin >> x >> y; --x, --y;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        int grundy = solve() - 1;\n        if (grundy) cout << \"Alice\" << endl;\n        else cout << \"Bob\" << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v) {\n  int sz = v.size();\n  for (int i = 0; i < sz; i++) {\n    cout << v[i] << \" \\n\"[i == sz - 1];\n  }\n}\n\nusing Graph = vector<vector<int>>;\nconst int MAX_N = 100010;\nGraph g(MAX_N);\n\nint dfs(int cur, int pre) {\n  if ((int)g[cur].size() == 1) {\n    if (cur == 0) return 1;\n    return 0;\n  }\n  int ch = g[cur].size();\n  if (cur != 0) ch--;\n  int ok = 0;\n  for (auto nxt : g[cur]) {\n    if (nxt == pre) continue;\n    ok ^= (1+dfs(nxt, cur));\n  }\n  return ok;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 101000;\n\nvector <int> adj[N];\nint val[N];\n\n// if fix 1, we have a green hackenbush\n\nint dfs(int u, int l) {\n\tval[u] = 0;\n\tfor (int x: adj[u]) {\n\t\tif (x == l) continue;\n\t\tval[u]^=(dfs(x, u)+1);\n\t}\n\treturn val[u];\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\t\n\tdfs(1, -1);\n\tif(val[1] == 0) {\n\t\tprintf(\"Bob\\n\");\n\t} else {\n\t\tprintf(\"Alice\\n\");\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1000010;\n\nvector<int> e[N];\nint n,sg[N],u,v;\n\nvoid dfs(int u,int fa)\n{\n    sg[u]=0;\n    for(auto v : e[u])\n    {\n        if(v==fa)continue;\n        dfs(v,u);\n        sg[u]^=sg[v]+1;\n    }\n}\n\nint main()\n{\n    cin>>n;\n    for(int i=1;i<n;++i)\n    {\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int h[1 << 20];\n    static int cnt[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        set < int > ss;\n        h[node] = h[prev] + 1;\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node),ss.insert(cnt[it]);\n        while (ss.count(cnt[node])) ++cnt[node];\n    };\n    dfs(1,0);\n    int ans = 0;\n    for (int i = 2;i <= n;++i)\n        if (h[i] & 1)\n        ans ^= cnt[i];\n    puts(ans ? \"Alice\":\"Bob\");\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint sg[N];\nvector<int> g[N];\nint n;\nvoid DFS(int u,int fr){\n    for(int i:g[u])\n        if(i!=fr)\n            DFS(i,u),sg[u]^=sg[i];\n    sg[u]+=u!=1;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=2,f,t;i<=n;i++) scanf(\"%d%d\",&f,&t),g[f].push_back(t),g[t].push_back(f);\n    DFS(1,0);\n    puts(sg[1]==0? \"Bob\":\"Alice\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e5+5;\nint a[maxn],n,m,opt,x,y,tpp,z,val[maxn],kl,head[maxn],ind[maxn],sg[maxn];\nstruct line{int to,next,val;}q[maxn*2];\nvoid pushline(int f,int t){ind[f]++,q[++kl].next=head[f];head[f]=kl;q[kl].to=t;q[kl].val=z;}\nvoid dfs(int x,int fa)\n{\n\tfor(int p=head[x];int v=q[p].to;p=q[p].next)\n\t{\n\t\tif(v==fa)continue;\n\t\tdfs(v,x);\n\t\tsg[x]^=sg[v]+1;\n\t//\tcout<<x<<\" \"<<sg[x]<<\" \"<<sg[v]<<endl;\n\t\t\n\t}\n\t//cout<<\"fin\"<<x<<\" \"<<sg[x]<<endl;\n}\nsigned main()\n{\n\t\n\tcin>>n;\n\tfor(int i=1;i<n;i++){scanf(\"%d%d\",&x,&y);pushline(x,y);pushline(y,x);}\n\tdfs(1,0);\n\tif(sg[1])cout<<\"Alice\";\n\telse cout<<\"Bob\";\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nvector<int>vec[N];\nint vis[N],sg[N];\nint dfs(int u,int fa) {\n    int re=0;\n    for(int i=0; i<vec[u].size(); i++) {\n        if(vec[u][i]!=fa) {\n            re^=(1+sg[vec[u][i]]);\n        }\n    }\n    return re;\n}\nint main() {\n        int n;\n        scanf(\"%d\",&n);\n        for(int i=1; i<=n; i++) {\n            vec[i].clear();\n            vis[i]=0;\n        }\n        for(int i=1; i<n; i++) {\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            vec[a].push_back(b);\n            vis[b]=1;\n        }\n    printf(dfs(1,0)?\"Alice\\n\":\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint n, x, y;\nvector<int> g[100100];\n\nint Dfs(int x, int fa) {\n\tint ans = 0;\n\tfor(int i = 0; i < (int)g[x].size(); i++) {\n\t\tint v = g[x][i];\n\t\tif(v == fa) continue;\n\t\tans ^= (Dfs(v, x) + 1);\n\t}\n//\tprintf(\"%d : %d\\n\", x, ans ^ c1);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tDfs(1, 0) ? puts(\"Alice\") : puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link renamelink\n#define next renamenext\n#define prev renameprev\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string& fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 1e5 + 100;\n\nint n;\nvector<int> G[N];\nint val[N];\n\nvoid dfs(int u, int p) {\n  set<int> st;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (v == p) continue;\n    dfs(v, u);\n    st.insert(val[v]);\n  }\n  int& res = val[u];\n  while (st.count(res)) ++res;\n}\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n  dfs(0, -1);\n  int cnt = 0;\n  for (int i = 0; i < G[0].size(); i++) {\n    int u = G[0][i];\n    if (val[u] == 0) ++cnt;\n  }\n  if ((((int)G[0].size() - cnt) & 1)) {\n    puts(\"Alice\");\n  } else {\n    puts(\"Bob\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n\nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,k;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>n;\n    rep(i,n-1){\n            cin>>x>>y;\n            if(x==1)cnt++;\n    }\n    if(cnt%2==0)Cout(\"Bob\");\n    else Cout(\"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nint n,x,y,f[500010],hed[500010],too[500010],nxt[500010],nedge;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nvoid dfs(int x,int l){\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t\tf[x]^=f[y]+1;\n\t}\n}\nint main(){\n\tcin>>n;\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t}\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//作者：中国江苏省南京市李硕睿\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\nusing namespace std;\ntypedef long long ll;\nconst int =1e5+7;\nvector<int> adj[N];\nint mark[N];\nint nim[N];\nvoid dfs(int v,int p){\n\tfor (auto u:adj[v])\n\t\tif (u!=p){\n\t\t\tdfs(u,v);\n\t\t\tnim[v]^=nim[u]+1;\n\t\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--; \n\t\tv--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\tdfs(0,-1);\n\tcout<<(nim[0] ? \"Alice\" : \"Bob\")<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 101000;\n\nvector <int> adj[N];\nint val[N];\n\n// if fix 1, we have a green hackenbush\n\nint dfs(int u, int l) {\n\tval[u] = 0;\n\tfor (int x: adj[u]) {\n\t\tval[u]^=(val[x]+1);\n\t}\n\treturn val[u];\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t}\n\t\n\tdfs(1, -1);\n\tif(val[1] == 0) {\n\t\tprintf(\"Bob\\n\");\n\t} else {\n\t\tprintf(\"Alice\\n\");\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  In The Name Of GOD\n  author: amirhoseinatari\n*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define pp() pop_back()\n#define mp make_pair\n#define fir first\n#define sec second\n#define momaz(x) cout.precision(x);cout<<fixed\n#define _ ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\n#define debug(x) cout<<string(20,'#')<<endl<< #x <<\"--> \"<<x<<endl<<string(20,'-')<<endl\n#define debug1(x) cout<<string(20,'#')<<endl<< #x <<\"--> \"<<x<<endl<<string(20,'-')<<endl\n#define debug2(x,y) cout<<string(20,'#')<<endl<< #x <<\"--> \"<<x<<endl<< #y <<\"--> \"<<y<<endl<<string(20,'-')<<endl\n#define debug3(x,y,z) cout<<string(20,'#')<<endl<< #x <<\"--> \"<<x<<endl<< #y <<\"--> \"<<y<<endl<< #z <<\"--> \"<<z<<endl<<string(20,'-')<<endl\n#define debug4(x,y,z,t) cout<<string(20,'#')<<endl<< #x <<\"--> \"<<x<<endl<< #y <<\"--> \"<<y<<endl<< #z <<\"--> \"<<z<<endl<< #t <<\"--> \"<<t<<endl<<string(20,'-')<<endl\n///freopen(\"input.txt\",\"r\",stdin);   add to main()\n///freopen(\"output.txt\",\"w\",stdout);     //\n\n/*\n</head>\n<body>\n*/\n\nconst ll maxn = 100050 ;\nvi a[maxn];\n\nint dfs(int v,int par)\n{\n    int ans=0;\n    for(auto i:a[v])\n    {\n        if(i!=par)\n            ans^=dfs(i,v)+1;\n    }\n    return ans;\n}\nint main()\n{_\n\tint n,q1,q2;\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n        cin>>q1>>q2,a[q1].pb(q2),a[q2].pb(q1);\n    if(dfs(1,-1)==0)\n        cout<<\"Bob\";\n    else\n        cout<<\"Alice\";\n\n    return 0;\n}\n///Attar81 :)"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int N=200005;\nint head[N],nxt[N],to[N],e;\nint sg[N];\nvoid init(){\n\tmemset(head,-1,sizeof(head));\n\te=0;\n}\nvoid add_edge(int x,int y){\n\tto[e]=y;nxt[e]=head[x];head[x]=e++;\n}\nvoid dfs(int x,int f){\n\tsg[x]=0;\n\tfor(int i=head[x];i+1;i=nxt[i])if(to[i]!=f){\n\t\tdfs(to[i],x);\n\t\tsg[x]^=(sg[to[i]]+1);\n\t}\n}\nint main(){\n\tint n;read(n);\n\tinit();\n\trep(i,1,n-1){\n\t\tint x,y;\n\t\tread(x);read(y);\n\t\tadd_edge(x,y);\n\t\tadd_edge(y,x);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nint dp[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      //dp[v] += dp[to];\n      dp[v]++;\n    }\n  }\n}\nvoid solve() {\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  dfs(1, 1);\n  int res = 0;\n  rep(i, 1, n)\n    res ^= dp[i];\n  if (res) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, N) for (int i = 0; i < (int)N; i++)\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<vector<ll>> adj;\nint dfs(int n=0, int p=-1) {\n  int result = 0;\n  for (auto x: adj[n]) {\n    if (x==p) continue;\n    result ^= dfs(x,n);\n  }\n  if (p!=-1) result++;\n  cout << n << \" \" << p << \" \" << result << endl;\n  return result;\n}\n\nint main() {\n  int N; cin >> N;\n  adj.resize(N);\n  rep(i,N-1) {\n    // ll x, y; cin >> x >> y; x--; y--;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  string result = dfs() ? \"Alice\" : \"Bob\";\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define pb push_back\n#define tl(x) ((int)x.size()-1)\n#define rep(i,j,k) for (i=j;i<=k;i++)\nusing namespace std;\nconst int N=1e5+5;\nint n,i,u,v,ans;\nvector<int> b[N];\nint dfs(int x,int fa) {\n\tint j,ret=0;\n\trep(j,0,tl(b[x]))\n\tif (b[x][j]!=fa)\n\t\tret^=dfs(b[x][j],x)+1;\n\treturn ret;\n}\nint main()\n{\n\t//freopen(\"tree.in\",\"r\",stdin);\n\t//freopen(\"tree.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tb[u].pb(v); b[v].pb(u);\n\t}\n\tans=dfs(1,1);\n\tif (ans) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n//#define PB push_back\n#define PB emplace_back\n#define F first\n#define S second\n#define MP make_pair\n#define endl '\\n'\n\nconst double PI = acos(-1);\nconst double eps = 1e-9;\nconst int inf = 2000000000;\nconst ll infLL = 9000000000000000000;\n#define MOD 1000000007\n//#define harmonic(n) 0.57721566490153286l+log(n)\n\n#define mem(a,b) memset(a, b, sizeof(a) )\n#define gcd(a,b) __gcd(a,b)\n#define lcm(a,b) (a*(b/gcd(a,b)))\n#define sqr(a) ((a) * (a))\n\n#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define fraction() cout.unsetf(ios::floatfield); cout.precision(10); cout.setf(ios::fixed,ios::floatfield);\n\ntypedef vector<int>::iterator vit;\ntypedef set<int>::iterator sit;\n\ninline bool checkBit(ll n, int i) { return n&(1LL<<i); }\ninline ll setBit(ll n, int i) { return n|(1LL<<i);; }\ninline ll resetBit(ll n, int i) { return n&(~(1LL<<i)); }\n\nint dx[] = {0, 0, +1, -1};\nint dy[] = {+1, -1, 0, 0};\n//int dx[] = {+1, 0, -1, 0, +1, +1, -1, -1};\n//int dy[] = {0, +1, 0, -1, +1, -1, +1, -1};\n\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\ninline bool isLeapYear(ll year) { return (year%400==0) || (year%4==0 && year%100!=0); }\ninline void normal(ll &a) { a %= MOD; (a < 0) && (a += MOD); }\ninline ll modMul(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); return (a*b)%MOD; }\ninline ll modAdd(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); return (a+b)%MOD; }\ninline ll modSub(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); a -= b; normal(a); return a; }\ninline ll modPow(ll b, ll p) { ll r = 1; while(p) { if(p&1) r = modMul(r, b); b = modMul(b, b); p >>= 1; } return r; }\ninline ll modInverse(ll a) { return modPow(a, MOD-2); }\ninline ll modDiv(ll a, ll b) { return modMul(a, modInverse(b)); }\n\n/*\nbool seive[1010000];\nvi prime;\n\nvoid seiveGen(int limit) {\n    limit += 100;\n    int sqrtn = sqrt(limit);\n    for(int i = 3; i <= sqrtn; i += 2) {\n            if(!seive[i>>1]) {\n                    for(int j = i * i; j < limit; j += i + i) {\n                            seive[j>>1] = 1;\n                    }\n            }\n    }\n    prime.PB(2);\n    for(int i = 3; i < limit; i += 2) {\n            if(!seive[i>>1]) prime.PB(i);\n    }\n}\n*/\n\n//\n//debug\n#ifdef yamin\ntemplate < typename F, typename S >\nostream& operator << ( ostream& os, const pair< F, S > & p ) {\n            return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate < typename T >\nostream &operator << ( ostream & os, const vector< T > &v ) {\n            os << \"{\";\n                for(auto it = v.begin(); it != v.end(); ++it) {\n                                if( it != v.begin() ) os << \", \";\n                                        os << *it;\n                                            }\n                    return os << \"}\";\n}\n\ntemplate < typename T >\nostream &operator << ( ostream & os, const set< T > &v ) {\n            os << \"[\";\n                for(auto it = v.begin(); it != v.end(); ++it) {\n                                if( it != v.begin() ) os << \", \";\n                                        os << *it;\n                                            }\n                    return os << \"]\";\n}\n\ntemplate < typename T >\nostream &operator << ( ostream & os, const multiset< T > &v ) {\n            os << \"[\";\n                for(auto it = v.begin(); it != v.end(); ++it) {\n                                if( it != v.begin() ) os << \", \";\n                                        os << *it;\n                                            }\n                    return os << \"]\";\n}\n\ntemplate < typename F, typename S >\nostream &operator << ( ostream & os, const map< F, S > &v ) {\n            os << \"[\";\n                for(auto it = v.begin(); it != v.end(); ++it) {\n                                if( it != v.begin() ) os << \", \";\n                                        os << it -> first << \" = \" << it -> second ;\n                                            }\n                    return os << \"]\";\n}\n\n#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)\n\nclock_t tStart = clock();\n#define timeStamp dbg(\"Execution Time: \", (double)(clock() - tStart)/CLOCKS_PER_SEC)\n\nvoid faltu () {\n            cerr << endl;\n}\n\ntemplate <typename T>\nvoid faltu( T a[], int n ) {\n            for(int i = 0; i < n; ++i) cerr << a[i] << ' ';\n                cerr << endl;\n}\n\ntemplate <typename T, typename ... hello>\nvoid faltu( T arg, const hello &... rest) {\n            cerr << arg << ' ';\n                faltu(rest...);\n}\n#else\n#define dbg(args...)\n#endif // yamin\n\n//they see me trolling\n//they hating\n\nconst int N = 1e5 + 100;\n\nvi adjList[N];\n\nint dfs(int u, int p)\n{\n\tint ret = 0;\n\tfor (auto v : adjList[u]) {\n\t\tif(v == p) continue;\n\t\tret ^= dfs(v, u) + 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadjList[x].PB(y);\n\t\tadjList[y].PB(x);\n\t}\n\n\tif (dfs(1, 0))\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0;i < (int)(n);i++)\n#define RREP(i,n) for(int i = (int)n-1;i >= 0;i--)\n#define FOR(i,s,n) for(int i = s;i < (int)n;i++)\n#define RFOR(i,s,n) for(int i = (int)n-1;i >= s;i--)\n#define ALL(a) a.begin(),a.end()\n#define IN(a, x, b) (a<=x && x<b)\n#define BIT(S,i) ((S&(1ll<<i))>0)\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a = b;return true;}return false;}\nconstexpr long long INF = 1e18;\n\nsigned main(){\n\tint N;\n\tcin>>N;\n\tvector<vector<int>>g(N);\n\tREP(i,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tauto dfs = [&](auto&&f,int now,int par)->int{\n\t\tint ret = 0;\n\t\tfor(auto e:g[now]){\n\t\t\tif(e == par)continue;\n\t\t\tret ^= (1 + f(f,e,now));\n\t\t}\n\t\treturn ret;\n\t};\n\tif(dfs(dfs,0,-1))cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nvector<int> G[N];\nint n, sg[N];\n\nvoid DFS(int o, int f){\n\tfor(int v : G[o]){\n\t\tif(v == f) continue;\n\t\tDFS(v, o);\n\t\tsg[o] ^= sg[v] + 1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\tDFS(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint G[100001];\nvector<int> E[100001];\nint dfs(int A) {\n\tint g = 0;\n\tG[A] = -1;\n\tfor (auto i : E[A]) {\n\t\tif (G[i] != -1) g ^= dfs(i);\n\t}\n\treturn G[A] = g + 1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\trep(i, N - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\n\tdfs(1);\n\n\tif (G[1] - 1) co(\"Alice\");\n\telse co(\"Bob\");\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\nconst int N=100010;\nint e[N*2],next[N*2],head[N],ed=0;\nvoid adde(int x,int y){e[++ed]=y;next[ed]=head[x];head[x]=ed;}\nint dfs(int x,int fa){\n    int i,t=0;\n    for(i=head[x];i;i=next[i])\n        if(e[i]!=fa) t^=dfs(e[i],x)+1;\n    return t;\n}\nint main(){\n    int n,i,x,y;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++){\n        scanf(\"%d %d\",&x,&y);\n        adde(x,y);adde(y,x);\n    }\n    if(dfs(1,0)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 6;\n\nvector<int> edg[MAX_N];\nbool visit[MAX_N];\n\nint dfs(int id) {\n    visit[id]=1;\n    int ret=0;\n    for (int i:edg[id]) {\n        if (!visit[i]) ret ^= (dfs(i)+1);\n    }\n    return ret;\n}\n\nint main () {\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=1;n>i;i++) {\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        edg[a].push_back(b);\n        edg[b].push_back(a);\n    }\n    int ret=dfs(1);\n    if (ret==0) puts(\"Bob\");\n    else puts(\"Alice\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int N=100100;\nint i,j,k,n,m,ch,ff,x,y,En;\nint h[N],sg[N];\nstruct edge { int s,n;} E[N<<1];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(int x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nvoid R(ll &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nvoid E_add(int x,int y) {\n\tE[++En].s=y;E[En].n=h[x];h[x]=En;\n\tE[++En].s=x;E[En].n=h[y];h[y]=En;\n}\nvoid dfs(int x,int F) {\n\tfor (int k=h[x];k;k=E[k].n) if (E[k].s!=F) {\n\t\tdfs(E[k].s,x);\n\t\tsg[x]^=sg[E[k].s]+1;\n\t}\n}\nint main() {\n\tR(n);\n\tfor (i=1;i<n;i++) {\n\t\tR(x);R(y);\n\t\tE_add(x,y);\n\t}\n\tdfs(1,0);\n\tif (sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pqueue priority_queue\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll mod1=998244353;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nint N;\nvector<vector<int> > edge(100005);\nint DP[100005];\n\nint solve(int u, int v) {\n  if(DP[u]>-1) return DP[u];\n  int ans = 0;\n  for(int i=0;i<edge[u].size();++i) {\n    if(edge[u][i]==v) continue;\n    ans ^= solve(edge[u][i], u)+1;\n  }\n  return ans;\n}\n\nint main() {\n  cin>>N;\n  int a, b;\n  for(int i=0;i<N-1;++i) {\n    cin>>a>>b;\n    a--;\n    b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  for(int i=0;i<N;++i) DP[i] = -1;\n  if(solve(0, -1)==0) cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n;\nvector<int> ed[500000];\nint x, y;\nint f[300000];\nvoid dfs(int x, int y) {\n    for (int i = 0; i < ed[x].size(); i++) {\n        int to = ed[x][i];\n        if (to == y) continue;\n        dfs(to, x);\n        f[x] ^= f[to] + 1;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        cin >> x >> y;\n        ed[x].push_back(y);\n        ed[y].push_back(x);\n    }\n    dfs(1, 0);\n    if (f[1] > 0) cout << \"Alice\\n\";\n    else cout << \"Bob\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\nusing namespace std;\ntypedef long long LL;\nconst int N=1000010;\ntemplate<typename T>inline T chkmax(T A,T B){return A>B?A:B;}\ntemplate<typename T>inline T chkmin(T A,T B){return A<B?A:B;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n;\nint bgn[N],nxt[N<<1],to[N<<1],E,SG[N];\ninline void add_edge(int x,int y)\n{\n\tnxt[++E]=bgn[x],bgn[x]=E,to[E]=y;\n}\ninline void dfs(int u,int f)\n{\n\tSG[u]=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tSG[u]^=SG[v];\n\t}\n}\nint main()\n{\n\tint x,y;\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y);add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tif(SG[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\nli n;\nvector<vector<li>> g;\n\nli grundy(li pos, li parent) {\n    li res = 0;\n    for (li next : g[pos]) {\n        if (next == parent) {\n            continue;\n        }\n        res ^= grundy(next, pos) + 1;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    g = vector<vector<li>>(n);\n    for (int i = 0; i < n - 1; ++i) {\n        li x, y;\n        cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    cout << (grundy(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\nconst int MAXN = 100100;\nint n;\nint head[MAXN], to[MAXN << 1], nxt[MAXN << 1], cnt;\ninline void addedge(int u, int v) {\n    to[++cnt] = v, nxt[cnt] = head[u], head[u] = cnt,\n    to[++cnt] = u, nxt[cnt] = head[v], head[v] = cnt;\n}\ninline int dfs(int u, int v) {\n    int res = 0, tmp = head[u];\n    while(tmp) {\n        if(to[tmp] != v) res ^= dfs(to[tmp], u) + 1;\n        tmp = nxt[tmp];\n    } return res;\n}\nint main() {\n    int u, v;\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        addedge(u, v);\n    } if(dfs(1, 0)) puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint h[N];\nint used[N];\nvector<int> g[N];\n\nvoid dfs(int cur, int ch) {\n    h[ch] ^= 1;\n    used[cur] = 1;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t, ch + 1);\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0, 0);\n    for (int i = 1; i <= n; i++) {\n        if (h[i]) {\n            cout << \"Alice\\n\";\n            return 0;\n        }\n    }\n    cout << \"Bob\\n\";\n}       \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define maxn 100005\nint n;\nstruct node { int v; node *nxt; } edge[maxn*2],*head[maxn],*ncnt;\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[u];\n\thead[u]=ncnt;\n}\nint dfs(int u,int fa)\n{\n\tint res=0;\n\tfor(node *p=head[u];p;p=p->nxt)\n\t{\n\t\tint v=p->v;\n\t\tif(v!=fa) res^=dfs(v,u)+1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tncnt=&edge[0];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tprintf(\"%s\\n\",dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<math.h>\n#include<unordered_set>\n#include<string.h>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\n\n#define FOR(i,N) for(int i=0;i<N;i++)\n\nll mod=1e9+7;\n\n\nint main() {\n    int n;\n    cin>>n;\n    int a=0;\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        if(x==1||y==1){\n            a++;\n        }\n    }\n    if(a==1){\n        cout<<\"Alice\"<<endl;\n    } else {\n        if((n-1)%2==1){\n            cout<<\"Alice\"<<endl;\n        } else {\n            cout<<\"Bob\"<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nint sg[maxn];\nvector<int> E[maxn];\nvoid dfs(int x, int fa)\n{\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tdfs(v, x);\n\t\t\tsg[x] ^= (sg[v] + 1);\n\t\t} \n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int maxn = 1e5 +100;\nvector<int> G[maxn];\nint sg[maxn];\nvoid dfs(int x, int fa){\n    sg[x] = 0;\n    if(G[x].size() == 2 && x != 1){\n        for(auto to : G[x]) if(to != fa) dfs(to, x), sg[x] = sg[to] + 1;\n        return;\n    }\n    for(auto to : G[x]){\n        if(to == fa) continue;\n        dfs(to, x);\n        sg[x] ^= sg[to];\n    }\n}\n\nint main()\n{\n    int n, x, y;\n    cin>>n;\n    for(int i = 1; i < n; i++){\n        scanf(\"%d %d\", &x, &y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1, 1);\n    //for(int i = 1; i <= n; i++) cout<<sg[i]<<\" \";  cout<<endl;\n    if(sg[1]) cout<<\"Alice\";\n    else cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ll MOD = 1e9 + 7, INF = 1e18 + 1;\n \nusing namespace std;\n\nvector <int> g[1000000];\n\nint a[1000000], n;\n\nint dfs (int x, int p)\n{\n\tfor (int to : g[x])\n\t\tif (to != p)\n\t\t\ta[x] ^= dfs (to, x) + 1;\n\n\treturn a[x];\n}\n\nint main ()\n{\n\tcin >> n;\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v;\n\n\t\tscanf (\"%d%d\", &u, &v);\n\n\t\tg[u-1].push_back (v - 1);\n\t\tg[v-1].push_back (u - 1);\n\t}\n\n\tif (dfs (0, -1)) cout << \"Alice\";\n\telse cout << \"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define MAXN 100006\n#include<algorithm>\nusing namespace std;\nint d[MAXN],n,u,v;\nvector<int> road[MAXN];\nvoid DFS(int x,int fa)\n{\n\tfor(int i=0;i<(int)road[x].size();i++)\n\t{\n\t\tint nex=road[x][i];\n\t\tif(nex==fa) continue;\n\t\tDFS(nex,x);\n\t\td[x]^=(d[nex]+1);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\troad[u].push_back(v);\n\t\troad[v].push_back(u);\n\t}\n\tDFS(1,0);\n\tif(d[1]) printf(\"Alice\");\n\telse printf(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nint n;\nconst int maxn = 1e5 + 5;\n\nvector<int> G[maxn];\n\nint dfs(int u, int fa){\n    int ans = 0;\n    for(auto v : G[u]){\n        if(v == fa)\n            continue;\n        ans ^= (dfs(v, u) + 1);\n    } \n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    int ret = dfs(1, 0);\n    if(ret == 0){\n        cout << \"Bob\" << endl;\n    }else{\n        cout << \"Alice\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define inf 1000000007LL\n#define mod 1000000007LL\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define trep(i, n) for(int i = 0; i <= (n); i++)\n#define rrep(i, n) for(int i = (n) - 1; i >= 0; i--)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define mfor(i, s, t) for(int i = (s); i < (t); i++)\n#define tfor(i, s, t) for(int i = (s); i <= (t); i++)\n#define rfor(i, s, t) for(int i = (t) - 1; i >= (s); i--)\n\nvector<int> v[334334];\n\nint dfs(int p, int o) {\n  int now = 0;\n  for(auto i : v[p]) {\n    if(i != o) {\n      now ^= dfs(i, p) + 1;\n    }\n  }\n  return now;\n}\n\nsigned main() {\n  int n;\n  cin >> n;\n  rep(i, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  if(dfs(0, -1) == 0) {\n    cout << \"Bob\" << endl;\n  }\n  else {\n    cout << \"Alice\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nint dp[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      //dp[v] += dp[to];\n      dp[v]++;\n    }\n  }\n}\nvoid solve() {\n  freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  dfs(1, 1);\n  int res = 0;\n  rep(i, 1, n)\n    res ^= dp[i];\n  if (res) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint n,x[100005];\nvi g[100005];\nvoid dfs(int v,int p){\n\tfor(auto &i:g[v]){\n\t\tif(i==p)continue;\n\t\tdfs(i,v);\n\t\tx[v]^=(x[i]+1);\n\t}\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[--a].pb(--b);\n\t\tg[b].pb(a);\n\t}\n\tdfs(0,-1);\n\tif(x[0]==0)cout<<\"Bob\\n\";\n\telse cout<<\"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 42;\nint mx[maxn];\nvector<int> g[maxn];\n\nvoid dfs(int v = 0, int p = 0)\n{\n    set<int> lol;\n    int c = 0;\n    for(auto u: g[v])\n    {\n        if(u == p)\n            continue;\n        dfs(u, v);\n        c++;\n        mx[v] ^= 1 ^ mx[u];\n    }\n    if(c == 1)\n        mx[v] = 1;\n}\n\nsigned main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    for(int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        g[u - 1].push_back(v - 1);\n        g[v - 1].push_back(u - 1);\n    }\n    dfs();\n    cout << (mx[0] == 0 ? \"Bob\" : \"Alice\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define N 10005\n#define LL long long\n#define inf 1<<29\n#define eps 1e-7\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int t,n;\n    //scanf(\"%d\",&t);\n   // while(t--){\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    //}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n//#include <regex>\n\n/* g++ -g -std=c++0x */\n/* g++ -g -std=c++11 */\n\nusing namespace std;\n\n// std::ios::sync_with_stdio(false);\n\n// freopen(\"input.txt\", \"rt\", stdin);\n// freopen(\"output.txt\", \"wt\", stdout);\n\n#define ALL(c)          (c).begin(), (c).end()\n#define ALLR(c)         (c).rbegin(), (c).rend()\n#define FOR(i,a,b)      for (int i=(a); i < (b); ++i)\n#define FORR(i,a,b)     for (int i=(a); i > (b); --i)\n#define FOR_ALL(i,c)    for (__typeof((c).begin()) i=(c).begin();   \\\n                             i != (c).end(); ++i)\n#define FOR_ALLR(i,c)   for (__typeof((c).rbegin()) i=(c).rbegin(); \\\n                             i != (c).rend(); ++i)\n#define SZ(array)       (sizeof(array)/sizeof(array[0]))\n#define lc(x)           (x<<1)     /* 2*x */\n#define rc(x)           (x<<1 | 1) /* 2*x+1 */\n#define lowbit(x)       (x & (-x)) /* 0b10100 -> 0b100 */\n\ntypedef long long       LL;\ntypedef map<int,int>    MII;\ntypedef pair<int,int>   PII;\ntypedef set<int>        SI;\ntypedef vector<bool>    VB;\ntypedef vector<double>  VD;\ntypedef vector<int>     VI;\ntypedef vector<string>  VS;\n\n/* check if a key is in container C */\ntemplate <class C>\ninline bool in_(const typename C::key_type& k, const C& A)\n{ return A.find(k) != A.end(); }\ninline bool in_(const string& s, const string& S)\n{ return S.find(s) != string::npos; }\n\n/*\n * Suppose that the root has k > 1 children. In this case, we can\n * decompose the original tree into k smaller trees, and the Grundy\n * Number of the original tree is XOR of the Grundy Numbers of new k\n * trees.\n *\n * If the root has exactly one child, we can compute the Grundy Number\n * using the following theorem:\n *\n * Theorem. Let G(T) be the Grundy Number of a rooted tree T. Let T' be\n * a rooted tree obtained by attaching an edge to the root of T (and the\n * new root is the new node attached to the old root). Then,\n * G(T') = G(T)+1.\n *\n * Proof. We can prove it by the induction on the number of vertices in\n * T. Let's compute the Grundy Number of T'.\n *\n * If we remove the new edge, we get a single node, and its Grundy\n * Number is zero.\n *\n * Suppose that we remove one of other edges, and we get a new tree S.\n * This tree is of the form\n * \"(one of trees reachable from T) + (one edge)\". By the induction\n * hypothesis, in the set of Grundy Numbers of these trees,\n * 0+1, 1+1, .. ,G(T)-1+1 will appear, but G(T)+1 won't.\n * Therefore, G(T') = G(T) + 1.\n */\n\nconst int maxv = 1e5+5;\nint vis[maxv];\nVI G[maxv];\n\nint dfs(const int u)\n{\n    vis[u]++;\n    int ans = 0;\n    FOR_ALL(v,G[u]) if (!vis[*v]) \n        ans ^= 1+dfs(*v);\n    return ans;\n}\n\nint main()\n{\n/* #ifndef ONLINE_JUDGE */\n/*     freopen(\"foo\", \"rt\", stdin); */\n/* #endif */\n    int N;\n    while (cin >> N) {\n        FOR(i,0,N+1)\n            G[i].clear();\n        FOR(_,1,N) {\n            int x,y; cin >> x >> y;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        memset(vis,0,sizeof(vis));\n        const int grundy = dfs(1);\n        const string ans = grundy ? \"Alice\" : \"Bob\";\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int> > e;\nvector<int> gr;\n\nvoid dfs(int i,int p)\n{\n  gr[i]=0;\n  for(int x=0;x<e[i].size();x++){\n    int j=e[i][x];\n    if(j==p)continue;\n    dfs(j,i);\n    gr[i]^=gr[j]+1;\n  }\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  e=vector<vector<int> >(n);\n  for(int t=0;t<n-1;t++){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    x--,y--;\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  gr=vector<int>(n);\n  dfs(0,-1);\n  puts(gr[0]?\"Alice\":\"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nvector<int> g[100010];\nbool used[100010];\n\n/*int child[100010];\n\nint setChild(int now){\n    used[now]=true;\n    int res=0;\n    for(int i=0;i<g[now].size();i++){\n        int next=g[now][i];\n        if(used[next]) continue;\n\n        res+=setChild(next);\n    }\n    return (child[now]=res+1);\n}*/\n\nint dfs(int now){\n    used[now]=true;\n    int res=0;\n    for(int i=0;i<g[now].size();i++){\n        int next=g[now][i];\n        if(used[next]) continue;\n\n        res^=dfs(next);\n    }\n    return(res+1);\n}\n\nint main(){\n  cin>>N;\n  for(int i=1;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      x--;\n      y--;\n      g[x].push_back(y);\n      g[y].push_back(x);\n  }\n\n  used[0]=true;\n  /*for(int i=0;i<g[0].size();i++){\n      int x=setChild(g[0][i]);\n  }\n  for(int i=0;i<N;i++) used[i]=false;*/\n\n  int ans=0;\n  for(int i=0;i<g[0].size();i++){\n      int grundy=dfs(g[0][i]);\n      grundy--;\n      ans^=grundy;\n  }\n  /*for(int i=0;i<g[0].size();i++){\n      cout<<g[0][i]<<endl;\n      int ver=dfs(g[0][i],child[g[0][i]]);\n      for(int j=0;j<grundy.size();j++){\n          grundy[j]=ver-grundy[j];\n      }\n      sort(grundy.begin(),grundy.end());\n      grundy.erase(unique(grundy.begin(),grundy.end()),grundy.end());\n\n      int mi=0;\n      for(int j=0;j<grundy.size();j++) cout<<grundy[j]<<endl;\n      for(;mi<grundy.size();mi++){\n          if(mi!=grundy[mi]) break;\n      }\n      ans^=mi;\n      cout<<\"   \"<<mi<<endl;\n      grundy.clear();\n  }*/\n\n  if(ans==0) cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 2147483647 / 2;\nconst long long int llINF = 9223372036854775807 / 2;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VV(T, a, b, c) vector<vector<T>>(a, vector<T>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define VVV(T, a, b, c, d)                                                     \\\n  vector<vector<vector<T>>>(a, vector<vector<T>>(b, vector<T>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll dfs(vvl &G, ll now, ll par) {\n  ll po = 0;\n  ll count = 0;\n  AUTO(g, G[now]) {\n    if (g == par)\n      continue;\n    po ^= dfs(G, g, now) + 1;\n    count++;\n  }\n  // cout << now + 1 << po << endl;\n  return po;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ll N;\n  cin >> N;\n  vector<vector<ll>> G(N);\n  REP(i, N - 1) {\n    ll x, y;\n    cin >> x >> y;\n    G[x - 1].push_back(y - 1);\n    G[y - 1].push_back(x - 1);\n  }\n  if (dfs(G, 0, -1))\n    cout << \"Alice\" << endl;\n  else\n    cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tvi e[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(y);\n\t\t\te[y].pb(x);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tbool ans;\n\t\n\tvoid write () {\n\t\tputs(ans ? \"Alice\" : \"Bob\");\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint dfs (int v, int pr) {\n\t\t\tint res = 0;\n\t\t\tfor (int to : e[v]) {\n\t\t\t\tif (to == pr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres ^= dfs(to, v) + 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tans = dfs(0, -1);\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#define R(a,b,c) for(register int a = (b); a <= (c); ++a)\n#define nR(a,b,c) for(register int a = (b); a >= (c); --a)\n#define Swap(a,b) ((a) ^= (b) ^= (a) ^= (b))\n#define MP make_pair\n#ifdef QWQ\n#define D_e_Line printf(\"\\n--------\\n\")\n#define D_e(x) cout << (#x) << \" : \" << x << endl\n#define C_e(x) cerr << (#x) << \" : \" << x << endl\n#define Pause() system(\"pause\")\n#define FileOpen() freopen(\"in.txt\", \"r\", stdin)\n#define FileSave() freopen(\"out.txt\", \"w\", stdout)\n#include <assert.h>\n#define TIME() fprint(stderr, \"TIME : %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC)\n#define dbg(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define D_e_Line\n#define D_e(x)\n#define C_e(x)\n#define Pause\n#define FileOpen()\n#define FileSave()\n#define TIME()\n#define dbg(...)\n#endif\nstruct FastIO {\n\ttemplate<typename ATP> inline FastIO& operator >> (ATP &x) {\n\t\tx = 0; int f = 1; char c;\n\t\tfor(c = getchar(); c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;\n\t\twhile(c >= '0' && c <= '9') x = x * 10 + (c ^ '0'), c = getchar();\n\t\tif(f == -1) x = -x;\n\t\treturn *this;\n\t}\n} io;\nusing namespace std;\ntemplate<typename ATP> inline ATP Max(ATP x, ATP y) {\n\treturn x > y ? x : y;\n}\ntemplate<typename ATP> inline ATP Min(ATP x, ATP y) {\n\treturn x < y ? x : y;\n}\ntemplate<typename ATP> inline ATP Abs(ATP x) {\n\treturn x < 0 ? -x : x;\n}\n#include <vector>\n\nconst int N = 1e5 + 7;\n\nvector<int> G[N];\n\nint f[N];\nint siz[N];\ninline void DFS(int u, int father) {\n\tR(i,0,G[u].size() - 1){\n\t\tint v = G[u][i];\n\t\tif(v == father) continue;\n\t\tDFS(v, u);\n\t\tf[u] ^= f[v] + 1;\n\t}\n}\n\nint main() {\n\tint n;\n\tio >> n;\n\tR(i,2,n){\n\t\tint u, v;\n\t\tio >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tDFS(1, 1);\n//\tR(i,1,n) D_e(f[i]);\n\tif(f[1]){\n\t\tprintf(\"Alice\");\n\t}\n\telse{\n\t\tprintf(\"Bob\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n///////////// マクロ, エイリアス /////////////////\n#pragma region macros_and_aliases\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing mii = map<int, int>;\nusing pqll = priority_queue<long long>;\nusing pqllg = priority_queue<long long, vector<long long>, greater<long long>>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n#pragma endregion\n\n///////////// 定数など /////////////////\n#pragma region constants\n\nlong long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\nlong long const dekai = 1e15;\nconst long double pi = acos(-1);\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nint ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\n#pragma endregion\n\n// // 多倍長テンプレ\n// /* ---------------------- ここから ---------------------- */\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// // 任意長整数型\n// using Bint = mp::cpp_int;\n// // 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n// using Real = mp::number<mp::cpp_dec_float<1024>>;\n// /* ---------------------- ここまで ---------------------- */\n\n/////////////////// 基本処理系 ////////////////////\n#pragma region basic_procedure\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#pragma endregion\n\n//////////////// 数学処理系 ///////////////////////\n#pragma region math\n\ntemplate <class T>\nT divup(T a, T b) {\n\t//端数繰りあがり割り算\n\tassert(b != 0);\n\tT x = abs(a);\n\tT y = abs(b);\n\tT z = (x + y - 1) / y;\n\tif((a < 0 && b > 0) || (a > 0 && b < 0))\n\t\treturn -z;\n\telse if(a == 0)\n\t\treturn 0;\n\telse\n\t\treturn z;\n}\n\nlong long POW(long long a, long long n) {\n\t// 整数のとき限定の普通のPOW関数\n\t//標準機能のpow(a,n)は整数だとバグるのでこちらを使う\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ntemplate <class T>\nbool prime(T N) {\n\t//素数判定\n\t//素数ならばtrue、素数以外の整数にはfalse\n\t//負数は全てfalse\n\t//検証済み\n\tif(N <= 1) return false;\n\tT p = sqrt(N);\n\tfor(long long i = 2; i <= p; i++)\n\t\tif(N % i == 0) return false;\n\treturn true;\n}\n\nvector<long long> eratos(long long n) {\n\t//エラトステネスのふるい\n\t//素数なら1,素数でないなら0\n\tassert(n >= 0);\n\tvll v(n + 1, 1);\n\tif(n >= 0) v[0] = 0;\n\tif(n >= 1) v[1] = 0;\n\tRep(i, 2, n + 1) {\n\t\tif(v[i]) {\n\t\t\tfor(ll k = i * 2; k < n + 1; k += i) {\n\t\t\t\tv[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nvector<long long> primevec(long long n) {  // n以下の素数のみを入れたvector\n\tvll v = eratos(n);\n\tvll ret;\n\tRep(i, 2, n + 1) if(v[i]) ret.push_back(i);\n\treturn ret;\n}\n\nset<long long> primeset(long long n) {\t// n以下の素数を全て詰めたset\n\tvll v = eratos(n);\n\tsll s;\n\tRep(i, 2, n + 1) if(v[i]) s.insert(i);\n\treturn s;\n}\n\nvector<long long> yakusuu(long long n) {  // nの約数を列挙\n\tvector<long long> ret;\n\tlong long sq = sqrt(n);\n\tfor(long long i = 1; i <= sq; ++i) {\n\t\tif(n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif(i * i != n) {\n\t\t\t\tret.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\n\nmap<long long, long long> soinsuu(long long n) {  // map<素因数,個数>\n\tmap<long long, long long> m;\n\tlong long p = sqrt(n);\n\twhile(n % 2 == 0) {\n\t\tn /= 2;\n\t\tif(m.count(2)) {\n\t\t\tm[2]++;\n\t\t} else {\n\t\t\tm[2] = 1;\n\t\t}\n\t}\n\tfor(long long i = 3; i * i <= n; i += 2) {\n\t\twhile(n % i == 0) {\n\t\t\tn /= i;\n\t\t\tif(m.count(i)) {\n\t\t\t\tm[i]++;\n\t\t\t} else {\n\t\t\t\tm[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(n != 1) m[n] = 1;\n\treturn m;\n}\n\nvector<long long> keta(ll x) {\n\t// 10進法でn桁の整数xに対して、大きい方の位から、その位の1桁の数字を\n\t//収納した長さnのベクトルを返す\n\t// 0に対しては{}を返す\n\tvll w;\n\twhile(x > 0) {\n\t\tw.push_back(x % 10);\n\t\tx /= 10;\n\t}\n\treverse(all(w));\n\treturn w;\n}\n\nlong long ketasum(ll x) {  //各桁の和\n\tll ret = 0;\n\twhile(x > 0) {\n\t\tret += x % 10;\n\t\tx /= 10;\n\t}\n\treturn ret;\n}\n\nstring bits(long long n, long long k) {\t // nをk桁のbitで表示したstringを返す\n\tstring s = \"\";\n\trep(i, k) {\n\t\tchar c = '0' + (n % 2);\n\t\ts += c;\n\t\tn /= 2;\n\t}\n\treverse(all(s));\n\treturn s;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\t // a^n mod\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlong long modinv(long long a, long long mod) {\t// a^{-1} mod\n\t// modとaが互いに素のときのみ有効(数学的に逆元が一意に定まるのがそのときのみ)\n\treturn modpow(a, mod - 2, mod);\n}\n\nvvll comb(100, vll(100, -1));\nlong long com(long long n, long long k) {  //普通の二項計数(overflowに注意)\n\tassert(n < 100 && k < 100);\n\tif(n < k || k < 0 || n < 0) return 0;\n\tif(comb[n][k] != -1) return comb[n][k];\n\tll res;\n\tif(n - k < k)\n\t\tres = com(n, n - k);\n\telse if(k == 0)\n\t\tres = 1;\n\telse\n\t\tres = com(n - 1, k - 1) + com(n - 1, k);\n\tcomb[n][k] = res;\n\treturn res;\n}\n\n// nCk modを求める\nconst ll MAX = 510000;\n// この値は求める二項計数の値に応じて変える\n// MAX=3*10^7のとき1900msほど、ほぼ比例\n// MAX=5*10^6程度ならそれほど気にしなくてよい(300ms程)\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid cominit() {\n\t// テーブルを作る前処理\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nlong long commod(ll n, ll k) {\t// 二項係数計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nlong long pmod(ll n, ll k) {  //順列計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[n - k] % mod;\n}\nlong long hmod(ll n, ll k) {  // nHk計算\n\t// n個の区別しないoを区別するk個の箱に入れる方法の総数\n\t//(n+k-1)C(k-1)と等しい\n\treturn commod(n + k - 1, n);\n}\n\nlong long next_combination(long long sub) {\t //次の組み合わせをbitで返す\n\tlong long x = sub & -sub, y = sub + x;\n\treturn (((sub & ~y) / x) >> 1) | y;\n}\n\n#pragma endregion\n\n//////////////// vector処理系 ///////////////////////\n#pragma region vector\nvector<long long> vin(long long n) {  //整数n個の入力を受け取ってベクトルに突っ込んで返す\n\tvector<long long> v(n);\n\tfor(long long i = 0; i < n; i++) {\n\t\tcin >> v[i];\n\t}\n\treturn v;\n}\n\n//ベクトルの出力(検証済)\n// vectorの中身を出力する 答えの出力に利用可能\ntemplate <class T>\nvoid vout(vector<T> &v) {\n\tif(v.size() > 0) {\n\t\tfor(auto it = v.begin(); it < v.end(); it++) {\n\t\t\tcout << *it;\n\t\t\tif(it != v.end() - 1) cout << \" \";\n\t\t}\n\t}\n\tcout << endl;\n}\n\n//引数ベクトルに同一要素が複数あるとき、先頭を残し他は削除したベクトルを返す\n//ベクトル長も変化する\n// O(nlogn)くらい\ntemplate <class T>\nvector<T> singlized(vector<T> &v) {\n\tset<T> s;\n\tvector<T> ret;\n\tfor(auto seg : v) {\n\t\tif(!s.count(seg)) {\n\t\t\tret.push_back(seg);\n\t\t\ts.insert(seg);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//配列圧縮(検証済)\n//{1,36,1,3,8,-2,-92}を\n//{2, 5,2,3,4, 1,  0}にする\ntemplate <class T>\nvector<long long> press(vector<T> &v) {\n\tlong long n = v.size();\n\tvector<long long> w(n);\n\tmap<T, long long> m;\n\tfor(T &p : v) m[p] = 0;\n\tlong long i = 0;\n\tfor(auto &p : m) {\n\t\tp.second = i;\n\t\ti++;\n\t}\n\tfor(long long i = 0; i < n; i++) w.at(i) = m[v.at(i)];\n\treturn w;\n}\n\n//配列圧縮(同順位なし)\n//{1,36,1,3,8,-2,-92}を\n//{2, 6,3,4,5, 1,  0}にする\ntemplate <class T>\nvector<long long> ranking(vector<T> &v) {\n\tvector<pair<T, long long>> r;\n\tlong long n = v.size();\n\trep(i, n) r.push_back({v[i], i});\n\tsort(all(r));\n\tvll res(n);\n\trep(i, n) { res[r[i].second] = i; }\n\treturn res;\n}\n\n//着順配列\n// (sortedplace(v)).[i] = i番目に小さい要素が入っている箇所\ntemplate <class T>\nvector<long long> sortedplace(vector<T> &v) {\n\tauto w = ranking(v);\n\tll n = v.size();\n\tvll res(n);\n\trep(i, n) res[w[i]] = i;\n\treturn res;\n}\n\n// vectorの中身を数える map<要素,個数>を返す\ntemplate <class T>\nmap<T, long long> countv(vector<T> v) {\n\tmap<T, long long> m;\n\tfor(auto &g : v) {\n\t\tif(m.count(g))\n\t\t\tm[g]++;\n\t\telse\n\t\t\tm[g] = 1;\n\t}\n\treturn m;\n}\n\ntemplate <class T>\t// WarshallFloyd\nvoid warshall(vector<vector<T>> &v) {\n\tll n = v.size();\n\trep(i, n) rep(j, n) rep(k, n) v[j][k] = min(v[j][k], v[j][i] + v[i][k]);\n\treturn;\n}\n\n#pragma endregion\n\n//////////////// 累積和処理系 ///////////////////////\n#pragma region ruisekiwa\n\n// 1次元累積和\ntemplate <class T>\nvector<T> barsuminit(vector<T> &v) {\n\tll h = v.size();\n\tV<T> ret(h + 1);\n\tret[0] = 0;\n\trep(i, h) ret[i + 1] = v[i] + ret[i];\n\treturn ret;\n}\ntemplate <class T>\nT barsum(vector<T> &v, ll x0, ll x1) {\n\tif(x1 <= x0) return 0;\n\treturn v[x1] - v[x0];\n}\n// 2次元累積和\ntemplate <class T>\nvector<vector<T>> sheetsuminit(vector<vector<T>> &v) {\n\tll h = v.size();\n\tassert(h != 0);\n\tll w = v.at(0).size();\n\tVV<T> ret(h + 1, V<T>(w + 1));\n\trep(i, h + 1) ret[i][0] = 0;\n\trep(i, w + 1) ret[0][i] = 0;\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] = v[i][j];\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] += ret[i + 1][j];\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] += ret[i][j + 1];\n\treturn ret;\n}\n//[x0,y0],(x1,y1)で囲まれた領域内の和\n//端点は(x,y)のみ含む.面積は(x1-x0)*(y1-y0);\ntemplate <class T>\nT sheetsum(vector<vector<T>> &v, ll x0, ll y0, ll x1, ll y1) {\n\tif(x0 >= x1 || y0 >= y1) return 0;\n\treturn v[x0][y0] + v[x1][y1] - v[x0][y1] - v[x1][y0];\n}\n// 3次元累積和\ntemplate <class T>\nvector<vector<vector<T>>> cubiodsuminit(vector<vector<vector<T>>> &v) {\n\tll h = v.size();\n\tassert(h != 0);\n\tll w = v[0].size();\n\tassert(w != 0);\n\tll z = v[0][0].size();\n\tVVV<T> ret(h + 1, VV<T>(w + 1, V<T>(z + 1)));\n\trep(i, h + 1) rep(j, w + 1) rep(k, z + 1) { ret[i][j][k] = (i == 0 || j == 0 || k == 0 ? 0 : v[i - 1][j - 1][k - 1]); }\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i + 1][j + 1][k];\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i + 1][j][k + 1];\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i][j + 1][k + 1];\n\treturn ret;\n}\n//[x0,y0],(x1,y1)で囲まれた領域内の和\n//端点は(x,y)のみ含む.面積は(x1-x0)*(y1-y0);\ntemplate <class T>\nT cubiodsum(vector<vector<vector<T>>> &v, ll x0, ll y0, ll z0, ll x1, ll y1, ll z1) {\n\tif(x0 >= x1 || y0 >= y1 || z0 >= z1) return 0;\n\treturn v[x1][y1][z1] - v[x1][y1][z0] - v[x1][y0][z1] - v[x0][y1][z1] + v[x1][y0][z0] + v[x0][y1][z0] + v[x0][y0][z1] - v[x0][y0][z0];\n}\n\n#pragma endregion\n\n////////////// 構造体 ///////////////////////////\n#pragma region objects\n\nstruct mint {\n\t// auto mod int\n\t// https://youtu.be/L8grWxBlIZ4?t=9858\n\t// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n\t// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\n\tll x;  // typedef long long ll;\n\tmint(ll x = 0) : x((x % mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint &operator+=(const mint a) {\n\t\tif((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint a) {\n\t\tif((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint a) {\n\t\t(x *= a.x) %= mod;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif(!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif(t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint &operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream &operator>>(istream &is, const mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\nstruct UF {\t\t\t\t\t\t// Union_Find木(sizeあり)\n\tvector<long long> par, sz;\t// par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\t// sizeはiを根とする木のサイズ\n\tUF(long long N) : par(N), sz(N) {  //最初は全てが根であるとして初期化\n\t\tfor(long long i = 0; i < N; i++) {\n\t\t\tpar[i] = i;\n\t\t\tsz[i] = 1;\n\t\t}\n\t}\n\n\tlong long root(long long x) {  // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(long long x, long long y) {\t// xとyの木を併合\n\t\tlong long rx = root(x);\t\t\t\t// xの根をrx\n\t\tlong long ry = root(y);\t\t\t\t// yの根をry\n\t\tif(rx == ry) return;\t\t\t\t// xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry;\t\t\t\t\t\t// xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t\tsz[ry] += sz[rx];\n\t\tsz[rx] = 0;\t //サイズの処理 根じゃなくなったらサイズは0になる\n\t}\n\n\tbool same(long long x, long long y) {  // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tlong long rx = root(x);\n\t\tlong long ry = root(y);\n\t\treturn rx == ry;\n\t}\n\tlong long size(long long x) { return sz[root(x)]; }\n};\n\ntemplate <class T = ll>\nstruct BIT {\n\t//もとの配列a[i]はBIT内部ではvec[i+1]に対応\n\tvector<T> vec;\n\tll n;\n\tBIT(long long sz) : vec(sz + 1, 0), n(sz) {}\n\t//元の値に足す\n\tvoid add(long long place, T val, bool index = 0) {\n\t\tif(!index) place++;\n\t\tfor(long long x = place; x <= n; x += x & -x) vec[x] += val;\n\t\treturn;\n\t}\n\t//端からの合計値計算\n\tT sum0(long long a, bool index = 0) {\n\t\t// if(index == 0) a++;\n\t\tif(index) a--;\n\t\tT ret = 0;\n\t\tfor(int x = a; x > 0; x -= x & -x) ret += vec[x];\n\t\treturn ret;\n\t}\n\t//クエリ\n\tT sum(long long a, long long b) { return sum0(b) - sum0(a); }\n\t//更新 クエリと併用で可能にした\n\tvoid update(long long place, T val, bool index = 0) {\n\t\tT old = sum(place, place + 1);\n\t\tadd(place, val - old);\n\t\treturn;\n\t}\n};\n\ntemplate <class T = ll>\nstruct edge {\n\tT len;\n\tll to;\n};\n\ntemplate <class T = ll>\nstruct graph {\t// 0-indexed\n\tvector<vector<edge<T>>> edges;\n\tbool directed, weight;\n\tlong long ver;\n\n\t// constructor\n\tgraph(long long vertex, bool direction = 0, bool weigh = 0) : edges(vertex) {\n\t\tver = vertex;\n\t\tdirected = direction;\n\t\tweight = weigh;\n\t\tedges.resize(vertex);\n\t}\n\n\t//辺の追加 (0-indexed)\n\tvoid update(long long from, long long to, T len = 1, bool direction = 1) {\n\t\tedge<T> e;\n\t\te.to = to;\n\t\te.len = len;\n\t\tedges[from].push_back(e);\n\t\tif(!direction) {\n\t\t\te.to = from;\n\t\t\tedges[to].push_back(e);\n\t\t}\n\t}\n\n\t//入力受取 (1-indexed)\n\tvoid input(long long edge_num, long long index = 1) {\n\t\trep(i, edge_num) {\n\t\t\tll a;\n\t\t\tll b;\n\t\t\tcin >> a >> b;\n\t\t\ta -= index;\n\t\t\tb -= index;\n\t\t\tT c;\n\t\t\tif(weight)\n\t\t\t\tcin >> c;\n\t\t\telse\n\t\t\t\tc = 1;\n\t\t\tupdate(a, b, c, directed);\n\t\t}\n\t}\n\n\t//長さが負のpathがないときの単一始点最短経路<vll> O((ver)log(ver)+(edge))\n\tvector<T> dijkstra(long long start) {\n\t\tvector<T> ret(ver, (T)dekai);\n\t\tpqup<pair<T, long long>> p;\t //{dist,place}\n\t\tp.push({0, start});\n\t\tret[start] = 0;\n\n\t\twhile(!p.empty()) {\n\t\t\tT dist = p.top().first;\n\t\t\tll place = p.top().second;\n\t\t\tp.pop();\n\t\t\tif(ret[place] < dist) continue;\n\t\t\tfor(auto &next : edges[place]) {\n\t\t\t\tll nextplace = next.to;\n\t\t\t\tT dis = next.len;\n\t\t\t\tif(chmin(ret[nextplace], dist + dis)) {\n\t\t\t\t\tp.push({ret[nextplace], nextplace});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//単一始点最短経路 O((ver)*(edge))\n\t//ある頂点までのコストが無限に小さくなり得るとき→ ret[i] = -dekai;\n\tvector<T> BellmanFord(long long start) {\n\t\tvector<T> ret(ver, dekai);\n\t\tret[start] = 0;\n\t\trep(loop, ver - 1) {\n\t\t\trep(v, ver) {\n\t\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\t\tchmin(ret[e.to], ret[v] + e.len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//無限降下点の検索\n\t\tqueue<ll> q;\n\t\tvb chk(ver, 0);\n\t\trep(v, ver) {\n\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\tif(chmin(ret[e.to], ret[v] + e.len)) {\n\t\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, ver) if(chk[i]) ret[i] = -dekai;\n\n\t\treturn ret;\n\t}\n\n\t//閉路に含まれない頂点列挙\n\t//要素数がver未満なら閉路が存在、そうでなければ閉路は存在しない\n\tvector<long long> topo_sort() {\n\t\tassert(directed);\n\t\tvector<long long> num_input(ver);\n\t\t// 入次数\n\t\tfor(long long i = 0; i < ver; i++) {\n\t\t\tfor(auto e : edges[i]) {\n\t\t\t\tnum_input[e.to]++;\n\t\t\t}\n\t\t}\n\t\t// 入次数が0のノードをqueueで管理する\n\t\tqueue<long long> que;\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(num_input[i] == 0) {\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t\tvector<long long> ans;\n\t\twhile(!que.empty()) {\n\t\t\tauto node = que.front();\n\t\t\tque.pop();\n\t\t\tans.push_back(node);\n\t\t\t// 頂点の削除\n\t\t\tfor(auto e : edges[node]) {\n\t\t\t\tnum_input[e.to]--;\n\t\t\t\t// 行き先の入次数が0になったらqueueに追加\n\t\t\t\tif(num_input[e.to] == 0) {\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//無向木構造を根から葉に伸びる有向木構造に書き換える\n\tgraph<T> RootToLeaf(ll root) {\t// 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvb chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(now, e.to, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//無向木構造を葉から根に伸びる有向木構造に書き換える\n\tgraph<T> LeafToRoot(ll root) {\t// 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvb chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(e.to, now, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\tret.update(root, root, 0);\n\t\treturn ret;\n\t}\n\n\t// LeafToRootのvector版.par[i]=iの親の頂点\n\tvector<long long> par(ll root) {  // 0-indexed\n\t\tvll ret(ver, -1);\n\t\tret[root] = root;  // rootの親はroot\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != -1) continue;\n\t\t\t\tret[e.to] = now;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\tvector<edge<T>> ParentAndDistance(ll root) {  // 0-indexed\n\t\tV<edge<T>> ret(ver);\n\t\trep(i, ver) ret[i].to = -1;\n\t\tret[root].to = root;  // rootの親はroot\n\t\tret[root].len = 0;\t  // rootの親との距離は0\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to].to != -1) continue;\n\t\t\t\tret[e.to].to = now;\n\t\t\t\tret[e.to].len = e.len;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\tpair<pair<long long, long long>, T> DiameterOfTree() {\t//{{端点、端点},直径の大きさ}\n\t\tll v1, v2;\t\t\t\t\t\t\t\t\t\t\t// 0ともっとも遠い点、v1と最も遠い点\n\t\tV<T> dis(ver, -1);\n\t\tdis[0] = 0;\n\t\tqueue<ll> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(dis[e.to] != -1) continue;\n\t\t\t\tdis[e.to] = dis[now] + e.len;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t\tif(q.empty()) v1 = now;\n\t\t}\n\t\trep(i, ver) dis[i] = -1;\n\t\tdis[v1] = 0;\n\t\tq.push(v1);\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(dis[e.to] != -1) continue;\n\t\t\t\tdis[e.to] = dis[now] + e.len;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t\tif(q.empty()) v2 = now;\n\t\t}\n\t\tpair<pll, T> ans = {{v1, v2}, dis[v2]};\n\t\treturn ans;\n\t}\n\n\t//隣接sheet.主にwarshall用\n\tVV<T> GraphArray(void) {\n\t\tVV<T> ret(ver, V<ll>(ver, dekai));\n\t\trep(from, ver) {\n\t\t\tfor(auto &e : edges[from]) {\n\t\t\t\tret[from][e.to] = e.len;\n\t\t\t}\n\t\t\tret[from][from] = 0;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n#pragma region Segment_Trees\n\ntemplate <class T = ll>\nstruct STmax {\t//最大値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTmax(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\t\trep(i, size) { seg.push_back(-99999999977); }\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\t\t\tseg[v] = max(seg[v * 2 + 1], seg[v * 2 + 2]);\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での最大値を求める\n\t\tif(r <= a || b <= l) return -99999999977;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n\tT largest(ll a, ll b) {\n\t\tif(a >= b) return -99999999977;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct STmin {\t//最小値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTmin(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\t\trep(i, size) { seg.push_back(99999999977); }\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\t\t\tseg[v] = min(seg[v * 2 + 1], seg[v * 2 + 2]);\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での最大値を求める\n\t\tif(r <= a || b <= l) return 99999999977;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\tT smallest(ll a, ll b) {\n\t\tif(a >= b) return 99999999977;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct STsum {\t//区間の合計値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTsum(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\n\t\trep(i, size) { seg.push_back(0); }\n\t\t//改造時はここをまず変える\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\n\t\t\tseg[v] = seg[v * 2 + 1] + seg[v * 2 + 2];\n\t\t\t//改造時はここを変える\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での合計値を求める\n\t\tif(r <= a || b <= l) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn vl + vr;\t //改造時はここを変える\n\t}\n\tT sum(ll a, ll b) {\n\t\tif(a >= b) return 0;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct ST {\t //セグ木まとめ\n\tSTmax<T> stmax;\n\tSTmin<T> stmin;\n\tSTsum<T> stsum;\n\tST(long long n) : stmax(n), stmin(n), stsum(n) {}\n\tvoid update(ll place, T val) {\n\t\tstmax.update(place, val);\n\t\tstmin.update(place, val);\n\t\tstsum.update(place, val);\n\t}\n\tT largest(ll a, ll b) { return stmax.largest(a, b); }\n\tT smallest(ll a, ll b) { return stmin.smallest(a, b); }\n\tT sum(ll a, ll b) { return stsum.sum(a, b); }\n};\n\n#pragma endregion\n#pragma endregion\n\n////////////// 工事中 ////////////////////////\n#pragma region making\n// //ダブリング\n// // reach : 2^reach 先まで検索\n// VV<edge> doublize(vll &v, ll reach) {  // vは子から親へのvector\n// \tll n = v.size();\n// \tVV<long long> ret(n, 20);\n// }\n#pragma endregion\n\n////////////////// メモ //////////////////////\n#pragma region memo\n#pragma region update_memo\n// ilb9からの変更点\n//:STmin,STmax,STsumの型を一般化 #pragmaによる畳み込み\n//:STをまとめたSTallの作成\n\n//更新予定\n//:幾何ライブラリ作成\n//ダブリング/木の最短経路検索\n//有理数class\n//範囲更新セグ木(LazyST?)\n//文字列Algorithm(Z,KMP)\n#pragma endregion\n#pragma region programming_memo\n// Ctrl+Shift+[：折りたたみ\n// Ctrl+Shift+]：展開\n// Ctrl+k Ctrl+l：折り畳み／展開のトグル\n// Ctrl+k Ctrl+[：再帰的に折りたたみ\n// Ctrl+k Ctrl+]：再帰的に展開\n// Ctrl+k Ctrl+0：すべて折りたたみ\n// Ctrl+k Ctrl+j：すべて展開\n// Ctrl+k Ctrl+1：レベル1で折りたたみ\n// Ctrl+k Ctrl+2：レベル2で折りたたみ\n// Ctrl+k Ctrl+3：レベル3で折りたたみ\n// Ctrl+k Ctrl+8：すべての領域（region）の折りたたみ\n// Ctrl+k Ctrl+9：すべての領域（region）の展開\n// Ctrl+k Ctrl+/：すべてのブロックコメントの折りたたみ\n\n// long long intとして表示 (印字対象データの最上位ビットが立っているので負数とみなされる)\n// printf(\"case3: %lld\\n\", a);\n\n// c char 文字\n// s char *文字列\n// d int, short 10進の整数\n// u unsigned int, unsigned short 10進の符号なし整数\n// o int, short, unsigned int,unsigned short 8進の整数\n// x int, short, unsigned int,unsigned short 16進の整数\n// f float 浮動小数点数\n// e float 浮動小数点数の指数表示\n// g float %eもしくは %fのどちらか最適な形式の浮動小数点数\n// ld long 10進の倍精度整数\n// lu unsinged long 10進の符号なし倍精度整数\n// lo long,unsinged long 8進の倍精度整数\n// lf double 倍精度浮動小数点数\n// a double 16進の倍精度浮動小数点数\n// lld long long\n#pragma endregion\n#pragma endregion\n\nint main() {\n\tll n;\n\tcin >> n;\n\tgraph<> tr(n);\n\ttr.input(n - 1);\n\tauto g = tr.RootToLeaf(0);\n\tll f = 0;\n\n\t// vll dep(n, -1);\n\n\tfunction<ll(ll)> dfs = [&](ll now) {\n\t\tll res = 0;\n\t\tfor(auto &e : g.edges[now]) {\n\t\t\tres = abs(res - dfs(e.to) - 1);\n\t\t}\n\t\treturn res;\n\t};\n\n\tcout << (dfs(0) ? \"Alice\" : \"Bob\") << endl;\n\t// rep(i, n) {\n\t// \tprintf(\"%lld : \", i);\n\t// \tfor(auto e : g.edges[i]) {\n\t// \t\tcout << e.to << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N;\nint x[100010];\nint y[100010];\nvector<int> V[100010];\nint parent[100010];\n\nvoid make_parent(int v, int p) {\n  parent[v] = p;\n  for (auto x : V[v]) {\n    if (x != p) {\n      make_parent(x, v);\n    }\n  }\n}\n\nint grundy(int v) {\n  int s = V[v].size();\n  if (v == 0) ++s;\n  int ans;\n  if (s == 1) {\n    ans = 0;\n  } else if (s == 2) {\n    for (auto x : V[v]) {\n      if (x != parent[v]) {\n        ans = grundy(x) + 1;\n      }\n    }\n  } else {\n    ans = 0;\n    for (auto x : V[v]) {\n      if (x != parent[v]) {\n        ans ^= grundy(x);\n      }\n    }\n  }\n  // cerr << \"grundy(\" << v << \") = \" << ans << endl;\n  return ans;\n}\n\nint main () {\n  cin >> N;\n  for (auto i = 0; i < N-1; ++i) {\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n    V[x[i]].push_back(y[i]);\n    V[y[i]].push_back(x[i]);\n  }\n  make_parent(0, -1);\n  if (grundy(0) == 0) {\n    cout << \"Bob\" << endl;\n  } else {\n    cout << \"Alice\" << endl;    \n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, N) for (int i = 0; i < (int)N; i++)\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<vector<ll>> adj;\nint dfs(int n=0, int p=-1) {\n  int result = 0;\n  for (auto x: adj[n]) {\n    if (x==p) continue;\n    result ^= dfs(x,n);\n  }\n  if (p!=-1) result++;\n  // cout << n << \" \" << p << \" \" << result << endl;\n  return result;\n}\n\nint main() {\n  int N; cin >> N;\n  adj.resize(N);\n  rep(i,N-1) {\n    ll x, y; cin >> x >> y; x--; y--;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  string result = dfs() ? \"Alice\" : \"Bob\";\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 100005\nusing namespace std;\n\nstruct edge{int u,next;}e[M*2]={0}; int head[M]={0},use=0;\nvoid add(int x,int y){use++;e[use].u=y;e[use].next=head[x];head[x]=use;}\nint dfs(int x,int fa){\n\tint res=0;\n\tfor(int i=head[x];i;i=e[i].next) \n\tif(e[i].u!=fa) res^=(1+dfs(e[i].u,x));\n\treturn res;\n}\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tif(dfs(1,0)) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n\nconst int N=100005;\n\nstruct edge {int y,next;} e[N*2];\n\nint f[N],ls[N],edCnt;\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid add_edge(int x,int y) {\n\te[++edCnt]=(edge) {y,ls[x]}; ls[x]=edCnt;\n\te[++edCnt]=(edge) {x,ls[y]}; ls[y]=edCnt;\n}\n\nvoid dfs(int x,int d,int fa) {\n\tf[x]=0;\n\tfor (int i=ls[x];i;i=e[i].next) {\n\t\tif (e[i].y==fa) continue;\n\t\tdfs(e[i].y,d+1,x);\n\t\tf[x]^=f[e[i].y]+1;\n\t}\n}\n\nint main(void) {\n\tint n=read();\n\trep(i,2,n) add_edge(read(),read());\n\tdfs(1,1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n\nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,k;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>n;\n    rep(i,n-1){\n            cin>>x>>y;\n            if(x==1)cnt++;\n    }\n    if(cnt==1)Cout(\"Alice\");\n    else{\n            n--;\n            if(n%2==0)Cout(\"Bob\");\n            else Cout(\"Alice\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm> \n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int N=1e5+5;\nint n,u,v,cnt,first[N];\nstruct edge{int to,next;}e[N<<1];\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\nvoid ins(int u,int v){e[++cnt]=(edge){v,first[u]};first[u]=cnt;}\nint dfs(int x,int fa)\n{\n\tint sg=0;\n\tfor(int i=first[x];i;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to==fa)continue;\n\t\tsg^=dfs(to,x)+1;\n\t}\n\treturn sg;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t\tu=read(),v=read(),ins(u,v),ins(v,u);\n\tif(dfs(1,-1))printf(\"Alice\");\n\telse printf(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint dfs(int v,vector<vector<int>> &edge,vector<int> &grundy,vector<int> &used){\n    used[v]=true;\n    int res=100000000;\n    for(int i=0;i<edge[v].size();i++){\n        int to=edge[v][i];\n        if(used[to]){\n            continue;\n        }\n        res=min(dfs(to,edge,grundy,used),res);\n    }\n    if(res==100000000) return 0;\n    return grundy[v]=res+1;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> edge(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    vector<int> used(n);\n    vector<int> grundy(n);\n    grundy[0]=1;\n    vector<int> gs;\n    dfs(0,edge,grundy,used);\n    /*\n    for(int i=0;i<edge.size();i++){\n        for(int j=0;j<edge[i].size();j++){\n            if(i<edge[i][j]) continue;\n            gs.push_back(min(grundy[i],grundy[edge[i][j]]));\n        }\n    }\n    */\n    \n    int res=0;\n\n    for(int i=0;i<edge[0].size();i++){\n        res^=grundy[edge[0][i]];\n    }\n    cout<<(res?\"Alice\" :\"Bob\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 1e5 + 20;\n\nvector<int> adj[maxn];\n\nint grundy[maxn];\n\nvoid dfs(int v , int p = -1)\n{\n\tfor(auto u : adj[v])\n\t\tif(u != p)\n\t\t{\n\t\t\tdfs(u , v);\n\t\t\tgrundy[v] ^= (grundy[u] + 1);\n\t\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b;\n\t\tcin >> a >> b;\n\t\ta-- , b--;\n\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tdfs(0);\n\n\tcout << (grundy[0]? \"Alice\" : \"Bob\") << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dfs(const vector<vector<int>> &G, int v, int prev){\n  int cnt[] = {0,0};\n  for(auto v_ : G[v]){\n    if(v_ == prev) continue;\n    ++cnt[dfs(G,v_,v)];\n  }\n  if((cnt[1]%2) or (cnt[0]%2)) return 1;\n  return 0;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<vector<int>> G(N);\n  for(int i = 1; i < N; ++i){\n    int x, y;\n    cin >> x >> y;\n    --x,--y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if(dfs(G,0,-1)) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define pp pop_back()\n#define mp make_pair\n#define fr first\n#define sc second\n#define sz size()\n#define smin(x,y) ((x)=min((x),(y)))\n#define smax(x,y) ((x)=max((x),(y)))\n#define all(x) x.begin(),x.end()\n#define CS ios_base::sync_with_stdio(false);\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi; \nconst int M=1e5+5;\nvi adj[M];\nint dfs(int v,int p=0){\n\tint ret=0;\n\tfor(int u:adj[v]) if(u!=p) ret^=(dfs(u,v)+1);\n\treturn ret;\n}\nint32_t main()\n{\n\tint n; cin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint u,v; cin>>u>>v;\n\t\tadj[u].pb(v),adj[v].pb(u);\n\t}\n\treturn cout<<(dfs(1)?\"Alice\":\"Bob\")<<endl,0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nbool dfs(int u, int p, std::vector<int> Adj[])\n{\n  int win = 0;\n  int lose = 0;\n  \n  for(int i = 0; i < Adj[u].size(); i++)\n  {\n    int v = Adj[u][i];\n    if(v != p)\n    {\n      bool add = dfs(v, u, Adj);\n      win += add;\n      lose += !add;\n    }\n  }\n  \n  return (win%2 || lose%2);\n} \n\nint main()\n{\n  int N;\n  std::cin >> N;\n  \n  std::vector<int> Adj[N];\n  for(int i = 1; i < N; i++)\n  {\n    int x, y;\n    std::cin >> x >> y;\n    x--; y--;\n    Adj[x].push_back(y);\n    Adj[y].push_back(x);\n  }\n  \n  if(dfs(0, -1, Adj))\n    std::cout << \"Alice\";\n  else\n    std::cout << \"Bob\";\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pp pair<int,int>\n#define MZ 1000000007\n#define Pi acos(-1)\n#define pq priority_queue\n\nusing namespace std;\n\nstruct Node\n{\n    int n1,n2;\n    int f,du;\n}num[100005];\nbool life[100005];\nvector <int> v1[100005];\nint root[100005];\nqueue <int> q;\n\nvoid dfs(int x)\n{\n    life[x]=1;\n    for(int i=0;i<v1[i].size();i++)\n    {\n        if(!life[v1[x][i]])\n        {\n            num[x].du++;\n            root[v1[x][i]]=x;\n            dfs(v1[x][i]);\n        }\n    }\n}\n\nint main()\n{\n    int n,temp;\n    int x,y;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v1[x].push_back(y);\n        v1[y].push_back(x);\n    }\n    dfs(1);\n    while(!q.empty())\n    {\n        temp=q.front();\n        q.pop();\n        if(num[temp].n2)\n        {\n            if(num[temp].n2%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        else\n        {\n            if(num[temp].n1%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        if(root[temp])\n        {\n            if(num[temp].f==1)\n                num[root[temp]].n1++;\n            else\n                num[root[temp]].n1++;\n            num[root[temp]].du--;\n            if(num[root[temp]].du==0)\n                q.push(root[temp]);\n        }\n    }\n    if(num[1].f==-1)\n        printf(\"Alice\\n\");\n    else\n        printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>> &s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nll used[100010];\n\nll dfs(Graph &graph, ll v) {\n\tused[v] = 1;\n\tll ret = 0;\n\n\tREP(i, graph[v].size()) {\n\t\tif (used[graph[v][i].to] == 0) {\n\t\t\tret ^= dfs(graph, graph[v][i].to);\n\t\t}\n\t}\n\treturn ret + min(v,1LL);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\n\tll n;\n\tcin >> n;\n\tGraph graph(n);\n\tREP(i, n - 1) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tadd_edge(graph, x, y, 1, true, 1);\n\t}\n\n\tif (dfs(graph, 0) == 0) {\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse {\n\t\tcout << \"Alice\" << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 101000\nusing namespace std;\nstruct KSD\n{\n    int v,next;\n}e[N<<1];\nint head[N],cnt;\ninline void add(int u,int v)\n{\n    e[++cnt].v=v;\n    e[cnt].next=head[u];\n    head[u]=cnt;\n}\nint n;\nint sg[N];\nvoid dfs(int x,int p)\n{\n    int i,v;\n    sg[x]=0;\n    for(i=head[x];i;i=e[i].next)\n    {\n        v=e[i].v;\n        if(v==p)continue;\n        dfs(v,x);\n        sg[x]^=(sg[v]+1);\n    }\n}\nint main()\n{\n    int i,j,T;\n    int a,b;\n\n\n        cnt=1;\n        memset(head,0,sizeof(head));\n        scanf(\"%d\",&n);\n        for(i=1;i<n;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            add(a,b),add(b,a);\n        }\n        dfs(1,0);\n        if(sg[1])puts(\"Alice\");\n        else puts(\"Bob\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nvoid bob() {\n  printf(\"Bob\\n\");\n  exit(0);\n}\n\nvoid alice() {\n  printf(\"Alice\\n\");\n  exit(0);\n}\n\nvvi g;\n\nint resolve(int u, int par) {\n  if ((int)g[u].size() == 1) {\n    return 1;\n  }\n  deque<int> chld;\n  for (int v : g[u]) {\n    if (v == par) { continue; }\n    chld.push_back(resolve(v, u));\n  }\n  sort(all(chld));\n  while ((int)chld.size() > 1) {\n    chld[1] -= chld[0];\n    chld.pop_front();\n  }\n  if (u == 0) {\n    return chld[0];\n  } else {\n    return chld[0] + 1;\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  g.resize(n);\n  rep (i, n-1) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    x -= 1; y -= 1;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  if (resolve(0, -1) == 0) {\n    bob();\n  } else {\n    alice();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100100;\n\nvector<int> edges[MAXN];\n\nint dfs(int i = 0, int par = 0)\n{\n\tint sol = 0, cnt = 0;\n\tfor (int j: edges[i]) if (j != par)\n\t{\n\t\t++cnt;\n\t\tsol ^= dfs(j, i);\n\t}\n\t\n\tif (cnt == 1)\n\t\t++sol;\n\t\n\treturn sol;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint n, i;\n\tint a, b;\n\t\n\tcin>>n;\n\t\n\tfor (i = 1; i < n; ++i)\n\t{\n\t\tcin>>a>>b;\n\t\t--a, --b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\t\n\tcout<<(dfs() ? \"Alice\" : \"Bob\")<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2016\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nvector<int> adj[MAXN];\nint n, gru[MAXN];\nll val[MAXN];\n\nvoid dfs(int u, int p) {\n\t\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t}\n\t\n\tgru[u] = 0;\n\tint tot = 0;\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\ttot ^= (gru[v] + 1);\n\t}\n\t\n\tgru[u] = tot;\n\t\n//\tfor (int i=0; i<(n+59)/60; i++) val[i] = 0;\n//\t\n//\tfor (int i=0; i<sz(adj[u]); i++) {\n//\t\tint v = adj[u][i];\n//\t\tif (v == p) continue;\n//\t\tint now = tot ^ (gru[v] + 1);\n//\t\tval[now/60] |= (1ll << (now % 60));\n//\t}\n//\t\n//\tfor (int i=0; i<(n+59)/60; i++) {\n//\t\tif (val[i] != (1ll << i) - 1) {\n////\t\t\tif (u == 3) cout << (val[i] & (1ll << 0)) << endl;\n//\t\t\tfor (int j=0; j<60; j++) {\n////\t\t\t\tif (u == 3) cout << (val[i] & (1ll << j)) << endl;\n//\t\t\t\tif ((val[i] & (1ll << j)) == 0) {\n//\t\t\t\t\tgru[u] = i * 60 + j;\n//\t\t\t\t\treturn;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t}\n}\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tcin >> n;\n\tfor (int i=0; i<n-1; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\n\tdfs(0, -1);\n\t\n//\tif (sz(adj[0]) == 1) cout << \"Alice\";\n//\telse {\n//\t\tint ans = 0;\n//\t\tfor (int i=0; i<sz(adj[0]); i++) {\n//\t\t\tans ^= gru[adj[0][i]];\n//\t\t}\n//\t\tif (ans) cout << \"Alice\";\n//\t\telse cout <<\"Bob\";\n//\t}\n//\tcout << gru[2] << endl;\n\tif (gru[0]) cout << \"Alice\";\n\telse cout << \"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int> > adj;\nvector<int> dp;\n\nvoid dfs(int u, int p) {\n    dp[u] = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        dfs(v, u);\n        dp[u] ^= dp[v];\n    }\n    dp[u]++;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dp.resize(N);\n    dfs(0, -1);\n\n    int Xor = 0;\n    for(int i = 0; i < adj[0].size(); i++) {\n        Xor ^= dp[ adj[0][i] ];\n    }\n    if(Xor) printf(\"Alice\");\n    else printf(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nvector<int>V[N];\nint n;\n\nint Dfs (int u, int fa) {\n\tint sg = 0; for (auto v : V[u]) if (v != fa) sg ^= Dfs(v, u) + 1; return sg;\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tV[u].emplace_back(v);\n\t\tV[v].emplace_back(u);\n\t}\n\tputs(Dfs(1, 0) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=400020;\nint n,h[N],t[N],v[N],a,b,i,k;\nint g[N];\nvoid add(int a,int b){\n\tt[++k]=h[a];\n\th[a]=k;\n\tv[k]=b;\n}\nvoid dfs(int i,int fa){\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(v[j]!=fa){\n\t\t\tdfs(v[j],i);\n\t\t\tg[i]^=g[v[j]]+1;\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);\n\t\tadd(b,a);\n\t}\n\tdfs(1,0);\n\tprintf(\"%s\",g[1]?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<cmath>\nusing namespace std;\n\n\n\nint n;\n#define MAX 100002\n\nvector<int> v[MAX];\nint gr[MAX];\n\ninline void dfs(int b,int pr=-1) {\n\tif (v[b].size() == 1 ) {\n\t\tgr[b] = 0;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < v[b].size(); i++) {\n\t\tint go = v[b][i];\n\t\tif (go != pr) {\n\t\t\tdfs(go,b);\n\t\t\tgr[b] ^= (gr[go] + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tif (gr[0]) {\n\t\tputs(\"Alice\");\n\t}\n\telse {\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, X, Y;\nvector<ll> E[100000];\n\nll dfs(ll v, ll p) {\n  ll g = 0;\n  for(ll u : E[v]) if(u != p) g = g ^ (dfs(u, v) + 1);\n  return g;\n}\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N - 1) {\n    cin >> X >> Y; X--; Y--;\n    E[X].push_back(Y);\n    E[Y].push_back(X);\n  }\n\n  cout << (dfs(0, -1) != 0 ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[100100];\nint d[100100];\nvoid dfs(int v, int p)\n{\n    d[v] = 0; int z = 0, o = 0;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n        {\n            dfs(g[v][i], v);\n            if(d[g[v][i]] == 0)\n                z++;\n            else\n                o++;\n        }\n    }\n    if(z % 2 == 0)\n    {\n        if(o % 2 == 0)\n            d[v] = 0;\n        else\n            d[v] = 1;\n    }\n    else\n    {\n        if(o % 2 == 1)\n            d[v] = 1;\n        else\n            d[v] = 1;\n    }\n}\n\nint main()\n{\n    int n, i, x, y, ans = 0;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1, 0);\n    if(d[1] == 0)\n        cout << \"Bob\";\n    else\n        cout << \"Alice\";\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 9;\nconst int MAXN = 100005;\n \nint n;\nvector<int> gph[MAXN];\n \nint f(int x, int p){\n\tint ans = 0;\n\tfor(auto &i : gph[x]){\n\t\tif(i == p) continue;\n\t\tans ^= f(i, x) + 1;\n\t}\n\treturn ans;\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tgph[x].push_back(y);\n\t\tgph[y].push_back(x);\n\t}\n\tcout << (f(1, 0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN = 100010;\n\nint n;\n\nnamespace Tree {\n\tint head[MAXN], nxt[MAXN<<1], to[MAXN<<1], eidx = 0;\n\tvoid init() {\n\t\tmemset( head, -1, sizeof(head) );\n\t}\n\tvoid adde( int u, int v ) {\n\t\tto[eidx] = v, nxt[eidx] = head[u], head[u] = eidx++;\n\t\tto[eidx] = u, nxt[eidx] = head[v], head[v] = eidx++;\n\t}\n}\n\nint dfs( int u, int fa ) {\n\tusing namespace Tree;\n\tint sg = 0;\n\tfor( int i = head[u]; ~i; i = nxt[i] ) {\n\t\tint v = to[i];\n\t\tif( v == fa ) continue;\n\t\tsg ^= dfs(v, u) + 1;\n\t}\n\treturn sg;\n}\n\nint main() {\n\tscanf( \"%d\", &n );\n\tTree::init();\n\tfor( int i = 0; i < n-1; ++i ) {\n\t\tint x, y;\n\t\tscanf( \"%d%d\", &x, &y );\n\t\tTree::adde(x, y);\n\t}\n\tputs( dfs(1, 0) ? \"Alice\" : \"Bob\" );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 100005;\n\nvector<int> edg[DIM];\n\nint dfs(int x, int f)\n{\n    int val = 0;\n    for (int y : edg[x]) if (y != f)\n        val ^= (dfs(y, x) + 1);\n    return val;\n}\n\nint main(void)\n{\n    int n; cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int x, y; cin >> x >> y;\n        \n        edg[x].push_back(y);\n        edg[y].push_back(x);\n    }\n    \n    cout << (dfs(1, 0) ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            res ^= dfs(e, now) + 1;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nvector<int>v[N];\nint b[N];\nint dfs(int x)\n{\n    int i,ans=0;\n    for(int i:v[x])\n    if(!b[i])\n    {\n        b[i]=1;\n        ans^=dfs(i)+1;\n    }\n    return ans;\n}\nint main()\n{\n    int i,n;\n    cin>>n;\n    memset(b,0,sizeof b);\n    for(i=0;i<n-1;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(dfs(1))printf(\"Alice\");\n    else printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pb push_back\n#define mem(x, y) memset(x, y, sizeof(x))\n#define pii pair<int, int>\n#define mkp make_pair\nconst int N = 100005;\nint n, a[N];\nvector<int> g[N];\n\nvoid dfs(int u, int fa) {\n    for(int i = 0; i < (int)g[u].size(); i++) {\n        int v = g[u][i];\n        if(v != fa) {\n            dfs(v, u);\n            a[u] ^= (a[v] + 1);\n        }\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0, x, y; i < n - 1; i++) {\n        scanf(\"%d%d\", &x, &y);\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1, 0);\n    puts(a[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nvector<vector<int>> G;\n\nint dfs(int v, int pv) {\n    int ret = 0;\n    for (auto nv: G[v]) {\n        if (pv==nv) continue;\n        ret ^= dfs(nv,v);\n    }\n    return v ? ret+1 : ret;\n}\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N; cin >> N;\n    G.resize(N);\n    rep(i,N-1) {\n        int u,v; cin >> u >> v;\n        --u; --v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    cout << (dfs(0,-1) ? \"Alice\" : \"Bob\") << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod2=1000000007;\nll mod=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n;cin>>n;\n    vector<int> v[n+1];\n    rep(i,0,n-1){\n        int a,b;cin>>a>>b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    int par[n+1];\n    par[1]=0;\n    v[1].push_back(0);\n    int cnt[n+1];\n    fill(cnt,cnt+n+1,0);\n    queue<int> q;\n    q.push(1);\n    while(q.size()>0){\n        int now=q.front();q.pop();\n        rep(i,0,v[now].size()){\n            int ne=v[now][i];\n            if(par[now]==ne)continue;\n            par[ne]=now;\n            q.push(ne);\n        }\n    }\n    int g[n+1];\n    rep(i,1,n+1){\n        if(v[i].size()==1)q.push(i);\n    }\n    while(q.size()>0){\n        int now=q.front();\n        q.pop();\n        g[now]=0;\n        rep(i,0,v[now].size()){\n            int ne=v[now][i];\n            if(par[now]==ne)continue;\n            g[now]^=g[ne]+1;\n        }\n        int p=par[now];\n        cnt[p]++;\n        if(cnt[p]==v[p].size()-1)q.push(p);\n    }\n    if(g[1]==0)cout<<\"Bob\"<<endl;\n    else cout<<\"Alice\"<<endl;\n   // rep(i,1,n+1)cout<<g[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n \n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n \ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n \nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n \ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n\ntemplate<class T = int> class Tree {\npublic:\n\tint nodeNum;\n\tint isWeighted;\n\tint maxBit;\n\tint idx;\n\tvector<vector<int>> edge;\n\tvector<vector<T>> weight;\n\tvector<int> depth;\n\tvector<int> order;\n\tvector<T> dist;\n\t\n\tvector<int> parent;\n\tvector<T> parentDist;\n\t\n\tvector<vector<int>> child;\n\tvector<vector<T>> childDist;\n \n\tvector<vector<int>> ancestor;\n\tvector<vector<int>> descendant;\n\t\n\tvector<int> eulerTour;\n    vector<T> eulerTourDist;\n\tvector<int> eulerTourIdxL;\n\tvector<int> eulerTourIdxR;\n    vector<int> eulerTourDive,eulerTourFloat;\n    vector<T> eulerTourDiveDist,eulerTourFloatDist;\n\tvector<int> eulerTourDiveIdxL,eulerTourFloatIdxL;\n\tvector<int> eulerTourDiveIdxR,eulerTourFloatIdxR;\n \n\tTree(const int nodeNum, const int isWeighted = 0, const int maxBit = 20) : \n\tnodeNum(nodeNum),\n\tisWeighted(isWeighted),\n\tmaxBit(maxBit),\n\tedge(nodeNum),\n\tdepth(nodeNum),\n\torder(nodeNum)\n\t{\n\t\tif(isWeighted) weight.resize(nodeNum);\n\t\tif(isWeighted) dist.resize(nodeNum);\n\t}\n \n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const T& w = 0) {\n\t\tedge[from].push_back(to);\n\t\tif(isWeighted)\tweight[from].push_back(w);\n\t}\n \n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tif(isWeighted) dist[root] = 0;\n\t\tidx = 0;\n\t\tdfs1(root);\n\t\torder[idx++] = root;\n\t}\n \n    //for makeDepth\n\tvoid dfs1(int from, int prev = -1){\n\t\tfor(int i = 0; i < edge[from].size(); ++i){\n\t\t\tint to = edge[from][i];\n\t\t\tif(to==prev) continue;\n\t\t\tdepth[to] = depth[from] + 1;\n\t\t\tif(isWeighted) dist[to] = dist[from] + weight[from][i];\n\t\t\tdfs1(to,from);\n\t\t\torder[idx++] = to;\n\t\t}\n\t}\n \n    //O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n \n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(nodeNum);\n\t\tiota(parent.begin(),parent.end(),0);\n\t\tfor (int i = 0; i < nodeNum; ++i) for (auto j : edge[i]) if (depth[i] > depth[j]) parent[i] = j;\n \n\t\tif(isWeighted) {\n\t\t\tparentDist.resize(nodeNum);\n\t\t\tfor (int i = 0; i < nodeNum; ++i) for (int j = 0; j < edge[i].size(); ++j) if (depth[i] > depth[edge[i][j]]) parentDist[i] = weight[i][j];\n\t\t}\n\t}\n \n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(nodeNum);\n\t\tfor (int i = 0; i < nodeNum; ++i) for (auto j : edge[i]) if (depth[i] < depth[j]) child[i].push_back(j);\n \n\t\tif(isWeighted) {\n\t\t\tchildDist.resize(nodeNum);\n\t\t\tfor (int i = 0; i < nodeNum; ++i) for (int j = 0; j < edge[i].size(); ++j) if (depth[i] < depth[edge[i][j]]) childDist[i].push_back(weight[i][j]);\n\t\t}\n\t}\n \n\t//O(NlogN) after makeDepth\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(nodeNum,vector<int>(maxBit));\n\t\tfor (int i = 0; i < nodeNum; ++i) ancestor[i][0] = i;\n\t\tfor (int i = 0; i < nodeNum; ++i) for (auto j : edge[i]) if (depth[i] > depth[j]) ancestor[i][0] = j;\n\t\tfor (int bit = 1; bit < maxBit; ++bit) for (int i = 0; i < nodeNum; ++i) ancestor[i][bit] = ancestor[ancestor[i][bit - 1]][bit - 1];\n\t}\n \n\t//O(N^2) after makeDepth\n\tvoid makeDescendant(void) {\n\t\tdescendant.resize(nodeNum);\n\t\tfor (int i = 0; i < nodeNum; ++i) descendant[i].push_back(i);\n\t\tfor (int i = 0; i < nodeNum; ++i) for (auto j : edge[order[i]]) if (depth[order[i]] < depth[j]) for(auto k: descendant[j]) descendant[order[i]].push_back(k);\n\t}\n \n\t//O(logN) after makeAncestor\n\tint lca(int l, int r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tfor (int bit = 0; bit < maxBit; ++bit) if (diff & (1 << bit)) l = ancestor[l][bit];\n\t\tif(l==r) return l;\n\t\tfor (int bit = maxBit - 1; 0 <= bit; --bit) if(ancestor[l][bit]!=ancestor[r][bit]) l = ancestor[l][bit], r = ancestor[r][bit];\n\t\treturn ancestor[l][0];\n\t}\n \n\t//O(N) after makeChild and makeParent\n\tvoid makeEulerTour(void){\n        dfs2(order[nodeNum-1]);\n\t\teulerTourIdxL.resize(nodeNum);\n\t\teulerTourIdxR.resize(nodeNum);\n\t\tfor(int i = 0; i < eulerTour.size(); ++i) eulerTourIdxR[eulerTour[i]] = i;\n\t\tfor(int i = eulerTour.size()-1; 0 <= i; --i) eulerTourIdxL[eulerTour[i]] = i;\n\t\treturn;\n\t}\n \n    //for makeEulerTour\n\tvoid dfs2(int from, int prev = -1){\n\t\teulerTour.push_back(from);\n        if(isWeighted) eulerTourDist.push_back(parentDist[from]);\n \n        for(int i = 0; i < child[from].size(); ++i){\n            int to = child[from][i];            \n            dfs2(to,from);            \n    \t\teulerTour.push_back(from);\n            if(isWeighted) eulerTourDist.push_back(-childDist[from][i]);\n        }\n\t}\n\n\t//O(NlogN) after makeEulerTour\n\tvoid makeEulerTourEdge(void) {\n\t\teulerTourDive.push_back(order[nodeNum-1]);\n\t\tif(isWeighted) eulerTourDiveDist.push_back(0);\n\t\tfor(int i = 1; i < eulerTour.size(); ++i) {\n\t\t\tint l = eulerTour[i-1];\n\t\t\tint r = eulerTour[i];\n\t\t\tif(depth[l] < depth[r]) {\n\t\t\t\teulerTourDive.push_back(i);\n\t\t\t\tif(isWeighted) eulerTourDiveDist.push_back(eulerTourDist[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\teulerTourFloat.push_back(i);\n\t\t\t\tif(isWeighted) eulerTourFloatDist.push_back(eulerTourDist[i]);\n\t\t\t}\n\t\t}\n\t\teulerTourDiveIdxL.resize(nodeNum);\n\t\teulerTourDiveIdxR.resize(nodeNum);\n\t\teulerTourFloatIdxL.resize(nodeNum);\n\t\teulerTourFloatIdxR.resize(nodeNum);\n\t\tfor(int i = 0; i < nodeNum; ++i) {\n\t\t\tint l = eulerTourIdxL[i];\n\t\t\tint r = eulerTourIdxR[i];\n\t\t\teulerTourDiveIdxL[i]  =  upper_bound(eulerTourDive.begin() ,eulerTourDive.end() ,l) - eulerTourDive.begin()     ;\n\t\t\teulerTourDiveIdxR[i]  = (upper_bound(eulerTourDive.begin() ,eulerTourDive.end() ,r) - eulerTourDive.begin())  -1;\n\t\t\teulerTourFloatIdxL[i] =  upper_bound(eulerTourFloat.begin(),eulerTourFloat.end(),l) - eulerTourFloat.begin()    ;\n\t\t\teulerTourFloatIdxR[i] = (upper_bound(eulerTourFloat.begin(),eulerTourFloat.end(),r) - eulerTourFloat.begin()) -1;\n\t\t\teulerTourDiveIdxR[i]  = max(eulerTourDiveIdxL[i]-1 ,eulerTourDiveIdxR[i]);\n\t\t\teulerTourFloatIdxR[i] = max(eulerTourFloatIdxL[i]-1,eulerTourFloatIdxR[i]);\n\t\t}\n\t}\n\t\t// iの部分木の頂点に加算するとき\n\t\t// [ eulerTourIdxL[i]  ,eulerTourIdxR[i]  ]に　+val\n\t\t// [i]の頂点クエリ\n\t\t// [eulerTourIdxL[i],eulerTourIdxL[i]]\n\n\t\t// iの部分木の辺に加算するとき\n\t\t// [ eulerTourDiveIdxL[i]  ,eulerTourDiveIdxR[i]  ]に　+val\n\t\t// [ eulerTourFloatIdxL[i] ,eulerTourFloatIdxR[i] ]に　-val\n\t\t// [0,i]のパスクエリ\n\t\t// [ 0, eulerTourDiveIdxL[i] ) + [0, eulerTourFloatIdxL[i])\n \n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n \n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n \n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n\nint main() {\n\tint N; cin >> N;\n\tTree<> tree(N);\n\tfor(int i = 0; i < N-1; ++i) {\n\t\tint u,v; cin >> u >> v;\n\t\tu--,v--;\n\t\ttree.makeEdge(u,v);\n\t\ttree.makeEdge(v,u);\n\t}\n\ttree.makeDepth(0);\n\ttree.makeChild();\n\tvector<int> dp(N,0);\n\tfor(int pa:tree.order){\n\t\tfor(int ch:tree.child[pa]) dp[pa] ^= (dp[ch]+1);\n\t}\n\tcout << (dp[0]?\"Alice\":\"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nvector< int > g[N];\nint lv[N];\nvoid dfs(int v, int par = -1) {\n  lv[v] = par == -1 ? 0 : lv[par] + 1;\n  for (int u : g[v]) if (u != par)\n    dfs(u, v);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--;v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(0);\n  int ans = 0;\n  for (int i = 0; i < n; i++)\n    ans ^= lv[i];\n  puts(ans ? \"Alice\" : \"Bob\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1234567;\n\nint n, x, res;\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tres = 0;\n\tfor (auto i : g[v])\n\t\tif (i != r)\n\t\t\tres ^= dfs (i, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tcout << (dfs (0,-1)==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define pb push_back\n#define debug(args...) fprintf(stderr,args)\n#define FOR(i,a,b) for(int i = a; i <= b; ++i)\n#define REP(i,a,b) for(int i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef pair<int,int>pii;\n\nconst int maxn = 1e5 + 10;\n\nint n;\nvector<int>g[maxn];\nint grundy[maxn];\n\nvoid dfs(int v, int par){\n\tfor(auto u: g[v])\n\t\tif(u != par){\n\t\t\tdfs(u,v);\n\t\t\tgrundy[v] ^= (grundy[u]+1);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n-1){\n\t\tint a, b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tdfs(1,-1);\n\tif(grundy[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb(x) push_back(x)\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\n\nconst int MAX_N = 1e5;\nvector<int> es[MAX_N];\nbool used[MAX_N];\n\n//nowより下の部分木においてnowを根として同様のゲームを行ったときのgrundy数\nint grundy(int now){\n    used[now] = true;\n    vector<int> child;\n    for(auto &e: es[now]){\n        if(!used[e]) child.pb(e);\n    }\n    if(child.empty()) return 0;\n    elif(child.size() == 1) return grundy(child[0])+1;\n    else{\n        int res = 0;\n        for(auto &e: child) res ^= grundy(e);\n        return res;\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    rep(i, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        es[a].pb(b), es[b].pb(a);\n    }\n    fill(used, used+N, false);\n    if(grundy(0)) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n    return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    s << \"[\";\n    for (int i = 0; i < v.size(); i++)\n        s << (i == 0 ? \"\" : \", \") << v[i];\n    s << \"]\";\n    return s;\n}\n\n#define ALL(a) (a).begin(), (a).end()\n\nvector<int> tree[100010];\n\nint dfs(int v, int p) {\n    // set<int> set;\n    int res = 0;\n    for (int to : tree[v]) {\n        if (p == to) continue;\n        res ^= (dfs(to, v) + 1);\n        // set.insert(dfs(to, v));\n    }\n    /*\n    while (set.count(res) != 0) {\n        res++;\n    }\n    */\n    return res;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n    int res = dfs(0, -1);\n    if (res == 0) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define ull unsigned long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\n#define flush fflush(stdout)\nusing namespace std;\n\n#define N 100007\n\nint n, a, b;\n\nVI G[N];\n\nint l[N];\nbitset<N> vis;\n\nvoid dfs(int v)\n{\n\tvis[v] = 1;\n\n\tfor(auto it:G[v])\n\t{\n\t\tif(!vis[it])\n\t\t{\n\t\t\tdfs(it);\n\t\t\tl[v] ^= (l[it]+1);\n\t\t}\n\t}\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\n\tdfs(1);\n\n\tif(l[1])\n\t\tcout << \"Alice\";\n\telse\n\t\tcout << \"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef KHOKHO\n//#pragma GCC optimize(\"O3\")\n#endif\n#include<bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp> // Common file\n//#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\n//#define CHKR\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define ARRS int(1e6+500)\n#define MAX ((long long)(1e18+1))\n#define EP ((double)(1e-12))\n#define HS1 ((ll)(1000001329))\n#define HS2 ((ll)(1000001531))\n#define MOD ((long long)1000000007ll)\n#define AT9 ((long long)1000000000ll)\n#define PI 3.14159265358979323846264338327950288419716939937510\n#define LG 20\n\nvector<ll> v[ARRS];\nll dp[ARRS];\n\nvoid go(ll x,ll p){\n\n\tset<ll> st;\n\tll xr=0;\n\tfor(auto y:v[x]){\n\t\tif(y==p)continue;\n        go(y,x);\n        xr^=(dp[y]+1);\n\t}\n\tdp[x]=xr;\n\t//cout<<x<<\" \"<<dp[x]<<endl;\n}\n\nint main(){\n\t#ifdef KHOKHO\n\t\tfreopen(\"in.in\",\"r\",stdin);\n\t\tfreopen(\"out.out\",\"w+\",stdout);\n\t#endif //KHOKHO\n\tll n,a,k,p,b,c,d;\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tcin>>k>>p;\n\t\tv[k].pb(p);\n\t\tv[p].pb(k);\n\t}\n\tgo(1,-1);\n\tif(dp[1]){\n\t\tcout<<\"Alice\";\n\t}\n\telse cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 100000;\n\nint n;\nvector<int> adj[MaxN + 1];\n\nint dfs(int u, int fa)\n{\n\tint w = 0;\n\tfor (int v : adj[u])\n\t\tif (v != fa)\n\t\t\tw ^= dfs(v, u) + 1;\n\treturn w;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = getint(), v = getint();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tcout << (dfs(1, 0) ? \"Alice\" : \"Bob\");\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> v[maxn];\nint sg[maxn];\nint son[maxn];\n\nvoid pretr(int root, int fa) {\n    son[root] = 0;\n    for (int i = 0;i < v[root].size();i++) {\n        int to = v[root][i];\n        if (to == fa) continue;\n        pretr(to, root);\n        son[root]++;\n    }\n}\nvoid dfs(int root, int fa) {\n    if (son[root] == 0) {\n        sg[root] = 0;\n        return;\n    }\n    if (son[root] == 1) {\n        for (int i = 0;i < v[root].size();i++) {\n            int to = v[root][i];\n            if (to != fa) {\n                dfs(to, root);\n                sg[root] = sg[to] + 1;\n                return;\n            }\n        }\n    }\n    else {\n\n        sg[root] = 0;\n        for (int i = 0;i < v[root].size();i++) {\n            int to = v[root][i];\n            if (to == fa) continue;\n            dfs(to, root);\n            sg[root] ^= sg[to];\n        }\n    }\n}\nint main() {\n   \n    int n;\n    cin >> n;\n    for (int i = 1, xi, yi;i < n;i++) {\n        scanf(\"%d %d\", &xi, &yi);\n        v[xi].push_back(yi);\n        v[yi].push_back(xi);\n    }\n    pretr(1, 0);\n    // for (int i = 1;i <= n;i++) {\n    //     printf(\"%d \", son[i]);\n    // }\n    // cout << endl;\n    dfs(1, 0);\n    // for (int i = 1;i <= n;i++) {\n    //     printf(\"%d \", sg[i]);\n    // }\n    // cout << endl;\n    if (sg[1] != 0) {\n        printf(\"Alice\\n\");\n    }\n    else {\n        printf(\"Bob\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/***************************************\n    codeforces = topcoder = sahedsohel\n    IIT,Jahangirnagar University(42)\n****************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define ull unsigned long long int\n#define inf (INT_MAX/10)\n#define linf (LLONG_MAX/10LL)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define f(i,n) for(i=0;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define pb push_back\n#define aov(a) a.begin(),a.end()\n#define mpr make_pair\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define xx first\n#define yy second\n#define mxv(a) *max_element(aov(a))\n#define mnv(a) *min_element(aov(a))\n#define LB(a,x) (lower_bound(aov(a),x)-a.begin())\n#define UB(a,x) (upper_bound(aov(a),x)-a.begin())\n#define to_c_string(a) a.c_str()\n#define strtoint(c) atoi(&c[0])\n#define pll pair< ll , ll >\n#define pii pair< int , int >\n#define pcs(a) printf(\"Case %d: \", a)\n#define nl puts(\"\")\n#define endl '\\n'\n#define dbg(x) cout<<#x<<\" : \"<<x<<endl\n\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n\nint toInt(string s){int sm;stringstream ss(s);ss>>sm;return sm;}\nint toLlint(string s){long long int sm;stringstream ss(s);ss>>sm;return sm;}\n\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,+1,0,1,0,-1}; // Hexagonal Direction   **\n///int dy[]={-1,+1,1,0,-1,0}; //                       *#*\n///                                                     **\n///const double eps=1e-9;\n///int dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\n\n/*****************************************************************/\n/// ////////////////////   GET SET GO    ////////////////////// ///\n/*****************************************************************/\n\n\n#define intx(i,j,k,l) ((a[i]*b[j]-b[i]*a[j])*(a[k]-a[l])-(a[i]-a[j])*(a[k]*b[l]-b[k]*a[l]))/((a[i]-a[j])*(b[k]-b[l])-(b[i]-b[j])*(a[k]-a[l]))\n#define inty(i,j,k,l) ((a[i]*b[j]-b[i]*a[j])*(b[k]-b[l])-(b[i]-b[j])*(a[k]*b[l]-b[k]*a[l]))/((a[i]-a[j])*(b[k]-b[l])-(b[i]-b[j])*(a[k]-a[l]))\n#define dst(u,v,x,y) sqrt((x*1.0-u*1.0)*(x*1.0-u*1.0)+(y*1.0-v*1.0)*(y*1.0-v*1.0))\n#define area(p1,p2,p3) (p1.xx*p2.yy+p2.xx*p3.yy+p3.xx*p1.yy-p1.yy*p2.xx-p2.yy*p3.xx-p3.yy*p1.xx)\n#define dstt(u,v,x,y) ((ll)(x-u)*(ll)(x-u)+(ll)(y-v)*(ll)(y-v))\n\nint ts,kk=1;\n\n#define sqr(x) ((x)*(x))\n\n/// \t   0123456789ABCDEF\n#define M  100015\n#define MD 1000000009LL\n#define MX 1000005\n#define mid ((s+e)>>1)\n#define lft ((i<<1)+1)\n#define rgt (lft+1)\n\nint n;\nvector< int >al[M];\n\nint dfs(int u,int p)\n{\n\tint g=0;\n\tint i;\n\tf(i,al[u].size())\n\t{\n\t\tint v=al[u][i];\n\t\tif(v!=p)g^=(dfs(v,u)+1);\n\t}\n\treturn g;\n}\n\nint main()\n{\n\tint t,i,j,k;\n\t\n\tsc(n);\n\tfl(1,i,n)\n\t{\n\t\tsc2(j,k);\n\t\tal[j].pb(k);\n\t\tal[k].pb(j);\n\t}\n\t\n\tif( dfs(1,-1) )printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\t\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao on 2019/11/23.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nll cmp(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\nvector<int> g[100005];\nint dfs(int s,int q){\n    int k=0;\n    for(int r=0;r<g[s].size();r++){\n        if(g[s][r]!=q)\n            k^=(1+dfs(g[s][r],s));\n    }\n    return k;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    int n;\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--;y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if(dfs(0,-1))\n        cout<<\"Alice\"<<endl;\n    else\n        cout<<\"Bob\"<<endl;\n//-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\nusing namespace std;\nconst int N=200005;\nint head[N],nxt[N],to[N],e;\nint sg[N];\ninline void init(){memset(head,-1,sizeof(head));e=0;}\ninline void add_edge(int x,int y){to[e]=y;nxt[e]=head[x];head[x]=e++;}\nvoid dfs(int x,int f)\n{\n\tsg[x]=0;\n\tfor(int i=head[x];i+1;i=nxt[i])if(to[i]!=f)\n\t{\n\t\tdfs(to[i],x);\n\t\tsg[x]^=(sg[to[i]]+1);\n\t}\n\treturn;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);init();\n\trep(i,1,n-1){int x,y;scanf(\"%d%d\",&x,&y);add_edge(x,y);add_edge(y,x);}\n\tdfs(1,0);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint N;\nvector<int> adj[100005];\n\nbool f(int n, int p) {\n    int a = 0, b = 0;\n    for (int i : adj[n]) if (i != p) (f(i,n)?a:b)++;\n    return a&1 || b&1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1, x, y; i < N; i++) scanf(\"%d %d\", &x, &y), adj[x].push_back(y), adj[y].push_back(x);\n    printf(\"%s\\n\", f(1,0) ? \"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define _FILES\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n\nconst int MAXN = 100005;\nvector<int> g[MAXN];\nint mex[MAXN];\n\nvoid dfs(int v, int parent)\n{\n    set<int> s;\n    s.insert(0);\n    for (auto to : g[v])\n    {\n        if (to == parent) continue;\n        dfs(to, v);\n        s.insert(mex[to]);\n    }\n\n    for (int i=1;;i++)\n    {\n        if (s.find(i) == s.end())\n        {\n            mex[v] = i;\n            break;\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n\n    #ifdef _FILES\n        freopen(\"\",\"r\",stdin);\n        freopen(\"\",\"w\",stdout);\n    #endif // _FILES\n    int n;\n    cin >> n;\n    for (int i=0;i<n-1;i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].PB(y);\n        g[y].PB(x);\n    }\n    dfs(1, 0);\n    int ans = 0;\n    for (auto to : g[1])\n    {\n        ans ^= mex[to];\n    }\n\n    cout <<(ans ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nvector<int>v[N];\nint b[N];\nint dfs(int x)\n{\n    int i,ans=0;\n    for(int i:v[x])\n    if(!b[i])\n    {\n        b[i]=1;\n        ans^=dfs(i)+1;\n    }\n    return ans;\n}\nint main()\n{\n    int i,n;\n    cin>>n;\n    memset(b,0,sizeof b);\n    for(i=0;i<n-1;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    b[1]=1;\n    if(dfs(1))printf(\"Alice\");\n    else printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000005\n#define ll long long\n#define upperlimit 1000100\n#define INF 1e18\n#define eps 1e-8\n#define endl '\\n'\n#define pcc pair<char,char>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)\n#define MOD 1000000007\n#define slld(t) scanf(\"%lld\",&t)\n#define sd(t) scanf(\"%d\",&t)\n#define pd(t) printf(\"%d\\n\",t)\n#define plld(t) printf(\"%lld\\n\",t)\n#define mp(a,b) make_pair(a,b)\n#define FF first\n#define SS second\n#define pb(x) push_back(x)\n#define vi vector<int>\n#define vll vector<ll>\n#define clr(a) memset(a,0,sizeof(a))\n#define debug(a) printf(\"check%d\\n\",a)\n#define csl ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\n \nll gcd(ll n1,ll n2){\n\tif(n2==0)\n\t\treturn n1;\n\tif(n1%n2==0)return n2;\n\treturn gcd(n2,n1%n2);\n}\nll powmod(ll base,ll exponent)\n{\n\tll ans=1;\n\twhile(exponent){\n\t\tif(exponent&1)ans=(ans*base)%MOD;\n\t\tbase=(base*base)%MOD;\n\t\texponent/=2;\n\t}\n\treturn ans;\n}\nvi v[MAX];\nint dp[MAX];\nvoid DFS(int node,int p)\n{\n\tif(v[node].size()==1&&node!=1)\n\t{\n\t\tdp[node]=1;\n\t\treturn;\n\t}\n\tint now=0;\n\tfor(int i=0;i<v[node].size();i++)\n\t{\n\t\tint child=v[node][i];\n\t\tif(child!=p)\n\t\t{\n\t\t\tDFS(child,node);\n\t\t\tnow^=dp[child];\n\t\t}\n\t}\n\t//cout<<node<<\" \"<<dp[node]<<endl;\n\tdp[node]=now+1;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tv[a].pb(b);\n\t\tv[b].pb(a);\n\t}\n\tDFS(1,-1);\n\tif(dp[1]!=1)\n\t\tcout<<\"Alice\"<<endl;\n\telse\n\t\tcout<<\"Bob\"<<endl;\n\t//cout<<dp[1]<<endl;\n\t/*ll n,a,b,c,d;\n\tcin>>n>>a>>b>>c>>d;\n\tif(b<a)\n\t\tswap(a,b);\n\tll maxa=a,mina=a;\n\tfor(int i=0;i<n-2;i++)\n\t{\n\t\tmaxa+=d;\n\t\tmina+=c;\n\t}\n\tcout<<mina<<\" \"<<maxa<<endl;\n\tif(b<=maxa&&b>=mina)\n\t\tcout<<\"YES\"<<endl;\n\telse\n\t\tcout<<\"NO\"<<endl;*/\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n \n#include <iostream>\n#include <algorithm>\n \n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n \n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n \n \nusing namespace std;\n//#define int long long\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n \n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n \nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n \n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG \n \n#define DUMPOUT cout\n \n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...) \n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream \ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\n\nint dfs(int now, int par, vector<vector<int>>& g) {\n\tint ret = 0;\n\tfor (auto nx : g[now]) {\n\t\tif (nx == par) continue;\n\t\tret ^= dfs(nx, now, g);\n\t}\n\tif (now == 0) return ret;\n\treturn ret + 1;\n}\n\n\nsigned main() {\t\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tif (dfs(0, -1, g) == 0) cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n;\nvi g[N];\nbool tag[N],vis[N];\n\null dfs(int x){\n\tvis[x]=1;\n\tvector<ull> Hash;Hash.clear();\n\tull h=1,du=1;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tHash.pb(dfs(y));\n\t}\n\tif(!Hash.size()){\n\t\th-=1284743ull*du*du+1932975ull*du+19832573ull;\n\t\th^=du*du;\n\t\treturn h;\n\t}\n\tsort(Hash.begin(),Hash.end());\n\tfor(int i=0;i<Hash.size()-1;i++)\n\t\tif(Hash[i]==Hash[i+1]) tag[i]=tag[i+1]=1,i++;\n\tfor(int i=0;i<Hash.size();i++)\n\t\tif(!tag[i]) h=h*Hash[i],du++;\n\tfor(int i=0;i<Hash.size();i++) tag[i]=0;\n\th-=1284743ull*du*du+1932975ull*du+19832573ull;\n\th^=du*du;\n\treturn h;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tvector<ull> Hash;Hash.clear();\n\tvis[1]=1;\n\tfor(int i:g[1])\n\t\tHash.pb(dfs(i));\n//\tdebuge;\n\tsort(Hash.begin(),Hash.end());\n\tif(Hash.size()&1){puts(\"Alice\");return 0;}\n\tfor(int i=0;i<Hash.size();i+=2)\n\t\tif(Hash[i]!=Hash[i+1]){puts(\"Alice\");return 0;}\n\tputs(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i =s; i<=t;++i)\nconst int maxn = 100050;\n\nint sg[maxn];\nvector<int> nex[maxn];\nint n, ans;\n\nvoid dfs(int x,int fa=0)\n{\n\tfor(auto p:nex[x]) if(p!=fa) {dfs(p,x);sg[x]^=(sg[p]+1);}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tnex[u].push_back(v);\n\t\tnex[v].push_back(u);\n\t}\n\tdfs(1);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tchar ch;\n\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t;\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0'; \n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nconst int Max_N(100050);\n\nint N, Total, Head[Max_N], To[Max_N << 1], Next[Max_N << 1];\n\ninline void Add_Edge(const int &s, const int &t)\n{\n\t++Total, To[Total] = t, Next[Total] = Head[s], Head[s] = Total;\n}\n\nvoid init()\n{\n\tGet_Val(N);\n\tfor (int i = 1, u, v;i != N;++i)\n\t\tGet_Val(u), Get_Val(v), Add_Edge(u, v), Add_Edge(v, u);\n}\n\nint SG[Max_N];\nvoid dp(const int &u, const int &fa)\n{\n\tfor (int i = Head[u], v;i;i = Next[i])\n\t\tif ((v = To[i]) != fa)\n\t\t\tdp(v, u), SG[u] ^= (SG[v] + 1);\n}\n\nint main()\n{\n\n\tinit();\n\tdp(1, -1);\n\tif (SG[1])\n\t\tprintf(\"Alice\");\n\telse\n\t\tprintf(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[agc017] D - Game on Tree\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n#define ALL(c) (c).begin(), (c).end()\n\nconst int MAX_N = 100000;\n\nint N;\nvector<int> g[MAX_N];\n\nint dfs(int v, int par = -1) {\n    int grundy = 0;\n    for (int to : g[v]) {\n        if (to == par) {\n            continue;\n        }\n        grundy ^= dfs(to, v) + 1;\n    }\n    return grundy;\n}\n\nbool solve() { return dfs(0); }\n\nint main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        g[x - 1].push_back(y - 1);\n        g[y - 1].push_back(x - 1);\n    }\n\n    cout << (solve() ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define pb push_back\n#define fs first\n#define sc second\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> plli;\ntypedef vector<pii> vpii;\ntypedef tree<pii, null_type, less<pii>, rb_tree_tag,\n    tree_order_statistics_node_update> ost;\n\nconst int N=110000;\nvi adj[N];\nint sg[N];\n\nvoid dfs(int x, int p) {\n    for(int y: adj[x]) if(y!=p) {\n        dfs(y, x);\n        sg[x]^=1+sg[y];\n    }\n}\n\nint main() {\n    int i, n, u, v;\n    scanf(\"%d\", &n);\n    for(i=0; i<n-1; i++) {\n        scanf(\"%d%d\", &u, &v);\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    dfs(1, 0);\n    printf(sg[1]? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<int> G[114514];\nint dfs(int v,int p){\n  int res=0,cnt=0;\n  for(int u:G[v]){\n    if(u==p) continue;\n    res^=dfs(u,v)+1;\n    cnt++;\n  }\n  return res;\n}\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2000000000000000000\n#define ll long long\nusing namespace std;\n\nll grundy(vector<vector<ll>>& connection, vector<bool> already, ll now) {\n  already.at(now) = true;\n  vector<ll> res;\n  for (ll i = 0; i < connection.at(now).size(); ++i) {\n    ll next = connection.at(now).at(i);\n    if (already.at(next)) {\n      continue;\n    }\n    already.at(next) = true;\n    res.push_back(grundy(connection, already, next));\n  }\n  if (res.size() == 1) {\n    return res.at(0) + 1;\n  }\n  else {\n    ll temp = 0;\n    for (ll i = 0; i < res.size(); ++i) {\n      temp ^= res.at(i);\n    }\n    return temp;\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ll N;\n  cin >> N;\n  vector<vector<ll>> connection(N);\n  vector<bool> already(N, false);\n  for (ll i = 0; i < N - 1; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    x -= 1;y -= 1;\n    connection.at(x).push_back(y);\n    connection.at(y).push_back(x);\n  }\n  ll ans = grundy(connection, already, 0);\n  if (ans == 0) {\n    cout << \"Bob\" << \"\\n\";\n  }\n  else {\n    cout << \"Alice\" << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Grand Contest 017\n// D - Game on Tree\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\n\nconst int MAX_N = 100000;\n\nint N;\nvector<int> G[MAX_N];\nbool visited[MAX_N];\n\nint calc_grundy(int v) {\n    int grundy = 0;\n\n    visited[v] = true;\n    for (int to : G[v]) {\n        if (visited[to]) {\n            continue;\n        }\n        grundy ^= (calc_grundy(to) + 1);\n    }\n\n    return grundy;\n}\n\nint main() {\n\n    int x, y;\n\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        cin >> x >> y; x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    fill(visited, visited + N, false);\n\n    cout << (calc_grundy(0) != 0 ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint head[N],nxt[N<<1],to[N<<1],tot,n,f[N];\nvoid adli(int u,int v){\n\t++tot;nxt[tot]=head[u];head[u]=tot;to[tot]=v;\n\t++tot;nxt[tot]=head[v];head[v]=tot;to[tot]=u;\n}\nvoid dfs(int u,int fa){\n\tint i,v;\n\tfor(i=head[u];i;i=nxt[i]){\n\t\tv=to[i];if(v==fa)continue;\n\t\tdfs(v,u);f[u]^=f[v]+1;\n\t}\n}\nint main(){\n\tint u,v;\n\tgi(n);F(i,2,n)gi(u),gi(v),adli(u,v);\n\tdfs(1,0);puts(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\n\nint n, f[N];\nvector<int> g[N];\n\nvoid dfs(int u, int fa) {\n  for (auto v : g[u]) {\n    if (v != fa) {\n      dfs(v, u);\n      f[u] ^= f[v] + 1;\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf (\"%d %d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(1, 1);\n  puts(f[1] ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e6;\nconstexpr static int MOD = 1e9 + 7;\n\nvector <int> adj[MAXN];\nint cnt[MAXN];\nbool vis[MAXN];\n\nint dfs(int i) {\n    cnt[i] = 1;\n    vis[i] = true;\n    set <int> vals;\n    for (int j : adj[i])\n        if (!vis[j])\n            vals.insert(dfs(j));\n    while (vals.count(cnt[i]))\n        cnt[i]++;\n    return cnt[i];\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(0);\n\n    int sum = 0;\n    for (int i : adj[0])\n        sum ^= cnt[i];\n\n    return sum != 0;\n}\n\nint main() {\n    cout << (solve() ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\n\nstruct Road{\n    int e,next;\n}r[210000];int R[110000],num;\nint f[110000],n,x,y;\n\nvoid addr(int x,int y){\n    r[++num]=(Road){y,R[x]};\n    R[x]=num;\n}\n\nvoid dfs(int u,int fa){\n    for(int i=R[u];i;i=r[i].next){\n        int v=r[i].e;\n        if(v==fa)continue;\n        dfs(v,u);\n        f[u]^=f[v]+1;\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        scanf(\"%d %d\",&x,&y);\n        addr(x,y);addr(y,x);\n    }dfs(1,0);\n    if(f[1]==0)printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 2e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nstruct Edge {\n    int u, v, num;\n} ed[2 * MAXN];\n\nbool use[MAXN];\nint first[MAXN], nexxt[2 * MAXN], res[MAXN], p[MAXN];\n\n\nvoid dfs(int s)\n{\n    use[s] = 1;\n    res[s] = 0;\n\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (!use[ed[i].v])\n        {\n            p[ed[i].v] = s;\n            dfs(ed[i].v);\n            res[s] ^= res[ed[i].v]+1;\n        }\n}\n\nint dfs2(int s, int Gr)\n{\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (ed[i].v != p[s] && ((res[ed[i].v]+1) > (Gr ^ (res[ed[i].v]+1) ^ res[s])))\n        {\n            Gr ^= (res[ed[i].v] + 1) ^ res[s];\n            if (Gr == 0)\n                return ed[i].num;\n            return dfs2(ed[i].v, Gr-1);\n        }\n}\n\n\nmain() {\n    int n, r;\n    scanf(\"%ld\", &n);\n    r = 1;\n    --r;\n    int m = n-1;\n    for (int i = 0; i < m; ++i)\n    {\n        scanf(\"%ld%ld\", &ed[i].u, &ed[i].v);\n        --ed[i].u, --ed[i].v;\n        ed[i].num = i + 1;\n\n        ed[i+m].u = ed[i].v;\n        ed[i+m].v = ed[i].u;\n        ed[i+m].num = ed[i].num;\n    }\n\n    m *= 2;\n\n    for (int i = 0; i < n; ++i)\n    {\n        first[i] = -1;\n        use[i] = 0;\n    }\n\n    for (int i = 0; i < m; ++i)\n    {\n        nexxt[i] = first[ed[i].u];\n        first[ed[i].u] = i;\n    }\n\n    p[r] = -1;\n    dfs(r);\n    if (!res[r])\n        printf(\"Alice\");\n    else\n        printf(\"Bob\");\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = sz(v[u]) % 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= d[h] ^ ((sz(v[h]) - 1) % 2);\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long\n#define ull unsigned long long\n#define up(i,a,b) for (int i=a; i<=b; i++)\n#define down(i,a,b) for (int i=a; i>=b; i--)\n#define endl '\\n'\n#define pb push_back\n#define X first\n#define Y second\n#define II pair<int, int>\n#define III pair<int, pair<int, int> >\n#define V vector\n#define debug(X) cerr<< #X << \" = \" <<X << endl\n#define debug2(X,Y) cerr<< #X << \" = \" <<X << \",\"<<#Y<<\" = \"<<Y<<endl\n#define show(X,a,b) {cerr << #X << \" = \"; up(__,a,b) cerr << X[__] << ' '; cerr << endl;}\n#define gc getchar\n#define pc putchar\n\nusing namespace std;\n\ninline void read(int &x)\n{\n    register int c = gc();\n    x = 0;\n    int neg = 0;\n    for (;((c<48 || c>57) && c != '-') ;c = gc());\n    if(c=='-') {neg=1;c=gc();}\n    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n    if(neg) x=-x;\n}\ninline void writeln(int x){\n\n         char buffor[21];\n         register int i=0;\n         int neg=0; if (x<0) {neg=1; x= -x;}\n         do{\n               buffor[i++]=(x%10)+'0';\n               x/=10;\n            } while(x);\n           i--;\n           if (neg) pc('-');\n           while(i>=0) pc(buffor[i--]);\n           pc('\\n');\n       }\nconst int N= (int) 1e5+10;\nint n;\nV<int> a[N];\nint nim[N];\n\nvoid input()\n{\n\tcin>>n;\n\tup(i,1,n-1)\n\t{\n\t\tint x,y; cin>>x>>y;\n\t\ta[x].pb(y); a[y].pb(x);\n\t}\n}\nvoid dfs(int u,int p)\n{\n\tnim[u]= 0;\n    for (auto v: a[u])\n\t\tif (v!=p)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tnim[u]^= (nim[v]+1);\n\t\t};\n}\nvoid solve()\n{\n\tdfs(1,-1);\n\tif (nim[1]) cout<<\"Alice\"; else cout<<\"Bob\";\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);// don't use when interactive\n    #define TASK \"tmp\"\n  //  freopen(TASK\".inp\",\"r\",stdin);\n   // freopen(TASK\".out\",\"w\",stdout);\n\n    input();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dfs(const vector<vector<int>> &G, int v, int prev){\n  int cnt[] = {0,0};\n  for(auto v_ : G[v]){\n    if(v_ == prev) continue;\n    ++cnt[dfs(G,v_,v)];\n  }\n  if(cnt[1]%2 or cnt[0]%2) return 1;\n  return 0;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<vector<int>> G(N);\n  for(int i = 1; i < N; ++i){\n    int x, y;\n    cin >> x >> y;\n    --x,--y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if(dfs(G,0,-1)) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mkp make_pair\n#define pii pair<int, int> \n#define pll pair<long long int, long long int>\n#define sci(x) scanf(\"%d\", &x)\n#define scl(x) scanf(\"%lld\", &x)\n#define fi first\n#define sc second\n#define deb 0\n\nint lev[100001], mark[100001];\nvector <int> v[100001];\n\nvoid dfs(int x, int l)\n{\n\tlev[l]++;\n\tmark[x] = 1;\n\n\tfor (int i = 0; i < v[x].size(); ++i) {\n\t\tint y = v[x][i];\n\t\tif (!mark[y]) {\n\t\t\tdfs(y, l+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cout.tie(0);cin.tie(0);\n\n\tint n, i, j, k, x, y;\n\tcin >> n;\n\tfor (i = 1; i < n; ++i) {\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\n\tdfs(1, 1);\n\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (lev[i] & 1) {\n\t\t\tcout << \"Alice\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Bob\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\nconst int MX=100011;\nint n;\nstruct Edge{int t,nxt;Edge(int _t=0,int _nxt=0):t(_t),nxt(_nxt){}}e[MX<<1];\nint hed[MX],ec;\ninline void ade(int f,int t){e[++ec]=Edge(t,hed[f]);hed[f]=ec;}\n#define FE(k,i) for(int (i)=hed[k];(i);(i)=e[i].nxt)if(e[i].t!=f)\nint SG(int k,int f){\n\tint sum=0;\n\tFE(k,i)sum^=SG(e[i].t,k)+1;\n\treturn sum;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tstatic int a,b;scanf(\"%d%d\",&a,&b);\n\t\tade(a,b),ade(b,a);\n\t}\n\tputs(SG(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 1000010\nvector<int> edge[MAXN];\nint n,sg[MAXN],u,v;\nvoid dfs(int u,int fa)\n{\n    sg[u]=0;\n    for(auto v : edge[u])\n    {\n        if(v==fa)continue;\n        dfs(v,u);\n        sg[u]^=sg[v]+1;\n    }\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i)\n    {\n        scanf(\"%d%d\",&u,&v);\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nint N;\nvector<vector<int > > to;\nint dfs(int i,int from) {\n\tint ret = 0;\n\tif (to[i].size() == 1) {\n\t\treturn 1;\n\t}\n\telse {\n\t\t\n\t\tfor (int j = 0; j < to[i].size(); j++) {\n\t\t\tif (to[i][j] != from) {\n\t\t\t\tret += dfs(to[i][j], i);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret % 2;\n\t\n}\nsigned main() {\n\tcin >> N;\n\tto.resize(N);\n\tint x, y;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tto[x].push_back(y);\n\t\tto[y].push_back(x);\n\t}\n\tint res;\n\tres = dfs(0,-1);\n\tif (res == 1) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nint dp[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      //dp[v] += dp[to];\n      dp[v]++;\n    }\n  }\n}\nvoid solve() {\n  freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (sz(g[1]) == 1) cout << \"Alice\", ioi\n  dfs(1, 1);\n  int res = 0;\n  rep(i, 1, n)\n    res ^= dp[i];\n  if (res) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvector<int> tree[100005];\n\nint dfs(int v, int from){\n  if(tree[v].size()==1 && from != -1) return 0;\n  int ret = 0;\n  for(auto to : tree[v]) if(to != from) ret ^= dfs(to, v)+1;\n  return ret;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    tree[a].pb(b);\n    tree[b].pb(a);\n  }\n\n  if(dfs(0,-1) == 0) cout << \"Bob\" << endl;\n  else cout << \"Alice\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, b) for (int i = a; i <= b; ++i)\n#define PER(i, a, b) for (int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define mp make_pair\n#define pb push_back\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define fi first\n#define se second\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\n\nconst int N = 100005, mo = 1000000007;\nint n, cnt[N];\nVI to[N];\nvector<LL> tmp[N], v;\nLL hs[N];\n\nvoid dfs(int x, int fa){\n\tRVC(i, to[x]) if (to[x][i] != fa){\n\t\tdfs(to[x][i], x);\n\t\ttmp[x].pb(hs[to[x][i]]);\n\t}\n\tsort(tmp[x].begin(), tmp[x].end());\n\tv.clear();\n\tfor (int i = 0; i < tmp[x].size(); ++i){\n\t\tif (i + 1 < tmp[x].size() && tmp[x][i] == tmp[x][i + 1]){\n\t\t\t++i; continue;\n\t\t}\n\t\tv.pb(tmp[x][i]);\n\t}\n\tLL t = 37;\n\tRVC(i, v)\n\t\tt = ((t * 233) ^ v[i]) % mo;\n\ths[x] = t;\n\t// debug(\"hs[%d] = %lld\\n\", x, hs[x]);\n\tcnt[x] = v.size();\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tREP(i, 2, n){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tto[u].pb(v);\n\t\tto[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tputs(cnt[1] == 0 ? \"Bob\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 100010\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1];\n\nint n;\nint g[MAXN],nume;\nint f[MAXN];\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid dfs(int x,int p){\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdfs(e[i].to,x);\n\t\t\tf[x]^=f[e[i].to]+1;\n\t\t}\n}\n\nint main(){\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tif(f[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\nvector<int> E[100005];\n\nint dfs(int pos,int fa){\n    int ans=0;\n    for(int i=0;i<E[pos].size();i++){\n        if(E[pos][i]==fa) continue;\n        ans^=(dfs(E[pos][i],pos)+1);\n    }\n    return ans;\n}\n\nint main(){//ios_base::sync_with_stdio(0);cin.tie(0);\n    int n=readint();\n    for(int i=1;i<n;i++){\n        int u=readint(),v=readint();\n        E[u].push_back(v);\n        E[v].push_back(u);\n    }\n    if(dfs(1,0)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 1e5 + 5;\nint n;\nint a , b;\nvector < int > v[N];\nint ans;\nint dfs(int node , int parent){\n\tint res = 0;\n\tfor(int next : v[node]){\n\t\tif(next != parent){\n\t\t\tres ^= dfs(next , node) + 1;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i < n ; ++i){\n\t\tscanf(\"%d %d\" , &a , &b);\n\t\tv[a].emplace_back(b);\n\t\tv[b].emplace_back(a);\n\t}\n\tans = 0;\n\tfor(int x : v[1]){\n\t\tans ^= dfs(x , 1) + 1;\n\t}\n\tif(ans){\n\t\tprintf(\"Alice\\n\");\n\t}\n\telse{\n\t\tprintf(\"Bob\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_ll.hpp>\n//typedef boost::multiprecision::cpp_ll ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E18;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n//#define endl \"\\n\"\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\nll n;\nstruct Node{\n    ll par;\n    vector<ll> chi;\n};\nNode node[500001];\nvector<ll> v[500001];\nvoid init(ll x){\n    rep(i,0,(ll)v[x].size()-1){\n        if(v[x][i]!=node[x].par){\n            node[x].chi.pb(v[x][i]);\n            node[v[x][i]].par=x;\n            init(v[x][i]);\n        }\n    }\n}\nvoid init(){\n    cin>>n;\n    rep(i,0,n-2){\n        ll x,y;cin>>x>>y;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    node[1].par=1;\n    init(1);\n}\n\nll hoge(ll x){\n    ll res=0;\n    if(node[x].chi.size()==0){\n        return 0;\n    }else{\n        rep(i,0,node[x].chi.size()-1){\n            res=res^(hoge(node[x].chi[i])+1);\n        }\n        return res;\n    }\n}\n\nint main(){fastio\n    init();\n    if(hoge(1)==0){\n        cout<<\"Bob\"<<endl;\n    }else{\n        cout<<\"Alice\"<<endl;\n    }\n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint grundy(const vvi& g,int p,int u)\n{\n\tint x=0;\n\tfor(int v:g[u])\n\t\tif(v!=p)\n\t\t\tx^=grundy(g,u,v)+1;\n\treturn x;\n}\n\nbool solve(const vvi& g)\n{\n\treturn grundy(g,-1,0);\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvvi g(n);\n\t\trep(i,n-1){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tcout<<(solve(g)?\"Alice\":\"Bob\")<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e6;\nconstexpr static int MOD = 1e9 + 7;\n\nvector <int> adj[MAXN];\nint cnt[MAXN];\nbool vis[MAXN];\n\nint dfs(int i) {\n    cnt[i] = 1;\n    vis[i] = true;\n    int64_t val = 0;\n    for (int j : adj[i])\n        if (!vis[j])\n            val ^= dfs(j);\n    cnt[i] += val;\n    return cnt[i];\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(0);\n\n    int sum = 0;\n    for (int i : adj[0])\n        sum ^= cnt[i];\n\n    return sum != 0;\n}\n\nint main() {\n    cout << (solve() ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100000+5;\nint n;\nvector<int > g[maxn];\nint sg[maxn];\nvoid addedge(int from,int to)\n{\n    g[from].push_back(to);\n    g[to].push_back(from);\n}\nint dfs(int v,int fa)\n{\n    if(g[v].size()==1 && fa==g[v][0]) return sg[v]=0;\n    sg[v]=0;\n    for(int i=0;i<(int)g[v].size();i++)\n    {\n        int u=g[v][i];\n        if(u!=fa) sg[v]=sg[v] xor (1+dfs(u,v));\n    }\n    return sg[v];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++){int from,to;scanf(\"%d%d\",&from,&to);addedge(from,to);}\n    dfs(1,-1);\n    if(sg[1]) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> dp(n, 0);\n    function<void(int, int)> Dfs = [&](int x, int p) {\n        for (int u : g[x]) {\n            if (u == p) continue;\n            Dfs(u, x);\n            dp[x] ^= dp[u] + 1;\n        }\n    };\n\n    Dfs(0, -1);\n    if (dp[0]) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nvector<ll> node[100005];\nbool used[100005]={false};\nll grundy(ll pos){\n  if(pos==1){\n    ll X=0;\n    for(int i=0;i<node[pos].size();i++){\n      ll to=node[pos][i];\n      used[to]=true;\n      X^=grundy(to);\n    }\n    if(X==0){\n      cout<<\"Bob\"<<endl;\n    }\n    else{\n      cout<<\"Alice\"<<endl;\n    }\n    return 0;\n  }\n  else{\n    vector<ll> vec;\n    for(int i=0;i<node[pos].size();i++){\n      ll to=node[pos][i];\n      if(!used[to]){\n        used[to]=true;\n        vec.push_back(grundy(to));\n      }\n    }\n    sort(vec.begin(),vec.end());\n    vec.erase(unique(vec.begin(),vec.end()),vec.end());\n    ll res=0;\n    for(int i=0;i<vec.size();i++){\n      ll tp=vec[i];\n      if(res!=tp) break;\n      res++;\n    }\n    return res;\n  }\n}\nint main(){\n  ll n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    ll s,t;\n    cin>>s>>t;\n    node[s].push_back(t);\n    node[t].push_back(s);\n  }\n  for(int i=1;i<=n;i++) used[i]=false;\n  used[1]=true;\n  grundy(1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nconst int MAXN = 100000 + 10;\n\nvector<int> g[MAXN];\nint n;\n\nint compute(int v, int p) {\n\tint cnt = 0, w;\n\tFOR (i, g[v].sz)\n\t\tif (g[v][i] != p) {\n\t\t\tcnt++;\n\t\t\tw = g[v][i];\n\t\t}\n\tif (!cnt)\n\t\treturn 0;\n\tint ret = 0;\n\tFOR (i, g[v].sz) {\n\t\tw = g[v][i];\n\t\tif (w == p)\n\t\t\tcontinue;\n\t\tret ^= (1 + compute(w, v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tFOR (i, MAXN)\n\t\tg[i].clear();\n\t\t\n\tscanf(\"%d\", &n);\n\tint x, y;\n\tFOR (i, n - 1) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tint ret = compute(1, -1);\n\tif (ret)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 2e5 + 10;\n\nstruct Node\n{\n\tint to, next;\n}edge[maxN * 2 + 1];\n\nint n;\nint head[maxN + 1], tot;\nint sg[maxN + 1];\n\ninline int read()\n{\n\tint num = 0, f = 1;\n\tchar ch = getchar();\n\twhile( !isdigit( ch ) ) { if(ch == '-') f = -1; ch = getchar(); }\n\twhile( isdigit( ch ) ) num = (num << 3) + (num << 1) + (ch ^ 48), ch = getchar();\n\treturn num * f;\n}\n\ninline void add(int x, int y)\n{\n\ttot ++;\n\tedge[tot].to = y;\n\tedge[tot].next = head[x];\n\thead[x] = tot;\n}\n\ninline void dfs(int u, int pa)\n{\n\tsg[u] = 0;\n\tfor(int i = head[u]; i; i = edge[i].next)\n\t{\n\t\tint v = edge[i].to;\n\t\tif(v == pa) continue;\n\t\tdfs(v, u);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\n\nint main()\n{\n\tn = read();\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd(x, y); add(y, x);\n\t}\n\n\tdfs(1, 0);\n\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint beg[200100],nex[200100],tto[200100],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint sg[200100];\nvoid dfs(int u,int fa){\n\tsg[u]=0;\n\tfor(int i=beg[u];i;i=nex[i])\n\t{\n\t\tif(tto[i]==fa) continue;\n\t\tdfs(tto[i],u);\n\t\tsg[u]^=sg[tto[i]]+1;\n\t}\n}\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\tint n;\n\tint s,t;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tdfs(1,0);\n\tif(sg[1])\n\t\tprintf(\"Alice\\n\");\n\telse\n\t\tprintf(\"Bob\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    if(g[i].size()==1){sg[i]=1;return;}\n    sg[i]=0;\n    //set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        //s.insert(sg[g[i][j]]);\n        //f[g[i][j]]=0;\n    }\n    for(long j=0,l=g[i].size();j<l;j++)if(!f[g[i][j]]){sg[i]^=(sg[g[i][j]]+1);}//f[g[i][j]]=1;}\n    //sg[i]++;\n    f[i]=0;\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%ld%ld\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    //cout<<endl;for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1])cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/** @Date    : 2017-07-09 21:15:04\n  * @FileName: D 树上删边 NIM 博弈.cpp\n  * @Platform: Windows\n  * @Author  : Lweleth (SoungEarlf@gmail.com)\n  * @Link    : https://github.com/\n  * @Version : $Id$\n  */\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n//#include <bits/stdc++.h>\n#define LL long long\n#define PII pair<int ,int>\n#define MP(x, y) make_pair((x),(y))\n#define fi first\n#define se second\n#define PB(x) push_back((x))\n#define MMG(x) memset((x), -1,sizeof(x))\n#define MMF(x) memset((x),0,sizeof(x))\n#define MMI(x) memset((x), INF, sizeof(x))\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5+20;\nconst double eps = 1e-8;\n\nvector<int>edg[N]; \nint get_sg(int x,int pre)\n{ \n    int ret=0; \n    for(auto i:edg[x])\n    { \n        if(i!=pre) \n            ret^=(1 + get_sg(i, x)); \n    } \n    return ret; \n} \nint main()\n{ \n \tint n;\n    while(~scanf(\"%d\", &n)) \n    {\n        for(int i = 1; i <= n; i++) \n            edg[i].clear(); \n        for(int i=1; i<n; i++){ \n            int x,y; \n            scanf(\"%d%d\",&x, &y); \n            edg[x].PB(y); \n            edg[y].PB(x); \n        } \n        if(get_sg(1,-1)) \n            puts(\"Alice\"); \n        else \n            puts(\"Bob\"); \n    } \n    return 0; \n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint Grundy[100050];\nint N;\nvector<int> pathes[100500];\nint parent[100050];\n\nvoid bfs(int from) {\n    Grundy[from] = 0;\n    int child = 0;\n    for(int i = 0; i < pathes[from].size(); i++) {\n        int to = pathes[from][i];\n        if(to == parent[from]) continue;\n        parent[to] = from;\n        bfs(to);\n        Grundy[from] ^= Grundy[to];\n        child++;\n    }\n    if(child == 1) Grundy[from]++;\n    return;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 1; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        pathes[x].push_back(y);\n        pathes[y].push_back(x);\n    }\n    parent[1] = -1;\n    bfs(1);\n    if(Grundy[1] == 0) cout << \"BoB\" << endl;\n    else cout << \"Alice\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define VPII vector<pair<int,int> >\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst LL INF = 1LL<<30;\nconst double eps = 1e-13;\n\nvector<int> adj[100009];\n\nint solve(int x,int p=-1){\n\tint ans=0;\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\tint cv=solve(i,x);\n\t\tans^=(cv+1);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].PB(b);\n\t\tadj[b].PB(a);\n\t}\n\tif(solve(0)==0)printf(\"Bob\");\n\telse printf(\"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[100001];\nbool visited[100001];\n\nint dfs(int v){\n    int g=0;\n    for(int i=0; i<G[v].size(); i++){\n        if(visited[G[v][i]]==0){\n            visited[G[v][i]]=1;\n            g^=(dfs(G[v][i])+1);\n        }\n    }\n    return g;\n}\n\nint main(){\n    //input\n    int N;\n    cin >> N;\n    int x,y;\n    N--;\n    while(N--){\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    //calc\n    for(int i=0; i<=100000; i++){\n        visited[i]=0;\n    }\n    visited[1]=1;\n    int grundy=dfs(1);\n    \n\n    //output\n    if(grundy!=0){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n    system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=100005;\n\nstruct EDGE{\n\tint from,to,next;\n} e[N*2];\n\nint n,cnt;\nint head[N],f[N];\n\nvoid addedge(int u,int v){\n\te[++cnt].from=u;e[cnt].to=v;e[cnt].next=head[u];\n\thead[u]=cnt;\n}\n\nvoid dfs(int x,int fa){\n\tf[x]=0;\n\tfor (int i=head[x];i;i=e[i].next){\n\t\tif (e[i].to==fa) continue;\n\t\tdfs(e[i].to,x);\n\t\tf[x]^=f[e[i].to]+1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v);addedge(v,u);\n\t}\n\tdfs(1,0);\n\tif (f[1]==0) puts(\"Bob\");else puts(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> edges[100000];\n\nint solve(int v, int p){\n    int ch = edges[v].size();\n    if(p >= 0) --ch;\n    if(ch == 0) return 0;\n    int ret = 0;\n    for(int u: edges[v]){\n        if(u == p) continue;\n        ret ^= solve(u, v);\n    }\n    if(ch == 1) ++ret;\n    return ret;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    cin >> n;\n    for(int i=1;i<n;++i){\n        int x, y;\n        cin >> x >> y;\n        --x; --y;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n    if(solve(0, -1) == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                        #define ppa pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n              \n            void gya(){\n            \tpr[0]=1;\n            \tfor(int i=1;i<2000010;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<2000010;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\nvector<int> G2[100030];\nvector<int> G[100030];\nint n;\n\n\n\nint saiki2(int u,int oya){\n\t\n\tint r=0;\n\tfor(auto v:G2[u])if(v!=oya){\n\t\tr^=(1+saiki2(v,u));\n\t}\n\treturn r;\n}\n      signed main(){\n  cin>>n;\n      \t\n      \tfor(int i=1;i<n;i++){\n      \t\tint yy,yyy;\n      \t\tcin>>yy>>yyy;\n      \t\tG[yy].pb(yyy);\n      \t\tG[yyy].pb(yy);\n      \t}\n      \t\n      \n      \tif(saiki2(1,-1)!=0)cout<<\"Alice\"<<endl;\n      \telse cout<<\"Bob\"<<endl;\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint dfs (int now, const vvi &t) {\n  if((int)(t[now].size()) == 0) {\n    return 0;\n  } else {\n    int res = 0;\n    for(int i=0;i<(int)(t[now].size());++i) {\n      res ^= 1 + dfs(t[now][i], t);\n    }\n    return res;\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  int n; cin >> n;\n  vvi g(n);\n  for(int i=0;i<n-1;++i) {\n    int x, y; cin >> x >> y;\n    x--; y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vvi t(n);\n  queue<P> que;\n  que.push({0, -1});\n  while(!que.empty()) {\n    int now = que.front().first, prev = que.front().second; que.pop();\n    for(int i=0;i<(int)(g[now].size());++i) {\n      int next = g[now][i];\n      if(next != prev) {\n        t[now].push_back(next);\n        que.push({next, now});\n      }\n    }\n  }\n  int ans = dfs(0, t);\n  cout << (ans==0 ? \"Bob\" : \"Alice\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<cstdio>  \n#include<cstring>  \n#include<cmath>  \n#include<vector>  \n#include<algorithm>  \n#define N 200005  \n#define LL long long  \n#define inf 1<<29  \n#define eps 1e-7  \nusing namespace std;  \nvector<int>v[200005];  \nint get_sg(int u,int pre){  \n    int ret=0;  \n    for(int i=0;i<v[u].size();i++){  \n        if(v[u][i]!=pre)  \n            ret^=(1+get_sg(v[u][i],u));  \n    }  \n    return ret;  \n}  \nint main(){  \n    int t,n;  \n        scanf(\"%d\",&n);  \n        for(int i=1;i<=n;i++)  \n            v[i].clear();  \n        for(int i=1;i<n;i++){  \n            int x,y;  \n            scanf(\"%d%d\",&x,&y);  \n            v[x].push_back(y);  \n            v[y].push_back(x);  \n        }  \n        if(get_sg(1,-1))  \n            puts(\"Alice\");  \n        else  \n            puts(\"Bob\");  \n\n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int MAXN = 100100;\n\nstruct Par\n{\n\tint a;\n\tint b;\n};\n\nbool myCom(const Par &a, const Par &b)\n{\n\tif (a.a == b.a)\n\t\treturn a.b < b.b;\n\telse\n\t\treturn a.a < b.a;\n}\n\nint n;\nint x, y;\nPar par[MAXN];\nint index;\n\nint main()\n{\n\tcin >> n;\n\tint a, b;\n\tx = y = 0;\n\tindex = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tif (a > b)\n\t\t{\n\t\t\tint tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\tpar[index].a = a;\n\t\tpar[index].b = b;\n\t\tindex++;\n\t}\n\tsort(par, par + index, myCom);\n\n\tfor (int i = 0; i < index; ++i)\n\t{\n\t\tif (i == 0 || par[i].a != par[i - 1].a || par[i].b != par[i - 1].b)\n\t\t{\n\t\t\tif (par[i].a == 1)\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}\n\t}\n\n\tif (x == 1)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t{\n\t\tint xx = x % 2;\n\t\tint yy = y % 2;\n\t\tif (xx + yy == 1)\n\t\t\tcout << \"Alice\" << endl;\n\t\telse\n\t\t\tcout << \"Bob\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\nconst int Maxn = 100005;\n\nint n;\nvector <int> neigh[Maxn];\n\nint Get(int v, int p)\n{\n\tint res = 0;\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tint u = neigh[v][i];\n\t\tif (u == p) continue;\n\t\tres ^= (Get(u, v) + 1);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tneigh[a].push_back(b);\n\t\tneigh[b].push_back(a);\n\t}\n\tint res = Get(1, 0);\n\tprintf(\"%s\\n\", res? \"Alice\": \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100005\n\nint N;\nvector<int> Edge[MAX_N];\n\nint dfs(int pos, int pre)\n{\n  int ret = 0;\n  for (int i = 0; i < Edge[pos].size(); i++) {\n    int next = Edge[pos][i];\n    if(next == pre){\n      continue;\n    }\n    ret ^= (dfs(next, pos) + 1);\n  }\n\n  return ret;\n}\n\nint main()\n{\n  cin >> N;\n  for (int i = 0; i < N-1; i++) {\n    int x, y; cin >> x >> y; x--; y--;\n    Edge[x].push_back(y);\n    Edge[y].push_back(x);\n  }\n\n  if(dfs(0, -1) == 0){\n    cout << \"Bob\" << endl;\n  }\n  else{\n    cout << \"Alice\" << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi std::vector<std::vector<int> >\n#define vvl std::vector<std::vector<ll> >\n#define MODs 1000000007;\ntypedef long long int ll;\nusing namespace std;\n\nvvi G = vv(100001, 0, 0, int);\nint dfs(int from, int now){\n  int ret = 0;\n  if((from==-1&&G[now].size()==1)||(from!=-1&&G[now].size()==2)){\n    for(int i=0;i<G[now].size();i++){\n      if(G[now][i]==from) continue;\n      ret = dfs(now, G[now][i]) + 1;\n    }\n  }\n  else{\n    for(int i=0;i<G[now].size();i++){\n      if(from==G[now][i]) continue;\n      ret ^= (dfs(now, G[now][i])+1);\n    }\n  }\n  return ret;\n}\nint main(int argc, char const *argv[]) {\n  int N, a, b;\n  std::cin >> N;\n  for(int i=0;i<N-1;i++){\n    std::cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  std::cout << (dfs(-1, 1)==0?\"Bob\":\"Alice\")<< '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nvector<int> V[MC];\nint G[MC];\n\nint dfs(int p , int q){\n\tint z = 0;\n\tfor(auto u : V[q]){\n\t\tif(u == p) continue;\n\t\tz ^= dfs(q,u) + 1;\n\t}\n\treturn z;\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint x,y;\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tV[x].PB(y);\n\t\tV[y].PB(x);\n\t}\n\tprintf(\"%s\\n\" , dfs(-1,1) == 0 ? \"Bob\" : \"Alice\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    if(g[i].size()==1){sg[i]=1;return;}\n    sg[i]=0;\n    //set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        //s.insert(sg[g[i][j]]);\n        //f[g[i][j]]=0;\n    }\n    for(long j=0,l=g[i].size();j<l;j++)if(!f[g[i][j]]){sg[i]^=(sg[g[i][j]]+1);}//f[g[i][j]]=1;}\n    //sg[i]++;\n    f[i]=0;\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    //cout<<endl;for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1]||g[1].size()==1)cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n\nusing namespace std;\n\nint cnt[100001];\nvector<int> tree[1000001];\nbool used[100001];\n\nbool winner(vector<int> index){\n    int counter =0;\n    vector<int> nextindex;\n    if(index.size()==0)return false;\n    for(int i=0;i<index.size();i++){\n        int k=index[i];\n        used[k]=true;\n        counter+=cnt[k];\n        for(int j=0;j<tree[k].size();j++){\n            cnt[tree[k][j]]--;\n            if(!used[tree[k][j]]){\n                nextindex.push_back(tree[k][j]);\n            }\n        }\n    }\n\n    if(counter%2==1){\n        return true;\n    }else{\n        return winner(nextindex);\n    }\n\n}\n\n\n\nint main(){\n\n    int N;\n    cin>>N;\n    fill_n(cnt,100001,0);\n    fill_n(used,100001,false);\n    REP(i,N-1){\n        int x,y;\n        cin>>x>>y;\n        cnt[x]++;\n        cnt[y]++;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n\n    }\n\n\n    vector<int> a;\n    a.push_back(1);\n    if(winner(a)){\n        cout<<\"Alice\"<<endl;\n    }else{\n        cout<<\"Bob\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nclass Random {\n    public:\n    static unsigned get(unsigned x) {\n        return xorshift() % x;\n    }\n    \n    private:\n    inline static unsigned xorshift() {\n        static unsigned x = 123456789, y = 362436039, z = 521288629, w = 88675123;\n        unsigned t = x ^ (x << 11);\n        x = y, y = z, z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n};\n\nint mod = 1000000007;\nlong long r[100000];\nvector <int> v[100000];\n\npair<int, long long> dfs(int x, int y) {\n    int m = 0, i;\n    long long z = 1;\n    set <pair<int, long long> > s;\n    set <pair<int, long long> >::iterator it;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        pair<int, long long> p;\n        \n        if (v[x][i] == y) continue;\n        \n        p = dfs(v[x][i], x);\n        \n        if (s.count(p)) {\n            s.erase(p);\n        } else {\n            s.insert(p);\n        }\n    }\n    \n    if (s.size() == 0) return make_pair(0, 1);\n    \n    for (it = s.begin(); it != s.end(); it++) m = max(m, it->first + 1);\n    for (it = s.begin(); it != s.end(); it++) z = z * (r[m] + it->second) % mod;\n    \n    return make_pair(m, z);\n}\n\nint main() {\n    int n, i;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n - 1; i++) {\n        int x, y;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        x--;\n        y--;\n        \n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    \n    if (v[0].size() == 1) {\n        puts(\"Alice\");\n    } else {\n        for (i = 0; i < n; i++) r[i] = Random::get(mod);\n        \n        if (dfs(0, -1).first == 0) {\n            puts(\"Bob\");\n        } else {\n            puts(\"Alice\");\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nnamespace Jiang_Guo_De_Ti\n{\n\tconst int N=101000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint f[N];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\te=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\tvoid dfs(int p,int h=0)\n\t{\n\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\tif(to[i]!=h)dfs(to[i],p);\n\t\tf[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)f[p]^=f[q]+1;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tdfs(1);\n\t\tif(f[1])printf(\"Alice\\n\");\n\t\telse printf(\"Bob\\n\");\n\t}\n}\nint main()\n{\n\tJiang_Guo_De_Ti::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tif(rand()%2)puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nint sg[MAXN];\nvoid dfs(int x,int fa)\n{\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y!=fa)dfs(y,x),sg[x]^=(sg[y]+1);\n\t}\n}\nint n;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);ins(y,x);\n\t}dfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long N;\nvector<long long> tree[100005];\n\nlong long grundy(long long pa, long long cur){\n\tlong long ret = 0;\n\tfor(long long i = 0; i < tree[cur].size(); i++){\n\t\tif(tree[cur][i] != pa){\n\t\t\tret = ret ^ grundy(cur, tree[cur][i]);\n\t\t}\n\t}\n\tif(cur == 0){\n\t\t//cout << \"cur = \" << cur << \" ret = \" << 0 << endl;\n\t\treturn ret;\n\t}\n\tif(tree[cur].size() == 1){\n\t\t//cout << \"cur = \" << cur << \" ret = \" << 1 << endl;\n\t\treturn 1;\n\t}\n\treturn ret + 1;\n}\n\n\n\nint main(){\n\tcin >> N;\n\tfor(long long i = 0; i < N - 1; i++){\n\t\tlong long x, y;\n\t\tcin >> x >> y;\n\t\tx--;y--;\n\t\ttree[x].push_back(y);\n\t\ttree[y].push_back(x);\n\t}\n\n\tif(grundy(-1, 0) == 0){\n\t\tcout << \"Bob\" << endl;\n\t}else{\n\t\tcout << \"Alice\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n\n#define N 200005\n\nusing namespace std;\n\nint n;\nint h[N], adj[N], nxt[N], o;\n\ninline void add (int u, int v) {\n\tnxt[++o] = h[u];\n\th[u] = o;\n\tadj[o] = v;\n\treturn ;\n}\n\nint dfs (int u, int la) {\n    int sum = 0;\n    for (int i = h[u]; i; i = nxt[i]) {\n    \tint v = adj[i];\n    \tif (la != v)\n    \t\tsum ^= dfs (v, u) + 1; \n    }\n    return sum;\n}\n\nint main () {\n    scanf (\"%d\", &n);\n    for (int i = 1, u, v; i < n; ++i) {\n        scanf (\"%d%d\", &u, &v);\n        add (u, v);\n        add (v, u); \n    }\n    if (dfs (1, 0))\n    \tputs (\"Alice\");\n    else \n    \tputs (\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e5 + 20 ;\nint n , gnd[N] ;\nvector <int> g[N] ;\n\nvoid dfs (int v , int par = -1) {\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue ;\n\n\t\tdfs(u , v) ;\n\n\t\tgnd[v] ^= (gnd[u] + 1) ;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tfor (int i = 0 , u , v ; i < n - 1 ; i ++) {\n\t\tcin >> u >> v ;\n\t\tu -- , v -- ;\n\n\t\tg[u].push_back(v) ;\n\t\tg[v].push_back(u) ;\n\t}\n\n\tdfs(0) ;\n\n\tcout << (gnd[0] ? \"Alice\" : \"Bob\") << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\nconst int N=100010;\nint e[N*2],nex[N*2],head[N],ed=0;\nvoid adde(int x,int y){e[++ed]=y;nex[ed]=head[x];head[x]=ed;}\nint dfs(int x,int fa){\n    int i,t=0;\n    for(i=head[x];i;i=nex[i])\n        if(e[i]!=fa) t^=dfs(e[i],x)+1;\n    return t;\n}\nint main(){\n    int n,i,x,y;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++){\n        scanf(\"%d %d\",&x,&y);\n        adde(x,y);adde(y,x);\n    }\n    if(dfs(1,0)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fr(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\n/////////////////\n\nint const N = 2e5 + 41;\n\nint n;\nvector<int> e[N];\n\nint dfs(int u, int p){\n\tint r = 0;\n\tfr(i, 0, sz(e[u])){\n\t\tint to = e[u][i];\n\t\tif(to == p) continue;\n\t\tr ^= (dfs(to, u) + 1);\n\t}\n\treturn r;\n}\n\nvoid solve(){\n\tcin >> n;\n\tfr(i, 0, n-1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u;--v;\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tif(dfs(0, -1)) cout << \"Alice\";\n\telse cout << \"Bob\";\n\tcout << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<list>\n#include<queue>\n#include<string.h>\n#include<functional>\n#include<stack>\n#include<deque>\n#include<string>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n\nvector<int>r[100000];\nint DFS(int p, int a) {\n\tint b = 0;\n\tfor (int c : r[a]) {\n\t\tif (c != p) {\n\t\t\tb ^= DFS(a, c)+1;\n\t\t}\n\t}\n\treturn b;\n}\nsigned main() {\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tr[x].push_back(y);\n\t\tr[y].push_back(x);\n\t}\n\tif (DFS(-1, 0)) {\n\t\tputs(\"Alice\");\n\t}\n\telse {\n\t\tputs(\"Bob\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nint main() {\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<vector<int> > e(n);\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            scanf(\"%d%d\", &u, &v);\n            u--; v--;\n            e[u].push_back(v);\n            e[v].push_back(u);\n        }\n        function<int(int, int)> dfs = [&](int v, int pr) {\n            int cur = 0;\n            for (int to : e[v]) {\n                if (to == pr) continue;\n                cur ^= dfs(to, v) + 1;\n            }\n            return cur;\n        };\n        int x = dfs(0, 0);\n        string ans = x == 0 ? \"Bob\" : \"Alice\";\n        cout << ans << endl;\n    }\n\n#ifdef HOME\n    cerr << clock() / (double)CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nvector<int> g[100010];\nint dfs(int x,int f)\n{\n\tint s=0;\n\tfor(auto v:g[x])\n\t\tif(v!=f)\n\t\t\ts^=dfs(v,x)+1;\n\treturn s;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tif(dfs(1,0))\n\t\tprintf(\"Alice\\n\");\n\telse\n\t\tprintf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nclass Random {\n    public:\n    static unsigned get(unsigned x) {\n        return xorshift() % x;\n    }\n    \n    private:\n    inline static unsigned xorshift() {\n        static unsigned x = 123456789, y = 362436039, z = 521288629, w = 88675123;\n        unsigned t = x ^ (x << 11);\n        x = y, y = z, z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n};\n\nint mod = 1000000009;\nlong long r[100000];\nvector <int> v[100000];\n\npair<int, long long> dfs(int x, int y) {\n    int m = 0, i;\n    long long z = 1;\n    set <pair<int, long long> > s;\n    set <pair<int, long long> >::iterator it;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        pair<int, long long> p;\n        \n        if (v[x][i] == y) continue;\n        \n        p = dfs(v[x][i], x);\n        \n        if (s.count(p)) {\n            s.erase(p);\n        } else {\n            s.insert(p);\n        }\n    }\n    \n    for (it = s.begin(); it != s.end(); it++) m = max(m, it->first + 1);\n    for (it = s.begin(); it != s.end(); it++) z = z * (r[m] + it->second) % mod;\n    \n    return make_pair(m, z);\n}\n\nint main() {\n    int n, i;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n - 1; i++) {\n        int x, y;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        x--;\n        y--;\n        \n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    \n    for (i = 0; i < n; i++) r[i] = Random::get(mod);\n    \n    if (dfs(0, -1).first == 0) {\n        puts(\"Bob\");\n    } else {\n        puts(\"Alice\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" \" << x << endl\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n\n#define fst first\n#define snd second\n\ntypedef long long llint;\ntypedef pair<int, int> pii;\n\nconst int B = 27397, MOD = 1e9 + 7;\nconst int B1 = 33941, MOD1 = 1e9 + 9;\n\nconst int MAXN = 1e5+10;\n\nint n;\n\nvector<int> v[MAXN];\n\nint get_sum(int node, int p) {\n  int ret = 0;\n  for (int nxt : v[node]) {\n    if (nxt == p) continue;\n    ret ^= 1 + get_sum(nxt, node);\n  }\n  return ret;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b); --a; --b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n\n  if (get_sum(0, -1) == 0)\n    printf(\"Bob\\n\");\n  else\n    printf(\"Alice\\n\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"avx2\")  //Enable AVX\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(),a.end()\n#define F first\n#define S second\n#define pb push_back\n#define ll long long\n#define vi vector<int>\n#define pi pair<int,int>\n#define mp make_pair\n \n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...) 42\n#endif\n \nint mod=1e9+7;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint mul(int a,int b)\n{\n\treturn ((a)*1ll*(b))%mod;\n}\n \nvoid add(int &a,int b)\n{\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n \nint sub(int a,int b){\n\ta-=b;\n\tif(a<0){\n\t\ta+=mod;\n\t}\n\treturn a;\n}\n \nint powz(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1){\n\t\t\tres=mul(res,a);\n\t\t}\n\t\tb/=2;\n\t\ta=mul(a,a);\n\t}\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nistream& operator>>(istream& input,pair<A,B>& x) {\n\tinput>>x.F>>x.S;\n\treturn input;\n}\n \ntemplate <typename A>\nistream& operator>>(istream& input,vector<A>& x) {\n\tfor(auto& i:x)\n\t\tinput>>i;\n\treturn input;\n}\n \ntemplate<typename A>\nostream& operator<<(ostream& output,vector<A>& x) {\n\tfor(auto& i:x)\n\t\toutput<<i<<' ';\n\treturn output;\n}\n \nconst int N=1000002;\n \nvector<int>adj[N];\nint dp[N];\n \nint dfs(int u,int p){\n\tif(adj[u].size()==2&&p!=-1){\n\t\tfor(auto i:adj[u]){\n\t\t\tif(i!=p){\n\t\t\t\treturn dp[u]=dfs(i,u)+1;\n\t\t\t}\n\t\t}\n\t}\n\tint sum=0;\n\tfor(auto i:adj[u]){\n\t\tif(i!=p){\n\t\t\tsum^=dfs(i,u);\n\t\t}\n\t}\n\treturn dp[u]=sum;\n}\n \nvoid solve(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\tdfs(0,-1);\n\tint val=dp[0];\n\tif(val){\n\t\tcout<<\"Alice\";\n\t}\n\telse{\n\t\tcout<<\"Bob\";\n\t}\n}\n \nsigned main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tc=1;\n\t//~ cin>>tc;\n\tfor(int _=0;_<tc;_++){\n\t\t//~ cout<<\"Case #\"<<_+1<<\": \";\n\t\tsolve();\n\t\tif(_!=tc-1)\n\t\tcout<<\"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint N;\nvvi T;\n\nint dfs(int v, int p) {\n        int cur=0;\n        for (auto u : T[v]) {\n                if (u == p) continue;\n                cur ^= dfs(u,v)+1;\n        }\n\n        return cur;\n}\n\nint main() {\n        cin >> N;\n        T = vvi(N+1,vi());\n        for (int i=0; i<N-1; i++) {\n                int x,y;\n                cin >> x >> y;\n                T[x].push_back(y);\n                T[y].push_back(x);\n        }\n\n        int sg = dfs(1,-1);\n        if (sg == 0)\n                cout << \"Bob\\n\";\n        else\n                cout << \"Alice\\n\";\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\n#define MAXN 100001\nvector<int> g[MAXN];\nint dfs(int u, int p) {\n  int ret = 0;\n  for (auto v : g[u]) {\n    if (v==p) continue;\n    ret ^= dfs(v, u)+1;\n  }\n  return ret;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n-1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  cout << (dfs(1, 0) ? \"Alice\" : \"Bob\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5+10;\nvector<int> to[maxn];\nint n;\nint sg (int u, int fa) {\n    int sz = to[u].size();\n    int ret = 0;\n    for (int i = 0; i < sz; i++) if (to[u][i] != fa){\n        ret ^= sg (to[u][i], u) + 1;\n    }\n    return ret;\n}\nint main () {\n    scanf (\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf (\"%d%d\", &a, &b);\n        to[a].push_back (b);\n        to[b].push_back (a);\n    }\n    if (sg(1, 0) == 0) printf (\"Bob\\n\");\n    else printf (\"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "// sketchy code\n\n#include <stdio.h>\n#include <vector>\n\nint t1,t2;\n\nint n;\n\nstd::vector<int> g[100005];\nbool vis[100005];\nint nimsum[100005];\n\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for (int v:g[u]) {\n        if (vis[v]) continue;\n        dfs(v);\n        nimsum[u]^=nimsum[v]+1;\n    }\n    //printf(\"%d val %d\\n\",u,nimsum[u]);\n}\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d\",&n);\n    for (int i=1; i<n; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    dfs(1);\n    printf(nimsum[1]?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define all(a) a.begin(), a.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nusing namespace std;\ntypedef long long ll;\n\nvector<int> tree[100000];\nint dfs(int v, int p){\n    int cnt0 = 0, cnt1 = 0;\n    for(int u : tree[v])if(u != p){\n        bool t = dfs(u, v);\n        if(!t)cnt0++;\n        else cnt1++;\n    }\n    return cnt0 % 2 == 1 or cnt1 % 2 == 1;\n}\n\nint main(){\n\n    int N;\n    cin >> N;\n\n    rep(i, N - 1){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n\n    cout << (dfs(0, -1) ? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC diagnostic warning \"-Wconversion\"\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define all(a) begin(a), end(a)\n#define has(a, b) (a.find(b) != a.end())\n#define fora(i, n) for(int i = 0; i < n; i++)\n#define forb(i, n) for(int i = 1; i <= n; i++)\n#define forc(a, b) for(const auto &a : b)\n#define ford(i, n) for(int i = n; i >= 0; i--)\n#define maxval(t) numeric_limits<t>::max()\n#define minval(t) numeric_limits<t>::min()\n#define imin(a, b) a = min(a, b)\n#define imax(a, b) a = max(a, b)\n\n#define dbgs(x) #x << \" = \" << x\n#define dbgs2(x, y) dbgs(x) << \", \" << dbgs(y)\n#define dbgs3(x, y, z) dbgs2(x, y) << \", \" << dbgs(z)\n#define dbgs4(w, x, y, z) dbgs3(w, x, y) << \", \" << dbgs(z)\n\nusing ll = long long;\n\nvector<int> succ[100007];\n\nint dfs(int i, int from)\n{\n        int res = 0;\n        forc(next, succ[i])\n        {\n                if (next == from)\n                        continue;\n                res ^= dfs(next, i) + 1;\n        }\n        return res;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n        cin.tie(nullptr);\n\n        int n;\n        cin >> n;\n        fora(i, n - 1)\n        {\n                int a, b;\n                cin >> a >> b;\n                succ[a].pb(b);\n                succ[b].pb(a);\n        }\n\n        int res = dfs(1, 0);\n        if (res == 0)\n                cout << \"Bob\" << endl;\n        else cout << \"Alice\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2 && false) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int f = 0;\n        FORE(e, ch) f ^= (e & 1);\n        cout << (f ^ ((N - 1) & 1) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 9;\nconst int MAXN = 100005;\n\nint n;\nvector<int> gph[MAXN];\n\nint f(int x, int p){\n\tint ans = 0;\n\tfor(auto &i : gph[x]){\n\t\tif(i == p) continue;\n\t\tans ^= f(i, x) + 1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tgph[x].push_back(y);\n\t\tgph[y].push_back(x);\n\t}\n\tcout << (f(1, 0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <cmath>\nconst int MaxN = 1e5;\nusing namespace std;\nint pre[2 * MaxN + 5] , last[MaxN + 5] , other[MaxN + 5];\nint all , n , res[MaxN + 5];\nvoid Build(int u , int v){\n\tpre[++all] = last[u];\n\tlast[u] = all;\n\tother[all] = v;\n}\nvoid dfs(int x , int fa){\n\tint ed = last[x];\n\twhile(ed != -1){\n\t\tint dr = other[ed];\n\t\tif(dr != fa){\n\t\t\tdfs(dr , x);\n\t\t\tres[x] ^= res[dr] + 1;\n\t\t}\n\t\ted = pre[ed];\n\t}\n}\nint main()\n{\n\twhile(~scanf(\"%d\" , &n)){\n\t\tall = -1;\n\t\tmemset(last , -1 , sizeof(last));\n\t\tmemset(res , 0 , sizeof(res));\n\t\tfor(int i = 1;i <= n - 1;i++){\n\t\t\tint u , v;\n\t\t\tscanf(\"%d%d\" , &u , &v);\n\t\t\tBuild(u , v); Build(v , u);\n\t\t}\n\t\tdfs(1 , 0);\n\t\tif(res[1]) printf(\"Alice\\n\");\n\t\telse printf(\"Bob\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 100005;\n\nstruct Edge\n{\n\tint to, nxt;\n} e[maxn << 1];\n\nint first[maxn];\n\ninline void add_edge(int from, int to)\n{\n\tstatic int cnt = 0;\n\te[++cnt].nxt = first[from];\n\tfirst[from] = cnt;\n\te[cnt].to = to;\n\te[++cnt].nxt = first[to];\n\tfirst[to] = cnt;\n\te[cnt].to = from;\n}\n\nint sg[maxn];\nint n;\n\ninline void dfs(int now, int fa)\n{\n\tint gs = 0;\n\tfor (int i = first[now]; i; i = e[i].nxt)\n\t{\n\t\tregister int to = e[i].to;\n\t\tif (to != fa)\n\t\t{\n\t\t\tgs++;\n\t\t\tdfs(to, now);\n\t\t}\n\t}\n\tif(gs == 1)\n\t{\n\t\tfor (int i = first[now]; i; i = e[i].nxt)\n\t\t\tif (e[i].to != fa)\n\t\t\t\tsg[now] = sg[e[i].to] + 1;\n\t}\n\telse\n\t{\n\t\tfor (int i = first[now]; i; i = e[i].nxt)\n\t\t\tif (e[i].to != fa)\n\t\t\t\tsg[now] ^= sg[e[i].to];\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, f, t; i < n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tadd_edge(f, t);\n\t}\n\tdfs(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Template\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <utility>\n#include <stack>\n#include <set>\n#include <algorithm>\n#include <bitset>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <complex>\n#include <regex>\n#pragma comment(linker, \"/STACK:167772160\")\n\nusing namespace std;\n#define mp make_pair\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define print_var(x) cerr << #x << \" : \" << (x) << endl\n#define print_array(arr, len) {cerr << #arr << \" : \"; for(int i = 0; i < len; ++i) cerr << arr[i] << ' '; cerr << endl;}\n#define print_2d_array(arr, len1, len2) {cerr << #arr << endl; for(int i = 0; i < len1; ++i, cerr << endl) for(int j = 0; j < len2; ++j) cerr << arr[i][j] << ' ';}\n#define print_iterable(i) {cerr << #i << \" : \"; for(auto e : i) cerr << e << ' '; cerr << endl;}\n#define print_new_line() cerr << endl\n\ntemplate <typename T, typename Q>\nvoid print_pair1(pair<T, Q> x)\n{\n\tcerr << \"(\" << x.first << \", \" << x.second << \")\\n\";\n}\n\n#define print_pair(x) {cerr << #x << \" : \"; print_pair1(x);}\n#else\n#define print_pair(x) (void)0\n#define eprintf(...) (void)0\n#define print_var(x) (void)0\n#define print_array(arr, len) {}\n#define print_2d_array(arr, len1, len2) {}\n#define print_iterable(i) {}\n#define print_new_line() (void)0\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\nconst int INF = (int)1e9 + 10;\nconst ll LINF = ll(2e18) + 10;\nconst double PI = acosl(-1);\nconst double eps = 1e-8;\nconst ld EPS = 1e-12;\n#pragma endregion\n\n#ifdef LOCAL\n#define ERR_CATCH\n//#define NOERR\n#endif\n\nconst int N = 1e5 + 10;\nint n;\nvector<int> go[N];\n\nint dfs(int v, int p)\n{\n\tint x = 0;\n\tfor (auto e : go[v])\n\t\tif (e != p)\n\t\t\tx ^= dfs(e, v) + 1;\n\treturn x;\n}\n\nvoid solve()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\tgo[a].push_back(b);\n\t\tgo[b].push_back(a);\n\t}\n\tputs(dfs(0, -1) ? \"Alice\" : \"Bob\");\n}\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n#ifdef NOERR\n\tfreopen(\"err.txt\", \"w\", stderr);\n#endif\n#else\n\t//freopen(\"courier.in\", \"r\", stdin);\n\t//freopen(\"courier.out\", \"w\", stdout);\n#endif\n\n#ifdef ERR_CATCH\n\ttry\n\t{\n#endif\n\n#ifdef ST\n\t\twhile (true)\n\t\t\tsolve();\n#endif\n#ifdef CASES\n#define MULTITEST\n#endif\n#ifdef MULTITEST\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tchar endl1[5];\n\t\tfgets(endl1, 5, stdin);\n\t\tfor (int i = 0; i < t; ++i)\n\t\t{\n#ifdef CASES\n\t\t\tprintf(\"Case #%d: \", i + 1);\n#endif\n\t\t\tsolve();\n#ifdef CASES\n\t\t\teprintf(\"Passed case #%d:\\n\", i + 1);\n#endif\n\t\t}\n#else\n\t\tsolve();\n#endif\n\n#ifdef ERR_CATCH\n\t}\n\tcatch (logic_error e)\n\t{\n\t\tprint_var(e.what());\n\t\tputs(\"___________________________________________________________________________\");\n\t\texit(0);\n\t}\n#endif\n#ifdef LOCAL\n\teprintf(\"\\n\\nTime: %.3lf\\n\", double(clock()) / CLOCKS_PER_SEC);\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=2e5+10;\n\nint n,tote,FIR[maxn],NEXT[maxn],TO[maxn];\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint dfs(int u,int F)\n{\n\tint Ans=0;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tAns^=dfs(v,u)+1;\n\t}\n\treturn Ans;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * (c) fushar (Ashar Fuadi)\n*/\n\n#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i = 0, _n = n; i < _n; i++)\n#define FOR(i,a,b) for (int i = a, _b = b; i <= _b; i++)\n#define FORD(i,b,a) for (int i = b, _a = a; i >= _a; i--)\n#define RESET(c,v) memset(c, v, sizeof c)\n#define ALL(c) c.begin(), c.end()\n#define TT template<typename T>\n\nusing namespace std;\nusing ll = long long;\n\nTT bool in_range(int x, int a, int b) { return a <= x && x < b; }\n\n/***********************************************************/\n\nconst int MAXN = 100005;\n\nint N;\nvector<int> G[MAXN];\n\nint dfs(int u, int p, int level) {\n    if (p != -1 && G[u].size() == 1) {\n        return level;\n    }\n\n    int res = 0;\n    for (int v : G[u]) if (v != p) {\n        res ^= dfs(v, u, level+1);\n    }\n\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    REP(i, N-1) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    puts(dfs(0, -1, -1) == 0 ? \"Bob\" : \"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\nint n,dp[100111];\nvector<int> con[100111];\nvoid dfs(int x,int pre=-1)\n{\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i];\n\t\tif(u==pre)continue;\n\t\tdfs(u,x);\n\t\tdp[x]^=dp[u]+1;\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tgetii(x,y);\n\t\tcon[x].PB(y);\n\t\tcon[y].PB(x);\n\t}\n\tdfs(1);\n\tif(dp[1]==0)puts(\"Bob\");else puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\n\nint n;\nvector <int> G[N];\nint f[N];\n\nvoid dfs(int u, int p) {\n\tfor (int v: G[u]) if (v != p) {\n\t\tdfs(v, u);\n\t\tf[u] ^= (f[v] + 1);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1,0);\n\n\tprintf(f[1] > 0 ? \"Alice\\n\" : \"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwe\n#define y1 onyetvwe\n#define x2 onyette\n#define y2 ugmewuben\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint nodes,root=1;\nvector <int> node[100005];\nint dfs(int now,int par=-1){\n\tint ret=0;\n\tfor(auto v:node[now])\n\t{\n\t\tif(v==par)\n\t\t\tcontinue;\n\t\tret^=dfs(v,now)+1;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscan(nodes);\n\tfor(int i=1;i<=nodes-1;i++)\n\t{\n\t\tint u,v;\n\t\tscan(u,v);\n\t\tnode[u].pb(v);\n\t\tnode[v].pb(u);\n\t}\n\tif(dfs(root)==0)\n\t\tcout<<\"Bob\"<<endl;\n\telse\n\t\tcout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n#define inf (1<<30)-1\n#define INF (1LL<<62)-1\n#define MOD 1000000007LL\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define PI acos(-1)\n#define MEM(x,y) memset(x,y,sizeof (x))\n#define debug cout<<\"A\"<<'\\n'\n#define REP(i,a,b) for (int i=(a); i<=(b); i++)\n#define PER(i,a,b) for (int i=(a); i>=(b); i--)\n#define REPL(i,a,b) for (LL i=(a); i<=(b); i++)\n#define PERL(i,a,b) for (LL i=(a); i>=(b); i--)\n#define print(x) cout<<x<<'\\n'\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define UNIQUE(X) X.erase( unique( X.begin(), X.end() ), X.end() )\n\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int>PII;\ntypedef pair<LL,LL>PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\n\n\n// Order Statistic Tree\n\n/* Special functions:\n\n        find_by_order(k) --> returns iterator to the kth largest element counting from 0\n        order_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\ntypedef tree<\nPII,\nnull_type,\nless<PII>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    T ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\n/*end of header*/\n\nint n;\nVI graph[100009];\nint grundy[100009];\n\nvoid dfs(int u,int par)\n{\n    REP(i,0,graph[u].size()-1)\n    {\n        int v=graph[u][i];\n        if(v==par)continue;\n        dfs(v,u);\n        grundy[u]^=(grundy[v]+1);\n    }\n}\n\nint main()\n{\n    //freopen(\"input_file_name.in\",\"r\",stdin);\n    //freopen(\"output_file_name.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    REP(i,1,n-1)\n    {\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        graph[u].PB(v);\n        graph[v].PB(u);\n    }\n    dfs(1,-1);\n    if(grundy[1])print(\"Alice\");\n    else print(\"Bob\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxn=1e5;\n\nint n;\nvector<int> G[maxn+5];\n\nint dfs(int x,int r)\n{\n\tint res=0;\n\tif (G[x].size()==1 && x!=1) return 0;\n\tfor (int e:G[x])\n\t{\n\t\tif (e==r) continue;\n\t\tres^=(dfs(e,x)+1);\n\t}\n\treturn res;\n}\n\nbool solve()\n{\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tG[i].clear();\n\t}\n\t\n\tint u,v;\n\tfor (int i=1;i<=n-1;++i)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tif (dfs(1,-1)) return true;\n\telse return false;\n}\n\nint main(void)\n{\n\t#ifdef ex\n\tfreopen (\"in\",\"r\",stdin);\n\t#endif\n\t\n\twhile (scanf(\"%d\",&n)==1)\n\t{\n\t\tif (solve())\n\t\t{\n\t\t\tprintf(\"Alice\\n\");\n\t\t}\n\t\telse \n\t\t{\n\t\t\tprintf(\"Bob\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\nconst int MAXN = 100010;\n\nint n;\nvector<int> v[MAXN];\nint F[MAXN];\n\nvoid dfs(int x, int p)\n{\n\tF[x] = 0;\n\tfor (auto y : v[x])\n\t{\n\t\tif (y == p) continue;\n\t\tdfs(y, x);\n\t\tF[x] ^= (F[y]+1);\n\t}\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tputs(F[1] ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n;\nvector <int> v[N];\nset <int> s[N];\n\nvoid dfs(int node, int pnode){\n    int big = -1;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        dfs(i, node);\n        if(big == -1 || s[i].size() > s[big].size()){\n            big = i;\n        }\n    }\n    if(big != -1) swap(s[node], s[big]);\n    for(auto &i : v[node]){\n        if(i == pnode || i == big) continue;\n        for(auto &j : s[i]){\n            if(s[node].count(j)) s[node].erase(j);\n            else s[node].insert(j);\n        }\n    }\n    int cur;\n    if(s[node].size() == 0) cur = 1;\n    else cur = *s[node].rbegin() + 1;\n    s[node].insert(cur);\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    if(s[1].size() == 1) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <vector>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <utility>\n#include <bitset>\n#include <limits>\n#include <climits>\nusing namespace std;\n\n#ifdef DEBUG\n#define NDEBUG\n#endif\n#undef NDEBUG\n#include <cassert>\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n\n\n\nint solve(vector<vector<int>>& ne) {\n    vector<int> xors;\n\n    int N = ne.size();\n    vector<int> parent(N);\n    vector<vector<int>> children(N);\n    parent[0] = -1;\n    queue<int> q;\n    q.push(0);\n    vector<int> r;\n    vector<int> visited(N, false);\n    while (!q.empty()){\n        int u = q.front(); q.pop();\n        r.push_back(u);\n        visited[u] = true;\n        for (int v : ne[u]) {\n            if (visited[v]) continue;\n            parent[v] = u;\n            children[u].push_back(v);\n            q.push(v);\n        }\n    }\n    reverse(ALL(r));\n    vector<vector<int>> legs(N);\n    // cout << parent << endl;\n    // cout << r << endl;\n    rep(i,N) {\n        int v = r[i], u = parent[v];\n\n        int L = legs[v].size();\n        int msg = -1;\n        switch (L) {\n            case 0:\n                msg = 1;\n                if (v == 0) xors.push_back(msg);\n                break;\n            case 1:\n                msg = legs[v][0] + 1;\n                if (v == 0) xors.push_back(msg);\n                break;\n            default:\n                int x = 0;\n                rep(i, L) x ^= legs[v][i];\n                xors.push_back(x);\n                msg = 1;\n                break;\n        }\n        if (u != -1 && msg != -1) {\n            legs[u].push_back(msg);\n        }\n    }\n\n    int ans = 0;\n    for (int x : xors) ans += x;\n\n    return ans;\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> ne(N);\n    rep(i, N-1) {\n        int x, y; cin >> x >> y;\n        --x; --y;\n        ne[x].pb(y); ne[y].pb(x);\n    }\n    int ans = solve(ne);\n    cout << (ans == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio> \n#include<cstring> \n#include<cmath> \n#include<vector> \n#include<algorithm> \n#define N 10005 \n#define LL long long \n#define inf 1<<29 \n#define eps 1e-7 \nusing namespace std; \nvector<int>v[100005]; \nint get_sg(int u,int pre){ \n    int ret=0; \n    for(int i=0;i<v[u].size();i++){ \n        if(v[u][i]!=pre) \n            ret^=(1+get_sg(v[u][i],u)); \n    } \n    return ret; \n} \nint main(){ \n    int n; \n  \n        scanf(\"%d\",&n); \n        for(int i=1;i<=n;i++) \n            v[i].clear(); \n        for(int i=1;i<n;i++){ \n            int x,y; \n            scanf(\"%d%d\",&x,&y); \n            v[x].push_back(y); \n            v[y].push_back(x); \n        } \n        if(get_sg(1,-1)) \n            puts(\"Alice\"); \n        else \n            puts(\"Bob\"); \n     \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstatic int solve(int u, int p, const vector<vector<int>>& conn){\n\tint g = 0;\n\tfor(const auto v : conn[u]){\n\t\tif(v == p){ continue; }\n\t\tg ^= (solve(v, u, conn) + 1);\n\t}\n\treturn g;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> conn(n);\n\tfor(int i = 1; i < n; ++i){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tconn[a].push_back(b);\n\t\tconn[b].push_back(a);\n\t}\n\tcout << (solve(0, -1, conn) == 0 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\nconst int N = 1e5L + 11;\nvector <int> e[N];\n\nint sg[N];\nvoid dfs(int x, int p) {\n\tfor(int i : e[x]) if(i != p) {\n\t\tdfs(i, x);\n\t\tsg[x] ^= (sg[i] + 1);\n\t}\n}\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tint n; cin >> n;\n\tfor(int i = 1; i < n; i ++) {\n\t\tint u, v; cin >> u >> v;\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tcout << (sg[1] ? \"Alice\" : \"Bob\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint n;\nvector<vi> adj;\n\nint go(int u, int p) {\n    int ans = 0;\n    for (int v : adj[u]) if (v != p) {\n        ans ^= 1 + go(v,u);\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n\n    cin >> n;\n    adj.resize(n);\n    forn(_,n-1) {\n        int u,v; cin >> u >> v;\n        u--; v--;\n        adj[u].pb(v); adj[v].pb(u);\n    }\n\n    int ans = go(0,-1);\n    cout << (ans ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define maxn 1000001\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint nt[maxn], go[maxn], fi[maxn], n, cnt, sg[maxn];\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n}\nvoid dfs(int x, int fa){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; if(v == fa) continue;\n        sg[x] ^= (sg[v] + 1);\n    }\n}\nint main(){\n    n = read();\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add(x, y); add(y, x);\n    }\n    dfs(1, 0);\n    if(sg[1] == 0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint n, ta, tb;\nvector< int > x[100005];\n \nint dfs(int a, int b) {\n\tint re = 0;\n\tfor (int i = 0; i < x[a].size(); i++)\n\t\tif (x[a][i] != b)\n\t\t\tre ^= dfs(x[a][i], a) + 1;\n\treturn re;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tx[ta].push_back(tb);\n\t\tx[tb].push_back(ta);\n\t}\n\tprintf(dfs(1, 0) ? \"Alice\\n\" : \"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],e;\nvoid AddEdge(int u,int v) {\n\tto[++e]=v;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;nxt[e]=first[v];first[v]=e;\n}\nint dfs(int x,int fa) {\n\tint res=0;\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa) res^=dfs(to[i],x)+1;\n\treturn res;\n}\nint main() {\n\tn=read();\n\trep(i,2,n) AddEdge(read(),read());\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mkp make_pair\n#define pii pair<int, int> \n#define pll pair<long long int, long long int>\n#define sci(x) scanf(\"%d\", &x)\n#define scl(x) scanf(\"%lld\", &x)\n#define fi first\n#define sc second\n#define deb 0\n\nint lev[100001], mark[100001];\nvector <int> v[100001];\n\nvoid dfs(int x, int l)\n{\n\tlev[l]++;\n\tmark[x] = 1;\n\n\tfor (int y : v[x]) {\n\t\tif (!mark[y]) {\n\t\t\tdfs(y, l+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cout.tie(0);cin.tie(0);\n\n\tint n, i, j, k, x, y;\n\tcin >> n;\n\tfor (i = 1; i < n; ++i) {\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\n\tdfs(1, 1);\n\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (lev[i] & 1) {\n\t\t\tcout << \"Alice\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Bob\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\nvector<ll> v[100001];\nll vis[100001]={0};\nll val[100001]={0};\nvoid dfs(ll node)\n{\n\tvis[node]=1;\n\tfor(ll i=0;i<v[node].size();i++)\n\t{\n\t\tif(vis[v[node][i]]==0)\n\t\t{\n\t\t\tdfs(v[node][i]);\n\t\t\tval[node]^=(val[v[node][i]]+1);\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tll n;\n\tcin>>n;\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(1);\n\tif(val[1]!=0)\n\tcout<<\"Alice\"<<endl;\n\telse\n\tcout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n#define F first\n#define S second\n#define PB push_back\n#define PF push_front\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\nconst int maxn = 1e5 + 37;\n\nint gn[maxn];\nvector <int> t[maxn];\n\nvoid dfs (int v, int p = -1) { // find grundy_number\n\tif (t[v].size() == 2 and p != -1) {\n\t\tfor (auto w : t[v]) {\n\t\t\tif (w != p) {\n\t\t\t\tdfs (w, v);\n\t\t\t\tgn[v] = gn[w] + 1;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (auto w : t[v]) {\n\t\t\tif (w != p) {\n\t\t\t\tdfs (w, v);\n\t\t\t\tgn[v] ^= gn[w];\n\t\t\t}\n\t\t}\n\t}\n//\tcout << v << \" \" << gn[v] << endl;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tt[v].PB (u);\n\t\tt[u].PB (v);\n\t}\n\tdfs (1);\n\tif (gn[1] == 0)\n\t\tcout << \"Bob\" << endl;\n\telse\n\t\tcout << \"Alice\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*  AtCoder Grand Contest 017. Problem D, by Abreto<m@abreto.net>. */\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define MAXN    100000\n\nint N;\nvector<int> conj[MAXN];\n//int sg[MAXN];\nint visited[MAXN];\n\nint sg(int id)\n{\n    int ret = 0;\n    visited[id] = 1;\n    for(auto p : conj[id])\n        if(!visited[p])\n            ret ^= sg(p)+1;\n    return ret;\n}\n\nint main(void)\n{\n    int i = 0;\n    int xi = 0, yi = 0;\n\n    scanf(\"%d\", &N);\n    for(i = 1;i < N;++i)\n    {\n        scanf(\"%d%d\", &xi, &yi);\n        conj[xi].push_back(yi);\n        conj[yi].push_back(xi);\n    }\n    printf(\"%s\\n\", (0==sg(1))?\"Bob\":\"Alice\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint dfs(int v,vector<vector<int>> &edge,vector<int> &grundy,vector<int> &used){\n    used[v]=true;\n    int res=0;\n    for(int i=0;i<edge[v].size();i++){\n        int to=edge[v][i];\n        if(used[to]){\n            continue;\n        }\n        res=min(dfs(to,edge,grundy,used),res);\n    }\n    return grundy[v]=res+1;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> edge(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    vector<int> used(n);\n    vector<int> grundy(n);\n    grundy[0]=1;\n    vector<int> gs;\n    dfs(0,edge,grundy,used);\n    /*\n    for(int i=0;i<edge.size();i++){\n        for(int j=0;j<edge[i].size();j++){\n            if(i<edge[i][j]) continue;\n            gs.push_back(min(grundy[i],grundy[edge[i][j]]));\n        }\n    }\n    */\n    \n    int res=0;\n\n    for(int i=0;i<edge[0].size();i++){\n        res^=grundy[edge[0][i]];\n    }\n    cout<<(res?\"Alice\" :\"Bob\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N];\nint n,cnt;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nint dfs(int x,int fa){\n\tint res=0;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif ((y=E[i].y)!=fa){\n\t\t\tres^=dfs(y,x)+1;\n\t\t}\n\treturn res;\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tputs(dfs(1,-1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,i,j,v[100005];\nvector <int> edge[100005];\n\nvoid solve(int id, int p){\n\tfor(int k = 0; k < edge[id].size(); k++){\n\t\tint to = edge[id][k];\n\t\tif(to == p) continue;\n\t\tsolve(to, id);\n\t\t\n\t\tv[id] ^= (v[to] + 1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\t\n\tfor(i = 0; i < n - 1; i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\t\n\tsolve(1, -1);\n\t\n\tif(v[1] == 0)\n\tprintf(\"Bob\\n\");\n\telse\n\tprintf(\"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<int> G[114514];\nint dfs(int v,int p){\n  int res=0,cnt=0;\n  for(int u:G[v]){\n    if(u==p) continue;\n    res^=dfs(u,v)+1;\n    cnt++;\n  }\n  return res;\n}\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>\nvoid read(T &x)\n{\n    char ch=getchar();\n    int f=1;\n    for (x=0;ch!='-'&&(ch<'0'||ch>'9');ch=getchar());\n    if (ch=='-') f=-1,ch=getchar();\n    for (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n    x*=f;\n}\ntypedef long long ll; \n#define MAXN 100010\nstruct edge{\n\tint s,t,next;\n}e[MAXN<<1];\nint head[MAXN],cnt;\nvoid addedge(int s,int t)\n{\n\te[cnt].s=s;e[cnt].t=t;e[cnt].next=head[s];head[s]=cnt++;\n\te[cnt].s=t;e[cnt].t=s;e[cnt].next=head[t];head[t]=cnt++;\n}\nint n,u,v;\nll sg[MAXN];\nvoid dfs(int node,int lastfa)\n{\n\tsg[node]=0;\n\tfor (int i=head[node];i!=-1;i=e[i].next)\n\t\tif (e[i].t!=lastfa)\n\t\t{\n\t\t\tdfs(e[i].t,node);\n\t\t\tsg[node]^=(sg[e[i].t]+1);\n\t\t}\n}\nint main()\n{\n\tread(n);\n\tmemset(head,0xff,sizeof(head));\n\tcnt=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tread(u),read(v);\n\t\taddedge(u,v);\n\t}\n\tdfs(1,1);\n\tputs(sg[1]==0 ? \"Bob\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define ll long long\n#define INF 1000000000\n#define clr(x) memset(x,0,sizeof(x))\nusing namespace std;\n\ninline int read()\n{\n\tregister int ret=0,c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile(isdigit(c))ret=ret*10+c-'0',c=getchar();\n\treturn ret;\n}\n\nint n,ans;\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tif(x==1||y==1)ans++;\n\t}\n\tans+=n;\n\tif(ans&1)puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nconst int MAX_N = 100000;\nvector<int> adj [MAX_N];\n\nint dfs(int curr,int prev = -1)\n{\n\tint res = 0;\n\tfor(const auto& it : adj [curr]) if(it != prev){\n\t\tres ^= dfs(it,curr) + 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;\n\t\tv--;\n\t\tadj [u].push_back(v);\n\t\tadj [v].push_back(u);\n\t}\n\n\tint res = dfs(0);\n\tif(res){\n\t\tputs(\"Alice\");\n\t}\n\telse{\n\t\tputs(\"Bob\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Edge {\n  const int from, to;\n  Edge(int from, int to) : from(from), to(to) {}\n};\n\nvector<vector<Edge>> ReadUndirectedGraph(\n    int n, int m, bool is_one_indexed=false) {\n  vector<vector<Edge>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int v1, v2;\n    cin >> v1 >> v2;\n    if (is_one_indexed) {\n      v1--;\n      v2--;\n    }\n    graph[v1].push_back(Edge(v1, v2));\n    graph[v2].push_back(Edge(v2, v1));\n  }\n  return graph;\n}\n\nvector<vector<Edge>> ReadDirectedGraph(\n    int n, int m, bool is_one_indexed=false) {\n  vector<vector<Edge>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int v1, v2;\n    cin >> v1 >> v2;\n    if (is_one_indexed) {\n      v1--;\n      v2--;\n    }\n    graph[v1].push_back(Edge({v1, v2}));\n  }\n  return graph;\n}\n\nstruct WeightedEdge {\n  int from, to;\n  int64 weight;\n  WeightedEdge(int from, int to, int64 weight)\n      : from(from), to(to), weight(weight) {}\n};\n\n// Verified: ABC126D\nvector<vector<WeightedEdge>> ReadUndirectedWeightedGraph(\n    int n, int m, bool is_one_indexed=false) {\n  vector<vector<WeightedEdge>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int v1, v2;\n    int64 weight;\n    cin >> v1 >> v2 >> weight;\n    if (is_one_indexed) {\n      v1--;\n      v2--;\n    }\n    graph[v1].push_back(WeightedEdge(v1, v2, weight));\n    graph[v2].push_back(WeightedEdge(v2, v1, weight));\n  }\n  return graph;\n}\n\nvector<vector<WeightedEdge>> ReadDirectedWeightedGraph(\n    int n, int m, bool is_one_indexed=false) {\n  vector<vector<WeightedEdge>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int v1, v2;\n    int64 weight;\n    cin >> v1 >> v2 >> weight;\n    if (is_one_indexed) {\n      v1--;\n      v2--;\n    }\n    graph[v1].push_back(WeightedEdge(v1, v2, weight));\n  }\n  return graph;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  auto graph = ReadUndirectedGraph(n, n - 1, true);\n  function<int(int, int)> dfs = [&](int v, int p) -> int {\n    if (graph[v].size() == 0) return 0;\n    int value = 0;\n    for (const auto& e : graph[v]) {\n      if (e.to == p) continue;\n      value ^= dfs(e.to, v) + 1;\n    }\n    return value;\n  };\n  int grundy = dfs(0, -1);\n  if (grundy > 0) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=500050;\n\nint head[N],to[N],next[N],sg[N],n,tot;\n\nvoid addedge(int u,int v){\n\ttot++;to[tot]=v,next[tot]=head[u],head[u]=tot;\n\ttot++;to[tot]=u,next[tot]=head[v],head[v]=tot;\n}\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=next[i]){\n\t\tif(to[i]!=fa){\n\t\t\tdfs(to[i],x);\n\t\t\tsg[x]^=sg[to[i]]+1;\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\taddedge(j,k);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nvector<int> g[100100];\nint k=0;\n\nvoid dfs(int s,int p,int q){\n    k^=q;\n    for(int r:g[s]){\n        if(r!=p){\n            dfs(r,s,q+1);\n        }\n    }\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n    for(int i=0;i<n-1;i++){\n        int x,y; cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0,-1,0);\n    if(k){\n        cout << \"Alice\" << endl;\n    }\n    else{\n        cout << \"Bob\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint a[N];\nvector<int> v[N];\nvoid dfs(int x, int par=0)\n{\n    for(int i=0;i<v[x].size();i++)\n    {\n        if(v[x][i]==par)\n            continue;\n        dfs(v[x][i],x);\n        a[x]^=(a[v[x][i]]+1);\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1);\n    if(a[1])\n        cout<<\"Alice\"<<endl;\n    else\n        cout<<\"Bob\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define long long long\n#define pll pair < long , long >\n#define vll vector < pll >\n#define ml map < long , long >\n#define mll map < pll , long >\n#define x first\n#define y second\n#define vl vector < long >\n#define io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nvl a[100005];\nlong g[100005]={0};\nvoid dfs(long node , long par)\n{\n    long i;\n    for(i=0;i<a[node].size();++i)\n    if(a[node][i]!=par)\n    {\n        dfs(a[node][i],node);\n        g[node]^=(g[a[node][i]]+1);\n    }\n}\nint main()\n{\n    io\n    long n,x,y,i;\n    cin>>n;\n    n--;\n    while(n--)\n    {\n        cin>>x>>y;\n        a[x].pb(y);\n        a[y].pb(x);\n    }\n    dfs(1,-1);\n    if(g[1]==0) cout<<\"Bob\";\n    else cout<<\"Alice\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n,x=0,a,b,i;\n\tcin>>n;\n\tn--; \n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b;\n\t\tif(a==1) x++;\n\t}\n\tif(x==1){\n\t\tcout<<\"Alice\"<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2==1) cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  \n#include <cstring>  \n#include <iostream>  \n#include <algorithm>  \n#define N 501000  \nusing namespace std;  \nstruct KSD  \n{  \n    int v,next;  \n}e[N<<1];  \nint head[N],cnt;  \ninline void add(int u,int v)  \n{  \n    e[++cnt].v=v;  \n    e[cnt].next=head[u];  \n    head[u]=cnt;  \n}  \nint n;  \nint sg[N];  \nvoid dfs(int x,int p)  \n{  \n    int i,v;  \n    sg[x]=0;  \n    for(i=head[x];i;i=e[i].next)  \n    {  \n        v=e[i].v;  \n        if(v==p)continue;  \n        dfs(v,x);  \n        sg[x]^=(sg[v]+1);  \n    }  \n}  \nint main()  \n{  \n    int i,j,T;  \n    int a,b;  \n   // for(scanf(\"%d\",&T);T--;)  \n    //{  \n        cnt=1;  \n        memset(head,0,sizeof(head));  \n        scanf(\"%d\",&n);  \n        for(i=1;i<n;i++)  \n        {  \n            scanf(\"%d%d\",&a,&b);  \n            add(a,b),add(b,a);  \n        }  \n        dfs(1,0);  \n        if(sg[1])puts(\"Alice\");  \n        else puts(\"Bob\");  \n  //  }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\n#define N (ll)(1e6+3)\n#define INF (ll)(1e18+3)\n#define MOD (ll)(1e9+7)\n\n#define ll long long\n#define rep(i,a,n) for(ll i = a; i < n; i++)\n#define per(i,a,n) for(ll i = n-1; i >= a; i--)\n\n//using namespace __gnu_pbds;\nusing namespace std;\n \n// typedef\n// tree<\n//     pair<ll,ll>,\n//     null_type,\n//     less<pair<ll,ll>>,\n//     rb_tree_tag,\n//     tree_order_statistics_node_update>\n// ordered_set;\n\n\nll n;\nll par[N];\nvector<ll> g[N];\nll d[N];\n\nvoid dfs(ll u, ll p) {\n    vector<ll> v;\n\n    rep(i,0,g[u].size()) {\n        ll ch = g[u][i];\n        if (ch == p) continue;\n        dfs(ch,u);\n        v.push_back(d[ch]);\n    }\n\n    if (v.size() == 1)\n        d[u] = v[0]+1;\n    else {\n        ll mask = 0;\n        rep(i,0,v.size()) {\n            mask ^= v[i];\n        }\n        d[u] = !!mask;\n    }\n}\n\nvoid solve() {\n    cin >> n;\n    rep(i,0,n-1) {\n        ll a, b; cin >> a >> b; a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0,0);\n    if (d[0]) {\n        cout << \"Alice\" << endl;\n    }\n    else {\n        cout << \"Bob\" << endl;\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 2e5 + 10;\nint N;\nint cnt = 1, Head[MAXN], Next[MAXM], To[MAXM];\n\ninline void add_edge(int x, int y) {\n\tNext[++cnt] = Head[x], To[cnt] = y, Head[x] = cnt;\n}\n\ninline void insert_edge(int x, int y) {\n\tadd_edge(x, y), add_edge(y, x);\n}\n\ninline int Dfs(int x, int fa = 0) {\n\tregister int i; int res = 0;\n\tfor(i = Head[x]; i; i = Next[i])\n\t\tif(To[i] != fa)\n\t\t\tres ^= Dfs(To[i], x) + 1;\n\treturn res;\n}\n\nint main() {\n\tregister int i; int x, y;\n\tscanf(\"%d\", &N);\n\tfor(i = 1; i < N; ++i)\n\t\tscanf(\"%d%d\", &x, &y),\n\t\tinsert_edge(x, y);\n\tputs(Dfs(1, 0) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint Grundy(int v, int from, const vector<vector<int>>& g) {\n  int result = 0;\n  for (int x : g[v]) if (x != from) result ^= 1 + Grundy(x, v, g);\n  return result;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (Grundy(0, -1, g) > 0) {\n    cout << \"Alice\\n\";\n  } else {\n    cout << \"Bob\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long \n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n \n#define y1 what\n\nusing namespace std;\n \nconst int N = (int) 4e5 + 10;\nconst int M = (int) 1e6 + 10;\nconst ll LINF = (ll) 2e18;\nconst int INF = (int) 1e9 + 7;\nconst double EPS = (double) 1e-9;\nconst double PI =  3.14159265359;\n\nint n;\nvector<int> v[N];\n\nint main() {\n    #define fn \"euler\"\n    #ifdef witch                                                            \n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n        //freopen(fn\".in\", \"r\", stdin);\n        //freopen(fn\".out\", \"w\", stdout);\n    #endif      \n    cin >> n;\n    for (int i = 1, x, y; i < n; i++) {\n        cin >> x >> y;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans ^= sz(v[i]) - (i > 1);\n    }\n    if (ans) cout << \"Alice\";\n    else cout << \"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\nconst int N = 100010;\nstruct Edge{ int to, next;} edge[N * 2];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\nint dfs(int x, int f)\n{\n\tint ret = 0;\n\tRepG(i, x) if (v != f)\n\t\tret ^= (dfs(v, x) + 1);\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n - 1) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd_edge(x, y); add_edge(y, x);\n\t}\n\t\n\tif (dfs(1, 0)) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint sun[MAXN];\nint n, g[MAXN], nxt[MAXN << 1], to[MAXN << 1], edgeSize;\nvector<int>G[MAXN];\nvoid addEdge(int u, int v){\n\tnxt[++ edgeSize] = g[u];\n\tto[g[u] = edgeSize] = v;\n}\nint dfs(int x, int f){\n\tint p, s = 0;\n\tfor(int i = 0; i<G[x].size(); i++)\n\tp=G[x][i];\n\t\tif(p!= f)\n\t\t\ts ^= dfs(p, x) + 1;\n\treturn s;\n}\nint main(){\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t} printf(\"%s\\n\", dfs(1, -1) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n\nusing namespace std;\n\nint N;\nvector<vector<int>> E;\n\nint grundy[100000 + 100];\n\nint dfs(int pos, int bef) {\n\tif (grundy[pos] != -1)return grundy[pos];\n\n\tint g = 0;\n\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\tint nxt = E[pos][i];\n\t\tif (nxt == bef)continue;\n\t\tg ^= (dfs(nxt, pos) + 1);\n\t}\n\treturn grundy[pos] = g;\n}\n\nint main() {\n\n\tcin >> N;\n\tE.resize(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tE[u].push_back(v), E[v].push_back(u);\n\t}\n\n\tfor (int i = 0; i < N; i++)grundy[i] = -1;\n\tdfs(0, -1);\n\n\tif (grundy[0])cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<math.h>\n#include<unordered_set>\n#include<string.h>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\n\n#define FOR(i,N) for(int i=0;i<N;i++)\n\nll mod=1e9+7;\n\n\nint main() {\n    int n;\n    cin>>n;\n    int a=0;\n    set<int>con;\n    map<int,int>ma;\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        ma[x]++,ma[y]++;\n        if(x==1||y==1){\n            a++;\n            if(x==1){\n                con.insert(y);\n            } else {\n                con.insert(x);\n            }\n        }\n    }\n    bool dep=false;\n    for(auto c:con){\n        if(ma[c]>1){\n            dep=true;\n        }\n    }\n    if(a==1){\n        cout<<\"Alice\"<<endl;\n    } else {\n        if(a>2&&dep){\n            cout<<\"Alice\"<<endl;\n        }else if((n-1)%2==1){\n            cout<<\"Alice\"<<endl;\n        } else {\n            cout<<\"Bob\"<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nvector<int> G[100100];\nint f[100100];\n\nvoid dfs(int v, int p) {\n  for (int u: G[v]) {\n    if (u == p) continue;\n    dfs(u, v);\n  }\n  if (G[v].size() == 1) return;\n  if (G[v].size() == 2) {\n    for (int u: G[v]) {\n      if (u == p) continue;\n      f[v] = f[u] + 1;\n    }\n  }\n  else {\n    for (int u: G[v]) {\n      if (u == p) continue;\n      f[v] ^= f[u];\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n;\n  cin >> n;\n  rep(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  G[0].push_back(-1);\n  dfs(0, -1);\n  cout << (f[0] ? \"Alice\" : \"Bob\") << '\\n';\n\n  \n\n\n\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long int lld;\n\nconst lld mod = 1e9+7;\nconst lld INF = 1e9;\nconst lld MAXN = 1e5;\n\nint main()\n{\n\tint n,x[MAXN] = {0},y[MAXN] = {0};\n\tint deg[MAXN] = {0};\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tdeg[x[i]-1]++;\n\t\tdeg[y[i]-1]++;\n\t}\n\n\n\n\tint sum = 0;\n\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tsum ^= deg[i];\n\t}\n\n\tcout << sum << endl;\n\n\tif (sum %2 == 0)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}else\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nvector<int> V[MC];\n\nbool dfs(int p , int q){\n\tint z = 0;\n\tint y = 0;\n\tfor(auto u : V[q]){\n\t\tif(u == p) continue;\n\t\tif(dfs(q,u)) ++z;\n\t\telse ++y;\n\t}\n\treturn y%2 == 0 && z%2==0;\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint x,y;\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tV[x].PB(y);\n\t\tV[y].PB(x);\n\t}\n\tprintf(\"%s\\n\" , dfs(-1,1) ? \"Bob\" : \"Alice\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll N;\nll v[100009];\nstring calc() {\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        v[a]++;\n        v[b]++;\n    }\n\n    if (v[1] == 1) {\n        return \"Alice\";\n    } else {\n        if (v[1] == 2) {\n            if ((N - 1) & 1) {\n                return \"Alice\";\n            } else return \"Bob\";\n        } else {\n            // v[1] == 3\n            return \"Alice\";\n        }\n    }\n\n}\n\nint main () {\n    cout << calc() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n#include<list>\n#include<bitset>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<utility>\n#include<fstream>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<assert.h>\nusing namespace std;\n\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define CLR(a) memset(a, 0, sizeof(a))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) )\n#define S(X) ( (X) * (X) )\n#define SZ(V) (int )V.size()\n#define FORN(i, n) for(i = 0; i < n; i++)\n#define FORAB(i, a, b) for(i = a; i <= b; i++)\n#define ALL(V) V.begin(), V.end()\n#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))\n\ntypedef pair<int,int> PII;\ntypedef pair<double, double> PDD;\ntypedef vector<int> VI;\ntypedef vector<PII > VP;\n\n#define AIN(A, B, C) assert(IN(A, B, C))\n\n//typedef int LL;\ntypedef long long int LL;\n//typedef __int64 LL;\n\nVI V[100005];\nint g[100005];\nint n;\n\nint G(int at, int par) {\n\tg[at] = 0;\n\tfor (int v : V[at]) {\n\t\tif (par == v) continue;\n\t\tint x = G(v, at);\n\t\tx++;\n\t\tg[at] ^= x;\n\t}\n\treturn g[at];\n}\n\nint main()\n{\n\tMEM(g, -1);\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tV[u].push_back(v);\n\t\tV[v].push_back(u);\n\t}\n\n\tint ans = G(1, 0);\n\tif (ans == 0) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define N 200009\nusing namespace std;\ndouble ans;\nint head[N],tot,sg[N],n;\ninline int rd(){\n\tint x=0;char c=getchar();bool f=0;\n\twhile(!isdigit(c)){if(c=='-')f=1;c=getchar();}\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n\treturn f?-x:x;\n}\nstruct edge{int n,to;}e[N<<1];\ninline void add(int u,int v){e[++tot].n=head[u];e[tot].to=v;head[u]=tot;}\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=e[i].n)if(e[i].to!=fa){\n\t\tint v=e[i].to;dfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\nint main(){\n    n=rd();int u,v;\n\tfor(int i=1;i<n;++i){\n\t\tu=rd();v=rd();\n\t\tadd(u,v);add(v,u);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f,oo = inf;\n#define pi 3.14159265358979323846\n#define IL inline\n#define RG register\n#define rep(i,a,b) for(RG int i=(a);i<(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define Dep(i,a,b) for(RG int i=(a);i>=(b);--i)\n#define pc putchar\n/*char __wzp[1<<15|1],*__S=__wzp+32768;\n#define gc() (__S>=__wzp+32768?(__wzp[fread(__wzp,sizeof(char),1<<15,stdin)]=EOF),*((__S=__wzp)++):*(__S++))*/\n#define gc getchar\nIL ll read(){\n    RG ll x=0;char f=0;RG char c=gc();\n    for(;!isdigit(c);c=gc())f|=(c=='-');\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return f?-x:x;\n}\nIL double readdb(){\n    RG double x=0,p=0.1;RG char f=0,c=gc();\n    for(;!isdigit(c);c=gc())f|=(c=='-');\n    for(;isdigit(c);c=gc())x=x*10+(c^48);\n    if(c=='.')for(c=gc();isdigit(c);c=gc(),p/=10)x=x+(c^48)*p;\n    return f?-x:x;\n}\nIL void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);pc(x%10+'0');}\nIL void writeln(ll x){write(x);puts(\"\");}\nIL void writeln(ll x,char c,ll y){write(x);pc(c);writeln(y);}\nIL void writeln(ll x,char c,ll y,char d,ll z){write(x);pc(c);write(y);pc(d);writeln(z);}\n#define debug(x) printf(#x\" = %d\\n\",x);\n#define rd() read()\n#define rdb() readdb()\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define fin(x) freopen(#x\".in\",\"r\",stdin)\n#define fout(x) freopen(#x\".out\",\"w\",stdout)\n#define y1 ____y1\n#define hash __hash\n#define union _union\nconst int maxn = 100500;\nint sg[maxn],n,m;\nvector<int> edge[maxn];\nvoid dfs(int u,int fa){\n\tsg[u] = 0;\n\tfor(unsigned i=0;i<edge[u].size();++i){\n\t\tint v = edge[u][i];\n\t\tif(v ==fa) continue;\n\t\tdfs(v,u);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\nint main(){\n\tn = rd();\n\tRep(i,1,n) edge[i].clear();\n\trep(i,1,n){\n\t\tint a = rd(),b = rd();\n\t\tedge[a] . push_back(b);\n\t\tedge[b] . push_back(a);\n\t}\n\tdfs(1,0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM], w[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, nr = 0;\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n            dfs(v[nod][i], nod);\n        }\n    }\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n           w[++nr] = s[ v[nod][i] ];\n        }\n    }\n    sort(w + 1, w + nr + 1);\n    if(w[1] == 0){\n        for(i = 2; i <= nr; i++){\n            if(w[i] - w[i - 1] > 1){\n                s[nod] = w[i - 1] + 1;\n                break;\n            }\n        }\n        if(i == nr + 1){\n            s[nod] = w[nr] + 1;\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(v[1].size() == 1){\n        cout<<\"Alice\";\n        return 0;\n    }\n    dfs(1, 0);\n    for(i = 0; i < v[1].size(); i++){\n        sum ^= s[ v[1][i] ];\n    }\n    if(sum == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  //dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if((int)v[i].size()%2){\n      ans++;\n    }\n  }ans--;\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "        #include<bits/stdc++.h>\n        using namespace std;\n         \n        #define maxn 111111\n        vector<int> g[maxn];\n        int n;\n         \n        int main()\n        {\n            cin >> n;\n            for (int i = 1; i < n; i++)\n            {\n                int x, y;\n                cin >> x >> y;\n                g[x].push_back(y);\n                g[y].push_back(x);\n            }\n            if (g[1].size() == 1)\n            {\n                cout << \"Alice\" << endl;\n            }\n            return 0;\n        }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n \ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n \ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n \nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n \n \nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n \nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n \nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n \ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n \ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n \ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n \ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n \ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n \ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint n,q[100005],x[100005];\nvi g[100005];\nvoid dfs(int v,int p){\n\tint ch=0;\n\tfor(auto &i:g[v]){\n\t\tif(i==p)continue;\n\t\tdfs(i,v);\n\t\tch++;\n\t\tx[v]^=q[i];\n\t\tif(ch%2==0)q[v]=x[v];\n\t\telse q[v]=1;\n\t}\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[--a].eb(--b);\n\t\tg[b].eb(a);\n\t}\n\tdfs(0,-1);\n\tif(q[0])cout<<\"Alice\\n\";\n\telse cout<<\"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n    \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define doublecout(a) cout<<fixed<<setprecision(15)<<a<<endl;\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n#define V vector<ll> \n#define U_MAP unordered_map<ll,ll>\n#define pq priority_queue<ll>\n#define rpq priority_queue<ll,vector<ll>,greater<ll>>\n#define p_b push_back\n    \nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x[ohara],y[ohara],sum,pos,k,q;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl,vi[ohara];\nstruct edge{int to,cost;};\nV g[ohara];\nqueue<ll> que;\nP p[ohara];\nll p_cou;\nll dp[ohara],de[ohara];\n    \n//------ Believe yourself as a genius!!!!!! ------\n\n\nvoid dfs(ll now,ll dep){\n    if(vi[now])return;\n    vi[now]=true;\n    p[p_cou++]=m_p(dep,now);\n    de[now]=dep;\n    rep(i,Size(g[now])){\n        dfs(g[now][i],dep+1);\n    }\n}\n    \nint main(void){\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>n;\n    rep(i,n-1)cin>>x[i]>>y[i];\n    rep(i,n-1){\n        x[i]--;y[i]--;\n        g[x[i]].p_b(y[i]);\n        g[y[i]].p_b(x[i]);\n    }\n    dfs(0LL,0LL);\n    sort(p,p+p_cou);\n    reverse(p,p+p_cou);\n    rep(i,p_cou){\n        ll moto=p[i].se;\n        int ok=0;\n        ll cost=0;\n        rep(j,Size(g[moto])){\n            ll to=g[moto][j];\n            if(de[to]<de[moto])continue;\n            cost=(cost xor dp[to]);\n            ok++;\n        }\n        //Cout(moto);\n        if(moto==0){\n            if(ok==0)dp[moto]=0;\n            else dp[moto]=cost;\n        }\n        else{\n            if(ok==0)dp[moto]=1;\n            else dp[moto]=cost+1;\n        }\n    }\n    if(dp[0]==0)Cout(\"Bob\");\n    else Cout(\"Alice\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100000 + 10;\n\nint n , sg[maxn] , fa , ans;\nvector < int > Edge[maxn];\n\nint DFS( int u , int fa = 0 ){\n\tfor(auto v : Edge[u]){\n\t\tif( v == fa )\n\t\t\tcontinue;\n\t\tsg[u] ^= (DFS( v , u ) + 1);\n\t}\n\treturn sg[u];\n}\n\nint main( int argc , char * argv[] ){\n\tscanf( \"%d\" , & n );\n\tfor(int i = 2 ; i <= n ; ++ i){\n\t\tint u , v;\n\t\tscanf( \"%d%d\" , & u , & v );\n\t\tEdge[u].emplace_back( v );\n\t\tEdge[v].emplace_back( u );\n\t}\n\tif( DFS( 1 ) )\n\t\tputs( \"Alice\" );\n\telse\n\t\tputs( \"Bob\" );\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\n  typedef long long ll;\n  typedef pair<int,int> PII;\n  typedef pair<char,char> PCC;\n  typedef pair<ll,ll> PLL;\n  typedef pair<char,int> PCI;\n  typedef pair<int,char> PIC;\n  typedef pair<ll,int> PLI;\n  typedef pair<int,ll> PIL; \n  typedef pair<ll,char> PLC; \n  typedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\nconst int VMAX =1e5+10;\nvector<vector<int> >G(VMAX);\n\nint dfs(int v, int p){\n  if(p!=-1){\n    if(G[v].size()==1) return 1;\n    if(G[v].size()==2) return 0;\n  }\n  if(p==-1&&G[v].size()==1)return 0;\n  int count = 0;\n  for(const int & u : G[v]){\n    if(u == p)continue;\n    count += dfs(u,v);\n  }\n  return (count+1)&1;\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  int V;cin >> V;\n  rep(i,V-1){\n    int x,y;cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  int d = dfs(1,-1);\n  if(d==0)cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long ksm(long long u,long long v){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nint n,i,j,f[200005],x,y;\nint top,nex[400005],to[400005],fir[200005];\nvoid lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\nvoid ss(int u,int v){\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(to[top1]!=u){\n\t\t\tss(v,to[top1]);\n\t\t\tf[v]^=(f[to[top1]]+1);\n\t\t}\n}\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n   \tn=read();\n   \tfor(i=1;i<n;i++){\n   \t\tx=read();y=read();\n   \t\tlj(x,y);\n   \t\tlj(y,x);\n   \t}\n   \tss(1,1);\n   \tif(f[1]!=0)\n   \t\tprintf(\"Alice\\n\");\n\telse\n\t\tprintf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nvector<int>adj[100005];\nll dfs(ll x,ll p=-1){\n\tll xo=0;\n\tfor(auto it:adj[x]){\n\t\tif(it!=p){\n\t\t\txo^=dfs(it,x);\n\t\t}\n\t}\n\treturn 1+xo;\n}\nint main(){\n\tll n;\n\tcin>>n;\n\tfor(ll i=1;i<n;i++){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tll ans=dfs(1);\n\tans--;\n\t//cout<<ans<<endl;\n\tif(ans==0)cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define maxn 100005\nint n;\nstruct node { int v; node *nxt; } edge[maxn*2],*head[maxn],*ncnt;\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[u];\n\thead[u]=ncnt;\n}\nint dfs(int u,int fa)\n{\n\tint res=0;\n\tfor(node *p=head[u];p;p=p->nxt)\n\t{\n\t\tint v=p->v;\n\t\tif(v!=fa) res^=dfs(v,u)+1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tncnt=&edge[0];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tprintf(\"%s\\n\",dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define error(args...) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\nstruct hackenbush {\n  int n;\n  vector<vector<int>> adj;\n\n  hackenbush(int n) : n(n), adj(n) { }\n  void add_edge(int u, int v) {\n    adj[u].push_back(v);\n    if (u != v) adj[v].push_back(u);\n  }\n\n  // r is the only root connecting to the ground\n  int grundy(int r) {\n    vector<int> num(n), low(n);\n    int t = 0;\n    function<int(int,int)> dfs = [&](int p, int u) { \n      num[u] = low[u] = ++t;\n      int ans = 0;\n      for (int v: adj[u]) {\n        if (v == p) { p += 2*n; continue; } \n        if (num[v] == 0) {\n          int res = dfs(u, v);\n          low[u] = min(low[u], low[v]);\n          if (low[v] > num[u]) ans ^= (1 + res) ^ 1; // bridge\n          else                 ans ^= res;           // non bridge\n        } else low[u] = min(low[u], num[v]);\n      }\n      if (p > n) p -= 2*n;\n      for (int v: adj[u]) \n        if (v != p && num[u] <= num[v]) ans ^= 1;\n      return ans;\n    };\n    return dfs(-1, r);\n  }\n};\n\nint main(){\n    iostream_init();\n\n    int n;\n    cin >> n;\n    int ans = 0;\n    hackenbush g(n);\n    for (int i = 0; i < n-1; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      --u; --v;\n      g.add_edge(u, v);\n    }\n    cout << (g.grundy(0) ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nvector<vec>G(N);\nint dfs(int x,int p){\n  int g=0;\n  for(auto e:G[x]){\n    if(e!=p){\n    g^=(dfs(e,x)+1);}\n  }\n}\nmain(){\n    int n=in();\n  rep(i,n-1){\n  int a=in(),b=in();\n  G[a].pb(b);\n  G[b].pb(a);}\n  cout<<(dfs(1)?“Alice”:“Bob”);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \")\n{ if (!v.size()) puts(\"\"); rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nint n;\nvector<vi> G;\nbool used[101010] = {true};\n\nbool f(int v = 0) {\n\n  bool ret = false;\n  int cnt = 0;\n\n  for (int i = 0; i < G[v].size(); ++i) {\n    if (used[G[v][i]]) continue;\n    used[G[v][i]] = true;\n    cnt++;\n    if (!f(G[v][i])) ret = !ret;\n  }\n\n  if (cnt == 1) return true;\n\n  return ret;\n}\n\nsigned main() {\n  cin >> n;\n\n  G.resize(n);\n\n  rep(i, n - 1) {\n    int a = in() - 1, b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  cout << (f() ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 200020\nusing namespace std;\nnamespace IO{\n\tconst int BS=(1<<20); int Top=0;\n\tchar Buffer[BS],OT[BS],*OS=OT,*HD,*TL,SS[20]; const char *fin=OT+BS-1;\n\tchar Getchar(){if(HD==TL){TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);} return (HD==TL)?EOF:*HD++;}\n\tvoid flush(){fwrite(OT,1,OS-OT,stdout);}\n\tvoid Putchar(char c){*OS++ =c;if(OS==fin)flush(),OS=OT;}\n\tvoid write(int x){\n\t\tif(!x){Putchar('0');return;} if(x<0) x=-x,Putchar('-');\n\t\twhile(x) SS[++Top]=x%10,x/=10;\n\t\twhile(Top) Putchar(SS[Top]+'0'),--Top;\n\t}\n\tint read(){\n\t\tint nm=0,fh=1; char cw=Getchar();\n\t\tfor(;!isdigit(cw);cw=Getchar()) if(cw=='-') fh=-fh;\n\t\tfor(;isdigit(cw);cw=Getchar()) nm=nm*10+(cw-'0');\n\t\treturn nm*fh;\n\t}\n}\nusing namespace IO;\nint n,fs[M],nt[M],to[M],tmp;\nvoid link(int x,int y){nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;}\nint DP(int x,int last){\n\tint sg=0;\n\tfor(int i=fs[x];i!=-1;i=nt[i]) if(to[i]!=last) sg^=(DP(to[i],x)+1);\n\treturn sg;\n}\nint main(){\n\tn=read(),memset(fs,-1,sizeof(fs));\n\tfor(int i=1;i<n;i++){int x=read(),y=read();link(x,y),link(y,x);}\n\tputs(DP(1,0)?\"Alice\":\"Bob\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\nconst int maxn=100010;\nint nd[maxn<<1],nex[maxn<<1],lnk[maxn],e,n,sg[maxn];\nvoid add(int u,int v){\n\tnd[++e]=v;nex[e]=lnk[u];lnk[u]=e;\n}\nvoid dfs(int u,int fa){\n\tsg[u]=0;\n\tfor (int i=lnk[u]; i;i=nex[i]){\n\t\tif (nd[i]==fa) continue;\n\t\tdfs(nd[i],u);\n\t\tsg[u]^=sg[nd[i]]+1;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1,u,v; i<n; i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXM=MAXN-1;\n\nint n;\nint ghead[MAXN],gnxt[2*MAXM],gto[2*MAXM];\n\nint dfs(int at,int par) {\n\tint ret=0;\n\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) {\n\t\tint to=gto[x]; if(to==par) continue;\n\t\tret^=1+dfs(to,at);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) ghead[i]=-1;\n\tREP(i,n-1) {\n\t\tint a,b; scanf(\"%d%d\",&a,&b); --a,--b;\n\t\tgnxt[2*i+0]=ghead[a],ghead[a]=2*i+0,gto[2*i+0]=b;\n\t\tgnxt[2*i+1]=ghead[b],ghead[b]=2*i+1,gto[2*i+1]=a;\n\t}\n\n\tint res=dfs(0,-1);\n\tprintf(\"%s\\n\",res!=0?\"Alice\":\"Bob\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint n;\nvector<int> G[MAXN];\nint sg[MAXN];\nvoid dfs(int v,int p)\n{\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        dfs(to,v);\n        sg[v]^=(sg[to]+1);\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);G[v].push_back(u);\n    }\n    dfs(1,0);\n    if(sg[1]) puts(\"Alice\"); else puts(\"Bob\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nvector<int> graph[100010];\n\nvoid add_edge(int a,int b){\n\tgraph[a].push_back(b);\n\tgraph[b].push_back(a);\n}\n\nint dfs(int v,int p){\n\tint grundy = 0;\n\n\tfor(auto &v2:graph[v]){\n\t\tif(v2==p) continue;\n\t\tgrundy^=(dfs(v2,v)+1);\n\t}\n\t\n\treturn grundy;\t\n}\t\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n-1){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadd_edge(x-1,y-1);\n\t}\n\n\n\tif(dfs(0,-1)!=0)\n\t\tputs(\"Alice\");\n\telse\n\t\tputs(\"Bob\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std; \nint n,c,x,y,z;\nint main() {\n\tcin>>n;\n\tfor(c=1;c<n;c++)\n\tcin>>x>>y,z+=x==1,z+=y==1;\n\tputs((z+n&1)?\"Bob\":\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 200010;\nint f[N];\nstruct node {\n\tint to, nxt;\n} g[N];\nint lst[N], gl;\nvoid add(int x, int y) { g[++gl] = (node) {y, lst[x]}; lst[x] = gl; }\nvoid dfs(int u, int ff) {\n\tint c1 = 0, c2 = 0;\n\tfor (int i = lst[u]; i; i = g[i].nxt) {\n\t\tint v = g[i].to; if (v == ff) continue;\n\t\tdfs(v, u);\n\t\tif (f[v]) c1++;\n\t\telse c2++;\n\t}\n\tif (!c1) f[u] = c2 & 1;\n\telse f[u] = c1 & 1;\n\t//printf(\"[%d] %d\\n\", u, f[u]);\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = gi<int>(), y = gi<int>();\n\t\tadd(x, y); add(y, x);\n\t}\n\tdfs(1, 0);\n\tputs(f[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nvector<int> edge[100010], child[100010];\nvoid dfs(int i, int p){\n  for(auto e: edge[i]){\n    if(e == p)continue;\n    child[i].pb(e);\n    dfs(e, i);\n  }\n}\n\nint G[100010];\nvoid calc(int i){\n  for(auto e: child[i])calc(e);\n  for(auto e: child[i]){\n    G[i] ^= G[e];\n  }\n  G[i]++;\n}\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  rep(i, n - 1){\n    int x, y; cin >> x >> y, x--, y--;\n    edge[x].pb(y);\n    edge[y].pb(x);\n  }\n  dfs(0, -1);\n  int res = 0;\n  for(auto e: child[0]){\n    calc(e);\n    res ^= G[e];\n  }\n  if(res == 0)cout << \"Bob\" << endl;\n  else cout << \"Alice\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 500005\n\nvector<int> e[N];\nint dfs(int u,int v){\n\tint r=0;\n\tfor(auto x:e[v]){\n\t\tif(x!=u)r=r^(1+dfs(v,x));\n\t}\n\treturn r;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor (int i = 0; i < n-1; i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tif(dfs(0,1))cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, x, y, g[100005];\nvector<int> v[100005];\n\nvoid sgd(int dg, int op) {\n\tfor(int i = 0; i < v[dg].size(); ++i) {\n\t\tif(v[dg][i] != op) {\n\t\t\tsgd(v[dg][i], dg);\n\t\t\tg[dg] ^= g[v[dg][i]] + 1;\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i < n; ++i) {\n\t\tcin >> x >> y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tsgd(1, 0);\n\tif(g[1]) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define next nxt\n \nint n,x[N],y[N],next[N],p[N],f[N];\n \nint travel(int x){\n\tint ans=0;\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (y[t]!=f[x])\n\t\tf[y[t]]=x,ans^=travel(y[t])+1;\n\treturn ans;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();\n\tfor (int i=1;i<=n-1;i++){\n\t\tx[2*i-1]=y[2*i]=read();\n\t\ty[2*i-1]=x[2*i]=read();\n\t\tnext[2*i-1]=p[x[2*i-1]];p[x[2*i-1]]=2*i-1;\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t}\n\tprintf(travel(1)?\"Alice\\n\":\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  Bismillahir Rahmanir Rahim  */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\n\nint n;\nvector <int> g[N];\n\nint hack(int at, int par){\n\tint child = 0;\n\tvector <int> son;\n\tfor(auto u : g[at]){\n\t\tif(u == par) continue;\n\t\t++child;\n\t\tson.push_back(hack(u, at));\n\t}\n\tint ret;\n\tif(son.size() == 0) ret = 1;\n\tif(son.size() == 1) ret = son[0] + 1;\n\telse{\n\t\tint X = 0;\n\t\tfor(auto u : son) X ^= u;\n\t\tret = X + 1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x, y;\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; ++i){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint X = hack(1, 0) - 1;\n\tif(X) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int> g[101010];\n\nint dfs(int v, int prev) {\n        vector<int> grundy;\n        for (auto u : g[v]) if (u != prev) {\n                grundy.push_back(dfs(u, v));\n        }\n        if (grundy.size() == 0) {\n                return 0;\n        }\n        if (grundy.size() == 1) {\n                return grundy[0] + 1;\n        }\n        int res = 0;\n        for (int i = 0; i < grundy.size(); i ++) res ^= grundy[i];\n        return res;\n}\n\nint main() {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        cout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//21:16-23:16\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n;\nvector<int>edge[1000005];\nint dfs(int v,int u){\n    vector<int>vec;\n    set<int>S; int X = 0;\n    for(int i=0;i<edge[v].size();i++){\n        if(edge[v][i] == u) continue;\n        int Y = dfs(edge[v][i],v);\n        vec.pb(Y); X^=Y; \n    }\n    for(int i=0;i<vec.size();i++){\n        for(int j=0;j<max(1,vec[i]);j++){\n            S.insert(X^vec[i]^j);\n        }\n    }\n    for(int x=0;;x++){\n        if(S.find(x) == S.end()){\n            //cout << v << \" \" << x << endl;\n            return x;\n        }\n    }\n}\nint main(){\n    cin >> n ;\n    for(int i=1;i<n;i++){\n        int a,b; cin >> a >> b;\n        edge[a].pb(b); edge[b].pb(a);\n    }\n    if(dfs(1,-1)) puts(\"Alice\"); else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\nint n;\nvector<int> graph[500000];\nint x[500000];\nint dfs(int v)\n{\n\tx[v] = 1;\n\tint c = 0, f = 0;\n\tfor (auto u : graph[v])\n\t{\n\t\tif (x[u] == 0)\n\t\t{\n\t\t\tf ^= (dfs(u) + 1);\n\t\t\tc++;\n\t\t}\n\t}\n\treturn f;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i + 1 < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tgraph[v].push_back(u);\n\t\tgraph[u].push_back(v);\n\t}\n\tif (dfs(1)) cout << \"Alice\";\n\telse cout << \"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nint n, sg[100010];\nvector<int> g[100010];\ninline int rd(){\n\tint a=0; char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)) (a*=10)+=c-'0', c=getchar();\n\treturn a;\n}\nvoid dfs(int p, int f){\n\tfor(auto t: g[p]){\n\t\tif(t==f) continue;\n\t\tdfs(t, p); sg[p]^=sg[t]+1;\n\t}\n}\nint main(){\n\tn=rd();\n\tint u, v;\n\tfor(int i=1;i<n;i++){\n\t\tu=rd(), v=rd();\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tif(!sg[1]) puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid dfs(int v,vector<vector<int>> &edge,vector<int> &grundy,vector<int> &used){\n    used[v]=true;\n    for(int i=0;i<edge[v].size();i++){\n        int to=edge[v][i];\n        if(used[to]){\n            continue;\n        }\n        grundy[to]=grundy[v]+1;\n        dfs(to,edge,grundy,used);\n    }\n    return;\n}\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> edge(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    vector<int> used(n);\n    vector<int> grundy(n);\n    grundy[0]=1;\n    vector<int> gs;\n    dfs(0,edge,grundy,used);\n    \n    for(int i=0;i<edge.size();i++){\n        for(int j=0;j<edge[i].size();j++){\n            if(i<edge[i][j]) continue;\n            gs.push_back(min(grundy[i],grundy[edge[i][j]]));\n        }\n    }\n    \n    int res=0;\n\n    for(int i=0;i<gs.size();i++){\n        res^=gs[i];\n\n    }\n    cout<<(res?\"Alice\" :\"Bob\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/indexed.hpp>\n\nusing namespace std;\nusing namespace boost::adaptors;\nusing namespace std::string_literals;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing boost::irange;\n\nint grundy(const vector<vecint>& g, int i, int p) {\n  int x = 0;\n  for (int c: g[i]) {\n    if (c == p) continue;\n    x ^= grundy(g, c, i) + 1;\n  }\n  return x;\n}\n\nint main()\n{\n  int n;\n  cin>>n;\n  vector<vecint> g(n);\n  for(int i:irange(0,n-1)) {\n    int x,y;\n    cin>>x>>y;\n    --x;--y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int m = grundy(g, 0, -1);\n  if (m == 0) {\n    cout << \"Bob\" << endl;\n  } else {\n    cout << \"Alice\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int MAXN = 100100;\n\nstruct Par\n{\n\tint a;\n\tint b;\n};\n\nint n;\nint x, y;\nPar par[MAXN];\nint index = 0;\n\nbool fun(int a, int b)\n{\n\tfor (int i = 0; i < index; ++i)\n\t\tif (par[i].a == a && par[i].b == b)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tcin >> n;\n\tint a, b;\n\tx = y = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tif (a > b)\n\t\t{\n\t\t\tint tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\tif (!fun(a, b))\n\t\t{\n\t\t\tpar[index].a = a;\n\t\t\tpar[index].b = b;\n\t\t\tindex++;\n\t\t\tif (a == 1)\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}\n\t}\n\tif (x == 1)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t{\n\t\tint xx = x % 2;\n\t\tint yy = y % 2;\n\t\tif (xx + yy == 1)\n\t\t\tcout << \"Alice\" << endl;\n\t\telse\n\t\t\tcout << \"Bob\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define error(args...) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\nstruct hackenbush {\n  int n;\n  vector<vector<int>> adj;\n\n  hackenbush(int n) : n(n), adj(n) { }\n  void add_edge(int u, int v) {\n    adj[u].push_back(v);\n    if (u != v) adj[v].push_back(u);\n  }\n\n  // r is the only root connecting to the ground\n  int grundy(int r) {\n    vector<int> num(n), low(n);\n    int t = 0;\n    function<int(int,int)> dfs = [&](int p, int u) { \n      num[u] = low[u] = ++t;\n      int ans = 0;\n      for (int v: adj[u]) {\n        if (v == p) { p += 2*n; continue; } \n        if (num[v] == 0) {\n          int res = dfs(u, v);\n          low[u] = min(low[u], low[v]);\n          if (low[v] > num[u]) ans ^= (1 + res) ^ 1; // bridge\n          else                 ans ^= res;           // non bridge\n        } else low[u] = min(low[u], num[v]);\n      }\n      if (p > n) p -= 2*n;\n      for (int v: adj[u]) \n        if (v != p && num[u] <= num[v]) ans ^= 1;\n      return ans;\n    };\n    return dfs(-1, r);\n  }\n};\n\nint main(){\n    iostream_init();\n\n    int n;\n    cin >> n;\n    int ans = 0;\n    hackenbush g(n);\n    for (int i = 0; i < n-1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      g.add_edge(u, v);\n    }\n    cout << (g.grundy(0) ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define db double\n#define ll long long\n#define down(i,j,n) for(register int i=j;i>=n;i--)\n#define up(i,j,n) for(register int i=j;i<=n;i++)\n#define pb push_back\n#define se second\n#define fi first\n#define pa pair<int,int>\n#define mp make_pair\n#define FILE \"dealing\"\ntemplate<class T> bool cmax(T& a,T b){return a<b?a=b,true:false;}\ntemplate<class T> bool cmin(T& a,T b){return a>b?a=b,true:false;}\ntemplate<class T> T squ(T a){return a*a;}\nint read(){\n\tint x=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn f*x;\n}\nconst int maxn=200010,inf=100000000,mod=1e9+7;\nint mul(int a,int b){return 1LL*a*b%mod;}\nint sub(int a,int b){return (a-=b)<0  ?a+mod:a;}\n\nint p,n,A,B,C,D;\nstruct node{\n\tint y,next;\n}e[maxn];int len,linkk[maxn];\nvoid insert(int x,int y){e[++len].y=y;e[len].next=linkk[x];linkk[x]=len;}\nint dep[maxn],val[maxn],siz[maxn];\n\nvoid dfs(int x,int fa){\n\tval[dep[x]]++;\n\tint child=0;\n\tfor(int i=linkk[x];i;i=e[i].next){\n\t\tint y=e[i].y;if(y==fa)continue;\n\t\tdep[y]=dep[x]+1;child++;\n\t\tdfs(y,x);\n\t}\n}\nint main(){\n//\tfreopen(FILE\".in\",\"r\",stdin);freopen(FILE\".out\",\"w\",stdout);\n\tn=read();\n\tup(i,2,n){\n\t\tint x=read(),y=read();\n\t\tinsert(x,y);insert(y,x);\n\t}\n\tdfs(1,0);\n\tup(i,1,n)if(val[i]&1){\n\t\tprintf(\"Alice\\n\");\n\t\treturn 0;\n\t}cout<<\"Bob\"<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint win[101010];\n\n\nint dfs(int cur,int pre) {\n\t\n\twin[cur]=0;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\twin[cur]^=1^dfs(e,cur);\n\t}\n\treturn win[cur];\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tif(dfs(0,0)) cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\t\t\t\t//Written by ThiDaiLoc\nusing namespace std;\t\t\t\t//Team Three Wolves\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pll;\n#define fu(i,a,b)   for(ll i=a;i<b;i++)\n#define fd(i,b,a)   for(ll i=b;i>=a;i--)\n#define ms(a,x)     memset(a, x, sizeof a)\n#define prec(n)     fixed<<setprecision(n)\n#define pb(i)       push_back(i)\n#define popb()      pop_back()\n#define sc(a)       cin>>a\n#define sc2(a,b)    cin>>a>>b\n#define pr(a)       cout<<a<<\" \"\n#define pr2(a,b)    cout<<a<<\" \"<<b<<\" \"\n#define lowb(a,n,x) lower_bound(a,a+n,x) -a\n#define lowb2(a,x)  lower_bound(a.begin(),a.end(),x) -a.begin()\n#define all(x)      (x).begin(), (x).end()\n#define sz(a)       (ll)a.size()\n#define le(s)       (ll)s.length()\t\t\t\t\t\t\n#define re          return \t\n#define\tmp(a,b)     make_pair(a,b)\n#define se          second\n#define fi          first \n#define debug(x)    cerr << #x << \" = \" << x << endl\n#define INPUT       freopen(\"locin.txt\", \"r\", stdin)\n#define OUTPUT      freopen(\"locout.txt\", \"w\", stdout)\nvoid inline minize(ll& a,ll b){a=(a>b?b:a);};\nvoid inline maxize(ll& a,ll b){a=(a<b?b:a);};\ndouble const eps = 1e-6;\nll const Base=1e9+7,oo=1e17,MAXN=1e5;\nll n;\nbitset <MAXN+5> came;\nvi dske[MAXN];\n\nll DFS(ll cur){\n\tll res=0,x,cntchild=0;\n\tcame[cur]=1;\n\t\n\tfu(i,0,sz(dske[cur])){\n\t\tx=dske[cur][i];\n\t\tif(came[x])continue;\n\t\tcntchild++;\n\t\tres^=DFS(x);\n\t}\n\tif(cntchild==1)res++;\n\tre res;\n}\n\nll Solves(){\n\t//INPUT;\n\tll x,n,k,cnt=0,ans=0,a,b;\n\tcame.reset();\n\t// PROCESSING IN HERE\n\tsc(n);\n\tfu(i,0,n-1){\n\t\tsc2(a,b);\n\t\tdske[a].pb(b);\n\t\tdske[b].pb(a);\n\t\t\n\t}\n\t\n\tif(DFS(1))pr(\"Alice\");\n\telse pr(\"Bob\");\n\t\n\tre 0;\n\t// Hack it if you can :)\n}\nint main(){\n\t\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tSolves();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\nint gr[100010];\n\nint dfs(int v, int p)\n{\n\tfor (int to : g[v]) if (to != p) {\n\t\tgr[v] ^= (dfs(to, v) + 1);\n\t}\n\treturn gr[v];\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tputs(dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\nint dp[MAX];\n\ninline int dfs(int b,int pr=-1){\n\tdp[b] = 1;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tif (go == pr)continue;\n\t\tdfs(go,b);\n\t\tdp[b] += dp[go];\n\t}\n\treturn dp[b];\n}\n\nint main(){\n\tcin >> n;\n\tint non = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif (v[0].size() == 1){\n\t\tputs(\"Alice\");\n\t\treturn 0;\n\t}\n\tdfs(0);\n\tint del = v[0].size() - 2;\n\tbool want1 = false;\n\tbool want2 = false;\n\tif (del & 1){\n\t\twant2 = true;\n\t}\n\telse{\n\t\twant1 = true;\n\t}\n\tint c[] = { 0, 0 };\n\tfor (int i = 0; i < v[0].size(); i++){\n\t\tint go = v[0][i];\n\t\tc[dp[go] & 1]++;\n\t}\n\tif (want2&&(c[1] <= (del + 1) / 2||c[0]<=(del+1)/2)){\n\t\tputs(\"Alice\");\n\t}\n\telse{\n\t\tif (want2){\n\t\t\tputs(\"Bob\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (want1 && (c[1] <= (del) / 2 || c[0] <= (del) / 2)){\n\t\t\tputs(\"Bob\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"Alice\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge{int s,t,n;}e[200010];\nint n,h[100010];\n\nint dfs(int x,int f)\n{\n\tint s=0;\n\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif (y!=f)  s^=dfs(y,x)+1;\n\treturn s;\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x,y,tot=0; i<n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\te[++tot]=(edge){x,y,h[x]},h[x]=tot;\n\t\t\te[++tot]=(edge){y,x,h[y]},h[y]=tot;\n\t\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\ntypedef vector<int> vertex;\ntypedef vector<vertex> graph;\n\n#define N 112345\nint n;\ngraph g;\nbool used[N];\n\nint dfs(int x){\n\tused[x] = true;\n\tint r = 0;\n\tfor(int y: g[x]){\n\t\tif(used[y]) continue;\n\t\tr ^= dfs(y);\n\t}\n\treturn r+1;\n}\n\nint main(){\n\tcin>>n;\n\tg = graph(n);\n\trep(i, n-1){\n\t\tint x, y;\n\t\tcin>>x>>y; x--; y--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tcout<<(dfs(0)-1?\"Alice\":\"Bob\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        int odd = 0;\n        FORE(e, graph[0]) odd += (dfs(e, 0) + 1) % 2;\n        if (odd == 0) {\nassert(false);\n        } else if (odd == 3) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 1) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 2) {\n            cout << \"Alice\" << endl;\n        } else {\n            assert(false);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nvector<vector<int>> G;\n\nint grundy(int v, int pre)\n{\n    int g = 0;\n    for (auto u : G[v]) {\n        if (u == pre) continue;\n        g ^= (grundy(u, v) + 1);\n    }\n    return g;\n}\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    G.resize(N);\n    rep(i, N-1) {\n        int X, Y;\n        cin >> X >> Y;\n        X--, Y--;\n        G[X].push_back(Y);\n        G[Y].push_back(X);\n    }\n    cout << (grundy(0, -1) != 0 ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#define FOR(i,x,y) for(int (i)=(x); (i)<(y);(i++))\n#define INT long long\n#define MOD 1000000007\n#define oo 978654321\n#define OO 9999999987654321ll\nusing namespace std;\n\nINT n, g[100010];\nvector<INT> G[100010];\n\nint dfs(int v, int p)\n{\n    int ret = 0;\n    for(int w : G[v])\n        if( p != w )\n            ret ^= dfs(w, v) + 1;\n    return ret;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i = 0, a, b ; i < n-1 ; i++ )\n        cin>>a>>b, G[a].push_back(b), G[b].push_back(a);\n    cout<<(dfs(1, 1)?\"Alice\":\"Bob\")<<endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pie;\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst ll LINF = 4e18;\nconst ll delta = 1634569;\n\nconst int N = 1e5 + 20;\nvector<int> G[N];\nint n, g[N];\n\nvoid dfs(int v, int p = -1) {\n\tfor (int u : G[v])\n\t\tif (u - p)\n\t\t\tdfs(u, v);\t\n\tfor (int u : G[v])\n\t\tif (u - p)\n\t\t\tg[v] = g[v] ^ (g[u] + 1);\n}\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0, v, u; i < n - 1; i++) {\n\t\tcin >> v >> u;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tdfs(1);\n\tcout << (g[1] ? \"Alice\" : \"Bob\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef vector<int> V;\ntypedef vector<V> VV;\nint main(){\n    int N;\n    cin>>N;\n    VV g(N);\n    REP(i,N-1){\n        int a,b;cin>>a>>b;a--,b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    REC(int,int,int) dfs=[&](int v,int p){\n        int ret=0;\n        for(auto &u:g[v])if(u!=p)\n                             ret^=dfs(u,v)+1;\n        return ret;\n    };\n    if(dfs(0,0))cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define sz(V) ((int)(V).size())\nusing namespace std;\ntypedef long long ll;\nvoid fg(vector<int> G[], int a, int b) { G[a].pb(b); G[b].pb(a); }\n\nconst int MAXN = 100005;\n\nvector<int> G[MAXN];\n\nint dep[MAXN], cnt[MAXN];\n\nint N;\n\nvoid f(int i, int d) {\n\tdep[i] = d;\n\tint c = 0, x = 0;\n\tfor(int v : G[i]) {\n\t\tif(dep[v]) continue;\n\t\tf(v, d+1);\n\t\tc++;\n\t\tx ^= cnt[v];\n\t}\n\tcnt[i] = x + 1;\n}\n\nint main() {\n\tcin >> N;\n\tfor(int i = 1, a, b; i < N; i++) {\n\t\tcin >> a >> b;\n\t\tfg(G, a, b);\n\t}\n\tf(1, 1);\n\tputs(1 == cnt[1] ? \"Bob\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define int long long\n#define P pair<int,int>\n#define all(vec) vec.begin(),vec.end()\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nint kai(int x, int y, int m) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y, int m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nint n;\nvector<int> vec[100010];\nint d[100010];\n\nvoid dfs(int v, int p) {\n\tif ((v == 1 && (int)vec[v].size() == 1) || (1 < v && (int)vec[v].size() == 2)) {\n\t\tfor (int i = 0; i < (int)vec[v].size(); i++) {\n\t\t\tif (vec[v][i] == p)continue;\n\t\t\tdfs(vec[v][i], v);\n\t\t\td[v] = d[vec[v][i]] + 1;\n\t\t}\n\t}\n\telse {\n\t\tint k = 0;\n\t\tfor (int i = 0; i < (int)vec[v].size(); i++) {\n\t\t\tif (vec[v][i] == p)continue;\n\t\t\tdfs(vec[v][i], v);\n\t\t\tk ^= d[vec[v][i]] + 1;\n\t\t}\n\t\td[v] = k;\n\t}\n}\n\nsigned main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tif (d[1])cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N + 1);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N + 1, MOD);\n\tvector<int>parent(N + 1);\n\tdis[1] = 0;\n\tqueue<int>Q;\n\tQ.push(1);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (dis[i] > dis[cn] + 1) {\n\t\t\t\tdis[i] = dis[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t\tparent[i] = cn;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>used(N + 1);\n\tvector<int>nim(N + 1);\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (edge[i].size() == 1)Q.push(i);\n\t}\n\tedge[1].clear();\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tif (cn == 1)continue;\n\t\tint node = cn;\n\t\tint nx;\n\t\twhile (1) {\n\t\t\tnx = parent[node];\n\t\t\tused[node]++;\n\t\t\tused[nx]++;\n\t\t\tnode = nx;\n\t\t\tif (edge[nx].size() != 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnim[node] ^= (dis[cn] - dis[node]);\n\t\tnim[node] ^= nim[cn];\n\t\tif (edge[node].size() - used[node] == 1)Q.push(node);\n\t}\n\tif (!nim[1])cout << \"Bob\\n\";\n\telse cout << \"Alice\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = 0;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= d[h] ^ ((sz(v[h]) - 1) % 2);\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\n\nvector<int> a[MAXN];\nint ans[MAXN];\n\nvoid dfs(int v, int par){\n\tint cnt1 = 0, cnt2 = 0;\n\tfor(auto u : a[v]){\n\t\tif(u == par) continue;\n\t\tdfs(u, v);\n\t\tif(ans[u] == 1) cnt1 ++;\n\t\telse cnt2 ++;\n\t}\n\tif(cnt2 % 2 == 0 and cnt1 % 2 == 0) ans[v] = 2;\n\telse ans[v] = 1;\n\treturn;\n}\n\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint x, y; cin >> x >> y;\n\t\ta[x].pb(y);\n\t\ta[y].pb(x);\n\t}\n\tdfs(1, 0);\n\tif(ans[1] == 1) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100010\nusing namespace std;\nint u,v,n,m,d[maxn];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n-1;i++){\n\t\tcin>>u>>v;\n\t\tif(u>v) swap(u,v);\n\t\td[u]++;\n\t}\n\tint ans=d[1];\n\tfor(int i=2;i<=n;i++){\n\t\tans^=d[i];\n\t}\n\tif(ans==1){\n\t\tcout<<\"Alice\";\n\t}\n\telse \n\t\tcout<<\"Bob\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint mex[101010];\n\n\nvoid dfs(int cur,int pre,int dep) {\n\tset<int> S;\n\tmex[cur]=1;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,dep+1);\n\t\tS.insert(mex[e]);\n\t}\n\t\n\twhile(S.count(mex[cur])) mex[cur]++;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tdfs(0,0,0);\n\t\n\tint nim=0;\n\tFORR(e,E[0]) nim ^= mex[e];\n\t\n\tif(nim) _P(\"Alice\\n\");\n\telse _P(\"Bob\\n\");\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nCerberus97\nHanit Banga\n*/\n\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 5;\n\nvector <int> g[N];\nbool seen[N];\n\nint dfs(int cur);\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\tif (dfs(1))\n\t\tcout << \"Alice\\n\";\n\telse\n\t\tcout << \"Bob\\n\";\n}\n\nint dfs(int cur)\n{\n\tseen[cur] = true;\n\tint ans = 0;\n\tfor (auto &i : g[cur])\n\t\tif (!seen[i])\n\t\t\tans ^= (1 + dfs(i));\n\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI g[100010];\nbool used[100010];\nint dfs(int num) {\n  // cout << num << endl;\n  used[num] = true;\n  bool update = false;\n  int res = 0;\n  for(int i: g[num]) {\n    if(used[i]) continue;\n    update = true;\n    res ^= dfs(i)+1;\n  }\n  // 葉\n  if(!update) return 0;\n  return res;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(j, n) g[j].clear();\n  memset(used, false, sizeof(used));\n  REP(j, n-1) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  // cout << dfs(0) << endl;\n  if(dfs(0)) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 9;\nconst int MAXN = 100005;\n\nint n;\nvector<int> gph[MAXN];\n\nint f(int x, int p){\n\tint has_son = 0;\n\tint ret = 0;\n\tfor(auto &i : gph[x]){\n\t\tif(i == p) continue;\n\t\thas_son++;\n\t\tint v = f(i, x);\n\t\tret ^= v;\n\t}\n\tif(has_son == 0) return 0;\n\tif(has_son == 1) return 1;\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tgph[x].push_back(y);\n\t\tgph[y].push_back(x);\n\t}\n\tcout << (f(1, 0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n\tint N;\n\tcin>>N;\n\tint i;\n\tint v1, v2;\n\tint num1=0;\n\tint num2;\n\tfor (i=0;i<N-1;i++){\n\t\tcin>>v1>>v2;\n\t\tif (v1==1){\n\t\t\tnum1++;\n\t\t}else if (v2==1){\n\t\t\tnum1++;\n\t\t}\n\t}\n\tnum2=N-1-num1;\n\tif (num1==1){\n\t\tcout<<\"Alice\"<<endl;\n\t}else if (num1==2){\n\t\tif (num2%2==0){\n\t\t\tcout<<\"Bob\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Alice\"<<endl;\n\t\t}\n\t}else{\n\t\tif (num2>num1){\n\t\t\twhile (num1>2){\n\t\t\t\tnum1--;\n\t\t\t\tnum2--;\n\t\t\t}\n\t\t\tif (num2%2==0){\n\t\t\t\tcout<<\"Bob\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"Alice\"<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\t//num1>num2;\n\t\t\twhile (num1>2){\n\t\t\t\tnum1--;\n\t\t\t\tnum2--;\n\t\t\t\tif (num2==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num1%2==0){\n\t\t\t\tcout<<\"Bob\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"Alice\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <boost/range/adaptors.hpp>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::adaptors;\n\nint64_t grundy(const vector<vector<int64_t>>& adjs, int64_t v, int64_t p) {\n    int64_t g = 0;\n\n    for (auto u : adjs[v]) {\n        if (u == p) {\n            continue;\n        }\n\n        auto t = grundy(adjs, u, v);\n\n        g ^= t + 1;\n    }\n\n    return g;\n}\n\nint main() {\n    int64_t n;\n    cin >> n;\n\n    vector<vector<int64_t>> adjs(n);\n    for (auto _ : irange(0L, n - 1)) {\n        int64_t x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        adjs[x].push_back(y);\n        adjs[y].push_back(x);\n    }\n\n    auto g = grundy(adjs, 0, -1);\n\n    if (g != 0) {\n        cout << \"Alice\" << endl;\n    } else {\n        cout << \"Bob\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 100005;\n\nstruct Edge\n{\n\tint to, nxt;\n} e[maxn << 1];\n\nint first[maxn];\n\ninline void add_edge(int from, int to)\n{\n\tstatic int cnt = 0;\n\te[++cnt].nxt = first[from];\n\tfirst[from] = cnt;\n\te[cnt].to = to;\n\te[++cnt].nxt = first[to];\n\tfirst[to] = cnt;\n\te[cnt].to = from;\n}\n\nint sg[maxn];\nint n;\n\ninline void dfs(int now, int fa)\n{\n\tfor (int i = first[now]; i; i = e[i].nxt)\n\t{\n\t\tregister int to = e[i].to;\n\t\tif (to != fa)\n\t\t{\n\t\t\tdfs(to, now);\n\t\t\tsg[now] ^= sg[e[i].to];\n\t\t}\n\t}\n\tif(now != 1)\n\t\tsg[now]++;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, f, t; i < n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &f, &t);\n\t\tadd_edge(f, t);\n\t}\n\tdfs(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxn=100000+16;\n\nint n;\nvector<int> g[maxn];\n\nint solve(int p,int father)\n{\n\tint sg=0;\n\tfor (int x:g[p]) if (x!=father) sg^=(solve(x,p)+1);\n\treturn sg;\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\twhile (cin>>n)\n\t{\n\t\tREP(i,n) g[i].clear();\n\t\tREP(i,n-1)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tg[x].push_back(y);\n\t\t\tg[y].push_back(x);\n\t\t}\n\t\tif (solve(0,-1))\n\t\t\tprintf(\"Alice\\n\");\n\t\telse\n\t\t\tprintf(\"Bob\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n \nint N;\nvector<int> E[101010];\n//---------------------------------------------------------------------------------------------------\nint dfs(int cu, int pa = -1) {\n    int g = 0;\n    for (int to : E[cu]) if (to != pa) g ^= dfs(to, cu);\n    return g + 1;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n\n    rep(i, 0, N - 1) {\n        int a, b; cin >> a >> b;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    int g = dfs(1) - 1;\n\n    if (g == 0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <queue>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define ll long long\n#define maxn 500400\nusing namespace std;\ninline void read(int &x){\n    char ch;\n    bool flag=false;\n    for (ch=getchar();!isdigit(ch);ch=getchar())if (ch=='-') flag=true;\n    for (x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());\n    x=flag?-x:x;\n}\n\ninline void write(int x){\n    static const int maxlen=100;\n    static char s[maxlen];\n        if (x<0) {   putchar('-'); x=-x;}\n    if(!x){ putchar('0'); return; }\n    int len=0; for(;x;x/=10) s[len++]=x % 10+'0';\n    for(int i=len-1;i>=0;--i) putchar(s[i]);\n}\nlong long n,l,r,c,d;\n//int a[maxn];\n\n\nint main(){\n    if (n>10)\n        puts(\"Alice\");\n    else\n        puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            res ^= dfs(e, now);\n        }\n    }\n    return res ^ 1;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    else {\n        cout << (dfs(0, -1) == 0 ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nvector<ll> node[100005];\nbool used[100005]={false};\nll grundy(ll pos){\n  ll cnt=0;\n  for(int i=0;i<node[pos].size();i++){\n    ll to=node[pos][i];\n    if(!used[to]) cnt++;\n  }\n  if(cnt==0) return 0;\n  else if(cnt==1){\n    for(int i=0;i<node[pos].size();i++){\n      ll to=node[pos][i];\n      if(!used[to]){\n        used[to]=true;\n        return grundy(to)+1;\n      }\n    }\n  }\n  else{\n    ll res=0;\n    for(int i=0;i<node[pos].size();i++){\n      ll to=node[pos][i];\n      if(!used[to]){\n        used[to]=true;\n        res^=grundy(to);\n      }\n    }\n    return res;\n  }\n}\nint main(){\n  ll n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    ll s,t;\n    cin>>s>>t;\n    node[s].push_back(t);\n    node[t].push_back(s);\n  }\n  for(int i=1;i<=n;i++) used[i]=false;\n  used[1]=true;\n  cout<<(grundy(1)==0?\"Bob\":\"Alice\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<vector>\ninline int getint() {\n\tregister char ch;\n\twhile(!isdigit(ch=getchar()));\n\tregister int x=ch^'0';\n\twhile(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');\n\treturn x;\n}\nconst int N=1e5+1;\nstd::vector<int> e[N];\ninline void add_edge(const int &u,const int &v) {\n\te[u].push_back(v);\n\te[v].push_back(u);\n}\nint dfs(const int &x,const int &par) {\n\tint sg=0;\n\tfor(auto &y:e[x]) {\n\t\tif(y==par) continue;\n\t\tsg^=dfs(y,x)+1;\n\t}\n\treturn sg;\n}\nint main() {\n\tconst int n=getint();\n\tfor(register int i=1;i<n;i++) {\n\t\tadd_edge(getint(),getint());\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cctype>\n#include <cstdlib>      // srand,rand\n#include <random>\n#include <functional>\n\nusing namespace std;\n#define ll long long\n#define lp(i,n) for(ll i=0;i<n;i++)\n\n#define modd 1000000007\n#define mod2 998244353\n\n#define INF 8223372036854775807ll\n#define ALL(a)  (a).begin(),(a).end()\n\n\ntypedef pair<long long, long long> pl;\ntypedef pair<double, double> pd;\ntypedef pair<ll, string> pls;\n\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\n\n/*\nclass SegmentTree {\n\n\n\nprivate:\n\n\tll cont_num = 2;\n\tpd initial_v;\n\tvector<pd> dat;\n\n\npublic:\n\n\n\tSegmentTree() {};\n\n\n\tvoid init(ll size, double initial_value_first, double initial_value_second) {\n\n\t\tcont_num = 2;\n\t\tinitial_v.first = initial_value_first;\n\t\tinitial_v.second = initial_value_second;\n\n\t\twhile (cont_num < size) {\n\t\t\tcont_num *= 2;\n\t\t}\n\n\t\tdat.resize(2 * cont_num);//サイズ設定\n\n\t\tfor (int i = 0; i < 2 * cont_num; i++)dat[i] = initial_v;//初期化\n\n\n\n\t}\n\n\n\tvoid Update(ll position, double value_f, double value_s) {\n\n\n\n\t\tll k = cont_num + position;\n\n\t\tdat[k].first = value_f;\n\t\tdat[k].second = value_s;\n\n\t\twhile (k > 1) {\n\t\t\tk /= 2;\n\t\t\tdat[k].first = dat[k * 2 + 1].first * dat[k * 2].first;\n\t\t\tdat[k].second = dat[k * 2 + 1].first * dat[k * 2].second + dat[k * 2 + 1].second;\n\n\n\t\t}\n\n\n\t}\n\n\t/*\n\tll query_proces(ll a, ll b, ll k, ll l, ll r) {\n\n\t\tif (r <= a || b <= l)return initial_v;\n\n\t\tif (a <= l && r <= b)return dat[k];\n\t\telse {\n\t\t\tll vl = query_proces(a, b, k * 2, l, (l + r) / 2);\n\t\t\tll vr = query_proces(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\n\t}\n\n\n\tll query(ll left, ll right) {\n\t\treturn query_proces(left, right, 1, 0, cont_num);\n\t}\n\t*/\n\t/*\n\t\tdouble query() {\n\t\t\treturn dat[1].first + dat[1].second;\n\t\t}\n\n\t};*/\n\n\ntemplate <typename T>\nclass Zip {\n\tvector<T> d;\n\tbool flag;\n\tvoid init() {\n\t\tsort(d.begin(), d.end());\n\t\td.erase(unique(d.begin(), d.end()), d.end());\n\t\tflag = false;\n\t}\npublic:\n\tZip() {\n\t\tflag = false;\n\t}\n\tvoid add(T x) {\n\t\td.push_back(x);\n\t\tflag = true;\n\t}\n\tll getNum(T x) {\n\t\tif (flag) init();\n\t\treturn lower_bound(d.begin(), d.end(), x) - d.begin();\n\t}\n\tll size() {\n\t\tif (flag) init();\n\t\treturn (ll)d.size();\n\t}\n};\n\n\nll N, M, K, a, b, c, d, e, H, W, L, T;\nll x, y, z;\nll A[2000004] = {};\nll B[2000004] = {};\nll C[2000004] = {};\nll D[1000006] = {};\nll E[1000006] = {};\nbool f;\nstring S[200000];\nstring SS;\nset <long long>sll;\npl bufpl;\nvector <long long>vl[200005];\nvector <long long>vll;\nvector <long long>v;\nvector <pl>vpl;\nvector <string> vs;\nset<ll> llset;\nset<string> Sset;\nmultiset<ll> llmset;\nqueue<ll> ql;\nmultiset<pl> plmset;\n\n\ntypedef struct ST\n{\n\tll first;\n\tll second;\n\tll cost;\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn cost < another.cost;//比較\n\t};\n\n\tbool operator>(const ST& another) const\n\t{\n\t\treturn cost > another.cost;//比較\n\t};\n\n}ST;\n//queue<ST> qst;\npriority_queue<ST, vector<ST>, greater<ST> > qst;\n\n\n\n/*vector <ST> vst;\nST st[200005];\nST bufst;\nbitset<5000> bits;*/\n\n\nlong long modinv(long long aa, long long mm) {\n\tlong long bb = mm, uu = 1, vv = 0;\n\twhile (bb) {\n\t\tlong long tt = aa / bb;\n\t\taa -= tt * bb; swap(aa, bb);\n\t\tuu -= tt * vv; swap(uu, vv);\n\t}\n\tuu %= mm;\n\tif (uu < 0) uu += mm;\n\treturn uu;\n}\n\n\n\n\n\nll zettai(ll aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\nfloat zettai(float aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\n\n/*\nclass UnionFind\n{\n\npublic:\n\n\n\tvector <ll>pairent;\n\tvector <ll>depth;\n\tvector <ll>size;\n\n\n\tUnionFind(ll Amount) : pairent(Amount, 1), depth(Amount, 1), size(Amount, 1) {\n\n\t\tfor (ll i = 0; i < Amount; i++) {\n\t\t\tpairent[i] = i;\n\t\t}\n\n\n\t}\n\n\n\tll FindPairent(ll x) {\n\t\tif (pairent[x] == x)return x;\n\t\telse return pairent[x] = FindPairent(pairent[x]);\n\n\t}\n\n\n\tll Merge(ll x, ll y) {\n\t\tx = FindPairent(x);\n\t\ty = FindPairent(y);\n\n\t\tif (x != y) {\n\t\t\tif (depth[x] > depth[y]) {\n\t\t\t\tpairent[y] = pairent[x];\n\t\t\t\treturn size[x] += size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpairent[x] = pairent[y];\n\t\t\t\tif (depth[x] == depth[y]) {\n\t\t\t\t\tdepth[y] ++;\n\t\t\t\t}\n\n\t\t\t\treturn size[y] += size[x];\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\n\n\n\t}\n\n\n\n\tbool IsSame(ll x, ll y) {\n\t\tif (FindPairent(x) == FindPairent(y))return true;\n\t\telse return false;\n\t}\n\n\n\tll GetSize(ll x) {\n\t\tx = FindPairent(x);\n\t\treturn size[x];\n\t}\n\n\n};\n*/\n\nclass UnionFind\n{\n\npublic:\n\n\tvector <ll>pairent;\n\tvector <ll>depth;\n\tvector <ll>size;\n\n\tUnionFind(ll Amount) : pairent(Amount, 1), depth(Amount, 1), size(Amount, 1) {\n\n\t\tfor (ll i = 0; i < Amount; i++) {\n\t\t\tpairent[i] = i;\n\t\t}\n\t}\n\n\n\tll FindPairent(ll x) {\n\t\tif (pairent[x] == x)return x;\n\t\telse return pairent[x] = FindPairent(pairent[x]);\n\t}\n\n\n\tll Merge(ll x, ll y) {\n\t\tx = FindPairent(x);\n\t\ty = FindPairent(y);\n\n\t\tif (x != y) {\n\t\t\tif (depth[x] > depth[y]) {\n\t\t\t\tpairent[y] = pairent[x];\n\t\t\t\treturn size[x] += size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpairent[x] = pairent[y];\n\t\t\t\tif (depth[x] == depth[y]) {\n\t\t\t\t\tdepth[y] ++;\n\t\t\t\t}\n\t\t\t\treturn size[y] += size[x];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\n\tbool IsSame(ll x, ll y) {\n\t\tif (FindPairent(x) == FindPairent(y))return true;\n\t\telse return false;\n\t}\n\n\n\tll GetSize(ll x) {\n\t\tx = FindPairent(x);\n\t\treturn size[x];\n\t}\n\n\n};\n\nstruct Edge\n{\n\tll a, b, cost;\n\n\n\tbool operator<(const Edge& other) const {\n\t\treturn cost < other.cost;\n\t}\n};\n\nstruct Graph\n{\n\tll n;  // 頂点数\n\tvector<Edge> es;  // 辺集合\n};\n\nclass Kruskal {\n\n\tGraph origin_G;\n\tGraph MST;\n\tll total_cost = 0;\n\npublic:\n\n\tvoid Solve() {\n\t\tUnionFind uf = UnionFind(MST.n);\n\t\tfor (ll i = 0; i < origin_G.es.size(); i++) {\n\t\t\tll a = origin_G.es[i].a;\n\t\t\tll b = origin_G.es[i].b;\n\t\t\tll cost = origin_G.es[i].cost;\n\n\t\t\tif (!uf.IsSame(a, b)) {\n\t\t\t\tuf.Merge(a, b);\n\t\t\t\tMST.es.push_back(origin_G.es[i]);\n\t\t\t\ttotal_cost += cost;\n\t\t\t}\n\t\t}\n\t}\n\n\tKruskal(Graph graph) {\n\t\torigin_G = graph;\n\t\tMST = graph;\n\t\tMST.es.clear();\n\t\tsort(origin_G.es.begin(), origin_G.es.end());\n\t}\n\n\tll GetMinCost() {\n\t\treturn total_cost;\n\t}\n\n};\n\n\nll RepeatSquaring(ll N, ll P, ll M) {\n\tif (P == 0) return 1;\n\tif (P % 2 == 0) {\n\t\tll t = RepeatSquaring(N, P / 2, M) % M;\n\t\treturn t * t % M;\n\t}\n\treturn N * RepeatSquaring(N, P - 1, M) % M;\n}\n\n/*\nll KurikaesiNijou(ll a, ll b, ll P) {\n\n\tif (b == 0)return 1;\n\tif (b % 2 == 0) {\n\t\tll c=KurikaesiNijou(a,b/2,P)%P;\n\t\treturn c * c %P;\n\t}\n\telse {\n\t\tll c = KurikaesiNijou(a, b/2, P) % P;\n\t\treturn a * c * c % P;\n\t}\n\n}*/\n\n\n\n\nll GCD(ll a, ll b) {\n\tif (a % b == 0)return b;\n\telse return GCD(b, a % b);\n}\n\nll Min(ll a, ll b) {\n\tif (a < b)return a;\n\telse return b;\n}\n\nll Max(ll a, ll b) {\n\tif (a > b)return a;\n\telse return b;\n}\n\nll Sum(ll a, ll b) {\n\treturn a + b;\n}\n\ntemplate <typename T>\nclass SegmentTree {\n\tll n;\n\tvector<T> node;\n\tfunction<T(T, T)> fun, fun2;\n\tbool customChange;\n\tT outValue, initValue;\npublic:\n\tvoid init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n\t\t// changeFunction: (input, beforevalue) => newvalue\n\t\tfun = resultFunction;\n\t\tfun2 = changeFunction;\n\t\tcustomChange = changeFunction != NULL;\n\t\tn = 1;\n\t\twhile (n < num) n *= 2;\n\t\tnode.resize(2 * n - 1);\n\t\tfill(node.begin(), node.end(), init);\n\t\toutValue = out;\n\t\tinitValue = init;\n\t}\n\tvoid valueChange(ll num, T value) {\n\t\tnum += n - 1;\n\t\tif (customChange) node[num] = fun2(value, node[num]);\n\t\telse node[num] = value;\n\t\twhile (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n\t}\n\tT rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n\t\tif (r == -1) r = n;\n\t\tif (a <= l && r <= b) return node[k];\n\t\tif (b <= l || r <= a) return outValue;\n\t\tll mid = (l + r) / 2;\n\t\treturn fun(rangeQuery(a, b, l, mid, 2 * k + 1), rangeQuery(a, b, mid, r, 2 * k + 2));\n\t}\n};\n\n\n\n\nclass Combination {\n\n\tvector<ll> factorial;\n\tvector<ll> factorial_inv;\n\tll mod;\n\tll max_n;\n\n\npublic:\n\tvoid Init(ll init_max_n, ll init_mod) {\n\t\tmax_n = init_max_n;\n\t\tmod = init_mod;\n\t\tfactorial.resize(max_n + 1);\n\t\tfactorial[0] = 1;\n\t\tfor (ll i = 1; i < factorial.size(); i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * i;\n\t\t\tfactorial[i] %= mod;\n\t\t}\n\n\t\tfactorial_inv.resize(max_n + 1);\n\t\tfactorial_inv[0] = 1;\n\t\tfor (ll i = 1; i < factorial_inv.size(); i++) {\n\t\t\tfactorial_inv[i] = factorial_inv[i - 1] * modinv(i, mod);\n\t\t\tfactorial_inv[i] %= mod;\n\t\t}\n\t}\n\n\n\n\tll GetComb(ll n, ll k) {\n\t\tll comb = factorial[n];\n\t\tcomb *= factorial_inv[k];\n\t\tcomb %= mod;\n\t\tcomb *= factorial_inv[n - k];\n\t\tcomb %= mod;\n\t\treturn comb;\n\t}\n\n\tll GetH(ll n, ll k) {//n+k-1<=max_N\n\t\tll comb = factorial[n + k - 1];\n\t\tcomb *= factorial_inv[n];\n\t\tcomb %= mod;\n\t\tcomb *= factorial_inv[k - 1];\n\t\tcomb %= mod;\n\t\treturn comb;\n\t}\n\n};\n\n\n\nclass Tree {\n\n\tll node_N;\n\tvector<ll> node;\n\tvector<vector<pl>> pass;\n\tll diameter = -1;\n\tvector<ll> dist_Diamieter[2];\n\n\tpl maxDist_Num;\n\npublic:\n\n\n\tvoid Init(ll node_Num) {\n\t\tnode_N = node_Num;\n\t\tnode.resize(node_N + 1);\n\t\tpass.resize(node_N + 1);\n\n\t\tdist_Diamieter[0].resize(node_N + 1);\n\t\tlp(i, node_N + 1)dist_Diamieter[0][i] = -1;\n\t\tdist_Diamieter[1].resize(node_N + 1);\n\t\tlp(i, node_N + 1)dist_Diamieter[1][i] = -1;\n\t}\n\n\tvoid AddEdge(ll a, ll b, ll dist) {\n\t\tbufpl.first = b;\n\t\tbufpl.second = dist;\n\t\tpass[a].push_back(bufpl);\n\t\tbufpl.first = a;\n\t\tpass[b].push_back(bufpl);\n\t}\n\n\n\tvoid DFS(ll step, ll now, ll dist) {\n\n\t\tdist_Diamieter[step][now] = dist;\n\t\tif (dist_Diamieter[step][now] > maxDist_Num.first) {\n\t\t\tmaxDist_Num.first = dist_Diamieter[step][now];\n\t\t\tmaxDist_Num.second = now;\n\t\t}\n\n\t\tfor (ll i = 0; i < pass[now].size(); i++) {\n\t\t\tll next_node = pass[now][i].first;\n\t\t\tif (dist_Diamieter[step][next_node] == -1) {\n\t\t\t\tDFS(step, next_node, dist + pass[now][i].second);\n\t\t\t}\n\t\t}\n\t}\n\n\tll GetDiameter(ll min_node_num) {\n\t\tif (diameter >= 0)return diameter;\n\t\telse {\n\t\t\tmaxDist_Num.first = -1;\n\t\t\tmaxDist_Num.second = -1;\n\t\t\tDFS(0, min_node_num, 0ll);\n\t\t\tll step2_start = maxDist_Num.second;\n\n\t\t\tmaxDist_Num.first = -1;\n\t\t\tmaxDist_Num.second = -1;\n\t\t\tDFS(1, step2_start, 0ll);\n\n\t\t\tdiameter = maxDist_Num.first;\n\t\t\treturn diameter;\n\t\t}\n\t}\n\n\tll GetDistFromMinNode(ll num) {\n\t\treturn dist_Diamieter[0][num];\n\t}\n\n};\n\n\nvoid Nibu(ll node, ll co) {\n\n\tC[node] = co % 2;\n\tD[co % 2]++;\n\n\tlp(i, vl[node].size()) {\n\t\tll next = vl[node][i];\n\t\tif (C[next] == -1) {\n\t\t\tNibu(next, co + 1);\n\t\t}\n\t}\n\n}\n\nST bufst;\nmultiset<ST> stmset;\nvector<pl> vpll[10004];\n\nSegmentTree<ll> st;\n\nll grundy[100005] = {};\n\nll grund(ll n,ll rank) {\n\tif(grundy[n]==-1)grundy[n] = rank;\n\tll aa = rank;\n\n\tlp(i, vl[n].size()) {\n\t\tif (n == 1) {\n\t\t\tvll.push_back(grund(vl[n][i], rank + 1));\n\t\t}\n\t\telse {\n\t\t\tif (grundy[vl[n][i]] == -1) {\n\t\t\t\taa = aa xor grund(vl[n][i], rank + 1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn aa;\n\n}\n\nint main() {\n\n\t/*cin >> N >> M;\n\n\tlp(i, M) {\n\t\tcin >> a >> b >> c;\n\t\tbufpl.first = b;\n\t\tbufpl.second = c;\n\t\tvpll[a].push_back(bufpl);\n\t}\n\n\tlp(i, N)A[i] = INF;\n\n\tbufst.first = 0;\n\tbufst.second = 0;\n\tbufst.cost = 0;\n\tstmset.insert(bufst);\n\tA[0] = 0;\n\n\twhile (!stmset.empty()) {\n\n\t\tauto itr = stmset.begin();\n\t\ta = itr->first;\n\t\tb = itr->second;\n\t\tc = itr->cost;\n\n\t\tif (c != A[a]) {\n\t\t\tstmset.erase(itr);\n\t\t\tcontinue;\n\t\t}\n\n\n\t}\n\n\n\tlp(i, N)cout << A[i] << endl;\n\t*/\n\n\tcin >> N;\n\tlp(i, N-1) {\n\t\tcin >> a >> b;\n\t\tvl[a].push_back(b);\n\t\tvl[b].push_back(a);\n\t\t\n\t}\n\tlp(i, N + 1)grundy[i] = -1;\n\tgrund(1, 0);\n\tb = 0;\n\tlp(i, vll.size())b = b xor vll[i];\n\n\tif (b == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\n\n\t//cout << fixed << setprecision(12) << bb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<math.h>\n#include<unordered_set>\n#include<string.h>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\n\n#define FOR(i,N) for(int i=0;i<N;i++)\n\nll mod=1e9+7;\n\n\nint n;\nmap<int,vector<int> >tree;\nmap<int,int>depth;\nvector<int>visited;\n\nint dfs(int node,int d,int last){\n    int de=0;\n    for(auto a:tree[node]){\n        if(a!=last){\n            de=de^(dfs(a,d+1,node)+1);\n        }\n    }\n    return depth[node]=de;\n}\n\nint main() {\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n    ;\n  \n    if(dfs(1,0,-1)>0){\n        cout<<\"Alice\"<<endl;\n    } else {\n        cout<<\"Bob\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define maxn 100000\n#define rep(i,n) for(int i=0; i<int(n); ++i)\n#define pb push_back\n#define mp make_pair\n\nstd::vector<int> e[maxn];\nint a[maxn];\nvoid dfs(int u, int f){\n    a[u] = 0;\n    for(int v: e[u]) if(v!=f){\n        dfs(v, u);\n        a[u] ^= (1 + a[v]);\n    }\n}\n\nvoid solve(){\n    int n,m,k;\n    int x,y,z,A,B,C,D;\n    cin >> n;\n    rep(i,n-1){\n        cin >> x >> y;\n        --x,--y;\n        e[x].pb(y);\n        e[y].pb(x);\n    }\n    dfs(0,-1);\n    cout << (a[0]==0? \"Bob\":\"Alice\");\n}\n\nint main(int argc, char const *argv[])\n{\n    ios_base::sync_with_stdio(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \")\n{ if (!v.size()) puts(\"\"); rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nint n;\nvector<vi> G;\nbool used[101010] = {true};\n\nbool f(int v = 0) {\n\n  bool ret = false;\n  int cnt = 0;\n\n  for (int i = 0; i < G[v].size(); ++i) {\n    if (used[G[v][i]]) continue;\n    used[G[v][i]] = true;\n    cnt++;\n    if (!f(G[v][i])) ret = !ret;\n  }\n\n  if (cnt == 1) return true;\n  if (cnt == 0) return false;\n\n  return ret;\n}\n\nsigned main() {\n  cin >> n;\n\n  G.resize(n);\n\n  rep(i, n - 1) {\n    int a = in() - 1, b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  cout << (f() ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define INF32 (numeric_limits<int32_t>::max()/2-1)\n#define INF64 (numeric_limits<int64_t>::max()/2-1)\n#define INF (numeric_limits<int>::max()/2-1)\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T> constexpr bool chmin(T& x, T const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T> constexpr bool chmax(T& x, T const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n    vector<vector<int>> g(n);\n    rep (i,n-1) {\n        int x,y; cin >> x >> y; x--,y--;\n        g[x].eb(y);\n        g[y].eb(x);\n    }\n\n    def (dfs, int x, int p) -> int {\n        int ret = 0;\n        for (int y : g[x]) {\n            if (y == p) continue;\n            ret ^= 1+dfs(y,x);\n        }\n        return ret;\n    };\n\n    cout << (dfs(0,-1) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <string>\n#include <set>\n#include <bitset>\n#include <unordered_map>\n#include <cmath>\n#include <functional>\n#include <map>\n#include <cstdlib>\n\nusing namespace std;\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\ntemplate <class T>\nusing Vvec = vector<vector<T> >;\nusing Graph = Vvec<int>;\n\ntemplate <class T>\nvoid debug(T& v)\n{\n    for(auto& x: v) cout << x << \" \";\n    cout << endl;\n}\n\nvoid dfs(Graph& graph, vector<ll>& dp, int tmp = 0, int from = -1){\n    for(auto& to: graph[tmp]){\n        if(to != from){\n            dfs(graph, dp, to, tmp);\n            dp[tmp] ^= dp[to]+1;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    Graph graph(N);\n    for(int i=0; i<N-1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<ll> dp(N);\n    dfs(graph, dp);\n\n    cout << ((dp[0]) ? \"Alice\" : \"Bob\") << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define REP(i, N) for (int i = 0; i < (N); ++i)\n\nint N;\nvector<int> graph[100100];\n\nint grundy(int cur, int prv = -1) {\n    int ret = 0, cnt = 0;\n    for (auto& nxt: graph[cur]) {\n        if (nxt == prv) continue;\n        ret ^= grundy(nxt, cur);\n        ++cnt;\n    }\n    return ret + (cnt == 1);\n}\n\nsigned main() {\n    cin >> N;\n    REP(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        --a, --b;\n        graph[a].emplace_back(b);\n        graph[b].emplace_back(a);\n    }\n    if (grundy(0)) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint mex[101010];\n\n\nint dfs(int cur,int pre) {\n\t\n\tif(E[cur].size()-(pre!=-1)==1) {\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tmex[cur]=dfs(e,cur)+1;\n\t\t}\n\t}\n\telse {\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tmex[cur]^=dfs(e,cur);\n\t\t}\n\t}\n\t\n\treturn mex[cur];\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tif(dfs(0,-1)) cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nint dfs(int v, int prev, const Graph& G) {\n\tint g = 0;\n\tfor (auto to : G[v]) {\n\t\tif (to != prev) {\n\t\t\tg ^= dfs(to, v, G);\n\t\t}\n\t}\n\treturn g + 1;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tGraph G(N);\n\tfor (int i = 0, x, y; i < N - 1; i++) {\n\t\tcin >> x >> y; x--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tcout << (dfs(0, -1, G) - 1 ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> e[111111];\nint sg[111111];\nvoid dfs(int x,int fat){\n\tsg[x] = 0;\n\tfor(vector<int>::iterator it = e[x].begin(); it!=e[x].end(); it++)\n\t\tif(*it != fat){\n\t\t\tdfs(*it, x);\n\t\t\tsg[x] ^= (sg[*it]+1);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nsigned main(){\n    int n;\n    cin >> n;\n    int cnt = 0;\n    rep(i, 0, n - 1){\n        int a, b;\n        cin >> a >> b;\n        if(a == 1 || b == 1) cnt++;\n    }\n    int el = n - 1 - cnt;\n    bool f = false;\n    if(cnt == 1) f = true;\n    else{\n        if((n - 1) % 2) f = true;\n    }\n    cout << (f ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n long long n,one;\n  cin >> n;\n  for(long long i = 0; i < n-1; i++) { long long a, b;\n                                      cin >> a >> b;\n                                      if(min(a, b) == 1) one ++; }\n  if(n%2 && one > 1) cout << \"Bob\\n\";\n  else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nconst int MAXN = 100005;\nint dp[MAXN], visited[MAXN];\n\nint n;\n\nvector<vector<int>> adj;\n\nvoid dfs(int u) {\n    visited[u] = 1;\n\n    dp[u] = 0;\n\n    for (auto& v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n            dp[u] ^= (dp[v] + 1);\n        }\n    }\n}\n\nint main() {\n    GI(n);\n\n    int u, v;\n\n    adj.resize(n+1);\n\n    FORN(i, n-1) {\n        GI(u);\n        GI(v);\n\n        adj[u].PB(v);\n        adj[v].PB(u);\n    }\n\n    memset(visited, 0, sizeof visited);\n    dfs(1);\n\n//    DEBUG(dp[1]);\n\n    if (dp[1] == 0) {\n        printf(\"Bob\\n\");\n    }\n    else {\n        printf(\"Alice\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n\ntypedef long long int ll;\ntypedef vector< pair<int, int> > vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<long long int> vll;\ntypedef pair<int, int> pii;\n\nconst ll INF = 1e18;\nconst ll inf = 1e5 + 5;\nconst ll MOD = 1e9 + 7;\nconst ll nax = 100000 + 10;\n\nvi graph[nax];\n\nint dfs(int v, int par)\n{\n    if(graph[v].size() == 1 && par != -1)\n    {\n        return 0;\n    }\n    int xori = 0;\n    for(auto x: graph[v])\n    {\n        if(x == par) continue;\n        xori ^= (dfs(x, v) + 1);\n    }\n    return xori;\n}\nvoid clr()\n{\n    for(int i = 1; i <= 1e5; i++)\n        graph[i].clear();\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    int t = 1;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        clr();\n        for(int i = 1; i <= n - 1; i++)\n        {\n            int u, v;\n            cin >> u >> v;\n            graph[u].pb(v);\n            graph[v].pb(u);\n        }\n        int ans = dfs(1, -1);\n        if(ans == 0)\n            cout << \"Bob\" << endl;\n        else\n            cout << \"Alice\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int   ll;\ntypedef pair<ll, ll>    pll;\ntypedef pair<int, int>  pii;\n\n#define all(x)          x.begin(), x.end()\n#define kill(x)         return cout << x << endl, 0\n#define X               first\n#define Y               second\n#define sep             ' '\n#define endl            '\\n'\n\nll pw(ll a, ll b, ll mod) {\n    if (!b)    return 1;\n    if (b & 1) return a * pw(a * a % mod, b / 2, mod) % mod;\n    return pw(a * a % mod, b / 2, mod) % mod;\n}\n\nconst ll N    = 1e5 + 10;\nconst ll MOD  = 1e9 + 7;\nconst ll INF  = 1e18;\n\nint n, G[N];\nvector<int> adj[N];\n\nvoid DFS(int u, int p) {\n    for (int v : adj[u]) if (v != p) {\n        DFS(v, u);\n        G[u] ^= G[v] + 1;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    DFS(1, 0);\n    cout << (G[1] ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 3000000000000000000;\n\nvector<vector<int>> G;\n\nint dfs(int v = 0, int p = -1) {\n    int res = 0;\n    for (int u : G[v]) {\n        if (u == p) continue;\n        res ^= (dfs(u, v) + 1);\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    G = vector<vector<int>>(n);\n    REP(i, n - 1) {\n        int x, y;\n        cin >> x >> y;\n        --x; --y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (dfs() ? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nvector<vec>G(N);\nint dfs(int x,int p){\n  int g=0;\n  for(auto e:G[x]){\n    if(e!=p){\n    g^=(dfs(e,x)+1);}\n  }\n}\nmain(){\n    int n=in();\n  rep(i,n-1){\n  int a=in(),b=in();\n  G[a].pb(b);\n  G[b].pb(a);}\n  cout<<(dfs(1,0)?“Alice”:“Bob”);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n// #include <bits/extc++.h>\nusing namespace std;\n\n#define debug(s) cout << #s << \" = \" << s << endl\n#define all(v) (v).begin(), (v).end()\n#define KeepUnique(v) (v).erase( unique(all(v)), v.end() )\n#define MEMSET(a, val) memset(a, val, sizeof (a))\n#define PB push_back\n#define endl '\\n'\ntypedef long long ll;\n\ninline int myrand(int l, int r) {\n\tint ret = rand(); ret <<= 15; ret ^= rand();\n\tif(ret < 0) ret = -ret; ret %= (r-l+1); ret += l;\n\treturn ret;\n}\n\ntemplate <typename F, typename S>\nostream& operator << (ostream& os, const pair< F, S>& p) {\n\treturn os<<\"(\" <<p.first<<\", \"<<p.second<<\")\"; }\n\ntypedef pair<int, int> ii;\n\ntemplate<typename T> using min_pq =\n\tstd::priority_queue<T, vector<T>, greater<T> >;\n\n//int dx[] = {-1, +0, +1, +0};\n//int dy[] = {+0, +1, +0, -1};\n\nconst int maxn = 100005;\n\nint n;\nvector<int> g[maxn];\nint grundy[maxn], ok[maxn];\n\nvoid dfs(int u, int par) {\n\tfor(int v : g[u]) {\n\t\tif(v - par) {\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n\tfor(int v : g[u])\n\t\tok[grundy[v]] = 1;\n\tfor(int i = 0; ; i++) {\n\t\tif(!ok[i]) {\n\t\t\tgrundy[u] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int v : g[u])\n\t\tok[grundy[v]] = 0;\n}\n\nint32_t main () {\n    // freopen(\"in\", \"r\", stdin);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n    \tint u, v; cin >> u >> v;\n    \tg[u].push_back(v);\n    \tg[v].push_back(u);\n    }\n    dfs(1, -1);\n    int s = 0;\n    for(int v : g[1]) {\n    \ts ^= grundy[v];\n    }\n    puts(s ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,u,v,sg[N];\nVI e[N];\nvoid dfs(int u,int f) {\n\tfor (auto v:e[u]) if (v!=f) {\n\t\tdfs(v,u);\n\t\tsg[u]^=sg[v]+1;\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <list>\n#include <map>\n#include <queue>\n#include <iterator>\n#include <iomanip>\n#include <stdio.h>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define ld long double\n#define infinity (ll)1e18+1\n#define PI 3.14159265358979\n\n#define pdd pair<ld,ld>\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n\n#define MP make_pair\n#define SZ size()\n#define PB push_back\n\n#define vi vector<int>//ll\n#define vll vector<ll>\n#define vpll vector<pll>\n#define vpii vector<pii>\n#define vch vector<char>\n#define vb vector<bool>\n#define vld vector<ld>\n\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(ll i = (b) - 1; i >= (a); --i)\n#define REPEAT(i) FOR(counter1234,0,i)\n#define ALL(a) a.begin(), a.end()\n#define X first\n#define Y second\n#define MAXN 100001\nclock_t startTime;\n\nint n;\nvi g[MAXN];\n\nvi sons;\nint c = 0;\nvch used;\nvoid dfs(int v)\n{\n\tint s = c;\n\tused[v] = 1;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t\tdfs(i), c++;\n\tsons[v] = c - s;\n}\nint d[MAXN];\n\nvoid bfs()\n{\n\td[1] = 0;\n\tused.assign(n + 1, 0);\n\tused[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor(auto i: g[t])\n\t\t\tif (used[i] == 0)\n\t\t\t{\n\t\t\t\tused[i] = 1;\n\t\t\t\td[i] = d[t] + 1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tstartTime = clock();\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\t//ifstream in(\"In.txt\");\n\n\tcin >> n;\n\tint a, b;\n\tsons.assign(n + 1, 0);\n\tused.assign(n + 1, 0);\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll XOR_ALL = 0;\n\tdfs(1);\n\tbfs();\n\n\tvi xors;\n\txors.assign(n + 1, 0);\n\n\tFOR(i, 1, n + 1)\n\t\tfor (auto s : g[i])\n\t\t\tif (d[s] > d[i])\n\t\t\t\txors[i] ^= (sons[s] + 1);\n\t\n\n\tif (xors[1] == 0)\n\t{\n\t\tcout << \"Bob\";\n\t\treturn 0;\n\t}\n\t\n\tll x = 0;\n\tfor (auto s : g[1])\n\t\tx ^= xors[s];\n\tif (x == 0)\n\t\tcout << \"Bob\";\n\telse\n\t\tcout << \"Alice\";\n\n\treturn 0;\n}\n//don't forget about MAXN, mod and infinity "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\nconstexpr int MAX = 100000;\n\nstruct Graph {\n    void addEdge(int from, int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<int> edge[MAX];\n};\n\nint N;\nGraph g_;\nGraph g;\n\nll grundy(int root)\n{\n    if (g.edge[root].empty()) {\n        return 0;\n    } else if (g.edge[root].size() == 1) {\n        return grundy(g.edge[root][0]) + 1;\n    } else {\n        ll num = 0;\n        for (const int p : g.edge[root]) {\n            num ^= grundy(p);\n        }\n        return num;\n    }\n}\n\nint main()\n{\n    cin >> N;\n    for (ll i = 0; i < N - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        g_.addEdge(x, y);\n        g_.addEdge(y, x);\n    }\n    bool check[MAX];\n    fill(check, check + MAX, false);\n    queue<int> q;\n    q.push(0);\n    while (not q.empty()) {\n        const int p = q.front();\n        q.pop();\n        check[p] = true;\n        for (const int to : g_.edge[p]) {\n            if (not check[to]) {\n                g.addEdge(p, to);\n                q.push(to);\n            }\n        }\n    }\n\n    const ll grundynum = grundy(0);\n    if (grundynum == 0) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p=-1){\n\tint x = 0;\n\tfor(int u:G[v]) if(u!=p) x^=dfs(u,v);\n\treturn x+1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tif(dfs(0)!=1) puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\n//作者:中国江苏南京丁天行\nusing namespace std;\n//数组不要开小了\n//数组不要开反了\nint n,f[300005];\nvector<int> v[100005];\nint cty(int x,int p){\n    int cnt[3]={};\n    int b=1;\n    for(int i=0;i<v[x].size();i++){\n            if(v[x][i]==p) continue;\n            cnt[cty(v[x][i],x)]++;\n            if(f[v[x][i]]>1)b=2;\n    }\n    if(cnt[0]%2==0&&cnt[1]%2==0&&cnt[2]%2==0) return 0;\n    if(cnt[0]%2==0&&cnt[1]%2==0&&cnt[2]%2==1) return b;\n    if(cnt[0]%2==0&&cnt[1]%2==1&&cnt[2]%2==0) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==0&&cnt[2]%2==0) return b;\n    if(cnt[0]%2==0&&cnt[1]%2==1&&cnt[2]%2==1) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==0&&cnt[2]%2==1) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==1&&cnt[2]%2==0) return b;\n    if(cnt[0]%2==1&&cnt[1]%2==1&&cnt[2]%2==1) return b;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].pb(y),v[y].pb(x);\n            f[x]++,f[y]++;\n    }\n    if(cty(1,0))puts(\"Alice\");\n    else puts(\"Bob\");\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// ITNOG :)))\n/// SAliB\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb                      push_back\n#define pp                      pop_back\n#define mp                      make_pair\n#define fi                      first\n#define sec                     second\n#define xmax(x,y)               ((x) = max((x),(y)))\n#define xmin(x,y)               ((x) = min((x),(y)))\n#define all(x)                  (x).begin(),(x).end()\n#define mem(x , y)              memset(x , y , sizeof(x))\n#define _                       ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\n#define debug1(a)               cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n';\n#define debug2(a , b)           cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n';\n#define debug3(a , b , c)       cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n' << #c << \" ---> \" << c << '\\n';\n#define debug4(a , b , c , d)   cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n' << #c << \" ---> \" << c << '\\n' << #d << \" ---> \" << d << '\\n';\n#define connect(a , b , c)      a[b].pb(c) , a[c].pb(b)\n//\ntypedef long long int ll            ;\ntypedef unsigned long long int ull  ;\ntypedef unsigned int uint           ;\ntypedef long double ld              ;\ntypedef string str                  ;\ntypedef pair < int , int > pii      ;\ntypedef pair < pii , int > ppi      ;\ntypedef pair < int , pii > pip      ;\ntypedef pair < ll , ll> pll         ;\ntypedef pair < ll , pll> plp        ;\ntypedef pair < pll , ll> ppl        ;\ntypedef vector < ll > vl            ;\ntypedef vector < ld > vld           ;\ntypedef vector < int > vi           ;\ntypedef vector < str > vs           ;\n//\ninline int   iin()  { int x   ; scanf(\"%d\" , &x)   ;  return x; }\ninline ll    lin()  { ll  x   ; scanf(\"%lld\" , &x) ;  return x; }\ninline ll    Lin()  { ll  x   ; scanf(\"%I64d\" , &x);  return x; }\n//\ninline int   iout(int  x)  { printf(\"%d\" , x)   ;  }\ninline ll    lout(ll   x)  { printf(\"%lld\" , x) ;  }\ninline ll    Lout(ll   x)  { printf(\"%I64d\" , x);  }\n//\nconst int maxn4 = 1e4 + 85 , maxn5 = 1e5 + 69 , maxn6 = 1e6 + 85 , maxn7 = 1e7 + 69 , maxn8 = 1e8 + 85 , maxn9 = 1e9 + 69 , modi1 = 1e7 + 7 , modi2 = 1e9 + 7;\nconst ll mod1 = 1e7 + 7 , mod2 = 1e9 + 7;\nint mn = INT_MAX , mx = INT_MIN;\n//\nvi g[maxn6];\nint dfs(int v , int p = -1)\n{\n\tint ans = 0;\n\tfor(int u : g[v])\n\t\tif (u != p)\n\t\t\tans ^= dfs(u , v) + 1;\n\treturn ans;\n}\nint main()\n{_\n\tint n;cin >> n;\n\tfor(int i = 0; i < n - 1; i++)\n    {\n\t\tint u , v;cin >> u >> v;\n\t\t--u, --v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tcout << (dfs(0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint n;\nvector< vector<int> > graph(100100, vector<int>());\nvector<bool> visited(100100, false);\n\nint dfs(int now) {\n    int g = 0;\n    for(int i = 0; i < graph.at(now).size(); ++i) {\n        if(!visited.at(graph.at(now).at(i))) {\n            visited.at(graph.at(now).at(i)) = true;\n            g ^= dfs(graph.at(now).at(i));\n        }\n    }\n    return g+1;\n}\n\nint main() {\n    cin >> n;\n    for(int i = 0; i < n-1; ++i) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        graph.at(a).push_back(b);\n        graph.at(b).push_back(a);\n    }\n    visited.at(0) = true;\n    int ans = dfs(0)-1;\n\n    if(ans == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n,x,y,tot=0,sum=0;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tsum++;\n\t\tif(x==1||y==1)tot++;\n\t}\n\tint ans=sum-tot;\n\tif(ans&1)cout<<\"Alice\";\n\telse cout<<\"Bob\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<cstdlib>\n#include<algorithm>\n#include<bitset>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<iomanip>\n#include<ctime>\n#include<complex>\n#include<functional>\n#include<climits>\n#include<cassert>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n\n\nint n;\n#define MAX 100002\n\nvector<int> v[MAX];\nint gr[MAX];\n\ninline void dfs(int b,int pr=-1) {\n\tif (v[b].size() == 1 && pr != -1) {\n\t\tgr[b] = 0;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < v[b].size(); i++) {\n\t\tint go = v[b][i];\n\t\tif (go != pr) {\n\t\t\tdfs(go);\n\t\t\tgr[b] ^= (gr[go] + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tif (gr[0]) {\n\t\tputs(\"Alice\");\n\t}\n\telse {\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, dep[100005];\nvector<int> adjlist[100005];\nvector< pair<int, int> > edgelist;\n\nvoid dfs(int x, int p, int d) {\n\tdep[d]++;\n\tfor (int i = 0; i < adjlist[x].size(); i++) if (adjlist[x][i] != p) dfs(adjlist[x][i], x, d + 1);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tadjlist[a].push_back(b);\n\t\tadjlist[b].push_back(a);\n\t\tedgelist.push_back(make_pair(a, b));\n\t}\n\tdfs(0, -1, 0);\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (dep[i] % 2 == 1) ans = 1;\n\t}\n\tif (ans == 0) {\n\t\tprintf(\"Bob\\n\");\n\t\treturn 0;\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (dep[i] % 2 == 1) cnt++;\n\t\tif (dep[i] == 1) break;\n\t}\n\tif (cnt % 2 == 0) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX 100100\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX<<1];\nint h[MAX],cnt=1;\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}\nint n,sg[MAX],vis[MAX];\nvoid dfs(int u,int ff)\n{\n\tfor(int i=h[u];i;i=e[i].next)\n\t\tif(e[i].v!=ff)dfs(e[i].v,u),sg[u]^=sg[e[i].v]+1;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tAdd(u,v);Add(v,u);\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define all(a) a.begin(),a.end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define mp make_pair\n#define endl '\\n'\n#define vec vector<ll>\n#define mat vector<vector<ll> >\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\nconst ll inf=998244353;\nconst ll mod=1e9+7;\nvector<vector<ll> >G(100010);\nvector<ll>d(100010);\nvoid dfs(ll i,ll p,ll c){\n    d[i]=c;\n    for(auto e:G[i]){\n        if(e==p)continue;\n        dfs(e,i,c+1);\n    }\n    return;\n}\nsigned main(){\n    ll n;cin>>n;\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    dfs(0,-1,0);\n    ll ans=0;\n    rep(i,n){\n        ans^=d[i];\n    }\n    if(ans)cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define rt return\nusing dbl = double;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nvi G[100001];\n\nint f(int u, int p) {\n    if (u != 0 && sz(G[u]) == 1) { // leaf\n        return 0;\n    }\n    int sm = 0;\n    each(v, G[u])if (v != p) {\n        sm ^= f(v, u) + 1;\n    }\n    return sm;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N; // 2<=N<=10^5\n    cin >> N;\n\n    rep(i, N - 1) {\n        int x, y; // 1<=x,y<=N\n        cin >> x >> y;\n        --x; --y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    int gr = f(0, -1);\n    cout << (gr ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pp pair<int,int>\n#define MZ 1000000007\n#define Pi acos(-1)\n#define pq priority_queue\n\nusing namespace std;\n\nstruct Node\n{\n    int n1,n2;\n    int f,du;\n}num[100005];\nbool life[100005];\nvector <int> v1[100005];\nint root[100005];\nqueue <int> q;\n\nvoid dfs(int x)\n{\n    life[x]=1;\n    bool wtf=0;\n    for(int i=0;i<v1[x].size();i++)\n    {\n        if(!life[v1[x][i]])\n        {\n            wtf=1;\n            num[x].du++;\n            root[v1[x][i]]=x;\n            dfs(v1[x][i]);\n        }\n    }\n    if(!wtf)\n        q.push(x);\n}\n\nint main()\n{\n    int n,temp;\n    int x,y;\n    bool f=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v1[x].push_back(y);\n        v1[y].push_back(x);\n    }\n    dfs(1);\n    while(!q.empty())\n    {\n        temp=q.front();\n        q.pop();\n        if(num[temp].n2)\n        {\n            if(num[temp].n2%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        else\n        {\n            if(num[temp].n1%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        if(root[temp])\n        {\n            if(num[temp].f==1)\n                num[root[temp]].n1++;\n            else\n                num[root[temp]].n2++;\n            num[root[temp]].du--;\n            if(num[root[temp]].du==0)\n                q.push(root[temp]);\n        }\n    }\n    if(num[1].n2%2 || (num[1].n2==0 && num[1].n1%2))\n        printf(\"Alice\\n\");\n    else\n        printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 6;\n\nint f[maxn];\nvector<int> E[maxn];\n\nvoid dfs(int x,int pi) {\n\tf[x] = 0;\n\tfor (int i = 0; i < E[x].size(); i++) {\n\t\tint z = E[x][i];\n\t\tif (z == pi) continue;\n\t\tdfs(z,x);\n\t\tf[x] ^= 1 + f[z];\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\tdfs(1,-1);\n\tprintf(f[1]==0 ? \"Bob\\n\" : \"Alice\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nvector<ll> node[100005];\nbool used[100005]={false};\nll grundy(ll pos){\n  ll cnt=0;\n  for(int i=0;i<node[pos].size();i++){\n    ll to=node[pos][i];\n    if(!used[to]) cnt++;\n  }\n  if(cnt==0) return 0;\n  else if(cnt==1){\n    for(int i=0;i<node[pos].size();i++){\n      ll to=node[pos][i];\n      if(!used[to]){\n        used[to]=true;\n        return grundy(to)+1;\n      }\n    }\n  }\n  else{\n    ll res=0;\n    for(int i=0;i<node[pos].size();i++){\n      ll to=node[pos][i];\n      if(!used[to]){\n        used[to]=true;\n        res^=grundy(to)+1;\n      }\n    }\n    return res;\n  }\n}\nint main(){\n  ll n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    ll s,t;\n    cin>>s>>t;\n    node[s].push_back(t);\n    node[t].push_back(s);\n  }\n  for(int i=1;i<=n;i++) used[i]=false;\n  used[1]=true;\n  cout<<(grundy(1)==0?\"Bob\":\"Alice\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii; \n\nconst int N = 2e5 + 10; \nvector<int> adj[N]; \n\nint dfs(int u, int par = -1) {\n\tint g = 0; \n\tfor(int v : adj[u]) if(v - par) \n\t\tg ^= dfs(v, u) + 1; \n\treturn g; \n}\nint main(int argc, char const *argv[]) {\n\tint n; cin >> n; \n\tfor(int i = 1; i < n; i++) {\n\t\tint u, v; \n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\t\n\tputs(dfs(1) ? \"Alice\" : \"Bob\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int f = 0;\n        FORE(e, ch) f ^= (e & 1);\n        cout << (f ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 200001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= d[h] + 1;\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    if(g[i].size()==1){sg[i]=1;return;}\n    sg[i]=0;\n    set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        //s.insert(sg[g[i][j]]);\n    }\n    f[i]=0;\n    for(long j=0,l=g[i].size();j<l;j++)if(f[i])s.insert(sg[g[i][j]]);\n    f[i]=1;\n    for(long j=0,l=s.size();j<l;j++)\n    {\n        if(sg[i]==*s.begin()){s.erase(s.begin());sg[i]++;}\n        else break;\n    }\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    //for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1]||g[1].size()==1)cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200000;\nint n;\nmap <set <int>, int> M;\nint tot;\nvector <int> bi[N];\nint dfs(int t, int f = 0)\n{\n    set <int> a;\n    for (int i = 0; i < bi[t].size(); ++ i) if (bi[t][i] != f)\n    {\n        int x = dfs(bi[t][i], t);\n        if (a.count(x)) a.erase(x); else a.insert(x);\n    }\n    if (!M.count(a)) M[a] = tot ++;\n    return M[a];\n}\nint main()\n{\n    puts(\"Bob\"); return 0;\n    cin >> n;\n    for (int i = 1; i <n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        bi[a].push_back(b);\n        bi[b].push_back(a);\n    }\n    if (dfs(1)) puts(\"Alice\"); else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, N) for (int i = 0; i < (int)N; i++)\n#define FORIN(i, a, b) for (int i = a; i < (int)b; i++)\n#define ALL(x) (x).begin(), (x).end()\n#define MOD 1000000007\n#define MAX (1 << 29)\n#define DEBUG(...) debug(__LINE__, \":\" __VA_ARGS__)\n\nusing Pi = pair<int, int>;\nusing ll = long long;\nconst int INF = 1 << 28;\n\nstring to_string(string s) {\n  return s;\n}\n\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) {\n  return \"{\" + to_string(p.first) + \",\" + to_string(p.second) + \"}\";\n}\n\ntemplate <class T>\nstring to_string(vector<T> v) {\n  string ret = \"{\";\n  for (int i = 0; i < v.size() - 1; ++i) {\n    ret += to_string(v[i]) + \",\";\n  }\n  if (v.size() > 0) {\n    ret += to_string(v.back());\n  }\n  ret += \"}\";\n  return ret;\n}\n\nvoid debug() {\n  cerr << endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid debug(Head head, Tail... tail) {\n  cerr << to_string(head) << \" \";\n  debug(tail...);\n}\n\nvoid print() {\n  cout << endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head head, Tail... tail) {\n  cout << to_string(head);\n  print(tail...);\n}\n\nvoid get() {}\n\ntemplate <class Head, class... Tail>\nvoid get(Head& head, Tail&... tail) {\n  cin >> head;\n  get(tail...);\n}\n\ntemplate <class T>\nvoid getv(vector<T>& vec) {\n  for (int i = 0; i < vec.size(); ++i)\n    cin >> vec[i];\n}\n\nint main() {\n  int N;\n  cin >> N;\n  vector<vector<int>> G(N);\n  FOR(i, N - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  vector<int> val(N, -1);\n  val[0] = 0;\n  stack<int> s;\n  s.push(0);\n  while (!s.empty()) {\n    int v = s.top();\n    s.pop();\n    for (int x : G[v]) {\n      if (val[x] == -1) {\n        val[x] = val[v] + 1;\n        s.push(x);\n      }\n    }\n  }\n  map<int, int> ct;\n  FORIN(i, 1, N) ct[val[i]]++;\n  bool ans = 0;\n  for (Pi p : ct)\n    if (p.second % 2 == 1)\n      ans = 1;\n  print(ans ? \"Alice\" : \"Bob\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1234567;\n\nvector<int> g[MAX];\nint n;\nint dfs (int v, int r) {\n\tint res = 0;\n\tfor (auto u : g[v])\n\t\tif (u != r)\n\t\t\tres ^= dfs (u, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i =  0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tcout << (dfs (0,-1)==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxN 100002\nusing namespace std;\nint n;\nvector < int > V[maxN];\nbool ok[maxN], both[maxN];\n\nvoid dfs(int x, int t)\n{\n    int nrs = 0;\n    ok[x] = 0;\n    both[x] = 0;\n    for (int y : V[x])\n        if (y != t)\n        {\n            ++ nrs;\n            dfs(y, x);\n            if (V[y].size() > 2 || both[y])\n                both[x] = 1;\n            if (!both[y])\n                ok[x] = ok[x] ^ ok[y];\n        }\n    if (nrs == 0)\n        ok[x] = 1;\n\n    ok[x] ^= (nrs & 1);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++ i)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        V[x].push_back(y);\n        V[y].push_back(x);\n    }\n    if (V[1].size() == 1)\n    {\n        printf(\"Alice\\n\");\n        return 0;\n    }\n\n    dfs(1, 0);\n    if (ok[1])\n        printf(\"Alice\\n\");\n    else\n        printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fr first\n#define sc second\nconst int inf=INT_MAX;\nconst int nmax=1e5+5;\nconst int mod=1e9+7;\ntypedef long long ll;\nusing namespace std;\nint n,x,y,i,a[nmax];\nint main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n   cin>>n;\n   for(i=1;i<n;i++)\n   {\n   \tcin>>x>>y;\n   \ta[x]++;\n   \ta[y]++;\n   }\n   if(a[1]==1 || (n-1)%2!=0)cout<<\"Alice\"<<endl;\n   else cout<<\"Bob\"<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > Graph;\n\nGraph g;\n\nint dfs(int cur, int par) {\n\tint res = 0, cnt = 0;\n\tfor (int nex : g[cur]) {\n\t\tif (nex == par) continue;\n\t\tcnt++;\n\t\tres ^= dfs(nex, cur);\n\t}\n\tif (cnt == 1) res++;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tcout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb emplace_back\n#define fi first\n#define se second\n#define mp make_pair\n#define SZ(x) ((int)(x.size()))\n#define FOI(i,a,n) for(int (i)=int(a);(i)<=int(n);++(i))\n#define FOD(i,a,n) for(int (i)=int(a);(i)>=int(n);--(i))\n#define IN(x,y) ((y).find((x))!=(y).end())\n#define ALL(t) t.begin(),t.end()\n#define MSET(tabl,i) memset(tabl, i, sizeof(tabl))\n#define PSET(x,y) fixed<<setprecision(y)<<lf(x)\n#define DBG(c) cout<<#c<<\" = \"<<c<<endl;\n#define RTIME ((double)clock()/(double)CLOCKS_PER_SEC)\n\ntemplate<typename T,typename S>inline bool REMIN(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool REMAX(T&a,const S&b){return a<b?a=b,1:0;}\n\ntypedef long long ll;\ntypedef long double lf;\ntypedef pair<int, int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint bit(ll x, int pos){ return (x >> pos) & 1; }\nll power(ll base, ll exp, ll c = 1e9 + 7) { if(!exp) return 1; ll r = power(base, exp >> 1, c); r=(r*r)%c; if(exp&1) r=(r*base)%c; return r; }\n\nll T,N,M,K;  \nint a,b,c;\nstring s1,s2;\n\nconst lf PI = 2*acos(0);\nconst ll INF = 1e9 + 4;\nconst int NMAX = 3e5+5;\nconst ll MOD = 1000000007;\n\nvi eds[NMAX];\n\nint dfs(int cur, int par, int tillnow = 1) {\n\tif(SZ(eds[cur]) == 1) return tillnow;\n\tif(SZ(eds[cur]) == 2) {\n\t\tfor(int v : eds[cur]) if(v != par) return dfs(v, cur, tillnow + 1);\n\t}\n\tint ret = tillnow;\n\tfor(int v : eds[cur]) if(v != par) ret ^= dfs(v, cur, 1);\n\treturn ret;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tcin >> N;\n\tFOI(i, 1, N - 1) {\n\t\tcin >> a >> b;\n\t\teds[a].pb(b);\n\t\teds[b].pb(a);\n\t}\n\n\tint ans = 0;\n\tfor(int x : eds[1]) {\n\t\tans ^= dfs(x, 1);\n\t}\n\n\tcout << (ans ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 120000\n\nint n,f[N];\nvector<int> g[N];\n\nvoid dfs(int u,int fa){\n\tfor (int v:g[u])\n\t\tif (v!=fa){\n\t\t\tdfs(v,u);\n\t\t\tf[u]^=f[v];\n\t\t}\n\t++f[u];\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y); g[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tputs(f[1]>1?\"Alice\":\"Bob\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <stdlib.h>>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed, bool w) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b, c = 1;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (w)scanf(\"%d\", &c);\n\t\t\tcon(a - oindexed, b - oindexed, c);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//無向\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nsigned main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBiDGraph g(n);\n\tvector<int> ind(n);\n\tg.scan(n-1, 1, 0);\n\n\n\tfunction<void(int, int)> inn = [&](int c, int p) {\n\t\tREP(i, g.g[c].size()) {\n\t\t\tind[g.g[c][i].first] = i;\n\t\t}\n\t\tfor (auto itr : g.g[c]) {\n\t\t\tif (itr.first != p) {\n\t\t\t\tinn(itr.first, c);\n\t\t\t}\n\t\t}\n\t};\n\tinn(0, -1);\n\n\n\tvector<int> gr(n,INT_MAX);\n\n\tgr[g.g[0][0].first] = 0;\n\tint last = 0;\n\n\tfunction<int(int, int)> dfs = [&](int c, int p) {\n\t\tif(p >= 0)\n\t\t\tgr[c] = min(gr[c], gr[p]);\n\t\tlast = max(last, c);\n\n\t\tif ((ind[c] - 1) >= 0) {\n\t\t\tgr[c] = min(gr[g.g[p][ind[c] - 1].first], gr[c]);\n\t\t}\n\t\tint ret = gr[c];\n\n\t\tfor (auto itr : g.g[c]) {\n\t\t\tif (itr.first != p) {\n\t\t\t\tret = min(ret,dfs(itr.first, c));\n\t\t\t\tgr[itr.first] = min(ret, gr[c]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\tdfs(0, -1);\n\tprintf(!gr[last] ? \"Alice\\n\" : \"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 101000;\n\nvector <int> adj[N];\nint val[N];\n\n// if fix 1, we have a green hackenbush\n\nint dfs(int u, int l) {\n\tval[u] = 0;\n\tfor (int x: adj[u]) {\n\t\tif (x == l) continue;\n\t\tval[u]^=(dfs(x, u)+1);\n\t}\n\treturn val[u];\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t}\n\t\n\tdfs(1, -1);\n\tif(val[1] == 0) {\n\t\tprintf(\"Bob\\n\");\n\t} else {\n\t\tprintf(\"Alice\\n\");\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\n#define INF 1<<30\n#define eps 1e-9\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg_var(x) clog << #x  << \": \" << x << endl;\n    #define dbg_array(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg_var(x)\n    #define dbg_array(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n// This should not compile if used.\nconst int MAXN = 120000;\n\nvector<int> aa[MAXN];\nint dfs(int v, int p) {\n    int deg = 0;\n    int res = 0;\n    for (int a : aa[v]) {\n        if (a == p) continue;\n        deg++;\n        res ^= dfs(a, v);\n    }\n    if (deg == 1) return res + 1;\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in online problems!\n    int N;\n    cin >> N;\n    for (int i = 0; i < N-1; i++) {\n        int a,b;\n        cin >> a >> b;\n        a--, b--;\n        aa[a].push_back(b);\n        aa[b].push_back(a);\n    }\n    cout << (dfs(0, -1) ? \"Alice\" : \"Bob\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstruct IO_Tp\n{\n\tbool is_digit(const char ch)\n\t{\n\t\treturn '0' <= ch && ch <= '9';\n\t}\n\t\n\tIO_Tp& operator>>(int& res)\n\t{\n\t\tres = 0;\n\t\tstatic char ch;\n\t\twhile (ch = getchar(), !is_digit(ch))\n\t\t\t;\n\t\tdo\n\t\t\t(res *= 10) += ch & 15;\n\t\twhile (ch = getchar(), is_digit(ch));\n\t\treturn *this;\n\t}\n} IO;\n\nconst int Max_N(100005);\n\nint N, Total(1), Head[Max_N], Next[Max_N * 2], To[Max_N * 2];\n\nint sg(const int v, const int p = 0)\n{\n\tint res(0);\n\tfor (int e(Head[v]); e; e = Next[e])\n\t\tif (To[e] != p)\n\t\t\tres ^= sg(To[e], v) + 1;\n\treturn res;\n}\n\nint main(int argc, char** argv)\n{\n\tIO >> N;\n\t\n\tfor (int i(1), v, w; i != N; ++i)\n\t{\n\t\tIO >> v >> w;\n\t\tNext[Total] = Head[v], To[Total] = w, Head[v] = Total++;\n\t\tNext[Total] = Head[w], To[Total] = v, Head[w] = Total++;\n\t}\n\t\n\tputs(sg(1) ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>//WA\nusing namespace std;\n\nvector<int> G[100001];\nbool visited[100001];\n\nint dfs(int v, int dep){\n    int g=0;\n    for(int i=0; i<G[v].size(); i++){\n        if(visited[G[v][i]]==0){\n            visited[G[v][i]]=1;\n            g^=dfs(G[v][i],dep+1);\n        }\n    }\n    return dep+g;\n}\n\nint main(){\n    //input\n    int N;\n    cin >> N;\n    int x,y;\n    N--;\n    while(N--){\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    //calc\n    int grundy=0;\n    for(int i=0; i<=100000; i++){\n        visited[i]=0;\n    }\n    visited[1]=1;\n    for(int i=0; i<G[1].size(); i++){\n        visited[G[1][i]]=1;\n        grundy^=dfs(G[1][i],1);\n    }\n\n    //output\n    if(grundy!=0){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n    system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define CVector CPoint\n#define INF 0x3f3f3f3f\n#define MAXN 1e5\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-10;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-')f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\nvector<int> E[100005];\nint a[100005];\nbool v[100005];\nint sd;\nvoid dfs(int i,int d){\n    v[i]=true;\n    a[d]+=E[i].size();\n    for(int j=0;j<E[i].size();j++){\n        if(!v[E[i][j]]) dfs(E[i][j],d+1);\n    }\n    sd=max(sd,d);\n}\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    int n;cin>>n;\n    for(int i=1;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        E[x].push_back(y);\n        E[y].push_back(x);\n    }\n    sd=1;\n    dfs(1,1);\n    for(int i=1;i<sd;i++){\n        if(a[i]%2){\n            cout<<\"Alice\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Bob\"<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[100000];\n\nint dfs(int idx, int pre = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == pre) continue;\n    ret ^= dfs(to, idx) + 1;\n  }\n  return (ret);\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int X, Y;\n    cin >> X >> Y;\n    --X, --Y;\n    g[X].push_back(Y);\n    g[Y].push_back(X);\n  }\n  if(dfs(0, -1)) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0xccccccc;\nconst ll LINF = 0xcccccccccccccccLL;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\n#define N 100100\n\n//head\n\nint n;\nvi G[N];\n\nunsigned int dfs(int i, int j) {\n  unsigned int grundy = 0;\n  for(int ne:G[i]) {\n    if(ne == j) continue;\n    grundy ^= dfs(ne, i)+1;\n  }\n  return grundy;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  rep(i, n-1) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  cout << (dfs(0, -1)?\"Alice\\n\":\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/******************************************\n*    AUTHOR:         CHIRAG AGARWAL       *\n*    INSTITUITION:   BITS PILANI, PILANI  *\n******************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL; \ntypedef long double LD;\nconst int MAX=1e5+5;\nvector<int> adj[MAX];\n\nint st[MAX];\n\nvoid dfs(int s,int p)\n{\n    int cm=0;\n    for(int i=0;i<adj[s].size();i++)\n    {\n        int u=adj[s][i];\n        if(u!=p)\n        {\n            cm++;\n            dfs(u,s);\n            st[s]^=(st[u]+1);\n        }\n    } \n}\nint main() \n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    if(adj[1].size()==1)\n    {\n        printf(\"Alice\\n\");\n        return 0;\n    }\n    int ans=0;\n    for(int i=0;i<adj[1].size();i++)\n    {\n        dfs(adj[1][i],1);\n        ans^=(st[adj[1][i]]+1); \n    }    \n    if(!ans)\n    {\n        printf(\"Bob\\n\");\n    }\n    else\n    {\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nconst int MAXN = 100005;\nvector <int> G[MAXN];\nbool win[MAXN];\nvoid dfs(int pos, int prev)\n{\n\tint wc = 0, lc = 0;\n\tfor (int i = 0; i < G[pos].size(); ++i)\n\t{\n\t\tif(G[pos][i] != prev)\n\t\t{\n\t\t\tdfs(G[pos][i], pos);\n\t\t\tif(win[G[pos][i]])\n\t\t\t\twc++;\n\t\t\telse\n\t\t\t\tlc++;\n\t\t}\n\t}\n\twc%=2;\n\tlc%=2;\n\twin[pos] = (wc || lc);\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor (int i = 0; i < n - 1; ++i)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tif(win[1])\n\t\tcout<<\"Alice\\n\";\n\telse\n\t\tcout<<\"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;\n\tinline char Gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void Gi(I&x){\n\t\tfor(c=Gc();c<'0'||c>'9';c=Gc());\n\t\tfor(x=0;c<='9'&&c>='0';c=Gc())x=x*10+(c&15);\n\t}\n};\nusing io::Gi;\nint N,T;\nstruct edge{\n\t   int adj,nex;\n\t   edge (int a_=0,int n_=0){\n\t\t\tadj=a_;\n\t\t\tnex=n_;\n\t   }\n}E[333333];\nvoid add(int u,int v){\n\t   E[++T]=edge(v,E[u].nex);\n\t   E[u].nex=T;\n\t   E[++T]=edge(u,E[v].nex);\n\t   E[v].nex=T;\n}\nint dfs(int x,int f){\n\tint s=0;\n\tfor (int i=E[x].nex;i;i=E[i].nex){\n\t\tif (E[i].adj!=f){\n\t\t   s^=(dfs(E[i].adj,x)+1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint u,v;\n\tGi(N);\n\tT=N;\n\tfor (int i=1;i!=N;i++){\n\t\tGi(u);\n\t\tGi(v);\n\t\tadd(u,v);\n\t}\n\tprintf(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,x[100010];\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++)x[i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;cin>>a>>b;a--,b--;\n\t\tx[a]++,x[b]++;\n\t}\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(x[i]%2==1)cnt++;\n\t}\n\tif(cnt%2==1)cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<set>\n#include<map>\n#include<cstring>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 200010;\n\nstruct edge{\n\tint x,nxt;\n}e[N*2];\nint h[N],tot;\nint f[N];\nint n;\n\nvoid inse(int x,int y){\n\te[++tot].x=y;\n\te[tot].nxt=h[x];\n\th[x]=tot;\n}\n\nbool vis[N];\n\nvoid dfs(int x){\n\tf[x]=0;\n\tvis[x]=1;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (!vis[e[p].x]){\n\t\tdfs(e[p].x);\n\t\tf[x]^=(f[e[p].x]+1);\n\t}\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n-1){\n\t\tint x=get(),y=get();\n\t\tinse(x,y);\n\t\tinse(y,x);\n\t}\n\tdfs(1);\n\tif (f[1])printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else assert(false);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define N  51000\nint cmp(const void *a,const void *b) {\nreturn *(int *)a-*(int *)b;\n}\nint a[N];\nint sum[N];\ndouble all[N];\ndouble ss(int a,double b) {\nreturn (1.0*a-b)*(1.0*a-b);\n}\ndouble  Min(double a,double b) {\nreturn a>b?b:a;\n}\nint main() {\n    int n,m,i,t;\n    double ans,maxx;\n    scanf(\"%d\",&t);\n    while(t--) {\n        scanf(\"%d%d\",&n,&m);\n        for(i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n            qsort(a+1,n,sizeof(a[0]),cmp);\n            sum[0]=0;\n        for(i=1;i<=n;i++)\n            sum[i]=sum[i-1]+a[i];\n        for(i=1;i<=m+1;i++)\n    all[i]=1.0*(sum[i+n-m-1]-sum[i-1])/(n-m);\n  //  printf(\"%d\\n\",sum[n-m]);\n // printf(\"%.10f\\n\",all[1]);\n ans=0;\n        for(i=1;i<=n-m;i++)\n            ans+=1.0*ss(a[i],all[1]);\n            maxx=ans;\n        //   printf(\"%.10f\\n\",maxx);\n            for(i=2;i<=m+1;i++) {\n            ans=ans-2.0*(sum[i+n-m-2]-sum[i-1])*(all[i]-all[i-1])-1.0*ss(a[i-1],all[i-1])+1.0*ss(a[i+n-m-1],all[i])+(n-m-1)*(all[i]*all[i]-all[i-1]*all[i-1]);\n            maxx=Min(maxx,ans);\n            }\n   printf(\"%.10f\\n\",maxx);\n    }\nreturn 0;}\n"
  },
  {
    "language": "C++",
    "code": "/******************************************\n*    AUTHOR:         CHIRAG AGARWAL       *\n*    INSTITUITION:   BITS PILANI, PILANI  *\n******************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL; \ntypedef long double LD;\nconst int MAX=1e5+5;\nvector<int> adj[MAX];\n\nint st[MAX];\n\nvoid dfs(int s,int p)\n{\n    int cm=0;\n    for(int i=0;i<adj[s].size();i++)\n    {\n        int u=adj[s][i];\n        if(u!=p)\n        {\n            cm++;\n            dfs(u,s);\n            st[s]^=st[u];\n        }\n    } \n    if(cm%2)\n    {\n        st[s]^=1;\n    }\n}\nint main() \n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    if(adj[1].size()==1)\n    {\n        printf(\"Alice\\n\");\n        return 0;\n    }\n    dfs(1,0);\n   // printf(\"%d\\n\",st[1]);\n    if(st[1]==0)\n    {\n        printf(\"Bob\\n\");\n    }\n    else\n    {\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n;\nint x, y;\n\nint main()\n{\n\tcin >> n;\n\tint a, b;\n\tx = y = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tif (a == b)\n\t\t\tcontinue;\n\n\t\tif (a == 1 || b == 1)\n\t\t\tx++;\n\t\telse\n\t\t\ty++;\n\t}\n\tif (x == 1)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t{\n\t\tint xx = x % 2;\n\t\tint yy = y % 2;\n\t\tif (xx + yy == 1)\n\t\t\tcout << \"Alice\" << endl;\n\t\telse\n\t\t\tcout << \"Bob\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\nint dfs(vv<int> &g,int v,int p){\n  int re=0;\n  for(int w:g[v])if(w!=p) re^=dfs(g,w,v);\n  return re+1;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vv<int> g(n);\n  rep(i,n-1){\n    int x,y;\n    cin>>x>>y; --x; --y;\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  cout<<(dfs(g,0,-1)==1?\"Bob\":\"Alice\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define LL long long\n#define PB push_back\n#define MP make_pair\n#define I insert\n \nconst LL N = 1e5+5, mod = 1000000007;\n \nusing namespace std;\n \nLL n, m, i, j, k, l, r, t, ans, a[N];\nvector < LL > v[N];\n\nvoid go ( LL u, LL par = 0 ){\n\tfor ( LL i = 0; i < v[u].size(); ++i ){\n\t\tif ( v[u][i] == par ) continue;\n\t\tgo ( v[u][i], u );\n\t\ta[u] ^= a[v[u][i]];\n\t}\n\tif ( u == 1 && v[u].size() == 1 || u != 1 && v[u].size() == 2 ) a[u]++;\n}\n\nint main(){\n\tcin >> n;\n\tfor ( i = 1; i < n; ++i ){\n\t\tcin >> l >> r;\n\t\tv[l].PB(r);\n\t\tv[r].PB(l);\n\t}\n\t\n\tgo(1);\n\t\n\tif ( a[1] ) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\t\n\treturn 0;\n}\n \n/**/\n//      IIIIIIIII      OOOOO             A          NN        N    EEEEEEEEEE\n//          I         O     O           A A         N N       N    E\n//          I        O        O         A   A        N  N      N    E\n//          I        O       O        A     A       N   N     N    E\n//          I        O       O       AAAAAAAAA      N    N    N    EEEEEEEE\n//          I        O       O      A         A     N     N   N    E\n//          I        O       O     A           A    N      N  N    E\n//          I         O     O     A             A   N       N N    E\n//      IIIIIIIII      OOOOO     A               A  N        NN    EEEEEEEEEE ___ KAPANADZE"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn = 100100;\nint n;\nvector<int> mp[maxn];\nint sg[maxn];\nvoid dfs(int u, int f){\n    for(int i = 0; i < mp[u].size(); ++i)if(mp[u][i] != f){\n        dfs(mp[u][i], u);\n        sg[u] ^= sg[mp[u][i]] + 1;\n    }\n    return ;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 2; i <= n; ++i){\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        mp[a].push_back(b);\n        mp[b].push_back(a);\n    }\n    dfs(1,1);\n    //for(int i = 1; i <= n; ++i)printf(\"sg[%d] = %d\\n\", i, sg[i]);\n    if(sg[1])cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repdi(i,a,b) for(ll i=(a)-1;i>=(b);--i)\n#define repd(i,a) repdi(i,a,0)\n#define itr(it,a) for( auto it = (a).begin(); it != (a).end(); ++it )\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define endl '\\n'\n#define debug(x) std::cerr << #x << \" = \" << (x) << endl;\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class S, class T>\nstd::ostream& operator<< ( std::ostream& out, const std::pair<S,T>& a )\n{ std::cout << '(' << a.first << \", \" << a.second << ')'; return out; }\n\ntemplate<class T>\nstd::ostream &operator<< ( std::ostream& out, const std::vector<T>& a )\n{ std::cout << '['; rep( i, a.size() ){ std::cout << a[i]; if( i != a.size()-1 ) std::cout << \", \"; } std::cout << ']'; return out; }\n\nll N;\nstd::vector<ll> G[100010];\nll g[100010];\n\nbool dfs( ll v, ll p = -1 ) {\n  g[v] = 0;\n\n  bool used[2] = { false, false };\n  bool leaf = true;\n  ll cnt = 0;\n\n  for( auto u : G[v] ) if( u != p ) {\n    bool fl = dfs( u, v );\n\n    ++cnt;\n    leaf = false;\n\n    if( fl ) \n      continue;\n\n    g[u] %= 2;\n    g[v] += g[u];\n    g[v] %= 2;\n  }\n\n  if( leaf )\n    return leaf;\n\n  if( cnt == 1 )\n    g[v] = 1;\n  else if( cnt%2 == 1 && used[1] && !g[v] )\n    g[v] = 1;\n\n  return leaf;\n}\n\nint main() {\n  std::cin >> N;\n\n  rep( i, N-1 ) {\n    ll x, y;\n    std::cin >> x >> y;\n    --x; --y;\n\n    G[x].emplace_back( y );\n    G[y].emplace_back( x );\n  }\n\n  if( G[0].size() == 1 ) {\n    puts(\"Alice\");\n\n    return 0;\n  }\n\n  dfs( 0 );\n\n  puts( g[0] ? \"Alice\" : \"Bob\" );\n\n  //rep( i, N )\n    //printf( \"g[%lld] = %lld\\n\", i, g[i] );\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n\nconst int mxn = 100006;\n\nint n;\nvi e[mxn];\n\nint dfs(int x, int p) {\n\tint s = 0;\n\tfor (auto i : e[x]) if (i != p)\n\t\ts ^= dfs(i, x) + 1;\n\treturn s;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\t\n\tputs(dfs(1, 0) ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[100010];\nvector<int> T[100010];\n\nvoid gtot(int c,int p){\n  for(int i:G[c]){\n    if(i==p)continue;\n    gtot(i,c);\n  }\n  T[p].push_back(c);\n}\n\nint xortree(int x){\n  int a=0;\n  if(T[x].size()==0){\n    return 1;\n  }\n  if(T[x].size()==1){\n    a=xortree(T[x][0])+1;\n    return a;\n  }\n  for(int i:T[x]){\n    a^=xortree(i);\n  }\n  return a+1;\n}\n\nint main(){\n  int N,a,b;\n  cin>>N;\n  for(int i=0;i<N-1;i++){\n    cin>>a>>b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  gtot(1,0);\n  if(xortree(1)-1)cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,cnt,last[N],sg[N];\nstruct edge{int to,next;}e[N*2];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nvoid addedge(int u,int v)\n{\n    e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;\n    e[++cnt].to=u;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x,int fa)\n{\n    for (int i=last[x];i;i=e[i].next)\n    {\n        if (e[i].to==fa) continue;\n        dfs(e[i].to,x);\n        sg[x]^=sg[e[i].to]+1;\n    }\n}\n\nint main()\n{\n    n=read();\n    for (int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y);\n    }\n    dfs(1,0);\n    if (sg[1]) puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (llong i = 0ll; i < (llong) n; ++i)\n#define fornn(i, l, r) for (llong i = (llong) l; i < (llong) r; ++i)\n#define size(x) ((int) (x.size()))\n \nusing namespace std;\n \ntypedef long long llong;\nconst llong inf = (llong) 1e+9 + 7ll;\nconst llong linf = (llong) 1e+18 + 7ll;\nconst long double eps = (long double) 1e-9;\nconst long double pi = acosl((long double) -1.0);\nconst int alph = 26;\n\nmt19937 mrand(random_device{} ()); \n\ntemplate<typename T, typename U> inline llong umin(const T& a, const U& b) { return a < b ? a : b; }\ntemplate<typename T, typename U> inline llong umax(const T& a, const U& b) { return a > b ? a : b; }\n \nstatic char buff[(int) 2e6 + 17]; // reads std::string\nconst int maxn = (int) 1e5 + 17;\n\nint n;\nvector<int> g[maxn];\n\nbool read()\n{\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\n\tforn (i, n - 1)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tg[u - 1].push_back(v - 1);\n\t\tg[v - 1].push_back(u - 1);\n\t}\n\n\treturn true;\n}\n\nint dfs(int v, int pr)\n{\n\tint gr = 0;\n\t\n\tfor (auto to : g[v])\n\t\tif (to != pr)\n\t\t\tgr ^= dfs(to, v);\n\n\treturn gr + 1;\n}\n\nvoid solve()\n{\n\tif (dfs(0, -1) == 1)\n\t\tprintf(\"Bob\\n\");\n\telse\n\t\tprintf(\"Alice\\n\");\n}\n\nint main()\n{\n#if SEREZHKA\n\tfreopen(\"file.in\", \"r\", stdin);\n#endif\n\n\twhile (read())\n\t\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    sg[i]=0;\n    set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        s.insert(sg[g[i][j]]);\n    }\n    for(long j=0,l=s.size();j<l;j++)\n    {\n        if(sg[i]==*s.begin()){s.erase(s.begin());sg[i]++;}\n        else break;\n    }\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1]||g[1].size()==1)cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 200005\nint head[M],to[M<<1],nxt[M<<1],tot;\ninline void add(int a,int b){\n\tto[++tot]=b;\n\tnxt[tot]=head[a];\n\thead[a]=tot;\n}\nint n,sg[M];\nvoid dfs(int x,int f){\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=to[i];\n\t\tif(y==f)continue;\n\t\tdfs(y,x);\n\t\tsg[x]^=(sg[y]+1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b),add(b,a);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint dp[110000];\nvector<int>g[110000];\nint dfs(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tdfs(g[a][i],a);\n\t}\n\tint t=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tt^=(dp[g[a][i]]+1);\n\t}\n\treturn dp[a]=t;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tint ret=dfs(0,-1);\n\tif(ret)printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    sg[i]=0;\n    set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        s.insert(sg[g[i][j]]);\n    }\n    for(long j=0,l=s.size();j<l;j++)\n    {\n        if(sg[i]==*s.begin()){s.erase(s.begin());sg[i]++;}\n        else break;\n    }\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    //for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1])cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N];\nint dp [MAX_N];\n\nvoid dfs (int u, int p) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, u);\n\n      dp[u] ^= dp[nxt] + 1;\n    }\n  }\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  dfs(1, 0);\n\n  if (dp[1] == 0) {\n    cout << \"Bob\" << endl;\n  } else {\n    cout << \"Alice\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) FOR(i,0,n)\n#define ROF(i,a,b) for(ll i=a;i>=b;i--)\n#define per(i,a) ROF(i,a,0)\n#define pb push_back\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ch=char;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vP;\ntypedef vector<ch> vc;\ntypedef vector<vc> vvc;\nconst ll MOD=1000000007;\nconst ll MOD2=998244353;\nconst ld PI=acos(-1);\nconst ll INF=1e18;\nstruct edge{ll to,cost;};\nstruct edge2{ll from,to,cost;};\n\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nint cnt1,cnt2;\nconst int MXV=100005;\nvl G[MXV];\nvl d(MXV,0);\n\nvoid dfs(int v,int p){\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){\n            dfs(G[v][i],v);\n          \td[v]^=d[G[v][i]]+1;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    dfs(1,0);\n    if(d[1]==0){\n        cout << \"Bob\" << endl;\n    }\n    else{\n        cout << \"Alice\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 200020\nusing namespace std;\nnamespace IO{\n\tconst int BS=(1<<20); int Top=0;\n\tchar Buffer[BS],OT[BS],*OS=OT,*HD,*TL,SS[20]; const char *fin=OT+BS-1;\n\tchar Getchar(){if(HD==TL){TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);} return (HD==TL)?EOF:*HD++;}\n\tvoid flush(){fwrite(OT,1,OS-OT,stdout);}\n\tvoid Putchar(char c){*OS++ =c;if(OS==fin)flush(),OS=OT;}\n\tvoid write(int x){\n\t\tif(!x){Putchar('0');return;} if(x<0) x=-x,Putchar('-');\n\t\twhile(x) SS[++Top]=x%10,x/=10;\n\t\twhile(Top) Putchar(SS[Top]+'0'),--Top;\n\t}\n\tint read(){\n\t\tint nm=0,fh=1; char cw=Getchar();\n\t\tfor(;!isdigit(cw);cw=Getchar()) if(cw=='-') fh=-fh;\n\t\tfor(;isdigit(cw);cw=Getchar()) nm=nm*10+(cw-'0');\n\t\treturn nm*fh;\n\t}\n}\nusing namespace IO;\nint n,fs[M],nt[M],to[M],tmp;\nvoid link(int x,int y){nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;}\nint DP(int x,int last){\n\tint sg=0;\n\tfor(int i=fs[x];i!=-1;i=nt[i]) if(to[i]!=last) sg^=(DP(to[i],x)+1);\n\treturn sg;\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tn=read(),memset(fs,-1,sizeof(fs));\n\tfor(int i=1;i<n;i++){int x=read(),y=read();link(x,y),link(y,x);}\n\tputs(DP(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2000000000;//10^9\nll MOD  = 998244353;\nvector<vector<int>> edge(100010, vector<int>(0));\nvector<int> parent(100010, -1);\nvector<bool> vis(100010, 0);\nvector<int> child[100010];\n\nvoid makeParent(int N){\n    vis.at(N) = 1;\n    for(int i = 0; i < edge.at(N).size(); i++){\n        if(vis.at(edge.at(N).at(i)) == 0){\n            parent.at(edge.at(N).at(i)) = N;\n            makeParent(edge.at(N).at(i));\n            child[N].push_back(edge.at(N).at(i));\n        }\n    }\n}\nvector<int> memo(100010, -1);\n\nint grundy(int x){\n    if(memo.at(x) != -1) return memo.at(x);\n    \n    if(child[x].size() == 0)return 0;\n    \n    int XOR = grundy(child[x][0]);\n    for(int i = 1; i < child[x].size(); i++){\n        XOR ^= grundy(child[x][i]);\n    }\n    \n    if(XOR == 0){\n        if(child[x].size() == 1){\n            XOR = 1;\n        }\n    }\n    \n    return memo.at(x) = XOR;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N-1; i++){\n        int x,y;\n        cin >> x >> y;\n        x--,y--;\n        edge.at(x).push_back(y);\n        edge.at(y).push_back(x);\n    }\n    \n    makeParent(0);\n    \n    if(grundy(0)){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, x, n) for (int i = int(x); i <= int(n); ++i)\n#define for1(i, n, x) for (int i = int(n); i >= int(x); --i)\n#define F first\n#define S second\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef long double ld;\ntypedef vector <ll> vi;\n\nconst int N = 2e6 + 1;\nconst ll INF = 1e18 + 9;\nconst int B = 1e9 + 7;\n\nint n;\nvi g[N];\nint a[N];\nint u[N], timer;\n\nvoid calc(int x, int pr, int cur) {\ncerr <<x << \" \" << pr << \"\\n\";\n    u[cur] = timer;\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        cur ^= a[to];\n    }\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        calc(to, x, cur ^ a[to]);\n    }\n}\n\nvoid dfs(int x, int pr = -1) {\n    int cur = 0;\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        dfs(to, x);\n        cur ^= a[to];\n    }\n    timer++;\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        calc(to, x, cur ^ a[to]);\n    }\n    //if (x == 3) exit(0);\n    forn(i, 0, N - 1)\n        if (u[i] != timer) {\n            a[x] = i;\n            return;\n        }\n}\n\nint main() {\n    #ifdef black\n    freopen(\"in\", \"r\", stdin);\n    #endif // black\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n;\n    forn(i, 1, n - 1) {\n        int f, t;\n        cin >> f >> t;\n        g[f].pb(t);\n        g[t].pb(f);\n    }\n    dfs(1);\n    cout << (a[1] ? \"Alice\\n\" : \"Bob\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;  \n    vector<int> e[n];\n    for (int i = 0; i < n-1; i++) {\n        int a, b; cin >> a >> b; a--, b--;\n        e[a].emplace_back(b);\n        e[b].emplace_back(a);\n    }\n    auto dfs = [&e](auto f, int curr, int prev) -> int {\n        int ret = 0;\n        for (auto &to: e[curr]) {\n            if (prev == to) continue;\n            ret ^= f(f, to, curr);\n        }\n        return ret + 1;\n    };\n    int ok = dfs(dfs, 0, -1) - 1;\n    if (ok) cout << \"Alice\\n\";\n    else cout << \"Bob\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 1e5 + 10;\n\nvector<int> graph[MAX_SIZE];\nvector<bool> visited(MAX_SIZE);\n\nll dfs(int a)\n{\n\tvisited[a] = true;\n\tvector<ll> G;\n\tfor(auto &u : graph[a])\n\t{\n\t\tif(!visited[u])\n\t\t{\n\t\t\tG.pb(dfs(u));\n\t\t}\n\t}\n\tif(G.size() == 1)\n\t\treturn 1 + G[0];\n\telse if(G.size() == 0)\n\t\treturn 0;\n\tll s = 0;\n\tfor(auto &g : G)\n\t{\n\t\ts ^= g;\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tint x, y;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tcin >> x >> y;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t\tvisited[x] = false;\n\t\tvisited[y] = false;\n\t}\n\tll s = dfs(1);\n\tif(s == 0)\n\t\tcout << \"Bob\" << endl;\n\telse\n\t\tcout << \"Alice\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\n\n\nstruct Problem{\n    int n,cnt,b;\n    vector<vector<int>> t;\n    vector<int> vis,dep;\n    set<int> od;\n    Problem(LL n):n(n),cnt(0),t(n),vis(n),dep(n){};\n    void dfs(int cur){\n        od.erase(cur);\n        if((int)t[cur].size()==1 and cur!=0){\n            return;\n        }\n        for(auto x:t[cur]){\n            if(dep[x]>dep[cur]){\n                dfs(x);\n            }\n        }\n    }\n    void solve(){\n        for(int i=0; i<n-1; ++i){\n            int a,b;\n            cin >> a >>b;\n            --a;--b;\n            t[a].push_back(b);\n            t[b].push_back(a);\n        }\n        queue<int> Q;\n        Q.push(0);\n        while(!Q.empty()){\n            int tmp=Q.front();\n            vis[tmp]=1;\n            Q.pop();\n            if(((int)t[tmp].size()-(tmp!=0))%2==1){\n                od.insert(tmp);\n                if(od.size()==1) b=tmp;\n            }\n            for(auto x:t[tmp]){\n                if(vis[x]==0){\n                    Q.push(x);\n                    dep[x]=dep[tmp]+1;\n                }\n            }\n        }\n        if(od.empty()){\n            cout << \"Alice\"<<\"\\n\";\n            return;\n        }\n        DBG(od)\n        od.erase(b);\n        int aa=od.size();\n        for(auto y:t[b]){\n            if(dep[y]>dep[b]){\n                dfs(y);\n                DBG(od)\n                if(od.size()<aa and od.size()>0){\n                    cout << \"Bob\"<<\"\\n\";\n                    return ;\n                }else if(od.empty()){\n                    cout << \"Alice\"<<\"\\n\";\n                    return ;\n                }\n            }\n        }\n        if(od.empty())cout << \"Alice\"<<\"\\n\";\n        else cout << \"Bob\"<<\"\\n\";\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nint dp[100000];\nvector<int>E[100000];\nbool used[100000];\n\nint dfs(int v) {\n\tused[v] = true;\n\tint res = 0;\n\tset<int>s;\n\tfor (int u : E[v]) {\n\t\tif (!used[u]) {\n\t\t\tres ^= dfs(u);\n\t\t}\n\t\ts.insert(res);\n\t}\n\tfor (int i = 0;; i++) {\n\t\tif (!s.count(i))\n\t\t\treturn i;\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n\t\tE[x].push_back(y); E[y].push_back(x);\n\t}\n\tif (n > 50000)puts(dfs(0) ? \"Alice\" : \"Bob\");\n\telse puts(dfs(0) ? \"Bob\" : \"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double Double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n// chmax, chmin\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n\nvector<int> g[100010];\n\n\nint grundy(int n, int p) {\n    set<int> G;\n    for (auto i : g[n]) {\n        if (i != p) {\n            G.insert(grundy(i, n));\n        }\n    }\n    int s = 0;\n    while (G.count(s)) s++;\n    return s;\n\n}\n\nvoid solve(long long N, std::vector<long long> x, std::vector<long long> y) {\n    for (int i = 0; i < N - 1; i++) {\n        x[i]--;\n        y[i]--;\n        g[x[i]].push_back(y[i]);\n        g[y[i]].push_back(x[i]);\n    }\n    int ans = 0;\n    for (auto i : g[0]) {\n        ans ^= grundy(i, 0);\n    }\n    if (ans) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n    std::vector<long long> x(N - 1);\n    std::vector<long long> y(N - 1);\n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%lld\", &x[i]);\n        scanf(\"%lld\", &y[i]);\n    }\n    solve(N, std::move(x), std::move(y));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, sg[200007];\nvector<int>e[200007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint dfs(int w, int f)\n{\n\tfor (int i = e[w].size() - 1; i >= 0; i--)\n\t\tif (e[w][i] != f)\n\t\t\tsg[w] ^= dfs(e[w][i], w) + 1;\n\treturn sg[w];\n}\nint main()\n{\n\tn = read();\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a = read(), b = read();\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tcout << (dfs(1, 0) ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint sg[100001];\nint n,p,q;\nbool in[100001];\nvector<int>c[100001];\nvector<int>adj[100001];\nvoid build(int id){\n\tin[id]=true;\n\tfor(int i=0; i<adj[id].size() ;i++){\n\t\tint cur=adj[id][i];\n\t\tif(in[cur]) continue;\n\t\tc[id].push_back(cur);\n\t\tbuild(cur);\n\t}\n}\nvoid cal(int id){\n\tif(c[id].size()==0){\n\t\tsg[id]=0;\n\t\treturn;\n\t}\n\tbool have0=false,have1=false;\n\tfor(int i=0; i<c[id].size() ;i++){\n\t\tif(sg[c[id][i]]==0) have0=true;\n\t\telse have1=true;\n\t}\n\tif(have0 && have1) sg[id]=1;\n\telse sg[id]=c[id].size()%2;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<n ;i++){\n\t\tcin >> p >> q;\n\t\tadj[p].push_back(q);\n\t\tadj[q].push_back(p);\n\t}\n\tbuild(1);\n\tcal(1);\n\tif(sg[1]==0) cout << \"Bob\\n\";\n\telse cout << \"Alice\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n;\nint sg[maxn];\nvector<int> G[maxn]; \nvoid dfs(int u, int last) {\n\tfor(int i = 0; i < G[u].size(); ++i) {\n\t\tint v = G[u][i];\n\t\tif(v == last) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v, u);\n\t\tsg[u] ^= sg[v] + 1;\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long double ldo;\n\n#define pb push_back\nconst int MAX = 1234567;\nlong long n, x, res;\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tres = 0;\n\tfor (auto i : g[v])\n\t\tif (i != r)\n\t\t\tres ^= dfs (i, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tx = dfs (0,-1);\n\n\tcout << (x==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint n;\nvector<int> es[100000];\n\nbool solve(int v, int pa) {\n\tint l = 0, w = 0;\n\tREP(i, es[v].size()) if (es[v][i] != pa) {\n\t\tif (solve(es[v][i], v)) ++w;\n\t\telse ++l;\n\t}\n\treturn w % 2 == 1 || l % 2 == 1;\n}\n\nint main(int argc, char **argv) {\n\tcin >> n;\n\tREP(i, n - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tes[x].push_back(y);\n\t\tes[y].push_back(x);\n\t}\n\tcout << (solve(0, -1) ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>          \n#include <map>           \n#include <list>\n#include <ctime>\n#include <deque>         \n#include <bitset>        \n#include <vector>\n#include <list>\n#include <stack>\n#include <random>\t\t \n#include <string>       \n#include <numeric>      //  needed for  accumulate\n#include <utility>      // needed for std:: move\n#include <iterator> \n#include <iostream>   \n#include <algorithm> \n#include <functional>    \n#include <cmath>         \n#pragma warning(disable:4996) // ignore this\n#define ve vector\n#define pb push_back\n#define mp make_pair                     \n#define srt(x) sort(x.begin(),x.end())         \n#define mod static_cast<long long> (1e9+7)     \n#define sumx(x) accumulate(x.begin(),x.end(),0LL)\n#define pi 3.14159265358979323846\nusing namespace std;\ntemplate<typename T>\nistream& operator >> (istream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin >> x;\n\treturn in;\n}\ntemplate<typename T>\nostream& operator<<(ostream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin << x << \" \";\n\treturn in;\n}\nclass solve\n{\n\tlong long n;\n\tve<bool > vis;\n\tve<ve<int> > adj;\n\tve<ve<int> > adj2;\n\tvoid dfs(int c=0)\n\t{\n\t\tvis[c]=true;\n\t\tfor(auto &x:adj[c])\n\t\t{\n\t\t\tif(!vis[x])\n\t\t\t{\n\t\t\t\tadj2[c].pb(x);\n\t\t\t\tdfs(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tint winner(int c=0)\n\t{\n\t\tvis[c]=false;\n\t\tint ans=0;\n\t\tfor(auto &x:adj2[c])\n\t\t{\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tans^=winner(x);\n\t\t\t}\n\t\t}\n\t\treturn !ans;\n\t}\npublic:\n\tsolve()\n\t{\n\t\tcin >> n;\n\t\tvis.resize(n);\n\t\tadj.resize(n);\n\t\tadj2.resize(n);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\t--x,--y;\n\t\t\tadj[x].pb(y);\n\t\t\tadj[y].pb(x);\n\t\t}\n\t\tdfs();\n\t\tint p=winner(0);\n\t\tif(!p)\n\t\t{\n\t\t\tcout << \"Alice\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"Bob\\n\";\n\t\t}\n\t}\n};\n \nint main()\n{\n\tint t = 1, i = 1;\n\t//scanf(\"%d\", &t);\n \n\twhile (t--)\n\t{\n\t\tnew solve;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/***********Template Starts Here***********/\n//copied from https://www.hackerrank.com/contests/5-days-of-game-theory/challenges/deforestation/editorial\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define FOR(i,x,y) for(vlong i = (x) ; i <= (y) ; ++i)\n#define ROF(i,x,y) for(vlong i = (y) ; i >= (x) ; --i)\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define UNIQUE(V) (V).erase(unique((V).begin(),(V).end()),(V).end())\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define SZ(x) ((vlong)(x).size())\n\nusing namespace std;\n\ntypedef long long vlong;\n\nconst vlong inf = 2147383647;\n\n/***********Template Ends Here***********/\n#define NODE 502\nvector<int> adj[NODE+10];\n\nint hackenbush ( int s, int p ) {\n\n    int res = 0;\n    FOR(i,0,SZ(adj[s])-1) {\n        int t = adj[s][i];\n\n        if ( t == p ) continue;\n\n        res ^= hackenbush ( t, s ) + 1;\n    };\n\n    return res;\n}\n\nvoid solution() {\n    int kase;\n    //scanf ( \"%d\", &kase );\n\n    //assert ( kase >= 1 && kase <= 100 );\n    kase = 1;\n    while ( kase-- ) {\n        int n;\n        scanf ( \"%d\", &n );\n\n      //  assert ( n >= 1 && n <= 500 );\n\n        FOR(i,1,n) adj[i].clear();\n\n        FOR(i,1,n-1) {\n            int u, v;\n            scanf ( \"%d %d\", &u, &v );\n            adj[u].pb ( v );\n            adj[v].pb ( u );\t\t\t\n        };\n\n        int res = hackenbush ( 1, 0 );\n\n        if ( res ) printf ( \"Alice\\n\" );\n        else printf ( \"Bob\\n\" );\n    }\n}\n\nint main () {\n\n    solution();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100010\nusing namespace std;\nint u,v,n,m,d[maxn];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n-1;i++){\n\t\tcin>>u>>v;\n\t\tif(u>v) swap(u,v);\n\t\td[u]++;\n\t}\n\tif(d[1]==1){\n\t\tcout<<\"Alice\";\n\t\treturn 0;\n\t}\n\tint ans=d[1];\n\tfor(int i=2;i<=n;i++){\n\t\tans^=d[i];\n\t}\n\tif(ans==1){\n\t\tcout<<\"Alice\";\n\t}\n\telse \n\t\tcout<<\"Bob\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<string>\n\nusing namespace std;\n\nint N;\nvector<vector<int>> E;\nvector<int> cnt;\n\nvoid dfs(int pos, int bef, int depth) {\n\tif (depth == 2) {\n\t\treturn;\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\tint nxt = E[pos][i];\n\t\tif (nxt == bef)continue;\n\t\tdfs(nxt, pos, depth);\n\t\tif (depth == 1) {\n\t\t\tc++;\n\t\t}\n\t}\n\tif (depth == 1)cnt.push_back(c);\n}\n\nint main() {\n\tcin >> N;\n\tE.resize(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tE[u].push_back(v), E[v].push_back(u);\n\t}\n\n\tdfs(0, -1, 0);\n\n\tint s = 0;\n\tfor (int i = 0; i < cnt.size(); i++)s += cnt[i];\n\tif (s % 2 == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(ll i = (ll)(s); i < (ll)(t); i++)\n#define rrep(i,s,t) for(ll i = (ll)(s-1);(ll)(t) <= i; i--)\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconstexpr ll INF = numeric_limits<ll>::max()/4;\nconstexpr ll n_max = 2e5+10;\n#define int ll\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) {return '\"' + s + '\"';}\nstring to_string(const char *c) {return to_string((string) c);}\nstring to_string(bool b) {return (b ? \"true\" : \"false\");}\ntemplate <size_t N>\nstring to_string(bitset<N> v){\n    string res = \"\";\n    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n    return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) res += \", \";\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\n\nvoid debug_out() {cerr << endl;}\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<class T>\nbool chmax(T &a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<class T>\nbool chmin(T &a, T b){if(a > b){a = b; return true;} return false;}\n\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    vector<vector<ll>> graph(n);\n    for(int i = 0; i < n-1; i++) {\n        ll a,b;cin >> a >> b;\n        a--;b--;\n        graph[a].emplace_back(b);\n        graph[b].emplace_back(a);\n    }\n    auto dfs = [&](auto self, ll now, ll pre = -1) -> ll{\n        ll sum = 0;\n        for(auto &to : graph[now]){\n            if(to == pre)continue;\n            sum ^= self(self, to, now);\n        }\n        return sum + 1;\n    };\n\n    bool ok = dfs(dfs, 0) != 1;\n    cout << (ok ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rint register int\nusing namespace std;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nint n;\nvector<int> g[233333];\n\ninline int dfs(int u, int fat) {\n  int now = 0;\n  for (int v : g[u])\n    if (v != fat)\n      now ^= 1 + dfs(v, u);\n  return now;\n}\n\nmain(void) {\n  read(n);\n  for (int i = 2; i <= n; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y); g[y].push_back(x);\n  }\n  puts( dfs(1, 0) ? \"Alice\" : \"Bob\" );\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n// #include <bits/extc++.h>\nusing namespace std;\n\n#define debug(s) cout << #s << \" = \" << s << endl\n#define all(v) (v).begin(), (v).end()\n#define KeepUnique(v) (v).erase( unique(all(v)), v.end() )\n#define MEMSET(a, val) memset(a, val, sizeof (a))\n#define PB push_back\n#define endl '\\n'\ntypedef long long ll;\n\ninline int myrand(int l, int r) {\n\tint ret = rand(); ret <<= 15; ret ^= rand();\n\tif(ret < 0) ret = -ret; ret %= (r-l+1); ret += l;\n\treturn ret;\n}\n\ntemplate <typename F, typename S>\nostream& operator << (ostream& os, const pair< F, S>& p) {\n\treturn os<<\"(\" <<p.first<<\", \"<<p.second<<\")\"; }\n\ntypedef pair<int, int> ii;\n\ntemplate<typename T> using min_pq =\n\tstd::priority_queue<T, vector<T>, greater<T> >;\n\n//int dx[] = {-1, +0, +1, +0};\n//int dy[] = {+0, +1, +0, -1};\n\nconst int maxn = 100005;\n\nint n;\nvector<int> g[maxn];\nint grundy[maxn], ok[maxn];\n\nvoid dfs(int u, int par) {\n\tfor(int v : g[u]) {\n\t\tif(v - par) {\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n\tfor(int v : g[u])\n\t\tif(v - par) ok[grundy[v]] = 1;\n\tfor(int i = 0; ; i++) {\n\t\tif(!ok[i]) {\n\t\t\tgrundy[u] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int v : g[u])\n\t\tif(v - par) ok[grundy[v]] = 0;\n}\n\nint32_t main () {\n    // freopen(\"in\", \"r\", stdin);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n    \tint u, v; cin >> u >> v;\n    \tg[u].push_back(v);\n    \tg[v].push_back(u);\n    }\n    dfs(1, -1);\n    int s = 0;\n    for(int v : g[1]) {\n    \ts ^= grundy[v];\n    }\n    puts(s ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nint x[100001];\nint y[100001];\nvector<int>G[100001];\nbool check=true;\nbool used[100001];\n//LL now=0;\nvector<int> dfs(int x,int d){\n    vector<int>ans;\n    if(used[x])return ans;\n    used[x]=true;\n    vector<int>v;\n    REP(i,G[x].size()){\n        if(used[G[x][i]]==false){\n           auto a=dfs(G[x][i],d+1);\n           REP(j,a.size()){\n           v.push_back(a[i]);\n           }\n        }\n    }\n    sort(v.begin(),v.end());\n    int me=0;\n\n    REP(i,v.size()){\n        if(v[i]==0)continue;\n        if(me==0){\n           me=v[i];\n           continue;\n        }\n        if(me!=v[i]){\n           ans.push_back(v[i]+1);\n           //check=false;\n        }else{\n           me=0;\n        }\n    }\n    //now^=d;\n    //cout<<x<<me<<endl;\n    if(me!=0)ans.push_back(me+1);\n    return ans;\n}\n\nint main(){\n    cin>>N;\n    REP(i,N-1){\n        cin>>x[i];x[i]--;\n        cin>>y[i];y[i]--;\n        G[x[i]].push_back(y[i]);\n        G[y[i]].push_back(x[i]);\n    }\n    REP(i,N){\n        used[i]=false;\n    }\n    if(N==2){\n       cout<<\"Alice\"<<endl;\n       return 0;\n    }\n    auto ans=dfs(0,0);\n    if(ans.size()!=1){\n       cout<<\"Alice\"<<endl;\n    /*}else /*if(check==false){\n       cout<<\"Alice\"<<endl;*/\n    }else{\n       cout<<\"Bob\"<<endl;\n    }\n    \n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint grundy[100000];\n\nint dfs(vector<vector<int>>& G, int pos, int par){\n  int x = 0;\n  for(auto nx : G[pos]){\n    if(nx == par) continue;\n    auto v = dfs(G, nx, pos) + 1;\n    x ^= v;\n  }\n\n  return grundy[pos] = x;\n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<vector<int>> G(n);\n  for(int i=0; i<n-1; i++){\n    int x,y;\n    cin >> x,y;\n    x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  auto ans = dfs(G, 0, -1);\n  println( ans == 0 ? \"Bob\" : \"Alice\");\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,x,y) for (int i=x;i<=y;i++)\n#define dep(i,y,x) for (int i=y;i>=x;i--)\n#define sz(x) (int)(x.size())\n\nusing namespace std;\n\ntypedef long long LL;   \ntypedef unsigned long long uLL;\n\nconst int maxn=100000+10;\n\nint n,x,y;\nvector<int> G[maxn];\n\nint DFS(int k,int fa)\n{\n    int sg=0;\n    rep(i,0,sz(G[k])-1)\n    {\n        if (G[k][i]==fa) continue;\n\n        sg^=(DFS(G[k][i],k)+1);\n    }\n    return sg;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    rep(i,2,n)\n    {\n        scanf(\"%d%d\",&x,&y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    if (DFS(1,-1)) printf(\"Alice\\n\"); else printf(\"Bob\\n\");\n\n    // system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=1e5+5;\n\nint n;\n\nint tot,go[2*maxn],nxt[2*maxn],f1[maxn];\nvoid ins(int x,int y)\n{\n\tgo[++tot]=y;\n\tnxt[tot]=f1[x];\n\tf1[x]=tot;\n}\n\nint sg[maxn];\nvoid dfs(int k,int last)\n{\n\tsg[k]=0;\n\tfor(int p=f1[k]; p; p=nxt[p]) if (go[p]!=last)\n\t{\n\t\tdfs(go[p],k);\n\t\tsg[k]^=(sg[go[p]]+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tins(x,y), ins(y,x);\n\t}\n\t\n\tdfs(1,0);\n\t\n\tprintf((sg[1]) ?\"Alice\\n\" :\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint n;\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if (g[1].size() == 1)\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        if ((n - 1 - g[1].size()) % 2 == 1)\n        {\n            cout << \"Alice\" << endl;\n        }\n        else\n        {\n            cout << \"Bob\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nvvi G;\n\nint dfs(int pos, int par) {\n\tint ret = 0;\n\tif (pos != 0 && G[pos].size() == 1) {\n\t\t// 葉\n\t\treturn 0;\n\t}\n\trep(i, G[pos].size()) {\n\t\tif (G[pos][i] == par)continue;\n\t\tret ^= dfs(G[pos][i], pos) + 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tG = vvi(N);\n\trep(i, N - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\tif (dfs(0, -1) == 0) {\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse {\n\t\tcout << \"Alice\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\n\nconst int N = 111111;\nvector<int> tree[N];\nint pl[N], xs[N];\nint n;\n\nvoid dfs(int node, int p = 0) {\n    for(nnode : tree[node]) {\n        if(nnode == p) continue;\n        dfs(nnode, node);\n    }\n    int nei = tree[node].size() - (node != 1);\n    if(nei == 0) {\n        pl[node] = 1;\n    } else if(nei == 1) {\n        int nnode = tree[node][0] == p ? tree[node][1] : tree[node][0];\n        pl[node] = pl[nnode] + 1;\n        xs[node] = xs[nnode];\n    } else if(nei > 1) {\n        for(nnode : tree[node]) {\n            xs[node] ^= xs[nnode] ^ pl[nnode];\n        }\n        pl[node] = 1;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    dfs(1);\n    cout << (xs[1] ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector <int> v[100010];\n\nint dfs (int nod, int tata)\n{\n    int rez = 0;\n    for (auto &it : v[nod])\n    {\n        if (it == tata) continue;\n\n        rez ^= (dfs (it, nod) + 1);\n    }\n\n    return rez;\n}\n\nint main ()\n{\n   // freopen (\"file.in\", \"r\", stdin);\n\n    int n;\n    scanf (\"%d\", &n);\n\n    for (int i = 1; i < n; ++i)\n    {\n        int x, y;\n        scanf (\"%d %d\", &x, &y);\n\n        v[x].push_back (y);\n        v[y].push_back (x);\n    }\n\n    if (!dfs (1, 0)) printf (\"Bob\\n\");\n    else printf (\"Alice\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint dfs(vector<vector<int>>& G, int pos){\n  int val = 0;\n  if( pos == 0 ){\n    for(auto nx : G[pos]){\n      val ^= dfs(G, nx);\n    }\n  }else{\n    return (G[pos].size()-1) >= 2 ? 1 : 0;\n  }\n  return val;\n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<vector<int>> G(n);\n  for(int i=0; i<n-1; i++){\n    int x,y;\n    cin >> x,y;\n    x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  auto ans = dfs(G, 0);\n  println( ans == 0 ? \"Bob\" : \"Alice\");\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> x, y;\n  for (int i = 0; i < n - 1; i++) {\n    int x_in, y_in;\n    cin >> x_in >> y_in;\n    x.push_back(x_in);\n    y.push_back(y_in);\n  }\n  \n  int count_1 = 0;\n  for (int i = 0; i < n - 1; i++) {\n    if (x[i] == 1) {\n      count_1++;\n    }\n  }\n\n  string answer;\n  if (count_1 % 2 == 1) {\n    answer = \"Alice\";\n  } else {\n    answer = \"Bob\";\n  }\n\n  cout << answer << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<1];\nint n,home[N],cnt=-1,f[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k,int F){\n\tint son=0;\n\tfor(int i=home[k];~i;i=e[i].next) if(e[i].k!=F){\n\t\tdfs(e[i].k,k);\n\t\tson++;\n\t\tf[k]^=f[e[i].k]^1;\n\t}\n\tif(son==1) f[k]=1;\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tif(f[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 5;\n\n#define st first\n#define nd second\n#define make(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pun;\ntypedef long long ll;\n\nvector<int> G[N];\nbool vis[N];\n\n\nint dfs(int x) {\n\tif (vis[x]) return -1;\n\tvis[x] = true;\n\tint res = 0;\n\tfor (int y: G[x]) {\n\t\tint a = dfs(y);\n\t\tres ^= (a+1);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i ++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tprintf(\"%s\\n\", dfs(1) == 0 ? \"Bob\" : \"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2];\nint i,j,k,l,t,n,m,tot;\nvoid add(int x,int y){\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nint dfs(int x,int y){\n    int l=0,t=h[x];\n    while (t){\n        if (go[t]!=y) l^=dfs(go[t],x)+1;\n        t=nxt[t];\n    }\n    return l;\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        add(j,k);add(k,j);\n    }\n    if (dfs(1,0)) printf(\"Alice\\n\");else printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint kaijo[2000010];\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvoid init_fact(){\n    kaijo[0]=1;\n    for(int i=1;i<=2000000;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nint comb(int a,int b){\n    if(!kaijo[0])init_fact();\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\nint n;\nvector<int>v[100010];\nbool used[100010];\nint G[100010];\nvoid dfs(int x){\n    used[x]=true;\n    for(int i:v[x]){\n        if(!used[i]){\n            dfs(i);\n            G[x]^=(G[i]+1);\n        }\n    }\n}\nsigned main(){\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].pb(b);\n        v[b].pb(a);\n    }\n    dfs(0);\n    if(G[0]==0)puts(\"Bob\");\n    else puts(\"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint n;\nvector<int> g[111111];\n\nint solve(int a, int par) {\n  int x = 0;\n  for (auto&& t : g[a]) {\n    if (t != par) {\n      x ^= (solve(t, a) + 1);\n    }\n  }\n  return x;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n-1; i++) {\n    int a, b; scanf(\"%d%d\", &a, &b);\n    --a; --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  bool w = solve(0, -1);\n  puts(w == 1 ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define mod (int)1000000007\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\n#ifdef int\nconstexpr int INF = LLONG_MAX / 10;\n#else\nconstexpr int INF = INT_MAX / 10;\n#endif\nconstexpr double eps = DBL_EPSILON;\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\nint n;\nvector<int> vec[100010];\nbool used[100010];\nbool dfs(int node) {\n\tused[node] = true;\n\tint cnt = 0;\n\tbool f = false;\n\tfor (int i : vec[node]) {\n\t\tif (!used[i]) {\n\t\t\tcnt++;\n\t\t\tif (dfs(i))f ^= true;\n\t\t}\n\t}\n\treturn (cnt & 1) | f;\n}\nsigned main() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tvec[u].push_back(v);\n\t\tvec[v].push_back(u);\n\t}\n\tif (dfs(1))puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<stack>\n#include<queue>\n \n#define REP(i, a, b) for(int i=a; i<b; ++i)\n#define rep(i, n) REP(i, 0, n)\n \nusing namespace std;\n \nvector< vector<int> > tree(100000, vector<int>(0));\n \nint rec(int node, int prev) {\n    //printf(\"now on %d\\n\", node);\n    //printf(\"size = %d\\n\", tree[node].size());\n    if (tree[node].size() % 2 == 0) {\n        return 1;\n    }\n \n    int ans = 0;\n    rep(i, tree[node].size()) {\n        int child = tree[node][i];\n        if (child != prev)\n            ans += rec(child, node);\n    }\n    return ans;\n}\n \nint main() {\n    int N;\n    scanf(\"%d\", &N);\n \n    rep(i, N - 1) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        v1--;\n        v2--;\n        tree[v1].push_back(v2);\n        tree[v2].push_back(v1);\n    }\n    tree[0].push_back(0);\n \n    int res = rec(0, 0);\n    if (res % 2 == 0) {\n        printf(\"Bob\\n\");\n    }else{\n        printf(\"Alice\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> >v;\nint par[100000],son[100000];\nset<int>st;\nvoid dfs(int u,int p){\n\tpar[u] = p;\n\tbool l = 1;\n\tfor(int i = 0;i < v[u].size();i++)\n\t\tif(v[u][i] != p){\n\t\t\tson[u]++;\n\t\t\tdfs(v[u][i],u),l = 0;\n\t\t}\n\tif(l)st.insert(u);\n}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\tv.resize(n);\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;b--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tif(v[0].size() == 1)return puts(\"Alice\"),0;\n\tdfs(0,-1);\n\tbool l = 1;\n\twhile(st.size()){\n\t\tint x = *st.begin();\n\t\tson[par[x]]--;\n\t\tif(!son[par[x]])st.insert(par[x]);\n\t\tst.erase(x);\n\t\tif(*st.begin() == -1)break;\n\t\tl^=1;\n\t}\n\tif(l)puts(\"Alice\");\n\telse puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> path[100010];\nbool visited[100010];\n\nint dfs(int v) {\n    visited[v] = true;\n    int ret = 0;\n    for (int sv : path[v]) {\n        if (visited[sv]) continue;\n        ret ^= (dfs(sv) + 1);\n    }\n    return ret;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        path[x].push_back(y);\n        path[y].push_back(x);\n    }\n\n    fill(visited, visited + N, false);\n\n    cout << (dfs(0) > 0 ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define gec     getchar\n#define FILE(F) freopen(F\".in\",\"r\",stdin),freopen(F\".out\",\"w\",stdout)\n\ntypedef long long ll;\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;bool f=0; char c=gec();\n\tfor(;c<'0'||c>'9';c=gec())f=(c=='-');\n\tfor(;c>='0'&&c<='9';c=gec())x=x*10+c-'0';\n\tx=f?-x:x;\n}\nnamespace IO\n{\ninline void fpr(char *c){fprintf(stderr,\"%s\\n\",c);}\ninline void fpr(int           x,char *c){fprintf(stderr,\"[ %s ] : = %d   \\n\",c,x);}\ninline void fpr(ll            x,char *c){fprintf(stderr,\"[ %s ] : = %lld \\n\",c,x);}\ninline void fpr(double        x,char *c){fprintf(stderr,\"[ %s ] : = %.5lf\\n\",c,x);}\ninline void fpr(long double   x,char *c){fprintf(stderr,\"[ %s ] : = %.5Lf\\n\",c,x);} \n}using namespace IO;\n\nconst int MAXN(100010);\nint n;\nstruct Node\n{\n\tint nd,nx;\n}bot[MAXN<<1];int tot,first[MAXN],val[MAXN];\nvoid add(int a,int b)\n{bot[++tot]=(Node){b,first[a]};first[a]=tot;\n bot[++tot]=(Node){a,first[b]};first[b]=tot;}\n\nvoid DFS(int x,int f)\n{\n\tfor(int y,v=first[x];v;v=bot[v].nx)\n\tif((y=bot[v].nd)!=f)\n\t{\n\t\tDFS(y,x);\n\t\tval[x]^=val[y];\n\t}\n\tval[x]=(val[x]>0);\n\tif(x==1)val[0]=val[1];\n\tval[x]++;\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1,a,b;i<n;i++)\n\t{\n\t\tread(a);read(b);\n\t\tadd(a,b);\n\t}\n\tDFS(1,0);\n\tputs(val[0]?\"Alice\":\"Bob\");\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1e5 + 50;\n\nstruct edge {\n  int nxt, to;\n} e[N << 1];\nint fir[N], cnt = 1;\n\ninline void addedge(int x, int y) {\n  e[++ cnt] = (edge) { fir[x], y }; fir[x] = cnt;\n}\n\nint n;\n\ninline int Dfs(int x, int f) {\n  int sg = 0;\n  for (int i = fir[x]; i; i = e[i].nxt)\n    if (e[i].to != f) sg ^= Dfs(e[i].to, x) + 1;\n  return sg;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, x, y; i < n; i ++) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y); addedge(y, x);\n  }\n  puts(Dfs(1, 0) ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u, int pre)\n{\n    int ret = 0;\n    for(int i = 0; i < v[u].size(); i++)\n    {\n        if(v[u][i] != pre)\n            ret ^= (1 + get_sg(v[u][i], u));\n    }\n    return ret;\n}\nint main()\n{\n    int  n;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n        v[i].clear();\n    for(int i = 1; i < n; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(get_sg(1, -1))\n        puts(\"Alice\");\n    else\n        puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 200010\nusing namespace std;\nint n;\nstruct node{\n\tint x;\n\tnode *nxt;\t\n}edge[MAXN*2];\nnode *head[MAXN],*ncnt=edge;\nvoid add_edge(int x,int y){\n\tncnt++;\n\tncnt->x=y;\n\tncnt->nxt=head[x];\n\thead[x]=ncnt;\n}\nint sg[MAXN];\nvoid dfs(int x,int fa){\n\tfor(node *v=head[x];v!=NULL;v=v->nxt){\n\t\tint u=v->x;\n\t\tif(u==fa)\n\t\t\tcontinue;\n\t\tdfs(u,x);\n\t\tsg[x]^=(sg[u]+1);\t\n\t}\n}\nint main(){\n\tSF(\"%d\",&n);\n\tint u,v;\n\tfor(int i=1;i<n;i++){\n\t\tSF(\"%d%d\",&u,&v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tif(sg[1]==0)\n\t\tPF(\"Bob\");\n\telse\n\t\tPF(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<string, string>;\nll MOD = 1e9+7;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> d(n);\n    for(int i = 0; i < n-1; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--;y--;\n        d[x].push_back(y);\n        d[y].push_back(x);\n    }\n    int size = d[0].size();\n    function<int(int, int)> dfs = [&](int v, int pre)\n    {\n        int grundy = 0;\n        for(int cand : d[v])\n        {\n            if(cand == pre) continue;\n            grundy ^= dfs(cand, v) + 1;\n        }\n        return grundy;\n    };\n    int x = 0;\n    for(int i = 0; i < size; i++)\n    {\n        int grundy = dfs(d[0][i], 0);\n        x ^= grundy+1;\n    }\n    if(x != 0)\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        cout << \"Bob\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define ll long long\n#define INF 1000000000\n#define clr(x) memset(x,0,sizeof(x))\nusing namespace std;\n\ninline int read()\n{\n\tregister int ret=0,c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile(isdigit(c))ret=ret*10+c-'0',c=getchar();\n\treturn ret;\n}\n\n#define M 100005\n\nint n,fa[M],sg[M];\nint first[M],lext[M<<1],to[M<<1],t;\n\nvoid addedge(int s,int v)\n{\n\tlext[++t]=first[s];\n\tfirst[s]=t;\n\tto[t]=v;\n}\n\nvoid dfs(int x)\n{\n\tfor(int i=first[x];i;i=lext[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa[x])continue;\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t\tsg[x]^=sg[v]+1;\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(1);\n\tif(sg[1]==0)puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define MOD 1000000007\n#define MOD2 998244353\n#define int long long\n//#define PI 3.14159265358979\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t\tos << A[i] << \" \";\n\tos << endl;\n\treturn os;\n}\ntemplate <>\nostream &operator<<(ostream &os, const vector< vector< int > > &A) {\n\tint N = A.size();\n\tint M;\n\tif (N > 0)\n\t\tM = A[0].size();\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++)\n\t\t\tos << A[i][j] << \" \";\n\t\tos << endl;\n\t}\n\treturn os;\n}\n\ntypedef pair< int, int > pii;\ntypedef long long ll;\n\nstruct edge {\n\tint from, to, d, c;\n\tedge(int _from = 0, int _to = 0, int _d = 0, int _c = 0) {\n\t\tfrom = _from;\n\t\tto = _to;\n\t\td = _d;\n\t\tc = _c;\n\t}\n\tbool operator<(const edge &rhs) const {\n\t\treturn (d == rhs.d) ? (c < rhs.c) : (d < rhs.d);\n\t}\n};\nstruct aabb {\n\tint x1, y1, x2, y2;\n\taabb(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\ntypedef vector< edge > edges;\ntypedef vector< edges > graph;\nstruct flow {\n\tint to, cap, rev, cost;\n\tflow(int to = 0, int cap = 0, int rev = 0, int cost = 0) : to(to), cap(cap), rev(rev), cost(cost) {}\n};\ntypedef vector< vector< flow > > flows;\n\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {-1, 0, 1, 0};\nconst int ci[5] = {0, 0, -1, 0, 1};\nconst int cj[5] = {0, -1, 0, 1, 0};\nconst ll LINF = LLONG_MAX / 2;\nconst int INF = INT_MAX / 2;\nconst double PI = acos(-1);\n\nint pow2(int n) { return 1 << n; }\ntemplate < typename T, typename U >\nbool chmin(T &x, const U &y) {\n\tif (x > y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate < typename T, typename U >\nbool chmax(T &x, const U &y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct initializer {\n\tinitializer() {\n\t\tcout << fixed << setprecision(20);\n\t}\n};\ninitializer _____;\n\nint N, M, K, T, Q, H, W;\nint dfs(vector< vector< int > > &G, int x, int p) {\n\tint ret = 0;\n\trep(i, G[x].size()) {\n\t\tint j = G[x][i];\n\t\tif (j == p)\n\t\t\tcontinue;\n\t\tret ^= (dfs(G, j, x) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tcin >> N;\n\tvector< vector< int > > G(N);\n\trep(i, N - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x;\n\t\t--y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tstring ans;\n\tif (!dfs(G, 0, -1)) {\n\t\tans = \"Bob\";\n\t} else {\n\t\tans = \"Alice\";\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\nstruct yuansu\n{\n    int x,y;\n}bian[500005];\nint cmp (yuansu a,yuansu b)\n{\n    return a.x<b.x;\n}\nint sum[500005],n,x,y,cnt;\nint dfs(int dian,int fa)\n{\n    if(sum[dian]==sum[dian-1]+1)\n    {\n        return 1;\n    }\n    int ans(0);\n    for(int i=sum[dian-1]+1;i<=sum[dian];i++)\n    {\n        if(bian[i].y==fa)\n        {\n            ans^=dfs(bian[i].y,dian)+1;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    cin>>n;\nfor(int i=1;i<n;i++)\n{\n    scanf(\"%d%d\",&x,&y);\n    bian[++cnt].x=x;\n    bian[cnt].y=y;\n    bian[++cnt].x=y;\n    bian[cnt].y=x;\n}\nsort(bian+1,bian+cnt+1,cmp);\nfor(int i=1;i<=cnt;i++)\n{\n    if(bian[i].x!=bian[i+1].x)\n    {\n        sum[bian[i].x]=i;\n    }\n}\nif(dfs(1,0))cout<<\"Alice\";\nelse cout<<\"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\n\nint n, s[MAXN];\nvector<int> g[MAXN];\n\nint dfs(int v, int f = -1) {\n\tfor (int u : g[v])\n\t\tif (u != f)\n\t\t\ts[v] ^= (1 + dfs(u, v));\n\treturn s[v];\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tif (dfs(0) == 0) {\n\t\tcout << \"Bob\\n\";\n\t} else\n\t\tcout << \"Alice\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "        #include<bits/stdc++.h>\n     \n         \n        using namespace std;\n         \n        #define N  1000000000;\n    #define ll         long long\n        vector<ll>adj[100005];\n        std::vector<ll> vis;\n        ll dfs(ll node)\n        {\n           if((node!=1&&adj[node].size()-1==0)||(node==1&&adj[node].size()==0))\n            return 0;\n           if((node!=1&&adj[node].size()-1==1)||(node==1&&adj[node].size()==1))\n           {\n            for(auto j:adj[node])\n            {\n                if(vis[j]==0)\n                {\n                    vis[j]+1;\n                    return 1+dfs(j);\n                }\n            }\n\n           }\n           ll ans=0;\n           for(auto j:adj[node])\n           {\n            if(vis[j]==0)\n            {\n                vis[j]=1;\n                ans^=(1+dfs(j));\n            }\n           }\n           return ans;\n         }\n         int main()\n        \n       \n        {\n            ios_base::sync_with_stdio(false);\n            cin.tie(0);\n            cout.tie(0);\n            int TESTS=1;\n           // cin>>TESTS;\n             while(TESTS--)\n            {\n              ll n;\n              cin>>n;\n              for(ll i=0;i<n-1;i++)\n              {\n                ll a,b;\n                cin>>a>>b;\n                adj[a].push_back(b);\n                adj[b].push_back(a);\n              }\n              vis=vector<ll>(n+2,0);\n              vis[1]=1;\n              if(dfs(1))\n                cout<<\"Alice\"<<endl;\n            else\n                cout<<\"Bob\"<<endl;\n            }\n            return 0;\n        }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000;\nint n;\nstruct edge {\n\tint to, nxt;\n}eg[maxn * 2 + 10];\nint h[maxn + 10], egcnt;\n\ninline void addeg(int &h, int to) {\n\teg[++egcnt] = (edge){to, h};\n\th = egcnt;\n}\n\nint dfs(int p, int fa) {\n\tint ans = 0;\n\tfor (int i = h[p]; i; i = eg[i].nxt)\n\t\tif (eg[i].to != fa) ans ^= dfs(eg[i].to, p) + 1;\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\taddeg(h[l], r); addeg(h[r], l);\n\t}\n\tprintf(\"%s\", dfs(1, 0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"grader.h\"\n#include <bits/stdc++.h>  \n\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define re return\n#define fi first\n#define mp make_pair\n#define se second\n#define sz(a) (int)a.size()\n#define prev previ\n#define tm tmmm\n#define div divv\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\nconst ll mod = ll(1e9) + 9LL, pr = 239, mod2 = ll(1e9) + 7;\n\nll n, a, b, c, d, gr[1000000];\nvector<int> e[1000000];\n\nvoid dfs(int nu, int p) {\n\tgr[nu] = 0;\n\tfor (int v : e[nu])\n\t\tif (v != p) {\n\t\t\tdfs(v, nu);\n\t\t\tgr[nu] ^= (gr[v] + 1);\n\t\t}\n}\nint main() {\n\tiostream::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tforn (i, n- 1) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tdfs(0, -1);\n\tif (gr[0]) cout << \"Alice\";\n\telse\n\t\tcout << \"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\nvector<vector<int> > G;\nint calc(int pos, int pre) {\n\tint ans = 0;\n\tfor (int i : G[pos]) {\n\t\tif (i != pre) {\n\t\t\tans ^= calc(i, pos) + 1;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tG.resize(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y; --x, --y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tint ans = calc(0, -1);\n\tcout << (ans ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"avx2\")  //Enable AVX\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(),a.end()\n#define F first\n#define S second\n#define pb push_back\n#define ll long long\n#define vi vector<int>\n#define pi pair<int,int>\n#define mp make_pair\n \n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...) 42\n#endif\n \nint mod=1e9+7;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint mul(int a,int b)\n{\n\treturn ((a)*1ll*(b))%mod;\n}\n \nvoid add(int &a,int b)\n{\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n \nint sub(int a,int b){\n\ta-=b;\n\tif(a<0){\n\t\ta+=mod;\n\t}\n\treturn a;\n}\n \nint powz(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1){\n\t\t\tres=mul(res,a);\n\t\t}\n\t\tb/=2;\n\t\ta=mul(a,a);\n\t}\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nistream& operator>>(istream& input,pair<A,B>& x) {\n\tinput>>x.F>>x.S;\n\treturn input;\n}\n \ntemplate <typename A>\nistream& operator>>(istream& input,vector<A>& x) {\n\tfor(auto& i:x)\n\t\tinput>>i;\n\treturn input;\n}\n \ntemplate<typename A>\nostream& operator<<(ostream& output,vector<A>& x) {\n\tfor(auto& i:x)\n\t\toutput<<i<<' ';\n\treturn output;\n}\n \nconst int N=1000002;\n \nvector<int>adj[N];\nint dp[N];\n \nint dfs(int u,int p){\n\tint sum=0;\n\tfor(auto i:adj[u]){\n\t\tif(i!=p){\n\t\t\tsum^=dfs(i,u);\n\t\t}\n\t}\n\treturn dp[u]=sum+1;\n}\n \nvoid solve(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\tdfs(0,-1);\n\tint val=dp[0];\n\tif(val!=1){\n\t\tcout<<\"Alice\";\n\t}\n\telse{\n\t\tcout<<\"Bob\";\n\t}\n}\n \nsigned main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tc=1;\n\t//~ cin>>tc;\n\tfor(int _=0;_<tc;_++){\n\t\t//~ cout<<\"Case #\"<<_+1<<\": \";\n\t\tsolve();\n\t\tif(_!=tc-1)\n\t\tcout<<\"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,a[100005];\nvector<int> v[100005];\nvoid dfs(int x,int y){\n    for(int i=0;i<v[x].size();++i){\n        int z=v[x][i];\n        if(y==z) continue;\n        dfs(z,x);\n        a[x]^=(a[z]+1);\n    }\n    if(cnt==1)++a[x];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    dfs(1,0);\n    if(a[1])puts(\"Alice\");\n    else puts(\"Bob\");\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n;\nvector <int> v[N];\n\nint dfs(int node, int pnode){\n    int ret = 0;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        ret = abs(ret - dfs(i, node));\n    }\n    return ret + 1;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(dfs(1, 0) == 1) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 1000010\n\nvector<int> edge[MAXN];\nint n,size[MAXN],u,v;\n\nvoid dfs(int u,int fa)\n{\n\tsize[u]=0;\n\tfor(auto v : edge[u])\n\t{\n\t\tif(v==fa)continue;\n\t\tdfs(v,u);\n\t\tsize[u]^=size[v]+1;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tputs(size[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\n\nconst int N = 111111;\nvector<int> tree[N];\nint pl[N];\nint n;\n\nvoid dfs(int node, int p = 0) {\n    for(nnode : tree[node]) {\n        if(nnode == p) continue;\n        dfs(nnode, node);\n    }\n    int nei = tree[node].size() - (node != 1);\n    if(nei == 1) {\n        pl[node] = pl[tree[node][0]] + 1;\n    } else if(tree[node].size() > 1) {\n        for(nnode : tree[node]) {\n            pl[node] ^= pl[nnode];\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    dfs(1);\n    cout << (pl[1] ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\nvector<int> g[100005];\nint dfs(int v,int p){\n  int cur=0;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    int tmp=dfs(to,v)+1;\n    cur^=tmp;\n  }\n  return cur;\n}\nint main(){\n  cin>>n;\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n  int r=dfs(0,-1);\n  puts(r==0?\"Bob\":\"Alice\");\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200000;\nint n;\nmap <set <int>, int> M;\nint tot;\nvector <int> bi[N];\nint dfs(int t, int f = 0)\n{\n    set <int> a;\n    for (int i = 0; i < bi[t].size(); ++ i) if (bi[t][i] != f)\n    {\n        int x = dfs(bi[t][i], t);\n        if (a.count(x)) a.erase(x); else a.insert(x);\n    }\n    if (!M.count(a)) M[a] = tot ++;\n    return M[a];\n}\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        bi[a].push_back(b);\n        bi[b].push_back(a);\n    }\n    if (dfs(1)) puts(\"Alice\"); else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst int mod = 200003;//1e9 + 7;//786433;//998244353;//1e9 + 7\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nbool ok[100005];\nvector <int> Adj[100005];\n\nvoid DFS(int node, int p = -1)\n{\n\tint cnt[2];\n\tcnt[0] = 0;\n\tcnt[1] = 0;\n\tfor(auto x : Adj[node])\n\t{\n\t\tif(x != p)\n\t\t{\n\t\t\tDFS(x, node);\n\t\t\tcnt[ok[x]]++;\n\t\t}\n\t}\n\tif(cnt[0] % 2 == 0 && cnt[1] % 2 == 0)\n\t{\n\t\tok[node] = false;\n\t}\n\telse\n\t{\n\t\tok[node] = true;\n\t}\n}\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tAdj[u].eb(v);\n\t\tAdj[v].eb(u);\n\t}\n\tDFS(1);\n\tif(ok[1])\n\t{\n\t\tcout << \"Alice\";\n\t}\n\telse\n\t{\n\t\tcout << \"Bob\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 1;\nvector<int> edges[MAX_N];\nbool check[MAX_N];\n\nint dfs( int u ) {\n    check[u] = 1;\n    int ans = 0, num_f = 0;\n    for ( int v : edges[u] )\n        if ( !check[v] ) {\n            ans ^= 1;\n            num_f++;\n            ans ^= dfs( v );\n        }\n    if ( num_f == 1 )\n        return 1;\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for ( int i = 0; i < n - 1; i++ ) {\n        int x, y;\n        cin >> x >> y;\n        edges[x].push_back( y );\n        edges[y].push_back( x );\n    }\n\n//    cout << dfs(1);\n    cout << ( dfs( 1 ) ? \"Alice\" : \"Bob\" );\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nconst int maxi=100010;\n\nvector <int> v[maxi];\n\nint gr[maxi],ob[maxi],x,y,n,t;\n\nvoid dfs(int x){\n    ob[x]=1;\n\n    for (int i=0;i<v[x].size();i++)\n    if (ob[v[x][i]]==0){\n        dfs(v[x][i]);\n        gr[x]=gr[x]^(gr[v[x][i]]+1);\n    }\n}\n\nvoid mainmain(){\n    scanf(\"%d\",&n);\n\n    for (int i=0;i<maxi;i++)\n    {\n        v[i].clear();\n        gr[i]=0;\n        ob[i]=0;\n    }\n\n    for (int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n     dfs(1);\n\n   if (gr[1]==0) printf(\"Bob\\n\"); else printf(\"Alice\\n\");\n\n}\n\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// double(64bit浮動小数)のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない). long double(80ビットの x87 浮動小数点型?)だと, 2分探索であってもこれだと足りないケースがある気がするので, もうちょっと余裕を持たせた方が良さそう.\nconstexpr i64 max_loop = 100;\n\nvoid solve() {\n    //constexpr i64 mod = 1'000'000'007;\n    i64 N;\n    cin >> N;\n    vector<vector<i64>> tree(N);\n    rep(i,0,N-1){\n        i64 x,y;\n        cin >> x >> y;\n        --x;\n        --y;\n        tree[x].emplace_back(y);\n        tree[y].emplace_back(x);\n    }\n\n    function<i64(i64,i64)> rec=[&](i64 u,i64 p){\n        i64 g=0;\n        for(i64 v:tree[u]){\n            if(v==p) continue;\n            g^=rec(v,u)+1;\n        }\n        return g;\n    };\n\n    cout << (rec(0,-1)!=0?\"Alice\":\"Bob\") << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nstruct Edge {\n    int u, v, num;\n} ed[2 * MAXN];\n\nbool use[MAXN];\nint first[MAXN], nexxt[2 * MAXN], res[MAXN], p[MAXN];\n\n\nvoid dfs(int s)\n{\n    use[s] = 1;\n    res[s] = 0;\n\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (!use[ed[i].v])\n        {\n            p[ed[i].v] = s;\n            dfs(ed[i].v);\n            res[s] ^= res[ed[i].v]+1;\n        }\n}\n\nint dfs2(int s, int Gr)\n{\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (ed[i].v != p[s] && ((res[ed[i].v]+1) > (Gr ^ (res[ed[i].v]+1) ^ res[s])))\n        {\n            Gr ^= (res[ed[i].v] + 1) ^ res[s];\n            if (Gr == 0)\n                return ed[i].num;\n            return dfs2(ed[i].v, Gr-1);\n        }\n}\n\n\nmain() {\n    int n, r;\n    scanf(\"%d%d\", &n);\n    r = 1;\n    --r;\n    int m = n-1;\n    for (int i = 0; i < m; ++i)\n    {\n        scanf(\"%d%d\", &ed[i].u, &ed[i].v);\n        --ed[i].u, --ed[i].v;\n        ed[i].num = i + 1;\n\n        ed[i+m].u = ed[i].v;\n        ed[i+m].v = ed[i].u;\n        ed[i+m].num = ed[i].num;\n    }\n\n    m *= 2;\n\n    for (int i = 0; i < n; ++i)\n    {\n        first[i] = -1;\n        use[i] = 0;\n    }\n\n    for (int i = 0; i < m; ++i)\n    {\n        nexxt[i] = first[ed[i].u];\n        first[ed[i].u] = i;\n    }\n\n    p[r] = -1;\n    dfs(r);\n    if (!res[r])\n        printf(\"Alice\");\n    else\n        printf(\"Bob\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 110000\nint n,tot;\nint head[N],nex[N<<1],to[N<<1];\nint sg[N];\nvoid add(int x,int y)\n{\n\ttot++;\n\tnex[tot]=head[x];head[x]=tot;\n\tto[tot]=y;\n}\nvoid dfs(int x,int y)\n{\n\tfor(int i=head[x];i;i=nex[i])\n\t\tif(to[i]!=y)\n\t\t{\n\t\t\tdfs(to[i],x);\n\t\t\tsg[x]^=sg[to[i]]+1;\t\t\n\t\t}\n}\nint main()\n{\n\t//freopen(\"tt.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint D[100001], G[100001];\nvector<int> E[100001];\nint dfs(int A) {\n\tif (!D[A]) {\n\t\tint g = 0;\n\t\tD[A] = 1;\n\t\tfor (auto i : E[A]) {\n\t\t\tg ^= dfs(i);\n\t\t}\n\t\tG[A] = g + 1;\n\t}\n\treturn G[A];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\trep(i, N - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\n\tdfs(1);\n\n\tif (G[1] - 1) co(\"Alice\");\n\telse co(\"Bob\");\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint G[100001];\npair<int, int> E[200001];\nint P[100002];\nint dfs(int A) {\n\tif (G[A] == 0) {\n\t\tint g = 0;\n\t\tG[A] = -1;\n\t\tfor (int i = P[A]; i < P[A + 1]; i++) {\n\t\t\tg ^= dfs(E[i].second);\n\t\t}\n\t\treturn G[A] = g + 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N + N - 2; i += 2) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[i] = mp(x, y);\n\t\tE[i + 1] = mp(y, x);\n\t}\n\tsort(E, E + N + N - 2);\n\tint k = 0;\n\trep(i, N + N - 2) {\n\t\tif (k != E[i].first) {\n\t\t\tk++;\n\t\t\tP[k] = i;\n\t\t}\n\t}\n\tP[N + 1] = N + N - 2;\n\n\tdfs(1);\n\n\tif (G[1] - 1) co(\"Alice\");\n\telse co(\"Bob\");\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvvi g;\n\nvi used;\n\nint dfs(int v){\n\tused[v]=1;\n\tint res=0;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tif(!used[u]) res^=dfs(u)+1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tused=vi(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tif(dfs(0)) cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n#define F first\n#define S second\n#define PB push_back\n#define PF push_front\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\nconst int maxn = 1e5 + 37;\n\nint gn[maxn];\nvector <int> t[maxn];\n\nvoid dfs (int v, int p = -1) { // find grundy_number\n\tfor (auto w : t[v]) {\n\t\tif (w != p) {\n\t\t\tdfs (w, v);\n\t\t\tgn[v] ^= gn[w];\n\t\t}\n\t}\n\tgn[v] ++;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tt[v].PB (u);\n\t\tt[u].PB (v);\n\t}\n\tdfs (1);\n\tif (gn[1] == 1)\n\t\tcout << \"Bob\" << endl;\n\telse\n\t\tcout << \"Alice\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Gosu_Hiroo\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#ifdef int\n#define V2(v,size_1, size_2, value) vector<vector<long long>>v(size_1, vector<long long>(size_2, value))\n#define V3(v,size_1,size_2,size_3,value) vector<vector<vector<long long>>>v(size_1,vector<vector<long long>>(size_2,vector<long long>(size_3, value)))\n#define VI vector<long long>\n#define G(g,size_1) vector<vector<long long>>g(size_1, vector<long long>())\n#define VVI  vector<vector<long long>>\n#define VVVI  vector<vector<vector<long long>>>\n#define SZ(x) ((long long)(x).size())\n#define READ ({long long t;cin >> t;t;})\n#define PII pair<long long, long long>\n#else\n#define V2(v,size_1, size_2, value) vector<vector<int>>v(size_1, vector<int>(size_2, value))\n#define V3(v,size_1,size_2,size_3,value) vector<vector<vector<int>>>v(size_1,vector<vector<int>>(size_2,vector<int>(size_3, value)))\n#define VI vector<int>\n#define G(g,size_1) vector<vector<int>>g(size_1, vector<int>())\n#define SZ(x) ((int)(x).size())\n#define VVI  vector<vector<int>>\n#define VVVI  vector<vector<vector<int>>>\n#define READ ({int t;cin >> t;t;})\n#define PII pair<int, int>\n#endif\n\n#define VM2(v,size_1, size_2, value) vector<vector<mint>>v(size_1, vector<mint>(size_2, value))\n#define VM3(v,size_1,size_2,size_3,value) vector<vector<vector<mint>>>v(size_1,vector<vector<mint>>(size_2,vector<mint>(size_3, value)))\n#define VM   vector<mint>\n#define VVM  vector<vector<mint>>\n#define VVVM  vector<vector<vector<mint>>>\n\n#define TR(container, it) \\\n        for (auto it = container.begin(); it != container.end(); it++)\n#define IN(c, x) ((c).find(x) != (c).end())   //O(log n)\n#define IN_L(c, x) (find((c).begin(),(c).end(),x) != (c).end()) //O(n)\n#define FOR(i, _begin, _end) for (__typeof(_end) end = _end, begin = _begin,  i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n#define REP(i, end) for (__typeof(end) i = 0, _len = (end); i < (_len); i += 1)\n#define ALL(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define MOD(x, m) ((((x) % (m)) + (m)) % (m))\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define EB emplace_back\n#define PB push_back\n#define fcout cout << fixed << setprecision(12)\n#define fcerr cerr << fixed << setprecision(12)\n#define print(x) cout << (x) << endl\n# define BYE(a) do { cout << (a) << endl; return ; } while (false)\n\n#ifdef DEBUG\n#define ERR(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(cerr,_it, args); }\n#define DBG(x) cerr << #x << \" is \" << x << endl;\n#else\n#define DBG(x) {};\n#define ERR(args...) {};\n#endif\nvoid _err(std::ostream& cerr,istream_iterator<string> it) {cerr << endl;}\ntemplate<typename T, typename... Args>\nvoid _err(std::ostream& cerr, istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \"  \";\n    _err(cerr,++it, args...);\n}\n\nconst double pi = 2 * acos(.0);\nconst int inf = 0x3f3f3f3f;\nconst ll mod = (ll) (1e9) + 7;\n//const ll mod = (ll) 998244353 ;\nconst double eps = 1e-10;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\n\ntemplate <typename T>\nostream& operator << (ostream& os, const vector<T> V) {\n    os << \"[\";\n    int cnt = 0;\n    T curr;\n    if(!V.empty()){\n        for (int i = 0; i < V.size() - 1; ++i) {\n            if(V[i] == curr)cnt ++;\n            else cnt = 0;\n            if(cnt == 4)os << \"... \";\n            if(cnt < 4)\n                os << V[i] << \" \";\n            curr = V[i];\n        }\n        os << V.back();\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator << (ostream& os, const pair<T,U> P) {\n    os << \"(\";\n    os << P.first << \",\" << P.second;\n    os << \")\";\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator << (ostream& os, const set<T,U> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename K, typename H, typename P>\nostream& operator << (ostream& os, const unordered_set<K, H, P> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename K, typename C>\nostream& operator << (ostream& os, const multiset<K, C> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename K, typename T, typename C>\nostream& operator << (ostream& os, const map<K,T,C> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << \"(\";\n            os << it->first << \",\" << it->second;\n            os << \") \";\n            it++;\n        }\n        os << \"(\";\n        os << it->first << \",\" << it->second;\n        os << \")\";\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename K, typename T, typename C>\nostream& operator << (ostream& os, const unordered_map<K,T,C> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << \"(\";\n            os << it->first << \",\" << it->second;\n            os << \") \";\n            it++;\n        }\n        os << \"(\";\n        os << it->first << \",\" << it->second;\n        os << \")\";\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator << (ostream& os, const deque<T> V) {\n    os << \"[\";\n    if (!V.empty()) {\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << V[i] << \"->\";\n        }\n        if (!V.empty())os << V.back();\n    }\n    os << \"]\";\n    return os;\n};\n\ntemplate <typename T, typename Cont, typename Comp>\nostream& operator << (ostream& os, const priority_queue<T, Cont, Comp> V) {\n    priority_queue<T, Cont, Comp> _V = V;\n    os << \"[\";\n    if(!_V.empty()){\n        while(_V.size() > 1){\n            os << _V.top() << \"->\";\n            _V.pop();\n        }\n        os << _V.top();\n    }\n    os << \"]\";\n    return os;\n};\n\ntemplate <class F>\nstruct y_combinator {\n    F f; // the lambda will be stored here\n\n    // a forwarding operator():\n    template <class... Args>\n    decltype(auto) operator()(Args&&... args) const {\n        // we pass ourselves to f, then the arguments.\n        // the lambda should take the first argument as `auto&& recurse` or similar.\n        return f(*this, std::forward<Args>(args)...);\n    }\n};\n// helper function that deduces the type of the lambda:\ntemplate <class F>\ny_combinator<std::decay_t<F>> recursive(F&& f){\nreturn {std::forward<F>(f)};\n}\n\nstruct hash_pair {\n    template <class T1, class T2>\n    size_t operator()(const pair<T1, T2>& p) const\n    {\n        auto hash1 = hash<T1>{}(p.first);\n        auto hash2 = hash<T2>{}(p.second);\n        return hash1 ^ hash2;\n    }\n\n};\n\n /*\nstruct X{\n    int x,y,id;\n    bool operator < (const X R)const{\n        return id < R.id;\n    }\n    friend ostream& operator << (ostream& os,  X R){\n        os << \"(\" << R.x << \",\" << R.y << \",\" << R.id << \")\";\n    }\n    friend bool operator == (const X L,  const X R){\n        return L.id == R.id;\n    }\n*/\ntemplate<class T>void Chmod(T &a, const T &m) {a = MOD(a, m);}\ntemplate<class T>bool Chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool Chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n//256MB = 2^29(~5.3*10^8)*sizeof(int)\n//#define int ll //2^31=2.15*10^9, 2^63=9.22*10^18\nclass DGameOnTree {\npublic:\n\nvoid solve(std::istream& cin, std::ostream& cout, std::ostream& cerr) {\n    int N;\n    cin >> N;\n    G(g, N+1);\n    REP(i,N){\n        int x,y;\n        cin >> x >> y;\n        g[x].EB(y);\n        g[y].EB(x);\n    }\n    VI visited(N+1);\n    auto dp  = recursive([&](auto &&dp , int v, int p)->int {\n        int ans = 0;\n        visited[v] = 1;\n        for(auto adj_v : g[v])if(!visited[adj_v] && adj_v != p)ans ^= (dp(adj_v, v) + 1);\n        ERR(v,p,ans)\n        return ans;\n    });\n    print(dp(1, -1)?\"Alice\":\"Bob\");\n\n}\n\n\n};\n\n\n#undef int\nint main() {\n\n\tDGameOnTree solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n    std::ostringstream err;\n\tin.tie(0); ios::sync_with_stdio(0);\n//\tsolver.solve(in, out);\n    solver.solve(in, out,err);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,head[MN+5],cnt=0,f[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int fa)\n{\n\tint num=0,num2=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)\n\t\t{\n\t\t\tdfs(e[i].to,x);\n\t\t\tf[e[i].to]?num2^=1:num^=1;\n\t\t}\n\tf[x]=num==0&&num2==0?0:1;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define ll long long\n#define maxn 100002\n#define pb push_back\nusing namespace std;\n\nvector<int> a[maxn];\nbool dfs(int u, int par){\n\tif(u==1&&a[u].size()==2) return true;\n\tint cnt = 0;\n\tint v;\n\tfor(int i=0;v= a[u][i];i++){\n\t\tif(v!=par){\n\t\t\tif(dfs(v,u)==false){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tif(cnt == 0&& a[u].size()==2) return false;\n\tif(cnt%2==1) return true;\n\treturn false;\n}\nmain(){\n\tint n,v,u;\n\tcin  >> n;\n\tFor(i,1,n-1){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\ta[u].pb(v);\n\t\ta[v].pb(u);\t\t\n\t}\n\tFor(i,1,n){\n\t\ta[i].pb(0);\n\t}\n\tif(dfs(1,1)){\n\t\tcout << \"Alice\";\n\t}\telse\t{\n\t\tcout << \"Bob\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(a, n) for (int a=0; a<n; a++)\n#define F(a, n) for (int a=1; a<=n; a++)\nusing namespace std;\n\nstruct node{\n\tvector<int> nei;\n\tvector<int> children;\n\tint sg, par=-1;\n};\nnode A[100005];\nint n, x, y;\nvoid orient(int nd){\n\tfor (auto x: A[nd].nei) if (x!=A[nd].par){\n\t\tA[nd].children.push_back(x);\n\t\tA[x].par = nd;\n\t\torient(x);\n\t}\n}\n\nvoid sg(int nd){\n\tint ret = 0;\n\tfor (auto x: A[nd].children){\n\t\tsg(x);\n\t\tret ^= A[x].sg;\n\t}\n\tret++;\n\tA[nd].sg = ret;\n\treturn;\n}\nint main() {\n\tcin>>n;\n\tf(i, n-1){\n\t\tcin>>x>>y;\n\t\tA[x].nei.push_back(y);\n\t\tA[y].nei.push_back(x);\n\t}\n\torient(1);\n\tsg(1);\n\tcout<<(A[1].sg == 1 ? \"Bob\" : \"Alice\") <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nll dist[100010] = {};\nvector<ll> tree[100010];\n\nvoid dfs(ll cur, ll par){\n    for(auto &e: tree[cur]){\n        if(e == par) continue;\n        dfs(e, cur);\n        dist[cur] ^= dist[e]+1;\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    rep(i,0,N-1){\n        ll a,b;\n        cin >> a >> b;\n        a--; b--;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    dfs(0,-1);\n    if(dist[0] == 0){\n        print(\"Bob\");\n    }else{\n        print(\"Alice\");\n    }\n\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N + 1);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N + 1, MOD);\n\tvector<int>parent(N + 1);\n\tdis[1] = 0;\n\tqueue<int>Q;\n\tQ.push(1);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (dis[i] > dis[cn] + 1) {\n\t\t\t\tdis[i] = dis[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t\tparent[i] = cn;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>used(N + 1);\n\tvector<int>nim(N + 1);\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (edge[i].size() == 1)Q.push(i);\n\t}\n\tedge[1].clear();\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tif (cn == 1)continue;\n\t\tint node = cn;\n\t\tint nx;\n\t\twhile (1) {\n\t\t\tnx = parent[node];\n\t\t\tused[node]++;\n\t\t\tused[nx]++;\n\t\t\tnode = nx;\n\t\t\tif (edge[nx].size() != 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnim[node] ^= (dis[cn] - dis[node]+nim[cn]);\n\t\t//nim[node] ^= nim[cn];\n\t\tif (edge[node].size() - used[node] == 1)Q.push(node);\n\t}\n\tif (!nim[1])cout << \"Bob\\n\";\n\telse cout << \"Alice\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nint n;\nvector<int> e[100000];\nint g[100000];\nbool saw[100000];\n\nint dfs(int v) {\n    saw[v] = true;\n    int ret = 0;\n    rep(i,e[v].size()) {\n        if(saw[e[v][i]]) continue;\n        ret ^= (dfs(e[v][i])+1);\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    int ans = dfs(0);\n    if(ans == 0) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7; bool fl[N];\nint n,ans,len[N],val[N]; vector<int>v[N];\ninline int read(){\n\tint num=0; char g=getchar(); while(g<48||57<g) g=getchar();\n\twhile(47<g&&g<58) num=(num<<1)+(num<<3)+g-48,g=getchar(); return num;\n}\ninline void find(int u){\n\tfl[u]=1;\n\tfor(int i=0;i<len[u];i++){\n\t\tint x=v[u][i]; if(fl[x]) continue; find(x),val[u]^=(val[x]+1);\n\t}\n}\nint main(){\n\tn=read(); int u,t;\n\tfor(int i=1;i<n;i++) u=read(),t=read(),v[u].push_back(t),v[t].push_back(u),len[u]++,len[t]++; find(1);\n\tif(val[1]) puts(\"Alice\"); else puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>;\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define pb push_back\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tint n; cin >> n;\n\tvi adj[n];\n\tf(i,0,n-1) {\n\t\tint a,b; cin>>a>>b;\n\t\tadj[--a].pb(--b); adj[b].pb(a);\n\t}\n\tfunction<int(int,int)> dfs = [&](int v, int p) {\n\t\tint ans = 0;\n\t\tfor (int w : adj[v]) if (w != p)\n\t\t\tans ^= 1+dfs(w,v);\n\t\treturn ans;\n\t};\n\tcout << (dfs(0,-1)?\"Alice\":\"Bob\") << endl;\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <bitset>\n#include <complex>\n#include <climits>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\ntypedef pair<double, double> dd;\n#define mp make_pair\n#define pb push_back\n#define debug(x) cerr << #x << \" = \" << x << \" \"\n\n\nconst int N = 1e5+1;\nvector<int> g[N];\nint n;\nint dfs(int cur, int p)\n{\n  vector<int> sgs;\n  for (auto nxt : g[cur])\n    if (nxt != p)\n      sgs.pb(dfs(nxt, cur));\n  int ret = 0;\n  for (auto e : sgs) ret ^= (e+1);\n  return ret;\n }\nint main()\n{\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n-1; ++i)\n    {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      g[u].pb(v);\n      g[v].pb(u);\n    }\n  puts(dfs(1, 1)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repdi(i,a,b) for(ll i=(a)-1;i>=(b);--i)\n#define repd(i,a) repdi(i,a,0)\n#define itr(it,a) for( auto it = (a).begin(); it != (a).end(); ++it )\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define endl '\\n'\n#define debug(x) std::cerr << #x << \" = \" << (x) << endl;\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class S, class T>\nstd::ostream& operator<< ( std::ostream& out, const std::pair<S,T>& a )\n{ std::cout << '(' << a.first << \", \" << a.second << ')'; return out; }\n\ntemplate<class T>\nstd::ostream &operator<< ( std::ostream& out, const std::vector<T>& a )\n{ std::cout << '['; rep( i, a.size() ){ std::cout << a[i]; if( i != a.size()-1 ) std::cout << \", \"; } std::cout << ']'; return out; }\n\nll N;\nstd::vector<ll> G[100010];\nll g[100010];\n\nvoid dfs( ll v, ll p = -1 ) {\n  g[v] = 0;\n\n  for( auto u : G[v] ) if( u != p ) {\n    dfs( u, v );\n\n    g[v] ^= g[u]+1;\n  }\n\n  return;\n}\n\nint main() {\n  std::cin >> N;\n\n  rep( i, N-1 ) {\n    ll x, y;\n    std::cin >> x >> y;\n    --x; --y;\n\n    G[x].emplace_back( y );\n    G[y].emplace_back( x );\n  }\n\n  dfs( 0 );\n\n  puts( g[0] ? \"Alice\" : \"Bob\" );\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int maxn = 123567;\nvector<int> g[maxn];\nint dfs(int cur, int pr){\n    int ans = 0;\n    for(int v : g[cur])\n        if(v != pr)\n            ans ^= dfs(v, cur) + 1;\n    return ans;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int e = 0; e < n - 1; e ++){\n        int x, y; scanf(\"%d %d\", &x, &y); x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if(dfs(0, -1)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define size(n) ( int( n.size() ) )\n#define sqr(n) ( (n) * (n) )\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 1e5 + 5;\nvector < int > g[N];\nint parent[N];\nll f[N], res = 0;\n\nvoid dfs( int v ){\n    if ( ( v != 1 ) && ( size(g[v]) == 1 ) ){\n        f[v] = 1;\n        return;\n    }\n    ll pr = 0, sf = 0;\n    for ( int j = 0; j < size(g[v]); j++ ){\n        int u = g[v][j];\n        if ( u != parent[v] ){\n            parent[u] = v;\n            dfs(u);\n            sf ^= f[u];\n        }\n    }\n    if ( v == 1 ){\n        res = sf;\n    }\n    vector < pair < int, int > > s;\n    ll e, sum = 0;\n    for ( int j = 0; j < size(g[v]); j++ ){\n        int u = g[v][j];\n        if ( u != parent[v] ){\n            sf ^= f[u];\n            e = ( sf ^ pr ^ 1 );\n            sum = 0;\n            for ( int i = 60; i >= 0; i-- ){\n                int bitU = ( f[u] >> i ) & 1LL;\n                int bitE = ( e >> i ) & 1LL;\n                if ( bitU == 1 ){\n                    if ( bitE == 0 ){\n                        s.pb( mp( sum, sum + ( 1LL << i ) - 1 ) );\n                    }\n                    else{\n                        s.pb( mp( sum + ( 1LL << i ), sum + ( 1LL << i ) - 1 + ( 1LL << i ) ) );\n                    }\n                }\n                sum += ( 1LL << i ) * ( bitE ^ bitU );\n            }\n            pr ^= f[u];\n        }\n    }\n    sort( s.begin(), s.end() );\n\n    int l = 0;\n    for ( int i = 0; i < size(s); i++ ){\n        int cl = s[i].first;\n        int cr = s[i].second;\n        if ( cl > l + 1 ){\n            break;\n        }\n        else{\n            l = cr;\n        }\n    }\n    f[v] = l + 1;\n}\n\nint main(){\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    int n;\n    scanf(\"%d\",&n);\n    for ( int i = 1; i <= n - 1; i++ ){\n        int v, u;\n        scanf(\"%d %d\",&v,&u);\n        g[v].pb(u);\n        g[u].pb(v);\n    }\n    dfs(1);\n    if ( res ){\n        puts(\"Alice\");\n    }\n    else{\n        puts(\"Bob\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\tvector<vi> gr(n);\n\trep(_,1,n){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\t--x,--y;\n\t\tgr[x].push_back(y);\n\t\tgr[y].push_back(x);\n\t}\n\n\tfunction<int(int,int)> nim = [&](int v, int par){\n\t\tint val = 0;\n\t\ttrav(u, gr[v]) if(par != u) val ^= nim(u, v);\n\t\treturn val+1;\n\t};\n\tint val = 0;\n\ttrav(u, gr[0]) val ^= nim(u, 0);\n\tcout << (val==0 ? \"Bob\" : \"Alice\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nvector<vec>G(N);\nint dfs(int x,int p){\n  int g=0;\n  for(auto e:G[x]){\n    if(e!=p){\n    g^=(dfs(e,x)+1);}\n  }\n}\nmain(){\n    int n=in();\n  rep(i,n-1){\n  int a=in(),b=in();\n  G[a].pb(b);\n  G[b].pb(a);}\n  cout<<((dfs(1,0)!=0)?“Alice”:“Bob”);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,fa[N];\nvi seq;\nvi g[N];queue<int> q;\nbool vis[N];\n\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tif(n%2==0){puts(\"Alice\");return 0;}\n\tq.push(1);vis[1]=1;\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tif(x!=1) seq.pb(x);\n\t\tfor(int y:g[x])\n\t\t\tif(!vis[y]) q.push(y),fa[y]=x,vis[y]=1;\n\t}\n\tfor(int i=0;i<n-1;i+=2)\n\t\tif(fa[seq[i+1]]==seq[i]){puts(\"Alice\");return 0;}\n\tputs(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<int> G[114514];\nint dfs(int v,int p){\n  int res=0,cnt=0;\n  for(int u:G[v]){\n    if(u==p) continue;\n    res^=dfs(u,v);\n    cnt++;\n  }\n  if(cnt==1) res++;\n  //cout<<v<<\" \"<<res<<endl;\n  return res;\n}\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint main() {\n\tint n,i,du=0,father,son;\n\tscanf(\"%d\",&n);\n\t\tfor (i=1;i<=n-1;i++) {\n\t\t\tscanf(\"%d%d\",&father,&son);\n\t\t\tif (father==1||son==1) du++;\n\t\t}\n\tif (du%2) cout << \"Alice\"; else cout << \"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i + 1 < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> grundy(n);\n  function<void(int, int)> dfs = [&](int v, int pv) {\n    for (int to : g[v]) {\n      if (to == pv) {\n        continue;\n      }\n      dfs(to, v);\n      grundy[v] ^= (grundy[to] + 1);\n    }\n  };\n  dfs(0, -1);\n  if (grundy[0] > 0) {\n    cout << \"Alice\\n\";\n  } else {\n    cout << \"Bob\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nvector<int> adj[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nint SG[MAXN + 5];\n\ninline void dfs(int u, int fa)\n{\n\tSG[u] = 0;\n\tfor(auto v : adj[u]) if(v != fa)\n\t{\n\t\tdfs(v, u);\n\t\tSG[u] ^= SG[v] + 1;\n\t}\n}\n\ninline void solve()\n{\n\tdfs(1, 0);\n\tputs(SG[1] ? \"Alice\" : \"Bob\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 2000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define seg_size 524288\nvector<int> vertexs[200000];\nstring ans[2] = { \"Alice\",\"Bob\" };\nint dfs(int now, int back) {\n\tint ans = 0;\n\tfor (int i = 0;i < vertexs[now].size();++i) {\n\t\tif (vertexs[now][i] != back) {\n\t\t\tans ^= 1+dfs(vertexs[now][i], now);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tvertexs[a].push_back(b);\n\t\tvertexs[b].push_back(a);\n\t}\n\tif (dfs(1, -1) != 0) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> ch[100005];\nint n;\n\nint dfs(int at, int par=-1)\n{\n\tint ans = 0;\n\tfor (int u: ch[at]) if (u != par) ans ^= (dfs(u, at)+1);\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1;i < n;i++)\n\t{\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\tch[a].push_back(b);\n\t\tch[b].push_back(a);\n\t}\n\tif (dfs(0)) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nvector<int> e[1010101];\nint n,sg[1010101],u,v;\nvoid dfs(int u,int faa){\n    sg[u]=0;\n    for (auto v:e[u]){\n        if (v==faa) continue;\n        dfs(v,u);\n        sg[u]^=sg[v]+1;\n    }\n}\nint main(){\n    n=read();\n    for (int i=1;i<n;++i){\n        int u=read(),v=read();\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 10000000;\n\nint n;\nVI e[100000];\nbool did[1000];\n\nint grundy(int p){\n\tdid[p]=true;\n\tint res=0;\n\tEACH(i,e[p]){\n\t\tint q=*i;\n\t\tif(did[q])continue; // is parent;\n\t\tres = res ^ (grundy(q) + 1);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tREP(i,n-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\t--x;--y;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tcout << (grundy(0) ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*  AtCoder Grand Contest 017. Problem D, by Abreto<m@abreto.net>. */\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define MAXN    100001\n\nint N;\nvector<int> conj[MAXN];\nint visited[MAXN];\n\nint sg(int id)\n{\n    int ret = 0;\n    visited[id] = 1;\n    for(auto p : conj[id])\n        if(!visited[p])\n            ret ^= sg(p)+1;\n    return ret;\n}\n\nint main(void)\n{\n    int i = 0;\n    int xi = 0, yi = 0;\n\n    scanf(\"%d\", &N);\n    for(i = 1;i < N;++i)\n    {\n        scanf(\"%d%d\", &xi, &yi);\n        conj[xi].push_back(yi);\n        conj[yi].push_back(xi);\n    }\n    printf(\"%s\\n\", (0==sg(1))?\"Bob\":\"Alice\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],sg[maxn];\nint n,tot;\ninline void add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nvoid dfs(int now,int fa)\n{\n\tsg[now]=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tdfs(e[i].to,now);\n\t\t\tsg[now]^=(sg[e[i].to]+1);\n\t\t}\n}\nint main()\n{\n\tn=read();\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tdfs(1,-1);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define maxn 1000001\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint nt[maxn], go[maxn], fi[maxn], n, cnt, sg[maxn];\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n}\nvoid dfs(int x, int fa){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; if(v == fa) continue;\n        sg[x] ^= sg[v] + 1;\n    }\n}\nint main(){\n    n = read();\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add(x, y); add(y, x);\n    }\n    dfs(1, 0);\n    if(sg[1] == 0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    int s = 0;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        s ^= !d[h];\n    }\n    if (sz(v[u]) - (u ? 1: 0) == 1) {\n        d[u] = 1;\n    }\n    d[u] |= s;\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> adia[100010];\n\nint calc(int nod, int tata)\n{\n    int ans = 0;\n    vector <int> fii;\n    for (auto i : adia[nod]) {\n        if (i == tata)\n            continue;\n        int x = calc(i, nod);\n        ans ^= x;\n        fii.push_back(x);\n        //fii.push_back(calc(i, nod));\n    }\n\n    if (fii.size() == 1)\n        return fii.back() + 1;\n\n    return ans;\n/*\n    if (fii.size() == 0)\n        return 0;\n    sort(fii.begin(), fii.end());\n\n    int mex = 0;\n    for (auto i : fii) {\n        if (i == mex)\n            mex++;\n        else if (i > mex)\n            return mex;\n    }\n    return mex;*/\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    cout << (calc(1, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000500\nusing namespace std;\n\nvector<int> E[N];\nint sg[N],n;\ninline int rd() {int r;scanf(\"%d\",&r);return r;}\nvoid dfs(int u,int f) {\n\tsg[u] = 0;\n\tfor (int i=0;i<(int)E[u].size();i++) {\n\t\tint v = E[u][i]; if (v == f) continue;\n\t\tdfs(v,u); sg[u] ^= sg[v]+1;\n\t}\n}\n\nint main() {\n\tn = rd();\n\tfor (int i=1;i<n;i++) {\n\t\tint a = rd(), b = rd();\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\t\n\t}\n\tdfs(1,1);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nVI e[100000];\n\nint dfs(int now, int past){\n\tint ret = 0;\n\tfor (int next : e[now]){\n\t\tif (next == past) continue;\n\t\tret ^= (dfs(next, now) + 1);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--;\n\t\tv--;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\n\tcout << (dfs(0, -1) > 0 ? \"Alice\" : \"Bob\") << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n \n#define N (ll)(1e6+3)\n#define INF (ll)(1e18+3)\n#define MOD (ll)(1e9+7)\n \n#define ll long long\n#define rep(i,a,n) for(ll i = a; i < n; i++)\n#define per(i,a,n) for(ll i = n-1; i >= a; i--)\n \n//using namespace __gnu_pbds;\nusing namespace std;\n \n// typedef\n// tree<\n//     pair<ll,ll>,\n//     null_type,\n//     less<pair<ll,ll>>,\n//     rb_tree_tag,\n//     tree_order_statistics_node_update>\n// ordered_set;\n \n \nll n;\nll par[N];\nvector<ll> g[N];\nll d[N];\n \nvoid dfs(ll u, ll p) {\n    vector<ll> v;\n \n    rep(i,0,g[u].size()) {\n        ll ch = g[u][i];\n        if (ch == p) continue;\n        dfs(ch,u);\n        v.push_back(d[ch]);\n    }\n \n    if (v.size() == 1)\n        d[u] = v[0]+1;\n    else {\n        ll mask = 0;\n        rep(i,0,v.size()) {\n            mask ^= (v[i]+1);\n        }\n        d[u] = mask;\n    }\n}\n \nvoid solve() {\n    cin >> n;\n    rep(i,0,n-1) {\n        ll a, b; cin >> a >> b; a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0,0);\n    if (d[0]) {\n        cout << \"Alice\" << endl;\n    }\n    else {\n        cout << \"Bob\" << endl;\n    }\n}\n \n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (int64_t)(n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (int64_t)(n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\n#define chmax(a, b) (a) = max(a, b)\n#define chmin(a, b) (a) = min(a, b)\n\nint dfs(int node, int parent, const vector<vector<int>> &edge) {\n  int grundy = 0;\n  for (int c : edge[node]) {\n    if (c != parent) {\n      grundy ^= dfs(c, node, edge) + 1;\n    }\n  }\n  return grundy;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  vector<vector<int>> edge(N);\n  rep(i, N - 1) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n\n  cout << (dfs(0, 0, edge) != 0 ? \"Alice\" : \"Bob\") << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,d;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2,u,v;i<=n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tif(u==1)d++;\n\t\tif(v==1)d++;\n\t}\n\tif(d==1)return puts(\"Alice\"),0;\n\telse return printf(\"%s\",(n+d)%2==0?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> adia[100010];\n\nint calc(int nod, int tata)\n{\n    vector <int> fii;\n    for (auto i : adia[nod]) {\n        if (i == tata)\n            continue;\n        fii.push_back(calc(i, nod));\n    }\n\n    if (fii.size() == 0)\n        return 0;\n    sort(fii.begin(), fii.end());\n\n    int mex = 0;\n    for (auto i : fii) {\n        if (i == mex)\n            mex++;\n        else if (i > mex)\n            return mex;\n    }\n    return mex;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    cout << (!calc(1, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n#define mat vector<vector<int>>\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\nconst db EPS = 1e-7;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nint N;\nvector<int> G[100010];\n\nint dfs(int v, int p){\n    int res = 0;\n    int son = 0;\n    for(auto u : G[v]){\n        if(u != p) res ^= dfs(u, v), son++; \n    }\n    return res + 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    for(int i = 1; i < N; i++){\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n \n    }\n    cout << (dfs(1, 0) - 1 == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define For(i,a,b) for(int i=a;i<b;i++)\nconst int M=100005;\nbool has[M];\nint n,fa[M],sg[M],res;\nvector<int>G[M];\nint Tz(int x=1,int f=-1){\n\tint res=sg[x];\n\tFor(i,0,G[x].size())if(G[x][i]!=f)\n\t\tres^=(Tz(G[x][i],x)+1);\t\t\t\n\treturn res;\n}\nint main(){\n    scanf(\"%d\",&n);\n    For(i,0,n-1){\n    \tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x-1].push_back(y-1);\n\t\tG[y-1].push_back(x-1);\n\t}\n    printf(\"%s\",Tz()?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * じょえチャンネル\n * 高評価・チャンネル登録よろしくおねがいします！\n * https://www.youtube.com/channel/UCRXsI3FL_kvaVL9zoolBfbQ\n */\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n\n\n\n//here!!!\n// define int long long !!!!!\n\n#define int long long\n\n// define int long long !!!!!\n\n\n#define mod 1000000007ll\n//constexpr int mod = 998244353ll;\n\ntypedef long long ll;\n\n#ifdef int\n#define inf (int)(3e18)\n#else\n#define inf (int)(5e8)\n#endif\n\n#define intt long long\n#define itn long long\n#define innt long long\n#define P pair<long long,long long>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define rev_rep(i,n) for(int i=n-1;i>=0;i--)\n#define REV_REP(i,n) for(int i=n;i>=1;i--)\n\n#define ALL(v) v.begin(),v.end()\n\n#define smallpriority_queue(x) priority_queue<x,vector<x>,greater<x>>\n\nusing namespace std;\n\n//Library\n//モッドパウ\ninline int modpow(int x, int y, int m = mod) {\n    int res = 1;\n    while (y) {\n        if (y & 1) {\n            res *= x;\n            res %= m;\n        }\n        x = x * x % m;\n        y /= 2;\n    }\n    return res;\n}\n\nint mypow(int x, int y) {\n    int res = 1;\n    while (y) {\n        if (y % 2) {\n            res *= x;\n        }\n        x = x * x;\n        y /= 2;\n    }\n    return res;\n}\n//is the number (x) a prime number?\nbool prime(int x) {\n    if (!x || x == 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= x; i++) {\n        if (!(x % i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//saidai-kouyakusuu\ninline int gcd(int x, int y) {\n    if (!y) {\n        return x;\n    }\n    return gcd(y, x % y);\n}\n\n\n//number of keta\nint keta(int x) {\n    int ans = 0;\n    while (x) {\n        x /= 10;\n        ans++;\n    }\n    return ans;\n}\n\n//number of 2shinsuu keta\nint bitketa(int x) {\n    int ans = 0;\n    while (x) {\n        x >>= 1;\n        ans++;\n    }\n    return ans;\n}\n\n//sum of keta\nint ketasum(int x) {\n    int ans = 0;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ninline int lcm(int x, int y) {\n    int ans = x / gcd(x, y) * y;\n    return ans;\n}\nint twobeki(int x) {\n    int ans = 0;\n    while (1) {\n        if (!(x & 1)) {\n            ans++;\n            x >>= 1;\n        }\n        else {\n            break;\n        }\n    }\n    return ans;\n}\n\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n    if (lhs < rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n    if (lhs > rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\nvoid Yes(){\n    cout<<\"Yes\"<<endl;\n}\nvoid No(){\n    cout<<\"No\"<<endl;\n}\nvoid YES(){\n    cout<<\"YES\"<<endl;\n}\nvoid NO(){\n    cout<<\"NO\"<<endl;\n}\n\n\n#define fin(i) scanf(\"%lld\",&i)\n#define fout(i) printf(\"%lld\",i)\n#define fendl printf(\"\\n\")\n\nint kai(int x, int y) {\n    int res = 1;\n    for (int i = x - y + 1; i <= x; i++) {\n        res *= i; res %= mod;\n    }\n    return res;\n}\n\nint comb(int x, int y) {\n    if (y > x)return 0;\n    //    cout<<kai(x, y)<<' '<<modpow(kai(y, y), mod - 2)<<endl;\n    return kai(x, y) * modpow(kai(y, y), mod - 2) % mod;\n}\n\n\n\n#define vecin(v) for(int i=0;i<v.size();i++)scanf(\"%lld\",&v[i]);\n#define vecout(v) {for(int i=0;i<(int)v.size();i++)printf(\"%lld \",v[i]);printf(\"\\n\");}\n\n\ntemplate<typename T>\nclass kaageSegTree {\nprotected:\n    unsigned int n = 1, rank = 0;\n    std::vector<T> node;\n    T nodee;\n    virtual T nodef(const T&, const T&)const = 0;\npublic:\n    kaageSegTree(unsigned int m, T init, T nodee):nodee(nodee) {\n        while (n < m) {\n            n *= 2;\n            rank++;\n        }\n        node.resize(2 * n);\n        for (unsigned int i = n; i < 2 * n; i++)node[i] = init;\n    }\n    kaageSegTree(const std::vector<T>& initvec, T nodee):nodee(nodee) {\n        unsigned int m = initvec.size();\n        while (n < m) {\n            n *= 2;\n            rank++;\n        }\n        node.resize(2 * n);\n        for (unsigned int i = n; i < 2 * n; i++) {\n            if (i - n < m)node[i] = initvec[i - n];\n        }\n    }\n    virtual void update(int i, T x) {\n        i += n;\n        node[i] = x;\n        while (i != 1) {\n            i >>= 1;\n            node[i] = nodef(node[2 * i], node[2 * i + 1]);\n        }\n    }\n    virtual T query(int l, int r) {\n        l += n; r += n;\n        T ls = nodee, rs = nodee;\n        while (l < r) {\n            if (l & 1) {\n                ls = nodef(ls, node[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                rs = nodef(node[r], rs);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return nodef(ls, rs);\n    }\n    virtual T operator[](const int& x) {\n        return node[n + x];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n};\nclass RSQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return lhs+rhs;}\npublic:\n    RSQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, 0) {}\n    RSQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, 0) {}\n};\nclass RMiQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return std::min(lhs,rhs);}\npublic:\n    RMiQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, inf) {}\n    RMiQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, inf) {}\n};\nclass RMaQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return std::max(lhs,rhs);}\npublic:\n    RMaQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, -inf) {}\n    RMaQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, -inf) {}\n};\ntemplate<typename T, typename U>\nclass IntervalSegTree :public kaageSegTree<T> {\nprotected:\n    using kaageSegTree<T>::n;\n    using kaageSegTree<T>::rank;\n    using kaageSegTree<T>::node;\n    using kaageSegTree<T>::nodef;\n    using kaageSegTree<T>::nodee;\n    std::vector<U> lazy;\n    std::vector<bool> lazyflag;\n    std::vector<int> width;\n    virtual void lazyf(U&, const U&) = 0;\n    virtual void updf(T&, const U&, const unsigned int&) = 0;\n    void eval(int k) {\n        for (int i = rank; i > 0; i--) {\n            int nk = k >> i;\n            if (lazyflag[nk]) {\n                updf(node[2 * nk], lazy[nk], width[2 * nk]);\n                updf(node[2 * nk + 1], lazy[nk], width[2 * nk + 1]);\n                if (lazyflag[2 * nk])lazyf(lazy[2 * nk], lazy[nk]);\n                else lazy[2 * nk] = lazy[nk];\n                if (lazyflag[2 * nk + 1])lazyf(lazy[2 * nk + 1], lazy[nk]);\n                else lazy[2 * nk + 1] = lazy[nk];\n                lazyflag[2 * nk] = lazyflag[2 * nk + 1] = true;\n                lazyflag[nk] = false;\n            }\n        }\n    }\npublic:\n    IntervalSegTree(unsigned int m, T init, T nodee) :kaageSegTree<T>(m, init, nodee) {\n        lazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n        width[1] = n;\n        for (unsigned int i = 2; i < 2 * n; i++) {\n            width[i] = width[i >> 1] >> 1;\n        }\n    }\n    IntervalSegTree(T nodee, const std::vector<T>& initvec) :kaageSegTree<T>(initvec, nodee) {\n        lazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n        width[1] = n;\n        for (unsigned int i = 2; i < 2 * n; i++) {\n            width[i] = width[i >> 1] >> 1;\n        }\n    }\n    void update(int i, U x) {\n        i += n;\n        eval(i);\n        updf(node[i], x, width[i]);\n        if (lazyflag[i])lazyf(lazy[i], x);\n        else {\n            lazyflag[i] = true;\n            lazy[i] = x;\n        }\n        while (i /= 2)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    void update(int l, int r, U x) {\n        l += n; r += n;\n        int nl = l, nr = r;\n        while (!(nl & 1))nl >>= 1;\n        while (!(nr & 1))nr >>= 1;\n        nr--;\n        eval(nl); eval(nr);\n        while (l < r) {\n            if (l & 1) {\n                updf(node[l], x, width[l]);\n                if (lazyflag[l])lazyf(lazy[l], x);\n                else {\n                    lazyflag[l] = true;\n                    lazy[l] = x;\n                }\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                updf(node[r], x, width[r]);\n                if (lazyflag[r])lazyf(lazy[r], x);\n                else {\n                    lazyflag[r] = true;\n                    lazy[r] = x;\n                }\n            }\n            l >>= 1; r >>= 1;\n        }\n        while (nl >>= 1)node[nl] = nodef(node[2 * nl], node[2 * nl + 1]);\n        while (nr >>= 1)node[nr] = nodef(node[2 * nr], node[2 * nr + 1]);\n    }\n    T query(int l, int r) {\n        l += n; r += n;\n        eval(l); eval(r - 1);\n        int ls = nodee, rs = nodee;\n        while (l < r) {\n            if (l & 1) {\n                ls = nodef(ls, node[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                rs = nodef(node[r], rs);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return nodef(ls, rs);\n    }\n    T operator[](const int& x) {\n        eval(n + x);\n        return node[n + x];\n    }\n    T queryForAll() {\n        return node[1];\n    }\n};\nclass RAQRSQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return a + b; }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += width * b; }\npublic:\n    RAQRSQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, 0) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRSQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>((int)0, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RAQRMiQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::min(a, b); }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += b; }\npublic:\n    RAQRMiQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRMiQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RAQRMaQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::max(a, b); }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += b; }\npublic:\n    RAQRMaQ(unsigned int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, -inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRMaQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(-inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRSQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return a + b; }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = width * b; }\npublic:\n    RUQRSQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, 0) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRSQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>((int)0, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRMiQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::min(a, b); }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n    RUQRMiQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRMiQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRMaQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::max(a, b); }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n    RUQRMaQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, -inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRMaQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(-inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\n\n////SegTree\n//template <class T>\n//class SegTree {\n//    int n;                       // 葉の数\n//    vector<T> node;              // データを格納するvector\n//    T def;                       // 初期値かつ単位元\n//    function<T(T, T)> operation; // 区間クエリで使う処理\n//    function<T(T, T)> update;    // 点更新で使う処理\n//\n//    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n//    T _query(int a, int b, int k, int l, int r) {\n//        if (r <= a || b <= l) return def; // 交差しない\n//        if (a <= l && r <= b)\n//            return node[k]; // a,l,r,bの順で完全に含まれる\n//        else {\n//            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n//            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n//            return operation(c1, c2);\n//        }\n//    }\n//\n//public:\n//    // _n:必要サイズ, _def:初期値かつ単位元, _operation:クエリ関数,\n//    // _update:更新関数\n//    SegTree(size_t _n, T _def, function<T(T, T)> _operation,\n//            function<T(T, T)> _update)\n//    : def(_def), operation(_operation), update(_update) {\n//        n = 1;\n//        while (n < _n) {\n//            n *= 2;\n//        }\n//        node = vector<T>(2 * n , def);\n//    }\n//\n//    // 場所i(0-indexed)の値をxで更新\n//    void change(int i, T x) {\n//        i += n - 1;\n//        node[i] = update(node[i], x);\n//        while (i > 0) {\n//            i = (i - 1) / 2;\n//            node[i] = operation(node[i * 2 + 1], node[i * 2 + 2]);\n//        }\n//    }\n//\n//    // [a, b)の区間クエリを実行\n//    T query(int a, int b) {\n//        return _query(a, b, 0, 0, n);\n//    }\n//\n//    // 添字でアクセス\n//    T operator[](int i) {\n//        return node[i + n - 1];\n//    }\n//};\n\ntemplate <class T>\nclass SegTree {\n    int n;\n    vector<T> node;\n    T def;\n    function<T(T,T)> operation;\n    function<T(T,T)> update;\n    \npublic:\n    SegTree(unsigned int _n, T _def, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    : def(_def), operation(_operation), update(_update) {\n        n=1;\n        while (n < _n) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n    }\n    SegTree(vector<int>& initvec, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    :  operation(_operation), update(_update) {\n        n=1;\n        while (n < initvec.size()) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n        for(int i=n;i<n+initvec.size();i++){\n            node[i]=initvec[i-n];\n        }\n        for(int i=n-1;i>=1;i--){\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    void change(int i,T x){\n        i+=n;\n        node[i]=update(node[i],x);\n        while (i>=1) {\n            i>>=1;\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    T query(int l, int r){\n        l+=n;\n        r+=n;\n        T rx=def,lx=def;\n        while(l<r){\n            if (l&1) {\n                lx=operation(lx,node[l]);\n                l++;\n            }\n            if (r&1) {\n                r--;\n                rx=operation(node[r],rx);\n            }\n            l>>=1; r>>=1;\n        }\n        return operation(lx,rx);\n    }\n    T operator [] (const int& x){\n        return node[x+n];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n    \n};\n\n#define R_MIN ([](long long a, long long b) { return min(a, b); })\n#define R_MAX ([](long long a, long long b) { return max(a, b); })\n#define R_SUM ([](long long a, long long b) { return a + b; })\n\n#define NORMAL_UPDATE ([](long long a, long long b) { return b; })\n#define ADD_UPDATE ([](long long a, long long b) { return a + b; })\n#define MINUS_UPDATE ([](long long a, long long b) { return a - b; }\n\nclass Union_Find {\n    vector<int> par;\n    vector<int> rankmy;\n    vector<int> ookisa;\n    \npublic:\n    Union_Find(int size) {\n        par = vector<int>(size);\n        rankmy = vector<int>(size);\n        ookisa=vector<int>(size);\n        for (int i = 0; i < size; i++) {\n            par[i] = i;\n            ookisa[i]=1;\n        }\n    }\n    \n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n    \n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return;\n        }\n        if (rankmy[x] < rankmy[y]) {\n            par[x] = y;\n            ookisa[y]+=ookisa[x];\n            ookisa[x]=0;\n        }\n        else {\n            par[y] = x;\n            ookisa[x]+=ookisa[y];\n            ookisa[y]=0;\n            if (rankmy[x] == rankmy[y]) {\n                rankmy[x]++;\n            }\n        }\n    }\n    int size(int i){\n        i=find(i);\n        return ookisa[i];\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n};\n\nclass BIT {\n    vector<int> data;\n    int size=0;\npublic:\n    BIT(int _size){\n        data=vector<int>(_size+1);\n        size=_size;\n    }\n    void add(int i,int x){\n        while (i<=size) {\n            data[i]+=x;\n            i += i & -i;\n        }\n    }\n    int sum(int i){\n        assert(i<=size);\n        int s=0;\n        while(i>0){\n            s+=data[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    int lower_bound(int x){\n        if(x<=0){\n            return 0;\n        }else{\n            int i=0;int r=1;\n            while(r<size) r=r<<1;\n            for(int len=r;len>0;len=len>>1) {\n                if(i+len<size && data[i+len]<x){\n                    x-=data[i+len];\n                    i+=len;\n                }\n            }\n            return i+1;\n        }\n    }\n};\n\n//Union-Find-End\n\nint perm[2000005];\nvoid init_perm() {\n    perm[0] = 1;\n    REP(i, 2000004) {\n        perm[i] = perm[i - 1] * i % mod;\n    }\n}\n\nint nCk(int x, int y) {\n    if (y>x) {\n        return 0;\n    }\n    if (x<0) {\n        return 0;\n    }\n    return perm[x] * modpow(perm[x - y], mod - 2) % mod * modpow(perm[y], mod - 2) % mod;\n}\n\ndouble kyori(pair<int, int> f, pair<int, int> s) {\n    double ans = 0;\n    double t = fabs(f.first - s.first);\n    double y = fabs(f.second - s.second);\n    ans = sqrt(t * t + y * y);\n    return ans;\n}\n\ninline string stringmax(string& x,string& y){\n    if (x.size()>y.size()) {\n        return x;\n    }\n    if (x.size()<y.size()) {\n        return y;\n    }\n    rep(i,x.size()){\n        if (x[i]>y[i]) {\n            return x;\n        }\n        if (x[i]<y[i]) {\n            return y;\n        }\n    }\n    return x;\n}\n\n//vector<int>  RollingHash(string &s, string& t){\n//    vector<int> ans;\n//    __int128 h=0,hamod=0,ki=0,kim=0,hikaku=0,one=0;\n//    one=1;\n//    ki=1000000007ll;\n//    hamod=(one<<61)-1;\n//    kim=1;\n//    rep(i,t.size()){\n//        hikaku*=ki;\n//        h*=ki;\n//        kim*=ki;\n//        hikaku+=t[i];\n//        h+=s[i];\n//        hikaku%=hamod;\n//        h%=hamod;\n//        kim%=hamod;\n//    }\n//    rep(i,(int)s.size()-(int)t.size()+1){\n//        if (h==hikaku) {\n//            ans.emplace_back(i);\n//        }\n//        h*=ki;\n//        h%=hamod;\n//        h+=s[i+(int)t.size()];\n//        h%=hamod;\n//        h+=hamod;\n//        h-=s[i]*kim%hamod;\n//        h%=hamod;\n//    }\n//    return ans;\n//}\nstruct edge {\n    int to;\n    int length;\n    edge(int _to, int _length){\n        to=_to;\n        length=_length;\n    }\n};\nvector<int> djkstra(vector<vector<edge>> &road,int start){\n    vector<int> kyo(road.size(),inf);\n    smallpriority_queue(P) q;\n    q.push({0,start});\n    kyo[start]=0;\n    while (q.size()) {\n        int x=q.top().second;\n        itn now=q.top().first;\n        q.pop();\n        if (kyo[x]<now) {\n            continue;\n        }\n        for(auto&i:road[x]){\n            if (kyo[i.to]>now+i.length) {\n                kyo[i.to]=now+i.length;\n                q.push({kyo[i.to],i.to});\n            }\n        }\n    }\n    return kyo;\n}\n\ntemplate <class T>\nvoid change_to_unique(vector<T> &v){\n    std::sort(ALL(v));\n    auto k=unique(ALL(v));\n    if(k!=v.end())v.erase(k,v.end());\n}\n\n#define endl \"\\n\" //interactive の時に注意！！！\n#define Endl \"\\n\" //interactive の時に注意！！！\n#define printd cout<<fixed<<setprecision(10)\n#define rrep(i,f,s) for(int i=f;i<s;i++)\n#define RREP(i,f,s) for(int i=f;i<=s;i++)\n/*------------------Library Zone!------------------*/\n\nint n,x[100004],y[100004],ans;\nvector<itn> road[100004];\nint solve(int x,int par){\n    int now=0;\n    for(auto&i:road[x]){\n        if (i==par) {\n            continue;\n        }\n        now^=solve(i,x)+1;\n    }\n    return now;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    cin>>n;\n    rep(i,n-1){\n        cin>>x[i]>>y[i];\n        road[x[i]].emplace_back(y[i]);\n        road[y[i]].emplace_back(x[i]);\n    }\n    if (solve(1, 0)) {\n        cout<<\"Alice\"<<endl;\n    }else{\n        cout<<\"Bob\"<<endl;\n    }\n}\n \n \n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nvector<int> e[ten(5)];\nll hs[ten(5)];\n\nll dfs(int v, int par) {\n\tll pv = 1;\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tll tmp = dfs(to, v);\n\t\tpv ^= tmp * (ten(9) + 7);\n\t}\n\n\treturn hs[v] = pv;\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tdfs(0, -1);\n\tmap<ll, int> dm;\n\tFOR(i, n) if(i) dm[hs[i]] ^= 1;\n\n\tbool bob = true;\n\tfor (auto kv : dm) {\n\t\tif (kv.second != 0) bob = false;\n\t}\n\n\tputs(bob ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n;\n\nvector<int> G[maxn];\n\nint f[maxn];\n\nvoid dfs(int u,int fa){\n\tfor(auto v:G[u])if(v!=fa){\n\t\tdfs(v,u);\n\t\tf[u]^=f[v]+1;\n\t}\n}\n\nvoid Work(){\n\tdfs(1,0);\n\tif(f[1])puts(\"Alice\");else puts(\"Bob\");\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,2,n){\n\t\tint u,v;read(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nvector<int> es[114514];\nmap<int, pii> memo;\n\npii Dfs(int v, int p) {\n  if (memo.count(v)) return memo[v];\n\n  int cnt = 0;\n  for (int u : es[v]) {\n    if (u == p) continue;\n    cnt++;\n  }\n  if (!cnt) return memo[v] = pii(-1, -1);\n    \n  bool first = true;\n  cnt = 0;\n  for (int u : es[v]) {\n    if (u == p) continue;\n\n    auto res = Dfs(u, v);\n    if (res.X == -1) {\n      first = false;\n      cnt++;\n    }\n  }\n \n  pii ret(1-cnt%2, cnt%2);\n  bool spe = false;\n  for (int u : es[v]) {\n    if (u == p) continue;\n\n    auto res = Dfs(u, v);\n    if (res.X == -1) continue;\n\n    if (first) {\n      ret.X = 0;\n      ret.Y = res.X;\n      if (res.X == 0) spe = true;\n    } else {\n      if (ret.X == 1) ret.X = 0;\n      else ret.X = res.Y;\n\n      if (ret.Y == 1) {\n        assert(!spe);\n        ret.Y = 0;\n      } else if (spe) {\n        assert(ret.Y == 0);\n        ret.Y = !res.X;\n      } else {\n        ret.Y = res.X;\n      }\n      spe = false;\n    }\n    first = false;\n  }\n  //printf(\"%d: %d, %d\\n\", v+1, ret.X, ret.Y);\n  return memo[v] = ret;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n    es[x].eb(y);\n    es[y].eb(x);\n  }\n\n  auto res = Dfs(0, 0);\n  if (res.X == 0) puts(\"Alice\");\n  else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\n#include <time.h> \n \nusing namespace std;\nlong long mod=1e9+7;\nlong long INF=1e7;\ndouble EPS = 1e-12;\ntypedef long long int lld;\ndouble tick(){static clock_t oldt;clock_t newt=clock();double diff=1.0*(newt-oldt)/CLOCKS_PER_SEC;oldt = newt;return diff;}\n#define rep(i,a,n) for(long long int i = (a); i <= (n); ++i)\n#define repI(i,a,n) for(int i = (a); i <= (n); ++i)\n#define repD(i,a,n) for(long long int i = (a); i >= (n); --i)\n#define repDI(i,a,n) for(int i = (a); i >= (n); --i)\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define sc(a) scanf(\"%lld\",&a)\n#define sc2(a,b) scanf(\"%lld%lld\",&a,&b)\n#define sc3(a,b,c) scanf(\"%lld%lld%lld\",&a,&b,&c)\n#define scd(a) scanf(\"%d\",&a)\n#define scd2(a,b) scanf(\"%d%d\",&a,&b)\n#define scd3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define scf(a) scanf(\"%lf\",&a)\n#define scf2(a,b) scanf(\"%lf%lf\",&a,&b)\n#define scf3(a,b,c) scanf(\"%lf%lf%lf\",&a,&b,&c)\n#define prL(a) printf(\"%lld\\n\",a)\n#define prS(a) printf(\"%lld \",a)\n#define prdL(a) printf(\"%d\\n\",a)\n#define prdS(a) printf(\"%d \",a)\n#define all(c) c.begin(), c.end()\n#define sz(a) ((int)a.size())\n#define Error(x) cout<< #x << \" = \" << (x) <<endl;\n#define Error2(a,b) cout<<\"( \"<<#a<<\" , \"<<#b<<\" ) = ( \"<<(a)<<\" , \"<<(b)<<\" )\\n\";\n#define Error3(a,b,c) cout<<\"(\"<<#a<<\" , \"<<#b<<\" , \"<<#c<<\" ) = ( \"<<(a)<<\" , \"<<(b)<<\" , \"<<(c)<<\")\\n\";\n#define Error4(a,b,c,d) cout<<\"(\"<<#a<<\" , \"<<#b<<\" , \"<<#c<<\" , \"<<#d<<\" ) = ( \"<<(a)<<\" , \"<<(b)<<\" , \"<<(c)<<\" , \"<<(d)<<\")\\n\";\n#define errop(a) cout<<#a<<\" = ( \"<<((a).x)<<\" , \"<<((a).y)<<\" )\\n\";\n#define mset(a, v) memset(a, v, sizeof(a))\n#define popcount __builtin_popcountll\n \ntypedef pair<lld,lld> PA;\n \nlld powP(lld a,lld b){\n    if(b==0) return 1%mod;\n    lld k;\n    k=powP(a,b/2);\n    k=k*k%mod;\n    if(b%2==0) return k;\n    else return a*k%mod;\n}\n \nbool bitSet(lld n,lld i){\n    if((n&(1LL<<i))!=0) return true;\n    else return false;\n}\n \nlld findGcd(lld a,lld b){\n    if(a==0) return b;\n    else return findGcd(b%a,a);\n}\n \n#define lim 500010\n#define lim2 200003\n#define qqqqqq 210\n// inline lld sqr(lld x) { return x * x; }\n// unordered_map<lld,lld>::iterator it;\n// std::ios::sync_with_stdio(false);\n// priority_queue<PA> Q;\n// lld dp[1<<18];\nvector<lld> V[lim];\n// int X[lim],Y[lim],C[lim];\n// string S[lim];\nlld A[lim],B[lim],dp[lim];\n// map<lld,lld> M;\n\nvoid solve(lld x,lld par,lld d){\n    A[d]++;\n    for(lld p:V[x]){\n        if(p!=par){\n            solve(p,x,d+1);\n        }\n    }\n}\n\nint main(){\n    lld T,i,n,m,p,j,l,e,r,b,c,k,q,a,d,w,x,y,v,z,t,curr,prev,sum,ans,pos,val,countA,indicator;\n    sc(n);\n    rep(i,1,n-1){\n        sc2(a,b);\n        V[a].pb(b);\n        V[b].pb(a);\n    }\n    solve(1,-1,0);\n    val = 0;\n    rep(i,1,n) if(A[i]&1) val++;\n    // rep(i,0,n) Error2(i,A[i]);\n    if(val==0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ninline int rd(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn f?x:-x;\n}\nstruct Edge{\n\tint nxt,to;\n}e[400050];\nint fir[200050],n,cnt;\ninline void add(int from,int to){\n\te[++cnt].nxt=fir[from];\n\tfir[from]=cnt;e[cnt].to=to;\n}\ninline int dfs(int x,int fa){\n\tint len=0;\n\tfor(int i=fir[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif(y==fa) continue;\n\t\tlen=len^(dfs(y,x)+1);\n\t}\n\treturn len;\n}\nint main(){\n\tn=rd();int u,v;\n\tfor(int i=1;i<n;i++){\n\t\tu=rd(),v=rd();\n\t\tadd(u,v);add(v,u);\n\t}\n\tif(dfs(1,0)) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\n#define MAXN 100111\n\nstruct Node\n{\n\tint id;\n\tint a;\n\tvector<Node*> child;\n};\nNode nodes[MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> e[MAXN];\n\tfor(int i=0; i<n-1; ++i)\n\t{\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\t--u,--v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\t\n\tvector<Node*> o;\n\tqueue<int> q;\n\tint used[MAXN] = {0};\n\tq.push(0);\n\tused[0] = 1;\n\t\n\tfor(int i=0; i<n; ++i)\n\t\tnodes[i].id = i+1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tint u = q.front();\n\t\tq.pop();\n\t\to.push_back(&nodes[u]);\n\t\t\n\t\tfor(int i=0; i<e[u].size(); ++i) if(!used[e[u][i]])\n\t\t{\n\t\t\tint v = e[u][i];\n\t\t\tused[v] = 1;\n\t\t\tnodes[u].child.push_back(&nodes[v]);\n\t\t\tq.push(v);\n\t\t}\n\t}\n\t\n\tfor(int i=o.size(); i--;)\n\t{\n\t\tNode &u = *o[i];\n\t\tu.a = 0;\n\t\t\n\t\tfor(int j=0; j<u.child.size(); ++j)\n\t\t{\n\t\t\tu.a ^= (u.child[j]->a+1);\n\t\t}\n\t}\n\t\n\tif(!nodes[0].a)\n\t\tcout << \"Bob\\n\";\n\telse\n\t\tcout << \"Alice\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2&&false) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int odd = 0;\n        FORE(e, ch) odd += e % 2;\n        cout << ((((odd & 1) ^ (oneCnt & 1)) & ((N - 1) & 1)) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint N;\nint adj[100005], gto[200005], gnxt[200005], e;\nint pre[100005], size[100005];\nint nim[100005];\n\nvoid add_edge(int u, int v) {\n    gto[e] = v; gnxt[e] = adj[u]; adj[u] = e++;\n}\n\nvoid dfs(int s) {\n    size[s] = 1;\n    if (!~adj[s]) {\n        return;\n    }\n    for (int e = adj[s]; ~e; e = gnxt[e]) {\n        if (gto[e] != pre[s]) {\n            pre[gto[e]] = s;\n            dfs(gto[e]);\n            size[s] += size[gto[e]];\n        }\n    }\n}\n\nint dfs2(int s) {\n    if (!~adj[s]) {\n        return nim[s] = 0;\n    }\n    for (int e = adj[s]; ~e; e = gnxt[e])\n        if (gto[e] != pre[s]) {\n            nim[s] ^= dfs2(gto[e]) + 1;\n        }\n    return nim[s];\n}\n\nint main() {\n    memset(adj, -1, sizeof adj);\n    scanf(\"%d\", &N);\n    for (int i = 1; i != N; ++i) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        add_edge(x, y); add_edge(y, x);\n    }\n    dfs(1); dfs2(1);\n    puts(nim[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 1000000007 \n#define N 150005\n#define M 1000003\n#define LOG 20\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nvector<int> g;\nvector<vector<int>> v;\n\nvoid dfs(int node,int ata) {\n\n\tfor(int i:v[node]) {\n\n\t\tif(i==ata) continue ;\n\n\t\tdfs(i,node);\n\n\t\tg[node]^=(g[i]+1);\n\n\t}\n\n}\n\nint main() {\n\n\tint n;\n\n\tscanf(\"%d\",&n);\n\n\tg=vector<int>(n+1,0);\n\tv=vector<vector<int>>(n+1);\n\n\tfor(int i=1;i<n;i++) {\n\n\t\tint x,y;\n\n\t\tscanf(\"%d %d\",&x,&y);\n\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\n\t}\n\n\tdfs(1,0);\n\n\tprintf(g[1]?\"Alice\":\"Bob\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n#define rep2(i, m, n) for(int i=int(m); i<int(n); i++)\n#define rep(i, n) rep2(i, 0, n)\n#define all(a) a.begin(), a.end()\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\nconst int INF = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS = 1e-10;\nconst int MOD = int(1e9)+7;\ntemplate<typename T> inline bool chmin(T& a, T b) {if(a>b) {a=b; return true;} return false;}\ntemplate<typename T> inline bool chmax(T& a, T b) {if(a<b) {a=b; return true;} return false;}\n\nusing Graph = vector<vector<int>>;\nGraph G;\nint dfs(int u, int p=-1) {\n  int g = 0;\n  for (auto v : G[u]) {\n    if (v == p) continue;\n    g ^= dfs(v, u);\n  }\n  return g + 1;\n}\n\nint main() {\n  ll N; cin >> N;\n\n  G = Graph(N);\n  for (int i = 0; i < N-1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  cout << ((dfs(0) != 1) ? \"Alice\" : \"Bob\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\n    public:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> parent;\n\n    //-1で初期化。最初はすべてバラバラ\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n    }\n\n    //Aがどのグループに属しているか(Aの根)を調べる\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A){\n        return -parent[root(A)];\n    }\n\n    //AとBをくっつける\n    bool unite(int A, int B) {\n    //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        //既にくっついているからくっつけない\n        if(A == B) return false; \n\n        //大きいほう(A)に小さいほう(B)をくっつける\n        //大小が逆ならひっくり返す\n        if(size(A) < size(B)) swap(A,B);\n\n        //Aのサイズを更新する\n        parent[A] += parent[B];\n        //Bの親をAに変更する\n        parent[B] = A;\n\n        return true;\n    }\n\n    //AとBが同じグループならtrueを返す\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n\nvector<vector<int>> v(100010);\nbool used[100010];\n\nint dfs(int p){\n    used[p] = true;\n    int x = 0;\n    for(auto i:v[p]){\n        if(!used[i]){\n            x ^= dfs(i) + 1;\n        }\n    }\n    return x;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n \n    int n;\n    cin>>n;\n    UnionFind uni(n);\n    for(int i=1;i<n;i++){\n        int a,b; cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        uni.unite(a,b);\n    }\n    ll ans = dfs(0);\n    cerr << ans << endl;\n    for(int i=1;i<n;i++){\n        if(!uni.same(0,i) && i==uni.root(i)){\n            ans ^= 1;\n        }\n    }\n    cerr << ans << endl;\n    if(ans){\n        cout << \"Alice\" << endl;\n    }\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define along long(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(long long i=(a);i<(b);++i)\n#define per(i,a,b) for(long long i=b-1long long;i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll d[100100];\nvector<vector<ll> > vv;\n\nvoid dfs(ll a, ll p, ll h){\n\td[h]++;\n\tif(vv[a].sz==1&&p!=-1)return;\n\trep(i,0,vv[a].sz){\n\t\tif(vv[a][i]==p)continue;\n\t\tdfs(vv[a][i],a,h+1);\n\t}\n}\n\nint main() {\n\tll n;\n\tcin>>n;\n\tclr(d,0);\n\tvector<vector<ll> > vv_(n,vector<ll>());\n\tvv = vv_;\n\trep(i,0,n-1){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tvv[a].pb(b);\n\t\tvv[b].pb(a);\n\t}\n\tdfs(0,-1,0);\n\tll c = 0;\n\trep(i,1,100050){\n\t\tif(d[i]%2==1)c++;\n\t}\n\tif(c%2==0){\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nint beg[N],to[N],nex[N];\nint sg[N];\nint len,n;\ninline void Add(int a,int b){\n\tnex[++len]=beg[a],beg[a]=len,to[len]=b;\n\tnex[++len]=beg[b],beg[b]=len,to[len]=a;\n}\nvoid dfs(int p,int fa){\n\tint A=0,B=0;\n\tfor(int i=beg[p];i;i=nex[i]){\n\t\tif(to[i]!=fa){\n\t\t\tdfs(to[i],p);\n\t\t\tif(sg[to[i]]) A++;\n\t\t\telse B++;\n\t\t}\n\t}\n\tif(A+B==0) sg[p]=0;\n\telse if(A+B==1) sg[p]=1;\n\telse if(A&1) sg[p]=1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tAdd(a,b);\n\t}\n\tdfs(1,-1);\n\tprintf(\"%s\\n\",sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 520005;\nconst int K = 25;\nvector < int > g[N];\nint dp[N];\nvoid dfs(int v, int p = -1){\n    int c = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        c ^= (dp[u] + 1);\n    }\n    dp[v] = c;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    if (dp[1] == 0) cout << \"Bob\"; else cout << \"Alice\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint DP[100005];\nvector <int> G[100005], V;\nint N;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n}\n\nvoid DFS(int node, int father)\n{\n    int cnt = 0, val = 0, S = 0;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father)\n            continue;\n        DFS(neighb, node);\n        //Sz[node] += Sz[neighb];\n        ++cnt;\n        S = (S ^ (DP[neighb] + 1));\n    }\n    //if(cnt != 1)\n        DP[node] = S;\n}\nint main()\n{\n    Read();\n    DFS(1, 0);\n    if(DP[1] == 0)\n    {\n        cout << \"Bob\\n\";\n    }\n    else\n        cout << \"Alice\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = 0;//(sz(v[u]) - (u ? 1: 0)) % 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= (1 - d[h]);\n    }\n    d[u] |= (sz(v[u]) - (u ? 1: 0)) % 2;\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint f[maxn];\nint n;\n\nvoid dfs(int v, int p)\n{\n    if (g[v].size() == 1)\n    {\n        f[v] = 1;\n        return;\n    }\n    for (int i = 0; i < g[v].size(); i++)\n    {\n        int u = g[v][i];\n        if (u == p)\n        {\n            continue;\n        }\n        dfs(u, v);\n        f[v] ^= f[u];\n    }\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1, 0);\n    if (f[1])\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        cout << \"Bob\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n///////////// マクロ, エイリアス /////////////////\n#pragma region macros_and_aliases\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing mii = map<int, int>;\nusing pqll = priority_queue<long long>;\nusing pqllg = priority_queue<long long, vector<long long>, greater<long long>>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n#pragma endregion\n\n///////////// 定数など /////////////////\n#pragma region constants\n\nlong long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\nlong long const dekai = 1e15;\nconst long double pi = acos(-1);\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nint ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\n#pragma endregion\n\n// // 多倍長テンプレ\n// /* ---------------------- ここから ---------------------- */\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// // 任意長整数型\n// using Bint = mp::cpp_int;\n// // 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n// using Real = mp::number<mp::cpp_dec_float<1024>>;\n// /* ---------------------- ここまで ---------------------- */\n\n/////////////////// 基本処理系 ////////////////////\n#pragma region basic_procedure\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#pragma endregion\n\n//////////////// 数学処理系 ///////////////////////\n#pragma region math\n\ntemplate <class T>\nT divup(T a, T b) {\n\t//端数繰りあがり割り算\n\tassert(b != 0);\n\tT x = abs(a);\n\tT y = abs(b);\n\tT z = (x + y - 1) / y;\n\tif((a < 0 && b > 0) || (a > 0 && b < 0))\n\t\treturn -z;\n\telse if(a == 0)\n\t\treturn 0;\n\telse\n\t\treturn z;\n}\n\nlong long POW(long long a, long long n) {\n\t// 整数のとき限定の普通のPOW関数\n\t//標準機能のpow(a,n)は整数だとバグるのでこちらを使う\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ntemplate <class T>\nbool prime(T N) {\n\t//素数判定\n\t//素数ならばtrue、素数以外の整数にはfalse\n\t//負数は全てfalse\n\t//検証済み\n\tif(N <= 1) return false;\n\tT p = sqrt(N);\n\tfor(long long i = 2; i <= p; i++)\n\t\tif(N % i == 0) return false;\n\treturn true;\n}\n\nvector<long long> eratos(long long n) {\n\t//エラトステネスのふるい\n\t//素数なら1,素数でないなら0\n\tassert(n >= 0);\n\tvll v(n + 1, 1);\n\tif(n >= 0) v[0] = 0;\n\tif(n >= 1) v[1] = 0;\n\tRep(i, 2, n + 1) {\n\t\tif(v[i]) {\n\t\t\tfor(ll k = i * 2; k < n + 1; k += i) {\n\t\t\t\tv[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nvector<long long> primevec(long long n) {  // n以下の素数のみを入れたvector\n\tvll v = eratos(n);\n\tvll ret;\n\tRep(i, 2, n + 1) if(v[i]) ret.push_back(i);\n\treturn ret;\n}\n\nset<long long> primeset(long long n) {\t// n以下の素数を全て詰めたset\n\tvll v = eratos(n);\n\tsll s;\n\tRep(i, 2, n + 1) if(v[i]) s.insert(i);\n\treturn s;\n}\n\nvector<long long> yakusuu(long long n) {  // nの約数を列挙\n\tvector<long long> ret;\n\tlong long sq = sqrt(n);\n\tfor(long long i = 1; i <= sq; ++i) {\n\t\tif(n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif(i * i != n) {\n\t\t\t\tret.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\n\nmap<long long, long long> soinsuu(long long n) {  // map<素因数,個数>\n\tmap<long long, long long> m;\n\tlong long p = sqrt(n);\n\twhile(n % 2 == 0) {\n\t\tn /= 2;\n\t\tif(m.count(2)) {\n\t\t\tm[2]++;\n\t\t} else {\n\t\t\tm[2] = 1;\n\t\t}\n\t}\n\tfor(long long i = 3; i * i <= n; i += 2) {\n\t\twhile(n % i == 0) {\n\t\t\tn /= i;\n\t\t\tif(m.count(i)) {\n\t\t\t\tm[i]++;\n\t\t\t} else {\n\t\t\t\tm[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(n != 1) m[n] = 1;\n\treturn m;\n}\n\nvector<long long> keta(ll x) {\n\t// 10進法でn桁の整数xに対して、大きい方の位から、その位の1桁の数字を\n\t//収納した長さnのベクトルを返す\n\t// 0に対しては{}を返す\n\tvll w;\n\twhile(x > 0) {\n\t\tw.push_back(x % 10);\n\t\tx /= 10;\n\t}\n\treverse(all(w));\n\treturn w;\n}\n\nlong long ketasum(ll x) {  //各桁の和\n\tll ret = 0;\n\twhile(x > 0) {\n\t\tret += x % 10;\n\t\tx /= 10;\n\t}\n\treturn ret;\n}\n\nstring bits(long long n, long long k) {\t // nをk桁のbitで表示したstringを返す\n\tstring s = \"\";\n\trep(i, k) {\n\t\tchar c = '0' + (n % 2);\n\t\ts += c;\n\t\tn /= 2;\n\t}\n\treverse(all(s));\n\treturn s;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\t // a^n mod\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlong long modinv(long long a, long long mod) {\t// a^{-1} mod\n\t// modとaが互いに素のときのみ有効(数学的に逆元が一意に定まるのがそのときのみ)\n\treturn modpow(a, mod - 2, mod);\n}\n\nvvll comb(100, vll(100, -1));\nlong long com(long long n, long long k) {  //普通の二項計数(overflowに注意)\n\tassert(n < 100 && k < 100);\n\tif(n < k || k < 0 || n < 0) return 0;\n\tif(comb[n][k] != -1) return comb[n][k];\n\tll res;\n\tif(n - k < k)\n\t\tres = com(n, n - k);\n\telse if(k == 0)\n\t\tres = 1;\n\telse\n\t\tres = com(n - 1, k - 1) + com(n - 1, k);\n\tcomb[n][k] = res;\n\treturn res;\n}\n\n// nCk modを求める\nconst ll MAX = 510000;\n// この値は求める二項計数の値に応じて変える\n// MAX=3*10^7のとき1900msほど、ほぼ比例\n// MAX=5*10^6程度ならそれほど気にしなくてよい(300ms程)\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid cominit() {\n\t// テーブルを作る前処理\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nlong long commod(ll n, ll k) {\t// 二項係数計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nlong long pmod(ll n, ll k) {  //順列計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[n - k] % mod;\n}\nlong long hmod(ll n, ll k) {  // nHk計算\n\t// n個の区別しないoを区別するk個の箱に入れる方法の総数\n\t//(n+k-1)C(k-1)と等しい\n\treturn commod(n + k - 1, n);\n}\n\nlong long next_combination(long long sub) {\t //次の組み合わせをbitで返す\n\tlong long x = sub & -sub, y = sub + x;\n\treturn (((sub & ~y) / x) >> 1) | y;\n}\n\n#pragma endregion\n\n//////////////// vector処理系 ///////////////////////\n#pragma region vector\nvector<long long> vin(long long n) {  //整数n個の入力を受け取ってベクトルに突っ込んで返す\n\tvector<long long> v(n);\n\tfor(long long i = 0; i < n; i++) {\n\t\tcin >> v[i];\n\t}\n\treturn v;\n}\n\n//ベクトルの出力(検証済)\n// vectorの中身を出力する 答えの出力に利用可能\ntemplate <class T>\nvoid vout(vector<T> &v) {\n\tif(v.size() > 0) {\n\t\tfor(auto it = v.begin(); it < v.end(); it++) {\n\t\t\tcout << *it;\n\t\t\tif(it != v.end() - 1) cout << \" \";\n\t\t}\n\t}\n\tcout << endl;\n}\n\n//引数ベクトルに同一要素が複数あるとき、先頭を残し他は削除したベクトルを返す\n//ベクトル長も変化する\n// O(nlogn)くらい\ntemplate <class T>\nvector<T> singlized(vector<T> &v) {\n\tset<T> s;\n\tvector<T> ret;\n\tfor(auto seg : v) {\n\t\tif(!s.count(seg)) {\n\t\t\tret.push_back(seg);\n\t\t\ts.insert(seg);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//配列圧縮(検証済)\n//{1,36,1,3,8,-2,-92}を\n//{2, 5,2,3,4, 1,  0}にする\ntemplate <class T>\nvector<long long> press(vector<T> &v) {\n\tlong long n = v.size();\n\tvector<long long> w(n);\n\tmap<T, long long> m;\n\tfor(T &p : v) m[p] = 0;\n\tlong long i = 0;\n\tfor(auto &p : m) {\n\t\tp.second = i;\n\t\ti++;\n\t}\n\tfor(long long i = 0; i < n; i++) w.at(i) = m[v.at(i)];\n\treturn w;\n}\n\n//配列圧縮(同順位なし)\n//{1,36,1,3,8,-2,-92}を\n//{2, 6,3,4,5, 1,  0}にする\ntemplate <class T>\nvector<long long> ranking(vector<T> &v) {\n\tvector<pair<T, long long>> r;\n\tlong long n = v.size();\n\trep(i, n) r.push_back({v[i], i});\n\tsort(all(r));\n\tvll res(n);\n\trep(i, n) { res[r[i].second] = i; }\n\treturn res;\n}\n\n//着順配列\n// (sortedplace(v)).[i] = i番目に小さい要素が入っている箇所\ntemplate <class T>\nvector<long long> sortedplace(vector<T> &v) {\n\tauto w = ranking(v);\n\tll n = v.size();\n\tvll res(n);\n\trep(i, n) res[w[i]] = i;\n\treturn res;\n}\n\n// vectorの中身を数える map<要素,個数>を返す\ntemplate <class T>\nmap<T, long long> countv(vector<T> v) {\n\tmap<T, long long> m;\n\tfor(auto &g : v) {\n\t\tif(m.count(g))\n\t\t\tm[g]++;\n\t\telse\n\t\t\tm[g] = 1;\n\t}\n\treturn m;\n}\n\ntemplate <class T>\t// WarshallFloyd\nvoid warshall(vector<vector<T>> &v) {\n\tll n = v.size();\n\trep(i, n) rep(j, n) rep(k, n) v[j][k] = min(v[j][k], v[j][i] + v[i][k]);\n\treturn;\n}\n\n#pragma endregion\n\n//////////////// 累積和処理系 ///////////////////////\n#pragma region ruisekiwa\n\n// 1次元累積和\ntemplate <class T>\nvector<T> barsuminit(vector<T> &v) {\n\tll h = v.size();\n\tV<T> ret(h + 1);\n\tret[0] = 0;\n\trep(i, h) ret[i + 1] = v[i] + ret[i];\n\treturn ret;\n}\ntemplate <class T>\nT barsum(vector<T> &v, ll x0, ll x1) {\n\tif(x1 <= x0) return 0;\n\treturn v[x1] - v[x0];\n}\n// 2次元累積和\ntemplate <class T>\nvector<vector<T>> sheetsuminit(vector<vector<T>> &v) {\n\tll h = v.size();\n\tassert(h != 0);\n\tll w = v.at(0).size();\n\tVV<T> ret(h + 1, V<T>(w + 1));\n\trep(i, h + 1) ret[i][0] = 0;\n\trep(i, w + 1) ret[0][i] = 0;\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] = v[i][j];\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] += ret[i + 1][j];\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] += ret[i][j + 1];\n\treturn ret;\n}\n//[x0,y0],(x1,y1)で囲まれた領域内の和\n//端点は(x,y)のみ含む.面積は(x1-x0)*(y1-y0);\ntemplate <class T>\nT sheetsum(vector<vector<T>> &v, ll x0, ll y0, ll x1, ll y1) {\n\tif(x0 >= x1 || y0 >= y1) return 0;\n\treturn v[x0][y0] + v[x1][y1] - v[x0][y1] - v[x1][y0];\n}\n// 3次元累積和\ntemplate <class T>\nvector<vector<vector<T>>> cubiodsuminit(vector<vector<vector<T>>> &v) {\n\tll h = v.size();\n\tassert(h != 0);\n\tll w = v[0].size();\n\tassert(w != 0);\n\tll z = v[0][0].size();\n\tVVV<T> ret(h + 1, VV<T>(w + 1, V<T>(z + 1)));\n\trep(i, h + 1) rep(j, w + 1) rep(k, z + 1) { ret[i][j][k] = (i == 0 || j == 0 || k == 0 ? 0 : v[i - 1][j - 1][k - 1]); }\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i + 1][j + 1][k];\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i + 1][j][k + 1];\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i][j + 1][k + 1];\n\treturn ret;\n}\n//[x0,y0],(x1,y1)で囲まれた領域内の和\n//端点は(x,y)のみ含む.面積は(x1-x0)*(y1-y0);\ntemplate <class T>\nT cubiodsum(vector<vector<vector<T>>> &v, ll x0, ll y0, ll z0, ll x1, ll y1, ll z1) {\n\tif(x0 >= x1 || y0 >= y1 || z0 >= z1) return 0;\n\treturn v[x1][y1][z1] - v[x1][y1][z0] - v[x1][y0][z1] - v[x0][y1][z1] + v[x1][y0][z0] + v[x0][y1][z0] + v[x0][y0][z1] - v[x0][y0][z0];\n}\n\n#pragma endregion\n\n////////////// 構造体 ///////////////////////////\n#pragma region objects\n\nstruct mint {\n\t// auto mod int\n\t// https://youtu.be/L8grWxBlIZ4?t=9858\n\t// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n\t// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\n\tll x;  // typedef long long ll;\n\tmint(ll x = 0) : x((x % mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint &operator+=(const mint a) {\n\t\tif((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint a) {\n\t\tif((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint a) {\n\t\t(x *= a.x) %= mod;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif(!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif(t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint &operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream &operator>>(istream &is, const mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\nstruct UF {\t\t\t\t\t\t// Union_Find木(sizeあり)\n\tvector<long long> par, sz;\t// par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\t// sizeはiを根とする木のサイズ\n\tUF(long long N) : par(N), sz(N) {  //最初は全てが根であるとして初期化\n\t\tfor(long long i = 0; i < N; i++) {\n\t\t\tpar[i] = i;\n\t\t\tsz[i] = 1;\n\t\t}\n\t}\n\n\tlong long root(long long x) {  // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(long long x, long long y) {\t// xとyの木を併合\n\t\tlong long rx = root(x);\t\t\t\t// xの根をrx\n\t\tlong long ry = root(y);\t\t\t\t// yの根をry\n\t\tif(rx == ry) return;\t\t\t\t// xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry;\t\t\t\t\t\t// xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t\tsz[ry] += sz[rx];\n\t\tsz[rx] = 0;\t //サイズの処理 根じゃなくなったらサイズは0になる\n\t}\n\n\tbool same(long long x, long long y) {  // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tlong long rx = root(x);\n\t\tlong long ry = root(y);\n\t\treturn rx == ry;\n\t}\n\tlong long size(long long x) { return sz[root(x)]; }\n};\n\ntemplate <class T = ll>\nstruct BIT {\n\t//もとの配列a[i]はBIT内部ではvec[i+1]に対応\n\tvector<T> vec;\n\tll n;\n\tBIT(long long sz) : vec(sz + 1, 0), n(sz) {}\n\t//元の値に足す\n\tvoid add(long long place, T val, bool index = 0) {\n\t\tif(!index) place++;\n\t\tfor(long long x = place; x <= n; x += x & -x) vec[x] += val;\n\t\treturn;\n\t}\n\t//端からの合計値計算\n\tT sum0(long long a, bool index = 0) {\n\t\t// if(index == 0) a++;\n\t\tif(index) a--;\n\t\tT ret = 0;\n\t\tfor(int x = a; x > 0; x -= x & -x) ret += vec[x];\n\t\treturn ret;\n\t}\n\t//クエリ\n\tT sum(long long a, long long b) { return sum0(b) - sum0(a); }\n\t//更新 クエリと併用で可能にした\n\tvoid update(long long place, T val, bool index = 0) {\n\t\tT old = sum(place, place + 1);\n\t\tadd(place, val - old);\n\t\treturn;\n\t}\n};\n\ntemplate <class T = ll>\nstruct edge {\n\tT len;\n\tll to;\n};\n\ntemplate <class T = ll>\nstruct graph {\t// 0-indexed\n\tvector<vector<edge<T>>> edges;\n\tbool directed, weight;\n\tlong long ver;\n\n\t// constructor\n\tgraph(long long vertex, bool direction = 0, bool weigh = 0) : edges(vertex) {\n\t\tver = vertex;\n\t\tdirected = direction;\n\t\tweight = weigh;\n\t\tedges.resize(vertex);\n\t}\n\n\t//辺の追加 (0-indexed)\n\tvoid update(long long from, long long to, T len = 1, bool direction = 1) {\n\t\tedge<T> e;\n\t\te.to = to;\n\t\te.len = len;\n\t\tedges[from].push_back(e);\n\t\tif(!direction) {\n\t\t\te.to = from;\n\t\t\tedges[to].push_back(e);\n\t\t}\n\t}\n\n\t//入力受取 (1-indexed)\n\tvoid input(long long edge_num, long long index = 1) {\n\t\trep(i, edge_num) {\n\t\t\tll a;\n\t\t\tll b;\n\t\t\tcin >> a >> b;\n\t\t\ta -= index;\n\t\t\tb -= index;\n\t\t\tT c;\n\t\t\tif(weight)\n\t\t\t\tcin >> c;\n\t\t\telse\n\t\t\t\tc = 1;\n\t\t\tupdate(a, b, c, directed);\n\t\t}\n\t}\n\n\t//長さが負のpathがないときの単一始点最短経路<vll> O((ver)log(ver)+(edge))\n\tvector<T> dijkstra(long long start) {\n\t\tvector<T> ret(ver, (T)dekai);\n\t\tpqup<pair<T, long long>> p;\t //{dist,place}\n\t\tp.push({0, start});\n\t\tret[start] = 0;\n\n\t\twhile(!p.empty()) {\n\t\t\tT dist = p.top().first;\n\t\t\tll place = p.top().second;\n\t\t\tp.pop();\n\t\t\tif(ret[place] < dist) continue;\n\t\t\tfor(auto &next : edges[place]) {\n\t\t\t\tll nextplace = next.to;\n\t\t\t\tT dis = next.len;\n\t\t\t\tif(chmin(ret[nextplace], dist + dis)) {\n\t\t\t\t\tp.push({ret[nextplace], nextplace});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//単一始点最短経路 O((ver)*(edge))\n\t//ある頂点までのコストが無限に小さくなり得るとき→ ret[i] = -dekai;\n\tvector<T> BellmanFord(long long start) {\n\t\tvector<T> ret(ver, dekai);\n\t\tret[start] = 0;\n\t\trep(loop, ver - 1) {\n\t\t\trep(v, ver) {\n\t\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\t\tchmin(ret[e.to], ret[v] + e.len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//無限降下点の検索\n\t\tqueue<ll> q;\n\t\tvb chk(ver, 0);\n\t\trep(v, ver) {\n\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\tif(chmin(ret[e.to], ret[v] + e.len)) {\n\t\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, ver) if(chk[i]) ret[i] = -dekai;\n\n\t\treturn ret;\n\t}\n\n\t//閉路に含まれない頂点列挙\n\t//要素数がver未満なら閉路が存在、そうでなければ閉路は存在しない\n\tvector<long long> topo_sort() {\n\t\tassert(directed);\n\t\tvector<long long> num_input(ver);\n\t\t// 入次数\n\t\tfor(long long i = 0; i < ver; i++) {\n\t\t\tfor(auto e : edges[i]) {\n\t\t\t\tnum_input[e.to]++;\n\t\t\t}\n\t\t}\n\t\t// 入次数が0のノードをqueueで管理する\n\t\tqueue<long long> que;\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(num_input[i] == 0) {\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t\tvector<long long> ans;\n\t\twhile(!que.empty()) {\n\t\t\tauto node = que.front();\n\t\t\tque.pop();\n\t\t\tans.push_back(node);\n\t\t\t// 頂点の削除\n\t\t\tfor(auto e : edges[node]) {\n\t\t\t\tnum_input[e.to]--;\n\t\t\t\t// 行き先の入次数が0になったらqueueに追加\n\t\t\t\tif(num_input[e.to] == 0) {\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//無向木構造を根から葉に伸びる有向木構造に書き換える\n\tgraph<T> RootToLeaf(ll root) {\t// 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvb chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(now, e.to, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//無向木構造を葉から根に伸びる有向木構造に書き換える\n\tgraph<T> LeafToRoot(ll root) {\t// 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvb chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(e.to, now, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\tret.update(root, root, 0);\n\t\treturn ret;\n\t}\n\n\t// LeafToRootのvector版.par[i]=iの親の頂点\n\tvector<long long> par(ll root) {  // 0-indexed\n\t\tvll ret(ver, -1);\n\t\tret[root] = root;  // rootの親はroot\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != -1) continue;\n\t\t\t\tret[e.to] = now;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\tvector<edge<T>> ParentAndDistance(ll root) {  // 0-indexed\n\t\tV<edge<T>> ret(ver);\n\t\trep(i, ver) ret[i].to = -1;\n\t\tret[root].to = root;  // rootの親はroot\n\t\tret[root].len = 0;\t  // rootの親との距離は0\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to].to != -1) continue;\n\t\t\t\tret[e.to].to = now;\n\t\t\t\tret[e.to].len = e.len;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\tpair<pair<long long, long long>, T> DiameterOfTree() {\t//{{端点、端点},直径の大きさ}\n\t\tll v1, v2;\t\t\t\t\t\t\t\t\t\t\t// 0ともっとも遠い点、v1と最も遠い点\n\t\tV<T> dis(ver, -1);\n\t\tdis[0] = 0;\n\t\tqueue<ll> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(dis[e.to] != -1) continue;\n\t\t\t\tdis[e.to] = dis[now] + e.len;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t\tif(q.empty()) v1 = now;\n\t\t}\n\t\trep(i, ver) dis[i] = -1;\n\t\tdis[v1] = 0;\n\t\tq.push(v1);\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(dis[e.to] != -1) continue;\n\t\t\t\tdis[e.to] = dis[now] + e.len;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t\tif(q.empty()) v2 = now;\n\t\t}\n\t\tpair<pll, T> ans = {{v1, v2}, dis[v2]};\n\t\treturn ans;\n\t}\n\n\t//隣接sheet.主にwarshall用\n\tVV<T> GraphArray(void) {\n\t\tVV<T> ret(ver, V<ll>(ver, dekai));\n\t\trep(from, ver) {\n\t\t\tfor(auto &e : edges[from]) {\n\t\t\t\tret[from][e.to] = e.len;\n\t\t\t}\n\t\t\tret[from][from] = 0;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n#pragma region Segment_Trees\n\ntemplate <class T = ll>\nstruct STmax {\t//最大値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTmax(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\t\trep(i, size) { seg.push_back(-99999999977); }\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\t\t\tseg[v] = max(seg[v * 2 + 1], seg[v * 2 + 2]);\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での最大値を求める\n\t\tif(r <= a || b <= l) return -99999999977;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n\tT largest(ll a, ll b) {\n\t\tif(a >= b) return -99999999977;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct STmin {\t//最小値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTmin(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\t\trep(i, size) { seg.push_back(99999999977); }\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\t\t\tseg[v] = min(seg[v * 2 + 1], seg[v * 2 + 2]);\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での最大値を求める\n\t\tif(r <= a || b <= l) return 99999999977;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\tT smallest(ll a, ll b) {\n\t\tif(a >= b) return 99999999977;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct STsum {\t//区間の合計値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTsum(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\n\t\trep(i, size) { seg.push_back(0); }\n\t\t//改造時はここをまず変える\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\n\t\t\tseg[v] = seg[v * 2 + 1] + seg[v * 2 + 2];\n\t\t\t//改造時はここを変える\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での合計値を求める\n\t\tif(r <= a || b <= l) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn vl + vr;\t //改造時はここを変える\n\t}\n\tT sum(ll a, ll b) {\n\t\tif(a >= b) return 0;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct ST {\t //セグ木まとめ\n\tSTmax<T> stmax;\n\tSTmin<T> stmin;\n\tSTsum<T> stsum;\n\tST(long long n) : stmax(n), stmin(n), stsum(n) {}\n\tvoid update(ll place, T val) {\n\t\tstmax.update(place, val);\n\t\tstmin.update(place, val);\n\t\tstsum.update(place, val);\n\t}\n\tT largest(ll a, ll b) { return stmax.largest(a, b); }\n\tT smallest(ll a, ll b) { return stmin.smallest(a, b); }\n\tT sum(ll a, ll b) { return stsum.sum(a, b); }\n};\n\n#pragma endregion\n#pragma endregion\n\n////////////// 工事中 ////////////////////////\n#pragma region making\n// //ダブリング\n// // reach : 2^reach 先まで検索\n// VV<edge> doublize(vll &v, ll reach) {  // vは子から親へのvector\n// \tll n = v.size();\n// \tVV<long long> ret(n, 20);\n// }\n#pragma endregion\n\n////////////////// メモ //////////////////////\n#pragma region memo\n#pragma region update_memo\n// ilb9からの変更点\n//:STmin,STmax,STsumの型を一般化 #pragmaによる畳み込み\n//:STをまとめたSTallの作成\n\n//更新予定\n//:幾何ライブラリ作成\n//ダブリング/木の最短経路検索\n//有理数class\n//範囲更新セグ木(LazyST?)\n//文字列Algorithm(Z,KMP)\n#pragma endregion\n#pragma region programming_memo\n// Ctrl+Shift+[：折りたたみ\n// Ctrl+Shift+]：展開\n// Ctrl+k Ctrl+l：折り畳み／展開のトグル\n// Ctrl+k Ctrl+[：再帰的に折りたたみ\n// Ctrl+k Ctrl+]：再帰的に展開\n// Ctrl+k Ctrl+0：すべて折りたたみ\n// Ctrl+k Ctrl+j：すべて展開\n// Ctrl+k Ctrl+1：レベル1で折りたたみ\n// Ctrl+k Ctrl+2：レベル2で折りたたみ\n// Ctrl+k Ctrl+3：レベル3で折りたたみ\n// Ctrl+k Ctrl+8：すべての領域（region）の折りたたみ\n// Ctrl+k Ctrl+9：すべての領域（region）の展開\n// Ctrl+k Ctrl+/：すべてのブロックコメントの折りたたみ\n\n// long long intとして表示 (印字対象データの最上位ビットが立っているので負数とみなされる)\n// printf(\"case3: %lld\\n\", a);\n\n// c char 文字\n// s char *文字列\n// d int, short 10進の整数\n// u unsigned int, unsigned short 10進の符号なし整数\n// o int, short, unsigned int,unsigned short 8進の整数\n// x int, short, unsigned int,unsigned short 16進の整数\n// f float 浮動小数点数\n// e float 浮動小数点数の指数表示\n// g float %eもしくは %fのどちらか最適な形式の浮動小数点数\n// ld long 10進の倍精度整数\n// lu unsinged long 10進の符号なし倍精度整数\n// lo long,unsinged long 8進の倍精度整数\n// lf double 倍精度浮動小数点数\n// a double 16進の倍精度浮動小数点数\n// lld long long\n#pragma endregion\n#pragma endregion\n\nint main() {\n\tll n;\n\tcin >> n;\n\tgraph<> tr(n);\n\ttr.input(n - 1);\n\tauto g = tr.RootToLeaf(0);\n\n\tfunction<ll(ll)> dfs = [&](ll now) {\n\t\tll res = 0;\n\t\tfor(auto &e : g.edges[now]) {\n\t\t\tres ^= dfs(e.to) + 1;\n\t\t}\n\t\tcout << now << \" \" << res << endl;\n\t\treturn res;\n\t};\n\n\tcout << (dfs(0) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 100010\nusing namespace std;\nstruct edge{int x, y, next;}a[N*2];\nint n, l, p[N], sg[N], x, y, ans;\ninline void add(int x, int y){a[++l].x=x; a[l].y=y; a[l].next=p[x]; p[x]=l;}\ninline void dfs(int x, int fa){\n\tsg[x]=0;\n\tfor(int i=p[x]; i; i=a[i].next)if(fa!=a[i].y){dfs(a[i].y, x); sg[x]^=sg[a[i].y];}\n\tsg[x]++;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tl=0; memset(p, 0, sizeof(p));\n\tfor(int i=1; i<=n-1; i++){scanf(\"%d%d\", &x, &y); add(x, y); add(y, x);}\n\tans=0;\n\tfor(int i=p[1]; i; i=a[i].next){dfs(a[i].y, 1); ans^=sg[a[i].y];}\n\tif(ans)printf(\"Alice\"); else printf(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, x, n) for (int i = int(x); i <= int(n); ++i)\n#define for1(i, n, x) for (int i = int(n); i >= int(x); --i)\n#define F first\n#define S second\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef long double ld;\ntypedef vector <ll> vi;\n\nconst int N = 2e6 + 1;\nconst ll INF = 1e18 + 9;\nconst int B = 1e9 + 7;\n\nint n;\nvi g[N];\nint a[N];\nint u[N], timer;\n\nvoid calc(int x, int pr, int cur) {\n    u[cur] = timer;\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        cur ^= a[to];\n    }\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        calc(to, x, cur ^ a[to]);\n    }\n}\n\nvoid dfs(int x, int pr = -1) {\n    int cur = 0;\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        dfs(to, x);\n        cur ^= a[to];\n    }\n    timer++;\n    for (auto to : g[x]) {\n        if (to == pr) continue;\n        calc(to, x, cur ^ a[to]);\n    }\n    //if (x == 3) exit(0);\n    forn(i, 0, N - 1)\n        if (u[i] != timer) {\n            a[x] = i;\n            return;\n        }\n}\n\nint main() {\n    #ifdef black\n    freopen(\"in\", \"r\", stdin);\n    #endif // black\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n;\n    forn(i, 1, n - 1) {\n        int f, t;\n        cin >> f >> t;\n        g[f].pb(t);\n        g[t].pb(f);\n    }\n    dfs(1);\n    cout << (a[1] ? \"Alice\\n\" : \"Bob\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n\nusing namespace std;\n\nint n;\nvector<int> g[N];\n\nint dfs(int u, int fa) {\n    int sg = 0;\n    for(auto v : g[u]) {\n        if(v == fa) continue;\n        sg ^= dfs(v, u) + 1;\n    }\n    return sg;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1, u, v; i < n; ++i) {\n        scanf(\"%d %d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    puts(dfs(1, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 101000;\n\nvector <int> adj[N];\nint val[N];\n\n// if fix 1, we have a green hackenbush\n\nint dfs(int u, int l) {\n\tval[u] = 0;\n\tfor (int x: adj[u]) {\n\t\tval[u]^=(dfs(x, u)+1);\n\t}\n\treturn val[u];\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadj[x].push_back(y);\n\t}\n\t\n\tdfs(1, -1);\n\tif(val[1] == 0) {\n\t\tprintf(\"Bob\\n\");\n\t} else {\n\t\tprintf(\"Alice\\n\");\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define has(c,i) ((c).find(i) != end(c))\n#define DBGDO(X) ({ if(1) cerr << \"DBGDO: \" << (#X) << \" = \" << (X) << endl; })\n\nvvl adj;\n\nll dfs(ll i, ll p) {\n\tll sum = 0;\n\tfor (ll j: adj[i]) if (j != p) {\n\t\tsum ^= 1 + dfs(j,i);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll n; cin >> n;\n\n\tadj.resize(n);\n\tFOR(i,1,n) {\n\t\tll a, b; cin >> a >> b;\n\t\ta--, b--;\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tll res = dfs(0,-1);\n\tcout << (res ? \"Alice\" : \"Bob\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int MAX = 200010;\nconst int INF = 2e9 + 10;\nconst int MOD = 1e9 + 7;\nconst lint LNF = 2e18 + 10;\n\nint n;\nvector<int> G[MAX];\n\nint dfs(int v, int p=0){\n\tint res = 0;\n\tfor(int x:G[v]) if(x!=p) res ^= 1+dfs(x,v);\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tcin>>n;\n\tfor(int i=1; i<n; i++){\n\t\tint u,v; cin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tcout<<(dfs(1) == 0 ? \"Bob\" : \"Alice\")<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dfs(const vector<vector<int>> &G, int v, int prev){\n  int cnt[2] = {};\n  for(auto v_ : G[v]){\n    if(v_ == prev) continue;\n    ++cnt[dfs(G,v_,v)];\n  }\n  if(cnt[0]%2 or cnt[1]%2) return 1;\n  return 0;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<vector<int>> G(N);\n  for(int i = 1; i < N; ++i){\n    int x, y;\n    cin >> x >> y;\n    --x,--y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if(dfs(G,0,-1)) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define LL long long\n#define PB push_back\n#define MP make_pair\n#define I insert\n \nconst LL N = 1e5+5, mod = 1000000007;\n \nusing namespace std;\n \nLL n, m, i, j, k, l, r, t, ans, a[N];\nvector < LL > v[N];\n\nvoid go ( LL u, LL par = 0 ){\n\tfor ( LL i = 0; i < v[u].size(); ++i ){\n\t\tif ( v[u][i] == par ) continue;\n\t\tgo ( v[u][i], u );\n\t\ta[u] ^= a[v[u][i]];\n\t}\n\tif ( u == 1 && v[u].size() == 1 || v[u].size() == 2 ) a[u]++;\n}\n\nint main(){\n\tcin >> n;\n\tfor ( i = 1; i < n; ++i ){\n\t\tcin >> l >> r;\n\t\tv[l].PB(r);\n\t\tv[r].PB(l);\n\t}\n\t\n\tgo(1);\n\t\n\tif ( a[1] ) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\t\n\treturn 0;\n}\n \n/**/\n//      IIIIIIIII      OOOOO             A          NN        N    EEEEEEEEEE\n//          I         O     O           A A         N N       N    E\n//          I        O        O         A   A        N  N      N    E\n//          I        O       O        A     A       N   N     N    E\n//          I        O       O       AAAAAAAAA      N    N    N    EEEEEEEE\n//          I        O       O      A         A     N     N   N    E\n//          I        O       O     A           A    N      N  N    E\n//          I         O     O     A             A   N       N N    E\n//      IIIIIIIII      OOOOO     A               A  N        NN    EEEEEEEEEE ___ KAPANADZE"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;\n\tinline char Gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void Gi(I&x){\n\t\tfor(c=Gc();c<'0'||c>'9';c=Gc());\n\t\tfor(x=0;c<='9'&&c>='0';c=Gc())x=x*10+(c&15);\n\t}\n};\nusing io::Gi;\nint N,T;\nstruct edge{\n\t   int adj,nex;\n\t   edge (int a_=0,int n_=0){\n\t\t\tadj=a_;\n\t\t\tnex=n_;\n\t   }\n}E[222222];\ninline void add(int u,int v){\n\t   E[++T]=edge(v,E[u].nex);\n\t   E[u].nex=T;\n\t   E[++T]=edge(u,E[v].nex);\n\t   E[v].nex=T;\n}\nint dfs(int x,int f){\n\tint s=0;\n\tfor (int i=E[x].nex;i;i=E[i].nex){\n\t\tif (E[i].adj!=f){\n\t\t   s^=(dfs(E[i].adj,x)+1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint u,v;\n\tGi(N);\n\tT=N;\n\tfor (int i=1;i!=N;i++){\n\t\tGi(u);\n\t\tGi(v);\n\t\tadd(u,v);\n\t}\n\tprintf(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tvvi E(N);\n\tfr(i,N-1){\n\t\tint x,y;cin>>x>>y;\n\t\tE[--x]<<--y;\n\t\tE[y]<<x;\n\t}\n\tauto f=[&](auto&f,int i,int p)->int{\n\t\tif(E[i].size()==1)return 1;\n\t\tif(E[i].size()==2){\n\t\t\tfor(int j:E[i])if(j!=p){\n\t\t\t\treturn 1+f(f,j,i);\n\t\t\t}\n\t\t}\n\t\tint x=0;\n\t\tfor(int j:E[i])if(j!=p){\n\t\t\tx^=f(f,j,i);\n\t\t}\n\t\treturn 1+x;\n\t};\n\tint x=0;\n\tfor(int i:E[0]){\n\t\tx^=f(f,i,0);\n\t}\n\tprint(x?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\t//vector<ULL>cash;\n\n\tint res = 0;\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tres ^= (seed(now, ch) + 1);\n\t}\n\treturn res;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 0)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const N = 1234567;\n\nvector<int> edges[N];\n\nint dfs(int v, int pv) {\n  int g = 0;\n  for (int to : edges[v]) {\n    if (to == pv) continue;\n    g ^= 1 + dfs(to, v);\n  }\n  return g;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n    edges[x].push_back(y);\n    edges[y].push_back(x);\n  }\n  if (dfs(0, -1) == 0) {\n    puts(\"Bob\");\n  } else {\n    puts(\"Alice\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n#define mat vector<vector<int>>\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\nconst db EPS = 1e-7;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nint N;\nvector<int> G[100010];\n\nint dfs(int v, int p){\n    int res = 0;\n    int son = 0;\n    for(auto u : G[v]){\n        if(u != p) res ^= dfs(u, v) + 1; \n    }\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    for(int i = 1; i < N; i++){\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n \n    }\n    cout << (dfs(1, 0) == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n//#define int long long \n\nconst int N = 1e5 + 7;\n\n\nvector <int> adj[N];\n\nint dfs(int u, int p) {\n\tint x = 0;\n\tfor(int v: adj[u]) if(v ^ p) {\n\t\tx ^= (1 + dfs(v, u));\n\t}\n\treturn x;\n}\n\nint32_t main() {\n\tios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tcout << (dfs(1, 0) ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n#define rep2(i, m, n) for(int i=int(m); i<int(n); i++)\n#define rep(i, n) rep2(i, 0, n)\n#define all(a) a.begin(), a.end()\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\nconst int INF = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS = 1e-10;\nconst int MOD = int(1e9)+7;\ntemplate<typename T> inline bool chmin(T& a, T b) {if(a>b) {a=b; return true;} return false;}\ntemplate<typename T> inline bool chmax(T& a, T b) {if(a<b) {a=b; return true;} return false;}\n\nusing Graph = vector<vector<int>>;\nGraph G;\nint dfs(int u, int p=-1) {\n  int cnt = 0;\n  int sum = 0;\n  for (auto v : G[u]) {\n    if (v == p) continue;\n    cnt++;\n    sum += dfs(v, u);\n  }\n  if (cnt % 2 == 1) return 1;\n  return sum%2;\n}\n\nint main() {\n  ll N; cin >> N;\n\n  G = Graph(N);\n  for (int i = 0; i < N-1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  cout << ((dfs(0) == 1) ? \"Alice\" : \"Bob\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nvector<int> G[100005];\n\nint dfs(int v, int prev)\n{\n\tint ret = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tret ^= dfs(G[v][i], v);\n\t}\n\treturn ret + 1;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint x, y;\n\tfor(int i = 1; i <= N-1; i++){\n\t\tcin >> x >> y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < G[1].size(); i++){\n\t\tans ^= dfs(G[1][i], 1);\n\t}\n\t\n\tif(ans) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pli = pair<ll, int>;\nusing pil = pair<int, ll>;\nusing uint = unsigned int;\nusing matrix = vector<vector<uint>>;\ntemplate <typename T>\nusing Graph = vector<vector<T>>;\nconst int MOD = 1e9 + 7;\nconst ld PI = acos(-1);\n\nvector<int> dp;\nint dfs(int v, int p, Graph<int> &G) {\n    for (auto nv : G[v]) {\n        if (nv == p)\n            continue;\n        dp[v] ^= dfs(nv, v, G) + 1;\n    }\n    return dp[v];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    Graph<int> G(N);\n    for (int i = 1; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    dp.resize(N);\n    dfs(0, -1, G);\n\n    cout << (dp[0] ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define long long long // for codeforces\n\nvector<int> tree[100005];\nint level[100005];\n\nint mx = 0;\n\nvoid dfs(int v){\n  mx = max(level[v], mx);\n  for(auto to : tree[v]) if(level[to]==-1){\n    level[to] = level[v]+1;\n    dfs(to);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    tree[a].pb(b);\n    tree[b].pb(a);\n  }\n  fill(level, level+n, -1);\n  level[0] = 0;\n\n  dfs(0);\n\n  vector<int> cnt(100005,0);\n  rep(i,n) cnt[level[i]]++;\n\n  repl(i,1,mx+1){\n    if(cnt[i]%2==1){\n      cout << \"Alice\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Bob\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=100000;\n\nint n,pre[maxn*2+10],now[maxn+10],son[maxn*2+10],tot,f[maxn+10];\n\nint ins(int a,int b)\n{\n  pre[++tot]=now[a];\n  now[a]=tot;\n  son[tot]=b;\n  return 0;\n}\n\nint search(int u,int fa)\n{\n  for(int i=now[u]; i; i=pre[i])\n    {\n      int v=son[i];\n      if(v==fa)\n        {\n          continue;\n        }\n      search(v,u);\n      f[u]^=(f[v]+1);\n    }\n  return 0;\n}\n\nint main()\n{\n  n=read();\n  for(int i=1; i<n; ++i)\n    {\n      int a=read(),b=read();\n      ins(a,b);\n      ins(b,a);\n    }\n  search(1,0);\n  puts(f[1]?\"Alice\":\"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nll dist[100010] = {};\nvector<ll> tree[100010];\n\nvoid dfs(ll cur, ll par){\n    if(cur == 0){\n        if(tree[cur].size() == 1){\n            dist[cur] = dist[tree[cur][0]] + 1;\n        }else{\n            for(auto &e: tree[cur]){\n                if(e == par) continue;\n                dfs(e, cur);\n                dist[cur] ^= dist[e]; \n            }\n        }\n    }else{\n        if(tree[cur].size() == 2){\n            if(tree[cur][0] == par){\n                dist[cur] = dist[tree[cur][1]] + 1;\n            }else{\n                dist[cur] = dist[tree[cur][0]] + 1;\n            }\n        }else{\n            for(auto &e: tree[cur]){\n                if(e == par) continue;\n                dfs(e, cur);\n                dist[cur] ^= dist[e]; \n            }\n        }\n    }\n\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    rep(i,0,N-1){\n        ll a,b;\n        cin >> a >> b;\n        a--; b--;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    dfs(0,-1);\n    ll res = 0;\n    // printa(dist, N);\n    rep(i,0,N) res ^= dist[i];\n    if(res == 0){\n        print(\"Bob\");\n    }else{\n        print(\"Alice\");\n    }\n\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\nusing namespace std;\n\nconst int N = 1e5;\nstruct Edge\n{\n\tint v,nxt;\n} e[(N<<1)+3];\nint fe[N+3];\nint sg[N+3];\nint n,en;\n\nvoid addedge(int u,int v)\n{\n\ten++; e[en].v = v;\n\te[en].nxt = fe[u]; fe[u] = en;\n}\n\nvoid dfs(int u,int prv)\n{\n\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(v==prv) continue;\n\t\tdfs(v,u);\n\t\tsg[u] ^= sg[v];\n\t}\n\tif(u!=1) sg[u]++;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tdfs(1,0);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  //dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if((int)v[i].size()%2){\n      ans++;\n    }else ans--;\n  }\n  ans=abs(ans);\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t\tif (add&&dis[c])ans ^= (dis[c]+1);\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint Grundy[100050];\nint N;\nvector<int> pathes[100500];\nint parent[100050];\n\nvoid bfs(int from) {\n    Grundy[from] = 0;\n    int child = 0;\n    for(int i = 0; i < pathes[from].size(); i++) {\n        int to = pathes[from][i];\n        if(to == parent[from]) continue;\n        parent[to] = from;\n        bfs(to);\n        Grundy[from] ^= Grundy[to];\n        child++;\n    }\n    if(child == 1) Grundy[from]++;\n    return;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 1; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        pathes[x].push_back(y);\n        pathes[y].push_back(x);\n    }\n    parent[1] = -1;\n    bfs(1);\n    if(Grundy[1] == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nvector<int> es[114514];\n\nint Dfs(int v, int p) {\n  int ret = 0;\n  for (int u : es[v]) {\n    if (u == p) continue;\n    ret ^= (Dfs(u, v)+1);\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n    es[x].eb(y);\n    es[y].eb(x);\n  }\n\n  auto res = Dfs(0, 0);\n  if (res != 0) puts(\"Alice\");\n  else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdlib> \n#include<stdio.h> \n#include<memory.h> \n#include<vector> \nusing namespace std; \nvector<int>v[100005]; \nint dfs(int x,int pre) \n{ \n    int ans=0; \n    for(int i=0;i<v[x].size();i++) \n    { \n        //printf(\"%d %d %d \\n\",x,i,v[x][i]); \n        if(v[x][i]!=pre) \n        { \n            ans^=(1+dfs(v[x][i],x)); \n        } \n    } \n    return ans; \n} \nint main() \n{ \n    int t,a,b,n; \n    scanf(\"%d\",&t); \n    while(t--) \n    { \n        scanf(\"%d\",&n); \n        for(int i=1;i<=n;i++) \n        v[i].clear(); \n        n--; \n        while(n--) \n        { \n            scanf(\"%d%d\",&a,&b); \n            v[a].push_back(b); \n            v[b].push_back(a); \n        } \n        //printf(\"%d\\n\",v[1][2]); \n        if(dfs(1,-1)) puts(\"Alice\"); \n        else puts(\"Bob\"); \n    } \n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=100005,M=N<<1;\n\nint v[M],nxt[M];\nint head[N],sg[N],n;\n\nil void addedge(int p,int x,int y){\n\tv[p]=y,nxt[p]=head[x],head[x]=p;\n}\n\nil void dfs(int u,int p){\n\tsg[u]=0;\n\tfor(int e=head[u];e;e=nxt[e]){\n\t\tif(v[e]==p) continue;\n\t\tdfs(v[e],u);\n\t\tsg[u]^=(sg[v[e]]+1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(lch(i),x,y);\n\t\taddedge(rch(i),y,x);\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long int\n#define vec vector<ll>\n#define mat vector<vector<ll>>\n\nusing namespace std;\n\nconst ll mod=1000000007;\nconst ll inf=LONG_LONG_MAX;\nll dx4[4]={1,0,-1,0};\nll dy4[4]={0,-1,0,1};\nll dx8[8]={1,0,-1,1,-1,1,0,-1};\nll dy8[8]={1,1,1,0,0,-1,-1,-1};\n\nll n;\nmat G(n);\nvec d(n);\nll dfs(ll a){\n  if(a!=0 && G[a].size()==1)return 0;\n  ll g=0;\n  for(ll i=0;i<G[a].size();i++){\n    if(d[G[a][i]]<=d[a])continue;\n    g^=((dfs(G[a][i]))+1);\n  }\n  return g;\n}\n\nint main(){\n\n  cin >> n;\n  G=mat(n);\n  for(ll i=0;i<n-1;i++){\n    ll a,b;\n    cin >> a >> b;\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  queue<ll> que;\n  que.push(0);\n  d=vec(n,-1);\n  d[0]=0;\n\n  //cout << 5 << endl;\n\n  while(!que.empty()){\n    ll v=que.front();\n    que.pop();\n\n    for(ll i=0;i<G[v].size();i++){\n      if(d[G[v][i]]==-1){\n        d[G[v][i]]=d[v]+1;\n        que.push(G[v][i]);\n      }\n    }\n  }\n\n  //cout << 5 << endl;/\n\n  //cout << dfs(0) << endl;\n\n  if(dfs(0)==0)cout << \"Bob\" << endl;\n  else cout << \"Alice\" << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\nusing namespace std;\n#define df 0\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef long int li;\n\nint dfs(const vector<vector<int>>& adj,int a=0,int seen=-1){\n  int s=0;\n  for(int v:adj.at(a)){\n    if(v==seen)continue;\n    s^=dfs(adj,v,a)+1;\n  }\n  return s;\n}\n\nint main(){\n  if(df) printf(\"*debug mode*\\n\");\n  int n; cin >>n;\n  vector<vector<int>> adj(n);\n  rep(i,n-1){\n    int x,y; cin >>x >>y; x--; y--;\n    adj.at(x).push_back(y);\n    adj.at(y).push_back(x);\n  }\n  int ans=dfs(adj);\n  cout << (dfs(adj)?\"Alice\":\"Bob\");\n}\n\n/// confirm df==0 ///\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint parent[100010];\nvint edge[100010];\nbool visited[100010];\nint grundy[100010];\n\nint dfs(int cur) {\n\tif (edge[cur].size() == 1)\treturn grundy[cur]=0;\n\tif (edge[cur].size() == 2) {\n\t\tif (visited[edge[cur][0]])\treturn grundy[cur]=dfs(edge[cur][1]) + 1;\n\t\telse\treturn grundy[cur]=dfs(edge[cur][0]) + 1;\n\t}\n\tint ret = 0;\n\trep(i, edge[cur].size()) {\n\t\tint to = edge[cur][i];\n\t\tif (!visited[to]) {\n\t\t\tvisited[to] = true;\n\t\t\tret ^= dfs(to) + 1;\n\t\t}\n\t}\n\treturn grundy[cur]=ret;\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint x, y;\tcin >> x >> y;\tx--;\ty--;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tvisited[0] = true;\n\tint ret = 0;\n\trep(i, edge[0].size()) {\n\t\tvisited[edge[0][i]] = true;\n\t\tret ^= dfs(edge[0][i]) + 1;\n\t}\n\tcout << (ret ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define debug cout << __LINE__ << endl\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<ppr> Vppr;\ntypedef pair<ut,ut> prs;\ninline void IN(ut &x){cin >> x;}\ninline void INA(ut n,ut x[]){REP(i,n) cin >> x[i];}\ninline void INE(ut m,VI edges[]){\n\tut a,b;\n\tREP(i,m){\n\t\tcin >> a >> b;\n\t\tedges[a].PB(b);\n\t\tedges[b].PB(a);\n\t}\n}\ninline void INEC(ut m,Vpr edges[]){\n\tut a,b,c;\n\tREP(i,m){\n\t\tcin >> a >> b >> c;\n\t\tedges[a].PB(pr(c,b));\n\t\tedges[b].PB(pr(c,a));\n\t}\n}\nconst LL p=7+1e9;\nconst int SIZE=300005;\nbool searched[SIZE];\nLL val[SIZE];\nLL parent[SIZE];\nVI nums[SIZE];\nVI edges[SIZE];\nint main(){\n\tLL x,y;\n\tLL N,M;\n\tcin >> N;\n\tREP(i,N-1){\n\t\tcin >> x >> y;\n\t\tedges[x].PB(y);\n\t\tedges[y].PB(x);\n\t}\n\tstack<LL> st;\n\tst.push(1);\n\twhile(!st.empty()){\n\t\tLL now=st.top();\n\t\tif(searched[now]){\n\t\t\tREP(i,nums[now].size()){\n\t\t\t\tLL next=nums[now][i];\n\t\t\t\tval[now]^=next;\n\t\t\t}\n\t\t\tnums[parent[now]].PB(val[now]+1);\n\t\t\tst.pop();\n\t\t}\n\t\tsearched[now]=true;\n\t\tREP(i,edges[now].size()){\n\n\t\t\tLL next=edges[now][i];\n\t\t\tif(!searched[next]){\n\t\t\t\tst.push(next);\n\t\t\t\tparent[next]=now;\n\t\t\t}\n\t\t}\n\t}\n\tif(val[1]==0){\n\t\tcout <<\"Bob\" << endl;\n\t}\n\telse {\n\t\tcout <<\"Alice\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint DP[100005];\nvector <int> G[100005], V;\nint N;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n}\n\nvoid DFS(int node, int father)\n{\n    int cnt = 0, val = 0, S = 0;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father)\n            continue;\n        DFS(neighb, node);\n        //Sz[node] += Sz[neighb];\n        ++cnt;\n        val = DP[neighb] + 1;\n        S = (S ^ DP[neighb]);\n    }\n    if(cnt != 1)\n        DP[node] = S;\n    else\n        DP[node] = val;\n}\nint main()\n{\n    Read();\n    DFS(1, 0);\n    if(DP[1] == 0)\n    {\n        cout << \"Bob\\n\";\n    }\n    else\n        cout << \"Alice\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, u, v, grundy[200010];\nvector<int> graph[200010];\n\nvoid dfs(int u, int p) {\n    for(int v : graph[u]) {\n        if(v == p) continue;\n        dfs(v, u);\n        grundy[u] ^= (grundy[v] + 1);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1, 1);\n    if(grundy[1]) printf(\"Alice\");\n    else printf(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    if (cur.empty()) return 0;\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 1;\n    } else {\n        for (auto t : sons) {\n            gr[cur] ^= (gr[t] + 1);\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    // for (int i = 0; i < n; i++) {\n    //     cerr << i + 1 << ' ' << gr[i] << endl;\n    // }\n    if (!gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\tvector<ULL>cash;\n\tULL ret = 1;\n\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tcash.push_back(seed(now, ch) % 2);\n\t\tret += cash.back();\n\t}\n\n\tsort(cash.begin(),cash.end());\n\n\twhile (cash.size() > 1 &&\n\t\tcash[cash.size() - 1] == cash[cash.size() - 2])\n\t{\n\t\tcash.pop_back();\n\t\tcash.pop_back();\n\t}\n\n\tif (cash.empty())\n\t{\n\t\treturn 1;\n\t}\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 1)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nvi g[MAXN];\nint gr[MAXN], prv[MAXN];\nint mex[MAXN];\n\nvoid dfs(int s) {\n\tREP(i, 0, SZ(g[s])) {\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]) {\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\t/*REPN(i, 0, SZ(g[s])) {\n\t\tmex[i] = 0;\n\t}\n\tREP(i, 0, SZ(g[s])) {\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]) {\n\t\t\tmex[gr[to] + 1] = 1;\n\t\t}\n\t}\n\tfor(; mex[gr[s]]; gr[s]++);*/\n\tREP(i, 0, SZ(g[s])) {\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]) {\n\t\t\tgr[s] ^= (gr[to] + 1);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tdfs(1);\n\tif (gr[1]) {\n\t\tprintf(\"Alice\\n\");\n\t} else {\n\t\tprintf(\"Bob\\n\");\n\t}\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_ll.hpp>\n//typedef boost::multiprecision::cpp_ll ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E18;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n//#define endl \"\\n\"\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\nll n;\nstruct Node{\n    ll par;\n    vector<ll> chi;\n};\nNode node[100001];\nvector<ll> v[100001];\n\nvoid init(ll x){\n    rep(i,0,(ll)v[x].size()-1){\n        if(v[x][i]!=node[x].par){\n            node[x].chi.pb(v[x][i]);\n            node[v[x][i]].par=x;\n            init(v[x][i]);\n        }\n    }\n}\n\nll hoge(ll x){\n    ll res=0;\n    if(node[x].chi.size()==0){\n        return 0;\n    }else{\n        rep(i,0,node[x].chi.size()-1){\n            res=res^(hoge(node[x].chi[i])+1);\n        }\n        return res;\n    }\n}\n\nint main(){fastio\n    cin>>n;\n    rep(i,0,n-2){\n        ll x,y;cin>>x>>y;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    node[1].par=1;\n    init(1);\n    if(hoge(1)==0){\n        cout<<\"Bob\"<<endl;\n    }else{\n        cout<<\"Alice\"<<endl;\n    }\n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, dep[100005];\nvector<int> adjlist[100005];\nvector< pair<int, int> > edgelist;\n\nint dfs(int x, int p) {\n\tint ans = 0;\n\tfor (int i = 0; i < adjlist[x].size(); i++) if (adjlist[x][i] != p) ans ^= dfs(adjlist[x][i], x);\n\treturn ans + 1;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tadjlist[a].push_back(b);\n\t\tadjlist[b].push_back(a);\n\t}\n\tif (dfs(0, -1) == 1) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nvector<int> e[ten(5)];\nll hs[ten(5)];\n\nll dfs(int v, int par) {\n\tmap<ll, int> dm;\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tll tmp = dfs(to, v);\n\t\ttmp *= ten(8) + 7;\n\t\tdm[tmp] ^= 1;\n\t}\n\tll pv = 1;\n\tll h = 1;\n\tfor (auto kv : dm) {\n\t\tif (kv.second == 0) continue;\n\t\th *= ten(9) + 7;\n\t\tpv += kv.first * h;\n\t}\n\n\treturn hs[v] = pv;\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tll ret = dfs(0, -1);\n\tputs(ret == 1 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\nvector<int> G[100010];\nint childs[100010]={0}, par[100010];\n\nint grundy(int i=0) {\n    int ans = 0;\n    for (auto g:G[i]) {\n        if (childs[g]) continue;\n        childs[i]++;\n        par[g] = i;\n        if (i > 0) ans += grundy(g);\n        else ans ^= grundy(g);\n    }\n    if (i > 0) {\n        if (childs[i] > 1) ans = 0;\n        ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i=1, x, y; i<n; i++) {\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (grundy() ? \"Alice\" : \"Bob\") << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ala be zekrellah tatmaenolgholoob ...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n#define MP make_pair\nconst int maxn = 1e5+9;\nconst ll mod = 1e9+7;\n\nvector <int> g[maxn];\nbool ans = true;\n\nint dfs (int v, int parent = -1) {\n\tll val = 0;\n\tll num = 0, sum = 0;\n\tfor (auto u : g[v]) {\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tnum++;\n\t\tll f = dfs(u, v);\n\t\tsum += f;\n\t\tval ^= f;\n\t}\n\tif (num == 1)\n\t\treturn sum + 1;\n\telse {\n\t\tif (val != 0)\n\t\t\tans = false;\n\t\treturn 1;\n\t}\n}\n\nint main () {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\t--v; --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0);\n\tif (ans)\n\t\tcout << \"Bob\\n\";\n\telse\n\t\tcout << \"Alice\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\tvector<ULL>cash;\n\tULL ret = 1;\n\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tcash.push_back(seed(now, ch));\n\t\tret += cash.back() * P;\n\t}\n\n\twhile (cash.size() > 1 &&\n\t\tcash[cash.size() - 1] == cash[cash.size() - 2])\n\t{\n\t\tcash.pop_back();\n\t\tcash.pop_back();\n\t}\n\n\tif (cash.empty())\n\t{\n\t\treturn 1;\n\t}\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 1)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <vector>\n#define vi vector<int>\n#define pb push_back\nconst int N = 100005;\nvi con[N];\nint g[N];\nint dfs(int s, int p){\n    int _g = 0;\n    for(int v : con[s]) if(v != p) _g ^= (dfs(v, s) + 1);\n    return g[s] = _g;\n}\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        con[u].pb(v);\n        con[v].pb(u);\n    }\n    cout << (dfs(1, 0) == 0 ? \"Bob\" : \"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100009\nusing namespace std;\n\nint n,tot,fst[N],pnt[N<<1],nxt[N<<1],fa[N];\nvoid add(int x,int y){\n\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n}\nint dfs(int x){\n\tint i,y,tg=0;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x; tg^=dfs(y)+1;\n\t\t}\n\t}\n\treturn tg;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor (i=1; i<n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tputs(dfs(1)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\n\nint grundy(int v,int pre,Graph& g){\n    vector<int> gs;\n    for(auto to:g[v]){\n        if(to!=pre) gs.push_back(grundy(to,v,g)+1);\n    }\n    int res=0;\n    for(auto g:gs) res^=g;\n    return res;\n} \nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    cout<<(grundy(0,-1,g) ? \"Alice\" : \"Bob\")<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef WIN32\n\t#define I64 \"%I64d\"\n#else\n\t#define I64 \"%lld\"\n#endif\n\ntypedef long long ll;\n\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(), s.end()\n#define sz(s) (int(s.size()))\n#define fname \"a\"\n#define MAXN 200002\n\nint n;\nvector <int> g[MAXN];\nint d[MAXN];\n\nvoid dfs(int v = 0, int pr = -1) {\n\td[v] = 0;\n\tint k = 0, s = 0;\n\tfor (const int& v2 : g[v]) {\n\t\tif (v2 == pr) continue;\n\t\tdfs(v2, v);\n\t\t++k;\n\t\ts ^= d[v2];\n\t}\n\tif (k == 1) d[v] = 1;\n\telse d[v] = s & 1;\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(fname\".in\", \"r\", stdin);\n\tfreopen(fname\".out\", \"w\", stdout);\n\t#endif\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint v1, v2;\n\t\tscanf(\"%d%d\", &v1, &v2);\n\t\t--v1, --v2;\n\t\tg[v1].pb(v2);\n\t\tg[v2].pb(v1);\n\t}\n\n\tdfs();\n\n\tputs(d[0] ? \"Alice\" : \"Bob\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;\n\tinline char Gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void Gi(I&x){\n\t\tfor(c=Gc();c<'0'||c>'9';c=Gc());\n\t\tfor(x=0;c<='9'&&c>='0';c=Gc())x=x*10+(c&15);\n\t}\n};\nusing io::Gi;\nint N,T;\nstruct edge{\n\t   int adj,nex;\n\t   edge (int a_=0,int n_=0){\n\t\t\tadj=a_;\n\t\t\tnex=n_;\n\t   }\n}E[222222];\ninline void add(int u,int v){\n\t   E[++T]=edge(v,E[u].nex);\n\t   E[u].nex=T;\n\t   E[++T]=edge(u,E[v].nex);\n\t   E[v].nex=T;\n}\nint dfs(int x,int f){\n\tint s=0;\n\tfor (int i=E[x].nex;i;i=E[i].nex){\n\t\tif (E[i].adj!=f){\n\t\t   s^=(dfs(E[i].adj,x)+1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint u,v;\n\t//Gi(N);\n\tscanf(\"%d\",&N);\n\tT=N;\n\tfor (int i=1;i!=N;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t//Gi(u);\n\t\t//Gi(v);\n\t\tadd(u,v);\n\t}\n\tprintf(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N;\nint x[100010];\nint y[100010];\nvector<int> V[100010];\nint parent[100010];\n\nvoid make_parent(int v, int p) {\n  parent[v] = p;\n  for (auto x : V[v]) {\n    if (x != p) {\n      make_parent(x, v);\n    }\n  }\n}\n\nint grundy(int v) {\n  int s = V[v].size();\n  if (v == 0) ++s;\n  int ans;\n  if (s == 1) {\n    ans = 0;\n  } else if (s == 2) {\n    for (auto x : V[v]) {\n      if (x != parent[v]) {\n        ans = grundy(x) + 1;\n      }\n    }\n  } else {\n    ans = 0;\n    for (auto x : V[v]) {\n      if (x != parent[v]) {\n        ans ^= grundy(x);\n      }\n    }\n  }\n  cerr << \"grundy(\" << v << \") = \" << ans << endl;\n  return ans;\n}\n\nint main () {\n  cin >> N;\n  for (auto i = 0; i < N-1; ++i) {\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n    V[x[i]].push_back(y[i]);\n    V[y[i]].push_back(x[i]);\n  }\n  make_parent(0, -1);\n  if (grundy(0) == 0) {\n    cout << \"Bob\" << endl;\n  } else {\n    cout << \"Alice\" << endl;    \n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = 0;//(sz(v[u]) - (u ? 1: 0)) % 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= (1 - d[h]);\n    }\n    if (sz(v[u]) - (u ? 1: 0) == 1) {\n        d[u] = 1;\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "/**\n    Sweet!\n**/\n#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mk make_pair\n#define pb push_back\n#define pp pop_back()\n#define ll long long\n#define ld long double\n#define OK puts(\"OK\");\n#define sz(s) (int)s.size()\n#define all(s) s.begin(), s.end()\n#define rand() rand() >> 16 * rand()\n\nusing namespace std;\n\nconst int N = 2e5+10;\nconst int inf = 2e9+7;\nconst ll linf = 1e18+9;\n\nint n;\nint lvl[N];\nvector <int> g[N];\n\nvoid dfs(int v, int lv, int p = 1) {\n    lvl[lv]++;\n    for(int to : g[v])\n        if(to != p)\n            dfs(to, lv + 1, v);\n}\n\nint main() {\n    cin >> n;\n    for(int i = 1, x, y; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1, 0);\n    for(int i = 1; i <= n; i++) {\n        if(lvl[i] % 2 == 1) {\n            puts(\"Alice\");\n            return 0;\n        }\n    }\n    puts(\"Bob\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1000010\n\nvector<int> e[N];\nint n,sg[N],u,v;\n\nvoid dfs(int u,int fa)\n{\n    sg[u]=0;\n    for(auto v : e[u])\n    {\n        if(v==fa)continue;\n        dfs(v,u);\n        sg[u]^=sg[v]+1;\n    }\n}\n\nint main()\n{\n    cin>>n;\n    for(int i=1;i<n;++i)\n    {\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\nint n;\nstruct Edge\n{\n    int num;\n    int next;\n}edge[200005];\nint tot,last[100005];\nint num[100005];\nint sg[100005];\nint fa[100005];\n\nvoid Add(int i,int j)\n{\n    tot++;\n    edge[tot].num=j;\n    edge[tot].next=last[i];\n    last[i]=tot;\n}\n\nvoid dfs_Init(int i)\n{\n    for (int k=last[i];k!=0;k=edge[k].next)\n        {\n        if (edge[k].num==fa[i]) continue;\n        fa[edge[k].num]=i;\n        num[i]++;\n        dfs_Init(edge[k].num);\n        }\n}\n\nvoid dfs_work(int i)\n{\n    if (num[i]==0)\n        {\n        sg[i]=0;\n        return ;\n        }\n    int sum=0;;\n    for (int k=last[i];k!=0;k=edge[k].next)\n        {\n        if (edge[k].num==fa[i]) continue;\n        dfs_work(edge[k].num);\n        sum=sum^(sg[edge[k].num]+1);\n        }\n    sg[i]=sum;\n}\n\nint main()\n{\n    scanf (\"%d\",&n);\n    for (int i=1;i<n;i++)\n        {\n        int a,b;\n        scanf (\"%d %d\",&a,&b);\n        Add(a,b);\n        Add(b,a);\n        }\n    dfs_Init(1);\n    dfs_work(1);\n    if (sg[1]==0) printf (\"Bob\");\n    else printf (\"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define all(a) a.begin(),a.end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define mp make_pair\n#define endl '\\n'\n#define vec vector<ll>\n#define mat vector<vector<ll> >\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\nconst ll inf=998244353;\nconst ll mod=1e9+7;\nvector<vector<ll> >G(100010);\nvector<ll>d(100010);\nvoid dfs(ll i,ll p,ll c){\n    d[i]=c;\n    for(auto e:G[i]){\n        if(e==p)continue;\n        dfs(e,i,c+1);\n    }\n    return;\n}\nsigned main(){\n    ll n;cin>>n;\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    dfs(0,-1,0);\n    ll ans=0;\n    rep(i,n){\n        ans^=d[i];\n    }\n    if(G[0].size()==1)ans=1;\n    if(ans)cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sg;\nvector<int>v[100010];\nint f[100001];\n\nint dfs(int n,int fa)\n{\n    sg=0;\n    for(int i=0;i<v[n].size();i++)\n    {\n        if(v[n][i]!=fa)\n        {\n            return sg^=dfs(v[n][i],n);\n        }\n        sg+=1;\n    }\n}\n\nint main()\n{\n    int n,a,b,ans;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    if(dfs(1,0)) printf(\"Alice\");\n    else printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    int cnt = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++cnt;\n            res += dfs(e, now);\n        }\n    }\n    if (cnt == 2) ++res;\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if ((N - 1) % 2) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n,x=0,a,b,i;\n\tcin>>n;\n\tn--; \n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b;\n\t\tif(a==1) x++;\n\t}\n\tif(x%2==0) cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nint x[100001];\nint y[100001];\nvector<int>G[100001];\nbool check=true;\nbool used[100001];\n//LL now=0;\nvector<int> dfs(int x,int d){\n    vector<int>ans;\n    if(used[x])return ans;\n    used[x]=true;\n    vector<int>v;\n    REP(i,G[x].size()){\n        if(used[G[x][i]]==false){\n           auto a=dfs(G[x][i],d+1);\n           REP(j,a.size()){\n           v.push_back(a[i]);\n           }\n        }\n    }\n    sort(v.begin(),v.end());\n    int me=0;\n\n    REP(i,v.size()){\n        if(v[i]==0)continue;\n        if(me==0){\n           me=v[i];\n           continue;\n        }\n        if(me!=v[i]){\n           ans.push_back(v[i]+1);\n           //check=false;\n        }else{\n           me=0;\n        }\n    }\n    //now^=d;\n    //cout<<x<<me<<endl;\n    if(me!=0)ans.push_back(me+1);\n    return ans;\n}\n\nint main(){\n    cin>>N;\n    REP(i,N-1){\n        cin>>x[i];x[i]--;\n        cin>>y[i];y[i]--;\n        G[x[i]].push_back(y[i]);\n        G[y[i]].push_back(x[i]);\n    }\n    REP(i,N){\n        used[i]=false;\n    }\n    if(N==2){\n       cout<<\"Alice\"<<endl;\n       return 0;\n    }\n    auto ans=dfs(0,0);\n    if(ans.size()!=1){\n       cout<<\"Alice\"<<endl;\n    /*}else /*if(check==false){\n       cout<<\"Alice\"<<endl;*/\n    }else{\n       cout<<\"Bob\"<<endl;\n    }\n    \n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\n\nbitset <N> dp[N], ans;\nvector <int> es[N];\n\nvoid dfs(const int& u, const int& f, const int& deep) {\n  dp[u].set(deep);\n  for (int i = 0; i < (int)es[u].size(); ++i) {\n    int v = es[u][i];\n    if (v == f)\n      continue;\n    dfs(v, u, deep + 1);\n    dp[u] ^= dp[v];\n  }\n  ans ^= dp[u];\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    es[u].push_back(v);\n    es[v].push_back(u);\n  }\n  ans = 0;\n  for (int i = 0; i < (int)es[1].size(); ++i)\n    dfs(es[1][i], 1, 0);\n  if (ans == 0)\n    printf(\"Bob\\n\");\n  else {\n    for (int i = 2; i <= n; ++i)\n      if (dp[i] == ans) {\n        printf(\"Alice\\n\");\n        return 0;\n      }\n    printf(\"Bob\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c,n;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint dfs(int u,int p)\n{\n\tint ret=0;\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=p)\n\t\t{\n\t\t\tret^=dfs(V[i],u)+1;\n\t\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tint ans=dfs(1,0);\n\tif(ans) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma warning(disable:4996)\n//#include <Windows.h>\n#include <iostream>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <functional>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n#include <complex>\n#include <cstdio>\n#include <list>\n#include <bitset>\n//#include <stdio.h>\n\n//< in.txt > out.txt\nusing namespace std;\n//std::ios::sync_with_stdio(false);\n//std::cin.tie(0);\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\ntypedef long long LL;\ntypedef long double LD;\n//typedef boost::multiprecision::cpp_int bigint;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, int> PI;\ntypedef pair<LD, LL> pdl;\ntypedef pair<LD, LD> pdd;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<int> VI;\ntypedef vector<vector<int>> VVI;\ntypedef unsigned long long ULL;\n\ntemplate<class T>\ninline void chmin(T& a, T b) {\n\ta = min(a, b);\n}\n\ntemplate<class T>\ninline void chmax(T& a, T b) {\n\ta = max(a, b);\n}\n\nvoid input();\nvoid solve();\n\nvoid daminput();\n\nint main() {\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tinput();\n\t//daminput();\n\tsolve();\n\treturn 0;\n}\n\n//////////////////////////////////////////////////\n//////////////////////////////////////////////////\n\nint N;\nVI X, Y;\n\nvoid input() {\n\tcin >> N;\n\tX.resize(N-1);\n\tY.resize(N-1);\n\tfor (int n = 0; n < N-1; n++)\n\t{\n\t\tcin >> X[n] >> Y[n];\n\t}\n}\n\nvoid daminput() {\n}\ntemplate<class T>\nstruct Gedge {\n\tint src, to;\n\tT cost;\n\tint id;\n\tGedge(int s, int t, T c, int i = -1) :src(s), to(t), cost(c), id(i) {}\n\tGedge(int t, T c) :src(-1), to(t), cost(c), id(-1) {}\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Gedge<T>>>;\nusing UnweightedGraph = vector<vector<LL>>;\ntemplate<class T>\nusing Gedges = vector<Gedge<T>>;\n\ntemplate<class T>\nstruct TNode {\n\tint parent;\n\tVI childs;\n\tT cost;\n\tint id;\n\tTNode() :parent(-1), cost(0), id(-1) {};\n};\ntemplate<class T>\nusing Tree = vector<TNode<T>>;\ntemplate<class Type>\nvoid SetTree(WeightedGraph<Type>& G, Tree<Type>& T, int root = 0) {\n\tint N = G.size();\n\tT.resize(N);\n\tqueue<int> q;\n\tq.push(root);\n\tT[root].parent = -1;\n\tT[root].id = -1;\n\tT[root].cost = 0;\n\twhile (!q.empty()) {\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tfor (Gedge<Type>& e : G[cur]) {\n\t\t\tif (e.to == T[cur].parent)continue;\n\t\t\tT[e.to].parent = cur;\n\t\t\tT[cur].childs.push_back(e.to);\n\t\t\tT[e.to].id = e.id;\n\t\t\tT[e.to].cost = e.cost;\n\t\t\tq.push(e.to);\n\t\t}\n\t}\n}\n\nWeightedGraph<int> G;\nTree<int> T;\n\nint dp(int n) {\n\tint ans = 0;\n\tfor (int ch : T[n].childs) {\n\t\tint chxor = dp(ch);\n\t\tans = ans ^ (chxor + 1);\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\tG.resize(N);\n\tfor (int n = 0; n < N - 1; n++)\n\t{\n\t\tG[X[n] - 1].push_back({ Y[n] - 1, 1 });\n\t\tG[Y[n] - 1].push_back({ X[n] - 1, 1 });\n\t}\n\tSetTree(G, T, 0);\n\tint grundy = dp(0);\n\tif (grundy == 0)cout << \"Bob\\n\";\n\telse cout << \"Alice\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\nconstexpr int MAX = 100000;\n\nstruct Graph {\n    void addEdge(int from, int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<int> edge[MAX];\n};\n\nint N;\nGraph g_;\nGraph g;\n\nll grundy(int root)\n{\n    if (g.edge[root].empty()) {\n        return 1;\n    } else if (g.edge[root].size() == 1) {\n        return grundy(g.edge[root][0]) + 1;\n    } else {\n        ll num = 0;\n        for (const int p : g.edge[root]) {\n            num ^= grundy(p);\n        }\n        return num + 1;\n    }\n}\n\nint main()\n{\n    cin >> N;\n    for (ll i = 0; i < N - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        g_.addEdge(x, y);\n        g_.addEdge(y, x);\n    }\n    bool check[MAX];\n    fill(check, check + MAX, false);\n    queue<int> q;\n    q.push(0);\n    while (not q.empty()) {\n        const int p = q.front();\n        q.pop();\n        check[p] = true;\n        for (const int to : g_.edge[p]) {\n            if (not check[to]) {\n                g.addEdge(p, to);\n                q.push(to);\n            }\n        }\n    }\n\n    const ll grundynum = grundy(0);\n    if (grundynum == 1) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nconst int calender[13] = {0, 31,28,31,30,31,30,31,31,30,31,30,31};\nconst int ucalender[13] = {0, 31,29,31,30,31,30,31,31,30,31,30,31};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\ntemplate< typename T > struct edge {\n   int src, to; T cost;\n   edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n   edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n   edge &operator=(const int &x) { to = x; return *this;}\n   operator int() const { return to; }\n};\ntemplate< typename T > using Edges = vector< edge< T > >;\ntemplate< typename T > using WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T > using Matrix = vector< vector< T > >;\nvoid add_edge(UnWeightedGraph& g, int x, int y){\n    g[x].push_back(y);\n    g[y].push_back(x);\n}\ntemplate< typename T > \nvoid add_edge(WeightedGraph< T >& g, int x, int y, T c){\n    g[x].push_back({y, c});\n    g[y].push_back({x, c});\n}\nvoid add_edge_bi(UnWeightedGraph& g, int x, int y){\n    g[x].push_back(y);\n}\ntemplate< typename T > \nvoid add_edge_bi(WeightedGraph< T >& g, int x, int y, T c){\n    g[x].push_back({y, c});\n}\n\nint dfs(UnWeightedGraph& g, int v, int p = -1){\n    int t = 0;\n    for(auto nv: g[v]){\n        if(p == nv) continue;\n        t ^= (dfs(g, nv, v) + 1);\n    }\n    return t;\n}\n\nint main(){\n    iosetup();\n    int n; cin >> n;\n    UnWeightedGraph g(n);\n    rep(i, 1, n){\n        int x, y; cin >> x >> y; x--, y--;\n        add_edge(g, x, y);\n    }\n    if(dfs(g, 0) != 0) puts(\"Alice\");\n    else puts(\"Bob\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 1000005\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0'||ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0'&&ch<='9'){\n\t\tx=(x<<1)+(x<<3)+(ch^'0');\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nvector<int>G[MAXN];\ninline void AddEdge(int u,int v){\n\tG[u].push_back(v);\n}\nint dfs(int u,int father){\n\tint ans=0;\n\tfor (int i=0;i<G[u].size();++i){\n\t\tint v=G[u][i];\n\t\tif (v!=father) ans^=(dfs(v,u)+1);\n\t}\n\treturn ans;\n}\nint main(){\n\tint n=read();\n\tint cnt=0;\n\tfor (int i=1;i<n;++i){\n\t\tint u=read(),v=read();\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tputs(dfs(1,1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\ndouble pi=2*acos(0);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nint main(){\n  int n;cin>>n;\n  vector<int> v[n+1];\n  rep(i,0,n-1){\n    int a,b;cin>>a>>b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  queue<int> q;\n  int par[n+1];\n  par[1]=-1;\n  q.push(1);\n  bool used[n+1];\n  fill(used,used+n+1,false);\n  while(q.size()>0){\n    int now=q.front();q.pop();\n    rep(i,0,v[now].size()){\n      int ne=v[now][i];\n      if(par[now]==ne)continue;\n      par[ne]=now;\n      used[now]=true;\n      q.push(ne);\n    }\n  }\n  rep(i,1,n+1){\n    if(used[i]==false)q.push(i);\n  }\n  int d[n+1];\n  int cnt[n+1];\n  fill(cnt,cnt+n+1,0);\n  v[1].push_back(-1);\n  while(q.size()>0){\n    int now=q.front();q.pop();\n    int u=0;\n    rep(i,0,v[now].size()){\n      int ne=v[now][i];\n      if(par[now]==ne)continue;\n      u^=d[ne];\n    }\n    if(u==0)d[now]=1;\n    else d[now]=2;\n    if(now==1)break;\n    int p=par[now];\n    cnt[p]++;\n    if(cnt[p]==v[p].size()-1)q.push(p);\n  }\n  if(d[1]==1)cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=100007;\n\nstd::vector<int>p[N];\nint n;\n\nint dfs(int x,int fa)\n{\n\tint t=0;\n\tfoe(i,p[x])if(*i!=fa)t^=dfs(*i,x)+1;\n\treturn t;\n}\n\nint main()\n{\n\tin,n;\n\tfo1(i,n-1)\n\t{\n\t\tint x,y;\n\t\tin,x,y;\n\t\tp[x].pb(y);\n\t\tp[y].pb(x);\n\t}\n\tout,dfs(1,0)?\"Alice\":\"Bob\",'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nvector<int> adj[N];\nint dfs(int v, int p = -1) {\n\tint res = 0;\n\tfor (int u : adj[v])\n\t\tif (u != p) {\n\t\t\tres ^= dfs(u, v) + 1;\n\t\t}\n\treturn res;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int j = 0; j < n - 1; ++j) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u, --v;\n\t\tadj[u].pb(v);\n\t\tadj[v].pb(u);\n\t}\n\tint res = dfs(0);\n\tif (res) {\n\t\tcout << \"Alice\\n\";\t\n\t} else {\n\t\tcout << \"Bob\\n\";\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n;cin>>n;\n    vector<vector<int>> g(n);\n    rep(i,n-1){\n        int u,v;cin>>u>>v;u--,v--;\n        g[u].push_back(v);g[v].push_back(u);\n    }    \n    function<int(int,int)> dfs=[&](int pre,int now){\n        int ret=0;\n        for(auto &to:g[now])if(to!=pre)ret^=dfs(now,to)+1;\n        return ret;\n    };\n    cout<<(dfs(-1,0)==0?\"Bob\\n\":\"Alice\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define int long long\n#define P pair<int,int>\n#define all(vec) vec.begin(),vec.end()\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nint kai(int x, int y, int m) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y, int m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nint n;\nvector<int> vec[100010];\nint d[100010];\n\nvoid dfs(int v, int p) {\n\tif ((v == 1 && (int)vec[v].size() == 1) || (1 < v && (int)vec[v].size() == 2)) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tif (vec[v][i] == p)continue;\n\t\t\tdfs(vec[v][i], v);\n\t\t\td[v] = d[vec[v][i]] + 1;\n\t\t}\n\t}\n\telse {\n\t\tint k = 0;\n\t\tfor (int i = 0; i < (int)vec[v].size(); i++) {\n\t\t\tif (vec[v][i] == p)continue;\n\t\t\tdfs(vec[v][i], v);\n\t\t\tk ^= d[vec[v][i]];\n\t\t}\n\t\td[v] = k;\n\t}\n}\n\nsigned main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tif (d[1] % 2)cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sg;\nvector<int>v[100010];\nint f[100001];\n\nint dfs(int n,int fa)\n{\n    sg=0;\n    for(int i=0;i<v[n].size();i++)\n    {\n        if(v[n][i]!=fa)\n        {\n             sg^=dfs(v[n][i],n);\n        }\n        return sg+1;\n    }\n}\n\nint main()\n{\n    int n,a,b,ans;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    if(dfs(1,0)==1) printf(\"Alice\");\n    else printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM], w[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, nr = 0;\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n            dfs(v[nod][i], nod);\n        }\n    }\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n           w[++nr] = s[ v[nod][i] ];\n        }\n    }\n    sort(w + 1, w + nr + 1);\n    if(w[1] == 0 && nr != 0){\n        for(i = 2; i <= nr; i++){\n            if(w[i] - w[i - 1] > 1){\n                s[nod] = w[i - 1] + 1;\n                break;\n            }\n        }\n        if(i == nr + 1){\n            s[nod] = w[nr] + 1;\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(v[1].size() == 1){\n        cout<<\"Alice\";\n        return 0;\n    }\n    dfs(1, 0);\n    for(i = 2; i <= n; i++){\n        sum ^= s[i];\n    }\n    if(sum == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nvector<int> bi[100005];\nint n,m,i,j,dp[100005];\nvoid dfs(int x,int fa)\n{\n\tint i;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tdfs(bi[x][i],x);\n\t\tdp[x]^=dp[bi[x][i]]+1;\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tif (dp[1]) cout<<\"Alice\"; else cout<<\"Bob\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nll sm;\nint dp[N];\nll dp1[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      dp[v]++;\n      dp1[v]++;\n      dp1[v] += dp1[to];\n    }\n  }\n  sm += dp1[v];\n}\nvoid solve() {\n  //freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (sz(g[1]) == 1) cout << \"Alice\", ioi\n  dfs(1, 1);\n  if (sm % 2) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);++i)\n#define rep11(i,n) for(int i=1;i<(int)(n);++i)\n#define repo(i,o,n) for(int i=o;i<(int)(n);++i)\n#define repm(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define sperase(v,n) (v).erase(remove(all(v), n), (v).end())\n#define vdelete(v) (v).erase(unique(all(v)), (v).end())\n#define pb(n) push_back(n)\n#define mp make_pair\n#define MOD 1000000007\n#define INF LONG_LONG_MAX\n\nint n,x,y,memo[100000],cnt[100000],c1,c2;\nvector<int> v[100000];\nqueue<int> que;\n\nsigned main() {\n    cin >> n;\n    rep(i,n) cnt[i]++;\n    rep(i,n-1) {\n        cin >> x >> y;\n        --x, --y;\n        v[x].pb(y);\n        v[y].pb(x);\n        memo[x]++;\n        memo[y]++;\n    }\n    rep(i,n) if (memo[i] == 1) que.push(i), memo[i]--;\n    while(que.size()) {\n        int qf = que.front();que.pop();\n        for(auto i : v[qf]) {\n            if (memo[i]) {\n                cnt[i] += cnt[qf];\n                memo[i]--;\n                if (memo[i] == 1) que.push(i), memo[i]--;\n            }\n        }\n    }\n    for(auto i : v[0]) {\n        if (cnt[i]%2) c1++;\n        else c2++;\n    }\n    c1 %= 2;\n    c2 %= 2;\n    if (c1|c2) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pqueue priority_queue\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll mod1=998244353;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nint main() {\n  int N;\n  cin>>N;\n  vector<vector<int> > edge(N);\n  int a, b;\n  for(int i=0;i<N-1;++i) {\n    cin>>a>>b;\n    a--;\n    b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  int depth[N];\n  for(int i=0;i<N;++i) depth[i] = -1;\n  queue<pair<int, int> > que;\n  que.push(mp(0, 0)); // (index, depth)\n  pair<int, int> state;\n  while(!que.empty()) {\n    state = que.front();que.pop();\n    if(depth[state.fi]>-1) continue;\n    depth[state.fi] = state.se;\n    for(int i=0;i<edge[state.fi].size();++i) {\n      if(depth[edge[state.fi][i]]>-1) continue;\n      que.push(mp(edge[state.fi][i], state.se+1));\n    }\n  }\n  int maxdepth = 0;\n  map<int, int> amap;\n  for(int i=0;i<N;++i) {\n    maxdepth = max(maxdepth, depth[i]);\n    amap[depth[i]]++;\n  }\n  bool can = true;\n  for(int i=1;i<=maxdepth;++i) {\n    if(amap[i]%2==1) can = false;\n  }\n  if(can) cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include <random>\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end());\n#define ll long long\n#define pb(a) push_back(a)\n#define print(x) cout<<x<<'\\n';\n#define pe(x) cout<<x<<\" \";\n#define lb(v,n) lower_bound(v.begin(), v.end(), n);\n#define ub(v,n) upper_bound(v.begin(), v.end(), n);\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \");\n//#define double long double\n\n\n\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a>b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a<b) a = b; }\n\nconst int MOD = 1e9 + 7;\nconst ll INF = 1e17;\nconst int INT_INF = 1e9;\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ntypedef pair<int, int>P;\nconst int MAX = 200020;\n\n\n\nbool vis[100010];\nvector<int>G[100010];\n\nint grundy(int n, int pre) {\n\t//print(n);\n\tif (n == 1) {\n\t\tif (G[n].size() == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tres ^= (grundy(nex, n)+1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\telse {\n\t\tif (G[n].size() == 2) {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tif (nex == pre)continue;\n\t\t\t\tres = grundy(nex, n);\n\t\t\t}\n\t\t\tres++;\n\t\t\treturn res;\n\t\t}\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tif (nex == pre)continue;\n\t\t\t\tres ^= grundy(nex, n);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N; cin >> N;\n\tREP(i, N-1) {\n\t\tint x, y; cin >> x >> y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tll res = grundy(1, -1);\n\tif (res == 0) {\n\t\tprint(\"Bob\");\n\t}\n\telse print(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#include<fstream>\n#include<string>\nusing namespace std;\n#define f(n) for(int i=0;i<n;++i)\n#define ll long long\n\nint main() {\n\tll ans = 0, n;\n\tcin >> n;\n\tvector<ll>v(1000000,0);\n\tf(n - 1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tv[a]++;\n\t\tv[b]++;\n\t}\n\tf(n) {\n\t\tif (v[i] % 2 == 0) {\n\t\t\tans++;\n\t\t}\n\t}\n\tans -= 1;\n\tif (ans % 2 == 0 || v[1] == 1) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author tatsumack\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)\n#define REV(i, a, b) for (int i = (a); i >= (b); --i)\n#define CLR(a, b) memset((a), (b), sizeof(a))\n#define DUMP(x) cout << #x << \" = \" << (x) << endl;\n#define INF 1001001001001001001ll\n#define fcout cout << fixed << setprecision(12)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nclass DGameOnTree {\npublic:\n    vector<vector<int>> G;\n\n    int dfs(int v, int p) {\n        int res = 0;\n        for (auto to : G[v]) {\n            if (to == p) continue;\n            int tmp = dfs(to, v);\n            res ^= (tmp + 1);\n        }\n        return res;\n    }\n\n    void solve(std::istream& cin, std::ostream& cout) {\n        int N;\n        cin >> N;\n        G.resize(N);\n        REP(i, N - 1) {\n            int x, y;\n            cin >> x >> y;\n            x--, y--;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        int ans = dfs(0, -1);\n        cout << (ans > 0 ? \"Alice\" : \"Bob\") << endl;\n    }\n};\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n\n    DGameOnTree solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nint n, a, b; vector<vector<int> > g;\nint solve(int pos, int pre) {\n\tint ret = 0;\n\tfor (int i : g[pos]) {\n\t\tif(i != pre) ret ^= solve(i, pos);\n\t}\n\treturn ret + 1;\n}\nint main() {\n\tcin >> n; g.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b; a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tcout << (solve(0, -1) - 1 ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <list>\n#include <map>\n#include <queue>\n#include <iterator>\n#include <iomanip>\n#include <stdio.h>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define ld long double\n#define infinity (ll)1e18+1\n#define PI 3.14159265358979\n\n#define pdd pair<ld,ld>\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n\n#define MP make_pair\n#define SZ size()\n#define PB push_back\n\n#define vi vector<int>//ll\n#define vll vector<ll>\n#define vpll vector<pll>\n#define vpii vector<pii>\n#define vch vector<char>\n#define vb vector<bool>\n#define vld vector<ld>\n\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(ll i = (b) - 1; i >= (a); --i)\n#define REPEAT(i) FOR(counter1234,0,i)\n#define ALL(a) a.begin(), a.end()\n#define X first\n#define Y second\n#define MAXN 100001\nclock_t startTime;\n\nint n;\nvi g[MAXN];\n\nvi sons;\nint c = 0;\nvch used;\nvoid dfs(int v)\n{\n\tint s = c;\n\tused[v] = 1;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t\tdfs(i), c++;\n\tsons[v] = c - s;\n}\nint d[MAXN];\n\nvoid bfs()\n{\n\td[1] = 0;\n\tused.assign(n + 1, 0);\n\tused[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor(auto i: g[t])\n\t\t\tif (used[i] == 0)\n\t\t\t{\n\t\t\t\tused[i] = 1;\n\t\t\t\td[i] = d[t] + 1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tstartTime = clock();\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\t//ifstream in(\"In.txt\");\n\n\tcin >> n;\n\tint a, b;\n\tsons.assign(n + 1, 0);\n\tused.assign(n + 1, 0);\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll XOR_ALL = 0;\n\tdfs(1);\n\tbfs();\n\n\tvi xors;\n\txors.assign(n + 1, 0);\n\n\tFOR(i, 1, n + 1)\n\t\tfor (auto s : g[i])\n\t\t\tif (d[s] > d[i])\n\t\t\t\txors[i] ^= (sons[s] + 1);\n\t\n\n\tif (xors[1] == 0)\n\t{\n\t\tcout << \"Bob\";\n\t\treturn 0;\n\t}\n\tfor (auto s : g[1])\n\t\tif (xors[s] != 0)\n\t\t{\n\t\t\tcout << \"Alice\";\n\t\t\treturn 0;\n\t\t}\n\n\n\tcout << \"Bob\";\n\treturn 0;\n}\n//don't forget about MAXN, mod and infinity "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2e5+5;\nstruct edge{\n\tint to,nxt;\n}e[N<<1];\nint head[N],n,cnt;\nint g(int u,int p){\n\tint r=0;\n\tfor(int i=head[u];i;i=e[i].nxt)\n\tif(e[i].to!=p)r^=g(e[i].to,u)+1;\n\treturn r;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[++cnt]=(edge){v,head[u]},head[u]=cnt;\n\t\te[++cnt]=(edge){u,head[v]},head[v]=cnt;\n\t}\n\tputs(g(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n};\n\nEdge e[200005];\nint head[100005];\n\nint dfs(int x,int fa) {\n  int s=0;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) s^=dfs(e[i].t,x)+1;\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[y]);\n  \thead[y]=2*i;\n  }\n  puts((dfs(1,0))?\"Alice\":\"Bob\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nvector<int>v[100005]; \nint get_sg(int u,int pre){ \n    int ret=0; \n    for(int i=0;i<v[u].size();i++){ \n        if(v[u][i]!=pre) \n            ret^=(1+get_sg(v[u][i],u)); \n    } \n    return ret; \n} \nint main(){ \n    int n;\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++) v[i].clear(); \n    for(int i=1;i<n;i++){ \n    \tint x,y; \n        scanf(\"%d%d\",&x,&y); \n        v[x].push_back(y); \n        v[y].push_back(x); \n    } \n    if(get_sg(1,-1)) puts(\"Alice\"); else puts(\"Bob\"); \n    return 0; \n} \n/*\nSample Input 1\n5\n1 2\n2 3\n2 4\n4 5\nSample Output 1\nAlice\nSample Input 2\n5\n1 2\n2 3\n1 4\n4 5\nSample Output 2\nBob\nSample Input 3\n6\n1 2\n2 4\n5 1\n6 3\n3 2\nSample Output 3\nAlice\nSample Input 4\n7\n1 2\n3 7\n4 6\n2 3\n2 4\n1 5\nSample Output 4\nBob\n*/"
  },
  {
    "language": "C++",
    "code": "/*   Abhijith  */\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<cmath>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define all(v) (v).begin(),(v).end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define\tendl '\\n'\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nvector<lld>     adj[300005];\nlld dp[300005];\nvoid dfs(lld s,lld par)\n{\n    lld sz=adj[s].size();\n    if(sz==1&&s!=1)          //leaf node base condition\n    {\n        dp[s]=1;\n        return;\n    }\n    lld ans1=0;\n    for(lld i=0;i<sz;i++)\n    {\n        if(adj[s][i]==par)\n            continue;\n        dfs(adj[s][i],s);\n        ans1=ans1^dp[adj[s][i]];\n    }\n    dp[s]=1+ans1;\n}\nint main()\n{\n      ios;\n      lld x,y,n,m;\n      cin>>n;\n      m=n-1;\n      rep(i,0,m-1)\n      {\n          cin>>x>>y;\n          adj[x].pb(y);\n          adj[y].pb(x);  //if graph is directed delete this line\n      }\n      dfs(1LL,0LL);\n      if(dp[1]==1)\n        cout<<\"Bob\"<<endl;\n      else\n        cout<<\"Alice\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?9e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvvi G;\nvi used;\nint dfs(int a){\n\tused[a]=true;\n\tint out=0;\n\trep(i,G[a].size())if(!used[G[a][i]])out^=dfs(G[a][i]);\n\treturn out+1;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tused=vi(n);\n\tint t=dfs(0);\n\tif(t==1)cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nusing namespace std;\n\nconst int N=100010;\nint n,x,y;\nvector<int> vec[N];\n\nint dfs(int x,int pa) {\n    int tmp=0;\n    for (int i=0;i<vec[x].size();i++) {\n        if (vec[x][i]==pa) continue;\n        tmp^=(dfs(vec[x][i],x)+1);\n    }\n    return tmp;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=0;i<n-1;i++) {\n        scanf(\"%d%d\",&x,&y);\n        vec[x].pb(y);\n        vec[y].pb(x);\n    }\n    int res=dfs(1,0);\n    if (res==0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define maxn 1000001\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint nt[maxn], go[maxn], fi[maxn], n, cnt, sg[maxn];\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n}\nvoid dfs(int x, int fa){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; if(v == fa) continue;\n        dfs(v, x); sg[x] ^= (sg[v] + 1);\n    }\n}\nint main(){\n    n = read();\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add(x, y); add(y, x);\n    }\n    dfs(1, 0);\n    if(sg[1] == 0) printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\nusing namespace std;\n#define PI acos(-1.0)\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int maxn=5e5+100,maxm=1e5+100,inf=0x3f3f3f3f,mod=1e9+7;\nconst ll INF=1e13+7;\npriority_queue<P,vector<P>,greater<P> >q;\nstruct edge\n{\n    int from,to;\n    int cost;\n};\nvector<int>G[maxn];\nint get_sg(int u,int pa)\n{\n    int ret=0;\n    for(int i=0; i<G[u].size(); i++)\n    {\n        if(G[u][i]==pa) continue;\n        ret^=(1+get_sg(G[u][i],u));\n    }\n    return ret;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1; i<=n; i++) G[i].clear();\n    for(int i=1; i<n; i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    if(get_sg(1,-1)) cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 55\n#define N 1005\n#define ll long long\n#define oo 1000000000\n#define mod 5557\nusing namespace std;\nint n,m,res[M];\nvector<int >vec[M];\nvoid dfs(int now,int f){  \n\tfor(int i=0;i<vec[now].size();i++){\n\t\tint y=vec[now][i];\n\t\tif(y==f)continue;\n\t\tdfs(y,now);\n\t\tres[now]=res[now]^(1+res[y]);\n\t}\n}  \nint main(){\n\tint i,j,a,b;\n\tcin>>n;\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs(1,0);\n\tif(res[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 100005;\n\nint n, sg[MAXN];\nvector < int > adj[MAXN];\n\ninline void Dfs(int x, int f)\n{\n\tfor (auto y : adj[x])\n\t\tif (y ^ f)\n\t\t\tDfs(y, x), sg[x] ^= sg[y] + 1;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read();\n\tfor (int i = 1, x, y; i < n; i ++)\n\t\tx = Read(), y = Read(), adj[x].pb(y), adj[y].pb(x);\n\n\tDfs(1, 0);\n\n\tif (sg[1])\n\t\tputs(\"Alice\");\n\telse\n\t\tputs(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005, LN = 50;\nint tc, n, m, idx, lc[N * LN], rc[N * LN], sum[N * LN], tag[N * LN], x, y;\nint head[N], tot;\nstruct edge { int to, nxt; } e[N << 1];\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x] }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y] }, head[y] = tot;\n}\nvoid pushdown(int root, int dep) {\n\tif (tag[root] >> dep & 1) std::swap(lc[root], rc[root]);\n\ttag[lc[root]] ^= tag[root], tag[rc[root]] ^= tag[root], tag[root] = 0;\n}\nvoid insert(int &root, int val, int dep) {\n\tif (!root) root = ++idx;\n\tif (dep == -1) { sum[root] = 1; return; }\n\tpushdown(root, dep);\n\tif (val >> dep & 1) insert(rc[root], val, dep - 1);\n\telse insert(lc[root], val, dep - 1);\n\tsum[root] = sum[lc[root]] + sum[rc[root]];\n}\nint query_mex(int root, int dep) {\n\tif (!root) return 0;\n\tpushdown(root, dep);\n\tif (sum[lc[root]] >> dep)\n\t\treturn query_mex(rc[root], dep - 1) | 1 << dep;\n\telse\n\t\treturn query_mex(lc[root], dep - 1);\n}\nint merge(int x, int y, int dep) {\n\tif (dep == -1 || !x || !y) return x ?: y;\n\tpushdown(x, dep), pushdown(y, dep);\n\tlc[x] = merge(lc[x], lc[y], dep - 1);\n\trc[x] = merge(rc[x], rc[y], dep - 1);\n\tsum[x] = sum[lc[x]] + sum[rc[x]];\n\treturn x;\n}\nbool vis[N];\nint root[N], sg[N], f[N];\nvoid dfs(int x) {\n\tvis[x] = 1; int s = 0;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (!vis[e[i].to]) f[e[i].to] = x, dfs(e[i].to), s ^= sg[e[i].to];\n\tinsert(root[x], s, 16);\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (f[e[i].to] == x) {\n\t\t\ttag[root[e[i].to]] ^= s ^ sg[e[i].to];\n\t\t\troot[x] = merge(root[x], root[e[i].to], 16);\n\t\t}\n\tsg[x] = query_mex(root[x], 16);\n}\nvoid solve() {\n\tstd::cin >> n, idx = tot = 0; m = n - 1;\n\tfor (int i = 1; i <= n; ++i) head[i] = f[i] = vis[i] = root[i] = 0;\n\tfor (int i = 1; i <= m; ++i) std::cin >> x >> y, link(x, y);\n\tint s = 0;\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i), s ^= sg[i];\n\tfor (int i = 0; i <= idx; ++i) lc[i] = rc[i] = sum[i] = tag[i] = 0;\n\tstd::cout << (s ? \"Alice\" : \"Bob\") << '\\n';\n}\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\ttc = 1;\n\twhile (tc--) solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 1E5 + 100;\nvector<int> G[N];\n\nint go(int u, int fa) {\n    int ret = 0;\n    for (int v: G[u]) {\n        if (v == fa) continue;\n        ret ^= go(v, u) + 1;\n    }\n    return ret;\n}\n\nint main() {\n    int n; cin >> n;\n    FOR (i, 0, n - 1) {\n        int u, v; cin >> u >> v;\n        G[u].push_back(v); G[v].push_back(u);\n    }\n    puts(go(1, 0) ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=100005;\nint n;\nstd::vector<int> g[N];\nint dfs(int u,int fa){\n\tint k=0,sg=0;\n\tfor(int v:g[u])\n\t\tif(v!=fa)sg^=dfs(v,u),k++;\n\treturn sg+(k==1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y),g[y].push_back(x);\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,head[MN+5],cnt=0,f[MN+5],g[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int fa)\n{\n\tint num=0,num2=0,ok=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)\n\t\t{\n\t\t\tdfs(e[i].to,x);\n\t\t\tif(!f[e[i].to]) num^=1;\n\t\t\telse num2^=1,ok|=g[e[i].to];\n\t\t}\n\tf[x]=(num^num2)|(num&&num2&&ok);\n\tg[x]=(num^num2)|ok;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//code for hackerrank problem: deforestation\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 101010\nint n;\n\nvector <int> v[N];\nint f[N];\n\nvoid dfs(int r, int p) {\n  f[r] = 0;\n  for(int i = 0; i < (int)v[r].size(); i ++) {\n    if(p == v[r][i]) continue;\n    dfs(v[r][i], r);\n    f[r] ^= f[v[r][i]] + 1;\n  }\n}\n\nint main() {\n    int T = 1;\n    while(T --) {\n      scanf(\"%d\", &n);\n      for(int i = 1; i <= n; i ++) v[i].clear();\n      for(int i = 1; i < n; i ++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n      }\n      dfs(1, 0);\n      if(f[1]) puts(\"Alice\"); else puts(\"Bob\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nint N;\nvector<vector<int > > to;\nint dfs(int i,int from) {\n\tif (to[i].size() == 1) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tint ret = 0;\n\t\tfor (int j = 0; j < to[i].size(); j++) {\n\t\t\tif (to[i][j] != from) {\n\t\t\t\tret += dfs(to[i][j], i);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret % 2;\n\t\n}\nsigned main() {\n\tcin >> N;\n\tto.resize(N);\n\tint x, y;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tto[x].push_back(y);\n\t\tto[y].push_back(x);\n\t}\n\tint res;\n\tres = dfs(0,-1);\n\tif (res == 1) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll     = long long;\nusing pii    = pair<int, int>;\nusing pll    = pair<ll, ll>;\nusing vi     = vector<int>;\nusing vl     = vector<ll>;\nusing vvi    = vector<vi>;\nusing vvl    = vector<vl>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1000000007;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\ntemplate <class C>\nvoid print(const C &c, std::ostream &os = std::cout) {\n    std::copy(std::begin(c), std::end(c), std::ostream_iterator<typename C::value_type>(os, \" \"));\n    os << std::endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vvi edges(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n    vi grundy(n, -1);\n    function<int(int, int)> dfs = [&](int c, int p) {\n        int child = 0;\n        for (auto &v : edges[c]) {\n            if (v == p)\n                continue;\n            else\n                child ^= dfs(v, c);\n        }\n        return grundy[c] = child + 1;\n    };\n    dfs(0, -1);\n    int gs = 0;\n    for (auto &v : edges[0]) {\n        gs ^= grundy[v];\n    }\n    if (gs == 0)\n        cout << \"Bob\"\n             << \"\\n\";\n    else\n        cout << \"Alice\"\n             << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector <int> vec[100005];\nbool vis[100005];\nint sg[100005];\nvoid dfs(int x)\n{sg[x]=0;vis[x]=1;\nfor (int i=0;i<vec[x].size();i++)\n{if (!vis[vec[x][i]])\n{dfs(vec[x][i]);sg[x]^=(sg[vec[x][i]]+1);}\n}\n}\nint main (){\n\tint i,a,b;\n\tscanf (\"%d\",&n);\n\tfor (i=1;i<n;i++)\n\t{scanf (\"%d%d\",&a,&b);\n\tvec[a].push_back(b);\n\tvec[b].push_back(a);\n\t}\n\tdfs(1);\n\tif (sg[1]==0)\n\t{puts(\"Bob\");}\n\telse {puts(\"Alice\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#define For(i, a, b) for (int i = a; i < b; ++i)\n#define Out(i, a, b) for (int i = a - 1; i >= b; --i)\n#define pb push_back\n#define point pair <int, int>\n#define x first\n#define y second\n#define free free228\n#define files(FileName) read(FileName); write(FileName)\n#define read(FileName) freopen((FileName + \".in\").c_str(), \"r\", stdin)\n#define write(FileName) freopen((FileName + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n\nconst string FILENAME = \"input\";\ntypedef long long base;\nconst int MAXN = 2e5 + 1;\n\nint n;\nint f[MAXN];\nvector <int> edge[MAXN];\n\nint func(int i = 1, int p = -1) {\n\tint res = 0;\n\tfor (int j : edge[i]) {\n\t\tif (p == j) continue;\n\t\tres ^= func(j, i) + 1;\n\t}\n\treturn res;\n}\n\nint main(int argc, char const *argv[]) {\n    ios::sync_with_stdio(false);\n    //read(FILENAME);\n    cin >> n;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\tif (func() == 0) {\n\t\tcout << \"Bob\" << endl;\n\t} else {\n\t\tcout << \"Alice\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <ctime>\n#define LL long long\n#define Yes puts(\"YES\")\n#define No puts(\"NO\")\nusing namespace std;\nLL a,b,c,d;\nint n;\ninline LL read(){\n\tLL ret=0,p=1;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') p=-1;\n\tfor (;isdigit(ch);ch=getchar()) ret=ret*10+ch-'0';\n\treturn ret*p;\n}\nbool dfs(LL x,int t){\n\tif (t%2==n%2){\n\t\tif (x>b){\n\t\t\tif (x-b>=c && x-b<=d) return 1;\n\t\t}else{\n\t\t\tif (b-x>=c && b-x<=d) return 1;\n\t\t}\n\t}\n\tif (t>=n){\n\t\treturn 0;\n\t}\n\tif (dfs(x+(rand()%(d-c+1)+c),t+1)) return 1;\n\tif (dfs(x+(rand()%(d-c+1)+c),t+1)) return 1;\n\tif (dfs(x-(rand()%(d-c+1)+c),t+1)) return 1;\n\tif (dfs(x-(rand()%(d-c+1)+c),t+1)) return 1;\n\treturn 0;\n}\nint main(){\n\tsrand(time(0));\n\tn=read();\n\ta=read();b=read();c=read();d=read();\n\tif (a>b) a^=b^=a^=b;\n\tif (b-a>d*(n-2)){No;return 0;}\n\twhile (b-a-d>c*10) a+=d,n--;\n\twhile (b-a>c*10) a+=c,n--;\t\n\tn-=2;\n\tn=min(n,(n+1)%2+9);\n\tbool ans=0;\n\tfor (int i=0;i<30;i++){\n\t\tans=ans|dfs(a,0);\n\t\tif (ans==1) break;\n\t}\n\tif (ans==0) No;\n\telse Yes;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<cstdlib>\n#include<algorithm>\n#include<bitset>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<iomanip>\n#include<ctime>\n#include<complex>\n#include<functional>\n#include<climits>\n#include<cassert>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n \n \n \nint n;\n#define MAX 100002\n \nvector<int> v[MAX];\nint gr[MAX];\n \ninline void dfs(int b,int pr=-1) {\n\tif (v[b].size() == 1 && pr != -1) {\n\t\tgr[b] = 0;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < v[b].size(); i++) {\n\t\tint go = v[b][i];\n\t\tif (go != pr) {\n\t\t\tdfs(go,b);\n\t\t\tgr[b] ^= (gr[go] + 1);\n\t\t}\n\t}\n}\n \nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tif (gr[0]) {\n\t\tputs(\"Alice\");\n\t}\n\telse {\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define int long long\n#define P pair<int,int>\n#define all(vec) vec.begin(),vec.end()\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nint kai(int x, int y, int m) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y, int m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nint n;\nvector<int> vec[100010];\nint d[100010];\n\nvoid dfs(int v, int p) {\n\tif ((v == 1 && (int)vec[v].size() == 1) || (1 < v && (int)vec[v].size() == 2)) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tif (vec[v][i] == p)continue;\n\t\t\tdfs(vec[v][i], v);\n\t\t\td[v] = d[vec[v][i]] + 1;\n\t\t}\n\t}\n\telse {\n\t\tint k = 0;\n\t\tfor (int i = 0; i < (int)vec[v].size(); i++) {\n\t\t\tif (vec[v][i] == p)continue;\n\t\t\tdfs(vec[v][i], v);\n\t\t\tk ^= d[vec[v][i]];\n\t\t}\n\t\td[v] = k;\n\t}\n}\n\nsigned main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tif (d[1])cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=100010;\nint N;\nstruct edge{int to;edge*next;}E[MaxN*2],*ne=E,*fir[MaxN];\nvoid link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\nint dfs(int i,int f=0){\n\tint g=0;\n\tfor(edge*e=fir[i];e;e=e->next)\n\t\tif(e->to!=f)g^=dfs(e->to,i)+1;\n\treturn g;\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=1,u,v;i<N;i++)scanf(\"%d%d\",&u,&v),link(u,v),link(v,u);\n\tputs(dfs(1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n#define mat vector<vector<int>>\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\nconst db EPS = 1e-7;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nint N;\nvector<int> G[100010];\n\nint dfs(int v, int p){\n    int res = 0;\n    int son = 0;\n    for(auto u : G[v]){\n        if(u != p) res ^= dfs(u, v), son++; \n    }\n    return res + (son <= 1 ? 1 : 0);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    for(int i = 1; i < N; i++){\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n \n    }\n    cout << (dfs(1, 0) == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nll MOD = 1e9 + 7;\n\nvector<int> G[100000];\n\nint grundy[100000];\n\nint calc(int v, int p) {\n\tif (grundy[v] != -1) return grundy[v];\n\tint x = 0;\n\tfor (int to : G[v]) {\n\t\tif (to == p) continue;\n\t\tx ^= calc(to, v) + 1;\n\t}\n\treturn grundy[v] = x;\n}\n\nint main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tmemset(grundy, -1, sizeof(grundy));\n\tif (calc(0, -1) == 0) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nvector<int> graph[100010];\n\nvoid add_edge(int a,int b){\n\tgraph[a].push_back(b);\n\tgraph[b].push_back(a);\n}\n\n\nconst ll B = 10007LL;\nconst ll mod = 1000000007LL;\n\nll dfs(int v,int p){\n\tll ret = 0LL;\n\tvector<ll> hash;\n\t\n\tfor(auto &v2:graph[v]){\n\t\tif(v2==p) continue;\n\t\thash.push_back(dfs(v2,v));\n\t}\n\n\tfor(auto &e:hash) ret^=e;\n\t//cerr << v << \" \" << ret << endl;\n\tif(ret == 0 or hash.empty()) return 1LL;\n\treturn B*ret%mod;\n}\t\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n-1){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tadd_edge(x-1,y-1);\n\t}\n\n\tif(dfs(0,-1)!=1)\n\t\tputs(\"Alice\");\n\telse\n\t\tputs(\"Bob\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2e5 + 5;\n\nint other[MAXN + 5], last[MAXN + 5], pre[MAXN + 5];\nint dp[MAXN + 5];\nint N, all = -1;\n\nvoid build(int u, int v)\n{\n\tpre[++all] = last[u];\n\tlast[u] = all;\n\tother[all] = v;\n}\n\nint dfs(int ans, int fa)\n{\n\tint dt = last[ans], c = 0, sum = 0;\n\twhile(dt != -1){\n\t\tint dr = other[dt];\n\t\tif(dr != fa) c ^= dfs(dr, ans), sum++;\n\t\tdt = pre[dt];\n\t}\n\tif(sum == 0) return 0;\n\tif(fa == 1) return c;\n\treturn c ^ 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tmemset(last, -1, sizeof(last));\n\tfor(int i = 1; i < N; i++){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tbuild(u, v);\n\t\tbuild(v, u);\n\t}\n\tint check = dfs(1, 0) ^ 1;\n\tif(check) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 123456;\nVI edges[N];\n\n\nint dfs(int v, int par) {\n  int sum = 0;\n  REP(i, 0, edges[v].size()) {\n    int w = edges[v][i];\n    if (w == par) { continue; }\n    int res = dfs(w, v);\n    sum ^= res + 1;\n  }\n  return sum;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    edges[x].push_back(y);\n    edges[y].push_back(x);\n  }\n  cout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nconst int M = 1e5 + 10;\nvector<int>vc[M];\nint dp[M];\nint dfs(int u , int pre) {\n    int len = vc[u].size();\n    for(int i = 0 ; i < len ; i++) {\n        int v = vc[u][i];\n        if(v == pre) continue;\n        dp[u] ^= (dfs(v , u) + 1);\n    }\n    return dp[u];\n}\nint main() {\n    int n;\n    scanf(\"%d\" , &n);\n    for(int i = 1 ; i < n ; i++) {\n        int u , v;\n        scanf(\"%d%d\" , &u , &v);\n        vc[u].push_back(v);\n        vc[v].push_back(u);\n    }\n    memset(dp , 0 , sizeof(dp));\n    if(dfs(1 , -1)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint n;\nstd::vector<int> g[100005];\nint dfs(int u,int fa){\n\tint sg=0;\n\tfor(int v:g[u])if(v!=fa)sg^=dfs(v,u)+1;\n\treturn sg;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y),g[y].push_back(x);\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\nint visit[100005];\nvector<int> G[100005];\nint dfs(int now){\n    visit[now] = 1;\n    int res = 0;\n    for(int i=0;i<G[now].size();i++){\n        if(visit[G[now][i]]==-1) res ^= (dfs(G[now][i])+1);\n    }\n    return res;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    REP(i, N-1){\n        int x, y;\n        cin>>x>>y;x--;y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    memset(visit, -1, sizeof(visit));\n    cout << (dfs(0)!=0?\"Alice\":\"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nvector<int> G[100100];\n\nint dfs(int v, int p) {\n  int x = 0;\n  for (int u: G[v]) {\n    if (u == p) continue;\n    x ^= dfs(u, v);\n  }\n  return x + 1;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n;\n  cin >> n;\n  rep(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  cout << (dfs(0, -1) != 1 ? \"Alice\" : \"Bob\") << '\\n';\n\n  \n\n\n\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<bitset>\n#include<unordered_map>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i)=0;(i)<(n);(i)++)\n#define rep(i,j,n) for(ll (i)=(j);(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\nconst long long MOD = 1e9 + 7;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//グラフ関連\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\nll dp[1010][1010];\n\nll dfs(Graph& g, ll now, ll pre) {\n\tll ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (e.to != pre) {\n\t\t\tans ^= dfs(g, e.to, now) + 1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\n\tll n;\n\tcin >> n;\n\tGraph g(n);\n\n\tREP(i, n - 1) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tadd_edge(g, x, y, 1, true, 1);\n\t}\n\n\tif (dfs(g,0,-1) == 0) {\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse {\n\t\tcout << \"Alice\" << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"math.h\"\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\ntypedef long long int lli;\nvector<int> p[100005];\nint d[100005];\nvoid dfs(int dep, int cur, int par)\n{\n    d[cur] = dep;\n    for (auto to : p[cur]) {\n        if (to == par)\n            continue;\n        dfs(dep + 1, to, cur);\n    }\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int x, y;\n    rep(i, n - 1)\n    {\n        cin >> x >> y;\n        x--, y--;\n        p[x].push_back(y);\n        p[y].push_back(x);\n    }\n    dfs(0, 0, -1);\n    x = 0;\n    rep(i, n)\n    {\n        x ^= d[i];\n    }\n    if (x == 0) {\n        cout << \"Bob\" << endl;\n        return 0;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\n  typedef long long ll;\n  typedef pair<int,int> PII;\n  typedef pair<char,char> PCC;\n  typedef pair<ll,ll> PLL;\n  typedef pair<char,int> PCI;\n  typedef pair<int,char> PIC;\n  typedef pair<ll,int> PLI;\n  typedef pair<int,ll> PIL; \n  typedef pair<ll,char> PLC; \n  typedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\nconst int VMAX =1e5+10;\nvector<vector<int> >G(VMAX);\n\nPII dfs(int v, int p){\n  PII ret = PII(0,0);\n  for(const int & u : G[v]){\n    if(u == p)continue;\n    PII d =  dfs(u,v);\n    ret.first += d.first;\n    ret.second += d.second;\n  }\n  if(ret.first%2 == 0 && ret.second%2 == 0) return PII(0,1);\n  return PII(1,0);\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  int V;cin >> V;\n  rep(i,V-1){\n    int x,y;cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  PII d = dfs(1,-1);\n  if(d.first)cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<pii, int> ppiii;\n\nvector<int> edges[100005];\n\nint dfs(int curr, int par=-1) {\n  int ans = 0;\n  int sz = 0;\n  for(int out: edges[curr]) {\n    if(out == par) continue;\n    ans ^= dfs(out, curr)+1;\n  }\n  return ans;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  for(int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n  int ret = dfs(1);\n  if(ret != 0) cout << \"Alice\\n\";\n  else cout << \"Bob\\n\";\n}\n\nvoid casesolve() {\n  int t;\n  cin >> t;\n  for(int i = 1; i <= t; i++) {\n    cout << \"Case #\" << i << \": \";\n    solve();\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); cout.tie(NULL);\n  solve();\n  // casesolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int N = 1e5 + 10;\nvector<int> e[N];\n\nint dfs(int u, int p) {\n    int ans = 0;\n    for (int v : e[u]) {\n        if (v == p) continue;\n        ans ^= (1 + dfs(v, u));\n    }\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    forn(i, 1, n) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        e[u].eb(v);\n        e[v].eb(u);\n    }\n    int res = dfs(0, -1);\n    if (res) cout << \"Alice\\n\";\n    else cout << \"Bob\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=100005;\nint n,h[N],to[N+N],las[N+N],cnt,sg[N];\n\nvoid dfs(int x,int fa)\n{\n\tfor(int i=h[x];i;i=las[i])\n\t    if(to[i]!=fa)\n\t    \tdfs(to[i],x),sg[x]^=(sg[to[i]]+1);\n}\n\nint main()\n{\n\tfreopen(\"code.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tint i,u,v;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlas[++cnt]=h[u],h[u]=cnt,to[cnt]=v;\n\t\tlas[++cnt]=h[v],h[v]=cnt,to[cnt]=u;\n\t}\n\tdfs(1,-1);\n\tif(sg[1])printf(\"Alice\");\n\telse printf(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define int long long\n#define mp make_pair\n#define inf 1000000007\n#define ll long long\nusing namespace std;\nvector<int> adj[114514];\nint deg[114514],grundy[114514];\nsigned main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tqueue<int> que;\n\tfor(int i=2;i<=n;i++){\n\t\tif(deg[i]==1){\n\t\t\tque.push(i);\n\t\t\tgrundy[i] = 0;\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint id = que.front(); que.pop();\n\t\tfor(int i=0;i<adj[id].size();i++){\n\t\t\tif(deg[adj[id][i]]>1 || adj[id][i]==1){\n\t\t\t\tint id2 = adj[id][i];\n\t\t\t\tgrundy[id2] = grundy[id2]^(grundy[id]+1);\n\t\t\t\tdeg[id2]--;\n\t\t\t\tif(deg[id2]==1 && id2!=1)que.push(id2);\n\t\t\t}\n\t\t}\n\t}\n\tif(grundy[1]==0){\n\t\tcout<<\"Bob\"<<endl;\n\t}\n\telse{\n\t\tcout<<\"Alice\"<<endl;\n\t}\n\t/* for(int i=1;i<=n;i++){\n\t\tcout<<i<<\" \"<<grundy[i]<<endl;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long \n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n \n#define y1 what\n\nusing namespace std;\n \nconst int N = (int) 4e5 + 10;\nconst int M = (int) 1e6 + 10;\nconst ll LINF = (ll) 2e18;\nconst int INF = (int) 1e9 + 7;\nconst double EPS = (double) 1e-9;\nconst double PI =  3.14159265359;\n\nint n;\nvector<int> v[N];\nint sz[N];\n\nint dfs(int x, int p = -1) {\n    int ans = 0;\n    for (auto it : v[x]) {\n        if (it != p) {\n            ans ^= dfs(it, x) + 1;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    #define fn \"euler\"\n    #ifdef witch                                                            \n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n        //freopen(fn\".in\", \"r\", stdin);\n        //freopen(fn\".out\", \"w\", stdout);\n    #endif      \n    cin >> n;\n    for (int i = 1, x, y; i < n; i++) {\n        cin >> x >> y;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    if (dfs(1)) cout << \"Alice\";\n    else cout << \"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 200005\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\nusing namespace std;\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}\nint n,m,fa[N],sg[N],x,y;\nint nedge,Next[N*2],head[N],to[N*2];\nvoid add(int a,int b){\n\tNext[++nedge]=head[a];head[a]=nedge;to[nedge]=b;\n}\n#define V to[i]\nvoid dfs(int x){\n\tfor (int i=head[x];i;i=Next[i]){\n\t\tif (V!=fa[x]){\n\t\t\tfa[V]=x;\n\t\t\tdfs(V);\n\t\t\tsg[x]^=(sg[V]+1);\n\t\t}\n\t}\n}\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\tx=read();y=read();add(x,y);add(y,x);\n\t}\n\tdfs(1);\n\tif (sg[1]==0) puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    V<t2> xylist; llinl2(xylist, n-1);\n\n    V<ll> linklist[100005];\n    make_linklist(xylist, linklist);\n\n    S ll parent[100005];\n    S V<ll> children[100005];\n    S ll level[100005];\n    make_parental_relation(linklist, 1, n,\n                            parent, children, level);\n\n    S ll grundy[100005];\n    memset(grundy, 0, sizeof(grundy));\n\n    ll childcnt[100005];\n    rep (i, 100005) childcnt[i] = children[i].size();\n\n    S queue<ll> q;\n    srep (v, 1, n+1) if (!childcnt[v]) q.push(v);\n\n    while (!q.empty()) {\n        ll v = q.front(); q.pop();\n        ll pv = parent[v];\n        if (v == pv) continue;\n        ll g = grundy[v] + 1LL;\n        grundy[pv] ^= g;\n        childcnt[pv]--;\n        if (!childcnt[pv]) q.push(pv);\n    }\n\n    cout << ((grundy[1]) ? \"Alice\" : \"Bob\") << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dfs(vector<vector<int>> &v, int now, int par = -1){\n\tint r = 0;\n\tfor(auto n:v[now]) if(n != par){\n\t\tr ^= dfs(v, n, now) + 1;\n\t}\n\treturn r;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> v(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tv[x].emplace_back(y);\n\t\tv[y].emplace_back(x);\n\t}\n\tcout << (dfs(v, 0) ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int maxn = 1e5 +100;\nvector<int> G[maxn];\nint sg[maxn];\nvoid dfs(int x, int fa){\n    sg[x] = 0;\n    if(G[x].size() == 2){\n        for(auto to : G[x]) if(to != fa) dfs(to, x), sg[x] = sg[to] + 1;\n        return;\n    }\n    for(auto to : G[x]){\n        if(to == fa) continue;\n        dfs(to, x);\n        sg[x] ^= sg[to];\n    }\n}\n\nint main()\n{\n    int n, x, y;\n    cin>>n;\n    for(int i = 1; i < n; i++){\n        scanf(\"%d %d\", &x, &y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1, 1);\n    if(G[1].size() == 1) sg[1] = sg[G[1][0]] + 1;\n    else {\n        sg[1] = 0;\n        for(auto to : G[1]) sg[1] ^= sg[to];\n    }\n    if(sg[1]) cout<<\"Alice\";\n    else cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f,oo = inf;\n#define pi 3.14159265358979323846\n#define IL inline\n#define RG register\n#define rep(i,a,b) for(RG int i=(a);i<(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define Dep(i,a,b) for(RG int i=(a);i>=(b);--i)\n#define pc putchar\n/*char __wzp[1<<15|1],*__S=__wzp+32768;\n#define gc() (__S>=__wzp+32768?(__wzp[fread(__wzp,sizeof(char),1<<15,stdin)]=EOF),*((__S=__wzp)++):*(__S++))*/\n#define gc getchar\nIL ll read(){\n    RG ll x=0;char f=0;RG char c=gc();\n    for(;!isdigit(c);c=gc())f|=(c=='-');\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return f?-x:x;\n}\nIL double readdb(){\n    RG double x=0,p=0.1;RG char f=0,c=gc();\n    for(;!isdigit(c);c=gc())f|=(c=='-');\n    for(;isdigit(c);c=gc())x=x*10+(c^48);\n    if(c=='.')for(c=gc();isdigit(c);c=gc(),p/=10)x=x+(c^48)*p;\n    return f?-x:x;\n}\nIL void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);pc(x%10+'0');}\nIL void writeln(ll x){write(x);puts(\"\");}\nIL void writeln(ll x,char c,ll y){write(x);pc(c);writeln(y);}\nIL void writeln(ll x,char c,ll y,char d,ll z){write(x);pc(c);write(y);pc(d);writeln(z);}\n#define debug(x) printf(#x\" = %d\\n\",x);\n#define rd() read()\n#define rdb() readdb()\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define fin(x) freopen(#x\".in\",\"r\",stdin)\n#define fout(x) freopen(#x\".out\",\"w\",stdout)\n#define y1 ____y1\n#define hash __hash\n#define union _union\nconst int maxn = 100500;\nint sg[maxn],n,m;\nvector<int> edge[maxn];\nvoid dfs(int u,int fa){\n\tsg[u] = 0;\n\tfor(unsigned i=0;i<edge[u].size();++i){\n\t\tint v = edge[u][i];\n\t\tif(v ==fa) continue;\n\t\tdfs(v,u);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\nint main(){\n\tn = rd();\n\tRep(i,1,n) edge[i].clear();\n\trep(i,1,n){\n\t\tint a = rd(),b = rd();\n\t\tedge[a] . push_back(b);\n\t\tedge[b] . push_back(a);\n\t}\n\tdfs(1,0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\nusing namespace std;\ntypedef long long LL;\nint read()\n{\n    char c=getchar();int f=1,sum=0;\n    while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}\n    return sum*f;\n}\nint n;\nint head[maxn],to[maxn<<1],nex[maxn<<1],cnt;\nvoid add(int u,int v){to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;}\nint dfs(int x,int fa)\n{\n\tint sg=0;\n\tfor(int i=head[x];i;i=nex[i])\n\tif(to[i]!=fa) sg^=(dfs(to[i],x)+1);\n\treturn sg;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\tif(dfs(1,0)) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\nconst ll M = (ll)(1e10);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nvector<int> g[100100];\n\nint solve(int v, int p = -1){\n\tint i,u,ret=0;\n\tfor(i=(g[v].l_ength()-1); i>=0; --i){\n\t\tu = g[v][i];\n\t\tif(u==p){\n\t\t\tcontinue;\n\t\t}\n\t\tret ^= (solve(u,v)+1);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint n,i,x,y;\n\tcin >> n;\n\tfor(i=1; i<n; ++i){\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tcout << (solve(0)?\"Alice\":\"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n  \n  function<Int(Int, Int) > dfs=\n    [&](Int v,Int p)->Int{\n      Int cnt=0;\n      for(Int u:G[v])\n        if(u!=p) cnt++;\n\n      if(cnt==0) return 0;\n\n      if(cnt==1){\n        for(Int u:G[v])\n          if(u!=p) return dfs(u,v)+1;\n      }\n      \n      Int res=0;\n      for(Int u:G[v])\n        if(u!=p) res^=dfs(u,v)+1;\n      \n      return res;\n    };\n  \n  cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M=100005;\n\nint n;\nvector <int> g[M];\n\nint sg[M];\nint dfs(int x,int fa) {\n\tsg[x]=0;\n\t// int s=0;\n\tfor (int i=0;i<g[x].size();++i) {\n\t\tif (g[x][i]==fa) continue;\n\t\tdfs(g[x][i],x);\n\t\tsg[x]^=(sg[g[x][i]]+1);\n\t}\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i=1;i<n;++i) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tif (sg[1]==0) cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\nint dp[MAX];\n\ninline int dfs(int b,int pr=-1){\n\tdp[b] = 1;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tif (go == pr)continue;\n\t\tdfs(go,b);\n\t\tdp[b] += dp[go];\n\t}\n\treturn dp[b];\n}\n\nint main(){\n\tcin >> n;\n\tint non = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif (v[0].size() == 1){\n\t\tputs(\"Alice\");\n\t\treturn 0;\n\t}\n\tdfs(0);\n\tint one = 0;\n\tint ot = 0;\n\tfor (int i = 0; i < v[0].size(); i++){\n\t\tint go = v[0][i];\n\t\tint f = dp[go];\n\t\tif (f == 1){\n\t\t\tone++;\n\t\t}\n\t\telse{\n\t\t\tot++;\n\t\t}\n\t}\n\tif (ot == 0){\n\t\tif (one & 1){\n\t\t\tputs(\"Alice\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"Bob\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (n & 1){\n\t\tputs(\"Bob\");\n\t}\n\telse{\n\t\tputs(\"Alice\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SQR(x) ((x)*(x))\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\nint parent[100010];\nvector<int>nodes[100010];\n\nvoid maketree(int x){\n    for(auto v:nodes[x]){\n        if(v==parent[x])continue;\n        parent[v]=x;\n        maketree(v);\n    }\n}\n\nint getval(int x){\n    int ans=0;\n    for(auto v:nodes[x]){\n        if(v==parent[x])continue;\n        ans=ans^(getval(v)+1);\n    }\n    return ans;\n}\n\n\nint main() {\n   // freopen(\"hi.txt\",\"r\",stdin);\n    int n;\n    scanf(\"%d\",&n);\n    parent[1]=-1;\n    int a,b;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d%d\",&a,&b);\n        nodes[a].push_back(b);\n        nodes[b].push_back(a);\n    }\n    maketree(1);\n    if(getval(1)==0){\n        printf(\"Bob\");\n    }\n    else{\n        printf(\"Alice\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n//#include <regex>\n\n/* g++ -g -std=c++0x */\n/* g++ -g -std=c++11 */\n\nusing namespace std;\n\n// std::ios::sync_with_stdio(false);\n\n// freopen(\"input.txt\", \"rt\", stdin);\n// freopen(\"output.txt\", \"wt\", stdout);\n\n#define ALL(c)          (c).begin(), (c).end()\n#define ALLR(c)         (c).rbegin(), (c).rend()\n#define FOR(i,a,b)      for (int i=(a); i < (b); ++i)\n#define FORR(i,a,b)     for (int i=(a); i > (b); --i)\n#define FOR_ALL(i,c)    for (__typeof((c).begin()) i=(c).begin();   \\\n                             i != (c).end(); ++i)\n#define FOR_ALLR(i,c)   for (__typeof((c).rbegin()) i=(c).rbegin(); \\\n                             i != (c).rend(); ++i)\n#define SZ(array)       (sizeof(array)/sizeof(array[0]))\n#define lc(x)           (x<<1)     /* 2*x */\n#define rc(x)           (x<<1 | 1) /* 2*x+1 */\n#define lowbit(x)       (x & (-x)) /* 0b10100 -> 0b100 */\n\ntypedef long long       LL;\ntypedef map<int,int>    MII;\ntypedef pair<int,int>   PII;\ntypedef set<int>        SI;\ntypedef vector<bool>    VB;\ntypedef vector<double>  VD;\ntypedef vector<int>     VI;\ntypedef vector<string>  VS;\n\n/* check if a key is in container C */\ntemplate <class C>\ninline bool in_(const typename C::key_type& k, const C& A)\n{ return A.find(k) != A.end(); }\ninline bool in_(const string& s, const string& S)\n{ return S.find(s) != string::npos; }\n\n/*\n * Suppose that the root has k > 1 children. In this case, we can\n * decompose the original tree into k smaller trees, and the Grundy\n * Number of the original tree is XOR of the Grundy Numbers of new k\n * trees.\n *\n * If the root has exactly one child, we can compute the Grundy Number\n * using the following theorem:\n *\n * Theorem. Let G(T) be the Grundy Number of a rooted tree T. Let T' be\n * a rooted tree obtained by attaching an edge to the root of T (and the\n * new root is the new node attached to the old root). Then,\n * G(T') = G(T)+1.\n *\n * Proof. We can prove it by the induction on the number of vertices in\n * T. Let's compute the Grundy Number of T'.\n *\n * If we remove the new edge, we get a single node, and its Grundy\n * Number is zero.\n *\n * Suppose that we remove one of other edges, and we get a new tree S.\n * This tree is of the form\n * \"(one of trees reachable from T) + (one edge)\". By the induction\n * hypothesis, in the set of Grundy Numbers of these trees,\n * 0+1, 1+1, .. ,G(T)-1+1 will appear, but G(T)+1 won't.\n * Therefore, G(T') = G(T) + 1.\n */\n\nconst int maxv = 1e5+5;\nint vis[maxv];\nVI G[maxv];\n\nint dfs(const int u)\n{\n    vis[u]++;\n    int cnt = 0;\n    FOR_ALL(v,G[u]) if (!vis[*v])\n        cnt++;\n    if (cnt == 0)\n        return 0;\n    int ans = 0;\n    FOR_ALL(v,G[u]) if (!vis[*v]) {\n        if (cnt == 1)\n            ans = 1+dfs(*v);\n        else\n            ans ^= dfs(*v);\n    }\n    return ans;\n}\n\nint main()\n{\n/* #ifndef ONLINE_JUDGE */\n/*     freopen(\"foo\", \"rt\", stdin); */\n/* #endif */\n    int N;\n    while (cin >> N) {\n        FOR(i,0,N+1)\n            G[i].clear();\n        FOR(_,1,N) {\n            int x,y; cin >> x >> y;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        memset(vis,0,sizeof(vis));\n        const int x = dfs(1);\n        const string ans = x ? \"Alice\" : \"Bob\";\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n;\nvi g[N];\nbool vis[N];\n\null dfs(int x){\n\tvis[x]=1;\n\tint ans=0;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tans^=dfs(y)+1;\n\t}\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tif(dfs(1)) puts(\"Alice\"); else puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid dfs(int v,vector<vector<int>> &edge,vector<int> &grundy,vector<int> &used){\n    used[v]=true;\n    for(int i=0;i<edge[v].size();i++){\n        int to=edge[v][i];\n        if(used[to]){\n            continue;\n        }\n        grundy[to]=grundy[v]+1;\n        dfs(to,edge,grundy,used);\n    }\n    return;\n}\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> edge(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    vector<int> used(n);\n    vector<int> grundy(n);\n    grundy[0]=0;\n    vector<int> gs;\n    dfs(0,edge,grundy,used);\n    /*\n    for(int i=0;i<edge.size();i++){\n        for(int j=0;j<edge[i].size();j++){\n            if(i<edge[i][j]) continue;\n            gs.push_back(min(grundy[i],grundy[edge[i][j]]));\n        }\n    }\n    */\n    int res=0;\n    for(int i=0;i<grundy.size();i++){\n        res^=grundy[i];\n\n    }\n    cout<<(res?\"Alice\" :\"Bob\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n     \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n     \nusing namespace std;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int MOD = (int)1e9 + 9;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nvector<int> g[N];\nint dp[N];\n\nvoid dfs(int u, int par)\n{\n    dp[u] = 0;\n    for (int v : g[u])\n        if (v != par)\n        {\n            dfs(v, u);\n            dp[u] ^= (dp[v] + 1);\n        }\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    rep(i, 0, n - 1)\n    {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    cout << (dp[0] > 0 ? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 1e5 + 5;\n\nint N;\nvector<int> G[MAXN];\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i < N; ++i) {\n        int u, v;\n        read(u); read(v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n}\n\nint calc(int u, int f)\n{\n    int ret = 0;\n    for (int i = 0; i < SZ(G[u]); ++i) {\n        int v = G[u][i];\n        if (v == f)\n            continue;\n        ret ^= calc(v, u) + 1;\n    }\n    return ret;\n}\n\nvoid solve()\n{\n    puts(calc(1, 0) ? \"Alice\" : \"Bob\");\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"D.in\", \"r\", stdin);\n    freopen(\"D.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 宁可枝头抱香死，何曾吹落北风中。\n//     -- 郑思肖《画菊》\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <math.h>\n#include <memory>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nusing ll = int64_t;\nusing ull = uint64_t;\nconstexpr ll LL_MAX = numeric_limits<ll>::max();\nconstexpr ull ULL_MAX = numeric_limits<ull>::max();\n\ntemplate<typename T>\nvector<T> make_vec_nd(T init, ll size) {\n\treturn vector<T>(size, init);\n}\ntemplate<typename T, typename... Args>\nauto make_vec_nd(T init, ll size, Args... rest) {\n\tauto inner = make_vec_nd(init, rest...);\n\treturn vector<decltype(inner)>(size, inner);\n}\n\n#define rep(i, a, b) for (ll i = (a); i < (b); i++)\n#define rrep(i, a, b) for (ll i = (a)-1; i >= (b); i--)\n\nvoid calc_grundy(ll now, vector<vector<ll>>& graph, vector<ll>& grundy, vector<bool>& visited) {\n    visited[now] = true;\n    ll g = 0;\n    for (ll to : graph[now]) {\n        if (visited[to]) {\n            continue;\n        }\n        calc_grundy(to, graph, grundy, visited);\n        g = g ^ (grundy[to] + 1);\n    }\n    grundy[now] = g;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    vector<vector<ll>> graph(N);\n    rep(i,0,N-1) {\n        ll x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    vector<bool> visited(N);\n    vector<ll> grundy(N);\n    calc_grundy(0, graph, grundy, visited);\n    if (grundy[0] == 0) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define gec     getchar\n#define FILE(F) freopen(F\".in\",\"r\",stdin),freopen(F\".out\",\"w\",stdout)\n\ntypedef long long ll;\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;bool f=0; char c=gec();\n\tfor(;c<'0'||c>'9';c=gec())f=(c=='-');\n\tfor(;c>='0'&&c<='9';c=gec())x=x*10+c-'0';\n\tx=f?-x:x;\n}\nnamespace IO\n{\ninline void fpr(char *c){fprintf(stderr,\"%s\\n\",c);}\ninline void fpr(int           x,char *c){fprintf(stderr,\"[ %s ] : = %d   \\n\",c,x);}\ninline void fpr(ll            x,char *c){fprintf(stderr,\"[ %s ] : = %lld \\n\",c,x);}\ninline void fpr(double        x,char *c){fprintf(stderr,\"[ %s ] : = %.5lf\\n\",c,x);}\ninline void fpr(long double   x,char *c){fprintf(stderr,\"[ %s ] : = %.5Lf\\n\",c,x);} \n}using namespace IO;\n\nconst int MAXN(100010);\nint n;\nstruct Node\n{\n\tint nd,nx;\n}bot[MAXN<<1];int tot,first[MAXN],val[MAXN];\nvoid add(int a,int b)\n{bot[++tot]=(Node){b,first[a]};first[a]=tot;\n bot[++tot]=(Node){a,first[b]};first[b]=tot;}\n\nvoid DFS(int x,int f)\n{\n\tfor(int y,v=first[x];v;v=bot[v].nx)\n\tif((y=bot[v].nd)!=f)\n\t{\n\t\tDFS(y,x);\n\t\tval[x]^=val[y]+1;\n\t}\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1,a,b;i<n;i++)\n\t{\n\t\tread(a);read(b);\n\t\tadd(a,b);\n\t}\n\tDFS(1,0);\n\tputs(val[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool seen[100010];\nvector<int> adj[100010];\nint n;\nint dfs(int a)\n{\n\tseen[a] = 1;\n\tint winner = 0;\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!seen[b]) winner ^= (dfs(b)+1);\n\t}\n\treturn winner;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tint res = dfs(1);\n\tif (res) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nvector<int> g[101010];\nbool used[101010];\nint oddcnt;\nint cnt[101010];\n\n\nvoid dfs(int s) {\n        used[s] = true;\n        if (cnt[s] & 1) { \n                oddcnt ++;\n                return;\n        }\n        for (auto t : g[s]) if (!used[t]) {\n                dfs(t);\n        }\n        return;\n}\n\nint main() {\n        int n;\n        cin >> n;\n        rep(i, n - 1) {\n                int x, y;\n                cin >> x >> y;\n                x --, y --;\n                cnt[x] ++;\n                cnt[y] ++;\n                g[x].push_back(y);\n                g[y].push_back(x);\n        }\n        for (int i = 1; i < n; i ++) cnt[i] --;\n        dfs(0); \n        cout << (oddcnt & 1 ? \"Alice\" : \"Bob\") << endl;\n        return 0;                              \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<1];\nint tot, head[N];\nvoid _add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot; }\nvoid add(int x, int y) { _add(x, y), _add(y, x); } \nint n;\nint dp(int x, int fa)\n{\n    int ret = 0;\n    for(int i = head[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa) continue;\n        ret ^= dp(y, x)+1;\n    }\n    return ret;\n}\nint main()\n{\n    n = read();\n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(x, y);\n    }\n    puts(dp(1, 0)?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n, a, b; vector<int>x[125000]; bool used[125000]; int F[125000];\nint dfs(int pos) {\n\tif (used[pos] == true) {\n\t\treturn -1;\n\t}\n\tused[pos] = true;\n\tvector<int>R(x[pos].size() + 1, 0);\n\tfor (int i = 0; i < x[pos].size(); i++) {\n\t\tint T = dfs(x[pos][i]);\n\t\tif (T >= 0 && T < R.size())R[T] = 1;\n\t}\n\tfor (int i = 0; i < R.size(); i++) { if (R[i] == 0) { F[pos] = i; return i; } }\n\treturn -1;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b;\n\t\tx[a].push_back(b);\n\t\tx[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++)F[i] = -1;\n\tdfs(1); int U = 0;\n\tfor (int i = 0; i < x[1].size(); i++)U ^= F[x[1][i]];\n\tif (U == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n     \n    using namespace std;\n     \n    const int N = 1234567;\n     \n    vector <int> g[N];\n     \n    int dfs(int v, int pr) {\n      int x = 0;\n      for (int u : g[v]) {\n        if (u == pr) {\n          continue;\n        }\n        x ^= dfs(u, v);\n      }\n      return x + 1;\n    }\n     \n    int main() {\n      int n;\n      scanf(\"%d\", &n);\n      for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n      }\n      printf(\"%s\\n\", dfs(0, -1) == 1 ? \"Bob\" : \"Alice\");\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<time.h>\n#include<map>\n#include<queue>\n#include<set>\n#define ji -\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define fe(x) for(int i=be[x];i;i=e[i].ne)\nusing namespace std;\nint n,xx,yy,et,be[120000],f[120000];\nstruct edg{\n\tint y,ne;\n};\nedg e[210000];\ninline void add_edge(int x,int y){\n\te[++et].y=y;\n\te[et].ne=be[x];\n\tbe[x]=et;\n}\nvoid dfs(int x,int fa){\n\tfe(x){\n\t\tint &y=e[i].y;\n\t\tif (y!=fa){\n\t\t\tdfs(y,x);\n\t\t\tf[x]^=f[y];\n\t\t}\n\t}\n\tf[x]++;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,2,n){\n\t\tscanf(\"%d%d\",&xx,&yy);\n\t\tadd_edge(xx,yy);\n\t\tadd_edge(yy,xx);\n\t}\n\tdfs(1,-1);\n\tif (f[1]>1) printf(\"Alice\\n\");else printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,K,Q,A,B;\nstring S, T;\n//const ll MOD = 998244353;\nconst ll MOD = (1e+9) + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<ll,ll> P;\n\nmat G(100010, vec(0));\nvector<bool> used(100010, false);\nll dfs(ll v){\n    used[v] = true;\n    ll res = 0;\n    for(ll to : G[v]){\n        if(!used[to]){\n            res = res ^ (dfs(to) + 1);\n        }\n    }\n    return res;\n}\nint main(){\n    cin>>N;\n    rep(i,N-1){\n        cin>>A>>B;\n        --A, --B;\n        G[A].push_back(B);\n        G[B].push_back(A);\n    }\n    ll ans = dfs(0);\n    cout<<(ans == 0 ? \"Bob\" : \"Alice\")<<endl;\n    //cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> adia[100010];\n\nint calc(int nod, int tata)\n{\n    int ans = 0;\n    vector <int> fii;\n    for (auto i : adia[nod]) {\n        if (i == tata)\n            continue;\n        int x = calc(i, nod);\n        ans ^= (x + 1);\n    }\n\n    return ans;\n/*\n    if (fii.size() == 0)\n        return 0;\n    sort(fii.begin(), fii.end());\n\n    int mex = 0;\n    for (auto i : fii) {\n        if (i == mex)\n            mex++;\n        else if (i > mex)\n            return mex;\n    }\n    return mex;*/\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    cout << (calc(1, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp>\n//namespace mp = boost::multiprecision;\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\ndouble equal(double a, double b) {\n    return fabs(a - b) < DBL_EPSILON;\n}\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    int a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n//const ll mod = 1e10;\n\ntypedef priority_queue<ll, vector<ll>, greater<ll> > PQ_ASK;\n\n\nint dfs(vector<vector<int>> &edges, int now, int prev) {\n    int grd = 0;\n    for (int next : edges[now]) {\n        if (next == prev) continue;\n        grd ^= dfs(edges, next, now);\n    }\n    grd++;\n    return grd;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n\n    vector<vector<int>> edges(n);\n    rep(i, n - 1) {\n        int x, y;\n        cin >> x >> y;\n\n        x--;\n        y--;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n\n    int res = dfs(edges, 0, -1);\n    res--;\n    cout << (res == 0 ? \"Bob\" : \"Alice\") << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing LD = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<LD>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr LD PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate<class T>static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()));\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear(); char c; for (i(c); !isspace(c); c = gc())v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')adp = true;\n\t\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\t\telse v = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1; bool neg = false, adp = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')adp = true;\n\t\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\t\telse v = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg)v = -v;\n\t}\n\ttemplate<class T, class U>static void i(pair<T, U>& v) {\n\t\ti(v.first); i(v.second);\n\t}\n\ttemplate<class T>static void i(vector<T>& v) {\n\t\tfor (auto& e : v)i(e);\n\t}\n\tstruct InputV {\n\t\tint n, id;\n\t\tInputV(int _n) :n(_n), id(0) {}\n\t\tInputV(const pair<int, int>& nm) :n(nm.first), id(nm.second) {}\n\t\ttemplate<class T>operator vector<T>() {\n\t\t\tvector<T> v(n); i(v); return v;\n\t\t}\n\t\ttemplate<class T>operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(id)); i(v); return v;\n\t\t}\n\t};\npublic:\n\tstatic string get_line() {\n\t\tstring v; char c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc())v += c;\n\t\treturn v;\n\t}\n\ttemplate<class T>static T in() {\n\t\tT v; i(v); return v;\n\t}\n\ttemplate<class T>operator T()const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int)const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n)const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n)const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()()const {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t)const {\n\t\ti(h); operator()(forward<T>(t)...);\n\t}\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(ll)\n#define STR input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(ll, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v)const {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(long long v)const {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v)const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v)const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v)const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v)const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v)const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate<class T> void p(const T& v)const {\n\t\tcout << v;\n\t}\n\ttemplate<class T, class U>void p(const pair<T, U>& v)const {\n\t\tp(v.first); p(D.d); p(v.second);\n\t}\n\ttemplate<class T>void p(const vector<T>& v)const {\n\t\trep(i, sz(v)) { if (i)p(D.d); p(v[i]); }\n\t}\n\ttemplate<class T>void p(const vector<vector<T>>& v)const {\n\t\trep(i, sz(v)) { if (i)p(D.l); p(v[i]); }\n\t}\npublic:\n\tOutput& operator()() {\n\t\tp(D.l); return *this;\n\t}\n\ttemplate<class H>Output& operator()(H&& h) {\n\t\tp(h); p(D.l); return *this;\n\t}\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class It>Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) { if (i != l)p(D.d); p(*i); } p(D.l); return *this;\n\t}\n\ttemplate<class T>Output& range(const T& a) {\n\t\trange(a.begin(), a.end()); return *this;\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout); return *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b; return *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d; return *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f); return *this;\n\t}\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b; a += c; return *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this; --b; a += c; return tmp;\n\t\t}\n\t\tconstexpr const T& operator*()const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->()const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i)const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i)const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start()const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T count()const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step()const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const {\n\t\treturn be;\n\t}\n\tconstexpr It end()const {\n\t\treturn en;\n\t}\n\tconstexpr T start()const {\n\t\treturn be.start();\n\t}\n\tconstexpr T count()const {\n\t\treturn be.count();\n\t}\n\tconstexpr T step()const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum()const {\n\t\treturn start() * count() + step() * (count() * (count() - 1) / 2);\n\t}\n\toperator vector<T>()const {\n\t\treturn as_vector();\n\t}\n\ttemplate<class F>void each(const F& f)const {\n\t\tfor (T i : *this)f(i);\n\t}\n\tauto as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto map(const F& f)const {\n\t\tvector<U> res; res.reserve(count()); each([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>auto select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {if (f(i))++res; }); return res;\n\t}\n\ttemplate<class F>T find_if(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return i; return 0;\n\t}\n\ttemplate<class F>auto max_by(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min_by(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>bool all_of(const F& f)const {\n\t\tfor (T i : *this)if (!f(i))return false; return true;\n\t}\n\ttemplate<class F>bool any_of(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return true; return false;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate<class T>inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate<class T>inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) {\n\t\tsort(all(a));\n\t}\n\ttemplate<class T>inline void RSort(T& a) {\n\t\tsort(rall(a));\n\t}\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), f);\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), f);\n\t}\n\ttemplate<class T>inline T Sorted(T a) {\n\t\tSort(a); return a;\n\t}\n\ttemplate<class T>inline T RSorted(T a) {\n\t\tRSort(a); return a;\n\t}\n\ttemplate<class T, class F>inline T Sorted(T& a, const F& f) {\n\t\tSort(a, f); return a;\n\t}\n\ttemplate<class T, class F>inline T RSorted(T& a, const F& f) {\n\t\tRSort(a, f); return a;\n\t}\n\ttemplate<class T, class F>inline void SortBy(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSortBy(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) {\n\t\treverse(all(a));\n\t}\n\ttemplate<class T>inline void Unique(T& a) {\n\t\ta.erase(unique(all(a)), a.end());\n\t}\n\ttemplate<class T>inline void Uniq(T& a) {\n\t\tSort(a); Unique(a);\n\t}\n\ttemplate<class T>inline void Rotate(T& a, int left) {\n\t\trotate(a.begin(), a.begin() + left, a.end());\n\t}\n\ttemplate<class T>inline T Reversed(T a) {\n\t\tReverse(a); return a;\n\t}\n\ttemplate<class T>inline T Uniqued(T a) {\n\t\tUnique(a); return a;\n\t}\n\ttemplate<class T>inline T Uniqed(T a) {\n\t\tUniq(a); return a;\n\t}\n\ttemplate<class T>inline T Rotated(T a, int left) {\n\t\tRotate(a, left); return a;\n\t}\n\ttemplate<class T>inline auto Max(const T& a) {\n\t\treturn *max_element(all(a));\n\t}\n\ttemplate<class T>inline auto Min(const T& a) {\n\t\treturn *min_element(all(a));\n\t}\n\ttemplate<class T>inline int MaxPos(const T& a) {\n\t\treturn max_element(all(a)) - a.begin();\n\t}\n\ttemplate<class T>inline int MinPos(const T& a) {\n\t\treturn min_element(all(a)) - a.begin();\n\t}\n\ttemplate<class T, class F>inline auto MaxBy(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto MinBy(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) {\n\t\treturn count(all(a), v);\n\t}\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) {\n\t\treturn count_if(all(a), f);\n\t}\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) {\n\t\treturn find(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) {\n\t\treturn find_if(all(a), f) - a.begin();\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) {\n\t\treturn accumulate(all(a), U());\n\t}\n\ttemplate<class T, class U>inline bool Includes(const T& a, const U& v) {\n\t\treturn find(all(a), v) != a.end();\n\t}\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(*v.begin()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) {\n\t\ta.erase(remove_if(all(a), f), a.end());\n\t}\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size);\n\t\tfor (size_t i = 0; i < size; ++i)res[i] = f(i);\n\t\treturn res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) {\n\t\treturn vector<vector<T>>(h, vector<T>(w, v));\n\t}\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(T& v, F&& f) {\n\t\tfor (auto& i : v)f(i);\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, F&& f) {\n\t\tfor (const auto& i : v)f(i);\n\t}\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res;\n\t\tfor (const auto& e : v)if (f(e))res.push_back(e);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, F&& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res;\n\t\tfor (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i);\n\t\treturn res;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline auto Indexed(const T& v) {\n\t\tvector<pair<U, int>> res(v.size());\n\t\tfor (int i = 0; i < (int)v.size(); ++i)res[i] = make_pair(static_cast<U>(v[i]), i);\n\t\treturn res;\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i)res += s;\n\t\treturn res;\n\t}\n\ttemplate<class T>inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2)); return v;\n\t}\n\ttemplate<class T>inline T Ceil(T n, T id) {\n\t\treturn (n + id - 1) / id;\n\t}\n\ttemplate<class T>inline T Ceil2(T n, T id) {\n\t\treturn Ceil(n, id) * id;\n\t}\n\ttemplate<class T>inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate<class T>inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate<class T>inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\tinline int pop_count(int n) {\n\t\treturn bitset<32>(n).count();\n\t}\n\tinline int pop_count(ll n) {\n\t\treturn bitset<64>(n).count();\n\t}\n\ttemplate<class T>inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) { a = b; return true; } return false;\n\t}\n\ttemplate<class T>inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) { a = b; return true; } return false;\n\t}\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate<class T>inline bool isSquere(T n) {\n\t\tT s = sqrt(n); return s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate<class T = ll>inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate<class T>inline T Gcd(T n, T id) {\n\t\treturn id ? Gcd(id, n % id) : n;\n\t}\n\ttemplate<class T>inline T Lcm(T n, T id) {\n\t\treturn n / Gcd(n, id) * id;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r;\n\t}\n\ttemplate<class T>inline T Powmod(T a, T n, T id = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % id, n--; else a = a * a % id, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint n = in;\n\tVVI g(n);\n\trep(i, n - 1) {\n\t\tint x = in--, y = in--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tauto rec = [&](auto&& f, int v, int p) {\n\t\tint size = g[v].size() - (p != -1);\n\t\tif (size == 0) {\n\t\t\treturn 0;\n\t\t} else if (size == 1) {\n\t\t\tint res = -1;\n\t\t\tfor (auto e : g[v])if (e != p) {\n\t\t\t\tres = f(f, e, v);\n\t\t\t}\n\t\t\tdump(v, res + 1);\n\t\t\treturn res + 1;\n\t\t} else {\n\t\t\tint res = 0;\n\t\t\tfor (auto e : g[v])if (e != p) {\n\t\t\t\tres ^= f(f, e, v);\n\t\t\t}\n\t\t\tdump(v, res);\n\t\t\treturn res;\n\t\t}\n\t};\n\n\tint ans = rec(rec, 0, -1);\n\tout.set(\"Alice\", \"Bob\")(ans != 0);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n//#define PROBLEM \"problem_name.h\"\n//#include PROBLEM\n//#include <message.h>\n//#include <spcppl/dgcj.h>\n\nusing namespace std;\n\nclass TaskD {\npublic:\n\tvector<vector<int>> g;\n\tint dfs(int v, int p) {\n\t\tint res = 0;\n\t\tfor (int to: g[v]) {\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres ^= (dfs(to, v) + 1);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n;\n\t\tin >> n;\n\t\tg.resize(n);\n\t\tfor (int i: range(n - 1)) {\n\t\t\tint a, b;\n\t\t\tin >> a >> b;\n\t\t\t--a, --b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\n\t\tout << (dfs(0, 0) == 0 ? \"Bob\" : \"Alice\") << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nint depth[100005];\nvoid dfs(int current, int parent)\n{\n    int i,l,x;\n    l = v[current].size();\n    depth[current] = depth[parent] + 1;\n    for(i=0;i<l;i++)\n    {\n        x = v[current][i];\n        if(x!=parent)\n            dfs(x,current);\n    }\n    \n}\nint main()\n{\n    int n,i,x,y;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    depth[0] = -1;\n    dfs(1,0);\n    int ans = 0;\n    for(i=1;i<=n;i++)ans ^= depth[i];\n    if(ans)printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\nstatic const int MAXN = 100005;\n\nint n;\nstd::vector<int> e[MAXN];\n\nint f[MAXN];\n\nvoid dfs(int u, int p = -1)\n{\n    f[u] = 0;\n    for (int v : e[u]) if (v != p) {\n        dfs(v, u);\n        f[u] ^= (f[v] + 1);\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0, u, v; i < n - 1; ++i) {\n        scanf(\"%d%d\", &u, &v); --u, --v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs(0);\n    puts(f[0] == 0 ? \"Bob\" : \"Alice\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\nusing namespace std;\ntypedef long long LL;\nconst int N=1000010;\ntemplate<typename T>inline T chkmax(T A,T B){return A>B?A:B;}\ntemplate<typename T>inline T chkmin(T A,T B){return A<B?A:B;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n;\nint bgn[N],nxt[N<<1],to[N<<1],E,SG[N];\ninline void add_edge(int x,int y)\n{\n\tnxt[++E]=bgn[x],bgn[x]=E,to[E]=y;\n}\ninline void dfs(int u,int f)\n{\n\tSG[u]=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tSG[u]^=SG[v]+1;\n\t}\n}\nint main()\n{\n\tint x,y;\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y);add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tif(SG[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, dp[100009];\nvector < int > v[100009];\n\nvoid dfs (int nod, int tata)\n{\n    for (auto it : v[nod])\n        if (it != tata)\n            dfs (it, nod), dp[nod] ^= (dp[it] + 1);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y);\n    v[x].push_back (y);\n    v[y].push_back (x);\n}\ndfs (1, -1);\nif (dp[1]) printf (\"Alice\\n\");\nelse printf (\"Bob\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>bool chmin(T&a,const T&b){return a>b?(a=b,1):0;}\ntemplate<class T>bool chmax(T&a,const T&b){return a<b?(a=b,1):0;}\n \n \nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n \nconst int MAX_N = 100000;\nvector<int> g[MAX_N];\n \nint f(int v, int prev) {\n  int x = 0;\n  for (int u : g[v]) if (u != prev) {\n    x ^= f(u, v);\n  }\n  x += 1;\n  // cout << v << \" \" << x << endl;\n  return x;\n}\n \nint main2() {\n  int N = nextInt();\n  REP(i, N) g[i].clear();\n  REP(_, N-1) {\n    int x = nextInt() - 1;\n    int y = nextInt() - 1;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int nim = f(0, -1) - 1;\n  if (nim == 0) cout << \"Bob\" << endl; \n  else cout << \"Alice\" << endl;\n  return 0;\n}\n \nint main() {\n  for (;!cin.eof();cin>>ws) main2();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  \n#include <cstring>  \n#include <iostream>  \n#include <algorithm>  \n#define N 101000  \nusing namespace std;  \nstruct KSD  \n{  \n    int v,next;  \n}e[N<<1];  \nint head[N],cnt;  \ninline void add(int u,int v)  \n{  \n    e[++cnt].v=v;  \n    e[cnt].next=head[u];  \n    head[u]=cnt;  \n}  \nint n;  \nint sg[N];  \nvoid dfs(int x,int p)  \n{  \n    int i,v;  \n    sg[x]=0;  \n    for(i=head[x];i;i=e[i].next)  \n    {  \n        v=e[i].v;  \n        if(v==p)continue;  \n        dfs(v,x);  \n        sg[x]^=(sg[v]+1);  \n    }  \n}  \nint main()  \n{  \n    int i,j,T;  \n    int a,b;  \n \n    \n        cnt=1;  \n        memset(head,0,sizeof(head));  \n        scanf(\"%d\",&n);  \n        for(i=1;i<n;i++)  \n        {  \n            scanf(\"%d%d\",&a,&b);  \n            add(a,b),add(b,a);  \n        }  \n        dfs(1,0);  \n        if(sg[1])puts(\"Alice\");  \n        else puts(\"Bob\");  \n    \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n#define rp(i,t) for(int i=0;i<(t);i++)\n#define rep(i,s,t) for(int i=(s);i<=(t);i++)\n#define rsp(i,s,t) for(int i=(s);i<(t);i++)\n#define rrp(i,t,s) for(int i=(t);i>=(s);i--)\n#define rcp(i,s,b,d) for(int i=(s);b;d)\n#define rgp(i,x) for(int i=h[x];i;i=e[i].t)\n#define mst(a,x) memset(a,x,sizeof(a))\n#define INF 0x3f3f3f3f\n#define N 100002\n#define E 200002\n\n#define Dp puts(\"\")\n#define Dw printf\n#define Ds printf(\"#\")\n\ntypedef long long ll;\nstruct Edge{int y,t;}e[E];\nchar ch;\nint n,x,y,h[N],ep,d[N],c[N];\n\ninline void read(int &x){x=0;do{ch=getchar();}while(ch<'0'||'9'<ch);do{x=x*10+ch-'0';ch=getchar();}while('0'<=ch&&ch<='9');}\ninline void addedge(const int &x,const int &y){e[++ep].y=y;e[ep].t=h[x];h[x]=ep;}\n\nvoid dfs(const int &x,const int &l)\n{\n\tc[d[x]=d[l]+1]++;\n\trgp(i,x)if(e[i].y!=l)dfs(e[i].y,x);\n}\n\nint main(void)\n{\n\tread(n);\n\trsp(i,1,n)read(x),read(y),addedge(x,y),addedge(y,x);\n\tdfs(1,0);\n\trep(i,2,n)if(c[i]&1)\n\t{\n\t\tprintf(\"Alice\");\n\t\treturn 0;\n\t}\n\tprintf(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sg;\nvector<int>v[100010];\nint f[100001];\n\nint dfs(int n,int fa)\n{\n    sg=0;\n    for(int i=0;i<v[n].size();i++)\n    {\n        if(v[n][i]!=fa)\n        {\n            return sg^=dfs(v[n][i],n);\n        }\n        return sg+1;\n    }\n}\n\nint main()\n{\n    int n,a,b,ans;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    if(dfs(1,0)==1) printf(\"Alice\");\n    else printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>\nvoid read(T &x)\n{\n    char ch=getchar();\n    int f=1;\n    for (x=0;ch!='-'&&(ch<'0'||ch>'9');ch=getchar());\n    if (ch=='-') f=-1,ch=getchar();\n    for (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n    x*=f;\n}\n#define MAXN 100010\nstruct edge{\n\tint s,t,next;\n}e[MAXN<<1];\nint head[MAXN],cnt;\nvoid addedge(int s,int t)\n{\n\te[cnt].s=s;e[cnt].t=t;e[cnt].next=head[s];head[s]=cnt++;\n\te[cnt].s=t;e[cnt].t=s;e[cnt].next=head[t];head[t]=cnt++;\n}\nint n,u,v;\nint sg[MAXN];\nvoid dfs(int node,int lastfa)\n{\n\tsg[node]=0;\n\tfor (int i=head[node];i!=-1;i=e[i].next)\n\t\tif (e[i].t!=lastfa)\n\t\t{\n\t\t\tdfs(e[i].t,node);\n\t\t\tsg[node]^=(sg[e[i].t]+1);\n\t\t}\n}\nint main()\n{\n\tread(n);\n\tmemset(head,0xff,sizeof(head));\n\tcnt=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tread(u),read(v);\n\t\taddedge(u,v);\n\t}\n\tdfs(1,1);\n\tputs(sg[1]==0 ? \"BoB\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <string>\n#define SIZE 100005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nvector <int> vec[SIZE];\n\nint solve(int v=0,int p=-1)\n{\n\tint ret=0;\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tint to=vec[v][i];\n\t\tif(to!=p)\n\t\t{\n\t\t\tret^=solve(to,v);\n\t\t}\n\t}\n\treturn ret+1;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);a--;b--;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tint ret=solve();\n\tif(ret==1) puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 1e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nvector<ll> G[Maxn];\n\nll g[Maxn];\nvoid DFS(ll u, ll p){\n\tfor(auto adj : G[u]){\n\t\tif(adj != p){\n\t\t\tDFS(adj, u);\n\t\t\tg[u] ^= g[adj];\n\t\t}\n\t}\n\tif(u == 1){\n\t\tif(g[u]) cout << \"Alice\\n\";\n\t\telse cout << \"Bob\\n\";\n\t}\n\tg[u] ++;\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\t\n\tll n;\n\tcin >> n;\n\tll u, v;\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> u >> v;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tDFS(1, -1);\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int h[1 << 20];\n    static int cnt[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        h[node] = h[prev] + 1;\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node);\n    };\n    dfs(1,0);\n    int ans = 0;\n    for (int i = 1;i <= n;++i)\n        ans ^= h[i] - 1;\n    fo << (ans ? \"Alice\":\"Bob\") << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H[500010], N[500010], G[500010], V[500010], Cnt = 0;\n\nvoid addedge(int x, int y) {G[++Cnt] = y, N[Cnt] = H[x], H[x] = Cnt;}\n\nvoid DFS(int x, int f = -1)\n{\n\tfor(int T = H[x]; T; T = N[T]) if(G[T] != f) DFS(G[T], x), V[x] ^= V[G[T]];\n\tV[x]++;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\taddedge(a, b), addedge(b, a);\n\t}\n\tDFS(1);\n\tputs(V[1] == 1 ? \"Bob\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, x, y;\nvector<int>v[100000];\nbool vis[100000];\n\nint dfs(int x) {\n\tvis[x] = true;\n\tint t = 0;\n\tfor (int i : v[x]) {\n\t\tif (!vis[i]) {\n\t\t\tt ^= dfs(i);\n\t\t}\n\t}\n\treturn t + 1;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tcin >> x >> y;\n\t\t--x;\n\t\t--y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif (dfs(0) == 1) {\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse {\n\t\tcout << \"Alice\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector<int> G[100100];\nbool ok[100100];\nint dfs(int n){\n  int ans=0;\n  ok[n]=false;\n  for(int i:G[n])\n    if(ok[i])ans^=dfs(i);\n  return ans+1;\n}\nsigned main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a,b;\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n  for(int i=0;i<N;i++)ok[i]=true;\n  ok[0]=false;\n  puts(dfs(0)-1?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#include<math.h>\n#include<memory>\n#include<vector>\n#include<bitset>\n#include<fstream>\n#include<stdio.h>\n#include<utility>\n#include<sstream>\n#include<string.h>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nstruct edge\n{\n    int y;\n    edge * next;\n};\nedge * li[100005];\nedge * new_edge()\n{\n    static edge a[200005];\n    static int top=0;\n    return &a[top++];\n}\nvoid inserts(int x,int y)\n{\n    edge * t=new_edge();\n    t->y=y;\n    t->next=li[x];\n    li[x]=t;\n}\nvoid insert_edge(int x,int y)\n{\n    inserts(x,y);\n    inserts(y,x);\n}\nbool vis[100005];\nbool dfs(int x)\n{\n    vis[x]=true;\n    edge * t;\n    bool lose=true;\n    bool win=false;\n    for (t=li[x];t!=0;t=t->next)\n    {\n        if (vis[t->y]) continue;\n        bool x=dfs(t->y);\n        if (x)\n        {\n            lose^=true;\n        }\n        else\n        {\n            win^=true;\n        }\n    }\n    if (win) return false;\n    return lose;\n}\nbool win[100005],lose[100005];\nbool res[100005];\nint num[100005];\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    int n;\n    scanf(\"%d\",&n);\n    int i;\n    for (i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--;\n        y--;\n        insert_edge(x,y);\n    }\n    static int que[100005];\n    que[0]=0;\n    int front=0,rail=1;\n    for (i=0;i<n;i++)\n    {\n        int now=que[i];\n        num[now]=i;\n        vis[now]=true;\n        edge * t;\n        for (t=li[now];t!=0;t=t->next)\n        {\n            if (vis[t->y]) continue;\n            que[rail++]=t->y;\n        }\n    }\n    for (i=n-1;i>=0;i--)\n    {\n        win[i]=false;\n        lose[i]=true;\n        int now=que[i];\n        vis[now]=false;\n        edge * t;\n        for (t=li[now];t!=0;t=t->next)\n        {\n            if (vis[t->y]) continue;\n            if (res[num[t->y]]) lose[i]^=true; else win[i]^=true;\n        }\n        if (win[i])\n        {\n            res[i]=false;\n        }\n        else\n        {\n            res[i]=lose[i];\n        }\n    }\n    if (!res[0]) puts(\"Alice\"); else puts(\"Bob\");\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma optimize O3\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \n#define RETD(x) { cout << fixed << setprecision(15) << x; exit(0); }\nconst ll M=2e5+5,LG=32,SM=600+5,inf=1e18+5;\nll mod=1e9+7;\n\nll n;\nvll g[M];\n\nll dfs(ll x,ll p)\n{\n    ll w=0,l=0;\n    for (ll y:g[x])\n    {\n        if (y==p) continue;\n        if (dfs(y,x))\n            w^=1;\n        else\n            l^=1;\n    }\n    return w||l;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].PB(y);\n        g[y].PB(x);\n    }\n    if (dfs(0,0)) RET(\"Alice\");\n    RET(\"Bob\");      \t\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int maxn=1000005;\nstruct edge{\n  int to,next;\n}lst[maxn<<1];int len=1,first[maxn];\nvoid addedge(int a,int b){\n  lst[len].to=b;lst[len].next=first[a];first[a]=len++;\n}\nint sg[maxn];\nvoid dfs(int x,int p){\n  sg[x]=0;\n  for(int pt=first[x];pt;pt=lst[pt].next){\n    if(lst[pt].to==p)continue;\n    dfs(lst[pt].to,x);\n    sg[x]^=(sg[lst[pt].to]+1);\n  }\n}\nint main(){\n  int n;scanf(\"%d\",&n);\n  for(int i=1,a,b;i<n;++i){\n    scanf(\"%d%d\",&a,&b);\n    addedge(a,b);addedge(b,a);\n  }\n  dfs(1,0);\n  printf(\"%s\\n\",(sg[1])?\"Alice\":\"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tvector<int> v[100000];\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<n-1; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tint d[100000];\n\tfill(d, d+n, -1);\n\td[0]=0;\n\tqueue<int> que;\n\tque.push(0);\n\twhile(!que.empty()){\n\t\tint x=que.front();\n\t\tque.pop();\n\t\tfor(int i=0; i<v[x].size(); i++){\n\t\t\tif(d[v[x][i]]==-1){\n\t\t\t\td[v[x][i]]=d[x]+1;\n\t\t\t\tque.push(v[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\tmultimap<int, int> mp;\n\tfor(int i=0; i<n; i++){\n\t\tmp.insert(make_pair(-d[i], i));\n\t}\n\tint g[100000];\n\tfor(auto itr=mp.begin(); itr!=mp.end(); itr++){\n\t\tint x=itr->second;\n\t\tg[x]=0;\n\t\tfor(int i=0; i<v[x].size(); i++){\n\t\t\tif(d[v[x][i]]>d[x]){\n\t\t\t\tg[x]=g[x]^(g[v[x][i]]+1);\n\t\t\t}\n\t\t}\n\t}\n\tif(g[0]==0){\n\t\tprintf(\"%s\\n\", \"Bob\");\n\t}else{\n\t\tprintf(\"%s\\n\", \"Alice\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\nint N;\nvector<vector<int> > G;\nint dfs(int pos, int pre){\n  int x = 0;\n  for(int to:G[pos]){\n    if(to == pre) continue;\n    x ^= dfs(to, pos) + 1;\n  }\n  return x;\n}\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>N;\n  G.resize(N);\n  for(int i=0;i<N-1;i++){\n    int x, y;\n    cin>>x>>y; x--, y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  int ans = dfs(0, -1);\n\n  if(ans == 0) cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pair2;\ntypedef pair<int, pair<int, int> > pair3;\ntypedef pair<int, pair<int, pair<int, int> > > pair4;\n#define MAXN 200013\n#define INF 1000000000000000000LL\n#define MOD 1000000007LL\n#define IINF 1000000000\n#define mp make_pair\n#define pb push_back\n#define remove pop\n#define all(x) x.begin(), x.end()\n\nint n;\nvector<int> adj[MAXN];\n\n\nint solve(int cur, int par) { //Returns 0 if the first player wins, 1 if the second player wins.\n\t//Solve the children\n\n\t//cout << \"solving \" << cur << ' ' << par << endl;\n\n\tint childCount = adj[cur].size() - (par == -1 ? 0 : 1);\n\n\tif (childCount == 1) {\n\t\treturn 0; //First player moves and wins.\n\t} else if (childCount == 0) {\n\t\treturn 1;\n\t}\n\n\tint zeroes = 0;\n\tint ones = 0;\n\n\tfor (int next : adj[cur]) {\n\t\tif (next == par) continue;\n\n\t\t//cout << \"solving \" << next << \" got \" << solve(next, cur) << endl;\n\t\tif (solve(next, cur)) {\n\t\t\tones++;\n\t\t} else {\n\t\t\tzeroes++;\n\t\t}\n\t}\n\n\t//If for example we have two zeroes, result is 1. (first player picks child, second player picks, second wins.)\n\t//If we have a zero and a one , result is 0\n\n\n\tif (ones % 2 == 0 && zeroes % 2 == 0) {\n\t\treturn 1;\n\t} else if (ones % 2 == 0 && zeroes % 2 == 1) {\n\t\treturn 0;\n\t} else if (ones % 2 == 1 && zeroes % 2 == 0) {\n\t\treturn 0;\n\t} else if (ones % 2 == 1 && zeroes % 2 == 1) {\n\t\treturn 0;\n\t}\n\t//should never be reached\n\tassert(false);\n\treturn 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); \n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tcout << (solve(0, -1) ? \"Bob\" : \"Alice\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n;\nvector <int> v[N];\nmap <set <int>, int> mp;\n\nint id(set <int> &s){\n    if(mp.find(s) == mp.end()){\n        int sz = mp.size();\n        mp[s] = sz;\n    }\n    return mp[s];\n}\nint dfs(int node, int pnode){\n    set <int> s;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        int cur = dfs(i, node);\n        if(s.count(cur)) s.erase(cur);\n        else s.insert(cur);\n    }\n    return id(s);\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(dfs(1, 0) == 0) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tQ.push(1);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t//\tif (edge[i].size() > 2)dis[i]--;\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define N 10005\n#define LL long long\n#define inf 1<<29\n#define eps 1e-7\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int n;\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n\n#include <bits/stdc++.h>\n\n#define N 100010\n#define M 200010\n\nusing namespace std;\n\n#define IV inline void\n#define II inline int\n\n#define lc c[x][0]\n\n#define rc c[x][1]\n\nint c[N][2],f[N],s[N],v[N],r[N];\n\nint st[N];\n\ninline bool proot(int x){\n\treturn c[f[x]][0]==x||c[f[x]][1]==x;\n}//返回1表示他不是根\n\nIV pushp(int x){\n\ts[x]=s[c[x][0]]^s[c[x][1]]^v[x];\n}\n\nIV pushr(int x){\n\tint t=c[x][0];c[x][0]=c[x][1];c[x][1]=t;\n\tr[x]^=1;return;\n}\n\nIV pushdown(int x){//你见过这么优秀的pushdown吗？\n\tif(r[x])\n\t{\n\t\tif(c[x][0]) pushr(c[x][0]);\n\t\tif(c[x][1]) pushr(c[x][1]);\n\t\tr[x]=0;\n\t}\n}\n\nII Get(int x){\n\treturn (c[f[x]][1]==x);\n}\n\nIV rotate(int x){\n\tint rf=f[x],rff=f[rf],h=Get(x),rh=Get(rf),w=c[x][!h];\n\tif(proot(rf)) c[rff][rh]=x;c[x][!h]=rf,c[rf][h]=w;\n\tif(w)  f[w]=rf;f[rf]=x;f[x]=rff;\n\tpushp(rf);\n\treturn;\n}\n\nIV splay(int x){\n\tint y=x,z=0;\n\tst[++z]=y;\n\twhile(proot(y)) st[++z]=y=f[y];\n\twhile(z) pushdown(st[z--]);\n\twhile(proot(x)){\n\t\ty=f[x];z=f[y];\n\t\tif(proot(y))\n\t\t  rotate((c[y][0]==x)^(c[z][0]==y)?x:y);\n\t\trotate(x);\n\t}\n\tpushp(x);\n}\n\nIV access(int x){\n\tfor(int y=0;x;x=f[y=x])\n\t  splay(x),c[x][1]=y,pushp(x);\n}\n\nIV makeroot(int x){\n\taccess(x);splay(x);\n\tpushr(x);\n}\n\nint findroot(int x){\n\taccess(x);splay(x);\n\twhile(c[x][0]) pushdown(x),x=c[x][0];\n\tsplay(x);\n\treturn x;\n}\n\nIV split(int x,int y){\n\tmakeroot(x);\n\taccess(y);splay(y);\n}\n\nIV link(int x,int y){\n\tmakeroot(x);\n\tif(findroot(y)!=x) f[x]=y;\n}\n\nIV cut(int x,int y){\n\tmakeroot(x);\n\tif(findroot(y)==x&&f[y]==x&&!c[y][0]){\n\t\tf[y]=c[x][1]=0;\n\t\tpushp(x);\n\t}\n}\n\nint ans[N];\nint ver[M],nex[M],head[N],nu;\nint n,x1,x2;\n\ninline int read(){\n\tint x=0;char c=getchar();\n\tfor(;c<'0' || c>'9';c=getchar());\n\tfor(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;\n\treturn x;\n}\n\ninline void add(int x,int y){\n\tver[++nu]=y;nex[nu]=head[x];head[x]=nu;\n}\n\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=nex[i]){\n\t\tint y=ver[i];\n\t\tif(y!=fa)\n\t\tdfs(y,x);\n\t\tans[x]^=(ans[y]+1);\n\t}\n\treturn;\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\tx1=read(),x2=read(),add(x1,x2),add(x2,x1);\n\tdfs(1,1);\n\tif(!ans[1]) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n\treturn 0;\n}                                                                                                                                                                                   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint x[110000],y[110000];\nvint G[110000];\nint dfs(int from, int to) {\n    int cur = 0;\n    for (int i=0;i<G[to].size();i++){\n      if(G[to][i]==from)continue;\n      cur^=dfs(to,G[to][i])+1;\n    }\n    return cur;\n}\n\nsigned main() {\n  cin >> N;\n  for(int i=0;i<N-1;i++){\n    cin>>x[i]>>y[i];\n    G[x[i]].push_back(y[i]);\n    G[y[i]].push_back(x[i]);\n  }\n  if(dfs(0,1)!=0)cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\nstruct yuansu\n{\n    int x,y;\n}bian[500005];\nint cmp (yuansu a,yuansu b)\n{\n    return a.x<b.x;\n}\nint sum[500005],n,x,y,cnt;\nint dfs(int dian,int fa)\n{\n    if(sum[dian]==sum[dian-1]+1)\n    {\n        return 0;\n    }\n    int ans(0);\n    for(int i=sum[dian-1]+1;i<=sum[dian];i++)\n    {\n        if(bian[i].y==fa)\n        {\n            ans^=dfs(bian[i].y,dian)+1;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    cin>>n;\nfor(int i=1;i<n;i++)\n{\n    scanf(\"%d%d\",&x,&y);\n    bian[++cnt].x=x;\n    bian[cnt].y=y;\n    bian[++cnt].x=y;\n    bian[cnt].y=x;\n}\nsort(bian+1,bian+cnt+1,cmp);\nfor(int i=1;i<=cnt;i++)\n{\n    if(bian[i].x!=bian[i+1].x)\n    {\n        sum[bian[i].x]=i;\n    }\n}\nif(dfs(1,0))cout<<\"Alice\";\nelse cout<<\"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(map<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(V<ll> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(V<t2> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(V<t3> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(V<t4> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(V<ll> &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\ntemplate <typename T>\nvoid _debug_print(T x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const map<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n#if DEBUG\n    struct tm *tm = localtime(&tv.tv_sec);\n#endif\n    debug_printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n                 prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parents[], V<ll> children[], ll levels[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parents[root] = root;\n    levels[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parents[next] = now;\n            children[now].pb(next);\n            levels[next] = levels[now] + 1LL;\n        }\n    }\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    V<t2> uvlist; llinl2(uvlist, n-1);\n\n    S V<ll> edgelist[100005];\n    make_edgelist(uvlist, edgelist);\n\n    S ll parents[100005];\n    S V<ll> children[100005];\n    S ll levels[100005];\n    make_parental_relation(edgelist, 1, n, parents, children, levels);\n\n    S ll levelcnt[100005] = {};\n    srep (v, 2, n+1) levelcnt[levels[v]]++;\n\n    rep (lv, n+1) if (levelcnt[lv] & 1LL) {\n        cout << \"Alice\" << endl;\n        return;\n    }\n    cout << \"Bob\" << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100000 + 10;\n\nint n , sg[maxn] , fa , ans;\nvector < int > que , Edge[maxn];\n\nint DFS( int u , int fa = 0 ){\n\tfor(auto v : Edge[u]){\n\t\tif( v == fa )\n\t\t\tcontinue;\n\t\tsg[u] ^= (DFS( v , u ) + 1);\n\t}\n\treturn sg[u];\n}\n\nint main( int argc , char * argv[] ){\n\tscanf( \"%d\" , & n );\n\tfor(int i = 2 ; i <= n ; ++ i){\n\t\tint u , v;\n\t\tscanf( \"%d%d\" , & u , & v );\n\t\tEdge[u].emplace_back( v );\n\t}\n\tif( DFS( 1 ) )\n\t\tputs( \"Alice\" );\n\telse\n\t\tputs( \"Bob\" );\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nvector<int> v[100010];\nint n;\nint DFS(int x,int from){\n\tint xors=0;\n\tlol(i,v[x].size()){\n\t\tint to=v[x][i];\n\t\tif(to==from)continue;\n\t\txors^=DFS(to,x)+1;\n\t}\n\treturn xors;\n}\nint main(){\n\tcin>>n;\n\tlol(i,n-1){\n\t\tint a,b;cin>>a>>b;a--,b--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tcout<<(DFS(0,0)?\"Alice\":\"Bob\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\n//I am fucking stupid\n//Stupidity level  -> 1/0\n\n\nconst int MAXN  = 1010;\nvector<int>v1[MAXN];\nint gr[MAXN];\n\nvoid DFS(int x,int par)\n{\n    for(auto itr : v1[x])\n    {\n        if(itr!=par)\n        {\n            DFS(itr, x);\n            gr[x]^=(gr[itr]+1);\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin>>t;\n    while (t--) {\n        int n;\n        cin>>n;\n        for(int i = 0 ;i<MAXN;i+=1){\n            v1[i].clear();\n            gr[i] = 0;\n         }\n        for(int i = 1;i<=n-1;i+=1)\n        {\n            int x,y;\n            cin>>x>>y;\n            v1[x].push_back(y);\n            v1[y].push_back(x);\n        }\n        DFS(1, -1);\n        if(gr[1]==0)\n        {\n            cout<<\"Bob\"<<endl;\n        }\n        else{\n            cout<<\"Alice\"<<endl;\n        }\n        \n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define LINF (9223372036854775807LL)\n#define EPS (1e-10)\n#define endl ('\\n')\n//#define MOD 1000000007LL\n#define MOD 998244353LL\n//#define MOD 18446744069414584321ULL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,...) for(auto i:range(__VA_ARGS__)) \n#define rrep(i,...) for(auto i:reversed(range(__VA_ARGS__)))\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\ninline vector<int64_t> range(int64_t n){vector<int64_t>v(n);iota(v.begin(),v.end(),0LL);return v;}\ninline vector<int64_t> range(int64_t a,int64_t b){vector<int64_t>v(b-a);iota(v.begin(),v.end(),a);return v;}\ninline vector<int64_t> range(int64_t a,int64_t b,int64_t c){vector<int64_t>v((b-a+c-1)/c);for(int i=0;i<(int)v.size();++i)v[i]=i?v[i-1]+c:a;return v;}\ninline auto reversed(auto v){reverse(v.begin(),v.end());return v;}\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\n//inline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\n//inline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\nbool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\nbool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[](auto f,auto... args){return f(f,args...);};\ntemplate<typename T,typename ...Args>auto make_vector(T x,int arg,Args ...args){if constexpr(sizeof...(args)==0)return vector<T>(arg,x);else return vector(arg,make_vector<T>(x,args...));}\n\nint main(){\n    lint n;\n    cin>>n;\n    mat v(n);\n    rep(i,n-1){\n        lint s,t;\n        cin>>s>>t;\n        s--;t--;\n        v[s].push_back(t);\n        v[t].push_back(s);\n    }\n    auto f=[&](auto f,lint n,lint p)->lint{\n        lint ans=0;\n        for(auto e:v[n]){\n            if(e==p)continue;\n            ans^=f(f,e,n);\n        }\n        return ans+1;\n    };\n    if(f(f,0,-1)==1)cout<<\"Bob\"<<endl;\n    else cout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nvector<vector<int>> v(100010);\nbool used[100010];\n\nint dfs(int p){\n    used[p] = true;\n    int x = 0;\n    for(auto i:v[p]){\n        if(!used[i]){\n            x ^= dfs(i) + 1;\n        }\n    }\n    return x;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n \n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int a,b; cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    ll ans = dfs(0);\n    if(ans){\n        cout << \"Alice\" << endl;\n    }\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\nconst ll M = (ll)(1e10);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nvector<int> g[100100];\n\nbool solve(int v, int p = -1){\n\tint i,u;\n\tbool ch = false, sl = false;\n\tfor(i=(g[v].l_ength()-1); i>=0; --i){\n\t\tu = g[v][i];\n\t\tif(u==p){\n\t\t\tcontinue;\n\t\t}\n\t\tch ^= solve(u,v);\n\t\tsl ^= true;\n\t}\n\treturn (ch|sl);\n}\n\nint main(void){\n\tint n,i,x,y;\n\tcin >> n;\n\tfor(i=1; i<n; ++i){\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tcout << (solve(0)?\"Alice\":\"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define li long long\n#define ld long double\n#define x first\n#define y second\n#define pt pair<int, int>\n#define pll pair<li, li>\n#define forn(i, t) for(int i = 0; i < (t); i++)\n#define fore(i, f, t) for(int i = (f); i < (t); i++)\n#define forr(i, f, t) for(int i = (f) - 1; i >= (t); i--)\n#define all(x) (x).begin(), (x).end()\n#define ins insert\n\nusing namespace std;\n\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst li INF64 = 1e18;\nconst ld EPS = 1e-7;\n\nmt19937 myrand(time(NULL));\n\nconst int N = 100 * 1000 + 13;\n\nint n;\nvector<int> g[N];\n\n\nbool read(){\n\tif(scanf(\"%d\", &n) != 1)\n\t\treturn 0;\n\tforn(i, n)\n\t\tg[i].clear();\n\tforn(i, n - 1){\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\t--f, --t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\treturn 1;\n}\n\nint dp[N];\n\nvoid dfs(int v, int p = -1){\n\tdp[v] = 0;\n\tint cnt = 0;\n\tfor (auto u : g[v]) if (u != p){\n\t\t++cnt;\n\t\tdfs(u, v);\n\t\tdp[v] ^= dp[u] + 1;\n\t}\n\tif (cnt == 1){\n\t\t++dp[v];\n\t}\n}\n\nvoid solve(){\n\tdfs(0);\n\tprintf(dp[0] ? \"Alice\\n\" : \"Bob\\n\");\n}\n\n\nint main(){\n\t#ifdef _DEBUG\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\twhile(read())\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a),i##_end_=(b);i<i##_end_;i++)\n#define MEMSET(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define SZ(a) ((int)a.size())\nusing namespace std;\nconst int M=100005;\n\nvector<int> E[M];\nbool T[M];\nint fa[M],g[M],SG[M];\nint n,ans;\n \nint dfs2(int u,int p,int fa){\n    int v;\n    FOR(i,0,SZ(E[u])) if((v=E[u][i])^fa) p^=SG[v];\n    T[p]=1;\n    FOR(i,0,SZ(E[u])) if((v=E[u][i])^fa) dfs2(v,p^SG[v],u);\n}\n \nint dfs(int u,int fa){\n    int v;\n    FOR(i,0,SZ(E[u])) if((v=E[u][i])^fa) dfs(v,u);\n    MEMSET(T,0); dfs2(u,0,fa);\n    while(T[SG[u]]) SG[u]++;\n}\n \nint main(){\n    scanf(\"%d\",&n);\n    \n    FOR(i,1,n){\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        u--;v--;\n        if(v) E[u].pb(v);\n        if(u) E[v].pb(u);\n        if(!u) fa[v]=-1;\n        if(!v) fa[u]=-1;\n    }\n    \n    FOR(i,1,n) if(!~fa[i]) dfs(i,0),ans^=SG[i];\n    printf(\"%s\",ans?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define TRACE\n\n#ifdef TRACE\n#define trace1(x)                cerr << #x << \": \" << x << endl;\n#define trace2(x, y)             cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << endl;\n#define trace3(x, y, z)          cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << \" | \" << #z << \": \" << z << endl;\n#define trace4(a, b, c, d)       cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" << #d << \": \" << d << endl;\n#define trace5(a, b, c, d, e)    cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" << #d << \": \" << d << \" | \" << #e << \": \" << e << endl;\n#define trace6(a, b, c, d, e, f) cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" << #d << \": \" << d << \" | \" << #e << \": \" << e << \" | \" << #f << \": \" << f << endl;\n\n#else\n\n#define trace1(x)\n#define trace2(x, y)\n#define trace3(x, y, z)\n#define trace4(a, b, c, d)\n#define trace5(a, b, c, d, e)\n#define trace6(a, b, c, d, e, f)\n\n#endif\n\nconst int INF=1e9;\nconst ll INFF=1e17;\nconst double EPS=1e-9;\nconst ll MOD=1e9+7;\nconst int MAXN=1e5+10;\nint n,gr[MAXN];\nbool vis[MAXN];\nvector<vector<int> > g(MAXN);\nvoid dfs(int v){\n\tgr[v]=0;\n\tvis[v]=1;\n\tfor(auto u:g[v]){if(!vis[u]){dfs(u);gr[v]^=(gr[u]+1);}}\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint t1,t2;\n\t\tcin >> t1 >> t2;t1--;t2--;\n\t\tg[t1].pb(t2);\n\t\tg[t2].pb(t1);\n\t}\n\tREP(i,n)vis[i]=0;\n\tdfs(0);\n\tcout << (!gr[0]?\"Bob\":\"Alice\") << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\nvector<vector<int> > v(100000);\nint dfs(int now,int p){\n\tint ret = 0;\n\tfor(auto& to:v[now]){\n\t\tif(to == p) continue;\n\t\tret ^= (dfs(to,now)+1);\n\t}\n\treturn ret;\n}\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    int n,a,b;\n    cin >> n;\n    for(int i=1;i<n;i++){\n    \tcin >> a >> b;\n    \ta--;b--;\n    \tv[a].pb(b);\n    \tv[b].pb(a);\n    }\n    if(dfs(0,-1))cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N=1e5+100;\nvi g[N];\n\nbool dfs(int v, int pr){\n    int tr=0,fl=0;\n    for(auto to:g[v]){\n        if(to==pr)\n            continue;\n        tr++;\n        bool u=dfs(to,v);\n        if(u)\n            fl++;\n    }\n    if(tr==0)\n        return true;\n    \n    if(fl==tr&&tr%2==0)\n        return false;\n    \n    return true;\n}\n\n\nvoid smain() {\n\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    bool u=dfs(1,1);\n    if(u)\n        cout<<\"Alice\";\n    else\n        cout<<\"Bob\";\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tif (edge[c].size() > 3)dis[c] = 0;\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAXN 100000\n\nvector < int > g[MAXN + 1];\nbool viz[MAXN + 1];\n\nint dfs(int x) {\n    int ans = 0;\n    viz[x] = 1;\n    for (auto &y : g[x])\n        if (viz[y] == 0)\n            ans ^= 1 + dfs(y);\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (n--; n; n--) {\n        int x, y;\n        cin >> x >> y;\n\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    cout << ( dfs( 1 ) ? \"Alice\" : \"Bob\" );\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nvector<int> e[ten(5)];\nint dep[ten(5)];\n\nvoid dfs(int v, int par, int d) {\n\tdep[v] = d;\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tdfs(0, -1, 0);\n\tmap<int, int> dm;\n\tFOR(i, n) if(i) dm[dep[i]] ^= 1;\n\n\tbool bob = true;\n\tfor (auto kv : dm) {\n\t\tif (kv.second != 0) bob = false;\n\t}\n\n\tputs(bob ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint G[100001];\npair<int, int> E[200001];\npair<int, int>* P[100002];\nint dfs(int A) {\n\tif (G[A] == 0) {\n\t\tint g = 0;\n\t\tG[A] = -1;\n\t\tfor (auto p = P[A]; p < P[A + 1]; p++) {\n\t\t\tg ^= dfs((*p).second);\n\t\t}\n\t\treturn G[A] = g + 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N + N - 2; i += 2) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[i] = mp(x, y);\n\t\tE[i + 1] = mp(y, x);\n\t}\n\tsort(E, E + N + N - 2);\n\tint k = 0;\n\trep(i, N + N - 2) {\n\t\tif (k != E[i].first) {\n\t\t\tk++;\n\t\t\tP[k] = E + i;\n\t\t}\n\t}\n\tP[N + 1] = E + N + N - 2;\n\n\tdfs(1);\n\n\tif (G[1] - 1) co(\"Alice\");\n\telse co(\"Bob\");\n\n\tWould you please return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define mod (int)1000000007\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\n#ifdef int\nconstexpr int INF = LLONG_MAX / 10;\n#else\nconstexpr int INF = INT_MAX / 10;\n#endif\nconstexpr double eps = DBL_EPSILON;\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\nint n;\nvector<int> vec[100010];\nbool used[100010];\nbool dfs(int node) {\n\tused[node] = true;\n\tbool f = false, g = false;\n\tfor (int i : vec[node]) {\n\t\tif (!used[i]) {\n\t\t\tf ^= dfs(i);\n\t\t\tg ^= true;\n\t\t}\n\t}\n\treturn f | g;\n}\nsigned main() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tvec[u].push_back(v);\n\t\tvec[v].push_back(u);\n\t}\n\tif (dfs(1))puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint f[maxn];\nint n;\n\nvoid dfs(int v, int p)\n{\n    if (g[v].size() - 1 == 1)\n    {\n        f[v] = 1;\n        return;\n    }\n    for (int i = 0; i < g[v].size(); i++)\n    {\n        int u = g[v][i];\n        if (u == p)\n        {\n            continue;\n        }\n        dfs(u, v);\n        f[v] ^= f[u];\n    }\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    g[1].push_back(0);\n    dfs(1, 0);\n    if (f[1])\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        cout << \"Bob\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nstd::vector<std::vector<int>> g;\nstd::vector<int> dp;\nint n;\n\nbool dfs(int v, int p = -1){\n\tif(~dp[v]) return dp[v];\n\t\n\tbool ret = false; int c = 0;\n\tfor(auto e : g[v]){\n\t\tif(e == p) continue; c++;\n\t\tret ^= dfs(e, v);\n\t}\n\tif(c == 1) ret = true;\n\t\n\treturn dp[v] = ret;\n}\n\nint main(){\n\tcin >> n; g.resize(n); dp.resize(n, -1);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint a, b; cin >> a >> b;\n\t\t\n\t\tg[a - 1].push_back(b - 1);\n\t\tg[b - 1].push_back(a - 1);\n\t}\n\t\n\tif(dfs(0)) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nset<int> ss;\nint dfs(int v,vector<vector<int>> &edge,vector<int> &cnt,vector<int> &used){\n    used[v]=true;\n    int res=0;\n    for(int i=0;i<edge[v].size();i++){\n        int to=edge[v][i];\n        if(used[to]) continue;\n        res+=dfs(to,edge,cnt,used);        \n    }\n    ss.insert(res+1);\n    return cnt[v]=res+1;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> edge(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    vector<int> grundy(n);\n    vector<int> used(n);\n    vector<int> cnt(n);\n    for(int i=0;i<edge[0].size();i++){\n        int to=edge[0][i];\n        used[0]=true;\n        ss.clear();\n        dfs(to,edge,cnt,used);\n        vector<int> aho(ss.begin(),ss.end());\n        for(int i=0;i<aho.size();i++) aho[i]=aho[aho.size()-1]-aho[i];\n        sort(aho.begin(),aho.end());\n        int res=aho.size();\n        for(int i=0;i<aho.size();i++){\n            if(aho[i]!=i){\n                res=i+1;\n                break;\n            }\n        }\n        \n        grundy[to]=res;\n\n    }\n    int res=0;\n\n    for(int i=0;i<edge[0].size();i++){\n        res^=grundy[edge[0][i]];\n        \n    }\n    cout<<(res?\"Alice\" :\"Bob\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i + 1 < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> win(n);\n  function<void(int, int)> dfs = [&](int v, int pv) {\n    int cn = 0;\n    for (int to : g[v]) {\n      if (to == pv) {\n        continue;\n      }\n      cn++;\n      dfs(to, v);\n      win[v] ^= win[to] ^ 1;\n    }\n    if (cn == 1) {\n      win[v] = 1;\n    }\n  };\n  dfs(0, -1);\n  cout << (win[0] ? \"Alice\" : \"Bob\") << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include<bits/stdc++.h>\n     \n         \n        using namespace std;\n         \n        #define N  1000000000;\n    #define ll         long long\n        vector<ll>adj[100005];\n        std::vector<ll> vis;\n        ll dfs(ll node)\n        {\n           \n           ll ans=0;\n           for(auto j:adj[node])\n           {\n            if(vis[j]==0)\n            {\n                vis[j]=1;\n                ans^=(1+dfs(j));\n            }\n           }\n           return ans;\n         }\n         int main()\n        \n       \n        {\n            ios_base::sync_with_stdio(false);\n            cin.tie(0);\n            cout.tie(0);\n            int TESTS=1;\n           // cin>>TESTS;\n             while(TESTS--)\n            {\n              ll n;\n              cin>>n;\n              for(ll i=0;i<n-1;i++)\n              {\n                ll a,b;\n                cin>>a>>b;\n                adj[a].push_back(b);\n                adj[b].push_back(a);\n              }\n              vis=vector<ll>(n+2,0);\n              vis[1]=1;\n              if(dfs(1))\n                cout<<\"Alice\"<<endl;\n            else\n                cout<<\"Bob\"<<endl;\n            }\n            return 0;\n        }"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(map<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(V<ll> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(V<t2> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(V<t3> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(V<t4> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(V<ll> &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\ntemplate <typename T>\nvoid _debug_print(T x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const map<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n#if DEBUG\n    struct tm *tm = localtime(&tv.tv_sec);\n#endif\n    debug_printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n                 prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parents[], V<ll> children[], ll levels[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parents[root] = root;\n    levels[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parents[next] = now;\n            children[now].pb(next);\n            levels[next] = levels[now] + 1LL;\n        }\n    }\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    V<t2> uvlist; llinl2(uvlist, n-1);\n\n    S V<ll> edgelist[100005];\n    make_edgelist(uvlist, edgelist);\n\n    S ll parents[100005];\n    S V<ll> children[100005];\n    S ll levels[100005];\n    make_parental_relation(edgelist, 1, n, parents, children, levels);\n\n    S ll childcnts[100005];\n    srep (v, 1, n+1) childcnts[v] = children[v].size();\n\n    S ll grundy[100005] = {};\n    queue<ll> q;\n    srep (v, 1, n+1) {\n        if (!childcnts[v]) q.push(v);\n    }\n\n    while (q.size()) {\n        ll v = q.front(); q.pop();\n        ll pv = parents[v];\n        if (v == pv) continue;\n        grundy[pv] ^= (grundy[v] + 1LL);\n        childcnts[pv]--;\n        if (!childcnts[pv]) q.push(pv);\n    }\n\n    cout << (grundy[1] ? \"Alice\" : \"Bob\") << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nint par[100011];\nVI ord;\nint nim[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    nim[v] ^= nim[*e] + 1;\n\t}\n    }\n\n    puts(nim[0]? \"Alice\": \"Bob\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, dt[N];\nvector<int> adj[N];\n\nvoid calc (int C, int P) {\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tcalc(T, C);\n\t\tdt[C] ^= (dt[T] + 1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tcalc(1, 0);\n\tputs(dt[1]?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n  int N;\nvector<int> G[MAX_N];\n\nint solve(int pos,int prev){\n  int res=0;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    res^=solve(to,pos);\n  }\n  return res+1;\n}\n\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N-1;i++){\n    int x,y;\n    cin>>x>>y;\n    x--,y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  int ans=0;\n  for(int i=0;i<(int)G[0].size();i++){\n    int x=G[0][i];\n    ans^=solve(x,0);\n  }\n  if(ans>0)cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n} \nll dfs(vvl &g,ll v=0, ll par=-1){\n    ll ret=0;\n    for(auto nv:g[v]){\n        if(nv==par)continue;\n        ret^=dfs(g,nv,v);\n    }\n    return ret+1;\n}\nint main(){\n    ll n;cin >> n;\n    vvl g(n);\n    rep(i,n-1){\n        ll a,b;cin >> a >> b;a--;b--;\n        g[a].pb(b);g[b].pb(a);\n    }\n    if(dfs(g)-1){\n        cout << \"Alice\" <<endl;\n    }\n    else cout << \"Bob\" <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <fstream>\n#include <cmath>\n#include <random>\n#include <complex>\n#include <functional>\n\n#define ll int64_t\n#define Rep(i, n) for (ll i = 0; i < n; i++)\nusing namespace std;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nconst ll inf = 1LL << 60;\n\ntemplate<class T> inline void chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n    }\n}\ntemplate<class T> inline void chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n    }\n}\n\nmat graph;\nvec status;\n\nll dfs(ll v, ll from) {\n    // cout << v << \"\\n\";\n    if (status[v] != -1) return status[v];\n    if (from != -1 and graph[v].size() == 1) {\n        status[v] = 0;\n        return 0;\n    }\n\n    ll zero = 0, one = 0;\n    for (ll nv : graph[v]) {\n        if (nv == from) continue;\n        if (dfs(nv, v) == 0) zero++;\n        else one++;\n    }\n\n    if ((zero + one) % 2 == 1) {\n        status[v] = 1;\n        return 1;\n    } else if (one % 2 == 1) {\n        status[v] = 1;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint main(){\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);\n\n    ll N;\n    cin >> N;\n    graph.assign(N, vec());\n    status.assign(N, -1);\n    Rep (i, N-1) {\n        ll x, y;\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n\n    if (dfs(0, -1) == 0) {\n        cout << \"Bob\\n\";\n    } else {\n        cout << \"Alice\\n\";\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<vector<int>> t;\n  vector<int> grundy;\n  Solver(LL n) : n(n), t(n), grundy(n){};\n\n  void solve() {\n    for (int i = 0; i < n - 1; ++i) {\n      int a, b;\n      cin >> a >> b;\n      t[--a].push_back(--b);\n      t[b].push_back(a);\n    }\n    dfs(0, -1);\n    cout << (grundy[0] ? \"Alice\" : \"Bob\") << endl;\n  }\n  void dfs(int c, int p) {\n    for (auto v : t[c]) {\n      if (v != p) {\n        dfs(v, c);\n        grundy[c] ^= (grundy[v] + 1);\n      }\n    }\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n\tint N;\n\tcin>>N;\n\tint i;\n\tint v1, v2;\n\tint num1=0;\n\tint num2;\n\tfor (i=0;i<N-1;i++){\n\t\tcin>>v1>>v2;\n\t\tif (v1==1){\n\t\t\tnum1++;\n\t\t}else if (v2==1){\n\t\t\tnum1++;\n\t\t}\n\t}\n\tif (num1==1){\n\t\tcout<<\"Alice\"<<endl;\n\t\treturn 0;\n\t}\n\tnum2=N-1-num1;\n\tif (num1==2){\n\t\tif (num2%2==0){\n\t\t\tcout<<\"Bob\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Alice\"<<endl;\n\t\t}\n\t}else{\n\t\tif (num2>num1){\n\t\t\twhile (num1>2){\n\t\t\t\tnum1--;\n\t\t\t\tnum2--;\n\t\t\t}\n\t\t\tif (num2%2==0){\n\t\t\t\tcout<<\"Bob\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"Alice\"<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\twhile (num1>2){\n\t\t\t\tnum1--;\n\t\t\t\tnum2--;\n\t\t\t\tif (num2==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num1%2==0){\n\t\t\t\tcout<<\"Bob\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"Alice\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int h[1 << 20];\n    static int cnt[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        h[node] = h[prev] + 1;\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node);\n    };\n    dfs(1,0);\n    static map < int , int > M;\n    for (int i = 2;i <= n;++i)\n        ++M[h[i]];\n    for (auto it : M)\n        if (it.y & 1)\n            return puts(\"Alice\") * 0;\n    puts(\"Bob\");\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,x,y,fa[N];\nint fst[N],nxt[N*2],to[N*2],l;\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nint Get(int x)\n{\n\tint now=0;\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tif (to[i]!=fa[x])\n\t\t{\n\t\t\tfa[to[i]]=x;\n\t\t\tnow^=Get(to[i])+1;\n\t\t}\n\treturn now;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tputs(Get(1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn (rand()<<16|rand())%x;\n}\nconst int N=100005;\nint n;\nvector<int> v[N];\nint dfs(int p,int fa){\n\t//if(fa)cout<<p<<\" \"<<*lower_bound(v[p].begin(),v[p].end(),fa)<<\" \"<<fa<<endl;\n\tsort(v[p].begin(),v[p].end());\n\tif(fa)v[p].erase(lower_bound(v[p].begin(),v[p].end(),fa));\n\tif(v[p].size()==0)return 0;\n\tint sum=0;\n\tfor(unsigned i=0;i<v[p].size();i++){\n\t\tif(v[p].size()>1)sum^=dfs(v[p][i],p);\n\t\telse {return dfs(v[p][i],p)+1;}\n\t}\n\t//cout<<p<<\" \"<<sum<<endl;\n\treturn sum;\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint s=read(),t=read();\n\t\tv[s].push_back(t); v[t].push_back(s);\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n    int n;\n    int sum=0;\n    int x,y;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        if(x==1||y==1)\n        {\n            sum++;\n        }\n    }\n    if(sum%2) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,a[100005];\nvector<int> v[100005];\nvoid dfs(int x,int y){\n    for(int i=0;i<v[x].size();++i){\n        int z=v[x][i];\n        if(y==z) continue;\n        dfs(z,x);\n        a[x]^=(a[z]+1);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    dfs(1,0);\n    if(a[1])puts(\"Alice\");\n    else puts(\"Bob\");\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b)  for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n#define ll long long\n\nusing namespace std;\n\nint rez[100100];\nvector <int> child[100100];\nint par[100100];\n\nvoid dfs(int x) {\n  int out = -1;\n  REP(i, child[x].size()) {\n    int ne = child[x][i];\n    if (ne == par[x]) continue;\n    par[ne] = x;\n    dfs(ne);\n    out *= rez[ne];\n  }\n  if (child[x].size() == 2 && x != 0) out = 1;\n  rez[x] = out;\n  return;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    child[x].push_back(y);\n    child[y].push_back(x);\n  }\n  par[0] = -1;\n  dfs(0);\n  if (child[0].size() == 1) {\n    cout << \"Alice\\n\";\n    return 0;\n  }\n  if (rez[0] == 1) cout << \"Alice\\n\";\n  else             cout << \"Bob\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nvector<vector<int>> edge;\nvector<int> grundy;\n\nvoid dfs(int now, int par) {\n    for (int child : edge[now]) {\n        if (child != par) {\n            dfs(child, now);\n            grundy[now] ^= grundy[child]+1;\n        }\n    }\n    return;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    edge.resize(N+1);\n    grundy = vector<int>(N+1, 0);\n    for (int i = 0; i < N-1; i++) {\n        int a, b;\n        cin >> a >> b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    dfs(1, 0);\n    if (grundy[1] == 0) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int h[1 << 20];\n    static int cnt[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        set < int > ss;\n        h[node] = h[prev] + 1;\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node),ss.insert(cnt[it]);\n        while (ss.count(cnt[node])) ++cnt[node];\n    };\n    dfs(1,0);\n    int ans = 0;\n    for (int i = 2;i <= n;++i)\n        if ((h[i] - 1) & 1)\n        ans ^= cnt[i];\n    puts(ans ? \"Alice\":\"Bob\");\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF (long long) 1e18//1234567890987654321\n#define INF 1234567890\n#define pb push_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos(-1))\n#define MAXN 300006\n#define MAXK 26\n#define MAXX 15000006\n#define ll long long int\n#define ld long double\n#define rep0(kk, l1, l2)for(ll kk = l1; kk < l2; kk++)\n#define rep1(kk, l1, l2)for(ll kk = l1; kk <= l2; kk++)\n#define foritr(itr, A) for(set<ll>::iterator itr = A.begin(); itr != A.end(); itr++)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = ss; ii < ee; ii++)\n#define cr(x) cerr << #x << \" = \" << x << \"\\n\";\n#define crA(x, A) cerr << #x << \" = \" << A[x] << \"\\n\";\n#define spacing cout << \" \";\n#define mmst(x, v) memset((x), v, sizeof ((x)));\n#define bg(ms) (*ms.begin())\n#define ed(ms) (*prev(ms.end(), 1))\n#define addedge(a, b, c, v) v[(a)].pb(pi((b), (c))); v[(b)].pb(pi((a), (c)))\n#define ph push\n#define btinpct(x) __builtin_popcountll(x)\n#define p2(x) (1LL<<(x))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nll n, vt;\nvector <ll> v[MAXN];\nvoid dfs(ll x, ll p, ll d)\n{\n\tif(d > 1) vt ++;\n\tfor(auto i : v[x]) { if(i!=p) dfs(i, x, d+1); }\n}\nint main()\n{\n\tcin >> n;\n\tFOR(i,1,n)\n\t{\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tv[a].pb(b);\n\t\tv[b].pb(a);\n\t}\n\tdfs(1, 1, 0);\n\tif(vt % 2) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+10;\nint n, nim[N];\nvector<int> g[N];\n\nvoid dfs(int u, int f) {\n\tfor(int v : g[u]) if(v != f)\n\t\tdfs(v,u);\n\tfor(int v : g[u]) if(v != f) {\n\t\tnim[u] ^= (nim[v] + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1,-1);\n\tif(nim[1] == 0) puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nstd::vector<std::vector<int>> g;\nstd::vector<int> dp;\nint n;\n\nint dfs(int v, int p = -1){\n\tif(~dp[v]) return dp[v];\n\t\n\tint ret = 0;\n\tfor(auto e : g[v]){\n\t\tif(e == p) continue;\n\t\tret ^= dfs(e, v) + 1;\n\t}\n\t\n\treturn dp[v] = ret;\n}\n\nint main(){\n\tcin >> n; g.resize(n); dp.resize(n, -1);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint a, b; cin >> a >> b;\n\t\t\n\t\tg[a - 1].push_back(b - 1);\n\t\tg[b - 1].push_back(a - 1);\n\t}\n\t\n\tif(dfs(0)) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n,-1);\n\tdist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front();\n\t\tq.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nint gr(int now, vvel &chi) {\n\tint ret = 0;\n\tfor(auto to:chi[now]) {\n\t\tret = ret xor (gr(to, chi) + 1);\n\t}\n\treturn ret;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvvel way(n);\n\tvel st(n-1), to(n - 1);\n\trep(i, n-1) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tway[x].push_back(y);\n\t\tway[y].push_back(x);\n\t\tst[i] = x; to[i] = y;\n\t}\n\tvel dist0 = dis(0, way);\n\tvvel chi(n);\n\trep(i, n-1) {\n\t\tif (dist0[st[i]] < dist0[to[i]]) {\n\t\t\tchi[st[i]].push_back(to[i]);\n\t\t}\n\t\telse { chi[to[i]].push_back(st[i]); }\n\t}\n\tint ans = gr(0, chi);\n\tif (ans == 0) { cout << \"Bob\" << endl; }\n\telse { cout << \"Alice\" << endl; }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n - 1; ++i) {\n        int a, b; cin >> a >> b;\n        a--, b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    function<int(int, int)> dfs = [&] (int v, int p) {\n        int res = 0;\n        for(auto to : g[v]) {\n            if(to == p) continue;\n            res ^= dfs(to, v) + 1;\n        }\n        return res;\n    };\n\n    cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nvector<int>e[N];\nint f[N],n,i,x,y;\nvoid dfs(int x,int fa){\n\tfor(int i=0;i<e[x].size();++i)\n\t\tif(e[x][i]!=fa)dfs(e[x][i],x),f[x]^=f[e[x][i]]+1;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(i=1;i<n;++i)cin>>x>>y,e[x].push_back(y),e[y].push_back(x);\n\tdfs(1,0);\n\tcout<<(f[1]?\"Alice\\n\":\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/******************************************\n*    AUTHOR:         CHIRAG AGARWAL       *\n*    INSTITUITION:   BITS PILANI, PILANI  *\n******************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL; \ntypedef long double LD;\nconst int MAX=2e5+5;\nvector<int> adj[MAX];\n\nint st[MAX];\n\nvoid dfs(int s,int p)\n{\n    int cm=0;\n    for(int i=0;i<adj[s].size();i++)\n    {\n        int u=adj[s][i];\n        if(u!=p)\n        {\n            cm++;\n            dfs(u,s);\n            st[s]^=st[u];\n        }\n    }\n    st[s]^=1; \n    if(cm==1)\n    {\n        st[s]=0;\n    }  \n}\nint main() \n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    dfs(1,0);\n   // printf(\"%d\\n\",st[1]);\n    if(st[1]==1)\n    {\n        printf(\"Bob\\n\");\n    }\n    else\n    {\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxn = 100005;\nstruct Edge { int next, to; } e[maxn << 1];\nint head[maxn], tot;\nvoid Add(int u, int v) {\n\te[++tot] = (Edge){head[u], v}; head[u] = tot;\n}\nint N, sg[maxn];\nint dfs(int x, int y) {\n\tfor(int i = head[x]; i; i = e[i].next) {\n\t\tint to = e[i].to;\n\t\tif(to == y) continue;\n\t\tsg[x] ^= dfs(to, x) + 1;\n\t}\n\treturn sg[x];\n}\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 1, u, v; i < N; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tAdd(u, v); Add(v, u);\n\t}\n\tputs(dfs(1, -1) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\nvector<vector<int> > G;\nint calc(int pos, int pre) {\n\tset<int> s = { 1 };\n\tfor (int i : G[pos]) {\n\t\tif (i != pre) {\n\t\t\ts.insert(calc(i, pos));\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (s.count(ans)) ++ans;\n\treturn ans;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tG.resize(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y; --x, --y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tint ans = 0;\n\tfor (int i : G[0]) {\n\t\tans ^= calc(i, 0);\n\t}\n\tcout << (ans ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VL vector<long long>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nVI e[SIZE];\nint v[SIZE];\nvoid dfs(int x,int lt){\n    int now=0;\n    REP(i,SZ(e[x])){\n        int y=e[x][i];\n        if(y==lt)continue;\n        dfs(y,x);\n        now^=v[y]+1;\n    }\n    v[x]=now;\n}\nint main(){\n    DRI(N);\n    REP(i,N-1){\n        DRII(x,y);\n        e[x].PB(y);\n        e[y].PB(x);\n    }\n    dfs(1,1);\n    puts(v[1]?\"Alice\":\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nstring ans[2]={\"Bob\",\"Alice\"};\n\nint main()\n{\nll n;\ncin >> n ;\nvector<vector<ll>> g(n);\nrep(i, n-1)\n{\n  ll a, b;\n  cin >> a >> b;\n  g[a - 1].push_back(b - 1);\n  g[b - 1].push_back(a - 1); \n}\nll root=0;\nvector<vector<ll>> child(n);\nvector<ll> par(n);\nvector<ll> gu(n);\nqueue<ll> q;\nqueue<ll> qq;\nq.push(root);\npar[root]=-1;\n//親の定義と葉を見つける\nwhile(!q.empty()){\n  ll p=q.front();\n  q.pop();\n  if(g[p].size()==1 && p!=root){qq.push(p);}\n  for(auto r:g[p]){\n    if(r==par[p])continue;\n    par[r]=p;\n    q.push(r);\n  }\n}\nwhile(!qq.empty()){\n  ll p=qq.front();\n  qq.pop();\n  child[par[p]].push_back(p);//親に値を追加する\n  //根の時は例外処理\n  if(child[par[p]].size()==g[par[p]].size()){\n    //child[par[p]]に子の値が入ってる\n    for(auto r:child[par[p]]){\n      gu[par[p]]^=(gu[r]+1);\n    }\n  }\n  //全ての葉が親に追加し終わった\n  if(child[par[p]].size()==g[par[p]].size()-1 && par[p]!=root){\n    //child[par[p]]に子の値が入ってる\n    for(auto r:child[par[p]]){\n      gu[par[p]]^=(gu[r]+1);\n    }\n    qq.push(par[p]);\n  }\n}\ncout << ans[(bool)gu[0]] << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nconst int maxn = 1e5 + 5;\n\nvector<int> adj[maxn];\nint DFS(int u , int par){\n    int cnt = 0 , res = 0;\n    for(int c : adj[u]){\n        if(c == par)continue;\n        res ^= (DFS(c , u) + 1);\n    }\n    return res;\n}\nint n;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n;\n    for(int i = 1; i < n ; ++i){\n        int u,v;cin >> u >> v;\n        adj[u].pb(v);adj[v].pb(u);\n    }\n    puts(DFS(1,0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nbool b[100001];\nint x,y,n;\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if((int)v[i].size()%2&&b[i]){\n      ans++;\n    r(j,v[i].size()){\n      b[v[i][j]]=1;\n    }}\n  }\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tvvi E(N);\n\tfr(i,N-1){\n\t\tint x,y;cin>>x>>y;\n\t\tE[--x]<<--y;\n\t\tE[y]<<x;\n\t}\n\tauto f=[&](auto&f,int i,int p)->int{\n\t\tint x=0;\n\t\tfor(int j:E[i])if(j!=p){\n\t\t\tx^=f(f,j,i)+1;\n\t\t}\n\t\treturn x;\n\t};\n\tprint(f(f,0,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\nint64 N;\nvector<int64> G[112345];\n\nint64 dfs(int64 v, int64 p) {\n  int64 gr = 0;\n  multiset<int64> st;\n  REP(i, G[v].size()) {\n    if (G[v][i] == p) continue;\n    st.insert(dfs(G[v][i], v));\n  }\n  if (st.size() == 0) return 0;\n  if (st.size() == 1) {\n    return *st.begin()+1;\n  } else {\n    for (auto &x : st) {\n      gr ^= x;\n    }\n  }\n  return gr;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i, N-1) {\n    int64 x, y;\n    cin >> x >> y;\n    x--; y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if (dfs(0, -1)) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N,x,y,grundy[100010],visited[100010] = {0};\nvector<vector<int>> v(100010);\n\nint dfs(int n){\n\tvisited[n] = 1;\n\tint g = 0;\n\tif(n!=1 && v[n].size()==1) return 0;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tif(n!=1 && v[n].size()==2) return dfs(s)+1;\n\t\t\telse{\n\t\t\t\tg ^= dfs(s);\n\t\t\t}\n\t\t}\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> x >> y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tcout << (dfs(1)==0? \"Bob\":\"Alice\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\t\t\t\t//Written by ThiDaiLoc\nusing namespace std;\t\t\t\t//Team Three Wolves\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pll;\n#define fu(i,a,b)   for(ll i=a;i<b;i++)\n#define fd(i,b,a)   for(ll i=b;i>=a;i--)\n#define ms(a,x)     memset(a, x, sizeof a)\n#define prec(n)     fixed<<setprecision(n)\n#define pb(i)       push_back(i)\n#define popb()      pop_back()\n#define sc(a)       cin>>a\n#define sc2(a,b)    cin>>a>>b\n#define pr(a)       cout<<a<<\" \"\n#define pr2(a,b)    cout<<a<<\" \"<<b<<\" \"\n#define lowb(a,n,x) lower_bound(a,a+n,x) -a\n#define lowb2(a,x)  lower_bound(a.begin(),a.end(),x) -a.begin()\n#define all(x)      (x).begin(), (x).end()\n#define sz(a)       (ll)a.size()\n#define le(s)       (ll)s.length()\t\t\t\t\t\t\n#define re          return \t\n#define\tmp(a,b)     make_pair(a,b)\n#define se          second\n#define fi          first \n#define debug(x)    cerr << #x << \" = \" << x << endl\n#define INPUT       freopen(\"locin.txt\", \"r\", stdin)\n#define OUTPUT      freopen(\"locout.txt\", \"w\", stdout)\nvoid inline minize(ll& a,ll b){a=(a>b?b:a);};\nvoid inline maxize(ll& a,ll b){a=(a<b?b:a);};\ndouble const eps = 1e-6;\nll const Base=1e9+7,oo=1e17,MAXN=1e5;\nll n;\nbitset <MAXN+5> came;\nvi dske[MAXN+5];\n\nll DFS(ll cur){\n\tll res=0,x,cntchild=0;\n\tcame[cur]=1;\n\t\n\tfu(i,0,sz(dske[cur])){\n\t\tx=dske[cur][i];\n\t\tif(came[x])continue;\n\t\tcntchild++;\n\t\tres^=(DFS(x)+1);\n\t}\n\t//if(cntchild==1)res++;\n\t//debug(cur); debug(res);\n\tre res;\n}\n\nll Solves(){\n//\tINPUT;\n\tll x,k,cnt=0,ans=0,a,b;\n\tcame.reset();\n\t// PROCESSING IN HERE\n\tsc(n);\n\tfu(i,0,n-1){\n\t\tsc2(a,b);\n\t\tdske[a].pb(b);\n\t\tdske[b].pb(a);\n\t\t\n\t}\n\t\n\tif(DFS(1))pr(\"Alice\");\n\telse pr(\"Bob\");\n\t\n\tre 0;\n\t// Hack it if you can :)\n}\nint main(){\n\t\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tSolves();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector <int> des[1000100];\nint sg(int s,int pre=0)\n{\n\tint ans=0;\n\tfor (int k=0;k<des[s].size();k++) if (des[s][k]!=pre)\n\t{\n\t\tans^=sg(des[s][k],s)+1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tdes[u].push_back(v);des[v].push_back(u);\n\t}\n\tif (sg(1)) printf(\"Alice\\n\");else printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nbool flag[MAX_N];\n\nint dfs(int u)\n{\n    flag[u] = true;\n    int ans = 0;\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            ans ^= (dfs(G[u][i]) + 1);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1);\n        G[b-1].pb(a-1);\n    }\n    rep(i,n){\n        flag[i] = false;;\n    }\n    int res = dfs(0);\n    if(res){\n        cout << \"Alice\\n\";\n    }else{\n        cout << \"Bob\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100010\nint n,g[N],ans;\nvector<int>f[N],d[N];\nbool s[N];\nbool b[N];\nvoid dfs2(int x,int t){\n    int i;\n    for (i=0;i<f[x].size();i++) t^=g[f[x][i]];\n    s[t]=1;\n    for (i=0;i<f[x].size();i++) dfs2(f[x][i],t^g[f[x][i]]);\n}\n     \nvoid dfs1(int x){\n\tb[x]=1;\n    int i;\n    for (i=0;i<f[x].size();i++) dfs1(f[x][i]);\n    memset(s,0,sizeof(s));\n    dfs2(x,0);\n    while (s[g[x]]) g[x]++;\n}\nvoid ac(int x){\n\tb[x]=1;\n\tfor (int i=0;i<d[x].size();i++) \n\t\tif (!b[d[x][i]])\n\t\t\tf[x].push_back(d[x][i]),ac(d[x][i]);\n}\nint main(){\n    int n,i,j;\n    scanf(\"%d\",&n);\n    for (i=1;i<n;i++){\n    \tint x,y;\n    \tscanf(\"%d%d\",&x,&y);\n    \td[x].push_back(y);\n    \td[y].push_back(x);\n    }\n    ac(1);\n    for (i=0;i<f[1].size();i++){\n        dfs1(f[1][i]);\n        ans^=g[f[1][i]];\n    }\n    if (ans) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rint register int\nusing namespace std;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nint n;\nvector<int> g[233333];\n\ninline int dfs(int u, int fat) {\n  int now = 0;\n  for (int v : g[u])\n    if (v != fat)\n      now ^= 1 + dfs(v, u);\n  return now;\n}\n\nmain(void) {\n  read(n);\n  for (int i = 2; i <= n; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y); g[y].push_back(x);\n  }\n  puts( dfs(1, 0) ? \"Alice\" : \"Bob\" );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nvector<int> tr[100001];\n\nint go(int v = 1, int p = 0){\n\tint an = 0;\n\tf(i, 0, tr[v].size()){\n\t\tint u = tr[v][i];\n\t\tif (u == p)continue;\n\t\tan ^= 1 + go(u, v);\n\t}\n\treturn an;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tf(i, 1, n){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ttr[a].push_back(b);\n\t\ttr[b].push_back(a);\n\t}\n\tprintf(\"%s\\n\", go() ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        int odd = 0;\n        FORE(e, graph[0]) odd += (dfs(e, 0) + 1) % 2;\n        if (odd == 0) {\nassert(false);\n        } else if (odd == 3) {\nassert(false);\n        } else if (odd == 1) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 2) {\n            cout << \"Alice\" << endl;\n        } else {\n            assert(false);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    i64 N;\n    cin >> N;\n    vector<vector<i64>> graph(N);\n    rep(i,0,N-1){\n        int x,y;\n        cin >> x >> y;\n        --x;\n        --y;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n\n    function<int(int,int)> rec=[&](int u,int p){\n        if(p!=-1 and graph[u].size()==1) return 0;\n        int res=0;\n        for(auto v:graph[u]){\n            if(v==p) continue;\n            res^=rec(v,u)+1;\n        }\n        return res;\n    };\n\n    if(rec(0,-1)) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n \n#define N (ll)(1e6+3)\n#define INF (ll)(1e18+3)\n#define MOD (ll)(1e9+7)\n \n#define ll long long\n#define rep(i,a,n) for(ll i = a; i < n; i++)\n#define per(i,a,n) for(ll i = n-1; i >= a; i--)\n \n//using namespace __gnu_pbds;\nusing namespace std;\n \n// typedef\n// tree<\n//     pair<ll,ll>,\n//     null_type,\n//     less<pair<ll,ll>>,\n//     rb_tree_tag,\n//     tree_order_statistics_node_update>\n// ordered_set;\n \n \nll n;\nll par[N];\nvector<ll> g[N];\nll d[N];\n \nvoid dfs(ll u, ll p) {\n    vector<ll> v;\n \n    rep(i,0,g[u].size()) {\n        ll ch = g[u][i];\n        if (ch == p) continue;\n        dfs(ch,u);\n        v.push_back(d[ch]);\n    }\n \n    if (v.size() == 1)\n        d[u] = v[0]+1;\n    else {\n        ll mask = 0;\n        rep(i,0,v.size()) {\n            mask ^= v[i];\n        }\n        d[u] = mask;\n    }\n}\n \nvoid solve() {\n    cin >> n;\n    rep(i,0,n-1) {\n        ll a, b; cin >> a >> b; a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0,0);\n    if (d[0]) {\n        cout << \"Alice\" << endl;\n    }\n    else {\n        cout << \"Bob\" << endl;\n    }\n}\n \n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<cstdlib>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cassert>\n#include<ctime>\n#include<functional>\n#include<deque>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 0x3f3f3f3f;\nconst double PI = acos(-1.0);\nint kase = 0;\nint n, m;\nconst int maxn = 1e5 + 10;\nvector<int> G[maxn];\n\n\nint dfs(int u, int pa)\n{\n\tint sg = 0;\n\tfor (int i = 0; i < G[u].size(); i++)\n\t{\n\t\tint v = G[u][i];\n\t\tif (v != pa)\n\t\t\tsg = sg ^ (dfs(v, u) + 1);\n\t}\n\treturn sg;\n}\n\nint main() {\n\twhile(cin>>n)\n\t{\n\t\tfor (int i = 0; i <= n; i++)  G[i].clear();\n\t\tfor (int i = 0; i < n-1; i++)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tif (dfs(1, -1)) printf(\"Alice\\n\");\n\t\telse printf(\"Bob\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> g;\n\nint grundy(int cur, int parent)\n{\n    int ret = 0;\n    for (auto& n : g[cur]) {\n        if (n == parent)\n            continue;\n        ret ^= grundy(n, cur) + 1;\n    }\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    g.resize(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    int g = grundy(0, -1);\n\n    cout << (g == 0 ? \"Bob\" : \"Alice\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAXN=100005;\n\nint N;\nvector<int> adj[MAXN];\nint sg[MAXN];\n\nvoid dfs(int u,int fa=0)\n{\n\tfor(auto v:adj[u])\n\t{\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tdfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tdfs(1);\n\tif(sg[1])\n\t\tputs(\"Alice\");\n\telse\n\t\tputs(\"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long double ldo;\n\n#define pb push_back\nconst int MAX = 1234567;\nint n, x, res;\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tres = 0;\n\tfor (auto i : g[v])\n\t\tif (i != r)\n\t\t\tres ^= dfs (i, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tx = dfs (0,-1);\n\n\tcout << (x==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nll d[1000000];\n\nvoid addedge(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\n//根付き木を作る。parentVectorに親nodeの番号が入る。\n//parentVector[root] = -1\n//treeRankVectorにはnodeのrankが入る。rootのrankは0\nvector<ll> par;\nvector<ll> treeRank;\nvoid makeRootedTree(vector<ll> &parentVector, vector<ll> &treeRankVector, ll vecSize, ll root) {\n    parentVector = vector<ll>(vecSize);\n    treeRankVector = vector<ll>(vecSize);\n    assert(root < (ll)parentVector.size());\n    parentVector[root] = -1;\n    treeRankVector[root] = 0;\n    queue<ll> que;\n    que.push(root);\n    while (!que.empty()) {\n        ll node = que.front();\n        que.pop();\n        REP (i, 0, G[node].size()) {\n            edge e = G[node][i];\n            if (e.to != parentVector[node]) {\n                parentVector[e.to] = node;\n                treeRankVector[e.to] = treeRankVector[node] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    V = N;\n    REP(i, 0, N - 1) {\n        ll x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        addedge(x, y, 1);\n        addedge(y, x, 1);\n    }\n    makeRootedTree(par, treeRank, N, 0);\n    vector<ll> grundy;\n    REP(i, 0, G[0].size()) {\n        queue<ll> que;\n        vector<ll> rank;\n        que.push(G[0][i].to);\n        rank.push_back(1);\n        while (!que.empty()) {\n            ll node = que.front();\n            que.pop();\n            REP(j, 0, G[node].size()) {\n                edge e = G[node][j];\n                if (e.to != par[node]) {\n                    rank.push_back(treeRank[e.to]);\n                    que.push(e.to);\n                }\n            }\n        }\n        sort(rank.begin(), rank.end());\n        ll tmpgr = 0;\n        ll num = rank[0];\n        ll tmp = 1;\n        REP(i, 1, rank.size()) {\n            if (rank[i] != num) {\n                if (tmp == 1) {\n                    tmpgr++;\n                }\n                tmp = 1;\n                num = rank[i];\n            } else {\n                tmp++;\n            }\n        }\n        if (tmp == 1) {\n            tmpgr++;\n        }\n        grundy.push_back(tmpgr);\n    }\n    ll ans = 0;\n    REP(i, 0, grundy.size()) {\n        ans ^= grundy[i];\n    }\n    if (ans != 0) {\n        cout << \"Alice\" << endl;\n    } else {\n        cout << \"Bob\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n    int N;\n    \n    cin >> N;\n    vector<vector<int> > adjlists(N);\n\n    for(int i=0;i<N-1;i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n\n        adjlists[u].push_back(v);\n        adjlists[v].push_back(u);\n    }\n    /*\n    for(int i=0;i<N;i++){\n        cout << i << \": \";\n        for(int j=0;j<adjlists[i].size();j++){\n            cout << adjlists[i][j] << \" \";\n        }\n        cout << endl;\n    }*/\n\n    // bfs\n    queue<int> bfs;\n    vector<bool> seen(N, false);\n    vector<vector<int> > children(N);\n    vector<int> preorder;\n    bfs.push(0);\n    seen[0] = true;\n    while(!bfs.empty()){\n        int cur = bfs.front();\n        bfs.pop();\n\n        preorder.push_back(cur);\n\n        for(int j=0;j<adjlists[cur].size();j++){\n            int nxt = adjlists[cur][j];\n            if(!seen[nxt]){\n                children[cur].push_back(nxt);\n                seen[nxt] = true;\n                bfs.push(nxt);\n            }\n        }\n    }\n\n\n    vector<int> values(N, 0);\n    for(int i=N-1;i>=0;i--){\n        int cur = preorder[i];\n        for(int j=0;j<children[cur].size();j++){\n            int child = children[cur][j];\n            values[cur] ^= (values[child] + 1);\n        }\n    }\n\n    if(values[0] == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\nint const nmax = 100000;\nstd::vector<int> g[1 + nmax];\nint nimber[1 + nmax];\n\nvoid dfs(int node, int parent) {\n  for(int h = 0; h < g[node].size(); h++) {\n    int to = g[node][h];\n    if(to != parent) {\n      dfs(to, node);\n      nimber[node] ^= nimber[to] + 1;\n    }\n  }\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  for(int i = 1;i < n; i++) {\n    int x, y;\n    std::cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  if(nimber[1] == 0)\n    std::cout << \"Bob\";\n  else\n    std::cout << \"Alice\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[100009], n, x, y;\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x]++, a[y]++;\n\t}\n\tif(a[1] == 1){\n\t\tprintf(\"Alice\\n\");\n\t}else{\n\t\tif(n&1){\n\t\t\tprintf(\"Bob\\n\");\n\t\t}else{\n\t\t\tprintf(\"Alice\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "5\n1 2\n2 3\n1 4\n4 5"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);++i)\n#define rep11(i,n) for(int i=1;i<(int)(n);++i)\n#define repo(i,o,n) for(int i=o;i<(int)(n);++i)\n#define repm(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define sperase(v,n) (v).erase(remove(all(v), n), (v).end())\n#define vdelete(v) (v).erase(unique(all(v)), (v).end())\n#define pb(n) push_back(n)\n#define mp make_pair\n#define MOD 1000000007\n#define INF LONG_LONG_MAX\n\nint n,x,y,memo[100000],cnt[100000],sum;\nvector<int> v[100000];\nqueue<int> que;\n\nsigned main() {\n    cin >> n;\n    rep(i,n) cnt[i]++;\n    rep(i,n-1) {\n        cin >> x >> y;\n        --x, --y;\n        v[x].pb(y);\n        v[y].pb(x);\n        memo[x]++;\n        memo[y]++;\n    }\n    rep(i,n) if (memo[i] == 1) que.push(i), memo[i]--;\n    while(que.size()) {\n        int qf = que.front();que.pop();\n        for(auto i : v[qf]) {\n            if (memo[i]) {\n                cnt[i] += cnt[qf];\n                memo[i]--;\n                if (memo[i] == 1) que.push(i), memo[i]--;\n            }\n        }\n    }\n    for(auto i : v[0]) sum += cnt[i]%2;\n    if (sum%2) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint x, y;\n\nint main()\n{\n\tcin >> n;\n\tint a, b;\n\tx = y = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tif (a > b)\n\t\t{\n\t\t\tint tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\tif (a == 1)\n\t\t\tx++;\n\t\telse\n\t\t\ty++;\n\t}\n\n\tif (x == 0)\n\t\tcout << \"Bob\" << endl;\n\telse if (x == 1)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t{\n\t\tint xx = x % 2;\n\t\tint yy = y % 2;\n\t\tif (xx + yy == 1)\n\t\t\tcout << \"Alice\" << endl;\n\t\telse\n\t\t\tcout << \"Bob\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nvector<int>v[N];\ninline int dfs(int k,int fa=0) {\n\tint ans=0;\n\tfor (int t:v[k])\n\t\tif (t!=fa)\n\t\t\tans^=dfs(t,k)+1;\n\treturn ans;\n}\nint main()\n{\n\tint n=gi(),a,b;\n\twhile (--n) v[a=gi()].push_back(b=gi()),v[b].push_back(a);\n\tputs(dfs(1)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <complex>\n#include <ctime>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\n#define REP(i,s,t) for(int i=(s);i<(t);i++)\n#define FILL(x,v) memset(x,v,sizeof(x))\n\nconst int INF = (int)1E9;\n#define MAXN 100005\n\nint N;\nVI adj[MAXN];\nint dfs(int x, int p) {\n  int sg = 0;\n  REP(i,0,adj[x].size()) {\n    int y = adj[x][i];\n    if (y == p) continue;\n    sg ^= dfs(y, x) + 1;\n  }\n  return sg;\n}\nint main() {\n  cin >> N;\n  REP(i,0,N-1) {\n    int x,y;\n    scanf(\"%d%d\", &x, &y); x--; y--;\n    adj[x].push_back(y);\n  }\n  puts(dfs(0, -1) ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define ll long long\n#define maxn 100002\n#define pb push_back\nusing namespace std;\n\nvector<int> a[maxn];\nbool dfs(int u, int par){\n\tif(u==1&&a[u].size()==2) return true;\n\tif(u!=1 && a[u].size()==3) return true;\n\tint cnt = 0;\n\tint v;\n\tfor(int i=0;v= a[u][i];i++){\n\t\tif(v!=par){\n\t\t\tif(dfs(v,u)==false){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tif(cnt == 0&& a[u].size()==2) return false;\n\tif(cnt%2==1) return true;\n\treturn false;\n}\nmain(){\n\tint n,v,u;\n\tcin  >> n;\n\tFor(i,1,n-1){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\ta[u].pb(v);\n\t\ta[v].pb(u);\t\t\n\t}\n\tFor(i,1,n){\n\t\ta[i].pb(0);\n\t}\n\tif(dfs(1,1)){\n\t\tcout << \"Alice\";\n\t}\telse\t{\n\t\tcout << \"Bob\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2&&false) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int odd = 0;\n        FORE(e, ch) odd += e % 2;\n        cout << (((odd & 1) ^ (oneCnt & 1)) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\n\nint n, g[MAXN], nxt[MAXN << 1], to[MAXN << 1], edgeSize;\n\nvoid addEdge(int u, int v){\n\tnxt[++ edgeSize] = g[u];\n\tto[g[u] = edgeSize] = v;\n}\nint dfs(int x, int f){\n\tint p, s = 0;\n\tfor(p = g[x]; p; p = nxt[p])\n\t\tif(to[p] != f)\n\t\t\ts ^= dfs(to[p], x) + 1;\n\treturn s;\n}\nint main(){\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v), addEdge(v, u);\n\t} printf(\"%s\\n\", dfs(1, -1) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nvint G[111111];\n\nint dp[111111];\nvoid dfs(int v,int p){\n    int &X=dp[v];\n    for(auto u:G[v]){\n        if(u==p)continue;\n        dfs(u,v);\n        X^=dp[u];\n    }\n\n    if(p!=-1)X++;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    dfs(0,-1);\n    if(dp[0])cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef long double LD;\n\nint N,a[100010],l[100010];\nvector<int> g[100010];\n\nvoid dfs(int nod, int f){\n    for (int nxt : g[nod])\n        if (nxt!=f){\n            dfs(nxt,nod);\n            l[nod]^=(l[nxt]+1);\n        }\n}\n\nint main(){\n    cin >> N;\n\n    int x,y,i;\n    for (i=1; i<N; i++){\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    dfs(1,0);\n    cout << (l[1] ? \"Alice\" : \"Bob\") << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<iomanip>\n#include<set>\n#include<bitset>\n#define rep(index,num) for(int index=0;index<num;index++)\n#define rep1(index,num) for(int index=1;index<=num;index++)\n#define brep(index,num) for(int index=num-1;index>=0;index--)\n#define brep1(index,num) for(int index=num;index>0;index--)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=1e+18+1;\nint INF=1e+9+1;\nvint adj[100001];\nint p[100001];\nbool visited[100001]={};\nvint ko[100001];\nint depthmax=0;\nvint edgedepth[100001];\nvoid dfs(int u,int depth){\n\tvisited[u]=1;\n\tedgedepth[depth].push_back(u);\n\tdepthmax=max(depthmax,depth);\n\tint flag=0;\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(visited[v]==0){\n\t\t\tflag=1;\n\t\t\tp[v]=u;\n\t\t\tko[u].push_back(v);\n\t\t\tdfs(v,depth+1);\n\t\t}\n\t}\n}\nint main(){\n\tint N;\n\tint a[100001],b[100001];\n\tscan(N);\n\trep(i,N-1){\n\t\tscan(a[i]>>b[i]);\n\t\ta[i]--; b[i]--;\n\t\tadj[a[i]].push_back(b[i]);\n\t\tadj[b[i]].push_back(a[i]);\n\t}\n\tp[0]=-1;\n\tdfs(0,0);\n\tint grundy[100001];\n\tbrep(d,depthmax+1){\n\t\trep(i,edgedepth[d].size()){\n\t\t\tint v=edgedepth[d][i];\n\t\t\tgrundy[v]=0;\n\t\t\trep(j,ko[v].size()){\n\t\t\t\tint u=ko[v][j];\n\t\t\t\tgrundy[v]^=(grundy[u]+1);\n\t\t\t}\n\t\t}\n\t}\n\tif(grundy[0]==0) prin(\"Bob\");\n\telse prin(\"Alice\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link renamelink\n#define next renamenext\n#define prev renameprev\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string& fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 1e5 + 100;\n\nint n;\nvector<int> G[N];\nint val[N];\n\nvoid dfs(int u, int p) {\n  set<int> st;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (v == p) continue;\n    dfs(v, u);\n    st.insert(val[v]);\n  }\n  int& res = val[u];\n  while (st.count(res)) ++res;\n}\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n  dfs(0, -1);\n  int cnt = 0;\n  for (int i = 0; i < G[0].size(); i++) {\n    int u = G[0][i];\n    if (val[u] == 0) ++cnt;\n  }\n  if (n >= 100) {\n    puts(\"Alice\");\n    return 0;\n  }\n  if ((((int)G[0].size() - cnt) & 1)) {\n    puts(\"Alice\");\n  } else {\n    puts(\"Bob\");\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nint n;\nvector<int> adj[maxn + 5];\n\nint dfs(int x, int f = -1)\n{\n\tint ret = 0;\n\tfor (auto y : adj[x]) if (y != f)\n\t{\n\t\tret ^= dfs(y, x) + 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n - 1)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v), --u, --v;\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tputs(dfs(0) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1ll << 60;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\n#define asn ans\nbool dbg = false;\n\nint N;\nvi G[101010];\n\nint f(int idx, int par) {\n    int ret = 0;\n    for (auto& nxt : G[idx]) {\n        if (nxt != par) {\n            ret ^= (f(nxt, idx) + 1);\n        }\n    }\n    return ret;\n}\n\nvoid solve() {\n    if (f(0, -1))\n        cout << \"Alice\" << endl;\n    else\n        cout << \"Bob\" << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    FOR(N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].eb(b);\n        G[b].eb(a);\n    }\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nint dfs(const auto& G, auto cur, auto pre) {\n  return accumulate(begin(G[cur]), end(G[cur]), 0, [&](auto g, auto to) {return to!=pre ? g^(dfs(G, to, cur)+1) : g;});\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Graph G(N);\n  for(auto i = 1; i < N; ++i) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if(dfs(G,0,0)) cout << \"Alice\" << endl;\n  else           cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nstruct edge{\n\tint d,nex;\n}e[200010];\nint sg[100010],n,efree,q[100010],mex,a[100010],sg1[100010];\nbool f,fl;\ntemplate<class T>\ninline void read(T&a){\n\tchar c=getchar();\n\tfor(a=0;c<'0'||c>'9';c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';\n}\ninline void add(int x,int y){e[++efree]=(edge){y,q[x]};q[x]=efree;}\nvoid dfs(int x,int y,int d){\n\tfor(int i=q[x];i;i=e[i].nex)\n\t\tif(e[i].d!=y)dfs(e[i].d,x,d+1),a[x]+=a[e[i].d];\n\ta[x]++;sg[a[x]]++;sg1[d]++;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x),read(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0,1);\n\tfor(int i=1;i<n;i++)\n\t\tif(sg[i]&1)f=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(sg1[i]&1)fl=1;\n\tif(!fl||!f)puts(\"Bob\");\n\telse puts(\"Alice\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dfs(VVI& G, int u, int p = -1){\n  int res = 0;\n  for(int to: G[u])\n\tif(to != p)\n\t  res ^= dfs(G, to, u) + 1;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  VVI G(N);\n  REP(i,N-1){\n\tint u, v;\n\tcin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].EB(v);\n\tG[v].EB(u);\n  }\n  cout << (dfs(G, 0)==0?\"Bob\": \"Alice\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <stdio.h>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\n#define debug(args...) {vector<string> _v = split(#args, ','); err(_v.begin(), args); puts(\"\");}\nvector<string> split(const string& s, char c) {vector<string> v; stringstream ss(s); string x; while (getline(ss, x, c)) v.push_back(x); return v;}\nvoid err(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; err(++it, args...);}\n\n#define all(x)  (x).begin(),(x).end()\n#define tr(c, it)   for(auto it=c.begin(); it!=c.end(); it++)\n#define clr(a, b)   memset(a, b, sizeof(a))\n#define forn(i, n)   for(int i=0; i<n; i++)\n\nconst double eps = 1e-5;\nconst int INF = 0x3f3f3f3f;\n\n\nconst int N = 100010;\n\nint head[N], e;\nstruct E{\n    int v, next;\n}edge[N << 1];\n\nvoid addedge(int u, int v){\n    edge[e].v = v, edge[e].next = head[u];\n    head[u] = e++;\n}\n\nint n;\nint dp[N];\n\nint dfs(int u, int f)\n{\n    int val = 0;\n    for(int i=head[u]; ~i; i=edge[i].next)\n    {\n        int v = edge[i].v;\n        if(v == f) continue;\n\n        val ^= (dfs(v, u) + 1);\n    }\n    return dp[u] = val;\n\n}\n\n\nint main()\n{\n#ifdef LOCAL\n    freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n#endif\n\n    //scanf(\"%d\",&T);\n\n\n    while(~scanf(\"%d\",&n))\n    {\n        clr(head, -1), e = 0;\n        clr(dp, 0);\n        for(int i=1; i<n; ++i)\n        {\n            int u, v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(u, v);\n            addedge(v, u);\n        }\n\n        dfs(1, -1);\n\n        if(dp[1]) puts(\"Alice\");\n        else puts(\"Bob\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define along long(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(long long i=(a);i<(b);++i)\n#define per(i,a,b) for(long long i=b-1long long;i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll d[100100];\nvector<vector<ll> > vv;\n\nvoid dfs(ll a, ll p, ll h){\n\td[h]++;\n\tif(vv[a].sz==1&&p!=-1)return;\n\trep(i,0,vv[a].sz){\n\t\tif(vv[a][i]==p)continue;\n\t\tdfs(vv[a][i],a,h+1);\n\t}\n}\n\nint main() {\n\tll n;\n\tcin>>n;\n\tclr(d,0);\n\tvector<vector<ll> > vv_(n,vector<ll>());\n\tvv = vv_;\n\trep(i,0,n-1){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tvv[a].pb(b);\n\t\tvv[b].pb(a);\n\t}\n\tdfs(0,-1,0);\n\tll flag = 1;\n\trep(i,1,100050){\n\t\tif(d[i]%2==1)flag = 0;\n\t}\n\tif(flag==1){\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst int INF=1e9;\nconst long long LINF=1e18;\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nstd::vector<int> edge[100005];\nint f(int pa,int idx){\n  int res=0;\n  for(int p:edge[idx]){\n    if(p==pa)continue;\n    res^=f(idx,p);\n  }\n  return res+1;\n}\n//main\nsigned main(){\n  int N;cin>>N;\n  for(int i=1;i<N;i++){\n    int a,b;cin>>a>>b;a--;b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  if(f(-1,0)==1)fin(\"Bob\");\n  fin(\"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=100005;\nint n,sg[N];\nvector <int> e[N],v[N];\nvoid solve(int x,int pre){\n\tv[x].push_back(0);\n\tv[x].push_back(1e9);\n\tfor (auto y : e[x])\n\t\tif (y!=pre){\n\t\t\tsolve(y,x);\n\t\t\tv[x].push_back(sg[y]);\n\t\t}\n\tsort(v[x].begin(),v[x].end());\n\treverse(v[x].begin(),v[x].end());\n\twhile (1){\n\t\tint now=v[x].back();\n\t\tv[x].pop_back();\n\t\tif (v[x].back()-now>1){\n\t\t\tsg[x]=now+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (!v[x].empty())\n\t\tv[x].pop_back();\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tsolve(1,0);\n\tint t=0;\n\tfor (auto y : e[1])\n\t\tt^=sg[y];\n\tputs(t?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint Grundy[100050];\nint N;\nvector<int> pathes[100500];\nint parent[100050];\n\nvoid bfs(int from) {\n    Grundy[from] = 0;\n    for(int i = 0; i < pathes[from].size(); i++) {\n        int to = pathes[from][i];\n        if(to == parent[from]) continue;\n        parent[to] = from;\n        bfs(to);\n        Grundy[from] ^= (Grundy[to] + 1);\n    }\n    return;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 1; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        pathes[x].push_back(y);\n        pathes[y].push_back(x);\n    }\n    parent[1] = -1;\n    bfs(1);\n    if(Grundy[1] == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long int lld;\n\nconst lld mod = 1e9+7;\nconst lld INF = 1e9;\nconst lld MAXN = 1e5;\n\nint main()\n{\n\tint n,x[MAXN] = {0},y[MAXN] = {0};\n\tint deg[MAXN] = {0};\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tdeg[x[i]-1]++;\n\t\tdeg[y[i]-1]++;\n\t}\n\n\n\n\tint sum = 0;\n\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tsum ^= deg[i];\n\t}\n\n\tcout << sum << endl;\n\n\tif (sum %2 != 0)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}else\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\n//作者:中国江苏南京丁天行\nusing namespace std;\n//数组不要开小了\n//数组不要开反了\nint n,f[2][100005];\nvector<int> v[100005];\nint cty(int x,int p){\n    int cnt[2]={};\n    for(int i=0;i<v[x].size();i++){\n            if(v[x][i]==p) continue;\n            cnt[cty(v[x][i],x)]++;\n    }\n    if(cnt[1]&1) return 1;\n    if(cnt[0]&1) return 1;\n    if(cnt[0]%2==1&&cnt[1]%2==1) return 1;\n    return 0;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].pb(y),v[y].pb(x);\n    }\n    if(cty(1,0))puts(\"Alice\");\n    else puts(\"Bob\");\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nostream &operator<<(ostream &os, pair<ll, ll>&p){\n  return os << p.first << \" \" << p.second;\n}  \nll dfs(ll k,vector<vector<ll>>&g,ll par){\n  ll now=0;\n  for(auto to:g[k]){\n    if(to != par){\n      now^=dfs(to,g,k); \n    }\n  }\n  return now+1;\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll x,y;cin>>x>>y;x--;y--;\n    g[x].PB(y);\n    g[y].PB(x);\n  }\n  auto k=dfs(0,g,-1);\n  ans(k==1,\"Bob\",\"Alice\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint D[101010];\nint nd[101010];\n\nvoid dfs(int cur,int pre,int dep) {\n\tD[cur]=dep;\n\tnd[D[cur]]++;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,dep+1);\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tdfs(0,0,0);\n\tfor(i=1;i<=N;i++) if(nd[i]%2==1) return _P(\"Alice\\n\");\n\t_P(\"Bob\\n\");\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<utility>\n#include<algorithm>\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define For(i,x,y) for(int i=((int)x);i<=((int)y);i++)\n#define Dep(i,y,x) for(int i=((int)y);i>=((int)x);i--)\n#define Rep(i,x) for (int y,i=head[x];i;i=E[i].nxt)\nusing namespace std;\n\nconst int inf=1000000009;\n\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\n\nint rd() {\n\tchar c=getchar(); int t=0,f=1;\n\twhile (!isdigit(c)) f=(c=='-')?-1:1,c=getchar();\n\twhile (isdigit(c)) t=t*10+c-48,c=getchar(); return t*f;\n}\nvoid wt(int x) {\n\tif (x<0) putchar('-'),wt(-x);\n\telse { if (x>9) wt(x/10); putchar(x%10+48); }\n}\n\nconst int N=100000+35;\n\nint sg[N],n;\nvector<int>E[N];\n\nvoid dfs(int x,int fa) {\n\tint y;\n\tFor (i,0,E[x].size()-1)\n\t\tif ((y=E[x][i])!=fa) {\n\t\t\tdfs(y,x);\n\t\t\tsg[x]^=(sg[y]+1);\n\t\t}\n}\n\nint main() {\n\tn=rd();\n\tFor (i,2,n) {\n\t\tint x=rd(),y=rd();\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n\tdfs(1,-1);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y; cin >> x >> y, x--, y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  V<> par(n, -1);\n  queue<int> que;\n  par[0] = n; que.push(0);\n  while (!que.empty()) {\n    int v = que.front(); que.pop();\n    for (int w : g[v]) if (par[w] == -1) {\n      par[w] = v; que.push(w);\n    }\n  }\n  VV<> ch(n);\n  for (int i = 1; i < n; i++) ch[par[i]].push_back(i);\n  function<int(int)> dfs= [&](int v) {\n    int res = 0;\n    for (int w : ch[v]) {\n      res ^= dfs(w) + 1;\n    }\n    return res;\n  };\n  cout << (dfs(0) ? \"Alice\" : \"Bob\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 200005;\nint n,ehead[maxn],ecnt,f[maxn];\nstruct edge {\n\tint u,v,next;\n}edg[maxn];\nvoid add(int u,int v) {\n\tedg[++ecnt]=(edge){u,v,ehead[u]};\n\tehead[u]=ecnt;\n\tedg[++ecnt]=(edge){v,u,ehead[v]};\n\tehead[v]=ecnt;\n}\nvoid solve(int u,int fa)\n{\n\tfor (int v,j=ehead[u];j;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa)\n\t\tsolve(v,u),f[u]^=f[v]+1;\n}\nint main()\n{\n\t#ifdef LOCAL_JUDGE\n\t\tfreopen(\"tree.in\",\"r\",stdin);\n\t\tfreopen(\"tree.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor (int u,v,i=1;i<n;i++)\n\t\tscanf(\"%d %d\",&u,&v),add(u,v);\n\tsolve(1,0);printf(\"%s\",f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 1100\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\n\nint n, sg[N];\nint tot, fir[N], nxt[N << 1], to[N << 1];\n\ninline void add(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nvoid dfs(int u, int p = 0) {\n    for (int i = fir[u], v; i; i = nxt[i]) {\n        v = to[i];\n        if (v == p) continue;\n        dfs(v, u);\n        sg[u] xor_eq sg[v] + 1;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1, u, v; i < n; ++i)\n        scanf(\"%d%d\", &u, &v), add(u, v), add(v, u);\n    dfs(1);\n    cout << (sg[1] ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n// #include \"../debug/debug.cpp\"\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nVV<ll> edges;\n\nll dfs(ll cur, ll pre) {\n    ll ret = 0, cnt_child = 0;\n    for(ll nxt : edges[cur]) {\n        if(nxt == pre) continue;\n        ret ^= dfs(nxt, cur);\n        cnt_child++;\n    }\n    if(cnt_child == 0) return 0;\n    if(cnt_child == 1) return ret + 1;\n    return ret;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    edges.resize(N);\n    for(ll i = 1; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        x--; y--;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n    cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::vector<int>G[100010];\nint SG[100010];\nvoid dfs(int x,int fa=-1){for(int i:G[x])if(i!=fa)dfs(i,x),SG[x]^=SG[i]+1;}\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),x,y;\n\tfor(int i=1;i<n;++i)x=gi(),y=gi(),G[x].push_back(y),G[y].push_back(x);\n\tdfs(1);\n\tif(SG[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 52, B = 50, oo = 1e18 + 100, M = 1e9 + 7, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2;\n\n\nint dp[N];\nvi g[N];\n\n\nvoid dfs(int v, int p = -1)\n{\n    for (int u : g[v])\n    {\n        if (u == p)\n            continue;\n\n        dfs(u, v);\n        dp[v] ^= (dp[u] + 1);\n    }\n}\n\n\nvoid smain()\n{\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    dfs(1);\n    if (dp[1])\n        cout << \"Alice\\n\";\n    else\n        cout << \"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nVI g[MAX];\n\nint go(int x, int p)\n{\n\tint s = 0;\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tint v = go(to, x) + 1;\n\n\t\ts ^= v;\n\t}\n\n\treturn s;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t}\n\n\tint v = go(0, -1);\n\n\tif (v == 0) cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n\n#define nn 200010\nusing namespace std;\n\nint f[nn],l[nn],n,tot;\nstruct Edge{int to,old;}e[nn*2];\ninline void Lnk(int x,int y){e[++tot].to=y,e[tot].old=l[x],l[x]=tot;}\ninline void Dfs(int x,int y){\n\tfor (int i=l[x];i;i=e[i].old)if(e[i].to!=y){\n\t\tDfs(e[i].to,x);\n\t\tf[x]^=(f[e[i].to]+1);\n\t}\n}\n\nint main()\n{\n\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tLnk(u,v),Lnk(v,u);\n\t}\n\t\n\tDfs(1,0);\n\t\n\tif (f[1]) puts(\"Alice\");else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint sg[100001];\nint n,p,q;\nbool in[100001];\nvector<int>c[100001];\nvector<int>adj[100001];\nvoid build(int id){\n\tin[id]=true;\n\tfor(int i=0; i<adj[id].size() ;i++){\n\t\tint cur=adj[id][i];\n\t\tif(in[cur]) continue;\n\t\tc[id].push_back(cur);\n\t\tbuild(cur);\n\t}\n}\nvoid cal(int id){\n\tfor(int i=0; i<c[id].size() ;i++){\n\t\tcal(c[id][i]);\n\t\tsg[id]^=(sg[c[id][i]]+1);\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor(int i=1; i<n ;i++){\n\t\tcin >> p >> q;\n\t\tadj[p].push_back(q);\n\t\tadj[q].push_back(p);\n\t}\n\tbuild(1);\n\tcal(1);\n\tif(sg[1]==0) cout << \"Bob\\n\";\n\telse cout << \"Alice\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdlib> \n#include<stdio.h> \n#include<memory.h> \n#include<vector> \nusing namespace std; \nvector<int>v[100005]; \nint dfs(int x,int pre) \n{ \n    int ans=0; \n    for(int i=0;i<v[x].size();i++) \n    { \n        \n        if(v[x][i]!=pre) \n        { \n            ans^=(1+dfs(v[x][i],x)); \n        } \n    } \n    return ans; \n} \nint main() \n{ \n    int a,b,n; \n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++) \n    v[i].clear(); \n    n--; \n    while(n--) \n    { \n        scanf(\"%d%d\",&a,&b); \n        v[a].push_back(b); \n        v[b].push_back(a); \n    } \n        \n        if(dfs(1,-1)) puts(\"Alice\"); \n        else puts(\"Bob\"); \n    \n} "
  },
  {
    "language": "C++",
    "code": "/*\n\n    author : s@if\n\n*/\n\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define \t\tNIL \t\t\t-1\n#define\t\t \tfi\t \t\t    first\n#define \t\tsec \t\t\tsecond\n#define \t\tMAX \t\t\tINT_MAX\n#define\t\t\tINF \t\t\t1e9\n#define \t\tll \t\t\t    long long\n#define \t\tPI \t\t\t    acos(-1.0)\n#define\t\t\tMOD \t\t\t1000000007\n#define \t\tPLL \t\t\tpair<ll,ll>\n#define \t\tPII\t\t\t    pair<int,int>\n#define \t\tull \t\t\tunsigned long long\n#define \t\tFor(i,a,b) \t\tfor(int i=a;i<=(int)b;i++)\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n            tree_order_statistics_node_update> new_data_set;\n\n//*find_by_order(k)  gives the kth element;\n//order_of_key(item)   gives the index(number of element strictly less than item) of item;\n\n\ninline int in() {int x; scanf(\"%d\", &x); return x; }\nbool Check(int N , int pos)\t{\treturn (bool) (N & (1<<pos));}\nint Set(int N, int pos) {\treturn N = N | (1<<pos);}\n\nint fx[]={+0,+0,+1,-1,-1,+1,-1,+1};    // King's move\nint fy[]={-1,+1,+0,+0,+1,+1,-1,-1};\nint hx[]={-2,-2,-1,+1,+2,+2,-1,+1};    // Knight's move\nint hy[]={+1,-1,+2,+2,-1,+1,-2,-2};\nint dx[]={+1,-1,+0,+0};\nint dy[]={+0,+0,+1,-1};\n\nconst int MAXN = (int)2e5+9;\n\nvector<int>adj[MAXN];\nint dp[MAXN];\n\nvoid dfs(int curr, int prev = -1)\n{\n    dp[curr] = 0;\n\n    for(int i=0; i<adj[curr].size(); i++)\n    {\n        int v = adj[curr][i];\n        if(v!=prev){\n            dfs(v, curr);\n            dp[curr]^=1+dp[v];\n        }\n    }\n}\n\nint main()\n{\n/*\tfreopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout); */\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int i,j,k,l,m,n,p,q,x,y,u,v,r,tc,t;\n\n    cin>>n;\n    for(i=1; i<n; i++)\n    {\n        cin>>u>>v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1);\n\n    if(dp[1]>0){\n        cout<<\"Alice\\n\";\n    }else{\n        cout<<\"Bob\\n\";\n    }\n\n    return 0;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF (long long) 1e18//1234567890987654321\n#define INF 1234567890\n#define pb push_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos(-1))\n#define MAXN 300006\n#define MAXK 26\n#define MAXX 15000006\n#define ll long long int\n#define ld long double\n#define rep0(kk, l1, l2)for(ll kk = l1; kk < l2; kk++)\n#define rep1(kk, l1, l2)for(ll kk = l1; kk <= l2; kk++)\n#define foritr(itr, A) for(set<ll>::iterator itr = A.begin(); itr != A.end(); itr++)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = ss; ii < ee; ii++)\n#define cr(x) cerr << #x << \" = \" << x << \"\\n\";\n#define crA(x, A) cerr << #x << \" = \" << A[x] << \"\\n\";\n#define spacing cout << \" \";\n#define mmst(x, v) memset((x), v, sizeof ((x)));\n#define bg(ms) (*ms.begin())\n#define ed(ms) (*prev(ms.end(), 1))\n#define addedge(a, b, c, v) v[(a)].pb(pi((b), (c))); v[(b)].pb(pi((a), (c)))\n#define ph push\n#define btinpct(x) __builtin_popcountll(x)\n#define p2(x) (1LL<<(x))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nll n, vt;\nvector <ll> v[MAXN];\nvoid dfs(ll x, ll p, ll d)\n{\n\tif(d > 1) vt ++;\n\tfor(auto i : v[x]) { if(i!=p) dfs(i, x, d+1); }\n}\nint main()\n{\n\tcin >> n;  assert(n > 15);\n\tFOR(i,1,n)\n\t{\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tv[a].pb(b);\n\t\tv[b].pb(a);\n\t}\n\tdfs(1, 1, 0);\n\tif(vt % 2 || v[1].size() == 1) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,x,y;\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>x>>y;\n\tif(n%2==0)cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n6\n1 2\n2 4\n5 1\n6 3\n3 2\n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> edge[100005];\n\nint dfs(int u, int p)\n{\n\tint ret = 0;\n\tfor(int v : edge[u])\n\t{\n\t\tif(v==p) continue;\n\t\tret ^= 1 + dfs(v, u);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i<n-1; i++)\n    {\n    \tint u, v;\n    \tscanf(\"%d %d\", &u, &v);\n    \tedge[u].push_back(v);\n    \tedge[v].push_back(u);\n    }\n    if(dfs(1, -1)) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nint x[100001];\nint y[100001];\nvector<int>G[100001];\nbool check=true;\nbool used[100001];\nint dfs(int x){\n    if(used[x])return 0;\n    used[x]=true;\n    vector<int>v;\n    REP(i,G[x].size()){\n        if(used[G[x][i]]==false){\n           v.push_back(dfs(G[x][i]));\n        }\n    }\n    sort(v.begin(),v.end());\n    int me=0;\n    REP(i,v.size()){\n        if(v[i]==0)continue;\n        if(me==0){\n           me=v[i];\n           continue;\n        }\n        if(me!=v[i]){\n           check=false;\n        }else{\n           me=0;\n        }\n    }\n    //cout<<x<<me<<endl;\n    return me+1;\n}\n\nint main(){\n    cin>>N;\n    REP(i,N-1){\n        cin>>x[i];x[i]--;\n        cin>>y[i];y[i]--;\n        G[x[i]].push_back(y[i]);\n        G[y[i]].push_back(x[i]);\n    }\n    REP(i,N){\n        used[i]=false;\n    }\n    if(N==2){\n       cout<<\"Alice\"<<endl;\n       return 0;\n    }\n    int ans=dfs(0);\n    if(ans!=1){\n       cout<<\"Alice\"<<endl;\n    }else if(check==false){\n       cout<<\"Alice\"<<endl;\n    }else{\n       cout<<\"Bob\"<<endl;\n    }\n    \n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=2e5+5;\nvector<int> g[N];\nint d[N];\nvoid dfs(int v,int p=0){\n    int cnt=0;\n    for(int to:g[v]){\n        if(to^p){\n            dfs(to,v);\n            cnt++;\n            d[v]^=d[to]+1;\n        }\n    }\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    dfs(1);\n    if(d[1])cout<<\"Alice\\n\";\n    else cout<<\"Bob\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100 * 1000 + 7;\n\nvector<int> g[MX];\n\nint dfs(int v, int p = -1) {\n    int xr = 0;\n    for (int to : g[v]) {\n        if (to != p) {\n            xr ^= (dfs(to, v) + 1);\n        }\n    }\n    return xr;\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    if (dfs(1)) {\n        cout << \"Alice\\n\";\n    } else {\n        cout << \"Bob\\n\";\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 100010;\n\nstd::vector <int> e[N];\nint sg[N], cnt[N];\nint n;\n\nvoid dfs(int u, int fa){\n\tfor (auto v : e[u]){\n\t\tif (v == fa){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v, u);\n\t\tsg[u] ^= 1 + sg[v];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0, u, v; i < n - 1; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\treturn printf(sg[1] ? \"Alice\\n\" : \"Bob\\n\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<bits/stdc++.h>\n    using namespace std;\n     \n    #define maxn 111111\n    vector<int> g[maxn];\n    int n;\n     \n    int main()\n    {\n        cin >> n;\n        for (int i = 1; i < n; i++)\n        {\n            int x, y;\n            cin >> x >> y;\n            g[x].push_back(y);\n            g[y].push_back(x);\n        }\n        if (g[1].size() == 1)\n        {\n            cout << \"Alice\" << endl;\n        }\n        else\n        {\n            if ((n - 1 - g[1].size()) % 2 != g[1].size() % 2)\n            {\n                cout << \"Alice\" << endl;\n            }\n            else\n            {\n            //    cout << \"Bob\" << endl;\n            }\n        }\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define LL long long\n#define PB push_back\n#define MP make_pair\n#define I insert\n \nconst LL N = 1e5+5, mod = 1000000007;\n \nusing namespace std;\n \nLL n, m, i, j, k, l, r, t, ans, a[N];\nvector < LL > v[N];\n\nvoid go ( LL u, LL par = 0 ){\n\tfor ( LL i = 0; i < v[u].size(); ++i ){\n\t\tif ( v[u][i] == par ) continue;\n\t\tgo ( v[u][i], u );\n\t\ta[u] ^= a[v[u][i]];\n\t}\n\tif ( u == 1 && v[u].size() == 1 || u != 1 && v[u].size() == 2 ) a[u]++;\n}\n\nint main(){\n\tcin >> n;\n\tfor ( i = 1; i < n; ++i ){\n\t\tcin >> l >> r;\n\t\tv[l].PB(r);\n\t\tv[r].PB(l);\n\t}\n\t\n\tgo(1);\n\t\n\t cout << \"Alice\\n\";\n\t\n\treturn 0;\n}\n \n/**/\n//      IIIIIIIII      OOOOO             A          NN        N    EEEEEEEEEE\n//          I         O     O           A A         N N       N    E\n//          I        O        O         A   A        N  N      N    E\n//          I        O       O        A     A       N   N     N    E\n//          I        O       O       AAAAAAAAA      N    N    N    EEEEEEEE\n//          I        O       O      A         A     N     N   N    E\n//          I        O       O     A           A    N      N  N    E\n//          I         O     O     A             A   N       N N    E\n//      IIIIIIIII      OOOOO     A               A  N        NN    EEEEEEEEEE ___ KAPANADZE"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long int\n#define INF 0x3f3f3f3f\n#define pb push_back\n#define se second\n#define fi first\nusing namespace std;\nconst int N=1e5+5;\nint vis[N],grundy[N];\nvector<int> g[N];\n\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u]){\n        if(vis[v]) continue;\n        dfs(v);\n        grundy[u]^=(grundy[v]+1);\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    int n; cin>>n;\n    for(int i=1;i<n;i++){\n        int u,v; cin>>u>>v;\n        g[u].pb(v); g[v].pb(u);\n    }\n    dfs(1);\n    cout<<(grundy[1]?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 100010;\n\nint N;\nvector<int> adj[MN];\nint dp[MN];\n\nvoid dfs(int u, int p) {\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        dfs(v, u);\n        dp[u] ^= (dp[v] + 1);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(0, -1);\n\n    if(dp[0]) printf(\"Alice\");\n    else printf(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: test.cpp\n    > Author: Akira \n    > Mail: qaq.febr2.qaq@gmail.com \n ************************************************************************/\n\n#include<bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*4\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1E9+7;\nconst double eps = 1e-6;\n#define bug cout<<88888888<<endl;\n#define debug(x) cout << #x\" = \" << x << endl;\ntemplate<typename T> T abs(T val){return val>0?val:-val;}\nint N;\nstruct Edge\n{\n    int v,next;\n}edge[MaxM];\nint cont,head[MaxN];\nvoid add(int u, int v)\n{\n    edge[cont].v = v, edge[cont].next = head[u], head[u] = cont++;\n}\n\nint DFS(int u, int pre)\n{\n    int flag = 0;\n    for(int i=head[u];i!=-1;i=edge[i].next)\n    {\n        int v = edge[i].v;\n        if(v==pre) continue;\n        flag ^= DFS(v,u);\n    }\n    return flag^1;\n}\nvoid solve()\n{\n    if(DFS(1,0)!=1) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n\nvoid init()\n{\n    cont = 0;\n    MST(head,-1);\n}\nint main()\n{\n    //std::ios::sync_with_stdio(false);\n    while(scanf(\"%d\", &N)!=EOF)\n    {\n        init();\n        int a,b;\n        for(int i=1;i<N;i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            add(a,b);add(b,a);\n        }\n        solve();\n    }\n    //system(\"pause\");\n    //printf(\"%lld\\n\", (x%mod+mod)%mod );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint f[maxn];\nint n;\n\nvoid dfs(int v, int p)\n{\n    for (int i = 0; i < g[v].size(); i++)\n    {\n        int u = g[v][i];\n        if (u == p)\n        {\n            continue;\n        }\n        dfs(u, v);\n        f[v] ^= (f[u] + 1);\n    }\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1, 0);\n    if (f[1])\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        cout << \"Bob\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * (c) fushar (Ashar Fuadi)\n*/\n\n#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i = 0, _n = n; i < _n; i++)\n#define FOR(i,a,b) for (int i = a, _b = b; i <= _b; i++)\n#define FORD(i,b,a) for (int i = b, _a = a; i >= _a; i--)\n#define RESET(c,v) memset(c, v, sizeof c)\n#define ALL(c) c.begin(), c.end()\n#define TT template<typename T>\n\nusing namespace std;\nusing ll = long long;\n\nTT bool in_range(int x, int a, int b) { return a <= x && x < b; }\n\n/***********************************************************/\n\nconst int MAXN = 100005;\n\nint N;\nvector<int> G[MAXN];\n\nint dfs(int u, int p) {\n    if (p != -1 && G[u].size() == 1) {\n        return 0;\n    }\n\n    int res = 0;\n    for (int v : G[u]) if (v != p) {\n        res ^= 1 + dfs(v, u);\n    }\n\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    REP(i, N-1) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    puts(dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > Graph;\n\nGraph g;\n\nint dfs(int cur) {\n\tint res = 0;\n\tfor (int nex : g[cur]) {\n\t\tres ^= dfs(nex);\n\t}\n\tif (g[cur].size() == 1) res++;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tif (x > y) swap(x, y);\n\t\tg[x].push_back(y);\n\t}\n\n\tcout << (dfs(0) == 0 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n\nclass Solver {\n  public:\n    vector<vector<int>> E;\n    int grundy(int now, int prev) {\n        int g = 0;\n        for(int nxt : E[now]) {\n            if(nxt == prev) continue;\n            g ^= grundy(nxt, now) + 1;\n        }\n        return g;\n    }\n    bool solve() {\n        int N; cin >> N;\n        E.resize(N);\n        rep(i, N - 1) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n        cout << (grundy(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Nurbakyt Madibek\n// Look at my code! IT'S AWESOME\n\n#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <algorithm>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <cassert>\n#include <unordered_map>\n#include <bitset>\n#include <unordered_set>\n\nusing namespace std;\n\n#define pb push_back\n#define pp pop_back\n#define f first\n#define s second\n#define mp make_pair\n#define sz(a) (int)((a).size())\n#ifdef _WIN32\n#  define I64 \"%I64d\"\n#else\n#  define I64 \"%lld\"\n#endif\n#define fname \".\"\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int, int > pi;\ntypedef pair < int, ull > pu;\ntypedef pair < ll, ll > pl;\n\nconst int inf = (int)1e9 + 123;\nconst ll infl = (ll)1e18 + 123;\nconst double eps = 1e-9;\n\nconst int MAX_N = (int)1e5 + 5;\nconst int mod = (int)1e9 + 7;\n\nint n;\nvector < int > g[MAX_N];\n\nint dfs(int v, int pr = -1) {\n    int res = 0;\n    for (auto to : g[v]) {\n        if (to == pr)\n            continue;\n        int val = dfs(to, v) + 1;\n        res ^= val;\n    }\n    return res;\n}\n\nint main() {\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    cin >> n;\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        g[u].pb(v), g[v].pb(u);\n    }\n    if (dfs(1) > 0)\n        cout << \"Alice\\n\";\n    else\n        cout << \"Bob\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#define inf 0x3f3f3f3f\n#define esp 1e-7\nusing namespace std;\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nstruct Tree{\n\tint sg;\n\tint visited;\n}t[100050];\nint n;\nvector<int> to[100050];\n\nvoid dfs(int index){\n\tfor (unsigned int i=0;i<to[index].size();i++){\n\t\tif (t[to[index][i]].visited==0){\n\t\t\tt[to[index][i]].visited=1;\n\t\t\tdfs(to[index][i]);\n\t\t\tt[index].sg^=(t[to[index][i]].sg+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++)\tto[i].clear();\n\tfor (int i=1,tmp1,tmp2;i<n;i++){\n\t\ttmp1=read();tmp2=read();\n\t\tto[tmp1].push_back(tmp2);\n\t\tto[tmp2].push_back(tmp1);\n\t}\n\tt[1].visited=1;\n\tdfs(1);\n\tif (t[1].sg==0)\tcout<<\"Bob\"<<endl;\n\telse\t\t\tcout<<\"Alice\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+5;\n\nint n,G[N];\nvector < int > v[N];\n\nvoid Dfs(int x,int p) {\n\tint tot=0,G_=0;\n\tfor (int i=0; i<v[x].size(); i++) {\n\t\tif (v[x][i]!=p) {\n\t\t\ttot++;\n\t\t\tDfs(v[x][i],x);\n\t\t\tG_=(G_^G[v[x][i]]);\n\t\t}\n\t}\n\t\n\tif (!tot) G[x]=0;\n\t\telse\n\tif (tot==1) G[x]=G_+1;\n\t\telse G[x]=G_;\n}\n\nmain () {\n\tcin>>n;\n\t\n\tfor (int i=1; i<n; i++) {\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\t\n\tDfs(1,1);\n\t\n\tif (G[1]) cout<<\"Alice\\n\";\n\t\telse cout<<\"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 1000;\n\nint n;\nint f[MAXN], h[MAXN];\nvector<int> edg[MAXN];\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\tdfs(y, x);\n\t\t\tf[x] ^= (f[y] + 1);\n\t\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tedg[x].push_back(y);\n\t\tedg[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tcout << (f[1] ? \"Alice\" : \"Bob\") << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cctype>\n#include <cstdlib>      // srand,rand\n#include <random>\n#include <functional>\n\nusing namespace std;\n#define ll long long\n#define lp(i,n) for(ll i=0;i<n;i++)\n\n#define modd 1000000007\n#define mod2 998244353\n\n#define INF 8223372036854775807ll\n#define ALL(a)  (a).begin(),(a).end()\n\n\ntypedef pair<long long, long long> pl;\ntypedef pair<double, double> pd;\ntypedef pair<ll, string> pls;\n\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\n\n/*\nclass SegmentTree {\n\n\n\nprivate:\n\n\tll cont_num = 2;\n\tpd initial_v;\n\tvector<pd> dat;\n\n\npublic:\n\n\n\tSegmentTree() {};\n\n\n\tvoid init(ll size, double initial_value_first, double initial_value_second) {\n\n\t\tcont_num = 2;\n\t\tinitial_v.first = initial_value_first;\n\t\tinitial_v.second = initial_value_second;\n\n\t\twhile (cont_num < size) {\n\t\t\tcont_num *= 2;\n\t\t}\n\n\t\tdat.resize(2 * cont_num);//サイズ設定\n\n\t\tfor (int i = 0; i < 2 * cont_num; i++)dat[i] = initial_v;//初期化\n\n\n\n\t}\n\n\n\tvoid Update(ll position, double value_f, double value_s) {\n\n\n\n\t\tll k = cont_num + position;\n\n\t\tdat[k].first = value_f;\n\t\tdat[k].second = value_s;\n\n\t\twhile (k > 1) {\n\t\t\tk /= 2;\n\t\t\tdat[k].first = dat[k * 2 + 1].first * dat[k * 2].first;\n\t\t\tdat[k].second = dat[k * 2 + 1].first * dat[k * 2].second + dat[k * 2 + 1].second;\n\n\n\t\t}\n\n\n\t}\n\n\t/*\n\tll query_proces(ll a, ll b, ll k, ll l, ll r) {\n\n\t\tif (r <= a || b <= l)return initial_v;\n\n\t\tif (a <= l && r <= b)return dat[k];\n\t\telse {\n\t\t\tll vl = query_proces(a, b, k * 2, l, (l + r) / 2);\n\t\t\tll vr = query_proces(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\n\t}\n\n\n\tll query(ll left, ll right) {\n\t\treturn query_proces(left, right, 1, 0, cont_num);\n\t}\n\t*/\n\t/*\n\t\tdouble query() {\n\t\t\treturn dat[1].first + dat[1].second;\n\t\t}\n\n\t};*/\n\n\ntemplate <typename T>\nclass Zip {\n\tvector<T> d;\n\tbool flag;\n\tvoid init() {\n\t\tsort(d.begin(), d.end());\n\t\td.erase(unique(d.begin(), d.end()), d.end());\n\t\tflag = false;\n\t}\npublic:\n\tZip() {\n\t\tflag = false;\n\t}\n\tvoid add(T x) {\n\t\td.push_back(x);\n\t\tflag = true;\n\t}\n\tll getNum(T x) {\n\t\tif (flag) init();\n\t\treturn lower_bound(d.begin(), d.end(), x) - d.begin();\n\t}\n\tll size() {\n\t\tif (flag) init();\n\t\treturn (ll)d.size();\n\t}\n};\n\n\nll N, M, K, a, b, c, d, e, H, W, L, T;\nll x, y, z;\nll A[2000004] = {};\nll B[2000004] = {};\nll C[2000004] = {};\nll D[1000006] = {};\nll E[1000006] = {};\nbool f;\nstring S[200000];\nstring SS;\nset <long long>sll;\npl bufpl;\nvector <long long>vl[200005];\nvector <long long>vll;\nvector <long long>v;\nvector <pl>vpl;\nvector <string> vs;\nset<ll> llset;\nset<string> Sset;\nmultiset<ll> llmset;\nqueue<ll> ql;\nmultiset<pl> plmset;\n\n\ntypedef struct ST\n{\n\tll first;\n\tll second;\n\tll cost;\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn cost < another.cost;//比較\n\t};\n\n\tbool operator>(const ST& another) const\n\t{\n\t\treturn cost > another.cost;//比較\n\t};\n\n}ST;\n//queue<ST> qst;\npriority_queue<ST, vector<ST>, greater<ST> > qst;\n\n\n\n/*vector <ST> vst;\nST st[200005];\nST bufst;\nbitset<5000> bits;*/\n\n\nlong long modinv(long long aa, long long mm) {\n\tlong long bb = mm, uu = 1, vv = 0;\n\twhile (bb) {\n\t\tlong long tt = aa / bb;\n\t\taa -= tt * bb; swap(aa, bb);\n\t\tuu -= tt * vv; swap(uu, vv);\n\t}\n\tuu %= mm;\n\tif (uu < 0) uu += mm;\n\treturn uu;\n}\n\n\n\n\n\nll zettai(ll aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\nfloat zettai(float aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\n\n/*\nclass UnionFind\n{\n\npublic:\n\n\n\tvector <ll>pairent;\n\tvector <ll>depth;\n\tvector <ll>size;\n\n\n\tUnionFind(ll Amount) : pairent(Amount, 1), depth(Amount, 1), size(Amount, 1) {\n\n\t\tfor (ll i = 0; i < Amount; i++) {\n\t\t\tpairent[i] = i;\n\t\t}\n\n\n\t}\n\n\n\tll FindPairent(ll x) {\n\t\tif (pairent[x] == x)return x;\n\t\telse return pairent[x] = FindPairent(pairent[x]);\n\n\t}\n\n\n\tll Merge(ll x, ll y) {\n\t\tx = FindPairent(x);\n\t\ty = FindPairent(y);\n\n\t\tif (x != y) {\n\t\t\tif (depth[x] > depth[y]) {\n\t\t\t\tpairent[y] = pairent[x];\n\t\t\t\treturn size[x] += size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpairent[x] = pairent[y];\n\t\t\t\tif (depth[x] == depth[y]) {\n\t\t\t\t\tdepth[y] ++;\n\t\t\t\t}\n\n\t\t\t\treturn size[y] += size[x];\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\n\n\n\t}\n\n\n\n\tbool IsSame(ll x, ll y) {\n\t\tif (FindPairent(x) == FindPairent(y))return true;\n\t\telse return false;\n\t}\n\n\n\tll GetSize(ll x) {\n\t\tx = FindPairent(x);\n\t\treturn size[x];\n\t}\n\n\n};\n*/\n\nclass UnionFind\n{\n\npublic:\n\n\tvector <ll>pairent;\n\tvector <ll>depth;\n\tvector <ll>size;\n\n\tUnionFind(ll Amount) : pairent(Amount, 1), depth(Amount, 1), size(Amount, 1) {\n\n\t\tfor (ll i = 0; i < Amount; i++) {\n\t\t\tpairent[i] = i;\n\t\t}\n\t}\n\n\n\tll FindPairent(ll x) {\n\t\tif (pairent[x] == x)return x;\n\t\telse return pairent[x] = FindPairent(pairent[x]);\n\t}\n\n\n\tll Merge(ll x, ll y) {\n\t\tx = FindPairent(x);\n\t\ty = FindPairent(y);\n\n\t\tif (x != y) {\n\t\t\tif (depth[x] > depth[y]) {\n\t\t\t\tpairent[y] = pairent[x];\n\t\t\t\treturn size[x] += size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpairent[x] = pairent[y];\n\t\t\t\tif (depth[x] == depth[y]) {\n\t\t\t\t\tdepth[y] ++;\n\t\t\t\t}\n\t\t\t\treturn size[y] += size[x];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\n\tbool IsSame(ll x, ll y) {\n\t\tif (FindPairent(x) == FindPairent(y))return true;\n\t\telse return false;\n\t}\n\n\n\tll GetSize(ll x) {\n\t\tx = FindPairent(x);\n\t\treturn size[x];\n\t}\n\n\n};\n\nstruct Edge\n{\n\tll a, b, cost;\n\n\n\tbool operator<(const Edge& other) const {\n\t\treturn cost < other.cost;\n\t}\n};\n\nstruct Graph\n{\n\tll n;  // 頂点数\n\tvector<Edge> es;  // 辺集合\n};\n\nclass Kruskal {\n\n\tGraph origin_G;\n\tGraph MST;\n\tll total_cost = 0;\n\npublic:\n\n\tvoid Solve() {\n\t\tUnionFind uf = UnionFind(MST.n);\n\t\tfor (ll i = 0; i < origin_G.es.size(); i++) {\n\t\t\tll a = origin_G.es[i].a;\n\t\t\tll b = origin_G.es[i].b;\n\t\t\tll cost = origin_G.es[i].cost;\n\n\t\t\tif (!uf.IsSame(a, b)) {\n\t\t\t\tuf.Merge(a, b);\n\t\t\t\tMST.es.push_back(origin_G.es[i]);\n\t\t\t\ttotal_cost += cost;\n\t\t\t}\n\t\t}\n\t}\n\n\tKruskal(Graph graph) {\n\t\torigin_G = graph;\n\t\tMST = graph;\n\t\tMST.es.clear();\n\t\tsort(origin_G.es.begin(), origin_G.es.end());\n\t}\n\n\tll GetMinCost() {\n\t\treturn total_cost;\n\t}\n\n};\n\n\nll RepeatSquaring(ll N, ll P, ll M) {\n\tif (P == 0) return 1;\n\tif (P % 2 == 0) {\n\t\tll t = RepeatSquaring(N, P / 2, M) % M;\n\t\treturn t * t % M;\n\t}\n\treturn N * RepeatSquaring(N, P - 1, M) % M;\n}\n\n/*\nll KurikaesiNijou(ll a, ll b, ll P) {\n\n\tif (b == 0)return 1;\n\tif (b % 2 == 0) {\n\t\tll c=KurikaesiNijou(a,b/2,P)%P;\n\t\treturn c * c %P;\n\t}\n\telse {\n\t\tll c = KurikaesiNijou(a, b/2, P) % P;\n\t\treturn a * c * c % P;\n\t}\n\n}*/\n\n\n\n\nll GCD(ll a, ll b) {\n\tif (a % b == 0)return b;\n\telse return GCD(b, a % b);\n}\n\nll Min(ll a, ll b) {\n\tif (a < b)return a;\n\telse return b;\n}\n\nll Max(ll a, ll b) {\n\tif (a > b)return a;\n\telse return b;\n}\n\nll Sum(ll a, ll b) {\n\treturn a + b;\n}\n\ntemplate <typename T>\nclass SegmentTree {\n\tll n;\n\tvector<T> node;\n\tfunction<T(T, T)> fun, fun2;\n\tbool customChange;\n\tT outValue, initValue;\npublic:\n\tvoid init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n\t\t// changeFunction: (input, beforevalue) => newvalue\n\t\tfun = resultFunction;\n\t\tfun2 = changeFunction;\n\t\tcustomChange = changeFunction != NULL;\n\t\tn = 1;\n\t\twhile (n < num) n *= 2;\n\t\tnode.resize(2 * n - 1);\n\t\tfill(node.begin(), node.end(), init);\n\t\toutValue = out;\n\t\tinitValue = init;\n\t}\n\tvoid valueChange(ll num, T value) {\n\t\tnum += n - 1;\n\t\tif (customChange) node[num] = fun2(value, node[num]);\n\t\telse node[num] = value;\n\t\twhile (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n\t}\n\tT rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n\t\tif (r == -1) r = n;\n\t\tif (a <= l && r <= b) return node[k];\n\t\tif (b <= l || r <= a) return outValue;\n\t\tll mid = (l + r) / 2;\n\t\treturn fun(rangeQuery(a, b, l, mid, 2 * k + 1), rangeQuery(a, b, mid, r, 2 * k + 2));\n\t}\n};\n\n\n\n\nclass Combination {\n\n\tvector<ll> factorial;\n\tvector<ll> factorial_inv;\n\tll mod;\n\tll max_n;\n\n\npublic:\n\tvoid Init(ll init_max_n, ll init_mod) {\n\t\tmax_n = init_max_n;\n\t\tmod = init_mod;\n\t\tfactorial.resize(max_n + 1);\n\t\tfactorial[0] = 1;\n\t\tfor (ll i = 1; i < factorial.size(); i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * i;\n\t\t\tfactorial[i] %= mod;\n\t\t}\n\n\t\tfactorial_inv.resize(max_n + 1);\n\t\tfactorial_inv[0] = 1;\n\t\tfor (ll i = 1; i < factorial_inv.size(); i++) {\n\t\t\tfactorial_inv[i] = factorial_inv[i - 1] * modinv(i, mod);\n\t\t\tfactorial_inv[i] %= mod;\n\t\t}\n\t}\n\n\n\n\tll GetComb(ll n, ll k) {\n\t\tll comb = factorial[n];\n\t\tcomb *= factorial_inv[k];\n\t\tcomb %= mod;\n\t\tcomb *= factorial_inv[n - k];\n\t\tcomb %= mod;\n\t\treturn comb;\n\t}\n\n\tll GetH(ll n, ll k) {//n+k-1<=max_N\n\t\tll comb = factorial[n + k - 1];\n\t\tcomb *= factorial_inv[n];\n\t\tcomb %= mod;\n\t\tcomb *= factorial_inv[k - 1];\n\t\tcomb %= mod;\n\t\treturn comb;\n\t}\n\n};\n\n\n\nclass Tree {\n\n\tll node_N;\n\tvector<ll> node;\n\tvector<vector<pl>> pass;\n\tll diameter = -1;\n\tvector<ll> dist_Diamieter[2];\n\n\tpl maxDist_Num;\n\npublic:\n\n\n\tvoid Init(ll node_Num) {\n\t\tnode_N = node_Num;\n\t\tnode.resize(node_N + 1);\n\t\tpass.resize(node_N + 1);\n\n\t\tdist_Diamieter[0].resize(node_N + 1);\n\t\tlp(i, node_N + 1)dist_Diamieter[0][i] = -1;\n\t\tdist_Diamieter[1].resize(node_N + 1);\n\t\tlp(i, node_N + 1)dist_Diamieter[1][i] = -1;\n\t}\n\n\tvoid AddEdge(ll a, ll b, ll dist) {\n\t\tbufpl.first = b;\n\t\tbufpl.second = dist;\n\t\tpass[a].push_back(bufpl);\n\t\tbufpl.first = a;\n\t\tpass[b].push_back(bufpl);\n\t}\n\n\n\tvoid DFS(ll step, ll now, ll dist) {\n\n\t\tdist_Diamieter[step][now] = dist;\n\t\tif (dist_Diamieter[step][now] > maxDist_Num.first) {\n\t\t\tmaxDist_Num.first = dist_Diamieter[step][now];\n\t\t\tmaxDist_Num.second = now;\n\t\t}\n\n\t\tfor (ll i = 0; i < pass[now].size(); i++) {\n\t\t\tll next_node = pass[now][i].first;\n\t\t\tif (dist_Diamieter[step][next_node] == -1) {\n\t\t\t\tDFS(step, next_node, dist + pass[now][i].second);\n\t\t\t}\n\t\t}\n\t}\n\n\tll GetDiameter(ll min_node_num) {\n\t\tif (diameter >= 0)return diameter;\n\t\telse {\n\t\t\tmaxDist_Num.first = -1;\n\t\t\tmaxDist_Num.second = -1;\n\t\t\tDFS(0, min_node_num, 0ll);\n\t\t\tll step2_start = maxDist_Num.second;\n\n\t\t\tmaxDist_Num.first = -1;\n\t\t\tmaxDist_Num.second = -1;\n\t\t\tDFS(1, step2_start, 0ll);\n\n\t\t\tdiameter = maxDist_Num.first;\n\t\t\treturn diameter;\n\t\t}\n\t}\n\n\tll GetDistFromMinNode(ll num) {\n\t\treturn dist_Diamieter[0][num];\n\t}\n\n};\n\n\nvoid Nibu(ll node, ll co) {\n\n\tC[node] = co % 2;\n\tD[co % 2]++;\n\n\tlp(i, vl[node].size()) {\n\t\tll next = vl[node][i];\n\t\tif (C[next] == -1) {\n\t\t\tNibu(next, co + 1);\n\t\t}\n\t}\n\n}\n\nST bufst;\nmultiset<ST> stmset;\nvector<pl> vpll[10004];\n\nSegmentTree<ll> st;\n\nll grundy[100005] = {};\n\nll grund(ll n) {\n\tgrundy[n] = 1;\n\tll aa = 0;\n\n\tlp(i, vl[n].size()) {\n\t\tif (grundy[vl[n][i]] != 1)aa = aa xor (grund(vl[n][i])+1);\n\t}\n\n\t\n\t\n\n\treturn aa;\n\n}\n\nint main() {\n\n\t/*cin >> N >> M;\n\n\tlp(i, M) {\n\t\tcin >> a >> b >> c;\n\t\tbufpl.first = b;\n\t\tbufpl.second = c;\n\t\tvpll[a].push_back(bufpl);\n\t}\n\n\tlp(i, N)A[i] = INF;\n\n\tbufst.first = 0;\n\tbufst.second = 0;\n\tbufst.cost = 0;\n\tstmset.insert(bufst);\n\tA[0] = 0;\n\n\twhile (!stmset.empty()) {\n\n\t\tauto itr = stmset.begin();\n\t\ta = itr->first;\n\t\tb = itr->second;\n\t\tc = itr->cost;\n\n\t\tif (c != A[a]) {\n\t\t\tstmset.erase(itr);\n\t\t\tcontinue;\n\t\t}\n\n\n\t}\n\n\n\tlp(i, N)cout << A[i] << endl;\n\t*/\n\n\tcin >> N;\n\tlp(i, N-1) {\n\t\tcin >> a >> b;\n\t\tvl[a].push_back(b);\n\t\tvl[b].push_back(a);\n\t\t\n\t}\n\tlp(i, N + 1)grundy[i] = -1;\n\tb=grund(1);\n\t\n\n\tif (b == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\n\n\t//cout << fixed << setprecision(12) << bb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 200007\n\nint tot , n ;\nint nex[2*N] , fire[N] , to[2*N] , sg[N] ;\n\nvoid add(int u , int v){\n    nex[++tot] = fire[u] ;\n    fire[u] = tot ;\n    to[tot] = v ;\n    return ;\n}\n\nvoid dfs(int x , int fr){\n    for(int i = fire[x] ; i ; i = nex[i] ){\n        int v = to[i] ;\n        if( v == fr ) continue ;\n        dfs( v , x ) ;\n        sg[x] ^= ( sg[v] + 1 ) ;\n    }\n    return ;\n}\n\nint main()\n{\n    scanf(\"%d\" , &n ) ;\n    for(int i = 1 ; i <= n - 1 ; i++ ){\n        int u , v ;\n        scanf(\"%d%d\" , &u , &v ) ;\n        add( u , v ) ; add( v , u ) ;\n    }\n    dfs( 1 , 0 ) ;\n    if( sg[1] ) printf(\"Alice\\n\") ;\n    else printf(\"Bob\\n\") ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <cstring>\n#include <bitset>\n#include <stack>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\nconst int INF=1e9;\n\nint n;\nvector <int> v[100005];\nbool b[100005];\n\ninline void dfs(int x,int p)\n{\n\tint w=0,l=0;\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint tx=v[x][i];\n\t\tif (tx==p) continue;\n\t\tdfs(tx,x);\n\t\tif (b[tx]==0) l++; else w++;\n\t}\n\tif ((l+w)==1)\n\t{\n\t\tb[x]=1;\n\t}\n\telse if (w==0 || l==0)\n\t{\n\t\tif (l%2==0) b[x]=0; else b[x]=1;\n\t}\n\telse if (w%2==0)\n\t{\n\t\tif ((l+w)%2==1) b[x]=1; else b[x]=0;\n\t}\n\telse\n\t{\n\t\tif ((l+w)%2==0) b[x]=1; else b[x]=0;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tv[x].PB(y);\n\t\tv[y].PB(x);\n\t}\n\tdfs(1,0);\n//\tfor (int i=1;i<=n;i++) cout<<b[i]<<\" \";\n\tcout<<(b[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 555555;\nVi e[N];int n,f[N];\nvoid dfs(int u, int fa){\n\tper(i,SZ(e[u])-1,0)\n\t\tif(e[u][i]!=fa)dfs(e[u][i],u),f[u]^=f[e[u][i]]+1;\n}\nint main() {\n\tread(n);rep(i,2,n){int u,v;read(u);read(v);e[u].pb(v);e[v].pb(u);}\n\tdfs(1,0);if(f[1])puts(\"Alice\");else puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \")\n{ if (!v.size()) puts(\"\"); rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nint n;\nbool used[101010];\n\nvector<vi> G;\n\nint f(int v = 0) {\n  if (used[v]) return -1;\n  used[v] = true;\n\n  int ret = 0;\n\n  for (int i = 0; i < G[v].size(); ++i) {\n    ret ^= f(G[v][i]) + 1;\n  }\n\n  return ret;\n}\n\nsigned main() {\n  cin >> n;\n\n  G.resize(n);\n  rep(i, n - 1) {\n    int a = in() - 1, b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  cout << (f() ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nvector<vector<int>> G;\nvector<int> grundy;\n\nint dfs(int cur = 0, int par = -1){\n    int ret = 0;\n    for(int v: G[cur]){\n        if(v != par){\n            ret ^= dfs(v, cur) + 1;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    int N;\n    cin >> N;\n    G.resize(N);\n    grundy.resize(N);\n    rep(i, N - 1){\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    \n    output(dfs() ? \"Alice\" : \"Bob\");\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> G[100010];\nint dfs(int s,int p){\n\tint res = 0;\n\tfor(int v:G[s]){\n\t\tif(v!=p){\n\t\t\tres ^= dfs(v,s);\n\t\t}\n\t}\n\tres++;\n\treturn res;\n}\n\nint main(){\n\tint i,n;\n\tcin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(b); G[b].push_back(a);\n\t}\n\tif(dfs(0,-1)==1){\n\t\tcout << \"Bob\" << endl;\n\t}else{\n\t\tcout << \"Alice\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2];\nint i,j,k,l,t,n,m,tot;\nvoid add(int x,int y){\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nint dfs(int x,int y){\n    int l=0,t=h[x];\n    while (t){\n        if (go[t]!=y) l^=dfs(go[t],x)+1;\n        t=nxt[t];\n    }\n    return l;\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        add(j,k);add(k,j);\n    }\n    if (dfs(1,0)) printf(\"Alice\\n\");else printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define input freopen(\"input.txt\",\"r\",stdin)\n#define output freopen(\"output.txt\",\"w\",stdout)\n#define N 10005\n#define LL long long\n#define inf 1<<29\n#define eps 1e-7\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int t,n;\n    //input;output;\n    while(~scanf(\"%d\",&n))\n    {\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n10\n1\n10\n100\n1000000007\n10000000000\n1000000009\n999999999\n999\n999\n999\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=100005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nvector<ll> p;\nbool isp[maxn];\n\nll a[maxn];\n\nmap<ll,ll> pr;\n\nmap<ll,ll> mp;\nll nocube(ll x){\n\t__int128 cc=1;\n\tll meow=x;\n\tfor(ll i:p){\n\t\tint cnt=0;\n\t\twhile(x%i==0){\n\t\t\tcnt++;\n\t\t\tx/=i;\n\t\t\tmeow/=i;\n\t\t\t// cout<<i<<' '<<meow<<' '<<x<<'\\n';\n\t\t}\n\t\tREP(j,cnt%3) x*=i;\n\t\tif(cnt%3==1) cc*=i*i;\n\t\telse if(cnt%3==2) cc*=i;\n\t}\n\t// cout<<(ll)cc<<' '<<meow<<'\\n';\n\tif(mp.count(meow)) cc*=mp[meow];\n\telse cc*=meow*meow;\n\tif(cc>1e10) cc=-1;\n\tpr[x]=cc;\n\t// cout<<x<<' '<<pr[x]<<'\\n';\n\treturn x;\n}\n\nmap<ll,ll> cnt;\n\nconst int magic=2154;\n\nset<ll> vis;\n\nint main()\n{\n\tIOS;\n\n\tfor(int i=2;i<magic;i++){\n\t\tif(!isp[i]){\n\t\t\tp.pb(i);\n\t\t}\n\t\tfor(int j=0;i*p[j]<magic;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\n\tfor(ll i=1;i<100000;i++){\n\t\tmp[i*i]=i;\n\t}\n\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>a[i];\n\t// REP(i,n) a[i]=999999967LL-i;\n  \tREP(i,n) a[i]=nocube(a[i]);\n\t// REP(i,n) cout<<a[i]<<\" \\n\"[i==n-1];\n\tbool flag=0;\n\tREP(i,n){\n\t\tif(a[i]>1) cnt[a[i]]++;\n\t\telse flag=1;\n\t}\n\tll ans=0;\n\tfor(auto i:cnt){\n\t\tll type=i.F;\n\t\tif(vis.count(type)) continue;\n\n\t\tll tmp=pr[type];\n\n\t\t\n\t\tif(tmp<10000000005LL&&cnt.count((ll)tmp)){\n\t\t\tans+=max(i.S,cnt[tmp]);\n\t\t\tvis.insert(tmp);\n\t\t}\n\t\telse ans+=i.S;\n\t}\n\tcout<<ans+flag<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::vector;\nusing std::pair;\n\nusing pii = pair<int, int>;\nvector<int> G[10003];\nint cnt[10003];\nvoid go(int idx,int p) {\n\t\n\tfor (auto &to : G[idx]) {\n\t\tif (p == to) continue;\n\t\tcnt[idx] ^= cnt[to] + 1;\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tgo(1,1);\n\tif (cnt[1] == 0) printf(\"Bob\");\n\telse printf(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint N, par[101010], lv[101010], xo;\nvector<int> con[101010];\n\nvoid dfs(int ix){\n\tint jcn=0;\n\tfor(auto e : con[ix]){\n\t\tif(par[ix] == e) continue;\n\t\tjcn++; par[e]=ix, lv[e]=lv[ix]+1;\n\t\tdfs(e);\n\t}\n\tif(jcn != 1) xo^=lv[ix];\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i=0; i<N-1; i++){\n\t\tint s, e;\n\t\tscanf(\"%d%d\", &s, &e);\n\t\tcon[s].push_back(e), con[e].push_back(s);\n\t}\n\tdfs(1);\n\tputs(xo ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid dfs(int v,vector<vector<int>> &edge,vector<int> &grundy,vector<int> &used){\n    used[v]=true;\n    for(int i=0;i<edge[v].size();i++){\n        int to=edge[v][i];\n        if(used[to]){\n            continue;\n        }\n        grundy[to]=grundy[v]+1;\n        dfs(to,edge,grundy,used);\n    }\n    return;\n}\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> edge(n);\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    vector<int> used(n);\n    vector<int> grundy(n);\n    grundy[0]=0;\n    vector<int> gs;\n    dfs(0,edge,grundy,used);\n    for(int i=0;i<edge.size();i++){\n        for(int j=0;j<edge[i].size();j++){\n            if(i<edge[i][j]) continue;\n            gs.push_back(min(grundy[i],grundy[edge[i][j]]));\n        }\n    }\n    int res=0;\n    for(int i=0;i<gs.size();i++){\n        res^=gs[i];\n\n    }\n    cout<<(res?\"Alice\" :\"Bob\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nvi g[MAXN];\n\nint gr[MAXN];\n\nint mex[MAXN];\n\nint used[MAXN], prv[MAXN];\n\nvoid dfs(int s){\n\tused[s] = 1;\n\tint cnt = 0, val1 = 0;\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t\tcnt ^= 1;\n\t\t\tval1 ^= gr[to];\n\t\t}\n\t}\n\tgr[s] = (val1 | cnt);\n\t/*REP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tint val1 = val ^ gr[to];\n\t\t\tmex[val1] = s;\n\t\t}\n\t}\n\tfor(int i = 0; ; i++){\n\t\tif (mex[i] != s){\n\t\t\tgr[s] = i;\n\t\t\tbreak;\n\t\t}\n\t}*/\n}\n\nvoid solve(){\n\tint n, a, b;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tdfs(1);\n\t\n\t/*REPN(i, 1, n){\n\t\tprintf(\"%d %d\\n\", i, gr[i]);\n\t}*/\n\t\n\tif (gr[1]){\n\t\tprintf(\"Alice\\n\");\n\t} else {\n\t\tprintf(\"Bob\\n\");\n\t}\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nvector<int> adj[100005];\n\nint grundy(int node, int parent){\n\tint x = 0;\n\tfor(int to : adj[node]){\n\t\tif(to == parent)\n\t\t\tcontinue;\n\t\tx ^= grundy(to, node);\n\t}\n\treturn x+1;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\n\tint N;\n\tcin >> N;\n\trep(i,0,N-1){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x;--y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tif(grundy(0, -1) == 1)\n\t\tcout << \"Bob\" << endl;\n\telse\n\t\tcout << \"Alice\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\n\nvector<vector<int>> e;\nint dfs(int now, int prv)\n{\n    int g = 0;\n    for (auto nxt : e[now]) if (nxt != prv) g ^= dfs(nxt, now);\n    return g + 1;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    e.resize(N + 1);\n    REP(_, N - 1)\n    {\n        int u, v;\n        cin >> u >> v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    cout << (dfs(1, 0) - 1 ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " #define PROB Treestrat\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define all(b) b.begin() , b.end()\n#define mp(a, b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define vi vector<int>\n#define vd vector<double>\n#define vs vector<string>\n#define vii vector<pair<int,int>>\n#define vvi vector<vector<int>>\n#define ii pair<int,int>\n#define turnOff(k, i) (k&(~(1<<(i-1))))\n#define isOn(k, i) (k&&(1<<i-1)?true:false)\n#define pll pair<long long int , long long int>\n#define ull unsigned long long int\n#define ll  long long int\n#ifdef  DEBUG\n#define MAXN 20\n#else\n#define MAXN 200050\n#endif\n#define MAXLG 20\n#define endl '\\n'\n#define PI 3.14159265i3589793238\n#define MOD (1000000007l)\n#define INF (1000000007)\n#define EPS (0.00000001)\n#define treap treapNode*\n\nvi adj[MAXN];\n\n\nint dfs (int curr,int par = -1) {\n    int nim = 0;\n    for (int nxt : adj[curr]) {\n        if (nxt!=par) {\n            nim = nim ^(dfs(nxt,curr)+1);\n        }\n    }\n    return nim;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n#ifdef DEBUG\n    freopen(\"input\", \"r\", stdin);\n#endif\n    int n;\n    cin>>n;\n    rep (i,0,n-1) {\n        int x,y;\n        cin>>x>>y;\n        adj[--x].push_back(--y);\n        adj[y].push_back(x);\n    }\n    if(dfs(0)!=0) cout<<\"Alice\";\n    else cout<<\"Bob\";\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n;\nvi g[N];\nbool vis[N];\n\null dfs(int x){\n\tvis[x]=1;\n\tint ans=0;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tans^=dfs(y)+1;\n\t}\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tif(dfs(1)) puts(\"Alice\"); else puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nll c[111111],d[111111];\nvector<ll> v[111111];\n\nll dfs(int x,int p,int t) {\n  d[x]=t;\n  rep(i,v[x].size()) {\n    int y=v[x][i];\n    if(p!=y) dfs(y,x,t+1);\n  }\n  return c[x]+1;\n}\n\nvoid Main() {\n  ll n;\n  R n;\n  rep(i,n-1) {\n    int x,y;\n    cin >> x >> y;\n    x--,y--;\n    v[x].pb(y);\n    v[y].pb(x);\n  }\n  dfs(0,-1,0);\n  ll a[n];mem(a);\n  rep(i,n) a[d[i]]++;\n  ll t=0;\n  REP(i,1,n) t|=a[i]%2;\n  if(t) pr(\"Alice\");\n  else pr(\"Bob\");\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,sg[SZ]; Edg\ninline void dfs(int x,int f=0)\n{for esb(x,e,b) if(b!=f) dfs(b,x),sg[x]^=sg[b]+1;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,a,b;i<n;++i)\n\t\tscanf(\"%d%d\",&a,&b),adde(a,b);\n\tdfs(1);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nint k=0,m=0;\n\nvoid solve(){\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        if (a==1 || b==1) k+=1;\n        else m+=1;\n    }\n    if (k==1) cout << \"Alice\" << endl;\n    else if (n%2==0) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,x[100010];\nint main(){\n\tcin>>n;\n\tmemset(x,0,n);\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;cin>>a>>b;a--,b--;\n\t\tx[a]++,x[b]++;\n\t}\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(x[i]%2==1)cnt++;\n\t}\n\tif(cnt%2==1)cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 1000000007;\nusing ll = int64_t;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < n-1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        G[a-1].emplace_back(b-1);\n        G[b-1].emplace_back(a-1);\n    }\n    deque<int> Q;\n    vector<int> num(n);\n    {\n        stack<int> s;\n        int cnt = 0;\n        vector<int> visited(n, 0);\n        s.emplace(0);\n        while(!s.empty()){\n            int a = s.top(); s.pop();\n            visited[a]++;\n            num[a] = cnt++;\n            Q.emplace_front(a);\n            for (auto &&i : G[a]) {\n                if(!visited[i]) s.emplace(i);\n            }\n        }\n    }\n    vector<int> dp(n, 0);\n    while(!Q.empty()){\n        int i = Q.front(); Q.pop_front();\n        for (auto &&j : G[i]) {\n            if(num[i] < num[j]){\n                dp[i] ^= dp[j]+1;\n            }\n        }\n    }\n    puts(dp[0] ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nvoid bob() {\n  printf(\"Bob\\n\");\n  exit(0);\n}\n\nvoid alice() {\n  printf(\"Alice\\n\");\n  exit(0);\n}\n\nvvi g;\n\nint resolve(int u, int par) {\n  if ((int)g[u].size() == 1) {\n    if (u == 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  deque<int> chld;\n  for (int v : g[u]) {\n    if (v == par) { continue; }\n    chld.push_back(resolve(v, u) + 1);\n  }\n  sort(all(chld));\n  while ((int)chld.size() > 1) {\n    chld[1] -= chld[0];\n    chld.pop_front();\n  }\n  debug2(u, chld[0]);\n  return chld[0];\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  g.resize(n);\n  rep (i, n-1) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    x -= 1; y -= 1;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  if (resolve(0, -1) == 0) {\n    bob();\n  } else {\n    alice();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, dep[100005];\nvector<int> adjlist[100005];\nvector< pair<int, int> > edgelist;\n\nvoid dfs(int x, int p, int d) {\n\tdep[d]++;\n\tfor (int i = 0; i < adjlist[x].size(); i++) if (adjlist[x][i] != p) dfs(adjlist[x][i], x, d + 1);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tadjlist[a].push_back(b);\n\t\tadjlist[b].push_back(a);\n\t\tedgelist.push_back(make_pair(a, b));\n\t}\n\tdfs(0, -1, 0);\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (dep[i] % 2 == 1) ans = 1;\n\t}\n\tif (ans == 0) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 2e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nstruct Edge {\n    int u, v, num;\n} ed[2 * MAXN];\n\nbool use[MAXN];\nint first[MAXN], nexxt[2 * MAXN], res[MAXN], p[MAXN];\n\n\nvoid dfs(int s)\n{\n    use[s] = 1;\n    res[s] = 0;\n\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (!use[ed[i].v])\n        {\n            p[ed[i].v] = s;\n            dfs(ed[i].v);\n            res[s] ^= res[ed[i].v]+1;\n        }\n}\n\nint dfs2(int s, int Gr)\n{\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (ed[i].v != p[s] && ((res[ed[i].v]+1) > (Gr ^ (res[ed[i].v]+1) ^ res[s])))\n        {\n            Gr ^= (res[ed[i].v] + 1) ^ res[s];\n            if (Gr == 0)\n                return ed[i].num;\n            return dfs2(ed[i].v, Gr-1);\n        }\n}\n\n\nmain() {\n    int n, r;\n    scanf(\"%ld%ld\", &n);\n    r = 1;\n    --r;\n    int m = n-1;\n    for (int i = 0; i < m; ++i)\n    {\n        scanf(\"%ld%ld\", &ed[i].u, &ed[i].v);\n        --ed[i].u, --ed[i].v;\n        ed[i].num = i + 1;\n\n        ed[i+m].u = ed[i].v;\n        ed[i+m].v = ed[i].u;\n        ed[i+m].num = ed[i].num;\n    }\n\n    m *= 2;\n\n    for (int i = 0; i < n; ++i)\n    {\n        first[i] = -1;\n        use[i] = 0;\n    }\n\n    for (int i = 0; i < m; ++i)\n    {\n        nexxt[i] = first[ed[i].u];\n        first[ed[i].u] = i;\n    }\n\n    p[r] = -1;\n    dfs(r);\n    if (!res[r])\n        printf(\"Alice\");\n    else\n        printf(\"Bob\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nll n;\nvector<ll> g[101010];\n\nll dfs(ll v,ll pre){\n  ll res=0;\n  for(ll nv : g[v]){\n    if(nv==pre)continue;\n    ll tmp=dfs(nv,v);\n    res^=tmp+1;\n  }\n  return res;\n}\n\nint main(){\n\tcin>>n;\n  rep(i,n-1){\n    ll a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b); g[b].push_back(a);\n  }\n  if(dfs(0,-1)==0)cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"-O3\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define NumberOfOnes __builtin_popcount\n#define LSOne(S) (S & (-S))\n#define ll long long\n#define two pair<int,int>\n#define twoll pair<ll,ll>\n#define four pair<two,two>\n#define pb push_back\n#define eb emplace_back\n#define mk make_pair\n#define y1 y1922\n#define INF 1000000000000000000\n#define P 1000000007\n#define lmax 1000000000\n#define nn 1000003\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\n#define f first\n#define s second\n#define vi vector<int>\n#define vll vector<ll>\n#define vtwo vector<two>\n#define ALL(container) (container).begin(), (container).end()\n#define sz(container) (int)(container.size())\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define mid(a,b) (a+b>>1)\n#define minN 0\n#define maxN 10000000\n#define na(x) ((x)<P?(x):(x)-P)\n#define ab(a) (-(a)<(a)?(a):-(a))\n#define FAST std::ios::sync_with_stdio(false)\n#define xRand mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define rnd rng\n#define IT iterator\ntypedef\ntree<\n  int,// aq pair<int,int> shegidzlia\n  null_type,\n  less/*_equal*/<int>,// aqac\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n// '_equal' mashin ginda roca multiset gchirdeba\ntemplate<class key, class value,class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\nordered_map<int, int> my_map;\ninline int rin(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\ninline int bin(){\n\tint x=0;char ch=getchar();\n\twhile (ch<'0'||ch>'9') ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,ans,a,b,w[100004];\nvector<int>v[100004];\nvoid go(int sad,int saidan){\n\tfor(auto i:v[sad]){\n\t\tif(i==saidan) continue;\n\t\tgo(i,sad);\n\t}\n\tif(sz(v[sad])==1){\n\t\tw[sad]=0;\n\t}else{\n\t\tfor(auto i:v[sad]){\n\t\t\tif(i==saidan) continue;\n\t\t\tw[sad]^=w[i]+1;\n\t\t}\n\t}\n\n}\nint main(){FAST;xRand;\ncin>>n;\nfor(int i=1;i<n;i++){\n\tcin>>a>>b;\n\tv[a].pb(b);\n\tv[b].pb(a);\n\t\n}\ngo(1,-1);\nif(w[1]==0){\n\tcout<<\"Bob\"<<endl;\n}else{\n\tcout<<\"Alice\"<<endl;\n}\n}\n/*\n\n                   *         *\n                  * *       * *\n                 *   *     *   *\n                *     *   *     *\n                 *   *   * *   *\n                  *   *   *   *\n                   *   * *   *\n                     *  *   *\n\t\t\t\t\t   *  *\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb push_back\n#define mp std::make_pair\n//#define endl \"\\n\"\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\nusing std::endl;\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\n//const ll MOD=100000;\nconst ll MAX=1e7;\nconst ll INF=(1ll<<50);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nll modpow(ll X,ll Y){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=MOD;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=MOD;\n        }\n    }\n    return ret;\n}\nll fac[MAX],finv[MAX],inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r];\n}\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N; cin>>N;\n    vi cnt(N);\n    vi edge;\n    rep(i,1,N){\n        ll X,Y; cin>>X>>Y;\n        cnt[X-1]++;\n        cnt[Y-1]++;\n        if(X==1) edge.pb(Y-1);\n        if(Y==1) edge.pb(X-1);\n    }\n    string ans=\"Bob\";\n    if(cnt[0]==1) ans=\"Alice\";\n    if(N%2==0) ans=\"Alice\";\n    ll c=0,d=0;\n    rep(i,0,edge.size()){\n        ll X=edge[i];\n        if(cnt[X]==1) c++;\n        if(cnt[X]==2) d++;\n    }\n    if(d==1&&c==1&&cnt[0]==2) ans=\"Alice\";\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 1e5 + 10;\n\nvector<int> graph[MAX_SIZE];\nvector<bool> visited(MAX_SIZE, false);\n\n#define pb push_back\n\nll dfs(int i)\n{\n\tvisited[i] = true;\n\tif(graph[i].size() - 1 == 0)\n\t{\n\t\treturn 0;\n\t}\n\telse if(graph[i].size() - 1 == 1)\n\t{\n\t\tll s = 0;\n\t\tfor(auto &e: graph[i])\n\t\t{\n\t\t\tif(visited[e] == false)\n\t\t\t{\n\t\t\t\ts += dfs(e);\n\t\t\t}\n\t\t}\n\t\treturn 1 + s;\n\t}\n\tll s = 0;\n\tfor(auto &e: graph[i])\n\t{\n\t\tif(!visited[e])\n\t\t{\n\t\t\ts ^= dfs(e);\n\t\t}\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tint x, y;\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tcin >> x >> y;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t}\n\tgraph[1].pb(1);\n\tll a = dfs(1);\n\tif(a == 0)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> con[100001];\nqueue<pair<int, int>> q;\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tint N;\n\tcin >> N;\n\tint a, b;\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> a >> b;\n\t\tcon[a].push_back(b);\n\t\tcon[b].push_back(a);\n\t}\n\t\n\tbool seen[100001];\n\tmemset(seen, 0, sizeof(seen));\n\tq.push({1, 1});\n\tint d=1, nd, m=-1;\n\tbool aw = false;\n\twhile (!q.empty()) {\n\t\tint p = q.front().second;\n\t\tseen[p] = true;\n\t\tnd = q.front().first;\n\t\tq.pop();\n\t\tif (d != nd) {\n\t\t\tif (m %2 == 1) {\n\t\t\t\taw = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = nd;\n\t\t\tm = 0;\n\t\t}\n\t\tm++;\n\t\t//cout << p << m << \"\\n\";\n\n\t\tfor (int i: con[p]) {\n\t\t\tif (seen[i]) continue;\n\t\t\tq.push({d+1, i});\n\t\t}\n\t}\n\tif (aw or m%2) cout << \"Alice\";\n\telse cout << \"Bob\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 200005\n#define gc getchar\nusing namespace std;\n\ninline int rd() {\n  int x = 0;\n  bool f = 0;\n  char c = gc();\n  while (!isdigit(c)) {\n    if (c == '-') f = 1;\n    c = gc();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + (c ^ 48);\n    c = gc();\n  }\n  return f ? -x : x;\n}\n\nint n, tot, hd[N];\n\nstruct edge {int to, nxt;} e[N << 1];\n\ninline void add(int u, int v) {\n  e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot;\n  e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot;\n}\n\nint dfs(int u, int fa) {\n  int len = 0;\n  for (int i = hd[u], v; i; i = e[i].nxt)\n    if ((v = e[i].to) != fa) len = len ^ (dfs(v, u) + 1);\n  return len;\n}\n\nint main() {\n  n = rd();\n  for (int i = 1; i < n; ++i) add(rd(), rd());\n  puts(dfs(1, 0) ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <ctime>\n#ifdef WK\n\t#include <windows.h>\n#endif\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) (x&(-x))\n#define rep(i,x,y) for(int i=x;i<=y;i++)\n#define drep(i,x,y) for(int i=x;i>=y;i--)\n#define repg(i,x) for(int i=p[x];i;i=e[i].nt)  \nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL rtn=0;char ch=getchar();\n\twhile(ch>'9'||ch<'0')ch=getchar();\n\twhile(ch<='9'&&ch>='0')rtn=(rtn<<3)+(rtn<<1)+ch-'0',ch=getchar();\n\treturn rtn;\n}\nconst int N=100010;\nstruct edge{\n\tint b,nt;\n}e[N*2];\nint p[N],nn;\nvoid anode(int x,int y){\n\tnn++;e[nn].b=y;e[nn].nt=p[x];p[x]=nn;\n\tswap(x,y);\n\tnn++;e[nn].b=y;e[nn].nt=p[x];p[x]=nn;\n}\nint sg[N];\nvoid dfs(int x,int fa=0){\n\trepg(i,x){\n\t\tint t=e[i].b;\n\t\tif(t==fa)continue;\n\t\tdfs(t,x);\n\t\tsg[x]^=(sg[t]+1);\n\t}\n}\nint n;\nint main(){\n#ifdef WK\n\tfreopen(\"in.txt\",\"r\",stdin);\n\t//freopen(\"ou1.txt\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\trep(i,1,n-1){anode(read(),read());}\n\tdfs(1);\n\tprintf(\"%s\\n\",sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 2e5 + 50;\n\nint head[N], nxt[N], ver[N], cnt, n, SG[N];\n\ninline void add(int u, int v)\n{\n\tnxt[++cnt] = head[u], ver[cnt] = v, head[u] = cnt;\n}\n\ninline void solve(int x, int fa = -1)\n{\n\tfor (int i = head[x]; i; i = nxt[i])\n\t{\n\t\tint y = ver[i];\n\t\tif (y != fa)\n\t\t{\n\t\t\tsolve(y, x);\n\t\t\tSG[x] ^= SG[y] + 1;\n\t\t}\n\t}\n}\n\ninline char nc()\n{\n\tstatic char buf[1000000], *p1 = buf, *p2 = buf;\n\treturn p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;\n}\n\ninline int read()\n{\n\tint res = 0;\n\tchar ch;\n\tdo ch = nc(); while (ch < 48 || ch > 57);\n\tdo res = res * 10 + ch - 48, ch = nc(); while (ch >= 48 && ch <= 57);\n\treturn res;\n}\n\nint main()\n{\n\tn = read();\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd(x, y), add(y, x);\n\t}\n\tsolve(1);\n\tputs(SG[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\n\nstruct eT\n{\n\tvoid setd ( int _u, int _v, int _l )\n\t{\n\t\tu = _u, v = _v, last = _l;\n\t}\n\n\tint u, v, last;\n}edge[MAXN*2];\n\nint n;\nint ke, la[MAXN];\nint sg[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nint dfs ( int now, int fa );\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%d\", &n );\n\tint u, v;\n\tke = 0;\n\tINIT ( la, -1 );\n\tlp ( i, 1, n ){\n\t\tscanf ( \"%d%d\", &u, &v );\n\t\tedge[ke].setd ( u, v, la[u] );\n\t\tla[u] = ke++;\n\t\tedge[ke].setd ( v, u, la[v] );\n\t\tla[v] = ke++;\n\t}\n}\n\nvoid work ()\n{\n\t// main work\n\n\tprintf ( dfs ( 1, -1 ) ? \"Alice\\n\" : \"Bob\\n\" );\n}\n\n\n\nint dfs ( int now, int fa )\n{\n\tsg[now] = 0;\n\tfor ( int i = la[now]; ~i; i = edge[i].last ){\n\t\tif ( edge[i].v ^ fa ) sg[now] ^= ( dfs ( edge[i].v, now ) + 1 );\n\t}\n\treturn sg[now];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, vecin;\n    for(i = 0; i < v[nod].size(); i++){\n        vecin = v[nod][i];\n        if(vecin != t){\n            dfs(vecin, nod);\n            s[nod] ^= (s[vecin] + 1);\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(v[1].size() == 1){\n        cout<<\"Alice\";\n        return 0;\n    }\n    dfs(1, 0);\n    if(s[1] == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint n;\nvector<int> es[100000];\n\nbool solve(int v, int pa) {\n\tbool res = false;\n\tif ((es[v].size() - (pa >= 0 ? 1 : 0)) % 2 == 1) return true;\n\tREP(i, es[v].size()) if (es[v][i] != pa) {\n\t\tres = res != solve(es[v][i], v);\n\t}\n\treturn res;\n}\n\nint main(int argc, char **argv) {\n\tcin >> n;\n\tREP(i, n - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tes[x].push_back(y);\n\t\tes[y].push_back(x);\n\t}\n\tcout << (solve(0, -1) ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\t\t\t\t//Written by ThiDaiLoc\nusing namespace std;\t\t\t\t//Team Three Wolves\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pll;\n#define fu(i,a,b)   for(ll i=a;i<b;i++)\n#define fd(i,b,a)   for(ll i=b;i>=a;i--)\n#define ms(a,x)     memset(a, x, sizeof a)\n#define prec(n)     fixed<<setprecision(n)\n#define pb(i)       push_back(i)\n#define popb()      pop_back()\n#define sc(a)       cin>>a\n#define sc2(a,b)    cin>>a>>b\n#define pr(a)       cout<<a<<\" \"\n#define pr2(a,b)    cout<<a<<\" \"<<b<<\" \"\n#define lowb(a,n,x) lower_bound(a,a+n,x) -a\n#define lowb2(a,x)  lower_bound(a.begin(),a.end(),x) -a.begin()\n#define all(x)      (x).begin(), (x).end()\n#define sz(a)       (ll)a.size()\n#define le(s)       (ll)s.length()\t\t\t\t\t\t\n#define re          return \t\n#define\tmp(a,b)     make_pair(a,b)\n#define se          second\n#define fi          first \n#define debug(x)    cerr << #x << \" = \" << x << endl\n#define INPUT       freopen(\"locin.txt\", \"r\", stdin)\n#define OUTPUT      freopen(\"locout.txt\", \"w\", stdout)\nvoid inline minize(ll& a,ll b){a=(a>b?b:a);};\nvoid inline maxize(ll& a,ll b){a=(a<b?b:a);};\ndouble const eps = 1e-6;\nll const Base=1e9+7,oo=1e17,MAXN=1e5;\nll n;\nbitset <MAXN+5> came;\nvi dske[MAXN+5];\n\nll DFS(ll cur){\n\tll res=0,x,cntchild=0;\n\tcame[cur]=1;\n\t\n\tfu(i,0,sz(dske[cur])){\n\t\tx=dske[cur][i];\n\t\tif(came[x])continue;\n\t\tcntchild++;\n\t\tres^=DFS(x);\n\t}\n\tif(cntchild==1)res++;\n\tre res;\n}\n\nll Solves(){\n\t//INPUT;\n\tll x,k,cnt=0,ans=0,a,b;\n\tcame.reset();\n\t// PROCESSING IN HERE\n\tsc(n);\n\tfu(i,0,n-1){\n\t\tsc2(a,b);\n\t\tdske[a].pb(b);\n\t\tdske[b].pb(a);\n\t\t\n\t}\n\t\n\tif(DFS(1))pr(\"Alice\");\n\telse pr(\"Bob\");\n\t\n\tre 0;\n\t// Hack it if you can :)\n}\nint main(){\n\t\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tSolves();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint n;\nvector<int>g[N];\nint dfs(int x,int fa=-1){\n\tint ret=0;\n\tfor(int i:g[x])if(i!=fa)ret^=dfs(i,x)+1;\n\treturn ret;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tcout<<(dfs(1)?\"Alice\\n\":\"Bob\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[100005];\nint solve(int v,int p){\n  int x = 0;\n  for(int to : G[v]) {\n    if (to != p)\n      x ^= solve(to,v)+1;\n  }\n  return x;\n}\nint main(){\n  int n; cin >> n;\n  for(int i=0;i<n-1;i++){\n    int a,b; cin >> a >> b;\n    G[a].emplace_back( b );\n    G[b].emplace_back( a );\n  }\n  if( solve( 1, 1 ) ) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\n//I am fucking stupid\n//Stupidity level  -> 1/0\n\n\nconst int MAXN  = 101010;\nvector<int>v1[MAXN];\nint gr[MAXN];\n\nvoid DFS(int x,int par)\n{\n    for(auto itr : v1[x])\n    {\n        if(itr!=par)\n        {\n            DFS(itr, x);\n            gr[x]^=(gr[itr]+1);\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n        int n;\n        cin>>n;\n        for(int i = 0 ;i<MAXN;i+=1){\n            v1[i].clear();\n            gr[i] = 0;\n        }\n        for(int i = 1;i<=n-1;i+=1)\n        {\n            int x,y;\n            cin>>x>>y;\n            v1[x].push_back(y);\n            v1[y].push_back(x);\n        }\n        DFS(1, -1);\n        if(gr[1]==0)\n        {\n            cout<<\"Bob\"<<endl;\n        }\n        else{\n            cout<<\"Alice\"<<endl;\n        }\n    \n    return 0;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cstring>\n#define re(i,a,b) for(int i=a;i<=b;i++)\n#define _re(i,a,b) for(int i=a;i>=b;i--)\n#define for_edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define ll long long\n#define maxn 100005\n#define inf 1e9\nusing namespace std;\ninline int read(){char c = getchar();int ans = 0,f=1;while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){ans = ans*10 + c - '0';c = getchar();}return f*ans;}\n//____________________________________________________________________________________________________________________________________________________________________\nstruct edge\n{\n\tint nxt,to;\n\tedge(int nxt=0,int to=0)\n\t:nxt(nxt),to(to){};\n}e[maxn*2];\nint head[maxn],TOT=1,n,sg[maxn];\ninline void add(int x,int y)\n{\n\te[++TOT] = edge(head[x],y) ; head[x] = TOT;\n}\nvoid dfs(int x,int fa)\n{\n\tfor_edge(x)\n\t{\n\t\tint y = e[i].to ;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\tdfs(y,x);\n\t\tsg[x]^=sg[y]+1;\n\t}\n}\nint main()\n{\n\tn = read();\n\tre(i,1,n-1)\n\t{\n\t\tint x = read() , y= read();\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tif(sg[1])\n\t\tprintf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define dbg(x) cout << #x << '=' << x << '\\n';\n#define ll long long\n#define pi pair<int,int>\n#define pl pair<long long,long long>\n#define lg length()\n#define pb push_back\nifstream in(\"file.in\");\nofstream out(\"file.out\");\n#define MAXN 100005\n#define INF 1000000005\n#define LINF 1000000000000000005\n\nint n,a[100005],x,y,ans,v[100005];\n\nvector <int> g[100005];\n\nvoid DFS(int nod){\n    a[nod]=1; v[nod]=1;\n    int add=0;\n    for(int i : g[nod]){\n        if(v[i]) continue;\n        DFS(i);\n        add^=a[i];\n    }\n    a[nod]+=add;\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n;\n    for(int i=1;i<n;i++){\n        cin >> x >> y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    DFS(1);\n    for(int i : g[1]) ans^=a[i];\n    if(ans) cout << \"Alice\";\n    else cout << \"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 1000005;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 1];\n\nint head[MAX_N], sg[MAX_N], cnt, N;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nvoid dfs(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      dfs(e[i].to, u);\n      sg[u] ^= sg[e[i].to] + 1;\n    }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1, u, v; i < N; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    addedge(u, v);\n  }\n  \n  dfs(1, 0);\n\n  if (sg[1] == 0) puts(\"Bob\");\n  else puts(\"Alice\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\n#define INF 1<<30\n#define eps 1e-9\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg_var(x) clog << #x  << \": \" << x << endl;\n    #define dbg_array(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg_var(x)\n    #define dbg_array(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n// This should not compile if used.\nconst int MAXN = 120000;\n\nvector<int> aa[MAXN];\nint dfs(int v, int p) {\n    int res = 0;\n    for (int a : aa[v]) {\n        if (a == p) continue;\n        res ^= 1 + dfs(a, v);\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in online problems!\n    int N;\n    cin >> N;\n    for (int i = 0; i < N-1; i++) {\n        int a,b;\n        cin >> a >> b;\n        a--, b--;\n        aa[a].push_back(b);\n        aa[b].push_back(a);\n    }\n    cout << (dfs(0, -1) ? \"Alice\" : \"Bob\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint N;\nvector<vi> E;\nvi G;\n\nvoid dfs(int cur, int pre) {\n\tfor (int i = 0; i < (int)E[cur].size(); ++i) {\n\t\tif (E[cur][i] != pre) {\n\t\t\tdfs(E[cur][i], cur);\n\t\t\tG[cur] ^= (G[E[cur][i]] + 1);\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin >> N;\n\n\tE.resize(N + 1);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\n\tG.resize(N + 1, 0);\n\tdfs(1, 0);\n\n\tif (G[1] == 0)\n\t\tcout << \"Bob\\n\";\n\telse\n\t\tcout << \"Alice\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define long long long\n#define pll pair < long , long >\n#define vll vector < pll >\n#define ml map < long , long >\n#define mll map < pll , long >\n#define x first\n#define y second\n#define vl vector < long >\n#define io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nvl a[100005];\nlong g[100005]={0};\nvoid dfs(long node , long par)\n{\n    long i;\n    for(i=0;i<a[node].size();++i)\n    if(a[node][i]!=par)\n    {\n        dfs(a[node][i],node);\n        g[node]^=(g[a[node][i]]+1);\n    }\n}\nint main()\n{\n    io\n    long n,x,y,i;\n    cin>>n;\n    n--;\n    while(n--)\n    {\n        cin>>x>>y;\n        a[x].pb(y);\n        a[y].pb(x);\n    }\n    dfs(1,-1);\n    if(g[1]==0) cout<<\"Bob\";\n    else cout<<\"Alice\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 300000\nvector<int>g[MAX];\nint dfs(int u,int p){\n    int l=0;\n    for(int v:g[u]){\n        if(v!=p){\n         l^=1+dfs(v,u);   \n        }\n    }\n    return l;\n}\nint main() {\n\tint n,u,v;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++){\n\t    cin>>u>>v;\n\t    g[u].push_back(v);\n\t    g[v].push_back(u);\n\t}\n\tcout<<(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#pragma GCC optimize (\"-O3\")\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <bitset>\n#include <list>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <functional>\n#include <queue>\n#include <regex>\n#include <cassert>\n#include <map>\n#include <type_traits>\n#include <array>\n#include <cassert>\n#include <typeinfo>\n#include <time.h>\n#include <iomanip>\n#include <random>\n#include <sstream>\n#ifdef _MSC_VER\n#include <intrin.h>\n#define popcnt __popcnt64\n//#  define __builtin_popcount __popcnt\n#else\n#define popcnt __builtin_popcountll\n#endif\n//#include \"boost/variant.hpp\"\n\n\n\nusing namespace std;\n\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 60;\n\n#define rep(i, N, M) for(ll i=N, i##_len=(M); i<i##_len; ++i)\n#define rep_skip(i, N, M, ...) for(ll i=N, i##_len=(M); i<i##_len; i+=(skip))\n#define rrep(i, N, M)  for(ll i=(M)-1, i##_len=(N-1); i>i##_len; --i)\n#define pb push_back\n#define fir first\n#define sec second\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define perm(c) sort(all(c));for(bool c##perm=1;c##perm;c##perm=next_permutation(all(c))) //perm(c){write(c)} writes all permutation of c \n\ntypedef pair<double, double> pd;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pll> vpll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<string> vs;\ntemplate<typename T>\nusing pq_greater = priority_queue<T, vector<T>, greater<T>>;\nstruct Point { ll x; ll y; };\nusing vpt = vector<Point>;\n\ntemplate<int n>\nstruct tll_impl {\n\tusing type = decltype(tuple_cat(tuple<ll>(), declval<typename tll_impl<n - 1>::type>()));\n};\ntemplate<>\nstruct tll_impl<1> {\n\tusing type = tuple<ll>;\n};\ntemplate<int n>\nusing tll = typename tll_impl<n>::type;\n\ntemplate<class T>\nconstexpr ll SZ(T& v) { return static_cast<ll>(v.size()); };\n\ntemplate<int n, typename T>\nstruct vec_t_impl {\n\tusing type = vector<typename vec_t_impl<n-1,T>::type>;\n};\ntemplate<typename T>\nstruct vec_t_impl<1,T> {\n\tusing type = vector<T>;\n};\ntemplate<int n, typename T>\nusing vec_t = typename vec_t_impl<n, T>::type;\n// check \nstatic_assert(is_same<vec_t<3,ll>, vector<vector<vector<ll>>>>::value, \"\");\n\n// decompose vector into basetype and dimension.\ntemplate<typename T> \nstruct vec_dec {\n\tstatic constexpr int dim = 0;\n\tusing type  = T;\n};\ntemplate<typename T>\nstruct vec_dec<vector<T>> {\n\tstatic constexpr int dim = vec_dec<T>::dim+1;\n\tusing type  = typename vec_dec<T>::type;\n};\nstatic_assert(is_same<typename vec_dec<vec_t<3, ll>>::type, ll>::value, \"\");\nstatic_assert(vec_dec<vec_t<3, ll>>::dim == 3, \"\");\n\ntemplate<typename T = ll>\nvector<T> makev(size_t a) { return vector<T>(a); }\n\ntemplate<typename T = ll, typename... Ts>\nauto makev(size_t a, Ts... ts) {\n\treturn vector<decltype(makev<T>(ts...))>(a, makev<T>(ts...));\n}\n// ex:  auto dp =  makev<ll>(4,5) => vector<vector<ll>> dp(4,vector<ll>(5));\n\n// check if T is vector\ntemplate < typename T >\nstruct is_vector : std::false_type {};\n\ntemplate < typename T >\nstruct is_vector<vector<T>> : std::true_type {};\nstatic_assert(is_vector<vector<ll>>::value == true && is_vector<ll>::value == false, \"\");\n\n// check if T is vector\ntemplate < typename T>\nstruct is_pair : std::false_type {};\n\ntemplate < typename T, typename S >\nstruct is_pair<pair<T, S>> : std::true_type {};\nstatic_assert(is_pair<pll>::value == true && is_pair<ll>::value == false, \"\");\n\ntemplate<typename T, typename V, typename enable_if<!is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid fill_v(T& t, const V& v) { t = v; }\n\ntemplate<typename T, typename V, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid fill_v(T& t, const V& v) {\n\tfor (auto &&x : t)\n\t\tfill_v(x, v);\n}\n// ex:  fill_v(dp, INF);\n\ntemplate<typename T, typename enable_if < !is_vector<T>::value && !is_pair<T>::value, nullptr_t > ::type = nullptr >\nvoid read(T& x) {\tcin >> x;}\n\ntemplate<typename T, typename enable_if<is_pair<T>::value, nullptr_t>::type = nullptr>\nvoid read(T& x) { read(x.first); read(x.second); }\n\ntemplate<typename T, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid read(T& x) { rep(i,0,x.size()) read(x[i]); }\n\ntemplate<>\nvoid read(Point& p) { cin >> p.x >> p.y; }\n\ntemplate<typename T, typename Delim_t = string, typename enable_if<!is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid write(T& x, Delim_t delim = \" \") { cout << x << delim; }\n\ntemplate<typename T, typename Delim_t = string, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid write(T& x, Delim_t delim = \" \") { rep(i, 0, x.size()) write(x[i], (i == (x.size() - 1) ? \"\" : delim)); cout << '\\n'; }\n\n\n\ntemplate<typename T> void chmin(T &a, T b) {\n\tif (a > b) a = b;\n}\ntemplate<typename T> void chmax(T &a, T b) {\n\tif (a < b) a = b;\n}\n\nvll seq(ll i, ll j) {\n\tvll res(j - i);\n\trep(k, i, j) res[k] = i + k;\n\treturn res;\n}\n\nconstexpr ll POW_0(ll x, ll y) {\n\tif (y == 0)return 1;\n\tif (y == 1)return x ;\n\tif (y == 2)return x * x ;\n\tif (y % 2 == 0)return POW_0(POW_0(x, y / 2), 2LL);\n\treturn ((POW_0(POW_0(x, y / 2), 2LL)) * (x)) ;\n}\n\nconstexpr ll POW(ll x, ll y, ll mod = 0) {\n\tif (mod == 0)return POW_0(x, y);\n\tif (y == 0)return 1;\n\tif (y == 1)return x % mod;\n\tif (y == 2)return x * x % mod;\n\tif (y % 2 == 0)return POW(POW(x, y / 2, mod), 2LL, mod) % mod;\n\treturn ((POW(POW(x, y / 2, mod), 2LL, mod)) * (x % mod)) % mod;\n}\n\ntemplate<\n\ttypename Inputs,\n\ttypename Functor,\n\ttypename T = typename Inputs::value_type>\n\tvoid sort_by(Inputs& inputs, Functor f) {\n\tstd::sort(std::begin(inputs), std::end(inputs),\n\t\t[&f](const T& lhs, const T& rhs) { return f(lhs) < f(rhs); });\n}\n\ntemplate<\n\ttypename Inputs,\n\ttypename Functor,\n\ttypename T = typename Inputs::value_type>\n\tvoid stable_sort_by(Inputs& inputs, Functor f) {\n\tstd::stable_sort(std::begin(inputs), std::end(inputs),\n\t\t[&f](const T& lhs, const T& rhs) { return f(lhs) < f(rhs); });\n}\n\ntemplate<typename Inputs>\nvoid sort_uniq(Inputs& inputs) {\n\tsort(all(inputs));\n\tinputs.erase(unique(all(inputs)), inputs.end());\n}\n\nvector<string> split(const string& s, char delim) {\n\tvector<string> elems;\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, delim)) {\n\t\tif (!item.empty()) {\n\t\t\telems.push_back(item);\n\t\t}\n\t}\n\treturn elems;\n}\n\ntemplate<class T>\nmap<T,ll> inv_map(vector<T>& x) {\n\tmap<T, ll> res;\n\trep(i, 0, x.size()) {\n\t\tres[x[i]] = i;\n\t}\n\treturn res;\n}\ntemplate<class T, class val_t = typename T::value_type, enable_if_t<!is_same<T, set<val_t>>::value >* = nullptr >\nconstexpr bool exist(const T& container, val_t val) { return find(all(container), val) != container.end(); }\ntemplate<class T, class val_t = typename T::value_type,  enable_if_t<is_same<T, set<val_t>>::value >* = nullptr >\nconstexpr bool exist(const T& container, val_t val) { return container.find(val) != container.end(); }\n\n\n\n\n\nstruct UnionFind {\n\tvector<ll> data;\n\tvll querySize_;\n\tset<ll> roots;\n\tUnionFind(ll size) : data(size, -1), querySize_(size, 0) {\n\t\trep(i, 0, size) roots.insert(i);\n\t}\n\n\tll unite(ll x, ll y) {\n\t\t// return: root\n\t\tx = get_root(x); y = get_root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tquerySize_[x] += querySize_[y] + 1;\n\t\t\troots.erase(y);\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tquerySize_[x]++;\n\t\t\treturn x;\n\t\t}\n\t}\n\tbool is_same(ll x, ll y) {\n\t\t// check whether x and y are connected\n\t\treturn get_root(x) == get_root(y);\n\t}\n\tll get_root(ll x) {\n\t\t// get root\n\t\treturn data[x] < 0 ? x : data[x] = get_root(data[x]);\n\t}\n\tll size(ll x) {\n\t\treturn -data[get_root(x)];\n\t}\n\tll  query_size(ll x) {\n\t\treturn querySize_[get_root(x)];\n\t}\n\tconst set<ll>& get_roots() {\n\t\treturn roots;\n\t}\n\tvoid initialize() {\n\t\tfor (auto& i : data) {\n\t\t\ti = -1;\n\t\t}\n\t}\n};\n\n\n\n\ntemplate<class cost_t>\nstruct Edge_Base\n{\n\tll from;\n\tll to;\n\tcost_t cost;\n\tEdge_Base reverse() const { return Edge_Base{ to, from , cost }; }\n\tEdge_Base(ll from , ll to, cost_t cost=1) : from(from),to(to),cost(cost){};\n\tEdge_Base(pll e) :from(e.first), to(e.second), cost(1) { }\n\tEdge_Base() :from(0), to(0), cost(0){ };\n\tbool operator<  (const Edge_Base& e) const {\treturn cost < e.cost; }\n\tbool operator>  (const Edge_Base& e) const {\treturn cost > e.cost; }\n\tbool operator== (const Edge_Base& e) const { return cost == e.cost && from == e.from && to == e.to; }\n};\nusing Edge = Edge_Base<ll>;\n\ntemplate<class EdgeType, class EdgeContainerType>\nstruct Edge_Itr_Base {\n\tconstexpr Edge_Itr_Base() :index(), edges(nullptr) {}\n\tconstexpr Edge_Itr_Base(ll index, EdgeContainerType& edges_) :index(index), edges(&edges_) {}\n\tconstexpr Edge_Itr_Base& operator++() { ++index; return *this; }\n\tconstexpr bool operator==(const Edge_Itr_Base& rhs) const { return index == rhs.index; }\n\tconstexpr bool operator!=(const Edge_Itr_Base& rhs) const { return index != rhs.index; }\n\tconstexpr EdgeType* operator->() const { return &(*edges)[index]; }\n\tconstexpr EdgeType& operator*() const { return (*edges)[index]; }\n\tconstexpr Edge_Itr_Base& operator+=(ll n) { index += n; return *this; }\n\tll index;\n\tEdgeContainerType* edges;\n};\n\n\n\nauto nullAction = [](const auto&) {};\n\ntemplate<class cost_t>\nstruct Graph_Base {\n\tusing Edge = Edge_Base<cost_t>;\n\tusing Edge_Itr = Edge_Itr_Base<Edge_Base<cost_t>, vector<Edge_Base<cost_t>>>;\n\tusing Edge_CItr = Edge_Itr_Base<const Edge_Base<cost_t>, const vector<Edge_Base<cost_t>>>;\n\n\tll nodeSize;\n\tvector<Edge> edges;\n\tvector<vector<Edge_Itr>> out_edges;\n\tvector<vector<Edge_Itr>> in_edges;\n\tenum Dir{dir, undir};\n\tGraph_Base(ll nodeSize, const vector<Edge>& edges_ = vector<Edge>(), Dir dirct= dir)\n\t\t: nodeSize(nodeSize), out_edges(nodeSize), in_edges(nodeSize){\n\t\tif (dirct == undir) {\n\t\t\tfor (const Edge& e : edges_) push_undir(e);\n\t\t}\n\t\telse {\n\t\t\tfor (const Edge& e : edges_) push(e);\n\t\t}\n\t}\n\tGraph_Base(ll nodeSize, vector<pll> edges_, Dir dirct = dir)\n\t\t: nodeSize(nodeSize), out_edges(nodeSize), in_edges(nodeSize){\n\t\tif (dirct == undir) {\n\t\t\tfor (const pll& e : edges_) push_undir(Edge(e));\n\t\t}\n\t\telse {\n\t\t\tfor (const pll& e : edges_) push(Edge(e));\n\t\t}\n\t}\n\tGraph_Base(vvll ajacency_matrix, ll default_value) \n\t\t: nodeSize(ajacency_matrix.size()), out_edges(nodeSize), in_edges(nodeSize){\n\t\tll n = ajacency_matrix.size();\n\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (ajacency_matrix[i][j] != default_value)\n\t\t\t\tpush(Edge(i, j, ajacency_matrix[i][j]));\n\t\t}\n\t}\n\t\n\tEdge& operator[](ll ind) { return this->edges[ind]; } \n\tconst Edge& operator[](ll ind) const{ return this->edges[ind]; }\n\tvector<Edge_Itr>& out(ll ind){ return this->out_edges[ind]; }\n\tconst vector<Edge_Itr>& out(ll ind) const { return this->out_edges[ind]; }\n\tvector<Edge_Itr>& in(ll ind){ return this->in_edges[ind]; }\n\tconst vector<Edge_Itr>& in(ll ind) const{ return this->in_edges[ind]; }\n\tEdge_Itr begin() { return Edge_Itr(0, edges); }\n\tEdge_Itr end() { return Edge_Itr(edges.size(), edges); }\n\tEdge_CItr begin() const { return Edge_CItr(0, edges); }\n\tEdge_CItr end() const { return Edge_CItr(edges.size(), edges); }\n\n\tll size() const { return nodeSize; }\n\tll sizeEdges() const { return edges.size(); }\n\n\tvoid push(const Edge& edge){\n\t\tassert(max(edge.from, edge.to) < nodeSize);\n\t\tedges.emplace_back(edge);\n\t\tout_edges[edge.from].emplace_back(Edge_Itr(edges.size()-1,edges));\n\t\tin_edges[edge.to].emplace_back(Edge_Itr(edges.size() - 1, edges));\n\t}\n\tvoid push(const Edge& edge, Graph_Base::Dir dir) {\n\t\tif (dir == Dir::undir)\n\t\t\tpush_undir(edge);\n\t\telse\n\t\t\tpush(edge);\n\t}\n\tvoid push_undir(const Edge& edge) {\n\t\tpush(edge); push(edge.reverse());\n\t}\n\tvoid push(vector<Edge> edges) {\n\t\tfor (const Edge& e : edges) {\n\t\t\tpush(e);\n\t\t}\n\t}\n\tvvll adjacency_matrix() const {\n\t\tvvll d(size(), vll(size()));\n\t\tfor (auto& e : edges) {\n\t\t\td[e.from][e.to] = e.cost;\n\t\t}\n\t\treturn d;\n\t}\n\n\tvll get_topologically_sorted_nodes() const\n\t{\n\t\t// graph needs to be represented by adjacent list.\n\t\t// complexity: O( node size + edge size)\n\t\tll nodeSize = this->size();\n\n\t\t// find root\n\t\tvll roots;\n\t\tvll inDegree(nodeSize);\n\t\trep(i, 0, nodeSize)\n\t\t{\n\t\t\tfor (auto& sibling : this->out(i)) {\n\t\t\t\tinDegree[sibling->to]++;\n\t\t\t}\n\t\t}\n\t\trep(i, 0, nodeSize) {\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\troots.push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tstack<ll> parents;\n\t\tfor (ll i : roots)\n\t\t\tparents.push(i);\n\n\t\tvll sortedNodes;\n\t\twhile (!parents.empty()) {\n\t\t\tll parent = parents.top();\n\t\t\tparents.pop();\n\t\t\tsortedNodes.push_back(parent);\n\t\t\tfor (auto& sibling : this->out(parent)) {\n\t\t\t\tinDegree[sibling->to]--;\n\t\t\t\tif (inDegree[sibling->to] == 0) {\n\t\t\t\t\tparents.push(sibling->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sortedNodes;\n\t}\n\n\tvoid topological_sort() {\n\t\tvll sorted = get_topologically_sorted_nodes();\n\t\tvll new_ind(sorted.size());\n\t\tvector<Edge> new_edges;\n\t\trep(i, 0, sorted.size()) {\n\t\t\tnew_ind[sorted[i]] = i;\n\t\t}\n\t\tfor (Edge& e : edges) {\n\t\t\tnew_edges.emplace_back(Edge{ new_ind[e.from], new_ind[e.to],e.cost });\n\t\t}\n\t\t*this = Graph_Base(this->size(), new_edges);\n\t}\n\tcost_t diameter() const\n\t{\n\t\t// require : graph is tree\n\t\t// calculate the diameter ( longest path length ) in O(N)\n\t\tvector<cost_t> dp(size(), -1);\n\t\tcost_t m = 0; ll ind;\n\t\tfunction<void(ll)> dfs = [&](ll x) {\n\t\t\tfor (auto& e : out(x)) {\n\t\t\t\tll nextnode = e->to;\n\t\t\t\tif (dp[nextnode] == -1) {\n\t\t\t\t\tdp[nextnode] = dp[x] + e->cost;\n\t\t\t\t\tif (dp[nextnode] > m) {\n\t\t\t\t\t\tm = dp[nextnode];  ind = nextnode;\n\t\t\t\t\t}\n\t\t\t\t\tdfs(nextnode);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdp[0] = 0; ind = 0;\n\t\tdfs(0);\n\t\tll first = ind;\n\t\tfill_v(dp, -1);\n\t\tdp[first] = 0;\n\t\tdfs(first);\n\t\treturn m;\n\t\t// remark two end points of diameter are 'first' and 'ind';\n\t}\n\n\tvll leaves() const {\n\t\tvll res;\n\t\trep(i, 0, nodeSize) {\n\t\t\tif (out(i).size() <= 1)\n\t\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid dfs(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\t// Impliment func: void(const Edge&) representing what this should do, when target node moves from visited node (e.from) to unvisited node (e.to).\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto dfs_impl = [&](auto dfs_impl, ll startNode)-> void {\n\t\t\tvisited[startNode] = 1;\n\t\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\t\tif (visited[e->to])\n\t\t\t\t\tcontinue;\n\t\t\t\tbefore_act(*e);\n\t\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t\t\tafter_act(*e);\n\t\t\t}\n\t\t};\n\t\tdfs_impl(dfs_impl, startNode);\n\n\t};\n\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid dfs_node(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\t// Impliment func: void(ll node_ind) representing what this should do, when target node moves from visited node to unvisited node (node_ind).\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto dfs_impl = [&](auto dfs_impl, ll startNode)-> void {\n\t\t\tbefore_act(startNode);\n\t\t\tvisited[startNode] = 1;\n\t\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\t\tif (visited[e->to])\n\t\t\t\t\tcontinue;\n\t\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t\t}\n\t\t\tafter_act(startNode);\n\t\t};\n\t\tdfs_impl(dfs_impl, startNode);\n\t};\n\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid bfs(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto bfs_impl = [&](ll startNode) {\n\t\t\t//if (visited[startNode] != 0) return;\n\t\t\tvisited[startNode] = 1;\n\t\t\tqueue<Edge> toVisit;\n\t\t\tfor (auto& e : graph.out(startNode))\n\t\t\t\ttoVisit.push(*e);\n\t\t\twhile (toVisit.size()) {\n\t\t\t\tauto next = toVisit.front(); toVisit.pop();\n\t\t\t\tif (visited[next.to])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[next.to] = 1;\n\t\t\t\tbefore_act(next);\n\t\t\t\tfor (auto& e : graph.out(next.to)) {\n\t\t\t\t\tif (!visited[e->to])\n\t\t\t\t\t\ttoVisit.push(*e);\n\t\t\t\t}\n\t\t\t\tafter_act(next);\n\t\t\t}\n\t\t};\n\t\tbfs_impl(startNode);\n\t};\n\t\n\tvector<cost_t> dijkstra(ll start) const {\n\t\tvector<cost_t> fromList;\n\t\treturn dijkstra(start, fromList);\n\t}\n\n\tvector<cost_t> dijkstra(ll start, vector<cost_t>& from_list) const {\n\t\t// graph: weighted directed graph of adjacent representation\n\t\t// start: index of start point\n\t\t// return1: minimum path length from start\n\t\t// complexity : E*log(V)\n\t\tconst auto& graph = *this;\n\t\tll node_size = graph.size();\n\t\tvector<cost_t> dist(node_size, INF);\n\t\tfrom_list.resize(node_size);\n\t\tfill_v(from_list, -1);\n\t\tdist[start] = 0;\n\t\tpq_greater<pair<cost_t, pll>> pq;\n\t\tpq.push({ 0, {start, start} });\n\t\twhile (!pq.empty()) {\n\t\t\tauto node = pq.top(); pq.pop();\n\t\t\t// if not shortest path fixed, fix\n\t\t\tll from = node.second.first;\n\t\t\tll to = node.second.second;\n\t\t\tif (from_list[to] != -1)\n\t\t\t\tcontinue;\n\t\t\tfrom_list[to] = from;\n\n\t\t\tfor (auto& edge : graph.out(to)) {\n\t\t\t\tll adj = edge->to;\n\t\t\t\tcost_t cost = dist[to] + edge->cost;\n\t\t\t\tif (dist[adj] > cost) {\n\t\t\t\t\tdist[adj] = min(dist[adj], cost);\n\t\t\t\t\tpq.push({ cost ,{to, adj} });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tvll euler_tour(ll start) const\n\t{\n\t\tvll res;\n\t\tres.push_back(start);\n\t\tdfs(start, [&](const Edge& e) {\n\t\t\tres.push_back(e.to);\n\t\t\t}, [&](const Edge& e) {\n\t\t\t\tres.push_back(e.from);\n\t\t\t});\n\t\treturn res;\n\t}\n\n\tGraph_Base kruskal(Graph_Base::Dir = Dir::undir) const\n\t{\n\t\t//returns minimal spanning tree\n\t\tGraph_Base res(nodeSize);\n\t\tvpll sortedEdges;\n\t\trep(i, 0, edges.size()) {\n\t\t\tsortedEdges.push_back({ edges[i].cost, i });\n\t\t}\n\t\tsort(all(sortedEdges));\n\t\tUnionFind uf(nodeSize);\n\t\trep(i, 0, sortedEdges.size()) {\n\t\t\tll cost, eInd;\n\t\t\ttie(cost, eInd) = sortedEdges[i];\n\t\t\tll from = (*this)[eInd].from; ll to = (*this)[eInd].to;\n\t\t\tif (!uf.is_same(from, to)) {\n\t\t\t\tres.push((*this)[eInd], dir);\n\t\t\t}\n\t\t\tuf.unite(from, to);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvvll warshall_floyd() const {\n\t\t// O(|V|^3)\n\t\tconst Graph_Base& g = *this;\n\t\tll n = g.size();\n\t\tvvll d = g.adjacency_matrix();\n\t\trep(k, 0, n)rep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (d[i][j] > d[i][k] + d[k][j])\n\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t}\n\t\treturn d;\n\t}\n\n\tvll bellman_ford(ll start, ll negative_closed_loop_value = -INF) const {\n\t\tvll from_list;\n\t\treturn bellman_ford(start, from_list, negative_closed_loop_value);\n\t}\n\n\tvll bellman_ford(ll start, vll& from_list, ll negative_closed_loop_value = -INF) const {\n\t\t// O(|E| * |V|)\n\t\tconst Graph_Base& g = *this;\n\t\tvll dist(g.size(), INF);\n\t\tdist[start] = 0;\n\t\tfrom_list.resize(g.size());\n\t\trep(i, 0, g.size()) {\n\t\t\tfor(const Edge& e: g){\n\t\t\t\tif (dist[e.from] != INF && dist[e.to] > dist[e.from] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\tfrom_list[e.to] = e.from;\n\t\t\t\t\tif (i == g.size() - 1 && dist[e.to] != INF) {\n\t\t\t\t\t\t// check negative closed loop\n\t\t\t\t\t\tdist[e.to] = negative_closed_loop_value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// propagate negative path\n\t\trep(i, 0, g.size()) {\n\t\t\trep(j, 0, g.edges.size()) {\n\t\t\t\tauto& e = g.edges[j];\n\t\t\t\tif (dist[e.from] == negative_closed_loop_value && dist[e.from] != INF)\n\t\t\t\t\tdist[e.to] = negative_closed_loop_value;\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tbool is_bipartite() const {\n\t\tvll even(size(),-1);\n\t\teven[0] = 0;\n\t\tbool ok = true;\n\t\tdfs_node(0,\n\t\t\t[&](ll node) {\n\t\t\t\tfor (auto& e : out(node)) {\n\t\t\t\t\tif (even[e->to] != -1 ) {\n\t\t\t\t\t\tif (even[e->from] == even[e->to]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\teven[e->to] = !even[e->from];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\treturn ok;\n\t}\n};\n\nusing Graph = Graph_Base<ll>;\n\nvll shortest_path_generator(const vll& from_list, ll start, ll goal) {\n\t// usage : vll path =  shortest_path(dijkstra(g,s).second, s, g);\n\tvll path;\n\tpath.emplace_back(goal);\n\twhile (true) {\n\t\tll from = from_list[goal];\n\t\tpath.emplace_back(from);\n\t\tif (from == start) {\n\t\t\tbreak;\n\t\t}\n\t\tgoal = from;\n\t}\n\treverse(all(path));\n\treturn path;\n}\n\nclass FordFulkerson {\nprivate:\n\tvb usedNode;\n\tusing Edge = Edge_Base<ll>;\npublic:\n\tstruct RevEdge { ll from, to, cap, rev; };\n\n\tFordFulkerson(Graph graph) \n\t\t:usedNode(graph.size()), G(vec_t<2,RevEdge>(graph.size()))\n\t{\n\t\trep(i, 0, graph.size()) {\n\t\t\tfor (auto& e : graph.out(i)) {\n\t\t\t\tadd_revedge(*e);\n\t\t\t}\n\t\t}\n\n\t}\n\tvec_t<2, RevEdge> G;\n\tvoid add_revedge(const Edge& e) {\n\t\tG[e.from].push_back(RevEdge{ e.from, e.to ,e.cost, SZ(G[e.to]) });\n\t\tG[e.to].push_back(RevEdge{ e.to, e.from, 0 , SZ(G[e.from]) - 1 });\n\t}\n\t\n\tll single_flow(ll from, ll to, ll flow) {\n\t\t// make a single flow\n\t\tif (from == to)\n\t\t\treturn flow;\n\t\tusedNode[from] = 1;\n\t\trep(i, 0, G[from].size()) {\n\t\t\tRevEdge& e = G[from][i];\n\t\t\tif (usedNode[e.to] || e.cap <= 0)\n\t\t\t\tcontinue;\n\t\t\tll flow_from_e = single_flow(e.to, to, min(flow, e.cap));\n\t\t\tif (flow_from_e > 0) {\n\t\t\t\te.cap -= flow_from_e; assert(e.cap >= 0);\n\t\t\t\tG[e.to][e.rev].cap += flow_from_e;\n\t\t\t\t// get a larger flow\n\t\t\t\treturn flow_from_e;\n\t\t\t}\n\t\t}\n\t\t// if we already visited all edges or cap = 0 flow = 0;\n\t\treturn 0;\n\t}\n\tll max_flow(ll from, ll to) {\n\t\tll flow = 0;\n\t\twhile (true) {\n\t\t\tfill_v(usedNode, 0);\n\t\t\tll f = single_flow(from, to, INF);\n\t\t\tif (f == 0)\n\t\t\t\treturn flow;\n\t\t\telse\n\t\t\t\tflow += f;\n\t\t}\n\t}\n};\n\n// Least Common Ancestor\nclass LCA {\npublic:\n\tLCA(const Graph& graph, ll root) : max_par(ceil(log2(graph.size()) + 2)), parent(graph.size(), vll(max_par,-1)),\n\t\tdepth() {\n\t\t//parent[root][0] = root;\n\t\tgraph.dfs(root, [&](const Edge & e) {\n\t\t\tll to = e.to;\n\t\t\tparent[to][0] = e.from;\n\t\t\trep(i, 1, parent[to].size()) {\n\t\t\t\tif (parent[to][i - 1] == -1)\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\tparent[to][i] = (parent[parent[to][i - 1]][i - 1]);\n\t\t\t}\n\t\t});\n\t\tdepth = graph.dijkstra(root);\n\t}\n\tll operator()(ll node1, ll node2) {\n\t\tif (depth[node1] > depth[node2]) swap(node1, node2);\n\t\trrep(i, 0, max_par) {\n\t\t\tif (((depth[node2] - depth[node1]) >> i) & 1) {\n\t\t\t\tnode2 = parent[node2][i];\n\t\t\t}\n\t\t}\n\t\tif (node1 == node2)return node1;\n\t\trrep(i, 0, max_par) {\n\t\t\tif (parent[node1][i] != parent[node2][i]) {\n\t\t\t\tnode1 = parent[node1][i];\n\t\t\t\tnode2 = parent[node2][i];\n\t\t\t}\n\t\t}\n\t\treturn parent[node1][0];\n\t}\nprivate:\n\tll max_par;\n\tvvll parent;\n\tvll depth;\n};\n\nclass BipartiteMatching {\n\t// O(V*E)\n\tint n, left, right;\n\tvector< vector< int > > graph;\n\tvector< int > used;\n\tint timestamp;\npublic:\n\tBipartiteMatching(int left, ll right) : n(left+right), left(left), right(right), graph(n), used(n, 0), timestamp(0){}\n\n\tvoid push(int u, int v) {\n\t\tgraph[u].push_back(v + left);\n\t\tgraph[v + left].push_back(u);\n\t}\n\n\tbool dfs(int idx, vector<int>& match) {\n\t\tused[idx] = timestamp;\n\t\tfor (auto& to : graph[idx]) {\n\t\t\tint to_match = match[to];\n\t\t\tif (to_match == -1 || (used[to_match] != timestamp && dfs(to_match, match))) {\n\t\t\t\tmatch[idx] = to;\n\t\t\t\tmatch[to] = idx;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_match(vector<int>& match) {\n\t\tmatch.resize(n); fill_v(match, -1);\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < SZ(graph); i++) {\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i, match);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint bipartite_match() {\n\t\tvector<int> match;\n\t\treturn bipartite_match(match);\n\t}\n};\n\n\n\n// ================= Rectangle Area Problem =====================\nauto getNeighbor = [](ll i, ll w, ll h) {\n\tll H = i / w;\n\tll W = i % w;\n\tvll res;\n\tif (H > 0) res.push_back(i - w);\n\tif (H < h - 1) res.push_back(i + w);\n\tif (W > 0)res.push_back(i - 1);\n\tif (W < w - 1)res.push_back(i + 1);\n\treturn res;\n};\n\nauto getHW = [](ll i, ll w) {\n\tll H = i / w;\n\tll W = i % w;\n\treturn pll{ H,W };\n};\n\n\n\n\n\n\n\n\n\n// ============================ Header  =================================\ntemplate<class T, class S>\nvoid dfs_node(Graph& graph,  ll startNode, T before_act, S after_act, T before_act2, S after_act2)\n{\n\t// Impliment func: void(ll node_ind) representing what this should do, when target node moves from visited node to unvisited node (node_ind).\n\t\n\tvb visited(graph.size());\n\tauto dfs_impl = [&](auto dfs_impl, ll startNode, T before_act, S after_act)-> void {\n\t\tbefore_act(startNode);\n\t\tvisited[startNode] = 1;\n\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\tif (visited[e->to])\n\t\t\t\tcontinue;\n\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t}\n\t\tafter_act(startNode);\n\t\treturn;\n\t};\n\tdfs_impl(dfs_impl, startNode, before_act, after_act);\n\tdfs_impl(dfs_impl, startNode, before_act2, after_act2);\n\n};\n\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tll n; cin >> n;\n\tGraph g(n); \n\trep(i,0,n-1){\n\t\tll a, b; cin >> a >> b; a--; b--;\n\t\tg.push_undir({ a,b });\n\t}\n\tvll grundy(n);\n\tauto dfs = [&](auto dfs, ll from, ll to) ->void{\n\t\tfor (auto& e : g.out(to)) {\n\t\t\tif (e->to != from) {\n\t\t\t\tdfs(dfs, to, e->to);\n\t\t\t\tgrundy[to] ^= grundy[e->to] + 1;\n\t\t\t}\n\t\t}\n\t};\n\tdfs(dfs, 0, 0);\n\tll ok = grundy[0]!=0;\n\t\n\tif (ok)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nbool used[100005];\nvector<int> g[100005];\nint rnk[100005];\n\nint init(int node,int r){\n    rnk[node] = r;\n    used[node]=true;\n    for(int i=0;i<g[node].size();i++){\n        if(used[g[node][i]]) continue;\n        init(g[node][i],r+1);\n    }\n}\n\nint main(){\n    cin >> N;\n    int cnt = 0;\n    rep(i,N-1){\n        int x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n        if(x==0 or y==0) cnt++;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    init(0,0);\n    //rep(i,N) cout << i << \" \" <<rnk[i] << endl;\n\n    if(cnt==1){\n        cout << \"Alice\" << endl; \n        return 0;\n    }\n\n    int md = -1;\n    for(int i=0;i<N;i++){\n        chmax(md,rnk[i]);\n    }\n    int poi=0;\n    rep(i,N) if(rnk[i]==md) poi++;\n    if(poi%2==0){\n        cout << \"Bob\" << endl;\n    }else{\n        cout << \"Alice\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=100005;\nstruct node { int y,next; } a[N<<1];\nint head[N],sg[N],i,j,k,n,m;\nchar c;\n\ninline char getc()\n{\n\t#define VV 10000000\n\tstatic char s[VV],*l=s,*r=s;\n\tif (l==r)\n\t\tl=s,r=s+fread(s,1,VV,stdin);\n\treturn l==r?0:*l++;\n}\n\nint read(){ char c; int z=0; do c=getc(); while (c<'0'||c>'9'); while (c>='0'&&c<='9') z*=10,z+=c-'0',c=getc(); return z; }\n\nvoid jb(int x,int y)\n{\n\ta[++k]=(node){y,head[x]},head[x]=k,\n\ta[++k]=(node){x,head[y]},head[y]=k;\n}\n\nvoid dfs(int w,int sp)\n{\n\tfor (register int j=head[w];j;j=a[j].next)\n\t\tif ((j^1)!=sp)\n\t\t{\n\t\t\tint c=a[j].y;\n\t\t\tdfs(c,j),sg[w]^=sg[c]+1;\n\t\t}\n}\n\nint main()\n{\n\tn=read(),k=1;\n\tfor (i=1;i<n;++i) jb(read(),read());\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pair2;\ntypedef pair<int, pair<int, int> > pair3;\ntypedef pair<int, pair<int, pair<int, int> > > pair4;\n#define MAXN 200013\n#define INF 1000000000000000000LL\n#define MOD 1000000007LL\n#define IINF 1000000000\n#define mp make_pair\n#define pb push_back\n#define remove pop\n#define all(x) x.begin(), x.end()\n\nint n;\nvector<int> adj[MAXN];\n\n\nint solve(int cur, int par) { //Returns 0 if the first player wins, 1 if the second player wins.\n\t//Solve the children\n\n\t//cout << \"solving \" << cur << ' ' << par << endl;\n\n\tint childCount = adj[cur].size() - (par == -1 ? 0 : 1);\n\n\tif (childCount == 1) {\n\t\treturn 0; //First player moves and wins.\n\t} else if (childCount == 0) {\n\t\treturn 1;\n\t}\n\n\tint zeroes = 0;\n\tint ones = 0;\n\n\tfor (int next : adj[cur]) {\n\t\tif (next == par) continue;\n\n\t\t//cout << \"solving \" << next << \" got \" << solve(next, cur) << endl;\n\t\tif (solve(next, cur)) {\n\t\t\tones++;\n\t\t} else {\n\t\t\tzeroes++;\n\t\t}\n\t}\n\n\t//If for example we have two zeroes, result is 1. (first player picks child, second player picks, second wins.)\n\t//If we have a zero and a one , result is 0\n\n\n\tif (ones % 2 == 0 && zeroes % 2 == 0) {\n\t\treturn 1;\n\t} else if (ones % 2 == 0 && zeroes % 2 == 1) {\n\t\treturn 0;\n\t} else if (ones % 2 == 1 && zeroes % 2 == 0) {\n\t\treturn 0;\n\t} else if (ones % 2 == 1 && zeroes % 2 == 1) {\n\t\treturn 0;\n\t}\n\t//should never be reached\n\tassert(false);\n\treturn 1;\n}\n\nint main() {\n\tassert(false);\n\tif (fopen(\"FILENAME.in\", \"r\")) {\n\t\tfreopen(\"FILENAME.in\", \"r\", stdin);\n\t\tfreopen(\"FILENAME.out\", \"w\", stdout);\n\t}\n\tios_base::sync_with_stdio(false); \n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tcout << (solve(0, -1) ? \"Bob\" : \"Alice\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+20;\nint n,f[N];\nvector<int> e[N];\nvoid dfs(int u,int fa)\n{\n\tf[u]=0;\n\tfor(int i=0;i<e[u].size();i++)\n\t{\n\t\tint v=e[u][i];\n\t\tif(v==fa) \n\t\t\tcontinue;\n\t\tdfs(v,u);\n\t\tf[u]^=(f[v]+1);\n\t}\n}\nint main()\n{\n\twhile(cin>>n)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\te[i].clear();\n\t\tint u,v;\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tdfs(1,0);\n\t\tif(f[1])\n\t\t\tputs(\"Alice\");\n\t\telse\n\t\t\tputs(\"Bob\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define mod (int)1000000007\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\n#ifdef int\nconstexpr int INF = LLONG_MAX / 10;\n#else\nconstexpr int INF = INT_MAX / 10;\n#endif\nconstexpr double eps = DBL_EPSILON;\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\nint n;\nvector<int> vec[100010];\nbool used[100010];\nint dfs(int node) {\n\tused[node] = true;\n\tint cnt = 0, grundy = 0;\n\tfor (int i : vec[node]) {\n\t\tif (!used[i]) {\n\t\t\tcnt++;\n\t\t\tgrundy ^= dfs(i) + 1;\n\t\t}\n\t}\n\treturn grundy;\n}\nsigned main() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tvec[u].push_back(v);\n\t\tvec[v].push_back(u);\n\t}\n\tif (dfs(1))puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,x,y,i,ans;\nvector<int> edge[100007];\n\nint DFS(int pos, int par) {\n    int tmp = 0;\n    \n    for (int i = 0; i < edge[pos].size(); i++) if (edge[pos][i] != par) {\n        tmp ^= (1 + DFS(edge[pos][i],pos));\n    }\n    \n    return tmp;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for (i=0 ; i<n-1 ; i++) {\n        scanf(\"%d%d\",&x,&y);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    \n    ans = DFS(1,-1);\n    //printf(\"%d\\n\",ans);\n    if (ans == 0) printf(\"Bob\\n\"); else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nconst int maxn = 1e5 + 5;\n\nvector<int> adj[maxn];\nint DFS(int u , int par){\n    int cnt = 0 , res = 0;\n    for(int c : adj[u]){\n        if(c == par)continue;\n        res ^= DFS(c , u);\n        ++cnt;\n    }\n    return res += (cnt == 1);\n}\nint n;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n;\n    for(int i = 1; i < n ; ++i){\n        int u,v;cin >> u >> v;\n        adj[u].pb(v);adj[v].pb(u);\n    }\n    puts(DFS(1,0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <complex>\n#include <ctime>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\n#define REP(i,s,t) for(int i=(s);i<(t);i++)\n#define FILL(x,v) memset(x,v,sizeof(x))\n\nconst int INF = (int)1E9;\n#define MAXN 100005\n\nint N;\nVI adj[MAXN];\nint dfs(int x, int p) {\n  int sg = 0;\n  REP(i,0,adj[x].size()) {\n    int y = adj[x][i];\n    if (y == p) continue;\n    sg ^= dfs(y, x) + 1;\n  }\n  return sg;\n}\nint main() {\n  cin >> N;\n  REP(i,0,N-1) {\n    int x,y;\n    scanf(\"%d%d\", &x, &y); x--; y--;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  puts(dfs(0, -1) ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin n;\nVVI egs;\nin gn(in u, in pr){\n  in tn;\n  in txor=0;\n  forv(i,egs[u]){\n    if(egs[u][i]==pr)\n      continue;\n    tn=gn(egs[u][i],u);\n    txor^=tn;\n  }\n  return txor+1;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n;\n  egs.resize(n);\n  in ta,tb;\n  forn(z,n-1){\n    cin>>ta>>tb;\n    --ta;\n    --tb;\n    egs[ta].PB(tb);\n    egs[tb].PB(ta);\n  }\n  if(gn(0,0)==1)\n    cout<<\"Bob\"<<endl;\n  else\n    cout<<\"Alice\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    int s = 0;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        s ^= !d[h];\n    }\n    if ((sz(v[u]) - (u ? 1: 0)) % 2 == 1) {\n        d[u] = 1;\n    }\n    d[u] |= s;\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n;\nint x, y;\n\nint main()\n{\n\tcin >> n;\n\tint a, b;\n\tx = y = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tif (a == 1 || b == 1)\n\t\t\tx++;\n\t\telse\n\t\t\ty++;\n\t}\n\tif (x == 1)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t{\n\t\tint xx = x % 2;\n\t\tint yy = y % 2;\n\t\tif (xx + yy == 1)\n\t\t\tcout << \"Alice\" << endl;\n\t\telse\n\t\t\tcout << \"Bob\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nconstexpr int ms = 100100;\n\nvector<int> g[ms];\ndeque<bool> explored(ms, false);\nint node_xor[ms];\n\nvoid explore( int root ) {\n    explored[ root ] = true;\n    int countKid = 0;\n    for(const int& nei : g[root] ) {\n        if( explored[nei] == false ) {\n            countKid++;\n            explore(nei);\n            node_xor[root] ^= node_xor[nei];\n        }\n    }\n    if( root != 0 ) node_xor[root]++;\n}\n\n\nint main()\n{\n    int n;\n    ios::sync_with_stdio( false ); cin.tie(NULL);\n    cin >> n;\n    for(int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        g[a].push_back( b );\n        g[b].push_back( a );\n    }\n\n    explore(0);\n    \n    cout << ( node_xor[0] == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 1e5 + 10;\n\nvector<int> graph[MAX_SIZE];\nvector<bool> visited(MAX_SIZE);\n\nll dfs(int a)\n{\n\tvisited[a] = true;\n\tvector<ll> G;\n\tfor(auto &u : graph[a])\n\t{\n\t\tif(!visited[u])\n\t\t{\n\t\t\tG.pb(dfs(u));\n\t\t}\n\t}\n\tif(G.size() == 1)\n\t\treturn 1 + G[0];\n\telse if(G.size() == 0)\n\t\treturn 0;\n\tll s = 0;\n\tfor(auto &g : G)\n\t{\n\t\ts ^= (g + 1);\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tint x, y;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tcin >> x >> y;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t\tvisited[x] = false;\n\t\tvisited[y] = false;\n\t}\n\tll s = dfs(1);\n\tif(s == 0)\n\t\tcout << \"Bob\" << endl;\n\telse\n\t\tcout << \"Alice\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define pb push_back\n#define ld long double\n\nusing namespace std;\n\nconst int MAXN = 1048576 , MOD = 1e9 + 7 ;\n\nvector<int> adj[MAXN] ; \n\nint dp[MAXN] ; \n\nvoid dfs(int u , int p)\n{\n    for(auto v : adj[u])\n    {\n        if(v==p) continue ; \n        dfs(v,u) ; \n        dp[u] ^= dp[v] + 1 ; \n    }       \n}\n\nint32_t main() \n{\n    ios::sync_with_stdio(0); \n    int n ;\n    cin >> n ; \n    for(int i = 1 ; i < n ; i ++ )\n    {\n        int x ,  y ; \n        cin >> x >> y ;\n        adj[x].push_back(y) ; \n        adj[y].push_back(x) ; \n    }\n    dfs(1,-1) ; \n    cout << (dp[1]?\"Alice\":\"Bob\") << endl ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\n\nvector<int> G[100001];\n\nint dfs(int u, int p) {\n    int ret = 0;\n    for (int v : G[u]) if (v != p) ret ^= (dfs(v, u) + 1);\n    return ret;\n}\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int N; cin >> N;\n    for (int i = 1; i < N; ++i) {\n        int x, y; cin >> x >> y;\n        G[x].push_back(y), G[y].push_back(x);\n    }\n    cout << (dfs(1, 0) ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n//#define max(a,b) ((a)<(b)?(b):(a))\n//#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) a^=b^=a^=b\n#define lb(x) ((x)&(-(x)))\n#define dalao 1000000007\n#define inf 0x3f3f3f3f\n#define N 100010\nusing namespace std;\ntypedef long long ll;\nint n,f[N],a,b;\nvector<int> g[N];\ninline void dfs(int x,int p){\n\tfor(int i=0;i<g[x].size();i++)if(g[x][i]^p)dfs(g[x][i],x),f[x]^=(f[g[x][i]]+1);\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&a,&b),g[a].push_back(b),g[b].push_back(a);\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,n) for(ll i=(ll)a;i<(ll)n;i++)\n#define rep(i,n) FOR(i,0,n)\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>bool chmax(T &a,const T &b){\n    if(a>b)return false;\n    a=b;\n    return true;\n}\ntemplate<class T>bool chmin(T &a,const T &b){\n    if(a<b)return false;\n    a=b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n,x,y;\nvector<int> e[100009];\nbool visited[100009];\n\nint dfs(int m){\n    visited[m]=true;\n    int re=0,cnt=0;\n    rep(i,e[m].size()){\n        if(!visited[e[m][i]])cnt++,re^=dfs(e[m][i]);\n    }\n    return re+(cnt==1);\n}\n\nint main(){\n    cin>>n;\n    rep(i,n-1){\n        cin>>x>>y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    cout<<(dfs(1)?\"Alice\\n\":\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nll d[1000000];\n\nvoid addedge(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\n//根付き木を作る。parentVectorに親nodeの番号が入る。\n//parentVector[root] = -1\n//treeRankVectorにはnodeのrankが入る。rootのrankは0\nvector<ll> par;\nvector<ll> treeRank;\nvoid makeRootedTree(vector<ll> &parentVector, vector<ll> &treeRankVector, ll vecSize, ll root) {\n    parentVector = vector<ll>(vecSize);\n    treeRankVector = vector<ll>(vecSize);\n    assert(root < (ll)parentVector.size());\n    parentVector[root] = -1;\n    treeRankVector[root] = 0;\n    queue<ll> que;\n    que.push(root);\n    while (!que.empty()) {\n        ll node = que.front();\n        que.pop();\n        REP (i, 0, G[node].size()) {\n            edge e = G[node][i];\n            if (e.to != parentVector[node]) {\n                parentVector[e.to] = node;\n                treeRankVector[e.to] = treeRankVector[node] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    V = N;\n    REP(i, 0, N - 1) {\n        ll x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        addedge(x, y, 1);\n        addedge(y, x, 1);\n    }\n    makeRootedTree(par, treeRank, N, 0);\n    vector<ll> grundy;\n    REP(i, 0, G[0].size()) {\n        queue<ll> que;\n        vector<ll> rank;\n        que.push(G[0][i].to);\n        rank.push_back(1);\n        while (!que.empty()) {\n            ll node = que.front();\n            que.pop();\n            REP(j, 0, G[node].size()) {\n                edge e = G[node][j];\n                if (e.to != par[node]) {\n                    rank.push_back(treeRank[e.to]);\n                    que.push(e.to);\n                }\n            }\n        }\n        sort(rank.begin(), rank.end());\n        ll tmpgr = 0;\n        ll num = rank[0];\n        ll tmp = 1;\n        REP(j, 1, rank.size()) {\n            if (rank[j] != num) {\n                if (tmp == 1) {\n                    tmpgr++;\n                }\n                tmp = 1;\n                num = rank[j];\n            } else {\n                tmp++;\n            }\n        }\n        if (tmp == 1) {\n            tmpgr++;\n        }\n        grundy.push_back(tmpgr);\n    }\n    ll ans = 0;\n    REP(i, 0, grundy.size()) {\n        ans ^= grundy[i];\n    }\n    if (ans != 0) {\n        cout << \"Alice\" << endl;\n    } else {\n        cout << \"Bob\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 1;\nvector<int> edges[MAX_N];\nbool check[MAX_N];\n\nint dfs( int u ) {\n    check[u] = 1;\n    int ans = 0;\n    for ( int v : edges[u] )\n        if ( !check[v] ) {\n            ans ^= 1 + dfs( v );\n        }\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for ( int i = 0; i < n - 1; i++ ) {\n        int x, y;\n        cin >> x >> y;\n        edges[x].push_back( y );\n        edges[y].push_back( x );\n    }\n\n//    cout << dfs(1);\n    cout << ( dfs( 1 ) ? \"Alice\" : \"Bob\" );\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define f first\n#define s second\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n#define ll long long\n#define ld double\n#define ull unsigned long long\n#define PI pair < int, int > \n#define hash puper123\n\nconst int N = 5e5 + 123;\nconst int M = 123;\nconst ld Pi = acos(-1);\nconst ll Inf = 1e18;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nconst int Sz = 501;\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nint mult(int a, int b) {\n  return 1ll * a * b % mod;\n}\nint sum(int a, int b) {\n  add(a, b);\n  return a;\n}\n\nint n, dp[N];\nvector < int > g[N];\nint used[N], timer;\n\nvoid dfs(int v, int pr = -1) {\n  timer++;\n  for (auto to : g[v]) {\n    if (to != pr) {\n      dfs(to, v);\n      used[dp[to]] = timer;\n    }\n  }\n  while(used[dp[v]] == timer) dp[v]++;\n  //cout << \"v = \" << v << \" dp = \" << dp[v] << endl;\n}\nvoid solve() {\n  cin >> n;\n  for (int i = 1, u, v;i < n;i++) {\n    cin >> u >> v;\n    g[u].pb(v);\n    g[v].pb(u);\n  }\n  dfs(1);\n  int ans = 0;\n  for (auto to : g[1]) ans ^= dp[to];\n  if (ans) cout << \"Alice\\n\";\n  else cout << \"Bob\\n\";\n}\n\nint main() {\n  #ifdef wws\n   freopen(\"in\", \"r\", stdin);\n  #endif \n  ios_base::sync_with_stdio(0);\n  int tt = 1; \n  while(tt--) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>          \n#include <map>           \n#include <list>\n#include <ctime>\n#include <deque>         \n#include <bitset>        \n#include <vector>\n#include <list>\n#include <stack>\n#include <random>\t\t \n#include <string>       \n#include <numeric>      //  needed for  accumulate\n#include <utility>      // needed for std:: move\n#include <iterator> \n#include <iostream>   \n#include <algorithm> \n#include <functional>    \n#include <cmath>         \n#pragma warning(disable:4996) // ignore this\n#define ve vector\n#define pb push_back\n#define mp make_pair                     \n#define srt(x) sort(x.begin(),x.end())         \n#define mod static_cast<long long> (1e9+7)     \n#define sumx(x) accumulate(x.begin(),x.end(),0LL)\n#define pi 3.14159265358979323846\nusing namespace std;\ntemplate<typename T>\nistream& operator >> (istream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin >> x;\n\treturn in;\n}\ntemplate<typename T>\nostream& operator<<(ostream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin << x << \" \";\n\treturn in;\n}\nclass solve\n{\n\tlong long n;\n\tve<bool > vis;\n\tve<ve<int> > adj;\n\tve<ve<int> > adj2;\n\tvoid dfs(int c=0)\n\t{\n\t\tvis[c]=true;\n\t\tfor(auto &x:adj[c])\n\t\t{\n\t\t\tif(!vis[x])\n\t\t\t{\n\t\t\t\tadj2[c].pb(x);\n\t\t\t\tdfs(x);\n\t\t\t}\n\t\t}\n\t}\n\tint winner(int c=0)\n\t{\n\t\tvis[c]=false;\n\t\tif(adj2[c].size()==1)\n\t\t\treturn 1;\n\t\tint ans=0;\n\t\tfor(auto &x:adj2[c])\n\t\t{\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tans^=winner(x);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\npublic:\n\tsolve()\n\t{\n\t\tcin >> n;\n\t\tvis.resize(n);\n\t\tadj.resize(n);\n\t\tadj2.resize(n);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\t--x,--y;\n\t\t\tadj[x].pb(y);\n\t\t\tadj[y].pb(x);\n\t\t}\n\t\tdfs();\n\t\tint p=winner(0);\n\t\tif(p)\n\t\t{\n\t\t\tcout << \"Alice\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"Bob\\n\";\n\t\t}\n\t}\n};\n \nint main()\n{\n\tint t = 1, i = 1;\n\t//scanf(\"%d\", &t);\n \n\twhile (t--)\n\t{\n\t\tnew solve;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nstruct T {\n\tint to, nxt;\n} way[maxn << 1];\nint h[maxn], num;\ninline void link(int x,int y) {\n\tway[++num] = {y,h[x]}, h[x] = num;\n\tway[++num] = {x,h[y]}, h[y] = num;\n}\nint n;\ninline int dfs(int x,int fa = 0) {\n\tint ret = 0;\n\tfor(int i = h[x];i;i = way[i].nxt) if(way[i].to != fa)\n\t\tret ^= dfs(way[i].to, x) + 1;\n\treturn ret;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\trep(i, 1, n - 1) { \n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tlink(x, y);\n\t}\n\tcout << (dfs(1) ? \"Alice\" : \"Bob\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 100, MOD = 1000 * 1000 * 1000 + 7;\n\nint n, dp[N];\nvector<int> nei[N];\n\nvoid input() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n}\n\nvoid dfs(int v = 0, int par = -1) {\n\tfor (int u: nei[v])\n\t\tif (u ^ par) {\n\t\t\tdfs(u, v);\n\t\t\tdp[v] ^= ++dp[u];\n\t\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tinput();\n\tdfs();\n\tcout << (dp[0] == 0? \"Bob\\n\": \"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=1e5+5;\n\nint n;\n\nint tot,go[2*maxn],next[2*maxn],f1[maxn];\nvoid ins(int x,int y)\n{\n\tgo[++tot]=y;\n\tnext[tot]=f1[x];\n\tf1[x]=tot;\n}\n\nint sg[maxn];\nvoid dfs(int k,int last)\n{\n\tsg[k]=0;\n\tfor(int p=f1[k]; p; p=next[p]) if (go[p]!=last)\n\t{\n\t\tdfs(go[p],k);\n\t\tsg[k]^=(sg[go[p]]+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tins(x,y), ins(y,x);\n\t}\n\t\n\tdfs(1,0);\n\t\n\tprintf((sg[1]) ?\"Alice\\n\" :\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define REP(i, k) for (std::decay_t<decltype(k)> i = 0; i < k; i++)\n#define LOOP(k) REP (ngtkana_is_a_genius, k)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\ntemplate <class F>\nclass fixed_point {\n    F f;\n    public:\n    fixed_point(F&& f_) : f(f_) {}\n    template <class... Args> auto operator() (Args... args) { return f(f, args...); }\n};\ntemplate <class F> auto make_fixed_point(F&& f) { return fixed_point<F>(std::forward<F&&>(f)); }\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    u32 n; std::cin >> n;\n    vec<vec<u32>> g(n);\n    LOOP (n-1) {\n        u32 u, v; std::cin >> u >> v, u--, v--;\n        g.at(u).push_back(v);\n        g.at(v).push_back(u);\n    }\n\n    vec<u32> dp(n);\n    make_fixed_point([&](auto&& dfs, u32 x, u32 p) -> void {\n        auto&& v = g.at(x);\n        for (u32 y: v) if (y!=p) {\n            dfs(dfs, y, x);\n            dp.at(x) ^= dp.at(y);\n        }\n        dp.at(x)++;\n    })(0, 0);\n    std::cout << (dp.at(0)!=1 ? \"Alice\" : \"Bob\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n#include <assert.h>\n#include <unordered_set>\n#include <random>\n\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\n\n\n\n\nvector<vector<ll>> g;\nll xorsum = 0;\n \nll dfs(ll now, ll par){\n    ll res = 0;\n    for(auto &child : g[now]){\n        if(child == par) continue;\n        res ^= dfs(child, now) + 1;\n    }\n    return res;\n}\n \n \n \nint main(){\n    ll n;\n    cin >> n;\n    g.resize(n);\n    REP(i, n - 1){\n        ll x, y;\n        cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    cout << (dfs(0, -1)? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int h[1 << 20];\n    static int cnt[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        h[node] = h[prev] + 1;\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node);\n    };\n    dfs(1,0);\n    int ans = 0;\n    for (int i = 1;i <= n;++i)\n        ans ^= (h[i] - 1) & 1;\n    fo << (ans ? \"Alice\":\"Bob\") << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\tvector<ULL>cash;\n\tULL ret = 1;\n\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tcash.push_back(seed(now, ch));\n\t\tret += cash.back();\n\t}\n\n\tsort(cash.begin(),cash.end());\n\n\twhile (cash.size() > 1 &&\n\t\tcash[cash.size() - 1] == cash[cash.size() - 2])\n\t{\n\t\tcash.pop_back();\n\t\tcash.pop_back();\n\t}\n\n\tif (cash.empty())\n\t{\n\t\treturn 1;\n\t}\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 1)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100005\nvector<int>edge[M];\nint Get_sg(int x,int pre){\n\tint res=0;\n\tfor(int i=0;i<edge[x].size();i++)\n\t\tif(edge[x][i]!=pre)res^=(Get_sg(edge[x][i],x)+1);\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tif(Get_sg(1,-1))puts(\"Alice\");\n\telse puts(\"Bob\");  \n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200011\ntypedef struct{\n\tint to,nxt;\n}edge;\nedge e[N<<2];\nint head[N<<2],sg[N],n,a,b,cnt;\nvoid add(int a,int b){\n\tcnt++;\n\te[cnt].to=b;\n\te[cnt].nxt=head[a];\n\thead[a]=cnt;\n}\nvoid dfs(int u,int fa){\n\tsg[u]=0;\n\tfor(int i=head[u];i!=-1;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\nint main(){\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);add(b,a);\n\t}\n\tdfs(1,0);\n\tif(sg[1]==0) printf(\"Bob\\n\");else printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 2e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double dbl;\n#define pb push_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define all(a) a.begin(),a.end()\nbool debug = 0;\nconst int MAXN = 2e5 + 100;\nconst int LOG = 25;\nconst int mod = 998244353;\nconst int MX = 1e6 + 100;\ntypedef long long li;\nconst li MOD = 1000000000949747713ll;\n\nvector<int> g[MAXN];\n\n\nint dfs(int v, int p) {\n    vector<int> vals;\n    for (int to:g[v]) {\n        if (to == p)\n            continue;\n        int res = dfs(to, v);\n        vals.pb(res);\n    }\n    if (sz(vals) == 0) {\n        return 1;\n    } else if (sz(vals) == 1) {\n        return vals[0] + 1;\n    } else {\n        int val = 0;\n        for (int v:vals) {\n            val ^= v;\n        }\n        return val + 1;\n    }\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    int res = dfs(1,1);\n    if(res == 1){\n        cout <<\"Bob\";\n    } else{\n        cout <<\"Alice\";\n    }\n}\n\nsigned main() {\n#ifdef zxc\n    debug = 1;\n    freopen(\"../input.txt\", \"r\", stdin);\n    //freopen(\"../output.txt\", \"w\", stdout);\n#else\n\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(20);\n\n    int t = 1;\n    while (t--)\n        solve();\n    if (debug)\n        cerr << endl << \"time : \" << (1.0 * clock() / CLOCKS_PER_SEC) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 100000;\n\nint n;\nvector<int> adj[MaxN + 1];\n\nint dfs(int u, int fa)\n{\n\tint w = 0;\n\tfor (int v : adj[u])\n\t\tif (v != fa)\n\t\t\tw ^= dfs(v, u) + 1;\n\treturn w;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = getint(), v = getint();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tcout << (dfs(1, 0) ? \"Alice\" : \"Bob\");\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <list>\n#include <map>\n#include <queue>\n#include <iterator>\n#include <iomanip>\n#include <stdio.h>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define ld long double\n#define infinity (ll)1e18+1\n#define PI 3.14159265358979\n\n#define pdd pair<ld,ld>\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n\n#define MP make_pair\n#define SZ size()\n#define PB push_back\n\n#define vi vector<int>//ll\n#define vll vector<ll>\n#define vpll vector<pll>\n#define vpii vector<pii>\n#define vch vector<char>\n#define vb vector<bool>\n#define vld vector<ld>\n\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(ll i = (b) - 1; i >= (a); --i)\n#define REPEAT(i) FOR(counter1234,0,i)\n#define ALL(a) a.begin(), a.end()\n#define X first\n#define Y second\n#define MAXN 100001\nclock_t startTime;\n\nint n;\nvi g[MAXN];\n\nvi sons;\nint c = 0;\nvch used;\nvoid dfs(int v)\n{\n\tint s = c;\n\tused[v] = 1;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t\tdfs(i), c++;\n\tsons[v] = c - s;\n}\nint d[MAXN];\n\nvoid bfs()\n{\n\td[1] = 0;\n\tused.assign(n + 1, 0);\n\tused[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor(auto i: g[t])\n\t\t\tif (used[i] == 0)\n\t\t\t{\n\t\t\t\tused[i] = 1;\n\t\t\t\td[i] = d[t] + 1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tstartTime = clock();\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\t//ifstream in(\"In.txt\");\n\n\tcin >> n;\n\tint a, b;\n\tsons.assign(n + 1, 0);\n\tused.assign(n + 1, 0);\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll XOR_ALL = 0;\n\tdfs(1);\n\tbfs();\n\n\tvi xors;\n\txors.assign(n + 1, 0);\n\n\tFOR(i, 1, n + 1)\n\t\tfor (auto s : g[i])\n\t\t\tif (d[s] > d[i])\n\t\t\t\txors[i] ^= (sons[s] + 1);\n\t\t\n\tll x = 0;\n\tfor (auto s : g[1])\n\t\tx ^= xors[s];\n\tif (x == 0)\n\t\tcout << \"Bob\";\n\telse\n\t\tcout << \"Alice\";\n\n\treturn 0;\n}\n//don't forget about MAXN, mod and infinity "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> v[maxn];\n\nint dfs(int root, int fa) {\n    int ret = 0;\n    for (int i = 0;i < v[root].size();i++) {\n        int to = v[root][i];\n        if (to == fa) continue;\n\n        ret ^= 1 + dfs(to, root);\n    }\n    return ret;\n\n}\nint main() {\n    \n    int n;\n    cin >> n;\n    for (int i = 1, xi, yi;i < n;i++) {\n        scanf(\"%d %d\", &xi, &yi);\n        v[xi].push_back(yi);\n        v[yi].push_back(xi);\n    }\n    if (dfs(1, 0) != 0) {\n        printf(\"Alice\\n\");\n    }\n    else {\n        printf(\"Bob\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n, a, b; vector<int>x[125000];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b;\n\t\tx[a].push_back(b);\n\t\tx[b].push_back(a);\n\t}\n\tif (n % 2 == 0 || x[1].size() % 2 == 1)cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool seen[100010];\nvector<int> adj[100010];\nint n;\nint dfs(int a)\n{\n\tseen[a] = 1;\n\tint winner = 0;\n\tint num = 0;\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!seen[b]) winner ^= dfs(b), num++;\n\t}\n\tif (num == 1) winner++;\n\treturn winner;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tint res = dfs(1);\n\tif (res) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 200010\n#define M 400010\n\nusing namespace std;\n\nint ans[N];\nint ver[M],nex[M],head[N],nu;\nint n,x1,x2;\n\ninline int read(){\n\tint x=0;char c=getchar();\n\tfor(;c<'0' || c>'9';c=getchar());\n\tfor(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;\n\treturn x;\n}\n\ninline void add(int x,int y){\n\tver[++nu]=y;nex[nu]=head[x];head[x]=nu;\n}\n\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=nex[i]){\n\t\tint y=ver[i];\n\t\tif(y!=fa)\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tans[x]^=(ans[y]+1);\n\t\t}\t\n\t}\n\treturn;\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\tx1=read(),x2=read(),add(x1,x2),add(x2,x1);\n\tdfs(1,0);\n\tif(!ans[1]) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n\treturn 0;\n}                                                                                                                                                                                                                     "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#define ld long double\n#define MN 210000\nusing namespace std;\n\nint read_p,read_ca;\ninline int read(){\n    read_p=0;read_ca=getchar();\n    while(read_ca<'0'||read_ca>'9') read_ca=getchar();\n    while(read_ca>='0'&&read_ca<='9') read_p=read_p*10+read_ca-48,read_ca=getchar();\n    return read_p;\n}\nstruct na{int y,ne;}b[MN];\nint n,m,l[MN],num=0,x,y,s[MN];\ninline void in(int x,int y){\n\tb[++num].y=y;b[num].ne=l[x];l[x]=num;\n}\nvoid dfs(int x,int f){\n\tint u=0;s[x]=0;\n\tfor (int i=l[x];i;i=b[i].ne)\n\tif (b[i].y!=f){\n\t\tdfs(b[i].y,x);u^=s[b[i].y]+1;\n\t}\n\t\n\ts[x]=bool(u);\n\t/*for (int i=l[x];i;i=b[i].ne)\n\tif (b[i].y!=f){\n\t\tif ((u^s[b[i].y])==0) s[x]=1;\n\t}*/\n\t//printf(\"%d %d\\n\",x,s[x]);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<n;i++) x=read(),y=read(),in(x,y),in(y,x); \n\t\n\tdfs(1,0);\n\tputs(s[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nvector<int> g[N];\nint n;\n\nstatic int dfs(int u, int far = -1) {\n    int sg = 0;\n    for (auto v: g[u]) if (v != far)\n        sg^= dfs(v, u);\n    return sg + 1; }\n\nint main() {\n#ifdef HOME\n    freopen(\"dat.in\", \"r\", stdin);\n    freopen(\"dat.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    for (int a, b, i = 1; i < n; ++i) {\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a); }\n\n    cout << (dfs(1) > 1 ? \"Alice\" : \"Bob\") << endl;\n\n    return 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include <ios>\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int> > adjlist;\nstd::vector<std::vector<int> > children;\nbool vis[100005] = {};\n\nvoid dfs(int x)\n{\n    for (std::vector<int>::iterator it = adjlist[x].begin(); it != adjlist[x].end(); it++)\n    {\n        if (!vis[*it])\n        {\n            vis[*it] = true;\n            children[x].push_back(*it);\n            dfs(*it);\n        }\n    }\n}\n\nint nim(int x)\n{\n    if (children[x].size() == 0)\n        return 0;\n    else if (children[x].size() == 1)\n        return nim(*children[x].begin())+1;\n    else\n    {\n        int nm = 0;\n        for (std::vector<int>::iterator it = children[x].begin(); it != children[x].end(); it++)\n            nm ^= nim(*it);\n        return nm;\n    }\n}\n\nint main()\n{\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    std::cout.tie(NULL);\n    int n, x, y;\n    std::cin >> n;\n    adjlist.resize(n+5);\n    children.resize(n+5);\n    for (int i = 0; i < n-1; i++)\n    {\n        std::cin >> x >> y;\n        x--; y--;\n        adjlist[x].push_back(y);\n        adjlist[y].push_back(x);\n    }\n    vis[0] = true;\n    dfs(0);\n    std::cout << (nim(0) == 0 ? \"Bob\" : \"Alice\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mkp make_pair\n#define pii pair<int, int> \n#define pll pair<long long int, long long int>\n#define sci(x) scanf(\"%d\", &x)\n#define scl(x) scanf(\"%lld\", &x)\n#define fi first\n#define sc second\n#define deb 0\n\nvector <int> v[100001];\n\nint dfs(int x, int p)\n{\n\tint ans = 0;\n\tfor (int y: v[x]) {\n\t\tif (y == p) continue;\n\t\tans ^= dfs(y, x);\n\t}\n\treturn ans+1;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cout.tie(0);cin.tie(0);\n\n\tint n, i, j, k, x, y;\n\tcin >> n;\n\tfor (i = 1; i < n; ++i) {\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\n\tcout << dfs(1, 0) << endl;\n\tputs(dfs(1, 0) == 1 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint dp[100010];\nvector<int> V[100010];\nint depth[100010] = {0};\n\nint DP(int n)\n{\n    if(n == 1)\n    {\n        if(V[1].size() == 1)return DP(V[1][0]) + 1;\n        int res = -1;\n        for(int i = 0; i < V[1].size(); i++)\n        {\n            if(res == -1)res = DP(V[1][i]) + 1;\n            else res ^= DP(V[1][i]) + 1;\n        }\n        return res;\n    }\n    if(V[n].size() == 1)return 0;\n    if(V[n].size() == 2)\n    {\n        for(int i = 0; i < V[n].size(); i++)\n        {\n            if(depth[n] < depth[V[n][i]])return DP(V[n][i]) + 1;\n        }\n    }\n    int res = -1;\n    for(int i = 0; i < V[n].size(); i++)\n    {\n        if(depth[n] > depth[V[n][i]])continue;\n        if(res == -1)res = DP(V[n][i]) + 1;\n        else res ^= DP(V[n][i]) + 1;\n    }\n    return res;\n}\n\nvoid DFS(int n,int d)\n{\n    if(depth[n] != 0)return;\n    depth[n] = d;\n    for(int i = 0; i < V[n].size(); i++)\n    {\n        DFS(V[n][i],d + 1);\n    }\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N; i++)dp[i] = -1;\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        V[a].push_back(b);\n        V[b].push_back(a);\n    }\n    DFS(1,1);\n    if(DP(1))printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1e5+3;\nstruct edge{int v,nxt;}g[N+N];\nint n,head[N],k,f[N];\ninline void Insert(int u,int v){g[++k]=(edge){v,head[u]};head[u]=k;}\nvoid Dfs(int u,int fa){\n\tint v;\n\tfor(int i=head[u];i;i=g[i].nxt)if((v=g[i].v)!=fa)\n\t  Dfs(v,u),f[u]^=f[v]+1;\n}\nint main(){\n\tint u,v;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t  scanf(\"%d%d\",&u,&v),Insert(u,v),Insert(v,u);\n\tDfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> v[100010];\nint yh(int id,int f)\n{\n    int res,i;\n    if (f==-1)\n    {\n        if (v[id].size()==1) return 1;\n    }\n    else\n    {\n        if (v[id].size()==1) return 0;\n        if (v[id].size()==2) return 1;\n    }\n    res=0;\n    for(i=0;i<v[id].size();i++)\n    {\n        if (v[id][i]==f) continue;\n        res^=yh(v[id][i],id);\n    }\n    return res;\n}\nint main()\n{\n    int n,i,x,y,ans;\n    cin>>n;\n    for(i=1;i<=n-1;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    ans=yh(1,-1);\n    if (ans) cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn=100000+5;\nint h[maxn],mem;\nstruct\n{\n    int v,next;\n}e[maxn<<1];\nvoid add(int u,int v)\n{\n    e[mem].v=v;\n    e[mem].next=h[u];\n    h[u]=mem++;\n}\nint sg[maxn];\nvoid dfs(int u,int fa)\n{\n    sg[u]=0;\n    for(int i=h[u];i+1;i=e[i].next)\n    {\n        int v=e[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n        sg[u]^=(sg[v]+1);\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\",&n);\n    memset(h,-1,sizeof(h));mem=0;\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);add(y,x);\n    }\n    dfs(1,1);\n    int ans=0;\n    for(int i=h[1];i+1;i=e[i].next)\n    {\n        int v=e[i].v;\n        ans^=sg[v];\n    }\n    printf(\"%s\\n\",sg[1]!=0?\"Alice\":\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\n\nconst int N = 111111;\nvector<int> tree[N];\nint gn[N];\nint n;\n\nvoid dfs(int node, int p = 0) {\n    int nei = tree[node].size() - (node != 1);\n    for(nnode : tree[node]) {\n        if(nnode != p) {\n            dfs(nnode, node);\n            if(nei > 1) {\n                gn[node] ^= gn[nnode];\n            } else {\n                gn[node] += gn[nnode] + 1;\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    dfs(1);\n    cout << (gn[1] ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,cnt,last[N],sg[N];\nstruct edge{int to,next;}e[N*2];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nvoid addedge(int u,int v)\n{\n    e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;\n    e[++cnt].to=u;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x,int fa)\n{\n    for (int i=last[x];i;i=e[i].next)\n    {\n        if (e[i].to==fa) continue;\n        dfs(e[i].to,x);\n        sg[x]^=sg[e[i].to]+1;\n    }\n}\n\nint main()\n{\n    n=read();\n    for (int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y);\n    }\n    dfs(1,0);\n    if (sg[1]) puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long\t\t\t\tll;\ntypedef pair<int,int >\t\t\tpii;\n#define V\t\t\t\t\t\tvector\n#define SYNC\t\t\t\t\tios_base::sync_with_stdio(0);cin.tie(0);\n#define rep(i,b)\t\t\t\tfor(int i=0;i<b;i++)\n#define repn(i,n)\t\t\t\tfor(int i=1;i<=n;i++)\n#define ALL(x)\t\t\t\t\t(x).begin(),(x).end()\n#define fi\t\t\t\t\t\tfirst\n#define se\t\t\t\t\t\tsecond\n#define pb\t\t\t\t\t\tpush_back\n#define dzx\t\t\t\t\t\tcerr<<\"here\";\nconst ll MOD=1e9+7,INF=9e18;\nconst int inf=2e9;\n/* Equinox */\nV<V<int> > g;\nint findg(int c,int p){\n\tint ch=g[c].size();\n\tif(p)\n\t\tch--;\n\tif(ch==0)\n\t\treturn 0;\n\tint cur=0;\n\tfor(auto i:g[c]){\n\t\tif(i!=p)\n\t\t\tcur^=(findg(i,c)+1);\n\t}\n\treturn cur;\n}\nint main(){SYNC\n\tint n;\n\tcin>>n;\n\tg.resize(n+1);\n\trep(i,n-1){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tcout<<((findg(1,0)!=0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint n;\nvector<int> es[100000];\n\nint solve(int v, int pa) {\n\tint res = 0;\n\tREP(i, es[v].size()) if (es[v][i] != pa) res ^= solve(es[v][i], v) + 1;\n\treturn res;\n}\n\nint main(int argc, char **argv) {\n\tcin >> n;\n\tREP(i, n - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tes[x].push_back(y);\n\t\tes[y].push_back(x);\n\t}\n\tcout << (solve(0, -1) != 0 ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=500005;\nstruct node{int y,nxt;}e[N*2];\nint h[N],n,m,x,w,c=0;\nvoid add(int x,int y){\n    e[++c]=(node){y,h[x]};h[x]=c;\n    e[++c]=(node){x,h[y]};h[y]=c;\n} int dfs(int x,int fa){\n    int v=0;\n    for(int i=h[x],y;i;i=e[i].nxt)\n    if((y=e[i].y)!=fa) v^=(dfs(y,x)+1);\n    return v;\n} int main(){\n    scanf(\"%d\",&n);\n    for(int i=1,x,y;i<n;i++)\n    scanf(\"%d%d\",&x,&y),add(x,y);\n    if(n==1) return puts(\"Bob\"),0;\n    if(dfs(1,0)==0) puts(\"Bob\");\n    else puts(\"Alice\");return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            res ^= dfs(e, now);\n        }\n    }\n    return res + 1;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    else {\n        cout << (dfs(0, -1) != 1 ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(t[i]%2&&b[i]){\n      ans++;\n    r(j,v[i].size()){\n      t[v[i][j]]--;\n    }\n    }\n  }\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>          \n#include <map>           \n#include <list>\n#include <ctime>\n#include <deque>         \n#include <bitset>        \n#include <vector>\n#include <list>\n#include <stack>\n#include <random>\t\t \n#include <string>       \n#include <numeric>      //  needed for  accumulate\n#include <utility>      // needed for std:: move\n#include <iterator> \n#include <iostream>   \n#include <algorithm> \n#include <functional>    \n#include <cmath>         \n#pragma warning(disable:4996) // ignore this\n#define ve vector\n#define pb push_back\n#define mp make_pair                     \n#define srt(x) sort(x.begin(),x.end())         \n#define mod static_cast<long long> (1e9+7)     \n#define sumx(x) accumulate(x.begin(),x.end(),0LL)\n#define pi 3.14159265358979323846\nusing namespace std;\ntemplate<typename T>\nistream& operator >> (istream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin >> x;\n\treturn in;\n}\ntemplate<typename T>\nostream& operator<<(ostream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin << x << \" \";\n\treturn in;\n}\nclass solve\n{\n\tlong long n;\n\tve<bool > vis;\n\tve<ve<int> > adj;\n\tve<ve<int> > adj2;\n\tvoid dfs(int c=0)\n\t{\n\t\tvis[c]=true;\n\t\tfor(auto &x:adj[c])\n\t\t{\n\t\t\tif(!vis[x])\n\t\t\t{\n\t\t\t\tadj2[c].pb(x);\n\t\t\t\tdfs(x);\n\t\t\t}\n\t\t}\n\t}\n\tint Star(int c)\n\t{\n\t\tfor(auto &y:adj2[c])\n\t\t{\n\t\t\tif(adj2[y].size()!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tint winner(int c=0)\n\t{\n\t\tvis[c]=false;\n\t\tif(adj2[c].size()==1)\n\t\t\treturn 1;\n\t\tif(adj2[c].size()==0)\n\t\t\treturn 0;\n\t\tif(Star(c))\n\t\t{\n\t\t\treturn adj2[c].size()%2;\n\t\t}\n\t\tint ans=0;\n\t\tfor(auto &x:adj2[c])\n\t\t{\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tans^=winner(x);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\npublic:\n\tsolve()\n\t{\n\t\tcin >> n;\n\t\tvis.resize(n);\n\t\tadj.resize(n);\n\t\tadj2.resize(n);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\t--x,--y;\n\t\t\tadj[x].pb(y);\n\t\t\tadj[y].pb(x);\n\t\t}\n\t\tdfs();\n\t\tint p=winner(0);\n\t\tif(p)\n\t\t{\n\t\t\tcout << \"Alice\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"Bob\\n\";\n\t\t}\n\t}\n};\n \nint main()\n{\n\tint t = 1, i = 1;\n\t//scanf(\"%d\", &t);\n \n\twhile (t--)\n\t{\n\t\tnew solve;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define For(i,a,b) for(int i=a;i<b;i++)\nconst int M=100005;\nbool has[M];\nint n,fa[M],sg[M],res;\nvector<int>G[M];\nint Tz(int x=1,int f=-1){\n\tint res=sg[x];\n\tFor(i,0,G[x].size())if(G[x][i]!=f)\n\t\tres^=(Tz(G[x][i],x)+1);\t\t\t\n\treturn res;\n}\nint main(){\n    scanf(\"%d\",&n);\n    For(i,0,n-1){\n    \tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x-1].push_back(y-1);\n\t\tG[y-1].push_back(x-1);\n\t}\n\tFor(i,0,n)dfs(i);\n    printf(\"%s\",Tz()?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 200001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    int s = (sz(v[u]) - (u ? 1: 0)) % 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        s ^= !d[h];\n    }\n    if ((sz(v[u]) - (u ? 1: 0)) % 2 == 1) {\n        d[u] = 1;\n    }\n    d[u] |= s;\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\nint lst[100005], to[200005], pre[200005], tot;\ninline void add_edge(int u, int v)\n{\n\tto[tot] = v; \n\tpre[tot] = lst[u];\n\tlst[u] = tot++;\n}\nint dfs(int u, int fa = -1)\n{\n\tint res = 0;\n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (to[i] != fa)\n\t\t\tres ^= dfs(to[i], u) + 1;\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC017-D.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; \n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd_edge(--u, --v);\n\t\tadd_edge(v, u);\n\t}\n\tputs(dfs(0) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < ll , ll >\n#define F first\n#define S second\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\nconst int N=2e5+100;\nvector <int> g[N];\nll ans[N];\nll dfs(ll v,ll p){\n    ll cnt=0;\n    for (int i=0;i<g[v].size();i++){\n        ll u=g[v][i];\n        if (u==p){\n            continue;\n        }\n        dfs(u,v);\n        cnt^=ans[u]+1;\n    }\n    ans[v]=cnt;\n}\nint32_t main(){\n    ll n;\n    cin >> n;\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1,1);\n    if (ans[1]){\n        cout << \"Alice\" << endl;\n    }\n    else{\n        cout << \"Bob\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(x) sort((x).begin(), (x).end())\n#define ALL(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define reps(i, m, n) for (ll i = m; i < n; i++)\n#define repr(i, m, n) for (ll i = m; i >= n; i--)\n#define de(x) cout << #x << \"=\" << x << endl;\ntemplate <class T> bool maxi(T &a, const T &b) {\n    if (a < b) { a = b; return 1;} return 0;}\ntemplate <class T> bool mini(T &a, const T &b) {\n    if (b < a) { a = b; return 1;} return 0;}\n#define dame {cout<< \"-1\" <<\"\\n\"; return;}\n#define INF2 1000000000000000037\n#define INF  1000000007\n#define MOD  1000000007\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P  = pair<ll,ll>;\n//--GLOBAL---------------------------------\nstruct edge{ll to;};\nstruct graph{\n    ll N;\n    vector<vector<edge> > G;\n    vector<bool> used;\n    vector<ll> grundy;\n\n    graph(ll n): N(n), G(N), used(N,false), grundy(N) {}\n\n    void add_edge(ll s, ll t){\n        G[s].emplace_back((edge){t});\n        G[t].emplace_back((edge){s}); //無向ならON\n    }\n\n    void dfs(ll v=0){\n        used[v]=true;\n        ll ans=0;\n        for(auto& E : G[v]){\n            if(!used[E.to]){\n                dfs(E.to);\n                ans^=grundy[E.to]+1;\n            }\n        }\n        grundy[v]=ans;\n    }\n};\n//--MAIN-----------------------------------\nvoid Main(){\n    ll N; cin>>N;\n    graph g(N);\n    rep(i,N-1){\n        ll x,y; cin>>x>>y; --x; --y;\n        g.add_edge(x,y);\n    }\n    g.dfs();\n    cout<< ( g.grundy[0]!=0 ? \"Alice\" : \"Bob\" )<<\"\\n\";\n\n}\n//--START----------------------------------\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n}\n//-----------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <chrono>\n#include <ctime>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ll SIZE = 1e5 + 10, INF = 1e9, K = 300;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvector<vector<ll>> g;\n\nbool used[SIZE];\n\nll dfs(int v) {\n    used[v] = 1;\n\n    ll cur = 0;\n    for (auto to : g[v]) {\n        if (!used[to]) {\n            \n            cur ^= (dfs(to) + 1);\n        }\n    }\n\n    return cur;\n}\nint main() {\n    fastInp;\n\n    ll n;\n    cin >> n;\n\n    g.resize(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        ll u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    if (dfs(0)) {\n        cout << \"Alice\";\n    }\n    else {\n        cout << \"Bob\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n/*#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"avx2\")  //Enable AVX*/\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define vi vector<int>\n\n\nusing ll = long long;\n#define ld long double\n#define mp make_pair\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef tree<\n        pair<ll, int>,\n        null_type,\n        less<pair<ll, int>>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n/*\nint p = 1e9 + 7;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}*/\n\n\nvector<int> Z(vector<int> s)\n{\n    int n = s.size();\n    vector<int> z(n);\n    int L = 0, R = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > R) {\n            L = R = i;\n            while (R < n && s[R-L] == s[R]) R++;\n            z[i] = R-L; R--;\n        } else {\n            int k = i-L;\n            if (z[k] < R-i+1) z[i] = z[k];\n            else {\n                L = i;\n                while (R < n && s[R-L] == s[R]) R++;\n                z[i] = R-L; R--;\n            }\n        }\n    }\n    return z;\n}\n\nmt19937 rnd(time(0));\n\n//******CONVEX HULL TRICK******//\n\n/*\nstruct Line {\n    mutable ll k, m, p;\n    bool operator<(const Line& o) const { return k < o.k; }\n    bool operator<(ll x) const { return p < x; }\n};\n\nstruct CHT : multiset<Line, less<>> {\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\n    const ll inf = LLONG_MAX;\n    ll div(ll a, ll b) { // floored division\n        return a /b - ((a ^ b) < 0 && a % b); }\n    bool isect(iterator x, iterator y) {\n        if (y == end()) { x->p = inf; return false; }\n        if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;\n        else x->p = div(y->m - x->m, x->k - y->k);\n        return x->p >= y->p;\n    }\n    void add(ll k, ll m) {\n        auto z = insert({k, m, 0}), y = z++, x = y;\n        while (isect(y, z)) z = erase(z);\n        if (x != begin() && isect(--x, y)) isect(x, y = erase(y));\n        while ((y = x) != begin() && (--x)->p >= y->p)\n        isect(x, erase(y));\n    }\n    ll query(ll x) {\n        assert(!empty());\n        auto l = *lower_bound(x);\n        return l.k * x + l.m;\n    }\n};\n*/\n\n\n//******MAXFLOW******//\n\n/*\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int INF = 1000000000;\n\nstruct MaxFlow {\n  int N;\n  VVI cap, flow;\n  VI dad, Q;\n\n  MaxFlow(int N) :\n    N(N), cap(N, VI(N)), flow(N, VI(N)), dad(N), Q(N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    this->cap[from][to] += cap;\n  }\n\n  int BlockingFlow(int s, int t) {\n    fill(dad.begin(), dad.end(), -1);\n    dad[s] = -2;\n\n    int head = 0, tail = 0;\n    Q[tail++] = s;\n    while (head < tail) {\n      int x = Q[head++];\n      for (int i = 0; i < N; i++) {\n        if (dad[i] == -1 && cap[x][i] - flow[x][i] > 0) {\n          dad[i] = x;\n          Q[tail++] = i;\n        }\n      }\n    }\n\n    if (dad[t] == -1) return 0;\n\n    int totflow = 0;\n    for (int i = 0; i < N; i++) {\n      if (dad[i] == -1) continue;\n      int amt = cap[i][t] - flow[i][t];\n      for (int j = i; amt && j != s; j = dad[j])\n        amt = min(amt, cap[dad[j]][j] - flow[dad[j]][j]);\n      if (amt == 0) continue;\n      flow[i][t] += amt;\n      flow[t][i] -= amt;\n      for (int j = i; j != s; j = dad[j]) {\n        flow[dad[j]][j] += amt;\n        flow[j][dad[j]] -= amt;\n      }\n      totflow += amt;\n    }\n\n    return totflow;\n  }\n\n  int GetMaxFlow(int source, int sink) {\n    int totflow = 0;\n    while (int flow = BlockingFlow(source, sink))\n      totflow += flow;\n    return totflow;\n  }\n};*/\n\n\n//******DSU******//\n\n\n/*\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n       sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\n//******MODULAR FFT******//\n\n/*\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\n\nvoid fft (vector<int> & a, bool invert) {\n    int n = (int) a.size();\n\n    for (int i=1, j=0; i<n; ++i) {\n        int bit = n >> 1;\n        for (; j>=bit; bit>>=1)\n            j -= bit;\n        j += bit;\n        if (i < j)\n            swap (a[i], a[j]);\n    }\n\n    for (int len=2; len<=n; len<<=1) {\n        int wlen = invert ? root_1 : root;\n        for (int i=len; i<root_pw; i<<=1)\n            wlen = int (wlen * 1ll * wlen % p);\n        for (int i=0; i<n; i+=len) {\n            int w = 1;\n            for (int j=0; j<len/2; ++j) {\n                int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % p);\n                a[i+j] = u+v < p ? u+v : u+v-p;\n                a[i+j+len/2] = u-v >= 0 ? u-v : u-v+p;\n                w = int (w * 1ll * wlen % p);\n            }\n        }\n    }\n    if (invert) {\n        int nrev = po(n, p - 2);\n        for (int i=0; i<n; ++i)\n            a[i] = int (a[i] * 1ll * nrev % p);\n    }\n}\nvoid poly_mult(vector < int >& a, vector < int > b) {\n    int s = a.size() + b.size();\n    int r = 1;\n    while (r < s) r *= 2;\n    a.resize(r);\n    b.resize(r);\n    fft(a, false);\n    fft(b, false);\n    for (int j = 0; j < r; j++) {\n        a[j] = mul(a[j], b[j]);\n    }\n    fft(a, true);\n    while (!a.empty() && (a.back() == 0)) a.pop_back();\n}\n\n*/\n\nvector<vector<int>> G;\n\nint dfs(int x, int p = -1)\n{\n    int res = 0;\n    for (auto it: G[x]) if (it!=p) res^=(dfs(it, x) + 1);\n    return res;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n;\n    cin>>n;\n    G.resize(n+1);\n    int x, y;\n    for (int i = 0; i<n-1; i++)\n    {\n        cin>>x>>y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    if (dfs(1)) cout<<\"Alice\";\n    else cout<<\"Bob\";\n\n}\n\n/*\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n\n\n\n}*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(ll i= (ll) k;i< (ll) n;i++)\n#define all(v) (v).begin(), (v).end()\n#define SZ(v) (int)((v).size())\n#define pb push_back\n#define ft first\n#define sd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst long long INF = 4e18L + 1;\nconst int IINF = 2e9 + 1;\n\nusing namespace std;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define DBG(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) ;\n#define cerr if(0)cout\n#endif\n\nconst int N = 100000;\nint n;\nvector<int> nei[N + 1];\nbool visited[N + 1];\n\nll dfs(int v){\n    visited[v] = true;\n    ll res = 0;\n    for(auto& w : nei[v]){\n        if(!visited[w]){\n            res ^= dfs(w);\n        }\n    }\n    return res + (v != 1);\n}\n\nint main()\n{\n#ifndef LOCAL\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n    cin >> n;\n    rep(_, 0, n - 1){\n        int t1, t2; cin >> t1 >> t2;\n        nei[t1].pb(t2); nei[t2].pb(t1);\n    }\n    if(dfs(1)){\n        cout << \"Alice\\n\";\n    } else {\n        cout << \"Bob\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n;\nvi g[N];\nbool tag[N],vis[N];\n\null dfs(int x){\n\tvis[x]=1;\n\tvector<ull> Hash;Hash.clear();\n\tull h=1,du=1;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tHash.pb(dfs(y));\n\t}\n\tif(!Hash.size()){\n\t\th+=1284743ull*du*du*du;\n\th^=91348377ull*du;\n\t\treturn h;\n\t}\n\tsort(Hash.begin(),Hash.end());\n\tfor(int i=0;i<Hash.size()-1;i++)\n\t\tif(Hash[i]==Hash[i+1]) tag[i]=tag[i+1]=1,i++;\n\tfor(int i=0;i<Hash.size();i++)\n\t\tif(!tag[i]) h=h*Hash[i],du++;\n\tfor(int i=0;i<Hash.size();i++) tag[i]=0;\n\th+=1284743ull*du*du*du;\n\th^=91348377ull*du;\n\treturn h;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tvector<ull> Hash;Hash.clear();\n\tvis[1]=1;\n\tfor(int i:g[1])\n\t\tHash.pb(dfs(i));\n//\tdebuge;\n\tsort(Hash.begin(),Hash.end());\n\tif(Hash.size()&1){puts(\"Alice\");return 0;}\n\tfor(int i=0;i<Hash.size();i+=2)\n\t\tif(Hash[i]!=Hash[i+1]){puts(\"Alice\");return 0;}\n\tputs(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 100000;\nvector<int> adj[N];\n\nint dfs(int u, int p = -1) {\n\tint ret = 0;\n\tfor (auto &x : adj[u]) {\n\t\tif (x == p)continue;\n\t\tint g = dfs(x, u);\n\t\tret ^= g + 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; ni(n);\n\tF(i, n - 1) {\n\t\tint u, v; nii(u, v);\n\t\tu--; v--;\n\t\tadj[u].push_back(v);\n\t}\n\tint x = dfs(0);\n\tif (x)puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn (rand()<<16|rand())%x;\n}\nconst int N=100005;\nint n;\nvector<int> v[N];\nint dfs(int p,int fa){\n\t//if(fa)cout<<p<<\" \"<<*lower_bound(v[p].begin(),v[p].end(),fa)<<\" \"<<fa<<endl;\n\tint sum=0;\n\tfor(unsigned i=0;i<v[p].size();i++)if(v[p][i]!=fa){\n\t\tsum^=dfs(v[p][i],p)+1;\n\t}\n\t//cout<<p<<\" \"<<sum<<endl;\n\treturn sum;\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint s=read(),t=read();\n\t\tv[s].push_back(t); v[t].push_back(s);\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nvector<vector<int> > adj;\nint solve(int i, int p) {\n    int g = 0;\n    for (int j : adj[i]) if (j != p) g ^= 1 + solve(j, i);\n    return g;\n}\n\nint main() {\n    int n; cin >> n;\n    adj.resize(n);\n    for (int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        adj[u-1].push_back(v-1);\n        adj[v-1].push_back(u-1);\n    }\n    cout << (solve(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nint n, head[N], tot;\nstruct edge { int to, nxt; } e[N << 1];\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x] }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y] }, head[y] = tot;\n}\n\nint dfs(int x, int f = 0) {\n\tint ret = 0;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (e[i].to != f) ret ^= dfs(e[i].to, x) + 1;\n\treturn ret;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, x, y; i < n; ++i)\t\n\t\tstd::cin >> x >> y, link(x, y);\n\tstd::cout << (dfs(1) ? \"Alice\" : \"Bob\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define li long long\n#define ld long double\n#define x first\n#define y second\n#define pt pair<int, int>\n#define pll pair<li, li>\n#define forn(i, t) for(int i = 0; i < (t); i++)\n#define fore(i, f, t) for(int i = (f); i < (t); i++)\n#define forr(i, f, t) for(int i = (f) - 1; i >= (t); i--)\n#define all(x) (x).begin(), (x).end()\n#define ins insert\n\nusing namespace std;\n\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst li INF64 = 1e18;\nconst ld EPS = 1e-7;\n\nmt19937 myrand(time(NULL));\n\nconst int N = 100 * 1000 + 13;\n\nint n;\nvector<int> g[N];\n\n\nbool read(){\n\tif(scanf(\"%d\", &n) != 1)\n\t\treturn 0;\n\tforn(i, n)\n\t\tg[i].clear();\n\tforn(i, n - 1){\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\t--f, --t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\treturn 1;\n}\n\nset<pair<int, pt> > edges;\nchar used[N];\nint deg;\n\n\nvoid dfs(int v, int d = 0){\n\tused[v] = 1;\n\t\n\tfor (auto u : g[v])\n\t\tif (!used[u]){\n\t\t\tedges.insert({d, {v, u}});\n\t\t\tdfs(u, d + 1);\n\t\t}\n}\n\n\nvoid del(int v, int p, int d){\n\tif (p == 0)\n\t\t--deg;\n\t\n\tedges.erase({d, {p, v}});\n\t\n\tfor (auto u : g[v])\n\t\tif (u != p){\n\t\t\tdel(u, v, d + 1);\n\t\t}\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tedges = set<pair<int, pt> >();\n\tdfs(0);\n\t\n\tdeg = sz(g[0]);\n\tint st = 1;\n\t\n\twhile (!edges.empty() && deg > 0){\n\t\tif (deg % 2 == 0){\n\t\t\tauto cur = *edges.rbegin();\n\t\t\tdel(cur.y.y, cur.y.x, cur.x);\n\t\t}\n\t\telse{\n\t\t\tauto cur = *edges.begin();\n\t\t\tdel(cur.y.y, cur.y.x, cur.x);\n\t\t}\n\t\t\n\t\tst ^= 1;\n\t}\n\t\n\tprintf(st ? \"Bob\\n\" : \"Alice\\n\");\n}\n\n\nint main(){\n\t#ifdef _DEBUG\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\twhile(read())\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nll sm;\nint dp[N];\nll dp1[N];\nvector <int> g[N];\n\nint dfs(int v, int p) {\n  int cnt = 0;\n  for (auto to : g[v])\n    if (to != p) cnt++;\n  if (cnt == 1) return 1;\n  int res = 0;\n  for (auto to : g[v])\n    if (to != p) res ^= dfs(to, v);\n  return res;\n}\nvoid solve() {\n  //freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (sz(g[1]) == 1) cout << \"Alice\", ioi\n  if (dfs(1, 1)) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(a) for(int k=head[a];k;k=e[k].ne)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=1e6+5,M=5e3+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nint n;\nvector<int>e[N];\nint dfs(int x,int f){\n\tint res=0;\n\tre(i,0,e[x].size())if(e[x][i]!=f)res^=dfs(e[x][i],x)+1;\n\treturn res;\n}\nint main(){\n\tread(n);re(i,1,n){\n\t\tint x,y;read(x,y);\n\t\te[x].pb(y);e[y].pb(x);\n\t}\n\tcout<<(dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace {\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define len(x) (int)((x).size())\n#define X first\n#define Y second\n\n#define FOR(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\n// Types\nusing ll = long long int;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vll = vector<ll>;\ntemplate<typename T> using minpq = priority_queue<T, vector<T>, greater<T>>;\n\n#ifndef ONLINE_JUDGE\n#define DEBUG(args...) cerr << \"[Line \" << __LINE__ << \"]: \";  { vector<string> _v = __split(#args, ','); __ferr(_v.begin(), args); }\n#define DEBUG_2D(A) cerr << \"[Line \" << __LINE__ << \"]: \" << #A << \" = \\n\";  for (const auto& R : (A)) { cerr << '\\t' << R << '\\n'; }\nvector<string> __split(const string& s, char c) { vector<string> v; stringstream ss(s); string x; while (getline(ss, x, c)) v.emplace_back(x);  return v; }\nvoid __err(vector<string>::iterator it) { cerr << endl; }\ntemplate<typename T, typename... Args> void __err(vector<string>::iterator it, T a, Args... args) { cerr << \", \" << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a; __err(++it, args...); }\ntemplate<typename T, typename... Args> void __ferr(vector<string>::iterator it, T a, Args... args) { cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a; __err(++it, args...); }\n#else\n#define DEBUG(...) \n#define DEBUG_2D(...)\n#endif  // ONLINE_JUDGE\n\n// Printing containers\ntemplate<typename U, typename V> ostream& operator<<(ostream &s, const pair<U, V> &x) { s << \"(\" << x.first << \", \" << x.second << \")\"; return s; }\ntemplate<typename U> ostream& operator<<(ostream &s, const vector<U> &x) { s << \"[\"; bool was = false; for (auto it : x) { if (was) s << \", \"; was = true; s << it; } s << \"]\";  return s; }\ntemplate<typename U> ostream& operator<<(ostream &s, const deque<U> &x) { s << \"[\"; bool was = false; for (auto it : x) { if (was) s << \", \"; was = true; s << it; } s << \"]\"; return s; }\ntemplate<typename U, typename V> ostream& operator<<(ostream &s, const map<U, V> &x) { s << \"{\"; bool was = false; for (auto it : x) { if (was) s << \", \"; was = true; s << it; }  s << \"}\"; return s; }\ntemplate<typename U> ostream& operator<<(ostream &s, const set<U> &x) { s << \"{\"; bool was = false; for (auto it : x) { if (was) s << \", \"; was = true; s << it; } s << \"}\"; return s; }\ntemplate<typename U> ostream& operator<<(ostream &s, const multiset<U> &x) { s << \"{\"; bool was = false; for (auto it : x) { if (was) s << \", \"; was = true; s << it; } s << \"}\"; return s; }\n\n// Useful functions\nll expmod(ll a,ll b,ll mod) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\ntemplate<typename T> T sqr(const T& x) { return x*x; }\nll flog(const ll x) { return 63 - __builtin_clzll(x); }\ntemplate<typename T> void sort(T& t) { sort(all(t)); }\ntemplate<typename T> void undupe(vector<T>& v) { sort(v); v.erase(unique(all(v)), v.end()); }\ntemplate<typename T> string binary(T x, int w=8*sizeof(T)) { string r; for (int i=0;i<w;i++) r=(((T(1)<<i)&x)?'1':'0')+r; return r; }\n}\n\nconst ll MOD = 1000000009LL;\nconst ll INF = (ll)1e15;\nconst double EPS = 1e-8;\n\nint N;\nvvi adj;\n\nll grundy(int v, int p) {\n    if (adj[v].size() == 1)\n        return 1;\n    else {\n        int ans = 0;\n        for (int u : adj[v]) if (u != p) {\n            ans ^= grundy(u, v);\n        }\n        return ans + (p != -1);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc >= 1) freopen(argv[1], \"r\", stdin);\n    ios::sync_with_stdio(0); cin.tie(0);\n    \n    cin >> N;\n    adj.resize(N);\n    FOR(i,0,N-1) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    int g = grundy(0, -1);\n    if (g == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100100;\n\nint n;\nvector<int> g[N];\n\nint dfs(int u, int p) {\n   int ans = 0;\n   for (int v : g[u]) {\n      if (v != p) {\n         ans ^= (dfs(v, u) + 1);\n      }\n   }\n   return ans;\n}\n\nint main() {\n   scanf(\"%d\", &n);\n   for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      g[u].push_back(v);\n      g[v].push_back(u);\n   }\n   puts(dfs(1, -1) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n        int t,n;\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MAX = 2 * 1000 * 100 + 47;\nconst int MIN = 404;\nconst int MOD = INF;\n\n\nVI G[MAX];\n\n\nint dfs(int v, int p = -1)\n{\n    int g = 0;\n    FOR(i, 0, SZ(G[v]))\n    {\n        int to = G[v][i];\n        if (to == p)continue;\n        int gt = dfs(to, v);\n        g ^= gt + 1;\n    }\n    return g;\n}\n\nint main()\n{\n    // freopen(\"in.txt\", \"r\", stdin);\n    int n, m;\n    scanf(\"%d\", &n);\n    FOR(i, 0, n-1)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        --x, --y;\n        G[x].PB(y);\n        G[y].PB(x);\n    }\n    if (!dfs(0))printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int MAXN=100005;\n\nint n;\nint sg[MAXN];\nvector<int> E[MAXN];\n\nvoid dfs(int u,int fa=0){\n    sg[u]=0;\n    for(int i=0;i<(int)E[u].size();i++){\n        int v=E[u][i];\n        if(v==fa) continue;\n        dfs(v,u);\n        sg[u]^=(sg[v]+1);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        E[u].push_back(v);\n        E[v].push_back(u);\n    }\n    dfs(1);\n    if(sg[1]) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > Graph;\n\nGraph g;\n\nint dfs(int cur, int par) {\n\tint res = 0, cnt = 0;\n\tfor (int nex : g[cur]) {\n\t\tif (nex == par) continue;\n\t\tres ^= dfs(nex, cur) + 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tcout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n#include<stack>\n#include<set>\nusing namespace std ;\nusing ll = long long ;\nusing vll = vector<ll> ;\nusing vvll = vector<vll> ;\nusing pll = pair<ll,ll> ;\nll INF = 1e15 ;\nvoid chmin(ll &a,ll b){if(a>b) a = b ;}\nvoid chmax(ll &a,ll b){if(a<b) a = b ;}\nvoid YorN(bool a){cout << (a?\"YES\":\"NO\") << \"\\n\" ;}\n\nll DFS(vvll &g,int cur,int pre){\n\tll res = 0 ;\n\tfor(int i=0;i<g[cur].size();i++){\n\t\tif(pre==g[cur][i]) continue ;\n\t\tres ^= DFS(g,g[cur][i],cur)+1 ;\n\t}\n\treturn res ;\n}\n\nint main(){\n\tll n ; cin >> n ;\n\tvvll g(n) ;\n\tfor(int i=1;i<n;i++){\n\t\tll a,b ;\n\t\tcin >> a >> b ;\n\t\ta-- ; b-- ;\n\t\tg[a].push_back(b) ;\n\t\tg[b].push_back(a) ;\n\t}\n\tcout << (DFS(g,0,-1)?\"Alice\":\"Bob\") << endl ;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v) {\n  int sz = v.size();\n  for (int i = 0; i < sz; i++) {\n    cout << v[i] << \" \\n\"[i == sz - 1];\n  }\n}\n\nusing Graph = vector<vector<int>>;\nconst int MAX_N = 100010;\nGraph g(MAX_N);\n\nbool dfs(int cur, int pre) {\n  if ((int)g[cur].size() == 1) {\n    if (cur == 0) return true;\n    return false;\n  }\n  int ch = g[cur].size();\n  if (cur != 0) ch--;\n  if (ch % 2) {\n    return true;\n  }\n  int ok = 0;\n  for (auto nxt : g[cur]) {\n    if (nxt == pre) continue;\n    if (dfs(nxt, cur)) ok++;\n  }\n  if (ok % 2) return true;\n  return false;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> edge[1000010];\nint n,poi[1000010],u,v;\n\nvoid dfs(int u,int fa)\n{\n    poi[u]=0;\n    for(auto v : edge[u])\n    {\n        if(v==fa) continue;\n        dfs(v,u);\n        sg[u]^=sg[v]+1;\n    }\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n-1;++i)\n    {\n        scanf(\"%d%d\",&u,&v);\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    dfs(1,0);\n    puts(poi[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define IOS ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define ll long long int\n#define f(i,a,b) for(ll i=a;i<b;i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define en '\\n'\nvector<int> adj[100005];\nbool vis[100005];\nint c[100005];\nint dfs(int s)\n{\n    vis[s]=1;\n    int ch=0;\n    f(i,0,adj[s].size())\n    {\n        int o=0;\n        if(vis[adj[s][i]]==0)\n        {\n            o=dfs(adj[s][i])+1;\n        }\n        ch=ch^o;\n    }\n    return ch;\n}\nint main()\n{\n\tIOS;\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t{\n        int n,x,y;\n        cin>>n;\n        f(i,0,n-1)\n        {\n            cin>>x>>y;\n            adj[x].pb(y);\n            adj[y].pb(x);\n        }\n        x=dfs(1);\n        if(x)\n            cout<<\"Alice\";\n        else\n            cout<<\"Bob\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define all(a) a.begin(), a.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nusing namespace std;\ntypedef long long ll;\n\nvector<int> tree[100000];\nint dfs(int v, int p){\n    int cnt0 = 0, cnt1 = 0;\n    for(int u : tree[v])if(u != p){\n        int t = dfs(u, v);\n        if(t == 0)cnt0++;\n        else cnt1++;\n    }\n    return int(bool((cnt0 & 1) or (cnt1 & 1)));\n}\n\nint main(){\n\n    int N;\n    cin >> N;\n\n    rep(i, N - 1){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n\n    cout << (dfs(0, -1) ? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mkp make_pair\n#define pii pair<int, int> \n#define pll pair<long long int, long long int>\n#define sci(x) scanf(\"%d\", &x)\n#define scl(x) scanf(\"%lld\", &x)\n#define fi first\n#define sc second\n#define deb 0\n\nvector <int> v[100001];\n\nint dfs(int x, int p)\n{\n\tint ans = 0;\n\tfor (int y: v[x]) {\n\t\tif (y == p) continue;\n\t\tans ^= dfs(y, x);\n\t}\n\treturn ans+1;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cout.tie(0);cin.tie(0);\n\n\tint n, i, j, k, x, y;\n\tcin >> n;\n\tfor (i = 1; i < n; ++i) {\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\n\tputs(dfs(1, 0) == 1 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 100010;\n\nstd::vector <int> e[N];\nint dep[N], cnt[N];\nint n;\n\nvoid dfs(int u, int fa){\n\t++ cnt[dep[u]];\n\tfor (auto v : e[u]){\n\t\tif (v == fa){\n\t\t\tcontinue;\n\t\t}\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs(v, u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0, u, v; i < n - 1; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tfor (int i = 1; i < N; ++ i){\n\t\tif (cnt[i] & 1){\n\t\t\treturn printf(\"Alice\\n\"), 0;\n\t\t}\n\t}\n\treturn printf(\"Bob\\n\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint N;\nint x[100005], y[100005];\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n\n  int root = 0;\n  int edge = N - 1;\n\n  rep(i, N - 1) {\n      cin >> x[i] >> y[i];\n      x[i]--; y[i]--;\n      if (x[i] == 0 || y[i] == 0) root += 1;\n  }\n\n  int hand = 0;\n  while (true) {\n    if (root - 1 == 0) {\n      root -= 1;\n      edge -= 1;\n    } else {\n      if (edge == root) {\n          root -= 1;\n      }\n      edge -= 1;\n    }\n    if (root == 0) {\n      cout << (hand == 1 ? \"Bob\":\"Alice\") << endl;\n      break;\n    }\n\n    hand = (hand + 1)%2;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nusing Graph = vector< vector<int> >;\n\nint dfs(Graph &G, int cur, int par=-1) {\n    int grundy = 0, children = 0;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        children++;\n        grundy ^= dfs(G, to, cur) + 1;\n    }\n    // printf(\"cur = %d, grundy = %d\\n\", cur + 1, grundy);\n    return grundy;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    Graph G(N);\n    for(int i=0; i<N-1; i++) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    printf(\"%s\\n\", dfs(G, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nvector< int > g[N];\nint dfs(int v, int par = -1) {\n  int ret = 0;\n  for (int u : g[v]) if (u != par)\n    ret ^= (1 + dfs(u, v));\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int ans = dfs(0);\n  puts(ans ? \"Alice\" : \"Bob\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing anemspace std;\n\nint main()\n{\nchar c;\nwhile(scanf(\"%c\",&c)!=EOF);\nprintf(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nvector< int > g[N];\nint lv[N], ch[N];\nvoid dfs(int v, int par = -1) {\n  lv[v] = par == -1 ? 0 : lv[par] + 1;\n  ch[v] = 0;\n  for (int u : g[v]) if (u != par)\n    dfs(u, v), ch[v]++;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (g[0].size() == 1) {\n    puts(\"Alice\");\n    return 0;\n  }\n  dfs(0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (ch[i] != 1)\n      ans ^= lv[i];\n  }\n  puts(ans ? \"Alice\" : \"Bob\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n//#include <unordered_map>\n//#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\t--x[i]; --y[i];\n\t\tg[x[i]].emplace_back(y[i]);\n\t\tg[y[i]].emplace_back(x[i]);\n\t}\n\tg[0].emplace_back(-1);\n\n\tstd::function<bool(int, int)> dfs = [&](int v, int par) {\n\t\tif (g[v].size() == 1) return false;\n\t\tif (g[v].size() == 2) return true;\n\t\tbool res = 0;\n\t\tfor (auto& to : g[v]) {\n\t\t\tif (to == par) continue;\n\t\t\tres ^= !dfs(to, v);\n\t\t}\n\t\treturn res;\n\t};\n\tbool t = dfs(0, -1);\n\tOUT(((t) ? \"Alice\" : \"Bob\"))BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\n\nint solve(int now, int par);\n\nint main() {\n  cin >> n;\n  g.resize(n);\n  for (int i = 1; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    g[--a].push_back(--b);\n    g[b].push_back(a);\n  }\n  if (solve(0, -1))\n    cout << \"Alice\" << endl;\n  else\n    cout << \"Bob\" << endl;\n  return 0;\n}\n\nint solve(int now, int par) {\n  int res = 0;\n  for (auto to : g[now])\n    if (to != par) res ^= solve(to, now) + 1;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define M 1000005\nusing namespace std;\nint nxt[M],head[M],to[M],tot,n;\nint read(){\n\tchar c=getchar();int ans=0; \n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans; \n}\nvoid add(int u,int v){nxt[++tot]=head[u];head[u]=tot;to[tot]=v;return;}\nint DFS(int x,int fa){\n\tint ans=0;\n\tfor (register int i=head[x];i;i=nxt[i])\n\t\tif (to[i]!=fa) ans^=(DFS(to[i],x)+1);\n\treturn ans;\n}\nint main(){\n\tn=read();\n\tfor (register int i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v),add(v,u);\n\tprintf(\"%s\",DFS(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long double ldo;\n\n#define pb push_back\nconst int MAX = 1e5 + 20;\nlong long n, x, res;\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tres = 0;\n\tfor (auto i : g[v])\n\t\tif (i != r)\n\t\t\tres ^= dfs (i, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tx = dfs (0,0);\n\n\tcout << (!x ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nstatic const int MAXN = 100005;\n\nint n;\nstd::vector<int> e[MAXN];\n\nint f[MAXN];\n\nvoid dfs(int u, int p = -1)\n{\n    f[u] = 0;\n    for (int v : e[u]) if (v != p) {\n        dfs(v, u);\n        f[u] ^= (f[v] + 1);\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0, u, v; i < n - 1; ++i) {\n        scanf(\"%d%d\", &u, &v); --u, --v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs(0);\n    puts(f[0] == 0 ? \"Bob\" : \"Alice\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define M 100005\n\nint n;\nvector<int>v[M];\nint Sg[M];\n\nvoid DFS(int x,int p){\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint to=v[x][i];\n\t\tif(to==p)continue;\n\t\tDFS(to,x);\n\t\tSg[x]^=(Sg[to]+1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tDFS(1,0);\n\tint ans=Sg[1];\n\tif(ans==0)puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t100005\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <int> a[MAXN];\nint ans[MAXN];\nvoid work(int pos, int fa) {\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (a[pos][i] == fa) continue;\n\t\telse {\n\t\t\twork(a[pos][i], pos);\n\t\t\tans[pos] ^= ans[a[pos][i]] + 1;\n\t\t}\n}\nint main() {\n\tint n; read(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\twork(1, 0);\n\tif (ans[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\nvector<int> lis[100100];\n\nint dfs(int here, int p) {\n\tint res = 0;\n\tfor (auto &there : lis[here]) {\n\t\tif (there==p) continue;\n\t\tres ^= dfs(there,here);\n\t}\n\treturn res+(p!=-1);\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i=0;i<n-1;i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\",&a,&b);--a;--b;\n\t\tlis[a].push_back(b);\n\t\tlis[b].push_back(a);\n\t}\n\tif (dfs(0,-1)) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint sg[110000],x,y,n;\nvector<int> ve[110000]; \nvoid dfs(int x, int f) {\n\tsg[x] = 0;\n\tfor (int i = 0; i < ve[x].size(); i++) {\n\t\tif (ve[x][i] == f) continue;\n\t\tdfs(ve[x][i], x);\n\t\tsg[x] = sg[x] ^ (sg[ve[x][i]] + 1);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tve[x].push_back(y);\n\t\tve[y].push_back(x); \n\t}\n\tdfs(1,0);\n\tif (sg[1] == 0) cout<<\"Bob\"<<endl; else cout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define REP(i, N) for (int i = 0; i < (N); ++i)\n\nint N;\nvector<int> graph[100100];\n\nint grundy(int cur, int prv = -1) {\n    int ret = 0;\n    for (auto& nxt: graph[cur]) {\n        if (nxt == prv) continue;\n        ret ^= grundy(nxt, cur) + 1;\n    }\n    return ret;\n}\n\nsigned main() {\n    cin >> N;\n    REP(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        --a, --b;\n        graph[a].emplace_back(b);\n        graph[b].emplace_back(a);\n    }\n    if (grundy(0)) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define FOR(i,c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define F first\n#define S second\nusing namespace std;\n\nconst LL mod = 1e9 + 7;\n\ntemplate<typename T> T gcd(T a, T b) { return b == 0?a: gcd(b, a % b); }\ntemplate<typename T> T LCM(T a, T b) { return a*(b/gcd(a, b)); }\ntemplate<typename T> T expo(T base, T e, T mod) { T res = 1;\n  while(e > 0) { if(e&1) res = res * base % mod; base = base * base % mod; e >>= 1; }\n  return res;\n}\ntemplate<typename T, typename S> T expo(T b, S e){if(e <= 1)return e == 0?1: b;\\\n\treturn (e&1) == 0?expo((b*b), e>>1): (b*expo((b*b), e>>1));}\ntemplate<typename T, typename S> T modinv(T a, S mod) { return expo(a, mod-2, mod); }\ntemplate<class T, class S> std::ostream& operator<<(std::ostream &os, const std::pair<T, S> &t) {\n\tos<<\"(\"<<t.first<<\", \"<<t.second<<\")\";\n\treturn os;\n}\ntemplate<class T> std::ostream& operator<<(std::ostream &os, const std::vector<T> &t) {\n\tos<<\"[\"; FOR(it,t) { if(it != t.begin()) os<<\", \"; os<<*it; } os<<\"]\";\n\treturn os;\n}\n\nconst int MAXN = 1e5 + 100;\n\nint n;\nvector<int> adj[MAXN];\nLL g[MAXN];\n\nvoid go(int r, int p) {\n\tg[r] = 0;\n\tint cnt = 0;\n\tfor(auto &elem: adj[r]) {\n\t\tif(elem != p) {\n\t\t\tgo(elem, r);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt == 0) {\n\t\tg[r] = 0;\n\t} else if(cnt == 1) {\n\t\tfor(auto &elem: adj[r]) {\n\t\t\tif(elem != p) {\n\t\t\t\tg[r] = g[elem] + 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(auto &elem: adj[r]) {\n\t\t\tif(elem != p) {\n\t\t\t\tg[r] = g[r] ^ (g[elem] + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\tint a, b;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(b); adj[b].push_back(a);\n\t}\n\tgo(1, 0);\n\tif(g[1] > 0) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define MAXN 100000\n#define ll long long\nusing namespace std;\n\n\nvector<int> edges[MAXN+20];\nint GetGrundy(int par, int u) {\n    \n    int g = 0;\n    for(int j=0;j<edges[u].size();j++) {\n        int v=edges[u][j];\n        if (v != par)\n            g ^= (GetGrundy(u,v)+1);\n    }\n    \n    return g;\n}\n\nint main() {\n    int N;\n    cin>>N;\n    for(int i=1;i<=N-1;i++) {\n        int u,v;\n        cin>>u>>v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    \n    int g=GetGrundy(-1,1);\n    \n    if (g==0)\n        cout << \"Bob\" << endl;\n    else\n        cout << \"Alice\" << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nvector<int> V[N];\nint n, dp[N];\nset<int> ST;\n\nvoid dfs(int x, int fa){\n    dp[x] = 0;\n    for(int i=0; i<V[x].size(); i++){\n        int j = V[x][i];\n        if(j == fa) continue;\n        dfs(j, x);\n        dp[x] ^= (dp[j] + 1);\n    }\n}\n\nint main(){\n    int x, y;\n    while(~scanf(\"%d\", &n)){\n        for(int i=1; i<=n; i++) V[i].clear();\n        for(int i=1; i<n; i++){\n            scanf(\"%d %d\", &x, &y);\n            V[x].push_back(y);\n            V[y].push_back(x);\n        }\n        dfs(1, -1);\n        puts(dp[1] ? \"Alice\" : \"Bob\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdio.h>\n#define ff(i,x,y)for(int i=x;i<y+1;i++)\n#define fs(i,x,y)for(int i=x;i>y-1;i--)\n#define all(x) x.begin(),x.end()\n#define Ins(x) inserter(x,x.begin())\nusing namespace std;\nvector<int>hu[100005];\nint work(int u,int pre)\n{\n    int ret=0;\n    for(int i=0;i<hu[u].size();i++)\n    {\n        if(hu[u][i]!=pre)\n            ret^=(1+work(hu[u][i],u));\n    }\n    return ret;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        hu[i].clear();\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        hu[x].push_back(y);\n        hu[y].push_back(x);\n    }\n    if(work(1,-1))\n        puts(\"Alice\");\n    else\n        puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define pb push_back\n\nusing namespace std;\n\nconst int N=100005;\n\nint n,sg[N];\nvector<int>e[N];\n\nvoid dfs(int x,int fa){\n\tfor(auto v:e[x])if(v!=fa)dfs(v,x),sg[x]^=sg[v]+1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v),e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");else puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int>v[100005];\n\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int t,n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        v[i].clear();\n    for(int i=1;i<n;i++){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(get_sg(1,-1))\n        puts(\"Alice\");\n    else\n        puts(\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int nax = 1e5;\n\nint n, val[nax + 1];\nvector< int > gr[nax + 1];\n\nvoid dfs(const int v, const int oj)\n{\n    for (int s : gr[v])\n        if (s != oj)\n            dfs(s, v);\n\n    for (int s : gr[v])\n\tif (s != oj)\n\t    val[v] xor_eq (val[s] + 1);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n;\n\n    for (int i = 0; i < n - 1; ++i)\n    {\n        int p, q; cin >> p >> q;\n        gr[p].push_back(q);\n        gr[q].push_back(p);\n    }\n\n    dfs(1, 1);\n\n    cout << (val[1]? \"Alice\" : \"Bob\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\n\nconst int N = 111111;\nvector<int> tree[N];\nint n;\n\nint dfs(int node, int p = 0) {\n    int ans = 0;\n    for(nnode : tree[node]) {\n        if(nnode != p) {\n            ans ^= dfs(nnode, node);\n        }\n    }\n    return ans + 1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    cout << (dfs(1) - 1 ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[100005];\n\nint getgrundy(int t, int p)\n{\n    int ret = 0;\n    for (int nxt : graph[t])\n    {\n        if (nxt == p) continue;\n        ret ^= getgrundy(nxt, t) + 1;\n    }\n    return ret;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 1; i < n; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\",&a,&b);\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    if (getgrundy(1, -1)) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nvector<int> E[N];\nint n;\nint dfs(int u,int fa) {\n    int ret=0;\n    for(int v:E[u])\n        if(v!=fa) ret^=(dfs(v,u)+1);\n    return ret;\n}\nint main() {\n    cin>>n;\n    for(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].push_back(v),E[v].push_back(u);\n    dfs(1,0)?puts(\"Alice\"):puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\nint main() {\n\tint n;\n\tstd::cin >> n;\n\n\tstd::vector<std::vector<int>> g(n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tstd::cin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tstd::vector<int> dp(n);\n\n\tstd::function<void(int, int)> dfs = [&](int u, int p) {\n\t\tfor (int v : g[u]) {\n\t\t\tif (v != p) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tdp[u] ^= dp[v] + 1;\n\t\t\t}\n\t\t}\n\t};\n\n\tdfs(0, -1);\n\n\tputs(dp[0] != 0 ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "/***********Template Starts Here***********/\n//copied from https://www.hackerrank.com/contests/5-days-of-game-theory/challenges/deforestation/editorial\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define FOR(i,x,y) for(vlong i = (x) ; i <= (y) ; ++i)\n#define ROF(i,x,y) for(vlong i = (y) ; i >= (x) ; --i)\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define UNIQUE(V) (V).erase(unique((V).begin(),(V).end()),(V).end())\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define SZ(x) ((vlong)(x).size())\n\nusing namespace std;\n\ntypedef long long vlong;\n\nconst vlong inf = 2147383647;\n\n/***********Template Ends Here***********/\n#define NODE 100005\nvector<int> adj[NODE+10];\n\nint hackenbush ( int s, int p ) {\n\n    int res = 0;\n    FOR(i,0,SZ(adj[s])-1) {\n        int t = adj[s][i];\n\n        if ( t == p ) continue;\n\n        res ^= hackenbush ( t, s ) + 1;\n    };\n\n    return res;\n}\n\nvoid solution() {\n    int kase;\n    //scanf ( \"%d\", &kase );\n\n    //assert ( kase >= 1 && kase <= 100 );\n    kase = 1;\n    while ( kase-- ) {\n        int n;\n        scanf ( \"%d\", &n );\n\n      //  assert ( n >= 1 && n <= 500 );\n\n        FOR(i,1,n) adj[i].clear();\n\n        FOR(i,1,n-1) {\n            int u, v;\n            scanf ( \"%d %d\", &u, &v );\n            adj[u].pb ( v );\n            adj[v].pb ( u );\t\t\t\n        };\n\n        int res = hackenbush ( 1, 0 );\n\n        if ( res ) printf ( \"Alice\\n\" );\n        else printf ( \"Bob\\n\" );\n    }\n}\n\nint main () {\n\n    solution();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static vi g[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        fi>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    static int S[1 << 20];\n    function < void(int,int) > dfs = [&](int node,int prev)\n    {\n        for (auto it : g[node])\n            if (it != prev)\n                dfs(it,node),S[node] ^= 1 + S[it];\n    };\n    dfs(1,0);\n    puts(S[1] ? \"Alice\":\"Bob\");\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nvector<int> G[100010];\n\nint dfs(int v, int p = -1) {\n\tint res = 0;\n\trep(i, 0, G[v].size()) {\n\t\tint n = G[v][i];\n\t\tif(n == p) continue;\n\t\tres ^= (dfs(n, v) + 1);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tif(dfs(0)) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tQ.push(1);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t\tif (edge[i].size() > 2)dis[i]--;\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define li long long\n#define ld long double\n#define x first\n#define y second\n#define pt pair<int, int>\n#define pll pair<li, li>\n#define forn(i, t) for(int i = 0; i < (t); i++)\n#define fore(i, f, t) for(int i = (f); i < (t); i++)\n#define forr(i, f, t) for(int i = (f) - 1; i >= (t); i--)\n#define all(x) (x).begin(), (x).end()\n#define ins insert\n\nusing namespace std;\n\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst li INF64 = 1e18;\nconst ld EPS = 1e-7;\n\nmt19937 myrand(time(NULL));\n\nconst int N = 100 * 1000 + 13;\n\nint n;\nvector<int> g[N];\n\n\nbool read(){\n\tif(scanf(\"%d\", &n) != 1)\n\t\treturn 0;\n\tforn(i, n)\n\t\tg[i].clear();\n\tforn(i, n - 1){\n\t\tint f, t;\n\t\tscanf(\"%d%d\", &f, &t);\n\t\t--f, --t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\treturn 1;\n}\n\nint dp[N];\n\nvoid dfs(int v, int p = -1){\n\tdp[v] = 0;\n\tint cnt = 0;\n\tfor (auto u : g[v]) if (u != p){\n\t\t++cnt;\n\t\tdfs(u, v);\n\t\tdp[v] ^= dp[u] + 1;\n\t}\n}\n\nvoid solve(){\n\tdfs(0);\n\tprintf(dp[0] ? \"Alice\\n\" : \"Bob\\n\");\n}\n\n\nint main(){\n\t#ifdef _DEBUG\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\twhile(read())\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n//#define int long long\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nvector<vector<int>> graph(100010, vector<int>());\n\nint dfs(int n, int p) {\n\tint res = 0;\n\tfor (int i : graph[n]) {\n\t\tif (i == p) continue;\n\t\tres ^= (dfs(i, n) + 1);\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n;\n\tcin >> n;\n\trep(_, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tgraph[a].pb(b);\n\t\tgraph[b].pb(a);\n\t}\n\tcout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= (dis[c]+1);\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nvector <int> bi[N];\nint dfs(int t, int f = 0)\n{\n    int x = 0;\n    for (int i = 0; i < bi[t].size(); ++ i) if (bi[t][i] != f) x ^= dfs(bi[t][i], t) + 1;\n    return x;\n}\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        bi[a].push_back(b);\n        bi[b].push_back(a);\n    }\n    if (dfs(1)) puts(\"Alice\"); else puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define CVector CPoint\n#define INF 0x3f3f3f3f\n#define MAXN 1e5\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-10;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-')f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\nvector<int> E[100005];\nint a[100005];\nbool v[100005];\nint sd;\nvoid dfs(int i,int d){\n    v[i]=true;\n    for(int j=0;j<E[i].size();j++){\n        if(!v[E[i][j]]){\n            dfs(E[i][j],d+1);\n            a[d]++;\n        }\n    }\n    sd=max(sd,d);\n}\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    int n;cin>>n;\n    for(int i=1;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        E[x].push_back(y);\n        E[y].push_back(x);\n    }\n    sd=1;\n    dfs(1,1);\n    for(int i=1;i<sd;i++){\n        if(a[i]%2){\n            cout<<\"Alice\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Bob\"<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nint n, cnt[100010];\nvector<int> g[100010];\ninline int rd(){\n\tint a=0; char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)) (a*=10)+=c-'0', c=getchar();\n\treturn a;\n}\nvoid dfs(int p, int f, int d){\n\tcnt[d]++;\n\tfor(int t: g[p]){\n\t\tif(t==f) continue;\n\t\tdfs(t, p, d+1);\n\t}\n}\nint main(){\n\tn=rd();\n\tint u, v;\n\tfor(int i=1;i<n;i++){\n\t\tu=rd(), v=rd();\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tdfs(1, 0, 0);\n\tbool f=0;\n\tfor(int i=1;i<=n;i++)\n\t\tf|=(cnt[i]&1);\n\tif(!f) puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\ninline int read( )\n{\n  int sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int N=200005;\nint n;\nstruct ex{int num,next;}map[N];\nint head[N],len;\ninline void link(int x,int y)\n{\n  len++;map[len].num=y;map[len].next=head[x];head[x]=len;\n  len++;map[len].num=x;map[len].next=head[y];head[y]=len;\n}\nint f[N];\ninline void dfs(int k,int p)\n{\n  int i,x,y=0;\n  for(i=head[k];i;i=map[i].next)\n    {\n      x=map[i].num;\n      if(x==p) continue;\n      dfs(x,k);y^=(f[x]+1);\n    }\n  f[k]=y;\n}\nint main( )\n{\n  int i,j,x,y;\n  n=read( );\n  for(i=1;i<n;i++) x=read( ),y=read( ),link(x,y);\n  dfs(1,0);\n  puts(f[1]?\"Alice\":\"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 2e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nstruct Edge {\n    int u, v, num;\n} ed[2 * MAXN];\n\nbool use[MAXN];\nint first[MAXN], nexxt[2 * MAXN], res[MAXN], p[MAXN];\n\n\nvoid dfs(int s)\n{\n    use[s] = 1;\n    res[s] = 0;\n\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (!use[ed[i].v])\n        {\n            p[ed[i].v] = s;\n            dfs(ed[i].v);\n            res[s] ^= res[ed[i].v]+1;\n        }\n}\n\nint dfs2(int s, int Gr)\n{\n    for (int i = first[s]; i != -1; i = nexxt[i])\n        if (ed[i].v != p[s] && ((res[ed[i].v]+1) > (Gr ^ (res[ed[i].v]+1) ^ res[s])))\n        {\n            Gr ^= (res[ed[i].v] + 1) ^ res[s];\n            if (Gr == 0)\n                return ed[i].num;\n            return dfs2(ed[i].v, Gr-1);\n        }\n}\n\n\nmain() {\n    int n, r;\n    scanf(\"%ld\", &n);\n    r = 1;\n    --r;\n    int m = n-1;\n    for (int i = 0; i < m; ++i)\n    {\n        scanf(\"%ld%ld\", &ed[i].u, &ed[i].v);\n        --ed[i].u, --ed[i].v;\n        ed[i].num = i + 1;\n\n        ed[i+m].u = ed[i].v;\n        ed[i+m].v = ed[i].u;\n        ed[i+m].num = ed[i].num;\n    }\n\n    m *= 2;\n\n    for (int i = 0; i < n; ++i)\n    {\n        first[i] = -1;\n        use[i] = 0;\n    }\n\n    for (int i = 0; i < m; ++i)\n    {\n        nexxt[i] = first[ed[i].u];\n        first[ed[i].u] = i;\n    }\n\n    p[r] = -1;\n    dfs(r);\n    if (res[r])\n        printf(\"Alice\");\n    else\n        printf(\"Bob\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define edge(u) for(re int i=head[u];i;i=e[i].nxt)\nusing namespace std;\nconst int N=1e5+5;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,head[N],sg[N],cnt;\nstruct edge{\n\tint to,nxt;\n}e[N<<1];\nvoid add(int a,int b){\n\te[++cnt].to=b;\n\te[cnt].nxt=head[a];\n\thead[a]=cnt;\n}\nvoid dfs(int u,int f){\n\tedge(u){\n\t\tint v=e[i].to;\n\t\tif(v==f) continue;\n\t\tdfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\nint main(){\n\tn=read();\n\tinc(i,2,n){\n\t\tint a=read(),b=read();\n\t\tadd(a,b),add(b,a);\n\t}\n\tdfs(1,0);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 1e5 + 10, B = 50, oo = 1e18 + 100, M = 1e9 + 7, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2;\n\n\nint dp[N];\nvi g[N];\n\n\nvoid dfs(int v, int p = -1)\n{\n    for (int u : g[v])\n    {\n        if (u == p)\n            continue;\n\n        dfs(u, v);\n        dp[v] ^= (dp[u] + 1);\n    }\n}\n\n\nvoid smain()\n{\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    dfs(1);\n    if (dp[1])\n        cout << \"Alice\\n\";\n    else\n        cout << \"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100001];\nint dp[100001];\nbool used[100001];\nint cnt[100001];\n\nint dfs(int v,int p){\n\tint res=0;\n\tint cnt=0;\n\tif(G[v].size()==1)return 0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tres+=1-dfs(G[v][i],v);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==1)return 1;\n\treturn (res+cnt)%2;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tG[f].push_back(t);\n\t\tG[t].push_back(f);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(used,false,sizeof(used));\n\tprintf(\"%s\\n\",dfs(0,-1)==1?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint d[100010];\nint sg[100010];\nint x,y;\nvector<int> g[100010];\n\nvoid dfs(int o,int fa)\n{\n\td[o] = 1;\n    for (int i=0;i<g[o].size();i++) \n\t\tif (g[o][i]!=fa) \n\t\t{\n\t\t\tdfs(g[o][i],o);\n\t\t\td[o]+=d[g[o][i]];\n\t\t}\n}\n\nint dfs2(int o,int fa) \n{\n    if (o!=1 && g[o].size()==1)\n\t   return sg[o] = 0;\n\t   \n    for (int i=0;i<g[o].size();i++)\n        if (g[o][i] != fa)\n            sg[o] ^= dfs2(g[o][i],o) + 1;\n    return sg[o];\n}\n\nint main()\n{\n\tcin>>n;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(1,-1);\n\tdfs2(1,-1);\n\tif (sg[1]) return 0*puts(\"Alice\");\n\treturn 0*puts(\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define lc k << 1\n#define rc k << 1 | 1\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint to, nxt;\n}e[500005];\nint h[100005], cnt;\nint n, m;\nint f[100005], dep[100005], siz[100005], ans;\nvoid addedge(int x, int y){\n\tcnt++; e[cnt].to = y; e[cnt].nxt = h[x]; h[x] = cnt;\n}\nvoid dfs1(int x, int fa){\n\tsiz[x] = 1; f[x] = fa; dep[x] = dep[fa] + 1;\n\tfor(int i = h[x]; i; i = e[i].nxt){\n\t\tif(e[i].to == fa) continue;\n\t\tdfs1(e[i].to, x); siz[x] ^= siz[e[i].to];\n\t}\n\tif(e[h[x]].nxt == 0) siz[x] = 1;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i ++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\taddedge(x, y);\n\t\taddedge(y, x);\n\t}\n\tdfs1(1, 0);\n\tfor(int i = h[1]; i; i = e[i].nxt){\n\t\tans ^= siz[e[i].to];\n\t//\tprintf(\"%d \", siz[e[i].to]);\n\t}\n\tans = siz[1];\n\tif(ans == 0){\n\t\tprintf(\"Bob\\n\");\n\t}else{\n\t\tprintf(\"Alice\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pp pair<int,int>\n#define MZ 1000000007\n#define Pi acos(-1)\n#define pq priority_queue\n\nusing namespace std;\n\nstruct Node\n{\n    int n1,n2;\n    int f,du;\n}num[100005];\nbool life[100005];\nvector <int> v1[100005];\nint root[100005];\nqueue <int> q;\n\nvoid dfs(int x)\n{\n    life[x]=1;\n    bool wtf=0;\n    for(int i=0;i<v1[x].size();i++)\n    {\n        if(!life[v1[x][i]])\n        {\n            wtf=1;\n            num[x].du++;\n            root[v1[x][i]]=x;\n            dfs(v1[x][i]);\n        }\n    }\n    if(!wtf)\n        q.push(x);\n}\n\nint main()\n{\n    int n,temp;\n    int x,y;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v1[x].push_back(y);\n        v1[y].push_back(x);\n    }\n    dfs(1);\n    while(!q.empty())\n    {\n        temp=q.front();\n        q.pop();\n        if(num[temp].n2)\n        {\n            if(num[temp].n2%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        else\n        {\n            if(num[temp].n1%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        if(root[temp])\n        {\n            if(num[temp].f==1)\n                num[root[temp]].n1++;\n            else\n                num[root[temp]].n2++;\n            num[root[temp]].du--;\n            if(num[root[temp]].du==0)\n                q.push(root[temp]);\n        }\n    }\n    if(num[1].n2%2 || (num[1].n2==0 && num[1].n1%2))\n        printf(\"Alice\\n\");\n    else\n        printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(x) sort((x).begin(), (x).end())\n#define ALL(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define reps(i, m, n) for (ll i = m; i < n; i++)\n#define repr(i, m, n) for (ll i = m; i >= n; i--)\n#define de(x) cout << #x << \"=\" << x << endl;\ntemplate <class T> bool maxi(T &a, const T &b) {\n    if (a < b) { a = b; return 1;} return 0;}\ntemplate <class T> bool mini(T &a, const T &b) {\n    if (b < a) { a = b; return 1;} return 0;}\n#define dame {cout<< \"-1\" <<\"\\n\"; return;}\n#define INF2 1000000000000000037\n#define INF  1000000007\n#define MOD  1000000007\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P  = pair<ll,ll>;\n//--GLOBAL---------------------------------\nstruct edge{ll to;};\nstruct graph{\n    ll N;\n    vector<vector<edge> > G;\n    vector<bool> used;\n    vector<ll> grundy;\n\n    graph(ll n): N(n), G(N), used(N,false), grundy(N) {}\n\n    void add_edge(ll s, ll t){\n        G[s].emplace_back((edge){t});\n        G[t].emplace_back((edge){s}); //無向ならON\n    }\n\n    void dfs(ll v=0){\n        used[v]=true;\n        ll ans=0;\n        for(auto E : G[v]){\n            if(!used[E.to]){\n                dfs(E.to);\n                ans^=grundy[E.to]+1;\n            }\n        }\n        grundy[v]=ans;\n    }\n};\n//--MAIN-----------------------------------\nvoid Main(){\n    ll N; cin>>N;\n    graph g(N);\n    rep(i,N-1){\n        ll x,y; cin>>x>>y; --x; --y;\n        g.add_edge(x,y);\n    }\n    g.dfs();\n    cout<< ( g.grundy[0]!=0 ? \"Alice\" : \"Bob\" )<<\"\\n\";\n\n}\n//--START----------------------------------\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n}\n//-----------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            res ^= dfs(e, now);\n        }\n    }\n    return res + 1;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao on 2019/11/19.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nll cmp(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    int n;\n    cin>>n;\n    int ans=0;\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        if(x==1||y==1)\n            ans++;\n    }\n    if(ans==1)\n        cout<<\"Alice\"<<endl;\n    else if((n-1)%2==0)\n        cout<<\"Bob\"<<endl;\n    else if((n-1)%2!=0)\n        cout<<\"Alice\"<<endl;\n//-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(int _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(int _##i = (t), i = (f); i <  _##i; i++)\n#define downto(f, t, i)  for(int _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(int _##i = (t), i = (f); i >  _##i; i--)\ntypedef long double ld;\n#define long long long\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n    #define debug true\n    #define ln << endl\n#else\n    #define debug false\n    #define ln << '\\n'\n#endif\n#define tb << '\\t'\n#define sp << ' '\n\nconst int MOD = 1e9+7;\n\nint N;\nset<int> P[100010];\n\nint pyon(int i, int q) {\n    int x = 0;\n    for(int j: P[i]) if(j != q) {\n        x ^= pyon(j, i);\n    }\n    return x + 1;\n}\n\nsigned main() { // long: 64bit\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n\n    scanf(\"%d\",&N);\n    times(N-1, i) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        P[x-1].insert(y-1);\n        P[y-1].insert(x-1);\n    }\n\n    cout << (pyon(0, 0) != 1 ? \"Alice\" : \"Bob\") ln;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    if (cur.empty()) return 0;\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 0;\n    } else {\n        for (auto t : sons) {\n            gr[cur] ^= gr[t];\n        }\n        if (sons.size() == 1) {\n            gr[cur] = 1;\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    for (int i = 0; i < n; i++) {\n        cerr << i + 1 << ' ' << gr[i] << endl;\n    }\n    if (gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, x[MAXN];\nvector<int> adj[MAXN];\n\nvoid dfs(int v, int p = -1){\n\tfor (int u:adj[v])\n\t\tif (u^p){\n\t\t\tdfs(u, v);\n\t\t\tx[v] ^= x[u]+1;\n\t\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++){\n\t\tint a, b;\tcin >> a >> b, a--, b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tdfs(0);\n\tif (x[0])\n\t\tcout << \"Alice\\n\";\n\telse\n\t\tcout << \"Bob\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2016\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nvector<int> adj[MAXN];\nint n, gru[MAXN];\nll val[MAXN];\n\nvoid dfs(int u, int p) {\n\t\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t}\n\t\n\tgru[u] = 0;\n\tint tot = 0;\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\ttot ^= (gru[v] + 1);\n\t}\n\t\n\tfor (int i=0; i<(n+59)/60; i++) val[i] = 0;\n\t\n\tfor (int i=0; i<sz(adj[u]); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v == p) continue;\n\t\tint now = tot ^ (gru[v] + 1);\n\t\tval[now/60] |= (1ll << (now % 60));\n\t}\n\t\n\tfor (int i=0; i<(n+59)/60; i++) {\n\t\tif (val[i] != (1ll << i) - 1) {\n//\t\t\tif (u == 3) cout << (val[i] & (1ll << 0)) << endl;\n\t\t\tfor (int j=0; j<60; j++) {\n//\t\t\t\tif (u == 3) cout << (val[i] & (1ll << j)) << endl;\n\t\t\t\tif ((val[i] & (1ll << j)) == 0) {\n\t\t\t\t\tgru[u] = i * 60 + j;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tcin >> n;\n\tfor (int i=0; i<n-1; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\n\tdfs(0, -1);\n\t\n//\tif (sz(adj[0]) == 1) cout << \"Alice\";\n//\telse {\n//\t\tint ans = 0;\n//\t\tfor (int i=0; i<sz(adj[0]); i++) {\n//\t\t\tans ^= gru[adj[0][i]];\n//\t\t}\n//\t\tif (ans) cout << \"Alice\";\n//\t\telse cout <<\"Bob\";\n//\t}\n\n\tif (gru[0]) cout << \"Alice\";\n\telse cout << \"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define fore(e, u, v) for (int p = e(u), v = e[p].y; p; v = e[p = e[p].nxt].y)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 1e5 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n;\n\nstruct vec {\n\tstatic const int maxE = maxN;\n\tint g[maxN], te;\n\tstruct edge {int y, nxt;} e[maxE << 1];\n\tinline void push(int x, int y) {e[++te] = (edge){y, g[x]}; g[x] = te;}\n\tinline void link(int x, int y) {push(x, y), push(y, x);}\n\tinline int& operator () (int x) {return g[x];}\n\tinline edge& operator [] (int x) {return e[x];}\n}e;\n\nint sg[maxN];\n\nvoid dfs(int x, int fa) {\n\tfore (e, x, y) if (y != fa) {\n\t\tdfs(y, x);\n\t\tsg[x] ^= sg[y];\n\t}\n\tsg[x] += 1;\n}\n\nint main() {\n\n\tn = ri();\n\tFor (i, 1, n) e.link(ri(), ri());\n\tdfs(1, 0);\n\tputs(sg[1] != 1 ? \"Alice\" : \"Bob\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define N 10005\n#define LL long long\n#define inf 1<<29\n#define eps 1e-7\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int t,n;\n\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>          \n#include <map>           \n#include <list>\n#include <ctime>\n#include <deque>         \n#include <bitset>        \n#include <vector>\n#include <list>\n#include <stack>\n#include <random>\t\t \n#include <string>       \n#include <numeric>      //  needed for  accumulate\n#include <utility>      // needed for std:: move\n#include <iterator> \n#include <iostream>   \n#include <algorithm> \n#include <functional>    \n#include <cmath>         \n#pragma warning(disable:4996) // ignore this\n#define ve vector\n#define pb push_back\n#define mp make_pair                     \n#define srt(x) sort(x.begin(),x.end())         \n#define mod static_cast<long long> (1e9+7)     \n#define sumx(x) accumulate(x.begin(),x.end(),0LL)\n#define pi 3.14159265358979323846\nusing namespace std;\ntemplate<typename T>\nistream& operator >> (istream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin >> x;\n\treturn in;\n}\ntemplate<typename T>\nostream& operator<<(ostream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin << x << \" \";\n\treturn in;\n}\nclass solve\n{\n\tlong long n;\n\tve<bool > vis;\n\tve<ve<int> > adj;\n\tve<ve<int> > adj2;\n\tvoid dfs(int c=0)\n\t{\n\t\tvis[c]=true;\n\t\tfor(auto &x:adj[c])\n\t\t{\n\t\t\tif(!vis[x])\n\t\t\t{\n\t\t\t\tadj2[c].pb(x);\n\t\t\t\tdfs(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tint winner(int c=0)\n\t{\n\t\tvis[c]=false;\n\t\tif(adj2[c].size()==1)\n\t\t\treturn 1;\n\t\tint ans=0;\n\t\tfor(auto &x:adj2[c])\n\t\t{\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tans^=winner(x);\n\t\t\t}\n\t\t}\n\t\treturn !ans;\n\t}\npublic:\n\tsolve()\n\t{\n\t\tcin >> n;\n\t\tvis.resize(n);\n\t\tadj.resize(n);\n\t\tadj2.resize(n);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\t--x,--y;\n\t\t\tadj[x].pb(y);\n\t\t\tadj[y].pb(x);\n\t\t}\n\t\tdfs();\n\t\tint p=winner(0);\n\t\tif(p)\n\t\t{\n\t\t\tcout << \"Alice\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"Bob\\n\";\n\t\t}\n\t}\n};\n \nint main()\n{\n\tint t = 1, i = 1;\n\t//scanf(\"%d\", &t);\n \n\twhile (t--)\n\t{\n\t\tnew solve;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb push_back\n#define mp std::make_pair\n//#define endl \"\\n\"\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\nusing std::endl;\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\n//const ll MOD=100000;\nconst ll MAX=1e7;\nconst ll INF=(1ll<<50);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nll modpow(ll X,ll Y){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=MOD;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=MOD;\n        }\n    }\n    return ret;\n}\nll fac[MAX],finv[MAX],inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r];\n}\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N; cin>>N;\n    vi cnt(N);\n    vi edge(N);\n    rep(i,1,N){\n        ll X,Y; cin>>X>>Y;\n        cnt[X-1]++;\n        cnt[Y-1]++;\n        if(X==1) edge.pb(Y-1);\n        if(Y==1) edge.pb(X-1);\n    }\n    string ans=\"Bob\";\n    if(cnt[0]==1) ans=\"Alice\";\n    if(N%2==0) ans=\"Alice\";\n    ll c=0,d=0;\n    rep(i,0,edge.size()){\n        ll X=edge[i];\n        if(cnt[X]==1) c++;\n        if(cnt[X]==2) d++;\n    }\n    if(d==1&&c==1) ans=\"Alice\";\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nvector<int> g[101000];\n\nint dfs(int v,int p){\n   int res=0;\n   for(int nxt:g[v])if(nxt!=p)res^=dfs(nxt,v);\n   return res+1;\n}\n\nint main(){\n   int n; scanf(\"%d\",&n);\n   rep(_,0,n-1){\n      int x,y; scanf(\"%d%d\",&x,&y); x--; y--;\n      g[x].push_back(y); g[y].push_back(x);\n   }\n   printf(dfs(0,-1)==1?\"Bob\\n\":\"Alice\\n\");\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N,x,y,visited[100010] = {0};\nvector<vector<int>> v(100010);\n\nint dfs(int n){\n\tvisited[n] = 1;\n\tint g = 0;\n\tif(n!=1 && v[n].size()==1) return 0;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tif((n==1 && v[n].size()==1) || n!=1 && v[n].size()==2) return dfs(s)+1;\n\t\t\telse{\n\t\t\t\tg ^= dfs(s)+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> x >> y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tcout << (dfs(1)==0? \"Bob\":\"Alice\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\n\nconst int N = 1e5 + 123;\nint n, par[N], h[N], child[N];\nvi adj[N];\n\nvoid dfs(int v, int p) {\n\tfor (int to : adj[v]) {\n\t\tif (to == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tpar[to] = v;\n\t\th[to] = h[v] + 1;\n\t\tdfs(to, v);\n\t\tchild[v]++;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\tdfs(1, 1);\n\tset <pii> st;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (child[i] == 0) {\n\t\t\tst.insert({-h[i], i});\n\t\t}\n\t}\n\tpii a, b;\n\twhile (st.size() > 1) {\n\t\ta = *st.begin();\n\t\tb = *next(st.begin());\n\t\tst.erase(a);\n\t\tst.erase(b);\n\t\tint v = a.S, u = b.S;\n\t\t//cout << \"v u \" << v << ' ' << u << '\\n';\n\t\tchild[par[v]]--;\n\t\tif (child[par[v]] == 0) {\n\t\t\tst.insert({-h[par[v]], par[v]});\n\t\t}\n\t\tchild[par[u]]--;\n\t\tif (child[par[u]] == 0) {\n\t\t\tst.insert({-h[par[u]], par[u]});\n\t\t}\n\t}\n\tif (st.size() == 1 && (*(st.begin())).S == 1) {\n\t\tcout << \"Bob\";\n\t}\telse {\n\t\tcout << \"Alice\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nint n , a , b,res=0;\nvector<int> g[N];\n\nvoid dfs(int u , int p , int depth){\n\tres ^= depth;\n\tfor (int i = 0; i < g[u].size(); ++i){\n\t\tint v = g[u][i];\n\t\tif(v==p)continue;\n\t\tdfs(v,u,depth+1);\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (int i = 0; i < n-1; ++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tdfs(1,-1,0);\n\tif(res){\n\t\tputs(\"Alice\");\n\t}else{\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 200010;\nint f[N];\nstruct node {\n\tint to, nxt;\n} g[N];\nint lst[N], gl;\nvoid add(int x, int y) { g[++gl] = (node) {y, lst[x]}; lst[x] = gl; }\nvoid dfs(int u, int ff) {\n\tint c1 = 0, c2 = 0;\n\tfor (int i = lst[u]; i; i = g[i].nxt) {\n\t\tint v = g[i].to; if (v == ff) continue;\n\t\tdfs(v, u);\n\t\tif (f[v]) c1++;\n\t\telse c2++;\n\t}\t\n\tif (!c1) {\n\t\tif (c2) f[u] = c2 & 1;\t\t\n\t}\n\telse f[u] = c1 & 1;\n//\tprintf(\"[%d] %d\\n\", u, f[u]);\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = gi<int>(), y = gi<int>();\n\t\tadd(x, y); add(y, x);\n\t}\n\tdfs(1, 0);\n\tputs(f[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define For(i,a,b) for(int i=a;i<b;i++)\nconst int M=100005;\nbool has[M];\nint n,fa[M],sg[M],res;\nvector<int>G[M];\nvoid calc(int x,int res,int f=-1){\n    For(i,0,G[x].size())res^=sg[G[x][i]];\n    has[res]=1;\n    For(i,0,G[x].size())\n    \tif(G[x][i]!=f)calc(G[x][i],res^sg[G[x][i]],x);\n}\nvoid dfs(int x,int f=-1){\n    For(i,0,G[x].size())if(G[x][i]!=f)dfs(G[x][i],x);\n    memset(has,0,sizeof(has));\n    calc(x,0);\n    while(has[sg[x]])sg[x]++;\n}\nint Tz(int x=1,int f=-1){\n\tint res=sg[x];\n\tFor(i,0,G[x].size())if(G[x][i]!=f)\n\t\tres^=(Tz(G[x][i],x)+1);\t\t\t\n\treturn res;\n}\nint main(){\n    scanf(\"%d\",&n);\n    For(i,0,n-1){\n    \tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x-1].push_back(y-1);\n\t\tG[y-1].push_back(x-1);\n\t}\n\tFor(i,0,n)dfs(i);\n    printf(\"%s\",Tz()?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2000000000000000000\n#define ll long long\nusing namespace std;\n\nll grundy(vector<vector<ll>>& connection, vector<bool>& already, ll now) {\n  already.at(now) = true;\n  vector<ll> res;\n  for (ll i = 0; i < connection.at(now).size(); ++i) {\n    ll next = connection.at(now).at(i);\n    if (already.at(next)) {\n      continue;\n    }\n    already.at(next) = true;\n    res.push_back(grundy(connection, already, next) + 1);\n  }\n  ll temp = 0;\n  for (ll i = 0; i < res.size(); ++i) {\n    temp ^= res.at(i);\n  }\n  // cout << \"now\" << now << \" grundy \" << temp << \"\\n\";\n  return temp;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ll N;\n  cin >> N;\n  vector<vector<ll>> connection(N);\n  vector<bool> already(N, false);\n  for (ll i = 0; i < N - 1; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    x -= 1;y -= 1;\n    connection.at(x).push_back(y);\n    connection.at(y).push_back(x);\n  }\n  ll ans = grundy(connection, already, 0);\n  // cout << ans << \"\\n\";\n  if (ans == 0) {\n    cout << \"Bob\" << \"\\n\";\n  }\n  else {\n    cout << \"Alice\" << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n - 1) {\n        int x, y; scanf(\"%d%d\", &x, &y); -- x; -- y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    vector<int> grundy(n);\n    function<int (int, int)> go = [&](int i, int parent) {\n        int acc = 0;\n        for (int j : g[i]) if (j != parent) {\n            acc ^= go(j, i) + 1;\n        }\n        return acc;\n    };\n    int result = go(0, -1);\n    printf(\"%s\\n\", result ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,n) for(ll i=(ll)a;i<(ll)n;i++)\n#define rep(i,n) FOR(i,0,n)\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>bool chmax(T &a,const T &b){\n    if(a>b)return false;\n    a=b;\n    return true;\n}\ntemplate<class T>bool chmin(T &a,const T &b){\n    if(a<b)return false;\n    a=b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n,x,y;\nvector<int> e[100009];\nbool visited[100009];\n\nint dfs(int m){\n    visited[m]=true;\n    int re=0,cnt=0;\n    rep(i,e[m].size()){\n        if(!visited[e[m][i]]){\n            cnt++;\n            re^=dfs(e[m][i])+1;\n        }\n    }\n    return re;\n}\n\nint main(){\n    cin>>n;\n    rep(i,n-1){\n        cin>>x>>y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    cout<<(dfs(1)?\"Alice\\n\":\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/// ITNOG :)))\n/// SAliB\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb                      push_back\n#define pp                      pop_back\n#define mp                      make_pair\n#define fi                      first\n#define sec                     second\n#define xmax(x,y)               ((x) = max((x),(y)))\n#define xmin(x,y)               ((x) = min((x),(y)))\n#define all(x)                  (x).begin(),(x).end()\n#define mem(x , y)              memset(x , y , sizeof(x))\n#define _                       ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\n#define debug1(a)               cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n';\n#define debug2(a , b)           cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n';\n#define debug3(a , b , c)       cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n' << #c << \" ---> \" << c << '\\n';\n#define debug4(a , b , c , d)   cout << string(40 , '*') << '\\n' << #a << \" ---> \" << a << '\\n' << #b << \" ---> \" << b << '\\n' << #c << \" ---> \" << c << '\\n' << #d << \" ---> \" << d << '\\n';\n#define connect(a , b , c)      a[b].pb(c) , a[c].pb(b)\n//\ntypedef long long int ll            ;\ntypedef unsigned long long int ull  ;\ntypedef unsigned int uint           ;\ntypedef long double ld              ;\ntypedef string str                  ;\ntypedef pair < int , int > pii      ;\ntypedef pair < pii , int > ppi      ;\ntypedef pair < int , pii > pip      ;\ntypedef pair < ll , ll> pll         ;\ntypedef pair < ll , pll> plp        ;\ntypedef pair < pll , ll> ppl        ;\ntypedef vector < ll > vl            ;\ntypedef vector < ld > vld           ;\ntypedef vector < int > vi           ;\ntypedef vector < str > vs           ;\n//\ninline int   iin()  { int x   ; scanf(\"%d\" , &x)   ;  return x; }\ninline ll    lin()  { ll  x   ; scanf(\"%lld\" , &x) ;  return x; }\ninline ll    Lin()  { ll  x   ; scanf(\"%I64d\" , &x);  return x; }\n//\ninline int   iout(int  x)  { printf(\"%d\" , x)   ;  }\ninline ll    lout(ll   x)  { printf(\"%lld\" , x) ;  }\ninline ll    Lout(ll   x)  { printf(\"%I64d\" , x);  }\n//\nconst int maxn4 = 1e4 + 85 , maxn5 = 1e5 + 69 , maxn6 = 1e6 + 85 , maxn7 = 1e7 + 69 , maxn8 = 1e8 + 85 , maxn9 = 1e9 + 69 , modi1 = 1e7 + 7 , modi2 = 1e9 + 7;\nconst ll mod1 = 1e7 + 7 , mod2 = 1e9 + 7;\nint mn = INT_MAX , mx = INT_MIN;\n//\nvi g[maxn6];\nint dfs(int v , int p)\n{\n    int ans = 0;\n    for(int u : g[v])\n    {\n        if (u != p)\n            ans ^= dfs(u , v) + 1;\n    }\n    return ans;\n}\nint main()\n{_\n    int n; cin >> n;\n    for(int i = 0; i < n - 1; i++)\n    {\n        int x , y; cin >> x >> y;x--;y--;\n        connect(g , x , y);\n    }\n    cout << (dfs(0, -1) == 1 ? \"Bob\" : \"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nvector<int>V[N];\nint n, tim[N], tid, sg[N];\n\nvoid Dfs (int u, int fa) {\n\tfor (auto v : V[u]) if (v != fa) Dfs(v, u);\n\t++tid;\n\ttim[0] = tid;\n\tfor (auto v : V[u]) if (v != fa) tim[sg[v]] = tid;\n\twhile (tim[sg[u]] == tid) ++sg[u];\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tV[u].emplace_back(v);\n\t\tV[v].emplace_back(u);\n\t}\n\tint nim = 0;\n\tfor (auto v : V[1]) {\n\t\tDfs(v, 1);\n\t\tnim ^= sg[v];\n\t}\n\tputs(nim ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 100100;\nvector<int> g[N];\nint a[N];\nint n;\n\nvoid dfs(int v, int par) {\n    a[v] = 0;\n    for (int u : g[v]) {\n        if (u == par) continue;\n        dfs(u, v);\n        a[v] ^= a[u] + 1;\n    }\n    return;\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int v, u;\n        scanf(\"%d%d\", &v, &u);\n        v--;u--;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(0, -1);\n    if (a[0] == 0)\n        printf(\"Bob\\n\");\n    else\n        printf(\"Alice\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio> \n#include<cstring> \n#include<cmath> \n#include<vector> \n#include<algorithm> \n#define N 10005 \n#define LL long long \n#define inf 1<<29 \n#define eps 1e-7 \nusing namespace std; \nvector<int>v[100005]; \nint get_sg(int u,int pre){ \n    int ret=0; \n    for(int i=0;i<v[u].size();i++){ \n        if(v[u][i]!=pre) \n            ret^=(1+get_sg(v[u][i],u)); \n    } \n    return ret; \n} \nint main(){ \n    int t,n; \n    scanf(\"%d\",&t); \n    while(t--){ \n        scanf(\"%d\",&n); \n        for(int i=1;i<=n;i++) \n            v[i].clear(); \n        for(int i=1;i<n;i++){ \n            int x,y; \n            scanf(\"%d%d\",&x,&y); \n            v[x].push_back(y); \n            v[y].push_back(x); \n        } \n        if(get_sg(1,-1)) \n            puts(\"Alice\"); \n        else \n            puts(\"Bob\"); \n    } \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int>v[100010];\nint main()\n{\n    int n,a,b,ans;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    ans=v[v[1][0]].size()+1;\n    for(int i=1;i<v[1].size();i++)\n    {\n        ans^=v[v[1][i]].size();\n    }\n    if(!ans) printf(\"Alice\");\n    else printf(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> con[100001];\nint odd=0;\n\nvoid dfs(int p, int prev) {\n\tif (prev != -1 and con[p].size() % 2 == 0) {\n\t\todd++;\n\t\treturn;\n\t}\n\tfor (int i: con[p]) {\n\t\tif (i == prev) continue;\n\t\tdfs(i, p);\n\t}\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tint N;\n\tcin >> N;\n\tmemset(con, 0, sizeof(con));\n\tint a, b;\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> a >> b;\n\t\tcon[a].push_back(b);\n\t\tcon[b].push_back(a);\n\t}\n\t\n\tif (con[1].size() % 2 == 0) dfs(1, -1);\n\telse odd++;\n\n\tif (odd%2 == 1) cout << \"Alice\";\n\telse cout << \"Bob\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 7;\n\nvector<int> adj[N];\nint mark[N];\nint nim[N];\n\nvoid dfs(int v, int p)\n{\n\tfor (auto u : adj[v])\n\t\tif (u != p)\n\t\t{\n\t\t\tdfs(u, v);\n\t\t\tnim[v] ^= nim[u] + 1;\n\t\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tcout << (nim[0] ? \"Alice\" : \"Bob\") << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n#include <assert.h>\n#include <unordered_set>\n#include <random>\n\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\n\n\n\n\n\nvector<vector<ll>> g;\nll xorsum = 0;\n\nvoid dfs(ll now, ll par, ll dist){\n    bool f = true;\n    for(auto &child : g[now]){\n        if(child == par) continue;\n        dfs(child, now, dist + 1);\n        f = false;\n    }\n    if(f) xorsum ^= dist - 1;\n}\n\n\n\nint main(){\n    ll n;\n    cin >> n;\n    g.resize(n);\n    REP(i, n - 1){\n        ll x, y;\n        cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0, -1, 0);\n    if(g[0].size() <= 1 || xorsum != 0){\n        cout << \"Alice\" << endl;\n    }\n    else{\n        cout << \"Bob\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,sg[N];\nvector<int> e[N];\nvoid dfs(int x,int fa){\n\tfor (int i=0;i<e[x].size();i++){\n\t\tint v=e[x][i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x);\n\t\tsg[x]^=(sg[v]+1);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    if (cur.empty()) return 0;\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 0;\n    } else {\n        for (auto t : sons) {\n            gr[cur] ^= (gr[t] + 1);\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    // for (int i = 0; i < n; i++) {\n    //     cerr << i + 1 << ' ' << gr[i] << endl;\n    // }\n    if (!gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\nconst int MAX = 100*1000 + 7;\n\nVI g[MAX];\n\n\nint dfs(int v, int p = -1) {\n    int tot = 0;\n    int win = 0;\n    FOR(i, 0, SZ(g[v])) {\n        int to = g[v][i];\n        if (to == p)continue;\n        tot++;\n        if (dfs(to, v))win++;\n    }\n    \n    if (tot == 0)return 0;\n    int lose = tot - win;\n    ///cout << v << \" \" << tot << \" \" << win << \" \" << lose << endl;\n    \n\n    if (((tot & 1) == 0) && ((lose & 1)  == 0))return 0;\n    if (((tot & 1) == 1) && (lose & 1 == 1)) {\n        return lose;\n    }\n    if ((tot & 1 == 1) && (lose & 1 == 0))return win;\n    return win;\n    \n}\n\n\n\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    FOR(i, 0, n-1) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        g[a].PB(b);\n        g[b].PB(a);\n    }\n    cout << (dfs(1) ? \"Alice\" : \"Bob\") << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[100001];\nbool visited[100001];\nint d;\n\nvoid dfs(int v){\n    d++;\n    for(int i=0; i<G[v].size(); i++){\n        if(visited[G[v][i]]==0){\n            visited[G[v][i]]=1;\n            dfs(G[v][i]);\n        }\n    }\n}\n\nint main(){\n    //input\n    int N;\n    cin >> N;\n    int x,y;\n    N--;\n    while(N--){\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    //calc\n    int grundy=0;\n    for(int i=0; i<=100000; i++){\n        visited[i]=0;\n    }\n    visited[1]=1;\n    for(int i=0; i<G[1].size(); i++){\n        d=0;\n        visited[G[1][i]]=1;\n        dfs(G[1][i]);\n        grundy^=d;\n    }\n\n    //output\n    if(grundy!=0){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n    system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint N;\nset<int> cand;\nint x[100005], y[100005];\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n\n  int root = 0;\n  int edge = 0;\n\n  rep(i, N - 1) {\n      cin >> x[i] >> y[i];\n      x[i]--; y[i]--;\n      if (x[i] > y[i]) swap(x[i], y[i]);\n      if (x[i] == 0) {\n          root += 1;\n          cand.add(y[i]);\n      } \n  }\n\n  rep(i, N) {\n    if (HAS(cand, x[i])) {\n        edge += 1;\n        root -= 1;\n        cand.remove(x[i]);\n    }\n    if (HAS(cand, y[i])) {\n        edge += 1;\n        root -= 1;\n        cand.remove(y[i]);\n    }\n  }\n\n  int hand = 0;\n  while (true) {\n    if (edge == 0) {\n        root -= 1;\n    }\n    else {\n        if (root%2 == 1) {\n            edge -= 1;\n        } else {\n            root -= 1;\n        }\n    }\n    if (root == 0) {\n      cout << (hand == 1 ? \"Bob\":\"Alice\") << endl;\n      break;\n    }\n\n    hand = (hand + 1)%2;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nint dp[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      //dp[v] += dp[to];\n      dp[v]++;\n    }\n  }\n}\nvoid solve() {\n  //freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (sz(g[1]) == 1) cout << \"Alice\", ioi\n  dfs(1, 1);\n  int res = 0;\n  rep(i, 1, n)\n    res ^= dp[i];\n  if (res) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint num[100001], depth[100001], N;\nvi adj[100001];\n\nvoid dfs(int p, int node) {\n    num[depth[node]] ++;\n    for (int i: adj[node]) if (i != p) {\n        depth[i] = depth[node]+1;\n        dfs(node,i);\n    }\n}\n\nint main() {\n\tcin >> N;\n\tF0R(i,N-1) {\n\t    int a,b; cin >> a >> b;\n\t    adj[a].pb(b);\n\t    adj[b].pb(a);\n\t}\n\tdfs(0,1);\n\t//F0R(i,10) cout << n\n\tFOR(i,1,100001) if (num[i] % 2 == 1) {\n\t    cout << \"Alice\";\n\t    return 0;\n\t}\n\tcout << \"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "// Ala be zekrellah tatmaenolgholoob ...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n#define MP make_pair\nconst int maxn = 1e5+9;\nconst ll mod = 1e9+7;\n\nvector <int> g[maxn];\nint grundy[maxn];\n\nvoid dfs (int v, int parent = -1) {\n\tint num = 0;\n\tfor (auto u : g[v]) {\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tdfs(u, v);\n\t\tgrundy[v] ^= grundy[u] + 1;\n\t}\n}\n\nint main () {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\t--v; --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t\t}\n\tdfs(0);\n\tif (grundy[0])\n\t\tcout << \"Alice\\n\";\n\telse\n\t\tcout << \"Bob\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n\n#include <bits/stdc++.h>\n                                                                    \n#define N 200010\n#define M 400010\n\nusing namespace std;\n\n#define IV inline void\n#define II inline int\n\n#define lc c[x][0]\n\n#define rc c[x][1]\n\nint c[N][2],f[N],s[N],v[N],r[N];\n\nint st[N];\n\ninline bool proot(int x){\n\treturn c[f[x]][0]==x||c[f[x]][1]==x;\n}//返回1表示他不是根\n\nIV pushp(int x){\n\ts[x]=s[c[x][0]]^s[c[x][1]]^v[x];\n}\n\nIV pushr(int x){\n\tint t=c[x][0];c[x][0]=c[x][1];c[x][1]=t;\n\tr[x]^=1;return;\n}\n\nIV pushdown(int x){//你见过这么优秀的pushdown吗？\n\tif(r[x])\n\t{\n\t\tif(c[x][0]) pushr(c[x][0]);\n\t\tif(c[x][1]) pushr(c[x][1]);\n\t\tr[x]=0;\n\t}\n}\n\nII Get(int x){\n\treturn (c[f[x]][1]==x);\n}\n\nIV rotate(int x){\n\tint rf=f[x],rff=f[rf],h=Get(x),rh=Get(rf),w=c[x][!h];\n\tif(proot(rf)) c[rff][rh]=x;c[x][!h]=rf,c[rf][h]=w;\n\tif(w)  f[w]=rf;f[rf]=x;f[x]=rff;\n\tpushp(rf);\n\treturn;\n}\n\nIV splay(int x){\n\tint y=x,z=0;\n\tst[++z]=y;\n\twhile(proot(y)) st[++z]=y=f[y];\n\twhile(z) pushdown(st[z--]);\n\twhile(proot(x)){\n\t\ty=f[x];z=f[y];\n\t\tif(proot(y))\n\t\t  rotate((c[y][0]==x)^(c[z][0]==y)?x:y);\n\t\trotate(x);\n\t}\n\tpushp(x);\n}\n\nIV access(int x){\n\tfor(int y=0;x;x=f[y=x])\n\t  splay(x),c[x][1]=y,pushp(x);\n}\n\nIV makeroot(int x){\n\taccess(x);splay(x);\n\tpushr(x);\n}\n\nint findroot(int x){\n\taccess(x);splay(x);\n\twhile(c[x][0]) pushdown(x),x=c[x][0];\n\tsplay(x);\n\treturn x;\n}\n\nIV split(int x,int y){\n\tmakeroot(x);\n\taccess(y);splay(y);\n}\n\nIV link(int x,int y){\n\tmakeroot(x);\n\tif(findroot(y)!=x) f[x]=y;\n}\n\nIV cut(int x,int y){\n\tmakeroot(x);\n\tif(findroot(y)==x&&f[y]==x&&!c[y][0]){\n\t\tf[y]=c[x][1]=0;\n\t\tpushp(x);\n\t}\n}\n\nint ans[N];\nint ver[M],nex[M],head[N],nu;\nint n,x1,x2;\n\ninline int read(){\n\tint x=0;char c=getchar();\n\tfor(;c<'0' || c>'9';c=getchar());\n\tfor(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;\n\treturn x;\n}\n\ninline void add(int x,int y){\n\tver[++nu]=y;nex[nu]=head[x];head[x]=nu;\n}\n\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=nex[i]){\n\t\tint y=ver[i];\n\t\tif(y!=fa)\n\t\tdfs(y,x);\n\t\tans[x]^=(ans[y]+1);\n\t}\n\treturn;\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\tx1=read(),x2=read(),add(x1,x2),add(x2,x1);\n\tdfs(1,1);\n\tif(!ans[1]) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n\treturn 0;\n}                                                                                                                                                                                   "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nvector<vec>G(N);\nint dfs(int x,int p){\n  int g=0;\n  for(auto e:G[x]){\n    if(e!=p){\n    g^=(dfs(e,x)+1);}\n  }\n  return g;\n}\nmain(){\n    int n=in();\n  rep(i,n-1){\n  int a=in(),b=in();\n  G[a].pb(b);\n  G[b].pb(a);}\n  cout<<((dfs(1,0)!=0)?\"Alice\":\"Bob\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    V<t2> xylist; llinl2(xylist, n-1);\n\n    V<ll> linklist[100005];\n    make_linklist(xylist, linklist);\n\n    S ll parent[100005];\n    S V<ll> children[100005];\n    S ll level[100005];\n    make_parental_relation(linklist, 1, n,\n                            parent, children, level);\n\n    S ll levelcnt[100005];\n    memset(levelcnt, 0, sizeof(levelcnt));\n    srep (v, 1, n+1) levelcnt[level[v]]++;\n\n    srep (i, 1, 100005) {\n        if (levelcnt[i] & 1LL) {\n            cout << \"Alice\" << endl;\n            return;\n        }\n    }\n\n    cout << \"Bob\" << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2e5 + 5;\n\nint other[MAXN + 5], last[MAXN + 5], pre[MAXN + 5];\nint dp[MAXN + 5];\nint N, all = -1;\n\nvoid build(int u, int v)\n{\n\tpre[++all] = last[u];\n\tlast[u] = all;\n\tother[all] = v;\n}\n\nint dfs(int ans, int fa)\n{\n\tint dt = last[ans], c = 0, sum = 0;\n\twhile(dt != -1){\n\t\tint dr = other[dt];\n\t\tif(dr != fa) c ^= dfs(dr, ans), sum++;\n\t\tdt = pre[dt];\n\t}\n\tif(ans == 1){\n\t\tif(sum == 1) return c ^ 1;\n\t\telse return c;\n\t}\n\telse return c ^ 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tmemset(last, -1, sizeof(last));\n\tfor(int i = 1; i < N; i++){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tbuild(u, v);\n\t\tbuild(v, u);\n\t}\n\tint check = dfs(1, 0);\n\tif(check) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\nint sg[N],n;\nvoid dfs(int u,int fa){\n\tsg[u]=0;\n\tgo(u)if(v!=fa)dfs(v,u),sg[u]^=sg[v]+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(R int i=1,u,v;i<n;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n//Code by : Y-k-y\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <set>\n#define ll long long\nconst int N=100010;\nusing namespace std;\ninline int rnd(){\n\tint res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}\n\treturn res*f;\n}\ninline void wr(int x){\n\tif(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');\n}\nvector<int>vec[N];\nint n,sg[N];\ninline void dfs(int u,int f){\n\tsg[u]=0;\n\tfor(int i=0;i<vec[u].size();i++){\n\t\tint v=vec[u][i];\n\t\tif(v==f)continue;\n\t\tdfs(v,u);\n\t\tsg[u]^=(sg[v]+1);\n\t}\n}\nint main(){\n\tcin>>n;int x,y;\n\tfor(int i=1;i<n;i++){\n\t\tx=rnd();y=rnd();\n\t\tvec[x].push_back(y);\n\t\tvec[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit32(x) (1 << (x))\n#define bit64(x) (1ll << (x))\n#define sz(v) ((int) v.size())\n\nusing namespace std;\n\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<int>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\nvoid yes() { cout << \"Yes\" << endl; exit(0); }\nvoid no() { cout << \"No\" << endl; exit(0); }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> void amax(T &x, T y) { x = max(x, y); }\ntemplate <typename T> void amin(T &x, T y) { x = min(x, y); }\ntemplate <typename T> T exp(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { for (auto &x : v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\n\ntemplate <typename T, typename U>\nvector<U> make_vector(T&& n, U&& val) {\n  return vector<U>(forward<T>(n), forward<U>(val));\n}\ntemplate <typename T, typename... Args>\ndecltype(auto) make_vector(T&& n, Args&&... args) {\n  return vector<decltype(make_vector(forward<Args>(args)...))>(forward<T>(n), make_vector(forward<Args>(args)...));\n}\n\nconst int INF = 1001001001;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vi32> g(n);\n  rep(i, n - 1) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n  auto grundy = [&](auto grundy, int u, int p) -> int {\n    int ret = 0;\n    for (auto v : g[u]) if (v != p) {\n      ret ^= grundy(grundy, v, u) + 1;\n    }\n    return ret;\n  };\n  int ret = grundy(grundy, 0, -1);\n  if (ret != 0) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::vector;\nusing std::pair;\n\nusing pii = pair<int, int>;\nvector<int> G[100003];\nint cnt[100003];\nvoid go(int idx,int p) {\n\t\n\tfor (auto &to : G[idx]) {\n\t\tif (p == to) continue;\n\t\tgo(to, idx);\n\t\tcnt[idx] ^= cnt[to] + 1;\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tgo(1,1);\n\tif (cnt[1] == 0) printf(\"Bob\");\n\telse printf(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e5 + 10;\n\nll ans, cnt, gr[N];\nll a[N];\n\nvector<int> adj[N];\n\nvoid DFS(int v, int p = -1)\n{\n\t//par[v] = p;\n\tgr[v] = 0;\n\n\tfor(auto u : adj[v])\n\t{\n\t\tif(u == p)continue;\n\t\tDFS(u, v);\n\t\tgr[v] ^= (gr[u] + 1);\n\t}\n\treturn ;\n}\n\n/*\nvoid dfs(int v, int p = -1)\n{\n\tif(p != -1 && mark[p] && !mark[v])ans ^= (gr[v] + 1);\n\tfor(auto u : adj[v])\n\t{\n\t\tif(u == p)continue;\n\t\tdfs(u, v);\n\t}\n\treturn ;\n}\n*/\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\n\tint t = 1;\n\twhile(t--)\n\t{\n\t\tint ted = 0, n, root = 0; cin >> n;\n\t\t\n\t\t/*for(int i=0; i<n; i++){\n\t\t\tcin >> a[i];\n\t\t\tif(a[i])root = i, ted ++;\n\t\t}\n\t\tif(ted == 0)return cout << 1/0 << endl, 0;\n\t\tif(ted > 1)return cout << 1/0 << endl, 0;\n\t\t*/\n\n\t\tfor(int i=0; i<n; i++)adj[i].clear();\n\t\tfor(int i=0; i<n-1; i++)\n\t\t{\n\t\t\tint u, v; cin >> u >> v;\n\t\t\t--u; --v;\n\t\t\tadj[u].pb(v);\n\t\t\tadj[v].pb(u);\n\t\t}\n\t\tDFS(root);\n\t\tif(gr[root])cout << \"Alice\\n\";\n\t\telse cout << \"Bob\\n\";\n\t}\n\n}\t"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\t//vector<ULL>cash;\n\n\tint res = 0;\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tres ^= seed(now, ch);\n\t}\n\treturn res;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 0)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    Int N;\n    vector<vector<Int>> G;\n\n    pair<Int, Int> dfs(int v, int p = -1) {\n        Int ret_l = 1; // is linear ? , 1: linear, 0: not linear\n        Int ret_v = 0;\n        Int child = 0;\n\n        for (auto e : G[v]) {\n            if (e != p) {\n                auto tapi = dfs(e, v);\n                child++;\n                if (tapi.first == 0) {\n                    ret_l = 0;\n                }\n                ret_v ^= tapi.second;\n            }\n        }\n        if (child > 1) {\n            ret_l = 0;\n        }\n\n        if (child == 0) {\n            return make_pair(1ll, 0ll);\n        }\n\n        if (ret_l == 1) {\n            return make_pair(1ll, ret_v + 1);\n        }\n\n        return make_pair(0ll, ret_v);\n    }\n\n    void solve() {\n        cin >> N;\n        G.resize(N);\n        for (Int i = 0; i + 1 < N; ++i) {\n            Int a, b;\n            cin >> a >> b;\n            a--, b--;\n            G[a].push_back(b);\n        }\n\n        auto tapu = dfs(0);\n        if (tapu.second == 0) {\n            cout << \"Bob\" << endl;\n        } else {\n            cout << \"Alice\" << endl;\n        }\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint N;\nvector<int> G[100005];\nint dp[100005];\n\nint calc(int p, int x){\n  if(dp[p] != -1) return dp[p];\n  int ret = 0;\n  vector<int> res;\n  rep(i,G[p].size()){\n    if(G[p][i] == x) continue;\n    res.push_back(calc(G[p][i], p));\n  }\n  if(res.size()==0) ret = 0;\n  else if(res.size()==1) ret = res[0] + 1;\n  else{\n    rep(i,res.size()){\n      ret ^= (res[i]+1);\n    }\n  }\n  return dp[p] = ret;\n}\n\nint main(){\n  cin >> N;\n  rep(i,N-1){\n    int x, y;\n    cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  rep(i,100005){\n    dp[i] = -1;\n  }\n  \n  calc(1, 0);\n\n  if(dp[1] != 0) cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,x[100010];\nint main(){\n\tcin>>n;\n\tmemset(x,0,n);\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;a--,b--;\n\t\tx[a]++,x[b]++;\n\t}\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(x[i]%2==1)cnt++;\n\t}i\n\tif(cnt%2==1)cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nconst int MAXN = 100005;\nint dp[MAXN], visited[MAXN];\n\nint n;\n\nvector<vector<int>> adj;\n\nvoid dfs(int u) {\n    visited[u] = 1;\n\n    dp[u] = 0;\n\n    int children = 0;\n\n    for (auto& v : adj[u]) {\n        if (!visited[v]) {\n            children++;\n        }\n    }\n\n    if (children == 1) {\n        for (auto& v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n                dp[u] = dp[v] + 1;\n            }\n        }\n    }\n    else {\n        for (auto& v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n                dp[u] ^= dp[v];\n            }\n        }\n    }\n}\n\nint main() {\n    GI(n);\n\n    int u, v;\n\n    adj.resize(n+1);\n\n    FORN(i, n-1) {\n        GI(u);\n        GI(v);\n\n        adj[u].PB(v);\n        adj[v].PB(u);\n    }\n\n    memset(visited, 0, sizeof visited);\n    dfs(1);\n\n//    DEBUG(dp[1]);\n\n    if (dp[1] == 0) {\n        printf(\"Bob\\n\");\n    }\n    else {\n        printf(\"Alice\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nint dp[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      dp[v] += dp[to];\n    }\n  }\n}\nvoid solve() {\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  dfs(1, 1);\n  int res = 0;\n  rep(i, 1, n)\n    res ^= dp[i];\n  if (res) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;}\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;}\n    return false;\n}\n\nconst int MAX_N=1e5+10;\n\nint N,grundy=0;\nvector<vector<int>> G(MAX_N);\nvector<int> dist(MAX_N,0);\n\nvoid dfs(int v,int p){\n    int s=G[v].size();\n    if ((p>=0&&s==1)||s>2){\n        grundy^=dist[v];\n        dist[v]=0;\n    }\n    for (auto nv:G[v]){\n        if (nv==p) continue;\n        dist[nv]=dist[v]+1;\n        dfs(nv,v);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    rep(i,N-1){\n        int x,y; cin >> x >> y; --x,--y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(0,-1);\n    if (grundy!=0) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif (v[0].size() == 1){\n\t\tputs(\"Alice\");\n\t\treturn 0;\n\t}\n\tif (n & 1){\n\t\tputs(\"Bob\");\n\t}\n\telse{\n\t\tputs(\"Alice\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool used[100000];\nint grundy[100000];\n\nvoid dfs(int v){\n    used[v] = true;\n    grundy[v] = 0;\n    for(int i = 0; i < G[v].size(); i++){\n        if(!used[G[v][i]]){\n            dfs(G[v][i]);\n            grundy[v] ^= (grundy[G[v][i]]+1);\n        }\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i = 0; i < N-1; i++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(0);\n    if(grundy[0] != 0){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cctype>\n#include <cstdlib>      // srand,rand\n#include <random>\n#include <functional>\n\nusing namespace std;\n#define ll long long\n#define lp(i,n) for(ll i=0;i<n;i++)\n\n#define modd 1000000007\n#define mod2 998244353\n\n#define INF 8223372036854775807ll\n#define ALL(a)  (a).begin(),(a).end()\n\n\ntypedef pair<long long, long long> pl;\ntypedef pair<double, double> pd;\ntypedef pair<ll, string> pls;\n\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\n\n/*\nclass SegmentTree {\n\n\n\nprivate:\n\n\tll cont_num = 2;\n\tpd initial_v;\n\tvector<pd> dat;\n\n\npublic:\n\n\n\tSegmentTree() {};\n\n\n\tvoid init(ll size, double initial_value_first, double initial_value_second) {\n\n\t\tcont_num = 2;\n\t\tinitial_v.first = initial_value_first;\n\t\tinitial_v.second = initial_value_second;\n\n\t\twhile (cont_num < size) {\n\t\t\tcont_num *= 2;\n\t\t}\n\n\t\tdat.resize(2 * cont_num);//サイズ設定\n\n\t\tfor (int i = 0; i < 2 * cont_num; i++)dat[i] = initial_v;//初期化\n\n\n\n\t}\n\n\n\tvoid Update(ll position, double value_f, double value_s) {\n\n\n\n\t\tll k = cont_num + position;\n\n\t\tdat[k].first = value_f;\n\t\tdat[k].second = value_s;\n\n\t\twhile (k > 1) {\n\t\t\tk /= 2;\n\t\t\tdat[k].first = dat[k * 2 + 1].first * dat[k * 2].first;\n\t\t\tdat[k].second = dat[k * 2 + 1].first * dat[k * 2].second + dat[k * 2 + 1].second;\n\n\n\t\t}\n\n\n\t}\n\n\t/*\n\tll query_proces(ll a, ll b, ll k, ll l, ll r) {\n\n\t\tif (r <= a || b <= l)return initial_v;\n\n\t\tif (a <= l && r <= b)return dat[k];\n\t\telse {\n\t\t\tll vl = query_proces(a, b, k * 2, l, (l + r) / 2);\n\t\t\tll vr = query_proces(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\n\t}\n\n\n\tll query(ll left, ll right) {\n\t\treturn query_proces(left, right, 1, 0, cont_num);\n\t}\n\t*/\n\t/*\n\t\tdouble query() {\n\t\t\treturn dat[1].first + dat[1].second;\n\t\t}\n\n\t};*/\n\n\ntemplate <typename T>\nclass Zip {\n\tvector<T> d;\n\tbool flag;\n\tvoid init() {\n\t\tsort(d.begin(), d.end());\n\t\td.erase(unique(d.begin(), d.end()), d.end());\n\t\tflag = false;\n\t}\npublic:\n\tZip() {\n\t\tflag = false;\n\t}\n\tvoid add(T x) {\n\t\td.push_back(x);\n\t\tflag = true;\n\t}\n\tll getNum(T x) {\n\t\tif (flag) init();\n\t\treturn lower_bound(d.begin(), d.end(), x) - d.begin();\n\t}\n\tll size() {\n\t\tif (flag) init();\n\t\treturn (ll)d.size();\n\t}\n};\n\n\nll N, M, K, a, b, c, d, e, H, W, L, T;\nll x, y, z;\nll A[2000004] = {};\nll B[2000004] = {};\nll C[2000004] = {};\nll D[1000006] = {};\nll E[1000006] = {};\nbool f;\nstring S[200000];\nstring SS;\nset <long long>sll;\npl bufpl;\nvector <long long>vl[200005];\nvector <long long>vll;\nvector <long long>v;\nvector <pl>vpl;\nvector <string> vs;\nset<ll> llset;\nset<string> Sset;\nmultiset<ll> llmset;\nqueue<ll> ql;\nmultiset<pl> plmset;\n\n\ntypedef struct ST\n{\n\tll first;\n\tll second;\n\tll cost;\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn cost < another.cost;//比較\n\t};\n\n\tbool operator>(const ST& another) const\n\t{\n\t\treturn cost > another.cost;//比較\n\t};\n\n}ST;\n//queue<ST> qst;\npriority_queue<ST, vector<ST>, greater<ST> > qst;\n\n\n\n/*vector <ST> vst;\nST st[200005];\nST bufst;\nbitset<5000> bits;*/\n\n\nlong long modinv(long long aa, long long mm) {\n\tlong long bb = mm, uu = 1, vv = 0;\n\twhile (bb) {\n\t\tlong long tt = aa / bb;\n\t\taa -= tt * bb; swap(aa, bb);\n\t\tuu -= tt * vv; swap(uu, vv);\n\t}\n\tuu %= mm;\n\tif (uu < 0) uu += mm;\n\treturn uu;\n}\n\n\n\n\n\nll zettai(ll aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\nfloat zettai(float aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\n\n/*\nclass UnionFind\n{\n\npublic:\n\n\n\tvector <ll>pairent;\n\tvector <ll>depth;\n\tvector <ll>size;\n\n\n\tUnionFind(ll Amount) : pairent(Amount, 1), depth(Amount, 1), size(Amount, 1) {\n\n\t\tfor (ll i = 0; i < Amount; i++) {\n\t\t\tpairent[i] = i;\n\t\t}\n\n\n\t}\n\n\n\tll FindPairent(ll x) {\n\t\tif (pairent[x] == x)return x;\n\t\telse return pairent[x] = FindPairent(pairent[x]);\n\n\t}\n\n\n\tll Merge(ll x, ll y) {\n\t\tx = FindPairent(x);\n\t\ty = FindPairent(y);\n\n\t\tif (x != y) {\n\t\t\tif (depth[x] > depth[y]) {\n\t\t\t\tpairent[y] = pairent[x];\n\t\t\t\treturn size[x] += size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpairent[x] = pairent[y];\n\t\t\t\tif (depth[x] == depth[y]) {\n\t\t\t\t\tdepth[y] ++;\n\t\t\t\t}\n\n\t\t\t\treturn size[y] += size[x];\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\n\n\n\t}\n\n\n\n\tbool IsSame(ll x, ll y) {\n\t\tif (FindPairent(x) == FindPairent(y))return true;\n\t\telse return false;\n\t}\n\n\n\tll GetSize(ll x) {\n\t\tx = FindPairent(x);\n\t\treturn size[x];\n\t}\n\n\n};\n*/\n\nclass UnionFind\n{\n\npublic:\n\n\tvector <ll>pairent;\n\tvector <ll>depth;\n\tvector <ll>size;\n\n\tUnionFind(ll Amount) : pairent(Amount, 1), depth(Amount, 1), size(Amount, 1) {\n\n\t\tfor (ll i = 0; i < Amount; i++) {\n\t\t\tpairent[i] = i;\n\t\t}\n\t}\n\n\n\tll FindPairent(ll x) {\n\t\tif (pairent[x] == x)return x;\n\t\telse return pairent[x] = FindPairent(pairent[x]);\n\t}\n\n\n\tll Merge(ll x, ll y) {\n\t\tx = FindPairent(x);\n\t\ty = FindPairent(y);\n\n\t\tif (x != y) {\n\t\t\tif (depth[x] > depth[y]) {\n\t\t\t\tpairent[y] = pairent[x];\n\t\t\t\treturn size[x] += size[y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpairent[x] = pairent[y];\n\t\t\t\tif (depth[x] == depth[y]) {\n\t\t\t\t\tdepth[y] ++;\n\t\t\t\t}\n\t\t\t\treturn size[y] += size[x];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\n\tbool IsSame(ll x, ll y) {\n\t\tif (FindPairent(x) == FindPairent(y))return true;\n\t\telse return false;\n\t}\n\n\n\tll GetSize(ll x) {\n\t\tx = FindPairent(x);\n\t\treturn size[x];\n\t}\n\n\n};\n\nstruct Edge\n{\n\tll a, b, cost;\n\n\n\tbool operator<(const Edge& other) const {\n\t\treturn cost < other.cost;\n\t}\n};\n\nstruct Graph\n{\n\tll n;  // 頂点数\n\tvector<Edge> es;  // 辺集合\n};\n\nclass Kruskal {\n\n\tGraph origin_G;\n\tGraph MST;\n\tll total_cost = 0;\n\npublic:\n\n\tvoid Solve() {\n\t\tUnionFind uf = UnionFind(MST.n);\n\t\tfor (ll i = 0; i < origin_G.es.size(); i++) {\n\t\t\tll a = origin_G.es[i].a;\n\t\t\tll b = origin_G.es[i].b;\n\t\t\tll cost = origin_G.es[i].cost;\n\n\t\t\tif (!uf.IsSame(a, b)) {\n\t\t\t\tuf.Merge(a, b);\n\t\t\t\tMST.es.push_back(origin_G.es[i]);\n\t\t\t\ttotal_cost += cost;\n\t\t\t}\n\t\t}\n\t}\n\n\tKruskal(Graph graph) {\n\t\torigin_G = graph;\n\t\tMST = graph;\n\t\tMST.es.clear();\n\t\tsort(origin_G.es.begin(), origin_G.es.end());\n\t}\n\n\tll GetMinCost() {\n\t\treturn total_cost;\n\t}\n\n};\n\n\nll RepeatSquaring(ll N, ll P, ll M) {\n\tif (P == 0) return 1;\n\tif (P % 2 == 0) {\n\t\tll t = RepeatSquaring(N, P / 2, M) % M;\n\t\treturn t * t % M;\n\t}\n\treturn N * RepeatSquaring(N, P - 1, M) % M;\n}\n\n/*\nll KurikaesiNijou(ll a, ll b, ll P) {\n\n\tif (b == 0)return 1;\n\tif (b % 2 == 0) {\n\t\tll c=KurikaesiNijou(a,b/2,P)%P;\n\t\treturn c * c %P;\n\t}\n\telse {\n\t\tll c = KurikaesiNijou(a, b/2, P) % P;\n\t\treturn a * c * c % P;\n\t}\n\n}*/\n\n\n\n\nll GCD(ll a, ll b) {\n\tif (a % b == 0)return b;\n\telse return GCD(b, a % b);\n}\n\nll Min(ll a, ll b) {\n\tif (a < b)return a;\n\telse return b;\n}\n\nll Max(ll a, ll b) {\n\tif (a > b)return a;\n\telse return b;\n}\n\nll Sum(ll a, ll b) {\n\treturn a + b;\n}\n\ntemplate <typename T>\nclass SegmentTree {\n\tll n;\n\tvector<T> node;\n\tfunction<T(T, T)> fun, fun2;\n\tbool customChange;\n\tT outValue, initValue;\npublic:\n\tvoid init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n\t\t// changeFunction: (input, beforevalue) => newvalue\n\t\tfun = resultFunction;\n\t\tfun2 = changeFunction;\n\t\tcustomChange = changeFunction != NULL;\n\t\tn = 1;\n\t\twhile (n < num) n *= 2;\n\t\tnode.resize(2 * n - 1);\n\t\tfill(node.begin(), node.end(), init);\n\t\toutValue = out;\n\t\tinitValue = init;\n\t}\n\tvoid valueChange(ll num, T value) {\n\t\tnum += n - 1;\n\t\tif (customChange) node[num] = fun2(value, node[num]);\n\t\telse node[num] = value;\n\t\twhile (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n\t}\n\tT rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n\t\tif (r == -1) r = n;\n\t\tif (a <= l && r <= b) return node[k];\n\t\tif (b <= l || r <= a) return outValue;\n\t\tll mid = (l + r) / 2;\n\t\treturn fun(rangeQuery(a, b, l, mid, 2 * k + 1), rangeQuery(a, b, mid, r, 2 * k + 2));\n\t}\n};\n\n\n\n\nclass Combination {\n\n\tvector<ll> factorial;\n\tvector<ll> factorial_inv;\n\tll mod;\n\tll max_n;\n\n\npublic:\n\tvoid Init(ll init_max_n, ll init_mod) {\n\t\tmax_n = init_max_n;\n\t\tmod = init_mod;\n\t\tfactorial.resize(max_n + 1);\n\t\tfactorial[0] = 1;\n\t\tfor (ll i = 1; i < factorial.size(); i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * i;\n\t\t\tfactorial[i] %= mod;\n\t\t}\n\n\t\tfactorial_inv.resize(max_n + 1);\n\t\tfactorial_inv[0] = 1;\n\t\tfor (ll i = 1; i < factorial_inv.size(); i++) {\n\t\t\tfactorial_inv[i] = factorial_inv[i - 1] * modinv(i, mod);\n\t\t\tfactorial_inv[i] %= mod;\n\t\t}\n\t}\n\n\n\n\tll GetComb(ll n, ll k) {\n\t\tll comb = factorial[n];\n\t\tcomb *= factorial_inv[k];\n\t\tcomb %= mod;\n\t\tcomb *= factorial_inv[n - k];\n\t\tcomb %= mod;\n\t\treturn comb;\n\t}\n\n\tll GetH(ll n, ll k) {//n+k-1<=max_N\n\t\tll comb = factorial[n + k - 1];\n\t\tcomb *= factorial_inv[n];\n\t\tcomb %= mod;\n\t\tcomb *= factorial_inv[k - 1];\n\t\tcomb %= mod;\n\t\treturn comb;\n\t}\n\n};\n\n\n\nclass Tree {\n\n\tll node_N;\n\tvector<ll> node;\n\tvector<vector<pl>> pass;\n\tll diameter = -1;\n\tvector<ll> dist_Diamieter[2];\n\n\tpl maxDist_Num;\n\npublic:\n\n\n\tvoid Init(ll node_Num) {\n\t\tnode_N = node_Num;\n\t\tnode.resize(node_N + 1);\n\t\tpass.resize(node_N + 1);\n\n\t\tdist_Diamieter[0].resize(node_N + 1);\n\t\tlp(i, node_N + 1)dist_Diamieter[0][i] = -1;\n\t\tdist_Diamieter[1].resize(node_N + 1);\n\t\tlp(i, node_N + 1)dist_Diamieter[1][i] = -1;\n\t}\n\n\tvoid AddEdge(ll a, ll b, ll dist) {\n\t\tbufpl.first = b;\n\t\tbufpl.second = dist;\n\t\tpass[a].push_back(bufpl);\n\t\tbufpl.first = a;\n\t\tpass[b].push_back(bufpl);\n\t}\n\n\n\tvoid DFS(ll step, ll now, ll dist) {\n\n\t\tdist_Diamieter[step][now] = dist;\n\t\tif (dist_Diamieter[step][now] > maxDist_Num.first) {\n\t\t\tmaxDist_Num.first = dist_Diamieter[step][now];\n\t\t\tmaxDist_Num.second = now;\n\t\t}\n\n\t\tfor (ll i = 0; i < pass[now].size(); i++) {\n\t\t\tll next_node = pass[now][i].first;\n\t\t\tif (dist_Diamieter[step][next_node] == -1) {\n\t\t\t\tDFS(step, next_node, dist + pass[now][i].second);\n\t\t\t}\n\t\t}\n\t}\n\n\tll GetDiameter(ll min_node_num) {\n\t\tif (diameter >= 0)return diameter;\n\t\telse {\n\t\t\tmaxDist_Num.first = -1;\n\t\t\tmaxDist_Num.second = -1;\n\t\t\tDFS(0, min_node_num, 0ll);\n\t\t\tll step2_start = maxDist_Num.second;\n\n\t\t\tmaxDist_Num.first = -1;\n\t\t\tmaxDist_Num.second = -1;\n\t\t\tDFS(1, step2_start, 0ll);\n\n\t\t\tdiameter = maxDist_Num.first;\n\t\t\treturn diameter;\n\t\t}\n\t}\n\n\tll GetDistFromMinNode(ll num) {\n\t\treturn dist_Diamieter[0][num];\n\t}\n\n};\n\n\nvoid Nibu(ll node, ll co) {\n\n\tC[node] = co % 2;\n\tD[co % 2]++;\n\n\tlp(i, vl[node].size()) {\n\t\tll next = vl[node][i];\n\t\tif (C[next] == -1) {\n\t\t\tNibu(next, co + 1);\n\t\t}\n\t}\n\n}\n\nST bufst;\nmultiset<ST> stmset;\nvector<pl> vpll[10004];\n\nSegmentTree<ll> st;\n\nll grundy[100005] = {};\n\nll grund(ll n) {\n\tgrundy[n] = 1;\n\tll aa = 0;\n\n\n\n\tlp(i, vl[n].size()) {\n\t\tif (grundy[vl[n][i]] != 1)aa = aa xor grund(vl[n][i]);\n\t}\n\n\tif (n != 1) {\n\t\tif (vl[n].size() == 2)aa++;\n\t}\n\t\n\n\treturn aa;\n\n}\n\nint main() {\n\n\t/*cin >> N >> M;\n\n\tlp(i, M) {\n\t\tcin >> a >> b >> c;\n\t\tbufpl.first = b;\n\t\tbufpl.second = c;\n\t\tvpll[a].push_back(bufpl);\n\t}\n\n\tlp(i, N)A[i] = INF;\n\n\tbufst.first = 0;\n\tbufst.second = 0;\n\tbufst.cost = 0;\n\tstmset.insert(bufst);\n\tA[0] = 0;\n\n\twhile (!stmset.empty()) {\n\n\t\tauto itr = stmset.begin();\n\t\ta = itr->first;\n\t\tb = itr->second;\n\t\tc = itr->cost;\n\n\t\tif (c != A[a]) {\n\t\t\tstmset.erase(itr);\n\t\t\tcontinue;\n\t\t}\n\n\n\t}\n\n\n\tlp(i, N)cout << A[i] << endl;\n\t*/\n\n\tcin >> N;\n\tlp(i, N-1) {\n\t\tcin >> a >> b;\n\t\tvl[a].push_back(b);\n\t\tvl[b].push_back(a);\n\t\t\n\t}\n\tlp(i, N + 1)grundy[i] = -1;\n\tb=grund(1);\n\t\n\n\tif (b == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\n\n\t//cout << fixed << setprecision(12) << bb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n long long n;\n  cin >> n;\n  if(n%2) cout << \"Bob\\n\";\n  else cout << \"Alice\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    Graph<> graph(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y;\n        std::cin >> x >> y;\n        --x, --y;\n        graph.span(x, y);\n        graph.span(y, x);\n    }\n\n    std::function<int(int, int)> dfs = [&](int v, int r) {\n        int ret = 0;\n        for (auto e : graph[v]) {\n            if (e.to == r) continue;\n            ret ^= (dfs(e.to, v) + 1);\n        }\n        return ret;\n    };\n\n    std::cout << (dfs(0, -1) > 0 ? \"Alice\" : \"Bob\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 2e5 + 50;\n\nint head[N], nxt[N], ver[N], cnt, n, SG[N];\n\ninline void add(int u, int v)\n{\n\tnxt[++cnt] = head[u], ver[cnt] = v, head[u] = cnt;\n}\n\ninline void solve(int x, int fa = -1)\n{\n\tfor (int i = head[x]; i; i = nxt[i])\n\t{\n\t\tint y = ver[i];\n\t\tif (y != fa)\n\t\t{\n\t\t\tsolve(y, x);\n\t\t\tSG[x] ^= SG[y] + 1;\n\t\t}\n\t}\n}\n\ninline char nc()\n{\n\tstatic char buf[1000000], *p1 = buf, *p2 = buf;\n\treturn p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;\n}\n\ninline int read()\n{\n\tint res = 0;\n\tchar ch;\n\tdo ch = nc(); while (ch < 48 || ch > 57);\n\tdo res = res * 10 + ch - 48, ch = nc(); while (ch >= 48 && ch <= 57);\n\treturn res;\n}\n\nint main()\n{\n\tn = read();\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd(x, y), add(y, x);\n\t}\n\tsolve(1);\n\tputs(SG[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint to,next;\n}e[N*2];\nint head[N],f[N];\nint n,tot;\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nvoid dfs(int x,int fa){\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (fa!=e[i].to){\n\t\t\tdfs(e[i].to,x);\n\t\t\tf[x]^=f[e[i].to]+1;\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,x,y,cnt;\nint main() {\n\tscanf(\"%d\",&n);\n\tcnt=0;\n\tfor (int i=1;i<n;i++) {\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tif (x==1||y==1)\n\t\t\tcnt++;\n\t}\n\tif (cnt%2==1)\n\t\tprintf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//%std\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define lovelive long long\n#define lc son[x][0]\n#define rc son[x][1]\n#define lowbit(x) (x&(-x))\n#define pt vc\nconst int N=1e5+100; \nvoid read(int &x)\n{\n  int p=1;\n  x=0;\n  char c=getchar();\n  while(c<'0'||c>'9')\n  {\n    if(c=='-')\n      p=-1;\n    c=getchar();\n  }\n  while(c>='0'&&c<='9')\n  {\n  \tx=x*10+c-48;\n  \tc=getchar();\n  }\n  x*=p;\n}\nint fir[N],nxt[N<<1],to[N<<1],tot;\nvoid add_edge(int x,int y)\n{\n  nxt[++tot]=fir[x];\n  fir[x]=tot;\n  to[tot]=y;\n} \nint sg[N];\nvoid dfs(int i,int f)\n{\n  for(int j=fir[i];j;j=nxt[j])\n    if(to[j]!=f)\n      dfs(to[j],i),sg[i]^=(sg[to[j]]+1);  \n} \nint main()\n{\n  int n,x,y;\n  read(n);\n  for(int i=1;i<n;i++)\n  {\n    read(x);read(y);\n    add_edge(x,y);\n    add_edge(y,x);\n  }\n  dfs(1,0);\n  if(sg[1])\n    puts(\"Alice\");\n  else\n    puts(\"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int N;\n    cin >> N;\n    int c = 0;\n    for(int i = 0; i < (N-1); i++){\n        int a,b;\n        cin >> a >> b;\n        if(a==1){\n            c++;\n        }\n        if(b==1){\n            c++;\n        }\n    }\n    if(N%2==c%2){\n        cout << \"Alice\" << \"\\n\";\n    }else{\n        cout << \"Bob\" << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pll pair<ll,ll>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pii pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eps 1e-12\n#define MAXN 200009\nusing namespace std;\nvector<int> g[MAXN];\nint val[MAXN];\ninline void dfs(int pos,int prev)\n{\n\tfor(int i=0;i<g[pos].size();i++)\n\t{\n\t\tif(g[pos][i]!=prev)\n\t\t{\n\t\t\tdfs(g[pos][i],pos);\n\t\t}\n\t}\n\tint nval=0;\n\tfor(int i=0;i<g[pos].size();i++)\n\t{\n\t\tif(g[pos][i]!=prev)\n\t\t{\n\t\t\tnval=nval^(val[g[pos][i]]+1);\n\t\t}\n\t}\n\tval[pos]=nval;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tdfs(1,0);\n\tif(g[1].size()==1)\n\t{\n\t\tcout<<\"Alice\\n\";\n\t}\n\telse\n\t{\n\t\tif(val[1])\n\t\t{\n\t\t\tcout<<\"Alice\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<\"Bob\\n\";\n\t\t}\n\t}\n\t// for(int i=1;i<=n;i++)\n\t// {\n\t// \tcout<<val[i]<<\"\\n\";\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],e;\nvoid AddEdge(int u,int v) {\n\tto[++e]=v;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;nxt[e]=first[v];first[v]=e;\n}\nint dfs(int x,int fa) {\n\tint res=0;\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa) res^=dfs(to[i],x)+1;\n\treturn res;\n}\nint main() {\n\tn=read();\n\trep(i,2,n) AddEdge(read(),read());\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)ull\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\n\nint dfs(int v, int p=-1) {\n  int res = 0;\n  rep(i,sz(to[v])) {\n    int u = to[v][i];\n    if (u == p) continue;\n    int r = dfs(u,v);\n    res ^= r;\n  }\n  return res+!!v;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  int g = dfs(0);\n  string ans = g?\"Alice\":\"Bob\";\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\nvector<int> G[100010];\nint childs[100010]={0}, par[100010];\n\nint grundy(int i=0) {\n    int ans = 0;\n    for (auto g:G[i]) {\n        if (childs[g]) continue;\n        childs[i]++;\n        par[g] = i;\n        if (i > 0) ans += grundy(g);\n        else ans ^= grundy(g);\n    }\n    if (i > 0) {\n        if (child[i] > 1) ans = 0;\n        ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i=1, x, y; i<n; i++) {\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (grundy() ? \"Alice\" : \"Bob\") << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,f[100005];\nvector<int> g[100005];\n\nvoid DFS(int u,int root)\n{\n    bool Free[105];\n    for(int i=0;i<g[u].size();i++)\n        if(g[u][i]!=root)\n        {\n            DFS(g[u][i],u);\n            Free[f[g[u][i]]]=true;\n        }\n    for(int i=0;i<=g[u].size();i++)\n        if(Free[i]==false)\n        {\n            f[u]=i;\n            return;\n        }\n}\n\nint main()\n{\n    cin>>n;\n    int u,v;\n    for(int i=1;i<n;i++)\n    {\n        cin>>u>>v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int res=0;\n    for(int i=0;i<g[1].size();i++)\n    {\n        DFS(g[1][i],1);\n        res^=f[g[1][i]];\n    }\n    if(res>0)\n        cout<<\"Alice\";\n    else\n        cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, sg[MAXN];\n\nstruct Edge {\n\tint v, nxt;\n}e[MAXN<<1];\nint first[MAXN], eCnt;\n\ninline void AddEdge(int u, int v) {\n\te[++eCnt].v = v;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\nvoid DFS(int u, int fa) {\n\tfor (int i=first[u];i;i=e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif (v == fa) continue;\n\t\tDFS(v, u);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i=1,u,v;i<n;++i) {\n\t\tread(u); read(v);\n\t\tAddEdge(u, v);\n\t\tAddEdge(v, u);\n\t}\n}\n\nvoid solve() {\n\tDFS(1, 0);\n\tputs(sg[1]? \"Alice\" : \"Bob\");\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\")\n%:pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\n#define fo(i, n) for(int i = 1; i <= (n); i ++)\n#define out(x) cout << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\ntemplate<typename tp> inline void arr(tp *a, int n) {\n  for(int i = 1; i <= n; i ++)\n    cout << a[i] << \" \";\n  puts(\"\");\n}\nconst int N = 3e5 + 233;\nint n;\nvector<int> g[N];\n\ninline int dfs(int u, int fat, int fff) {\n  if(u != 1 && g[u].size() == 1) \n    return fff ^ 1;\n  int t = 0;\n  for(auto v: g[u]) if(v != fat) t ^= dfs(v, u, fff ^ 1);\n  return t;\n}\n\nmain(void) {\n  read(n);\n  for(int i = 1; i <= n - 1; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  cout << (dfs(1, 0, 0) ? \"Alice\" : \"Bob\") << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b)  for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n#define ll long long\n\nusing namespace std;\n\nint rez[100100];\nvector <int> child[100100];\nint par[100100];\n\nvoid dfs(int x) {\n  int out = -1;\n  REP(i, child[x].size()) {\n    int ne = child[x][i];\n    if (ne == par[x]) continue;\n    par[ne] = x;\n    dfs(ne);\n    out *= rez[ne];\n  }\n  if (child[x].size() == 2 && x != 0) out = 1;\n  rez[x] = out;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    child[x].push_back(y);\n    child[y].push_back(x);\n  }\n  par[0] = -1;\n  dfs(0);\n  if (child[0].size() == 1) {\n    cout << \"Alice\\n\";\n    return 0;\n  }\n  if (rez[0] == 1) cout << \"Alice\\n\";\n  else             cout << \"Bob\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 100000;\nvector<int> adj[N];\n\nint dfs(int u, int p = -1) {\n\tint ret = 0;\n\tfor (auto &x : adj[u]) {\n\t\tif (x == p)continue;\n\t\tint g = dfs(x, u);\n\t\tret ^= g + 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; ni(n);\n\tF(i, n - 1) {\n\t\tint u, v; nii(u, v);\n\t\tu--; v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint x = dfs(0);\n\tif (x)puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nusing Graph = vector< vector<int> >;\n\nint dfs(Graph &G, int cur, int par=-1) {\n    int grundy = 0;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        grundy ^= dfs(G, to, cur) + 1;\n    }\n    return grundy;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    Graph G(N);\n    for(int i=0; i<N-1; i++) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    printf(\"%s\\n\", dfs(G, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by OIerC\n//Forca Barcelona!\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\ninline int read()\n{\n \tint x = 0, f = 1; char ch = getchar();\n\tfor (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n\treturn x * f;\n}\n\nconst int N = 2e5 + 5;\nvector<int> G[N];\nint SG[N];\n\nvoid dfs(int u, int fa)\n{\n\tSG[u] = 0;\n\tfor (int v : G[u]) if (v != fa)\n\t\tdfs(v, u), SG[u] ^= (SG[v] + 1);\n}\n\nint main()\n{\n\tint n = read();\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = read();\n\t\tint v = read();\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tdfs(1, 0);\n\t\n\tputs(SG[1] ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\n    public:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> parent;\n\n    //-1で初期化。最初はすべてバラバラ\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n    }\n\n    //Aがどのグループに属しているか(Aの根)を調べる\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A){\n        return -parent[root(A)];\n    }\n\n    //AとBをくっつける\n    bool unite(int A, int B) {\n    //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        //既にくっついているからくっつけない\n        if(A == B) return false; \n\n        //大きいほう(A)に小さいほう(B)をくっつける\n        //大小が逆ならひっくり返す\n        if(size(A) < size(B)) swap(A,B);\n\n        //Aのサイズを更新する\n        parent[A] += parent[B];\n        //Bの親をAに変更する\n        parent[B] = A;\n\n        return true;\n    }\n\n    //AとBが同じグループならtrueを返す\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n\nvector<vector<int>> v(100010);\nbool used[100010];\n\nint dfs(int p){\n    used[p] = true;\n    int x = 0;\n    for(auto i:v[p]){\n        if(!used[i]){\n            x ^= dfs(i) + 1;\n        }\n    }\n    return x;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n \n    int n;\n    cin>>n;\n    UnionFind uni(n);\n    for(int i=1;i<n;i++){\n        int a,b; cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n        uni.unite(a,b);\n    }\n    ll ans = dfs(0);\n    cerr << ans << endl;\n    for(int i=1;i<n;i++){\n        if(i==uni.root(i)){\n            ans ^= 1;\n        }\n    }\n    cerr << ans << endl;\n    if(ans){\n        cout << \"Alice\" << endl;\n    }\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n    int n;\n    int sum=0;\n    int x,y;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        if(x==1)\n        {\n            sum++;\n        }\n    }\n    if(sum%2) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <stack>\n\nusing namespace std;\n\n#ifdef ZTDebug\n#define In scanf_s\n#else\n#define In scanf\n#endif // ZTDebug\n\n#define Ind(d) In(\"%d\", &d)\n#define Ind2(a, b) In(\"%d%d\", &a, &b)\n#define InD(d) int d; In(\"%d\", &d);\n#define InD2(a, b) int a, b; In(\"%d%d\", &a, &b);\n#define InDN(n, v) for (auto _i = 0; _i < n; ++_i) In(\"%d\", &v[_i]);\n#define OutDNLine(n, v) for (auto _i = 0; _i < n; ++_i) printf(\"%d%c\", *(v + _i), _i + 1 == n ? '\\n' : ' ');\n\ntypedef double db;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int Max = 100010;\n\nvector<int> edges[Max];\nint res[Max];\n\nint dfs(int x, int f) {\n    auto r = 0;\n    for (auto y : edges[x]) if (y != f) r ^= dfs(y, x) + 1;\n    return r;\n}\n\nint main() {\n#ifdef ZTDebug\n    while (true) {\n        for (auto i = 0; i < Max; ++i) edges[i].clear();\n#endif // ZTDebug\n        int n;\n        cin >> n;\n        for (auto i = 1; i < n; ++i) {\n            InD2(x, y);\n            edges[x].push_back(y);\n            edges[y].push_back(x);\n        }\n        cout << (dfs(1, -1) > 0 ? \"Alice\" : \"Bob\") << endl;\n#ifdef ZTDebug\n    }\n#endif // ZTDebug\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, Grundy[N];\nvi G[N];\n\nvoid DFS(int v, int p = 0){\n\tfor (auto u:G[v]){\n\t\tif (u == p) continue;\n\t\tDFS(u, v);\n\t\tGrundy[v] ^= (1 + Grundy[u]);\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++){\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tG[v].pb(u), G[u].pb(v);\n\t}\n\tDFS(1);\n\tcout << (Grundy[1] == 0?\"Bob\":\"Alice\");\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 100000;\n\nint n;\nvector<int> adj[MaxN + 1];\n\nint dfs(int u, int fa)\n{\n\tint w = 0;\n\tfor (int v : adj[u])\n\t\tif (v != fa)\n\t\t\tw ^= dfs(v, u) + 1;\n\treturn w;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = getint(), v = getint();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tcout << (dfs(1, 0) ? \"Alice\" : \"Bob\");\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100010\nvector<int>d[N];\nbool b[N];\nint sg[N];\nvoid dfs(int x){\n\tb[x]=1;\n\tfor (int i=0;i<d[x].size();i++)\n\t\tif (!b[d[x][i]]){\n\t\t\tdfs(d[x][i]);\n\t\t\tsg[x]^=sg[d[x][i]]+1;\n\t\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\td[x].push_back(y);\n\t\td[y].push_back(x);\n\t}\n\tdfs(1);\n\tif (sg[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n\nusing namespace std;\n\nint main(){\n\n    int N;\n    cin>>N;\n    int cnt=0;\n    REP(i,N-1){\n        int x,y;\n        cin>>x>>y;\n        if(x==1||y==1){\n            cnt++;\n        }\n    }\n\n    if(cnt%2==1){\n        cout<<\"Alice\"<<endl;\n    }else{\n        if((N-1)%2==1){\n            cout<<\"Alice\"<<endl;\n        }else{\n            cout<<\"Bob\"<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <iterator>\n#include <functional>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <stdio.h>\n#include <unordered_set>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LD, LD> PDD;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VCH;\ntypedef vector<LD> VLD;\ntypedef vector<string> VS;\ntypedef vector<VS> VSS;\ntypedef vector<VI> VVI;\ntypedef vector<VLL> VVLL;\ntypedef vector<VCH> VVCH;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<PDD> VPDD;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n#define next fake_next\n#define prev fake_prev\n#define left fake_left\n#define right fake_right\n\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LD PI = acos(-1.0);\nconst LL mod = 1000000007;\nconst LL INF = 1e9;\nconst LL LINF = 1e18;\nconst LL MAXN = 100 + 1;\nconst LL MAXS = 100 + 1;\nconst LL MAXT = 100 + 1;\n\nvoid ok()\n{\n\tcout << \"YES\";\n\texit(0);\n}\n\nvoid bad()\n{\n\tcout << \"NO\";\n\texit(0);\n}\n\nint n;\nVVI g;\nVCH used;\nVI grundy;\n\nvoid dfs(int v)\n{\n\tused[v] = 1;\n\tVI h;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\tdfs(i);\n\t\t\th.push_back(grundy[i]);\n\t\t}\n\t\n\tif (SZ(h) > 1)\n\t{\n\t\tgrundy[v] = h[0];\n\t\tFOR(i, 1, SZ(h))\n\t\t\tgrundy[v] ^= h[i];\n\t}\n\telse\n\t{\n\t\tif (SZ(h))\n\t\t\tgrundy[v] = grundy[h[0]] + 1;\n\t\telse\n\t\t\tgrundy[v] = 0;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"In.txt\", \"w\", stdout);\n\n\tcin >> n;\n\tg.resize(n);\n\tint u, v;\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tused.assign(n, 0);\n\tgrundy.assign(n, 0);\n\n\tdfs(0);\n\tif (grundy[0])\n\t\tcout << \"Alice\";\n\telse\n\t\tcout << \"Bob\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N;\nvector<vector<int>> G;\n\nint dfs(int s, int par){\n    int ret = 0;\n    for(int t : G[s]){\n        if(t == par) continue;\n        ret ^= 1+dfs(t, s);\n    }\n    return ret;\n}\n\nint main(){\n    cin >> N;\n    G.resize(N);\n    for(int i=0; i<N-1; i++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (dfs(0, -1)==0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nvector<int> g[N];\n\nint n;\n\nint dfs(int u, int fa) {\n    int res = 0;\n    for(int v: g[u]) {\n        if(v != fa) {\n            res ^= dfs(v, u) + 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1, u, v ; i < n ; ++ i) {\n        scanf(\"%d%d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    puts(dfs(1, 0) ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM], w[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, nr = 0;\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n            dfs(v[nod][i], nod);\n        }\n    }\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n           w[++nr] = s[ v[nod][i] ];\n        }\n    }\n    sort(w + 1, w + nr + 1);\n    if(w[1] == 0){\n        for(i = 2; i <= nr; i++){\n            if(w[i] - w[i - 1] > 1){\n                s[nod] = w[i - 1] + 1;\n                break;\n            }\n        }\n        if(i == nr + 1){\n            s[nod] = w[nr] + 1;\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    for(i = 0; i < v[1].size(); i++){\n        sum ^= s[ v[1][i] ];\n    }\n    if(sum == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint sumE,sg[MAXN],head[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid dfs(int u,int fa) {\n    sg[u] = 0;\n    for(int i = head[u]; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    dfs(v,u);\n\t    sg[u] ^= (sg[v] + 1);\n\t}\n    }\n}\nvoid Solve() {\n    read(N);\n    int x,y;\n    for(int i = 1 ; i < N ; ++i) {\n\tread(x);read(y);\n\tadd(x,y);add(y,x);\n    }\n    dfs(1,0);\n    if(sg[1]) puts(\"Alice\");\n    else puts(\"Bob\");\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 100000 + 5;\n\nint dp[NMAX];\nvector <int> graph[NMAX];\n\nvoid dfs(int node, int father) {\n    for (auto it: graph[node])\n        if (it != father) {\n            dfs(it, node);\n            dp[node] ^= dp[it];\n        }\n    if (father)\n        ++ dp[node];\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 1; i < N; ++ i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    \n    dfs(1, 0);\n    if (dp[1])\n        cout << \"Alice\\n\";\n    else\n        cout << \"Bob\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct Istream {\n\ttemplate <class T> \n\tIstream &operator >>(T &x) {\n\t\tstatic char ch;static bool neg;\n\t\tfor(ch=neg=0;ch<'0' || '9'<ch;neg|=ch=='-',ch=getchar());\n\t\tfor(x=0;'0'<=ch && ch<='9';(x*=10)+=ch-'0',ch=getchar());\n\t\tx=neg?-x:x;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\toperator T() {\n\t\tstatic T x;\n\t\t*this>>x;\n\t\treturn x;\n\t}\n}is;\nstruct Ostream {\n\ttemplate <class T>\n\tOstream &operator <<(T x) {\n\t\tx<0 && (putchar('-'),x=-x);\n\t\tstatic char stack[233];static int top;\n\t\tfor(top=0;x;stack[++top]=x%10+'0',x/=10);\n\t\tfor(top==0 && (stack[top=1]='0');top;putchar(stack[top--]));\n\t\treturn *this;\n\t}\n\tOstream &operator <<(char ch) {\n\t\tputchar(ch);\n\t\treturn *this;\n\t}\n}os;\nconst int MAXN=100000+11;\nstd::vector<int> G[MAXN];\nint fa[MAXN];\nint DFS(int pos) {\n\tint res=0;\n\tfor(int u : G[pos]) if(u!=fa[pos]) {\n\t\tfa[u]=pos;\n\t\tres^=DFS(u)+1;\n\t}\n\treturn res;\n}\nint main() {\n\tint n=is;\n\tfor(int i=1;i<=n-1;++i) {\n\t\tint x=is,y=is;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tstd::cout<<(DFS(1)?\"Alice\":\"Bob\")<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\n\nint dp[N], ans;\nvector <int> es[N];\n\nvoid dfs(const int& u, const int& f, const int& deep) {\n  dp[u] = 1 << deep;\n  for (int i = 0; i < (int)es[u].size(); ++i) {\n    int v = es[u][i];\n    if (v == f)\n      continue;\n    dfs(v, u, deep + 1);\n    dp[u] ^= dp[v];\n  }\n  ans ^= dp[u];\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    es[u].push_back(v);\n    es[v].push_back(u);\n  }\n  ans = 0;\n  for (int i = 0; i < (int)es[1].size(); ++i)\n    dfs(es[1][i], 1, 0);\n  if (ans == 0)\n    printf(\"Bob\\n\");\n  else {\n    for (int i = 2; i <= n; ++i)\n      if (dp[i] == ans) {\n        printf(\"Alice\\n\");\n        return 0;\n      }\n    printf(\"Bob\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2];\nint i,j,k,l,t,n,m,tot;\nvoid add(int x,int y){\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nint dfs(int x,int y){\n    int l=0,t=h[x];\n    while (t){\n        if (go[t]!=y) l^=dfs(go[t],x)+1;\n        t=nxt[t];\n    }\n    return l;\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        add(j,k);add(k,j);\n    }\n    if (dfs(1,0)) printf(\"Alice\\n\");else printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#define N 200011\nusing namespace std;\nstruct apple{\n\tint v,nxt;\n}edge[N*4];\nint indexx[N],n,dp[N],tot;\nvoid addedge(int x,int y){\n\tedge[++tot].v=y;\n\tedge[tot].nxt=indexx[x];\n\tindexx[x]=tot;\n}\nvoid dfs(int u,int fa){\n\tint t=indexx[u],vv;\n\twhile(t){\n\t\tvv=edge[t].v;\n\t\tif(vv!=fa){\n\t\t\tdfs(vv,u);\n\t\t\tdp[u]^=(dp[vv]+1);\n\t\t}\n\t\tt=edge[t].nxt;\n\t}\n}\nint main(){\n\tint x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(1,0);\n\tif(dp[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a),i##formax=(b);i<i##formax;i++)\n#define FORR(i,a,b) for(int i=(a),i##formax=(b);i>=i##formax;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define all(a) (a.begin()),(a.end())\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define perm(c) sort(all(c));for(bool c##p=1;c##p;c##p=next_permutation(all(c)))\n#define bitComb(a,n,k) for(int a##x,a##y,a=(1<<k)-1;a<(1<<n);a##x=a&-a,a##y=a+a##x,a=(((a&~a##y)/a##x)>>1)|a##y)\n#define uniq(v) sort(all(v));v.erase(unique(all(v)), v.end())\n#define bit(n) (1LL<<(n))\n#define randInt(l,r) (uniform_int_distribution<ll>(l,r)(rnd))\n#define randDouble(l,r) (uniform_real_distribution<double>(l,r)(rnd))\n#define dout(d) printf(\"%.12f\\n\",d)\n\ntypedef long long ll;\ntypedef __int128_t lll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T>using V=vector<T>;\ntemplate<class T>using VV=V<V<T>>;\ntemplate<class T,class Y>ostream& operator<<(ostream& o,const pair<T,Y>& p){return o<<\"(\"<<p.fi<<\", \"<<p.se<<\")\";}\ntemplate<typename A,size_t N,typename T>void Fill(A (&array)[N],const T&v){fill((T*)array,(T*)(array+N),v);}\nlll gcd(lll a,lll b,lll &x,lll &y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll gcd(ll a,ll b){lll x=0,y=0;return gcd(a,b,x,y);}\nll modInv(ll a,ll m){lll x,y;gcd(a,m,x,y);return (x%m+m)%m;}\nll modPow(lll a,lll n,ll m){if(!a)return a;lll p=1;for(;n>0;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return(ll)p;}\nbool isPrime(ll n){if(n<2||n%2==0)return n==2;lll t=n-1,d=t/(t&-t);for(lll a:{2,325,9375,28178,450775,9780504,1795265022})if(a%n){for(t=d,a=modPow(a,t,n);t!=n-1&&a!=1&&a!=n-1;a=a*a%n,t=t*2%n);if(a!=n-1&&t%2==0)return 0;}return 1;}\nconst int IINF = 1e9+6;\nconst ll LINF = 1e18;\nconst int MOD = 1e9+7;\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nstatic random_device rd;\nstatic mt19937 rnd(rd());\n\nconst int N = 1e5;\nint n;\nV<int> e[N];\nint dfs(int a, int p){\n  int r = 0;\n  for(int b:e[a]) if(b!=p) r ^= dfs(b, a)+1;\n  return r;\n}\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n;\n  FOR(i, 1, n){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    e[x].pb(y);\n    e[y].pb(x);\n  }\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nint n,G[N];\nvector < int > v[N];\nvoid Dfs(int x,int p) {\n\tint G_=0;\n\tfor (int i=0; i<v[x].size(); i++) \n\t\tif (v[x][i]!=p) {\n\t\t\tDfs(v[x][i],x);\n\t\t\tG_=(G_^(G[v[x][i]]+1));\n\t\t}\n\t\n\tG[x]=G_;\n}\nmain () {\n\tcin>>n;\n\t\n\tfor (int i=1; i<n; i++) {\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\t\n\tDfs(1,1);\n\t\n\tif (G[1]) cout<<\"Alice\\n\";\n\t\telse cout<<\"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c,n;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint dfs(int u,int p)\n{\n\tint ret=0;\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=p)\n\t\t{\n\t\t\tret^=dfs(V[i],u)+1;\n\t\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tint ans=dfs(1,0);\n\tif(ans) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=100005;\nint n,sg[N];\nvector <int> e[N];\nvoid solve(int x,int pre){\n\tint t=1;\n\tfor (auto y : e[x])\n\t\tif (y!=pre){\n\t\t\tsolve(y,x);\n\t\t\tt^=sg[y];\n\t\t}\n\tif (t==1)\n\t\tsg[x]=2;\n\telse\n\t\tsg[x]=1;\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tsolve(1,0);\n\tint t=0;\n\tfor (auto y : e[1])\n\t\tt^=sg[y];\n\tputs(t?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:20000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << nl;\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\n#define Toktama \"\"\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n//typedef tree < pair <int, int>, null_type, less < pair <int, int> >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 1e5 + 7, inf = 1e9 + 7, mod = 1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint get_int() {\n  char x = getchar();\n  bool mns = 0;\n  while (!isdigit(x)) mns |= x == '-', x = getchar();\n  int res = 0;\n  while (isdigit(x)) res = res * 10 + x - '0', x = getchar();\n  if (mns) res = -res;\n  return res;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  if (x < 0) x += mod;\n}\nint mult(int x, int y) {\n  return x * 1ll * y % mod;\n}\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint n;\nll sm;\nint dp[N];\nll dp1[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p) {\n  //dp[v] = 1;\n  int cnt = 0;\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n      dp[v]++;\n      dp1[v]++;\n      dp1[v] += dp1[to];\n      cnt++;\n    }\n  }\n  if (cnt > 1) sm += dp1[v];\n}\nvoid solve() {\n  //freopen (\"a10.txt\", \"r\", stdin);\n  n = get_int();\n  rep(i, 2, n) {\n    int v = get_int(), u = get_int();\n    g[v].pb(u);\n    g[u].pb(v);\n  }\n  if (sz(g[1]) == 1) cout << \"Alice\", ioi\n  dfs(1, 1);\n  if (sm % 2) cout << \"Alice\";\n  else cout << \"Bob\";\n}\nint main() {\n  #ifndef Toktama\n    freopen (Toktama\".in\", \"r\", stdin);\n    freopen (Toktama\".out\", \"w\", stdout);\n  #endif\n  Kazakhstan\n  int t = 1;\n  while (t--)\n    solve();\n  ioi\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2000000000;//10^9\nll MOD  = 998244353;\nvector<vector<int>> edge(100010, vector<int>(0));\nvector<int> parent(100010, -1);\nvector<bool> vis(100010, 0);\nvector<int> child[100010];\n\nvoid makeParent(int N){\n    vis.at(N) = 1;\n    for(int i = 0; i < edge.at(N).size(); i++){\n        if(vis.at(edge.at(N).at(i)) == 0){\n            parent.at(edge.at(N).at(i)) = N;\n            makeParent(edge.at(N).at(i));\n            child[N].push_back(edge.at(N).at(i));\n        }\n    }\n}\nvector<int> memo(100010, -1);\n\nint grundy(int x){\n    if(memo.at(x) != -1) return memo.at(x);\n    if(child[x].size() == 0)return 0;\n    int XOR = grundy(child[x][0]) + 1;\n    for(int i = 1; i < child[x].size(); i++){\n        XOR ^= grundy(child[x][i]) + 1;\n    }\n    return memo.at(x) = XOR;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N-1; i++){\n        int x,y;\n        cin >> x >> y;\n        x--,y--;\n        edge.at(x).push_back(y);\n        edge.at(y).push_back(x);\n    }\n    \n    makeParent(0);\n    \n    if(grundy(0)){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 200050;\n\nint head[N], to[N], nex[N], tot, sg[N], n;\nvoid addedge(int u, int v){\n\ttot ++; to[tot] = v, nex[tot] = head[u], head[u] = tot;\n\ttot ++; to[tot] = u, nex[tot] = head[v], head[v] = tot;\n}\nvoid dfs(int x, int fa){\n\tfor(int i = head[x]; i; i = nex[i]){\n\t\tif(to[i] != fa){\n\t\t\tdfs(to[i], x);\n\t\t\tsg[x] ^= sg[to[i]] + 1;\n\t\t}\n\t}\n}\ninline void gi(int &x){\n\tx = 0; char c = getchar();\n\twhile(c < '0' || c > '9')c = getchar();\n\twhile(c >= '0' && c <= '9'){\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n}\n\nint main()\n{\n\tint i, j, k;\n\tfor(gi(n), i = 1; i < n; i ++)\n\t\tgi(j), gi(k), addedge(j, k);\n\tdfs(1, 0); puts(sg[1] ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pp pair<int,int>\n#define MZ 1000000007\n#define Pi acos(-1)\n#define pq priority_queue\n\nusing namespace std;\n\nstruct Node\n{\n    int n1,n2;\n    int f,du;\n}num[100005];\nbool life[100005];\nvector <int> v1[100005];\nint root[100005];\nqueue <int> q;\n\nvoid dfs(int x)\n{\n    life[x]=1;\n    bool wtf=0;\n    for(int i=0;i<v1[x].size();i++)\n    {\n        if(!life[v1[x][i]])\n        {\n            wtf=1;\n            num[x].du++;\n            root[v1[x][i]]=x;\n            dfs(v1[x][i]);\n        }\n    }\n    if(!wtf)\n        q.push(x);\n}\n\nint main()\n{\n    int n,temp;\n    int x,y;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v1[x].push_back(y);\n        v1[y].push_back(x);\n    }\n    dfs(1);\n    while(!q.empty())\n    {\n        temp=q.front();\n        q.pop();\n        if(num[temp].n2)\n        {\n            if(num[temp].n2%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        else\n        {\n            if(num[temp].n1%2)\n                num[temp].f=-1;\n            else\n                num[temp].f=1;\n        }\n        if(root[temp])\n        {\n            if(num[temp].f==1)\n                num[root[temp]].n1++;\n            else\n                num[root[temp]].n2++;\n            num[root[temp]].du--;\n            if(num[root[temp]].du==0)\n                q.push(root[temp]);\n        }\n    }\n    if(num[1].n2%2 || (num[1].n2==0 && num[1].n1%2))\n        printf(\"Alice\\n\");\n    else\n        printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct tree{\n    size_t n,r,md;\n    vector<vector<int>> e;\n    vector<int> pa,d;\n    explicit tree(int n_){\n        n=n_;\n        e.resize(n);\n    }\n    void add(int a,int b){\n        e[a].emplace_back(b);\n        e[b].emplace_back(a);\n    }\n    int r_dfs(int i,vector<int>&X,int p=-1,int D=0){\n        pa[i]=p;d[i]=D;md=max(md,(size_t)D);++D;\n        for(auto j:e[i]) if(j!=p) X[i]^=r_dfs(j,X,i,D);\n        return X[i]+1;\n    }\n    int r_i(int r_,vector<int>&X){\n        pa.resize(n);d.resize(n);r=r_;md=0;\n        return r_dfs(r,X);\n    }\n};\n\nclass DGameOnTree {\npublic:\n    void solve(istream& in, ostream& out) {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        int n,x,y;\n        in>>n;\n        tree t(n);\n        fr(i,n-1){\n            in>>x>>y;\n            --x,--y;\n            t.add(x,y);\n        }\n        vector<int> X(n);\n        t.r_i(0,X);\n        out<<(X[0]?\"Alice\":\"Bob\")<<endl;\n    }\n};\n\nint main() {\n    DGameOnTree solver;\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 555555;\nVi e[N];int n,f[N];\nvoid dfs(int u, int fa){\n\tper(i,SZ(e[u])-1,0)\n\t\tif(e[u][i]!=fa)dfs(e[u][i],u),f[i]^=f[e[u][i]]+1;\n}\nint main() {\n\tread(n);rep(i,2,n){int u,v;read(u);read(v);e[u].pb(v);e[v].pb(u);}\n\tdfs(1,0);if(f[1])puts(\"Alice\");else puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> ed[100001];\n\nint dfs(int node,int p){\n\n\nint ans=0;\n\n\nint i;\nfor(i=0;i<ed[node].size();i++){\n\n    int x=ed[node][i];\n    if(x==p)\n        continue;\n    int u=1+dfs(x,node);\n    ans=ans^u;\n\n\n\n}\n\nreturn ans;\n\n\n\n}\n\n\nint main(){\nint n;\ncin>>n;\nint i;\nfor(i=1;i<n;i++)\n{\n\n    int x,y;\n    cin>>x>>y;\n    ed[x].push_back(y);\n    ed[y].push_back(x);\n\n\n\n}\n\nint g=dfs(1,0);\n\nif(g)\n    cout<<\"Alice\"<<endl;\nelse\n    cout<<\"Bob\"<<endl;\n\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <list>\n#include <map>\n#include <queue>\n#include <iterator>\n#include <iomanip>\n#include <stdio.h>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define ld long double\n#define infinity (ll)1e18+1\n#define PI 3.14159265358979\n\n#define pdd pair<ld,ld>\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n\n#define MP make_pair\n#define SZ size()\n#define PB push_back\n\n#define vi vector<int>//ll\n#define vll vector<ll>\n#define vpll vector<pll>\n#define vpii vector<pii>\n#define vch vector<char>\n#define vb vector<bool>\n#define vld vector<ld>\n\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(ll i = (b) - 1; i >= (a); --i)\n#define REPEAT(i) FOR(counter1234,0,i)\n#define ALL(a) a.begin(), a.end()\n#define X first\n#define Y second\n#define MAXN 100001\nclock_t startTime;\n\nint n;\nvi g[MAXN];\n\nvi sons;\nint c = 0;\nvch used;\nvoid dfs(int v)\n{\n\tint s = c;\n\tused[v] = 1;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t\tdfs(i), c++;\n\tsons[v] = c - s;\n}\nint d[MAXN];\n\nvoid bfs()\n{\n\td[1] = 0;\n\tused.assign(n + 1, 0);\n\tused[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor(auto i: g[t])\n\t\t\tif (used[i] == 0)\n\t\t\t{\n\t\t\t\tused[i] = 1;\n\t\t\t\td[i] = d[t] + 1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tstartTime = clock();\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\t//ifstream in(\"In.txt\");\n\n\tcin >> n;\n\tint a, b;\n\tsons.assign(n + 1, 0);\n\tused.assign(n + 1, 0);\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll XOR_ALL = 0;\n\tdfs(1);\n\tbfs();\n\n\tvi xors;\n\txors.assign(n + 1, 0);\n\n\tFOR(i, 1, n + 1)\n\t\tfor (auto s : g[i])\n\t\t\tif (d[s] > d[i])\n\t\t\t\txors[i] ^= (sons[s] + 1);\n\t\n\n\tif (xors[1] == 0)\n\t{\n\t\tcout << \"Bob\";\n\t\treturn 0;\n\t}\n\tint cou = 0;\n\tfor (auto s : g[1])\n\t\tif (xors[s] != 0)\n\t\t\tcou++;\n\n\tif (cou % 2 == 1)\n\t\tcout << \"Alice\";\n\telse\n\t\tcout << \"Bob\";\n\treturn 0;\n}\n//don't forget about MAXN, mod and infinity "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline void read(int &x){\n\tx=0;static char ch;static bool flag;flag = false;\n\twhile(ch=getchar(),ch<'!');if(ch == '-') ch=getchar(),flag = true;\n\twhile(x=10*x+ch-'0',ch=getchar(),ch>'!');if(flag) x=-x;\n}\n#define rg register int\n#define rep(i,a,b) for(rg i=(a);i<=(b);++i)\n#define per(i,a,b) for(rg i=(a);i>=(b);--i)\nconst int maxn = 100010;\nstruct Edge{\n\tint to,next;\n}G[maxn<<1];\nint head[maxn],cnt;\nvoid add(int u,int v){\n\tG[++cnt].to = v;\n\tG[cnt].next = head[u];\n\thead[u] = cnt;\n}\nint fa[maxn],g[maxn];\nvoid dfs(int u){\n\tg[u] = 0;\n\tfor(rg i = head[u],v;i;i=G[i].next){\n\t\tv = G[i].to;if(v == fa[u]) continue;\n\t\tfa[v] = u;dfs(v);\n\t\tg[u] ^= (g[v] + 1);\n\t}\n}\nint main(){\n\tint n;read(n);\n\tint u,v;\n\trep(i,2,n){\n\t\tread(u);read(v);\n\t\tadd(u,v);add(v,u);\n\t}dfs(1);\n\tputs(g[1] == 0 ? \"Bob\" : \"Alice\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define pb push_back\nusing namespace std;\nll n,dp[200005];\nvector<ll>v[200005];\nvoid go(ll x,ll par){\n    for(int i=0; i<v[x].size(); i++){\n        if(v[x][i] != par){\n            go(v[x][i] , x);\n            dp[x] ^= dp[v[x][i]] + 1;\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> n;\n    \n    for(int i=1; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    \n    go(1 , 0);\n    \n    if(dp[1])\n        cout << \"Alice\";\n    else\n        cout << \"Bob\";\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;\n\tinline char Gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void Gi(I&x){\n\t\tfor(c=Gc();c<'0'||c>'9';c=Gc());\n\t\tfor(x=0;c<='9'&&c>='0';c=Gc())x=x*10+(c&15);\n\t}\n};\nusing io::Gi;\nint N,T;\nstruct edge{\n\t   int adj,nex;\n\t   edge (int a_=0,int n_=0){\n\t\t\tadj=a_;\n\t\t\tnex=n_;\n\t   }\n}E[222222];\nvoid add(int u,int v){\n\t   E[++T]=edge(v,E[u].nex);\n\t   E[u].nex=T;\n\t   E[++T]=edge(u,E[v].nex);\n\t   E[v].nex=T;\n}\nint dfs(int x,int f){\n\tint s=0;\n\tfor (int i=E[x].nex;i;i=E[i].nex){\n\t\tif (E[i].adj!=f){\n\t\t   s^=(dfs(E[i].adj,x)+1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint u,v;\n\tGi(N);\n\tT=N;\n\tfor (int i=1;i!=N;i++){\n\t\tGi(u);\n\t\tGi(v);\n\t\tadd(u,v);\n\t}\n\tprintf(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define pow POW\nvector<int> v[100005];\nint dfs(int x,int f){\n    int res=0;\n    for(auto it:v[x]){\n        if(it!=f){\n            res=res^(dfs(it,x)+1);\n        }\n    }\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i= 1;i<n;i++){\n        int x,y;\n        scanf(\"%d %d\",&x,&y);\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    if(dfs(1,0))printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n}\n/*\n7 7\n1 1 4 7\n1 1 2 5\n1 2 6 7\n1 1 5 8\n1 1 3 6\n1 3 7 5\n0 1 6 7\nd-1 2-d 3-d=d\nd-1 2-d 3-d 4-d\n12 02 0 1\na1 a2 a3 a4\na1-a2-a3-a4\na1-a2-a3+a4\na1-a2+a3-a4\na1-a2+a3+a4\na1-a2-a3+a4\na1-a2+a3-a4\n*/\n//a+a+1=10a+1\n//3a+2=10a+2"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint DP[100005];\nvector <int> G[100005];\nint N;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n}\n\nvoid DFS(int node, int father)\n{\n    vector <int> V;\n    V.clear();\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father)\n            continue;\n        DFS(neighb, node);\n        V.push_back(DP[neighb]);\n    }\n    V.push_back(0);\n    sort(V.begin(), V.end());\n    int val = -1;\n    for(int i = 0; i < V.size() - 1; i++)\n    {\n        if(V[i + 1] > V[i] + 1)\n        {\n            val = V[i] + 1;\n            break;\n        }\n    }\n    if(val == -1)\n        val = V.back() + 1;\n    DP[node] = val;\n}\nint main()\n{\n    Read();\n    DFS(1, 0);\n    int S = 0;\n    for(int i = 0; i < G[1].size(); i++)\n    {\n        S = (S ^ DP[G[1][i]]);\n    }\n    if(S == 0)\n    {\n        cout << \"Bob\\n\";\n    }\n    else\n        cout << \"Alice\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> adjlist;\nvector<bool> visited;\n\nint visit(int v) {\n  visited[v] = true;\n  vector<int> unvisited;\n  for (int w : adjlist[v]) {\n    if (!visited[w]) {\n      unvisited.push_back(w);\n    }\n  }\n\n  if (unvisited.size() == 0) return 0;\n  else if (unvisited.size() == 1) {\n    return 1 + visit(unvisited[0]);\n  } else {\n    int res = 0;\n    for (int w : unvisited) {\n      int test = visit(w);\n      res ^= test;\n    }\n    return res;\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  adjlist.resize(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--;\n    b--;\n    adjlist[a].push_back(b);\n    adjlist[b].push_back(a);\n  }\n\n  visited.assign(n, false);\n  int test = visit(0);\n  if (test == 0) printf(\"Bob\\n\");\n  else printf(\"Alice\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dp[100005],N;\nvector<int> G[100005];\nvoid dfs(int nod,int tata)\n{\n    int cate=0,val=1;\n    for(auto it:G[nod])\n    {\n        int tmp;\n        if(it==tata)continue;\n        dfs(it,nod);tmp=dp[it];\n        cate+=tmp;\n        val^=(!tmp);\n    }\n    if(!cate)dp[nod]=(!val);\n    else dp[nod]=(cate%2==1);\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<N;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1,0);\n    int cate=0,val=0;\n    for(auto it:G[1])\n    {\n        cate+=(dp[it]);\n        val^=(!dp[it]);\n    }\n    if(!cate&&val==1)cout<<\"Alice\";\n    else if(cate%2==1)cout<<\"Alice\";\n    else cout<<\"Bob\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<stack>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\ntypedef long long ll;\nusing namespace std;\n\nll const MAX = 100005;\nll gr[MAX];\nvector<ll> children[MAX];\nvector<ll> G[MAX];\nll parent[MAX];\n\nvoid grundy(ll x) {\n\tll ans = 0;\n\tfor (ll i = 0; i < children[x].size(); i++) {\n\t\tll c = children[x][i];\n\t\tll cnt = 1 + gr[c];\n\t\tans ^= cnt;\n\t}\n\tgr[x] = ans;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tREP(i, 1, n - 1) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tstack<ll> st1,st2;\n\tst1.push(1); st2.push(1);\n\tparent[1] = 1;\n\twhile (!st1.empty()) {\n\t\tll cur = st1.top();\n\t\tst1.pop();\n\t\tfor (ll i = 0; i < G[cur].size(); i++) {\n\t\t\tll next = G[cur][i];\n\t\t\tif (next != parent[cur]) {\n\t\t\t\tchildren[cur].push_back(next);\n\t\t\t\tparent[next] = cur;\n\t\t\t\tst1.push(next);\n\t\t\t\tst2.push(next);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!st2.empty()) {\n\t\tll cur = st2.top();\n\t\tst2.pop();\n\t\tgrundy(cur);\n\t}\n\tif (gr[1] == 0) {\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse {\n\t\tcout << \"Alice\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nvector<int>vec[N];\nint dfs(int u,int fa) {\n    int re=0;\n    for(int i=0; i<vec[u].size(); i++) {\n        if(vec[u][i]!=fa) {\n            re^=1+dfs(vec[u][i],u);\n        }\n    }\n    return re;\n}\nint main() {\n        int n;\n        scanf(\"%d\",&n);\n        for(int i=1; i<n; i++) {\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            vec[a].push_back(b);\n            vec[b].push_back(a);\n        }\n    printf(dfs(1,0)?\"Alice\\n\":\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nint n, i, x, y;\nint sg[maxN];\nvector<int> list[maxN];\n\nvoid dfs(int node, int root) {\n    for (auto to : list[node]) {\n        if (to == root) continue;\n        dfs(to, node);\n        sg[node] ^= 1 + sg[to];\n    }\n}\n\nint main()\n{\n //   freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\", &n);\n    for (i = 1; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        list[x].pb(y);\n        list[y].pb(x);\n    }\n\n    dfs(1, 0);\n    if (sg[1])\n        printf(\"Alice\");\n    else\n        printf(\"Bob\");\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nstatic const int M = (int)1e5+5;\nstruct node{\n\tint to;\n\tnode *nxt;\n\tvoid add(int v){\n\t\tnode *p=new node;\n\t\tp->to=v,p->nxt=nxt,nxt=p;\n\t}\n}head[M];\nint SG[M];\nvoid dfs(int u,int f){\n\tSG[u]=0;\n\tfor(node *i=head[u].nxt;i;i=i->nxt){\n\t\tint v=i->to;\n\t\tif(v==f)continue;\n\t\tdfs(v,u);\n\t\tSG[u]^=SG[v]+1;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\thead[u].add(v);\n\t\thead[v].add(u);\n\t}\n\tdfs(1,0);\n\tputs(SG[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> adjlist;\nvector<bool> visited;\n\nint visit(int v) {\n  visited[v] = true;\n  vector<int> unvisited;\n  for (int w : adjlist[v]) {\n    if (!visited[w]) {\n      unvisited.push_back(w);\n    }\n  }\n\n  if (unvisited.size() == 0) return 0;\n  else if (unvisited.size() == 1) {\n    return 1 + visit(unvisited[0]);\n  } else {\n    int res = 0;\n    for (int w : unvisited) {\n      int test = 1 + visit(w);\n      res ^= test;\n    }\n    return res;\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  adjlist.resize(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--;\n    b--;\n    adjlist[a].push_back(b);\n    adjlist[b].push_back(a);\n  }\n\n  visited.assign(n, false);\n  int test = visit(0);\n  if (test == 0) printf(\"Bob\\n\");\n  else printf(\"Alice\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\t//vector<ULL>cash;\n\n\n\tmap<int, int>mp;\n\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tmp[seed(now, ch)]++;\n\t}\n\tint res = 0;\n\twhile (mp.count(res))\n\t{\n\t\t++res;\n\t}\n\treturn res;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 0)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define P pair<int,int>\n#define len(s) (int)s.size()\n#define pb push_back\n\ntemplate<class T> inline bool chmin(T &a, T b){\n\tif(a>b){a=b;return true;}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T &a, T b){\n\tif(a<b){a=b;return true;}\n\treturn false;\n}\nconstexpr int mod = 1e9+7;\nconstexpr int inf = 3e18;\n\nint N;\nvector<int>G[100005];\nint dfs(int x,int p){\n\tint res=0;\n\tfor(int i:G[x])if(i!=p){\n\t\tres^=dfs(i,x)+1;\n\t}\n\treturn res;\n}\nsigned main(){\n\tcin>>N;\n\trep(i,N-1){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tG[a].pb(b);G[b].pb(a);\n\t}\n\tif(dfs(0,0))cout<<\"Alice\\n\";\n\telse cout<<\"Bob\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef long double ld;\n\n#define rep(i,a,b) for(ll i=a;i<=b;++i)\n#define rev(i,a,b) for(ll i=a;i>=b;i--)\n#define pll pair<ll,ll>\n#define vll vector<ll>\n#define sll set<ll>\n#define vpll vector<pll>\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define ln length()\n#define M 1000000007\nll n,ct[100005];\nvll g[100005];\n\nll deg[100005];\nvoid dfs(ll st,ll pr,ll dp){\n    if(deg[st]%2) ct[dp]++;\n    for(ll v:g[st]) if(v!=pr) dfs(v,st,dp+1);\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    cin>>n;\n    rep(i,1,n-1){\n        ll u,v;cin>>u>>v;\n        g[u].pb(v);g[v].pb(u);\n        deg[u]++;deg[v]++;\n    }\n    if(g[1].size() == 1){\n        cout<<\"Alice\"<<'\\n';\n        return 0;;\n    }\n\n    dfs(1,1,0);\n    ll xr=0;\n    for(int i=1;i<=n+2;i+=2) xr^=ct[i];\n    if(xr) cout<<\"Alice\";\n    else cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gr[100009];\nint f[100009];\nvector<int> v[100009];\nvoid dfs(int x){\n    f[x] = 1;\n    for(auto i : v[x]){\n        if(f[i]) continue;\n        dfs(i);\n        gr[x] ^= gr[i];\n\n    }\n    if(x > 1) gr[x] ++;\n}\nmain(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n - 1; i++){\n        int x, y;\n        cin >>x>> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1);\n    if(gr[1] == 0) cout << \"Bob\"<< endl;\n    else cout << \"Alice\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint n;\nvector<int> G[100010];\nint grundy[100010];\n\nvoid dfs(int s,int par){\n    for(int t:G[s]){\n        if(t==par) continue;\n        dfs(t,s);\n        grundy[s]^=(grundy[t]+1);\n    }\n}\n\nvoid solve(){\n    cin >> n;\n    rep(i,n-1){\n        int x,y;cin >> x >> y;x--;y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(0,-1);\n    if(grundy[0]) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ad(x) (((x - 1) ^ 1) + 1)\n#define ID isdigit(c = *next++)\n\nstruct Istream {\n\tint size; char *next, buf[20030731 * 3 / 2];\n\tIstream (FILE *f = stdin) {fread(buf, 1, sizeof buf, f); next = buf;}\n\tIstream & operator >> (int &x) {\n\t\tint c; x = 0;\n\t\tfor (; !ID; ) if (!~c) return *this;\n\t\tfor (x = c & 15; ID; x = x * 10 + (c & 15));\n\t\treturn *this;\n\t}\n} cin;\n\nconst int N = 510000, M = 2040000 * 2;\n\nint n, V, E, Es = 0;\n\ninline void down(int &x, const int y) {x > y ? x = y : 0;}\n\nnamespace Green_Hackenbush {\n\tint to[M], first[N], Tfirst[N], next[M];\n\tint cnt = 0, id[N], low[N];\n\tint stc = 0, stack[N], top[N], w[N];\n\tbool bridge[M];\n\n\tinline void addedge(int u, int v, int *fst) {\n\t\tto[++Es] = v; next[Es] = fst[u]; fst[u] = Es;\n\t\tto[++Es] = u; next[Es] = fst[v]; fst[v] = Es;\n\t}\n\n\tvoid dfs(int x, int px = 0) {\n\t\tint i, y; id[x] = low[x] = ++cnt; stack[stc++] = x;\n\t\tfor (i = first[x]; i; i = next[i])\n\t\t\tif (!id[y = to[i]]) {\n\t\t\t\tdfs(y, i); down(low[x], low[y]);\n\t\t\t\tif (id[x] < low[y]) bridge[ad(i)] = bridge[i] = true;\n\t\t\t} else if (px - 1 ^ i - 1 ^ 1)\n\t\t\t\tdown(low[x], id[y]);\n\t\tif (id[x] == low[x])\n\t\t\tfor (y = 0; y != x; )\n\t\t\t\ty = stack[--stc], top[y] = x;\n\t}\n\n\tint dfs2(int x, int px = 0) {\n\t\tint i, y, ret = 0;\n\t\tfor (i = Tfirst[x]; i; i = next[i])\n\t\t\tif ((y = to[i]) != px)\n\t\t\t\tret ^= dfs2(y, x) + 1;\n\t\treturn ret ^ w[x];\n\t}\n\n\tint main() {\n\t\tint i, u, v;\n\t\tcin >> V, E = V - 1;\n\t\tfor (i = 0; i < E; ++i) cin >> u >> v, addedge(u, v, first);\n\t\tdfs(1);\n\t\tfor (i = 1; i <= E * 2; i += 2) {\n\t\t\tu = top[to[i]], v = top[to[i + 1]];\n\t\t\tu == v ? w[u] ^= 1 : (addedge(u, v, Tfirst), 0);\n\t\t}\n\t\treturn dfs2(top[1]);\n\t}\n}\n\nint main() {\n\tputs(Green_Hackenbush::main() ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=100010;\nnamespace T{\n\tconst int E=N<<1;\n\tint to[E],bro[E],head[N],e=0;\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tint dfs(int x,int fa){\n\t\tint f=0;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=fa){\n\t\t\t\tf^=dfs(v,x)+1;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n}\ninline int Main(){\n\tint n=ni;\n\tT::init();\n\tfor(int i=1;i<n;T::add(ni,ni),i++);\n\treturn T::dfs(1,0);\n}\nint main(){\n\tputs(Main()?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n            #include<bits/stdc++.h>\n            using namespace std;\n             \n            #define maxn 111111\n            vector<int> g[maxn];\n            int n;\n             \n            int main()\n            {\n                cin >> n;\n                for (int i = 1; i < n; i++)\n                {\n                    int x, y;\n                    cin >> x >> y;\n                    g[x].push_back(y);\n                    g[y].push_back(x);\n                }\n                    cout << \"Alice\" << endl;\n                return 0;\n            }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint N, E, head[100001], next[199999], to[199999], f[100001], fa[100001], q[100001];\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tint H = 0, T = 1, u;\n\tq[1] = 1;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\tfor (int i = N; i > 1; i--)\n\t\tf[fa[q[i]]] ^= ++f[q[i]];\n\tputs(f[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 200007\n\nint tot , n ;\nint nex[2*N] , fire[N] , to[2*N] , sg[N] ;\n\nvoid add(int u , int v){\n    nex[++tot] = fire[u] ;\n    fire[u] = tot ;\n    to[tot] = v ;\n    return ;\n}\n\nvoid dfs(int x , int fr){\n    for(int i = fire[x] ; i ; i = nex[i] ){\n        int v = to[i] ;\n        if( v == fr ) continue ;\n        dfs( v , x ) ;\n        sg[x] ^= ( sg[v] + 1 ) ;\n    }\n    return ;\n}\n\nint main()\n{\n    scanf(\"%d\" , &n ) ;\n    for(int i = 1 ; i <= n - 1 ; i++ ){\n        int u , v ;\n        scanf(\"%d%d\" , &u , &v ) ;\n        add( u , v ) ; add( v , u ) ;\n    }\n    dfs( 1 , 0 ) ;\n    if( sg[1] ) printf(\"Alice\\n\") ;\n    else printf(\"Bob\\n\") ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 10000000;\n\nint n;\nVI e[100000];\nbool did[100000];\n\nint grundy(int p){\n\tdid[p]=true;\n\tint res=0;\n\tEACH(i,e[p]){\n\t\tint q=*i;\n\t\tif(did[q])continue; // is parent;\n\t\tres = res ^ (grundy(q) + 1);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tREP(i,n-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\t--x;--y;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tcout << (grundy(0) ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tvector<vector<UL>> E(N);\n\t\tvector<UL> P(N, (UL)-1);\n\t\tvector<UL> S;\n\t\trep(i, N - 1) {\n\t\t\tUL a, b; cin >> a >> b; a--; b--;\n\t\t\tE[a].push_back(b);\n\t\t\tE[b].push_back(a);\n\t\t}\n\t\tqueue<UL> Q; Q.push(0);\n\t\twhile (Q.size()) {\n\t\t\tUL p = Q.front(); Q.pop();\n\t\t\tS.push_back(p);\n\t\t\tfor (UL e : E[p]) {\n\t\t\t\tif (P[p] == e) continue;\n\t\t\t\tP[e] = p;\n\t\t\t\tQ.push(e);\n\t\t\t}\n\t\t}\n\t\tvector<vector<UL>> dp(N + 1);\n\t\treverse(S.begin(), S.end());\n\t\tP[0] = N;\n\t\trep(i, S.size()) {\n\t\t\tUL p = S[i];\n\t\t\tUL ans = 0;\n\t\t\tUL s = 0; for (UL d : dp[p]) s ^= d;\n\t\t\tans = s + 1;\n\t\t\tdp[P[p]].push_back(ans);\n\t\t}\n\t\tif (dp[N][0] == 1) cout << \"Bob\" << endl;\n\t\telse cout << \"Alice\" << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\nvector<ll> v[100001];\nll vis[100001]={0};\nll val[100001]={0};\nvoid dfs(ll node)\n{\n\tvis[node]=1;\n\tfor(ll i=0;i<v[node].size();i++)\n\t{\n\t\tif(vis[v[node][i]]==0)\n\t\t{\n\t\t\tdfs(v[node][i]);\n\t\t\tval[node]^=(val[v[node][i]]+1);\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tll n;\n\tcin>>n;\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(1);\n\tif(val[1]!=0)\n\tcout<<\"Alice\"<<endl;\n\telse\n\tcout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<stack>\n#include<cstring>\n#include<vector>\n#include<list>\n#include<set>\n#include<map>\nusing namespace std;\n#define LL long long\n#define pi (4*atan(1.0))\n#define eps 1e-14\n#define bug(x)  cout<<\"bug\"<<x<<endl;\nconst int N=1e5+10,M=1e6+10,inf=1e9+10;\nconst LL INF=1e18+10,mod=2147493647;\n\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    return ret;\n}\nint main(){\n    int n;\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n\tint n,ji=0,cha[100001];\n\tint x,y;\n\tcin>>n;\n\tfor(int var1=1;var1<=n-1;var1++)\n\t{\n\t\tcin>>x>>y;\n\t\tif(x==1) ji++;\n\t}\n\tif((ji%2==0&&ji!=0)||ji==0) cout<<\"Bob\";\n\tif(ji%2==1) cout<<\"Alice\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: test.cpp\n    > Author: Akira \n    > Mail: qaq.febr2.qaq@gmail.com \n ************************************************************************/\n\n#include<bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*4\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1E9+7;\nconst double eps = 1e-6;\n#define bug cout<<88888888<<endl;\n#define debug(x) cout << #x\" = \" << x << endl;\ntemplate<typename T> T abs(T val){return val>0?val:-val;}\nint N;\nstruct Edge\n{\n    int v,next;\n}edge[MaxM];\nint cont,head[MaxN];\nvoid add(int u, int v)\n{\n    edge[cont].v = v, edge[cont].next = head[u], head[u] = cont++;\n}\n\nint DFS(int u, int pre)\n{\n    int flag = 0;\n    for(int i=head[u];i!=-1;i=edge[i].next)\n    {\n        int v = edge[i].v;\n        if(v==pre) continue;\n        flag ^= DFS(v,u);\n    }\n    return flag+1;\n}\nvoid solve()\n{\n    if(DFS(1,0)!=1) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n\nvoid init()\n{\n    cont = 0;\n    MST(head,-1);\n}\nint main()\n{\n    //std::ios::sync_with_stdio(false);\n    while(scanf(\"%d\", &N)!=EOF)\n    {\n        init();\n        int a,b;\n        for(int i=1;i<N;i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            add(a,b);add(b,a);\n        }\n        solve();\n    }\n    //system(\"pause\");\n    //printf(\"%lld\\n\", (x%mod+mod)%mod );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int MX = 100005;\n\nvector<int> G[MX];\nint dfs(int x, int p){\n\tint g = 0;\n\tfor(int c : G[x]){\n\t\tif( c == p ) continue;\n\t\tg ^= (dfs(c, x)+1);\n\t}\n\treturn g;\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif( dfs(1, 0) == 0 ) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<1];\nint n,home[N],cnt=-1,f[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k,int F){\n\tfor(int i=home[k];~i;i=e[i].next) if(e[i].k!=F){\n\t\tdfs(e[i].k,k);\n\t\tf[k]^=f[e[i].k]+1;\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tif(f[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n \n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n \ntypedef long long ll;\n \nconst int MAX_SIZE = 1e5 + 10;\n \nvector<int> graph[MAX_SIZE];\nvector<bool> visited(MAX_SIZE);\n \nll dfs(int a)\n{\n\tvisited[a] = true;\n        ll s = 0;\n\tfor(auto &u : graph[a])\n\t{\n\t\tif(!visited[u])\n\t\t{\n\t\t\ts ^= (dfs(u) + 1);\n\t\t}\n\t}\n\treturn s;\n}\n \nint main()\n{\n\tint N;\n\tcin >> N;\n\tint x, y;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tcin >> x >> y;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t\tvisited[x] = false;\n\t\tvisited[y] = false;\n\t}\n\tll s = dfs(1);\n\tif(s == 0)\n\t\tcout << \"Bob\" << endl;\n\telse\n\t\tcout << \"Alice\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int maxn=100010;\nusing namespace std;\nvector<int>G[maxn];\nint n,m;\nint sg[maxn];\n\nvoid calc(int cur,int pre)\n{\n    for(int i=0;i<G[cur].size();i++){\n        if(G[cur][i]==pre)\n            continue;\n        calc(G[cur][i],cur);\n        sg[cur]^=(sg[G[cur][i]]+1);\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n-1;i++){\n        int from, to;\n        scanf(\"%d %d\",&from,&to);\n        G[from].push_back(to);\n        G[to].push_back(from);\n    }\n    calc(1,0);\n    printf(\"%s\",sg[1]?\"Alice\":\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nint main() {\n        int n;\n        cin >> n;\n        vector<int> cnt(n, 0);\n        rep(i, n - 1) {\n                int x, y;\n                cin >> x >> y;\n                x --, y --;\n                cnt[x] ++;\n                cnt[y] ++;\n        }\n        for (int i = 1; i < n; i ++) cnt[i] --;\n        if (cnt[0] == 1) {\n                cout << \"Alice\" << endl;\n                return 0;\n        }\n        int odd = 0;\n        rep(i, n) if (cnt[i] & 1) odd ++;\n        cout << (odd & 1 ? \"Alice\" : \"Bob\") << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool seen[100010];\nvector<int> adj[100010];\nint n;\nint dfs(int a)\n{\n\tseen[a] = 1;\n\tint winner = 1;\n\tint num = 0;\n\tfor (auto b : adj[a])\n\t{\n\t\tif (!seen[b]) winner ^= dfs(b), num++;\n\t}\n\tif (num == 1) winner++;\n\treturn winner;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tint res = dfs(1);\n\tif (!res) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n\nconst int L=100000+1;\nvector<int> ps[L];\nint f(int r,int p)\n{\n\tint ret=0;\n\tfor(auto k:ps[r]){\n\t\tif(k==p)continue;\n\t\tret^=f(k,r)+1;\n\t}\n\treturn ret;\n}\nvoid solve(long long N, std::vector<long long> x, std::vector<long long> y){\n\tfor(int i=0;i<N-1;i++){\n\t\tps[x[i]].push_back(y[i]);\n\t\tps[y[i]].push_back(x[i]);\n\t}\n\n\tif(f(1,0)){\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse{\n\t\tcout << \"Bob\" << endl;\n\t}\n\n\n\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    std::vector<long long> x(N-1);\n    std::vector<long long> y(N-1);\n    for(int i = 0 ; i < N-1 ; i++){\n        scanf(\"%lld\",&x[i]);\n        scanf(\"%lld\",&y[i]);\n    }\n    solve(N, std::move(x), std::move(y));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int MN = 100005;\n\nint N;\nstd::vector<int> G[MN];\n\nint DFS(int u, int p) {\n\tint ret = 0;\n\tfor (int v : G[u]) if (v != p) ret ^= DFS(v, u) + 1;\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, x, y; i < N; ++i)\n\t\tscanf(\"%d%d\", &x, &y),\n\t\tG[x].push_back(y),\n\t\tG[y].push_back(x);\n\tputs(DFS(1, 0) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nint n;\nint f[200005];\nint tot,head[200005],nx[400005],to[400005];\nvoid jia(int aa,int bb)\n{\n\ttot++;\n\tnx[tot]=head[aa];\n\tto[tot]=bb;\n\thead[aa]=tot;\n\treturn;\n}\nvoid dfs(int rt,int fa)\n{\n\tint sum=0,cs=0;\n\tfor(int i=head[rt];i;i=nx[i])\n\t{\n\t\tint yy=to[i];\n\t\tif(yy==fa) continue;\n\t\tdfs(yy,rt);sum+=f[yy];cs++;\n\t}\n\tif(sum%2||cs%2) f[rt]=1;\n\treturn;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint x=read(),y=read();\n\t\tjia(x,y);jia(y,x);\n\t}\n\tdfs(1,1);\n\tif(f[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define db double\n#define ll long long\n#define down(i,j,n) for(register int i=j;i>=n;i--)\n#define up(i,j,n) for(register int i=j;i<=n;i++)\n#define pb push_back\n#define se second\n#define fi first\n#define pa pair<int,int>\n#define mp make_pair\n#define FILE \"dealing\"\ntemplate<class T> bool cmax(T& a,T b){return a<b?a=b,true:false;}\ntemplate<class T> bool cmin(T& a,T b){return a>b?a=b,true:false;}\ntemplate<class T> T squ(T a){return a*a;}\nint read(){\n\tint x=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn f*x;\n}\nconst int maxn=200010,inf=100000000,mod=1e9+7;\nint mul(int a,int b){return 1LL*a*b%mod;}\nint sub(int a,int b){return (a-=b)<0  ?a+mod:a;}\n\nint p,n,A,B,C,D;\nstruct node{\n\tint y,next;\n}e[maxn];int len,linkk[maxn];\nvoid insert(int x,int y){e[++len].y=y;e[len].next=linkk[x];linkk[x]=len;}\nint dep[maxn],val[maxn];\n\nvoid dfs(int x,int fa){\n\tval[dep[x]]++;\n\tfor(int i=linkk[x];i;i=e[i].next){\n\t\tint y=e[i].y;if(y==fa)continue;\n\t\tdep[y]=dep[x]+1;\n\t\tdfs(y,x);\n\t}\n}\nint main(){\n//\tfreopen(FILE\".in\",\"r\",stdin);freopen(FILE\".out\",\"w\",stdout);\n\tn=read();\n\tup(i,2,n){\n\t\tint x=read(),y=read();\n\t\tinsert(x,y);insert(y,x);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor(int i=0;i<n;i++)ans^=val[i];\n\tif(ans)cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector <vector <int> >g;\n\nint calc(int pre, int u){\n\tint s=0;\n\tfor(int i=0;i<g[u].size();++i){\n\t\tif(pre!=g[u][i]) s^=calc(u, g[u][i]);\n\t}\n\treturn s+1;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tg=vector <vector <int> >(n);\n\tfor(int i=0;i<n-1;++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint r=0;\n\tfor(int i=0;i<g[0].size();++i){\n\t\tr^=calc(0, g[0][i]);\n\t}\n\tif(r==0) cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define all(a) a.begin(), a.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nusing namespace std;\ntypedef long long ll;\n\nvector<int> tree[100000];\nint dfs(int v, int p){\n    int res = 0;\n    for(int u : tree[v])if(u != p){\n        res ^= (dfs(u, v) + 1);\n    }\n    return res;\n}\n\nint main(){\n\n    int N;\n    cin >> N;\n\n    rep(i, N - 1){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n\n    cout << (dfs(0, -1) ? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include <random>\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end());\n#define ll long long\n#define pb(a) push_back(a)\n#define print(x) cout<<x<<'\\n';\n#define pe(x) cout<<x<<\" \";\n#define lb(v,n) lower_bound(v.begin(), v.end(), n);\n#define ub(v,n) upper_bound(v.begin(), v.end(), n);\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \");\n//#define double long double\n\n\n\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a>b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a<b) a = b; }\n\nconst int MOD = 1e9 + 7;\nconst ll INF = 1e17;\nconst int INT_INF = 1e9;\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ntypedef pair<int, int>P;\nconst int MAX = 200020;\n\n\n\nbool vis[100010];\nvector<int>G[100010];\n\nint grundy(int n, int pre) {\n\t//print(n);\n\tif (n == 1) {\n\t\tif (G[n].size() == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tres ^= (grundy(nex, n)+1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\telse {\n\t\tif (G[n].size() == 2) {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tif (nex == pre)continue;\n\t\t\t\tres = grundy(nex, n);\n\t\t\t}\n\t\t\tres++;\n\t\t\treturn res;\n\t\t}\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tif (nex == pre)continue;\n\t\t\t\tres ^= (grundy(nex, n)+1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N; cin >> N;\n\tREP(i, N-1) {\n\t\tint x, y; cin >> x >> y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tll res = grundy(1, -1);\n\tif (res == 0) {\n\t\tprint(\"Bob\");\n\t}\n\telse print(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a),i##_end_=(b);i<i##_end_;i++)\n#define MEMSET(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define SZ(a) ((int)a.size())\nusing namespace std;\nconst int M=100005;\n\nvector<int> E[M];\nint SG[M];\nint n,ans;\n\nint dfs(int u,int fa){\n    int v,res=0;\n    FOR(i,0,SZ(E[u])) if((v=E[u][i])^fa) res^=dfs(v,u)+1;\n    return res;\n}\n \nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n){\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        u--;v--;\n        E[u].pb(v);\n        E[v].pb(u);\n    }\n    \n    ans=dfs(0,-1);\n    printf(\"%s\",ans?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <stdio.h>\n//#include <iostream>\n//#include <string.h>\n//#include <math.h>\n//#include <stdlib.h>\n//#include <limits.h>\n//#include <algorithm>\n//#include <queue>\n//#include <vector>\n//#include <set>\n//#include <map>\n//#include <stack>\n//#include <bitset>\n//#include <string>\n//#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p,c) memset(p,c,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD =1000000007ll;\nconst int maxn=100100;\nint sg[maxn];\nvector<int>node[maxn];\nvoid dfs(int u,int fa)\n{\n\tfor(auto v:node[u])\n\t\tif(v!=fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tsg[u]^=sg[v]+1;\n\t\t}\n}\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"in1.txt\", \"w\", stdout);\n    //::iterator iter;                  %I64d\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    int n;\n    scanf(\"%d\",&n);\n    for(int x=1;x<n;x++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tnode[u].pb(v);\n\t\tnode[v].pb(u);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100100;\nint grundy[N];\nvi a[N];\nint n;\n\nvoid calc(int v, int pr) {\n\tgrundy[v] = 0;\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i];\n\t\tif (to == pr)\n\t\t\tcontinue;\n\t\tcalc(to, v);\n\t\tgrundy[v] ^= grundy[to];\n\t}\n\tif (v) {\n\t\tgrundy[v]++;\n\t}\n}\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tcin >> n;\n\tforn(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\ta[u].pb(v);\n\t\ta[v].pb(u);\n\t}\t\n\tcalc(0, -1);\n\tif (grundy[0]) {\n\t\tputs(\"Alice\");\n\t} else {\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector<int> g[101010];\n\nint dfs(int v, int prev) {\n        int res = 0;\n        for (int u : g[v]) if (u != prev) res ^= dfs(u, v) + 1;\n        return res;\n}\n\nint main() {\n        int n, a, b;\n        cin >> n;\n        for (int i = 0; i < n - 1; i ++) {\n                cin >> a >> b;\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        cout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nconst int N = 2e5;\nusing namespace std;\nint n,edge[N * 2 + 5],nxt[N * 2 + 5],head[N + 5],edge_cnt,sg[N + 5];\nvoid add_edge(int u,int v)\n{\n    edge[++edge_cnt] = v;\n    nxt[edge_cnt] = head[u];\n    head[u] = edge_cnt;\n}\nvoid dfs(int u,int fa)\n{\n    for (int i = head[u];i;i = nxt[i])\n    {\n        int v = edge[i];\n        if (v == fa)\n            continue;\n        dfs(v,u);\n        sg[u] ^= sg[v] + 1;\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    int u,v;\n    for (int i = 1;i < n;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    dfs(1,0);\n    if (sg[1])\n        cout<<\"Alice\"<<endl;\n    else\n        cout<<\"Bob\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG //test only\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\n#define INF 1020304050\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> x(n-1);\n  vector<int> y(n-1);\n  int i;\n  rep(i,n-1)\n  {\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n  }\n  vector<vector<int>> e(n);\n  rep(i,n-1)\n  {\n    e[x[i]].emplace_back(y[i]);\n    e[y[i]].emplace_back(x[i]);\n  }\n  vector<int> root(n,-1);\n  stack<int> st;\n  queue<int> q;\n  queue<int> q2;\n  vector<int> grundy(n,0);\n  q.push(0);\n  while(!q.empty())\n  {\n    while(!q.empty())\n    {\n      int now = q.front();\n      q.pop();\n      rep(i,e[now].size())\n      {\n        int to = e[now][i];\n        if(to != 0 && root[to] == -1)\n        {\n          root[to] = now;\n          q2.push(to);\n          st.push(to);\n        }\n      }\n    }\n    while(!q2.empty())\n    {\n      q.push(q2.front());\n      q2.pop();\n    }\n  }\n  while(!st.empty())\n  {\n    int now = st.top();\n    st.pop();\n    if(e[now].size()==1)\n    {\n      grundy[now] = 1;\n    }\n    else\n    {\n      int kg = 0;\n      rep(i,e[now].size())\n      {\n        int from = e[now][i];\n        if(from == root[now]) continue;\n        kg = kg^grundy[from];\n      }\n      grundy[now] = kg+1;\n    }\n  }\n  int judge = 0;\n  rep(i,e[0].size())\n  {\n    judge = judge^grundy[e[0][i]];\n  }\n  if(judge == 0)\n  {\n    cout << \"Bob\" << endl;\n  }\n  else\n  {\n    cout << \"Alice\" << endl;\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma optimize O3\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \n#define RETD(x) { cout << fixed << setprecision(15) << x; exit(0); }\nconst ll M=2e5+5,LG=32,SM=600+5,inf=1e18+5;\nll mod=1e9+7;\n\nll n;\nvll g[M];\n\nll dfs(ll x,ll p)\n{\n    ll res=0;\n    for (ll y:g[x])\n    {\n        if (y==p) continue;\n            res^=dfs(y,x)+1;\n    }\n    return res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].PB(y);\n        g[y].PB(x);\n    }\n    if (dfs(0,0)) RET(\"Alice\");\n    RET(\"Bob\");      \t\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[100005];\nvector<int> g[100005];\nvoid dfs(int u, int p){\n \tint res = 0;\n \tfor(int i=0;i<g[u].size();i++){\n \t\tint v = g[u][i];\n \t\tif(v == p) continue;\n \t\tdfs(v, u);\n \t\tres ^= dp[v]+1;\n \t}\n \tdp[u] = res;\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i=0;i<N-1;i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tif(dp[1] != 0) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 1e5 + 5 ;\nusing namespace std ;\n\nint n, e, ter[N << 1], lnk[N], nxt[N << 1] ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e ;\n}\n\nint dfs(int p, int las) {\n\tint res = 0 ;\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) {\n\t\tres ^= dfs(ter[i], p) + 1 ;\n\t}\n\treturn res ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\tint x, y ;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, y), add(y, x) ;\n\t}\n\tputs(dfs(1, 0) ? \"Alice\" : \"Bob\") ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=100005;\nint fst[N],f[N],tot=0;\nstruct Edge{\n\tint to,nxt;\n}e[N*2];\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\nvoid dfs(int x,int fa){\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y!=fa){\n\t\t\tdfs(y,x);\n\t\t\tf[x]^=f[y]+1;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(1,0);\n\tif (f[1]) printf(\"Alice\\n\");\n\t\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\nconst int N = 100010;\nstruct Edge{ int to, next;} edge[N];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\nint dfs(int x, int f)\n{\n\tint ret = 0;\n\tRepG(i, x) if (v != f)\n\t\tret ^= (dfs(v, x) + 1);\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n - 1) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd_edge(x, y); add_edge(y, x);\n\t}\n\t\n\tif (dfs(1, 0)) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb(x) push_back(x)\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\n\nconst int MAX_N = 1e5;\nvector<int> es[MAX_N];\nbool used[MAX_N];\n\n//nowより下の部分木においてnowを根として同様のゲームを行ったときのgrundy数\nint grundy(int now){\n    used[now] = true;\n    int res = 0;\n    for(auto &e: es[now]){\n        if(!used[e]) res ^= grundy(e)+1;\n    }\n    return res;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    rep(i, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        es[a].pb(b), es[b].pb(a);\n    }\n    fill(used, used+N, false);\n    if(grundy(0)) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define DIM 100005\nusing namespace std;\nint n, i, sum, x, y;\nint s[DIM], w[DIM];\nvector<int> v[DIM];\nvoid dfs(int nod, int t){\n    int i, nr = 0;\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n            dfs(v[nod][i], nod);\n        }\n    }\n    for(i = 0; i < v[nod].size(); i++){\n        if(v[nod][i] != t){\n           w[++nr] = s[ v[nod][i] ];\n        }\n    }\n    sort(w + 1, w + nr + 1);\n    if(w[1] == 0 && nr != 0){\n        for(i = 2; i <= nr; i++){\n            if(w[i] - w[i - 1] > 1){\n                s[nod] = w[i - 1] + 1;\n                break;\n            }\n        }\n        if(i == nr + 1){\n            s[nod] = w[nr] + 1;\n        }\n    }\n}\nint main(){\n    cin>> n;\n    for(i = 1; i < n; i++){\n        cin>> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    if(v[1].size() == 1){\n        cout<<\"Alice\";\n        return 0;\n    }\n    dfs(1, 0);\n    for(i = 0; i < v[1].size(); i++){\n        sum ^= s[ v[1][i] ];\n    }\n    if(sum == 0){\n        cout<<\"Bob\";\n    }\n    else{\n        cout<<\"Alice\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a),i##_end=(b);i<=i##_end;i++)\n#define For(i,a,b) for(int i=(a),i##_end=(b);i<i##_end;i++)\n#define per(i,a,b) for(int i=(b),i##_st=(a);i>=i##_st;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define dbg(x) cerr<<#x\" = \"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define Es(x,i) for(F*i=G[x];i;i=i->nxt)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int inf=~0u>>1,MOD=1e9+7;\ninline int rd() {\n    int x,c,f=1;while(!isdigit(c=getchar()))f=c!='-';x=c-'0';\n    while(isdigit(c=getchar()))x=x*10+c-'0';return f?x:-x;\n}\nconst int N=1e5+11;\nstruct F{int v;F*nxt;}pl[N<<1],*cur=pl,*G[N];\ninline void ins(int u,int v){*cur=(F){v,G[u]},G[u]=cur++;}\nint sz[N],n,f[N];\nint dfs(int x,int t=0){\n\tEs(x,i)if(i->v^t)dfs(i->v,x),f[x]^=f[i->v],sz[x]++;\n\tf[x]+=(sz[x]==1);\n}\nint main(){\n\tn=rd();\n\trep(i,2,n){int u=rd(),v=rd();ins(u,v),ins(v,u);}\n\tdfs(1);\n\tputs(f[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\nvector<int>e[maxn];\n\nint dfs(int x,int fa){\n  int ret=0;\n  for(int i=0;i<e[x].size();i++){\n    int v=e[x][i];\n    if(v==fa)continue;\n    ret^=(1+dfs(v,x));\n  }\n  return ret;\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"in.cpp\",\"r\",stdin);\n#endif\n  cin>>n;\n  for(int i=1;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    e[x].push_back(y);\n  }\n  if(dfs(1,0))cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define rep(i,s,t) for(int i=(s),_t=(t);i<_t;++i)\n#define per(i,s,t) for(int i=(t)-1,_s=(s);i>=_s;--i)\n#define debug(x) cerr<<#x<<\" == \"<<(x)<<endl\n#define bug(x) cerr<<#x<<\" == \"<<(x)<<\" \"\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair<int,int> pii;\n\ntemplate<class T>inline void rd(T &x){\n\tstatic char c,f;\n\tx=0;f=1;\n\twhile(c=getchar(),c<48)if(c=='-')f=-1;\n\tdo x=x*10+(c&15);\n\twhile(c=getchar(),c>47);\n\tx*=f;\n}\n\ntemplate<class T>void pf(T x){\n\tif(x<0)putchar('-'),x=-x;\n\telse if(!x){putchar('0');return ;}\n\tstatic int stk[100],tp;\n\tfor(tp=0;x;x/=10)stk[tp++]=x%10;\n\twhile(tp)putchar(stk[--tp]^48);\n}\n\ntemplate<class T>void ptn(T x){pf(x),putchar('\\n');}\ntemplate<class T>void ptk(T x){pf(x),putchar(' ');}\ntemplate<class T>void Min(T &A,T B){if(A>B)A=B;}\ntemplate<class T>void Max(T &A,T B){if(A<B)A=B;}\n\nconst int N=(int)1e5+5;\n\nint head[N],n,tot,SG[N];\npii G[N<<1];\nvoid dfs(int x,int par){\n\tSG[x]=0;\n\tfor(int i=head[x];i;i=G[i].se){\n\t\tint y=G[i].fi;\n\t\tif(y==par)continue;\n\t\tdfs(y,x);\n\t\tSG[x]^=SG[y]+1;\n\t}\n}\nint main(){\n\trd(n);\n\tfor(int x,y,i=1;i<n;++i){\n\t\trd(x),rd(y);\n\t\tG[++tot]=pii(y,head[x]);head[x]=tot;\n\t\tG[++tot]=pii(x,head[y]);head[y]=tot;\n\t}\n\tdfs(1,0);\n\tif(SG[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t\tif (edge[i].size() >= 3)dis[i] = 0;\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n}\nint dfs(int u, int fa = 0) {\n\tint tc = 0;\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (to[i] != fa)\n\t\t\ttc ^= dfs(to[i], u) + 1;\n\treturn tc;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tint n; std::cin >> n;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, addedge(t1, t2);\n\tstd::cout << (dfs(1) ? \"Alice\" : \"Bob\") << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \n\nconst int N = 1e5; \n\nint n; \nvector<int> g[N + 2]; \nint SG[N + 2];\nvoid dfs (int foo, int p) {\n  SG[foo] = 0; \n  for (int bar : g[foo]) {\n    if (bar == p) continue; \n    dfs(bar, foo); \n    SG[foo] ^= SG[bar] + 1; \n  }\n} \nint main() {\n  //freopen(\"in.inp\", \"r\", stdin); freopen(\"in.out\", \"w\", stdout); \n  \n  scanf(\"%d\", &n); \n  for (int ie = 1; ie < n; ie++) {\n    int foo, bar; \n    scanf(\"%d %d\", &foo, &bar); \n    g[foo].push_back(bar); \n    g[bar].push_back(foo); \n  }\n  dfs(1, 0);\n  if (SG[1] != 0) {\n    printf(\"Alice\\n\"); \n  } else {\n    printf(\"Bob\\n\"); \n  } \n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\")\n%:pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\n#define fo(i, n) for(int i = 1; i <= (n); i ++)\n#define out(x) cout << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\ntemplate<typename tp> inline void arr(tp *a, int n) {\n  for(int i = 1; i <= n; i ++)\n    cout << a[i] << \" \";\n  puts(\"\");\n}\nconst int N = 3e5 + 233;\nint n;\nvector<int> g[N];\n\ninline int dfs(int u, int fat, int fff) {\n  if(u != 1 && g[u].size() == 1) \n    return 0;\n  int t = 0;\n  vector<int> vec;\n  for(auto v: g[u]) if(v != fat) vec.push_back(dfs(v, u, fff ^ 1));\n  sort(vec.begin(), vec.end());\n  for(auto v: vec) {\n    if(v != t) return t;\n    else t ++;\n  }\n  return t;\n}\n\nmain(void) {\n  read(n);\n  for(int i = 1; i <= n - 1; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int xo = 0;\n  for(auto v: g[1])\n    xo ^= dfs(v, 1, 0);\n  cout << (xo ? \"Alice\" : \"Bob\") << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst ll mod=1000000007;\nconst ll INF=1e15;\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define U_ERASE(V) V.erase(unique(ALL(V)), V.end());\n#define pb push_back\n#define mp make_pair\ntypedef pair<ll,ll> P;\nvec dx={1,0,-1,0};\nvec dy={0,1,0,-1};\n\nconst ll MAXN=100010;\nll memo[MAXN];\nvec d[MAXN], D[MAXN];\n\nbool used[MAXN];\n\n\nvoid INIT(ll a){\n    used[a]=true;\n    rep(i,d[a].size()){\n        ll b=d[a].at(i);\n        if(!used[b]){\n            D[a].pb(b);\n            INIT(b);\n        }\n    }\n    return;\n}\n\nll dfs(ll x){\n    if(memo[x]>=0) return memo[x];\n    if(D[x].size()==0) return memo[x]=0;\n    ll ret=0;\n    rep(i,D[x].size()){\n        ll a=D[x].at(i);\n        ret^=(dfs(a)+1);\n    }\n    return memo[x]=ret;\n}\nint main(){\n    ll N; cin>>N;\n    rep(i,N-1){\n        ll a,b; cin>>a>>b;\n        a--; b--;\n        d[a].pb(b);\n        d[b].pb(a);\n    }\n    INIT(0);\n\n    rep(i,MAXN) memo[i]=-INF;\n    if(dfs(0)) cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\nusing ll = long long;\n\nvector<int> tree[100000];\n\nint grundy(int x, int prev) {\n    int g = 0;\n    for (int v : tree[x]) {\n        if (v != prev)\n            g ^= grundy(v, x);\n    }\n    return g + 1;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        --v1;\n        --v2;\n        tree[v1].push_back(v2);\n        tree[v2].push_back(v1);\n    }\n\n    printf(grundy(0, -1) == 0 ? \"Alice\\n\" : \"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "\n//#pragma GCC optimize (\"-O3\")\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <bitset>\n#include <list>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <functional>\n#include <queue>\n#include <regex>\n#include <cassert>\n#include <map>\n#include <type_traits>\n#include <array>\n#include <cassert>\n#include <typeinfo>\n#include <time.h>\n#include <iomanip>\n#include <random>\n#include <sstream>\n#ifdef _MSC_VER\n#include <intrin.h>\n#define popcnt __popcnt64\n//#  define __builtin_popcount __popcnt\n#else\n#define popcnt __builtin_popcountll\n#endif\n//#include \"boost/variant.hpp\"\n\n\n\nusing namespace std;\n\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 60;\n\n#define rep(i, N, M) for(ll i=N, i##_len=(M); i<i##_len; ++i)\n#define rep_skip(i, N, M, ...) for(ll i=N, i##_len=(M); i<i##_len; i+=(skip))\n#define rrep(i, N, M)  for(ll i=(M)-1, i##_len=(N-1); i>i##_len; --i)\n#define pb push_back\n#define fir first\n#define sec second\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define perm(c) sort(all(c));for(bool c##perm=1;c##perm;c##perm=next_permutation(all(c))) //perm(c){write(c)} writes all permutation of c \n\ntypedef pair<double, double> pd;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<pll> vpll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<string> vs;\ntemplate<typename T>\nusing pq_greater = priority_queue<T, vector<T>, greater<T>>;\nstruct Point { ll x; ll y; };\nusing vpt = vector<Point>;\n\ntemplate<int n>\nstruct tll_impl {\n\tusing type = decltype(tuple_cat(tuple<ll>(), declval<typename tll_impl<n - 1>::type>()));\n};\ntemplate<>\nstruct tll_impl<1> {\n\tusing type = tuple<ll>;\n};\ntemplate<int n>\nusing tll = typename tll_impl<n>::type;\n\ntemplate<class T>\nconstexpr ll SZ(T& v) { return static_cast<ll>(v.size()); };\n\ntemplate<int n, typename T>\nstruct vec_t_impl {\n\tusing type = vector<typename vec_t_impl<n-1,T>::type>;\n};\ntemplate<typename T>\nstruct vec_t_impl<1,T> {\n\tusing type = vector<T>;\n};\ntemplate<int n, typename T>\nusing vec_t = typename vec_t_impl<n, T>::type;\n// check \nstatic_assert(is_same<vec_t<3,ll>, vector<vector<vector<ll>>>>::value, \"\");\n\n// decompose vector into basetype and dimension.\ntemplate<typename T> \nstruct vec_dec {\n\tstatic constexpr int dim = 0;\n\tusing type  = T;\n};\ntemplate<typename T>\nstruct vec_dec<vector<T>> {\n\tstatic constexpr int dim = vec_dec<T>::dim+1;\n\tusing type  = typename vec_dec<T>::type;\n};\nstatic_assert(is_same<typename vec_dec<vec_t<3, ll>>::type, ll>::value, \"\");\nstatic_assert(vec_dec<vec_t<3, ll>>::dim == 3, \"\");\n\ntemplate<typename T = ll>\nvector<T> makev(size_t a) { return vector<T>(a); }\n\ntemplate<typename T = ll, typename... Ts>\nauto makev(size_t a, Ts... ts) {\n\treturn vector<decltype(makev<T>(ts...))>(a, makev<T>(ts...));\n}\n// ex:  auto dp =  makev<ll>(4,5) => vector<vector<ll>> dp(4,vector<ll>(5));\n\n// check if T is vector\ntemplate < typename T >\nstruct is_vector : std::false_type {};\n\ntemplate < typename T >\nstruct is_vector<vector<T>> : std::true_type {};\nstatic_assert(is_vector<vector<ll>>::value == true && is_vector<ll>::value == false, \"\");\n\n// check if T is vector\ntemplate < typename T>\nstruct is_pair : std::false_type {};\n\ntemplate < typename T, typename S >\nstruct is_pair<pair<T, S>> : std::true_type {};\nstatic_assert(is_pair<pll>::value == true && is_pair<ll>::value == false, \"\");\n\ntemplate<typename T, typename V, typename enable_if<!is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid fill_v(T& t, const V& v) { t = v; }\n\ntemplate<typename T, typename V, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid fill_v(T& t, const V& v) {\n\tfor (auto &&x : t)\n\t\tfill_v(x, v);\n}\n// ex:  fill_v(dp, INF);\n\ntemplate<typename T, typename enable_if < !is_vector<T>::value && !is_pair<T>::value, nullptr_t > ::type = nullptr >\nvoid read(T& x) {\tcin >> x;}\n\ntemplate<typename T, typename enable_if<is_pair<T>::value, nullptr_t>::type = nullptr>\nvoid read(T& x) { read(x.first); read(x.second); }\n\ntemplate<typename T, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid read(T& x) { rep(i,0,x.size()) read(x[i]); }\n\ntemplate<>\nvoid read(Point& p) { cin >> p.x >> p.y; }\n\ntemplate<typename T, typename Delim_t = string, typename enable_if<!is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid write(T& x, Delim_t delim = \" \") { cout << x << delim; }\n\ntemplate<typename T, typename Delim_t = string, typename enable_if<is_vector<T>::value, nullptr_t>::type = nullptr>\nvoid write(T& x, Delim_t delim = \" \") { rep(i, 0, x.size()) write(x[i], (i == (x.size() - 1) ? \"\" : delim)); cout << '\\n'; }\n\n\n\ntemplate<typename T> void chmin(T &a, T b) {\n\tif (a > b) a = b;\n}\ntemplate<typename T> void chmax(T &a, T b) {\n\tif (a < b) a = b;\n}\n\nvll seq(ll i, ll j) {\n\tvll res(j - i);\n\trep(k, i, j) res[k] = i + k;\n\treturn res;\n}\n\nconstexpr ll POW_0(ll x, ll y) {\n\tif (y == 0)return 1;\n\tif (y == 1)return x ;\n\tif (y == 2)return x * x ;\n\tif (y % 2 == 0)return POW_0(POW_0(x, y / 2), 2LL);\n\treturn ((POW_0(POW_0(x, y / 2), 2LL)) * (x)) ;\n}\n\nconstexpr ll POW(ll x, ll y, ll mod = 0) {\n\tif (mod == 0)return POW_0(x, y);\n\tif (y == 0)return 1;\n\tif (y == 1)return x % mod;\n\tif (y == 2)return x * x % mod;\n\tif (y % 2 == 0)return POW(POW(x, y / 2, mod), 2LL, mod) % mod;\n\treturn ((POW(POW(x, y / 2, mod), 2LL, mod)) * (x % mod)) % mod;\n}\n\ntemplate<\n\ttypename Inputs,\n\ttypename Functor,\n\ttypename T = typename Inputs::value_type>\n\tvoid sort_by(Inputs& inputs, Functor f) {\n\tstd::sort(std::begin(inputs), std::end(inputs),\n\t\t[&f](const T& lhs, const T& rhs) { return f(lhs) < f(rhs); });\n}\n\ntemplate<\n\ttypename Inputs,\n\ttypename Functor,\n\ttypename T = typename Inputs::value_type>\n\tvoid stable_sort_by(Inputs& inputs, Functor f) {\n\tstd::stable_sort(std::begin(inputs), std::end(inputs),\n\t\t[&f](const T& lhs, const T& rhs) { return f(lhs) < f(rhs); });\n}\n\ntemplate<typename Inputs>\nvoid sort_uniq(Inputs& inputs) {\n\tsort(all(inputs));\n\tinputs.erase(unique(all(inputs)), inputs.end());\n}\n\nvector<string> split(const string& s, char delim) {\n\tvector<string> elems;\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, delim)) {\n\t\tif (!item.empty()) {\n\t\t\telems.push_back(item);\n\t\t}\n\t}\n\treturn elems;\n}\n\ntemplate<class T>\nmap<T,ll> inv_map(vector<T>& x) {\n\tmap<T, ll> res;\n\trep(i, 0, x.size()) {\n\t\tres[x[i]] = i;\n\t}\n\treturn res;\n}\ntemplate<class T, class val_t = typename T::value_type, enable_if_t<!is_same<T, set<val_t>>::value >* = nullptr >\nconstexpr bool exist(const T& container, val_t val) { return find(all(container), val) != container.end(); }\ntemplate<class T, class val_t = typename T::value_type,  enable_if_t<is_same<T, set<val_t>>::value >* = nullptr >\nconstexpr bool exist(const T& container, val_t val) { return container.find(val) != container.end(); }\n\n\n\n\n\nstruct UnionFind {\n\tvector<ll> data;\n\tvll querySize_;\n\tset<ll> roots;\n\tUnionFind(ll size) : data(size, -1), querySize_(size, 0) {\n\t\trep(i, 0, size) roots.insert(i);\n\t}\n\n\tll unite(ll x, ll y) {\n\t\t// return: root\n\t\tx = get_root(x); y = get_root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tquerySize_[x] += querySize_[y] + 1;\n\t\t\troots.erase(y);\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tquerySize_[x]++;\n\t\t\treturn x;\n\t\t}\n\t}\n\tbool is_same(ll x, ll y) {\n\t\t// check whether x and y are connected\n\t\treturn get_root(x) == get_root(y);\n\t}\n\tll get_root(ll x) {\n\t\t// get root\n\t\treturn data[x] < 0 ? x : data[x] = get_root(data[x]);\n\t}\n\tll size(ll x) {\n\t\treturn -data[get_root(x)];\n\t}\n\tll  query_size(ll x) {\n\t\treturn querySize_[get_root(x)];\n\t}\n\tconst set<ll>& get_roots() {\n\t\treturn roots;\n\t}\n\tvoid initialize() {\n\t\tfor (auto& i : data) {\n\t\t\ti = -1;\n\t\t}\n\t}\n};\n\n\n\n\ntemplate<class cost_t>\nstruct Edge_Base\n{\n\tll from;\n\tll to;\n\tcost_t cost;\n\tEdge_Base reverse() const { return Edge_Base{ to, from , cost }; }\n\tEdge_Base(ll from , ll to, cost_t cost=1) : from(from),to(to),cost(cost){};\n\tEdge_Base(pll e) :from(e.first), to(e.second), cost(1) { }\n\tEdge_Base() :from(0), to(0), cost(0){ };\n\tbool operator<  (const Edge_Base& e) const {\treturn cost < e.cost; }\n\tbool operator>  (const Edge_Base& e) const {\treturn cost > e.cost; }\n\tbool operator== (const Edge_Base& e) const { return cost == e.cost && from == e.from && to == e.to; }\n};\nusing Edge = Edge_Base<ll>;\n\ntemplate<class EdgeType, class EdgeContainerType>\nstruct Edge_Itr_Base {\n\tconstexpr Edge_Itr_Base() :index(), edges(nullptr) {}\n\tconstexpr Edge_Itr_Base(ll index, EdgeContainerType& edges_) :index(index), edges(&edges_) {}\n\tconstexpr Edge_Itr_Base& operator++() { ++index; return *this; }\n\tconstexpr bool operator==(const Edge_Itr_Base& rhs) const { return index == rhs.index; }\n\tconstexpr bool operator!=(const Edge_Itr_Base& rhs) const { return index != rhs.index; }\n\tconstexpr EdgeType* operator->() const { return &(*edges)[index]; }\n\tconstexpr EdgeType& operator*() const { return (*edges)[index]; }\n\tconstexpr Edge_Itr_Base& operator+=(ll n) { index += n; return *this; }\n\tll index;\n\tEdgeContainerType* edges;\n};\n\n\n\nauto nullAction = [](const auto&) {};\n\ntemplate<class cost_t>\nstruct Graph_Base {\n\tusing Edge = Edge_Base<cost_t>;\n\tusing Edge_Itr = Edge_Itr_Base<Edge_Base<cost_t>, vector<Edge_Base<cost_t>>>;\n\tusing Edge_CItr = Edge_Itr_Base<const Edge_Base<cost_t>, const vector<Edge_Base<cost_t>>>;\n\n\tll nodeSize;\n\tvector<Edge> edges;\n\tvector<vector<Edge_Itr>> out_edges;\n\tvector<vector<Edge_Itr>> in_edges;\n\tenum Dir{dir, undir};\n\tGraph_Base(ll nodeSize, const vector<Edge>& edges_ = vector<Edge>(), Dir dirct= dir)\n\t\t: nodeSize(nodeSize), out_edges(nodeSize), in_edges(nodeSize){\n\t\tif (dirct == undir) {\n\t\t\tfor (const Edge& e : edges_) push_undir(e);\n\t\t}\n\t\telse {\n\t\t\tfor (const Edge& e : edges_) push(e);\n\t\t}\n\t}\n\tGraph_Base(ll nodeSize, vector<pll> edges_, Dir dirct = dir)\n\t\t: nodeSize(nodeSize), out_edges(nodeSize), in_edges(nodeSize){\n\t\tif (dirct == undir) {\n\t\t\tfor (const pll& e : edges_) push_undir(Edge(e));\n\t\t}\n\t\telse {\n\t\t\tfor (const pll& e : edges_) push(Edge(e));\n\t\t}\n\t}\n\tGraph_Base(vvll ajacency_matrix, ll default_value) \n\t\t: nodeSize(ajacency_matrix.size()), out_edges(nodeSize), in_edges(nodeSize){\n\t\tll n = ajacency_matrix.size();\n\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (ajacency_matrix[i][j] != default_value)\n\t\t\t\tpush(Edge(i, j, ajacency_matrix[i][j]));\n\t\t}\n\t}\n\t\n\tEdge& operator[](ll ind) { return this->edges[ind]; } \n\tconst Edge& operator[](ll ind) const{ return this->edges[ind]; }\n\tvector<Edge_Itr>& out(ll ind){ return this->out_edges[ind]; }\n\tconst vector<Edge_Itr>& out(ll ind) const { return this->out_edges[ind]; }\n\tvector<Edge_Itr>& in(ll ind){ return this->in_edges[ind]; }\n\tconst vector<Edge_Itr>& in(ll ind) const{ return this->in_edges[ind]; }\n\tEdge_Itr begin() { return Edge_Itr(0, edges); }\n\tEdge_Itr end() { return Edge_Itr(edges.size(), edges); }\n\tEdge_CItr begin() const { return Edge_CItr(0, edges); }\n\tEdge_CItr end() const { return Edge_CItr(edges.size(), edges); }\n\n\tll size() const { return nodeSize; }\n\tll sizeEdges() const { return edges.size(); }\n\n\tvoid push(const Edge& edge){\n\t\tassert(max(edge.from, edge.to) < nodeSize);\n\t\tedges.emplace_back(edge);\n\t\tout_edges[edge.from].emplace_back(Edge_Itr(edges.size()-1,edges));\n\t\tin_edges[edge.to].emplace_back(Edge_Itr(edges.size() - 1, edges));\n\t}\n\tvoid push(const Edge& edge, Graph_Base::Dir dir) {\n\t\tif (dir == Dir::undir)\n\t\t\tpush_undir(edge);\n\t\telse\n\t\t\tpush(edge);\n\t}\n\tvoid push_undir(const Edge& edge) {\n\t\tpush(edge); push(edge.reverse());\n\t}\n\tvoid push(vector<Edge> edges) {\n\t\tfor (const Edge& e : edges) {\n\t\t\tpush(e);\n\t\t}\n\t}\n\tvvll adjacency_matrix() const {\n\t\tvvll d(size(), vll(size()));\n\t\tfor (auto& e : edges) {\n\t\t\td[e.from][e.to] = e.cost;\n\t\t}\n\t\treturn d;\n\t}\n\n\tvll get_topologically_sorted_nodes() const\n\t{\n\t\t// graph needs to be represented by adjacent list.\n\t\t// complexity: O( node size + edge size)\n\t\tll nodeSize = this->size();\n\n\t\t// find root\n\t\tvll roots;\n\t\tvll inDegree(nodeSize);\n\t\trep(i, 0, nodeSize)\n\t\t{\n\t\t\tfor (auto& sibling : this->out(i)) {\n\t\t\t\tinDegree[sibling->to]++;\n\t\t\t}\n\t\t}\n\t\trep(i, 0, nodeSize) {\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\troots.push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tstack<ll> parents;\n\t\tfor (ll i : roots)\n\t\t\tparents.push(i);\n\n\t\tvll sortedNodes;\n\t\twhile (!parents.empty()) {\n\t\t\tll parent = parents.top();\n\t\t\tparents.pop();\n\t\t\tsortedNodes.push_back(parent);\n\t\t\tfor (auto& sibling : this->out(parent)) {\n\t\t\t\tinDegree[sibling->to]--;\n\t\t\t\tif (inDegree[sibling->to] == 0) {\n\t\t\t\t\tparents.push(sibling->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sortedNodes;\n\t}\n\n\tvoid topological_sort() {\n\t\tvll sorted = get_topologically_sorted_nodes();\n\t\tvll new_ind(sorted.size());\n\t\tvector<Edge> new_edges;\n\t\trep(i, 0, sorted.size()) {\n\t\t\tnew_ind[sorted[i]] = i;\n\t\t}\n\t\tfor (Edge& e : edges) {\n\t\t\tnew_edges.emplace_back(Edge{ new_ind[e.from], new_ind[e.to],e.cost });\n\t\t}\n\t\t*this = Graph_Base(this->size(), new_edges);\n\t}\n\tcost_t diameter() const\n\t{\n\t\t// require : graph is tree\n\t\t// calculate the diameter ( longest path length ) in O(N)\n\t\tvector<cost_t> dp(size(), -1);\n\t\tcost_t m = 0; ll ind;\n\t\tfunction<void(ll)> dfs = [&](ll x) {\n\t\t\tfor (auto& e : out(x)) {\n\t\t\t\tll nextnode = e->to;\n\t\t\t\tif (dp[nextnode] == -1) {\n\t\t\t\t\tdp[nextnode] = dp[x] + e->cost;\n\t\t\t\t\tif (dp[nextnode] > m) {\n\t\t\t\t\t\tm = dp[nextnode];  ind = nextnode;\n\t\t\t\t\t}\n\t\t\t\t\tdfs(nextnode);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdp[0] = 0; ind = 0;\n\t\tdfs(0);\n\t\tll first = ind;\n\t\tfill_v(dp, -1);\n\t\tdp[first] = 0;\n\t\tdfs(first);\n\t\treturn m;\n\t\t// remark two end points of diameter are 'first' and 'ind';\n\t}\n\n\tvll leaves() const {\n\t\tvll res;\n\t\trep(i, 0, nodeSize) {\n\t\t\tif (out(i).size() <= 1)\n\t\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid dfs(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\t// Impliment func: void(const Edge&) representing what this should do, when target node moves from visited node (e.from) to unvisited node (e.to).\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto dfs_impl = [&](auto dfs_impl, ll startNode)-> void {\n\t\t\tvisited[startNode] = 1;\n\t\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\t\tif (visited[e->to])\n\t\t\t\t\tcontinue;\n\t\t\t\tbefore_act(*e);\n\t\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t\t\tafter_act(*e);\n\t\t\t}\n\t\t};\n\t\tdfs_impl(dfs_impl, startNode);\n\n\t};\n\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid dfs_node(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\t// Impliment func: void(ll node_ind) representing what this should do, when target node moves from visited node to unvisited node (node_ind).\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto dfs_impl = [&](auto dfs_impl, ll startNode)-> void {\n\t\t\tbefore_act(startNode);\n\t\t\tvisited[startNode] = 1;\n\t\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\t\tif (visited[e->to])\n\t\t\t\t\tcontinue;\n\t\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t\t}\n\t\t\tafter_act(startNode);\n\t\t};\n\t\tdfs_impl(dfs_impl, startNode);\n\t};\n\n\ttemplate<class T, class S = decltype(nullAction)>\n\tvoid bfs(ll startNode, T before_act, S after_act = nullAction) const\n\t{\n\t\tconst auto& graph = *this;\n\t\tvb visited(graph.size());\n\t\tauto bfs_impl = [&](ll startNode) {\n\t\t\t//if (visited[startNode] != 0) return;\n\t\t\tvisited[startNode] = 1;\n\t\t\tqueue<Edge> toVisit;\n\t\t\tfor (auto& e : graph.out(startNode))\n\t\t\t\ttoVisit.push(*e);\n\t\t\twhile (toVisit.size()) {\n\t\t\t\tauto next = toVisit.front(); toVisit.pop();\n\t\t\t\tif (visited[next.to])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[next.to] = 1;\n\t\t\t\tbefore_act(next);\n\t\t\t\tfor (auto& e : graph.out(next.to)) {\n\t\t\t\t\tif (!visited[e->to])\n\t\t\t\t\t\ttoVisit.push(*e);\n\t\t\t\t}\n\t\t\t\tafter_act(next);\n\t\t\t}\n\t\t};\n\t\tbfs_impl(startNode);\n\t};\n\t\n\tvector<cost_t> dijkstra(ll start) const {\n\t\tvector<cost_t> fromList;\n\t\treturn dijkstra(start, fromList);\n\t}\n\n\tvector<cost_t> dijkstra(ll start, vector<cost_t>& from_list) const {\n\t\t// graph: weighted directed graph of adjacent representation\n\t\t// start: index of start point\n\t\t// return1: minimum path length from start\n\t\t// complexity : E*log(V)\n\t\tconst auto& graph = *this;\n\t\tll node_size = graph.size();\n\t\tvector<cost_t> dist(node_size, INF);\n\t\tfrom_list.resize(node_size);\n\t\tfill_v(from_list, -1);\n\t\tdist[start] = 0;\n\t\tpq_greater<pair<cost_t, pll>> pq;\n\t\tpq.push({ 0, {start, start} });\n\t\twhile (!pq.empty()) {\n\t\t\tauto node = pq.top(); pq.pop();\n\t\t\t// if not shortest path fixed, fix\n\t\t\tll from = node.second.first;\n\t\t\tll to = node.second.second;\n\t\t\tif (from_list[to] != -1)\n\t\t\t\tcontinue;\n\t\t\tfrom_list[to] = from;\n\n\t\t\tfor (auto& edge : graph.out(to)) {\n\t\t\t\tll adj = edge->to;\n\t\t\t\tcost_t cost = dist[to] + edge->cost;\n\t\t\t\tif (dist[adj] > cost) {\n\t\t\t\t\tdist[adj] = min(dist[adj], cost);\n\t\t\t\t\tpq.push({ cost ,{to, adj} });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tvll euler_tour(ll start) const\n\t{\n\t\tvll res;\n\t\tres.push_back(start);\n\t\tdfs(start, [&](const Edge& e) {\n\t\t\tres.push_back(e.to);\n\t\t\t}, [&](const Edge& e) {\n\t\t\t\tres.push_back(e.from);\n\t\t\t});\n\t\treturn res;\n\t}\n\n\tGraph_Base kruskal(Graph_Base::Dir = Dir::undir) const\n\t{\n\t\t//returns minimal spanning tree\n\t\tGraph_Base res(nodeSize);\n\t\tvpll sortedEdges;\n\t\trep(i, 0, edges.size()) {\n\t\t\tsortedEdges.push_back({ edges[i].cost, i });\n\t\t}\n\t\tsort(all(sortedEdges));\n\t\tUnionFind uf(nodeSize);\n\t\trep(i, 0, sortedEdges.size()) {\n\t\t\tll cost, eInd;\n\t\t\ttie(cost, eInd) = sortedEdges[i];\n\t\t\tll from = (*this)[eInd].from; ll to = (*this)[eInd].to;\n\t\t\tif (!uf.is_same(from, to)) {\n\t\t\t\tres.push((*this)[eInd], dir);\n\t\t\t}\n\t\t\tuf.unite(from, to);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvvll warshall_floyd() const {\n\t\t// O(|V|^3)\n\t\tconst Graph_Base& g = *this;\n\t\tll n = g.size();\n\t\tvvll d = g.adjacency_matrix();\n\t\trep(k, 0, n)rep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (d[i][j] > d[i][k] + d[k][j])\n\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t}\n\t\treturn d;\n\t}\n\n\tvll bellman_ford(ll start, ll negative_closed_loop_value = -INF) const {\n\t\tvll from_list;\n\t\treturn bellman_ford(start, from_list, negative_closed_loop_value);\n\t}\n\n\tvll bellman_ford(ll start, vll& from_list, ll negative_closed_loop_value = -INF) const {\n\t\t// O(|E| * |V|)\n\t\tconst Graph_Base& g = *this;\n\t\tvll dist(g.size(), INF);\n\t\tdist[start] = 0;\n\t\tfrom_list.resize(g.size());\n\t\trep(i, 0, g.size()) {\n\t\t\tfor(const Edge& e: g){\n\t\t\t\tif (dist[e.from] != INF && dist[e.to] > dist[e.from] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.cost;\n\t\t\t\t\tfrom_list[e.to] = e.from;\n\t\t\t\t\tif (i == g.size() - 1 && dist[e.to] != INF) {\n\t\t\t\t\t\t// check negative closed loop\n\t\t\t\t\t\tdist[e.to] = negative_closed_loop_value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// propagate negative path\n\t\trep(i, 0, g.size()) {\n\t\t\trep(j, 0, g.edges.size()) {\n\t\t\t\tauto& e = g.edges[j];\n\t\t\t\tif (dist[e.from] == negative_closed_loop_value && dist[e.from] != INF)\n\t\t\t\t\tdist[e.to] = negative_closed_loop_value;\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tbool is_bipartite() const {\n\t\tvll even(size(),-1);\n\t\teven[0] = 0;\n\t\tbool ok = true;\n\t\tdfs_node(0,\n\t\t\t[&](ll node) {\n\t\t\t\tfor (auto& e : out(node)) {\n\t\t\t\t\tif (even[e->to] != -1 ) {\n\t\t\t\t\t\tif (even[e->from] == even[e->to]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\teven[e->to] = !even[e->from];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\treturn ok;\n\t}\n};\n\nusing Graph = Graph_Base<ll>;\n\nvll shortest_path_generator(const vll& from_list, ll start, ll goal) {\n\t// usage : vll path =  shortest_path(dijkstra(g,s).second, s, g);\n\tvll path;\n\tpath.emplace_back(goal);\n\twhile (true) {\n\t\tll from = from_list[goal];\n\t\tpath.emplace_back(from);\n\t\tif (from == start) {\n\t\t\tbreak;\n\t\t}\n\t\tgoal = from;\n\t}\n\treverse(all(path));\n\treturn path;\n}\n\nclass FordFulkerson {\nprivate:\n\tvb usedNode;\n\tusing Edge = Edge_Base<ll>;\npublic:\n\tstruct RevEdge { ll from, to, cap, rev; };\n\n\tFordFulkerson(Graph graph) \n\t\t:usedNode(graph.size()), G(vec_t<2,RevEdge>(graph.size()))\n\t{\n\t\trep(i, 0, graph.size()) {\n\t\t\tfor (auto& e : graph.out(i)) {\n\t\t\t\tadd_revedge(*e);\n\t\t\t}\n\t\t}\n\n\t}\n\tvec_t<2, RevEdge> G;\n\tvoid add_revedge(const Edge& e) {\n\t\tG[e.from].push_back(RevEdge{ e.from, e.to ,e.cost, SZ(G[e.to]) });\n\t\tG[e.to].push_back(RevEdge{ e.to, e.from, 0 , SZ(G[e.from]) - 1 });\n\t}\n\t\n\tll single_flow(ll from, ll to, ll flow) {\n\t\t// make a single flow\n\t\tif (from == to)\n\t\t\treturn flow;\n\t\tusedNode[from] = 1;\n\t\trep(i, 0, G[from].size()) {\n\t\t\tRevEdge& e = G[from][i];\n\t\t\tif (usedNode[e.to] || e.cap <= 0)\n\t\t\t\tcontinue;\n\t\t\tll flow_from_e = single_flow(e.to, to, min(flow, e.cap));\n\t\t\tif (flow_from_e > 0) {\n\t\t\t\te.cap -= flow_from_e; assert(e.cap >= 0);\n\t\t\t\tG[e.to][e.rev].cap += flow_from_e;\n\t\t\t\t// get a larger flow\n\t\t\t\treturn flow_from_e;\n\t\t\t}\n\t\t}\n\t\t// if we already visited all edges or cap = 0 flow = 0;\n\t\treturn 0;\n\t}\n\tll max_flow(ll from, ll to) {\n\t\tll flow = 0;\n\t\twhile (true) {\n\t\t\tfill_v(usedNode, 0);\n\t\t\tll f = single_flow(from, to, INF);\n\t\t\tif (f == 0)\n\t\t\t\treturn flow;\n\t\t\telse\n\t\t\t\tflow += f;\n\t\t}\n\t}\n};\n\n// Least Common Ancestor\nclass LCA {\npublic:\n\tLCA(const Graph& graph, ll root) : max_par(ceil(log2(graph.size()) + 2)), parent(graph.size(), vll(max_par,-1)),\n\t\tdepth() {\n\t\t//parent[root][0] = root;\n\t\tgraph.dfs(root, [&](const Edge & e) {\n\t\t\tll to = e.to;\n\t\t\tparent[to][0] = e.from;\n\t\t\trep(i, 1, parent[to].size()) {\n\t\t\t\tif (parent[to][i - 1] == -1)\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\tparent[to][i] = (parent[parent[to][i - 1]][i - 1]);\n\t\t\t}\n\t\t});\n\t\tdepth = graph.dijkstra(root);\n\t}\n\tll operator()(ll node1, ll node2) {\n\t\tif (depth[node1] > depth[node2]) swap(node1, node2);\n\t\trrep(i, 0, max_par) {\n\t\t\tif (((depth[node2] - depth[node1]) >> i) & 1) {\n\t\t\t\tnode2 = parent[node2][i];\n\t\t\t}\n\t\t}\n\t\tif (node1 == node2)return node1;\n\t\trrep(i, 0, max_par) {\n\t\t\tif (parent[node1][i] != parent[node2][i]) {\n\t\t\t\tnode1 = parent[node1][i];\n\t\t\t\tnode2 = parent[node2][i];\n\t\t\t}\n\t\t}\n\t\treturn parent[node1][0];\n\t}\nprivate:\n\tll max_par;\n\tvvll parent;\n\tvll depth;\n};\n\nclass BipartiteMatching {\n\t// O(V*E)\n\tint n, left, right;\n\tvector< vector< int > > graph;\n\tvector< int > used;\n\tint timestamp;\npublic:\n\tBipartiteMatching(int left, ll right) : n(left+right), left(left), right(right), graph(n), used(n, 0), timestamp(0){}\n\n\tvoid push(int u, int v) {\n\t\tgraph[u].push_back(v + left);\n\t\tgraph[v + left].push_back(u);\n\t}\n\n\tbool dfs(int idx, vector<int>& match) {\n\t\tused[idx] = timestamp;\n\t\tfor (auto& to : graph[idx]) {\n\t\t\tint to_match = match[to];\n\t\t\tif (to_match == -1 || (used[to_match] != timestamp && dfs(to_match, match))) {\n\t\t\t\tmatch[idx] = to;\n\t\t\t\tmatch[to] = idx;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_match(vector<int>& match) {\n\t\tmatch.resize(n); fill_v(match, -1);\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < SZ(graph); i++) {\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i, match);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint bipartite_match() {\n\t\tvector<int> match;\n\t\treturn bipartite_match(match);\n\t}\n};\n\n\n\n// ================= Rectangle Area Problem =====================\nauto getNeighbor = [](ll i, ll w, ll h) {\n\tll H = i / w;\n\tll W = i % w;\n\tvll res;\n\tif (H > 0) res.push_back(i - w);\n\tif (H < h - 1) res.push_back(i + w);\n\tif (W > 0)res.push_back(i - 1);\n\tif (W < w - 1)res.push_back(i + 1);\n\treturn res;\n};\n\nauto getHW = [](ll i, ll w) {\n\tll H = i / w;\n\tll W = i % w;\n\treturn pll{ H,W };\n};\n\n\n\n\n\n\n\n\n\n// ============================ Header  =================================\ntemplate<class T, class S>\nvoid dfs_node(Graph& graph,  ll startNode, T before_act, S after_act, T before_act2, S after_act2)\n{\n\t// Impliment func: void(ll node_ind) representing what this should do, when target node moves from visited node to unvisited node (node_ind).\n\t\n\tvb visited(graph.size());\n\tauto dfs_impl = [&](auto dfs_impl, ll startNode, T before_act, S after_act)-> void {\n\t\tbefore_act(startNode);\n\t\tvisited[startNode] = 1;\n\t\tfor (auto& e : graph.out(startNode)) {\n\t\t\tif (visited[e->to])\n\t\t\t\tcontinue;\n\t\t\tdfs_impl(dfs_impl, e->to);\n\t\t}\n\t\tafter_act(startNode);\n\t\treturn;\n\t};\n\tdfs_impl(dfs_impl, startNode, before_act, after_act);\n\tdfs_impl(dfs_impl, startNode, before_act2, after_act2);\n\n};\n\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tll n; cin >> n;\n\tGraph g(n); \n\trep(i,0,n-1){\n\t\tll a, b; cin >> a >> b; a--; b--;\n\t\tg.push_undir({ a,b });\n\t}\n\tvll deg(n);\n\tll cur = 0;\n\tg.dfs(0,\n\t\t[&](const Edge& e) {\n\t\t\tdeg[cur]++;\n\t\t\tcur++;\n\t\t}, [&](const Edge& e) {\n\t\t\tcur--;\n\t\t});\n\tll ok = false;\n\trep(i, 0, n) {\n\t\tif (deg[i] % 2)\n\t\t\tok = true;\n\t}\n\n\tif (ok)\n\t\tcout << \"Alice\" << endl;\n\telse\n\t\tcout << \"Bob\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ala be zekrellah tatmaenolgholoob ...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n#define MP make_pair\nconst int maxn = 1e5+9;\nconst ll mod = 1e9+7;\n\nvector <int> g[maxn];\nbool ans = true;\n\nint dfs (int v, int parent = -1) {\n\tll val = 0;\n\tll num = 0, sum = 0;\n\tfor (auto u : g[v]) {\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tnum++;\n\t\tll f = dfs(u, v);\n\t\tsum += f;\n\t\tval ^= f;\n\t}\n\tif (num == 1) {\n\t\tif (v == 0)\n\t\t\tans = false;\n\t\treturn sum + 1;\n\t} else {\n\t\tif (val != 0)\n\t\t\tans = false;\n\t\treturn 1;\n\t}\n}\n\nint main () {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\t--v; --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0);\n\tif (ans)\n\t\tcout << \"Bob\\n\";\n\telse\n\t\tcout << \"Alice\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint N;\nint x[100005], y[100005];\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n\n  int root = 0;\n  int edge = N - 1;\n\n  rep(i, N - 1) {\n      cin >> x[i] >> y[i];\n      x[i]--; y[i]--;\n      if (x[i] == 0 || y[i] == 0) root += 1;\n  }\n\n  int hand = 0;\n  while (true) {\n    if (root%2 == 1) {\n      root -= 1;\n      edge -= 1;\n    } else {\n      if (edge == root) {\n          root -= 1;\n      }\n      edge -= 1;\n    }\n    if (root == 0) {\n      cout << (hand == 1 ? \"Bob\":\"Alice\") << endl;\n      break;\n    }\n\n    hand = (hand + 1)%2;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\n//I am fucking stupid\n//Stupidity level  -> 1/0\n\n\nconst int MAXN  = 1010;\nvector<int>v1[MAXN];\nint gr[MAXN];\n\nvoid DFS(int x,int par)\n{\n    for(auto itr : v1[x])\n    {\n        if(itr!=par)\n        {\n            DFS(itr, x);\n            gr[x]^=(gr[itr]+1);\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n        int n;\n        cin>>n;\n        for(int i = 0 ;i<MAXN;i+=1){\n            v1[i].clear();\n            gr[i] = 0;\n        }\n        for(int i = 1;i<=n-1;i+=1)\n        {\n            int x,y;\n            cin>>x>>y;\n            v1[x].push_back(y);\n            v1[y].push_back(x);\n        }\n        DFS(1, -1);\n        if(gr[1]==0)\n        {\n            cout<<\"Bob\"<<endl;\n        }\n        else{\n            cout<<\"Alice\"<<endl;\n        }\n    \n    return 0;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n#include<bits/stdc++.h>\n#define N 100005\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,sg[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa=0)\n{\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tsg[u]^=(sg[v]+1);\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: test.cpp\n    > Author: Akira \n    > Mail: qaq.febr2.qaq@gmail.com \n ************************************************************************/\n\n#include<bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*4\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1E9+7;\nconst double eps = 1e-6;\n#define bug cout<<88888888<<endl;\n#define debug(x) cout << #x\" = \" << x << endl;\ntemplate<typename T> T abs(T val){return val>0?val:-val;}\nint N;\nstruct Edge\n{\n    int v,next;\n}edge[MaxM];\nint cont,head[MaxN];\nvoid add(int u, int v)\n{\n    edge[cont].v = v, edge[cont].next = head[u], head[u] = cont++;\n}\n\nint DFS(int u, int pre)\n{\n    int flag = 0;\n    for(int i=head[u];i!=-1;i=edge[i].next)\n    {\n        int v = edge[i].v;\n        if(v==pre) continue;\n        flag ^= (DFS(v,u)+1);\n    }\n    return flag;\n}\nvoid solve()\n{\n    if(DFS(1,0)) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n\nvoid init()\n{\n    cont = 0;\n    MST(head,-1);\n}\nint main()\n{\n    //std::ios::sync_with_stdio(false);\n    while(scanf(\"%d\", &N)!=EOF)\n    {\n        init();\n        int a,b;\n        for(int i=1;i<N;i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            add(a,b);add(b,a);\n        }\n        solve();\n    }\n    //system(\"pause\");\n    //printf(\"%lld\\n\", (x%mod+mod)%mod );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> nt[maxn];\nint n, sg[maxn];\n\nvoid dfs(int x, int fa)\n{\n\tfor (auto v:nt[x])\t\tif (v!=fa) dfs(v,x), sg[x]^=(sg[v]+1);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i = 0; i < n-1; i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tnt[x].push_back(y);\n\t\tnt[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tif (sg[1]) puts(\"Alice\");else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\n\nint dfs(int v, int p)\n{\n\tint st = 0;\n\n\tfor (int to : g[v]) {\n\t\tif (to != p) {\n\t\t\tint r = dfs(to, v);\n\t\t\tif (r == -1) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (st > 0) {\n\t\t\t\t\tif (st != r + 1) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tst = r + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn st;\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tputs(dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=200005;\nint n,i,j,k,head[N],adj[N*2],nxt[N*2],sg[N];\nbool v[N];\nvoid dfs(int x,int dad)\n{\n\tfor(int y=head[x];y;y=nxt[y])\n\t\tif(adj[y]!=dad)\n\t\t{\n\t\t\tdfs(adj[y],x);\n\t\t\tsg[x]^=sg[adj[y]]+1;\n\t\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tadj[i*2-1]=k;\n\t\tnxt[i*2-1]=head[j];\n\t\thead[j]=i*2-1;\n\t\tadj[i*2]=j;\n\t\tnxt[i*2]=head[k];\n\t\thead[k]=i*2;\n\t}\n\tdfs(1,-1);\n\tif(sg[1])\n\t\tprintf(\"Alice\");\n\telse\n\t\tprintf(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define _overload3(_1,_2,_3,name,...)name\n#define _rep(i,n)repi(i,0,n)\n#define repi(i,a,b)for(int i=int(a),i##_len=(b);i<i##_len;++i)\n#define MSVC_UNKO(x)x\n#define rep(...)MSVC_UNKO(_overload3(__VA_ARGS__,repi,_rep,_rep)(__VA_ARGS__))\n#define all(c)c.begin(),c.end()\n#define write(x)cout<<(x)<<'\\n'\nusing namespace std; typedef long long ll; template<class T>using vv = vector<vector<T>>;\ntemplate<class T>auto vvec(int n, int m, T v) { return vv<T>(n, vector<T>(m, v)); }\ntemplate<class T, class U>bool chmax(T& a, U&& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T, class U>bool chmin(T& a, U&& b) { return b < a ? a = b, 1 : 0; }\nconstexpr int INF = 1 << 29, MOD = int(1e9) + 7; constexpr ll LINF = 1LL << 60;\nstruct aaa { aaa() { cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }; }aaaa;\n\nint dfs(const vv<int>& tree, int v, int p) {\n    int g = 0;\n    for (int u : tree[v]) {\n        if (u == p) continue;\n        int r = dfs(tree, u, v);\n        g ^= r + 1;\n    }\n    return g;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vv<int> tree(N);\n    rep(i, N - 1) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n\n    write(dfs(tree, 0, -1) ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma gcc optimize(\"Ofast\")\n\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef int64_t lld;\ntypedef pair<int,int> pii;\ntypedef pair<lld,lld> pll;\ntypedef pair<int,pll> pip;\ntypedef pair<pll,int> ppi;\ntypedef pair<lld,pll> plp;\ntypedef pair<pll,lld> ppl;\ntypedef pair<pll,pll> ppp;\ntemplate<typename T>\nusing maxHeap = priority_queue<T,vector<T>,less<T>>;\ntemplate<typename T>\nusing minHeap = priority_queue<T,vector<T>,greater<T>>;\n#define ff first\n#define ss second\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define endl '\\n'\n#define jizz cin.tie(0);cout.tie(0);ios::sync_with_stdio(0);\ninline void input(int &_x) {\n    _x = 0;\n    int _tmp = 1; char _tc = getchar();\n    while((_tc < '0' || _tc > '9') && _tc != '-') _tc = getchar();\n    if(_tc == '-') _tc = getchar(), _tmp = -1;\n    while(_tc >= '0' && _tc <= '9') _x = _x*10+(_tc-48), _tc = getchar();\n    _x *= _tmp;\n}\ninline void output(int _x) {\n    char _buff[20]; int _f = 0;\n    if(_x == 0)putchar('0');\n    while(_x > 0)\n    {\n        _buff[_f++] = _x%10+'0';\n        _x /= 10;\n    }\n    for(_f-=1; _f >= 0; _f--)\n        putchar(_buff[_f]);\n    putchar('\\n');\n}\ntemplate<typename Iter>\nostream& _out(ostream &s, Iter b, Iter e) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\ntemplate<class T1,class T2>\nostream& operator<<(ostream& out, pair<T1,T2> p) {\n    return out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) {\n     return _out(s,c.begin(),c.end());\n }\n#ifdef erd1\n    #define pprint(x) cerr<<__PRETTY_FUNCTION__<<\":\"<<__LINE__<<\" - \"<<(#x)<<\"=\"<<(x)<<endl\n#else\n    #define pprint(x)\n#endif\n\n// code starts here\nvector<vector<int>> G;\nint dfs(int i, int p){\n    int ans = 0;\n    for(auto x: G[i])\n        if(x != p)ans ^= dfs(x, i) + 1;\n    return ans;\n}\nsigned main(){\n    int n;\n    cin >> n;\n    G.resize(n+1);\n    for(int i = 1; i < n; i++){\n        int a, b;\n        cin >> a >> b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    cout << (dfs(1, 1)?\"Alice\":\"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <iostream>\n#define maxn 100009\nusing namespace std;\nint n;\nvector<int>G[maxn];\nint sg[maxn];\nvoid dfs(int u, int fa){\n\tsg[u] = 0;\n\tfor(auto v: G[u]){\n\t\tif(v == fa)\n\t\t\tcontinue;\n\t\tdfs(v, u);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1, -1);\n\tif(sg[1])\n\t\tputs(\"Alice\");\n\telse\n\t\tputs(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n;\nvector <int> v[N];\nset <int> s[N];\nmap <set <int>, int> mp;\n\nint getid(set <int> &g){\n    if(mp.find(g) == mp.end()){\n        int sz = mp.size();\n        mp[g] = sz;\n    }\n    return mp[g];\n}\nvoid dfs(int node, int pnode){\n    int big = -1;\n    for(auto &i : v[node]){\n        if(i == pnode) continue;\n        dfs(i, node);\n        if(big == -1 || s[i].size() > s[big].size()){\n            big = i;\n        }\n    }\n    if(big != -1) swap(s[node], s[big]);\n    for(auto &i : v[node]){\n        if(i == pnode || i == big) continue;\n        for(auto &j : s[i]){\n            if(s[node].count(j)) s[node].erase(j);\n            else s[node].insert(j);\n        }\n    }\n    int id = getid(s[node]);\n    s[node].insert(id);\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    for(int i = 0 ; i < n - 1 ; i++){\n        int x, y;\n        cin >> x >> y;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(1, 0);\n    if(s[1].size() == 1) cout << \"Bob\\n\";\n    else cout << \"Alice\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long double ldo;\n\n#define pb push_back\nconst int MAX = 1e5 + 20;\nlong long n, x, res;\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tres = 0;\n\tfor (auto i : g[v])\n\t\tif (i != r)\n\t\t\tres ^= dfs (i, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tx = dfs (0,-1);\n\n\tcout << (x==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long int\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define rrep(i,n) for( int i = n; i >= 0; i-- )\n#define REP(i,s,t) for( int i = s; i <= t; i++ )\n#define RREP(i,s,t) for( int i = s; i >= t; i-- )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint depth[100010];\nvector<int> G[100010];\n\nint dfs(int x, int parent = -1, int d = 0) {\n    int XOR = 0;\n    for(auto to: G[x]) {\n        if (to != parent) {\n            XOR ^= dfs(to, x, d + 1);\n        }\n    }\n    if (XOR != 0) return 2;\n    else return 1;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    rep(i, N - 1) {\n        int x, y; cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    if(dfs(0) == 2) {\n        cout << \"Alice\" << endl;\n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int maxn = 1e5 +100;\nvector<int> G[maxn];\nint sg[maxn];\nvoid dfs(int x, int fa){\n    sg[x] = 1;\n    if(G[x].size() == 2){\n        for(auto to : G[x]) if(to != fa) dfs(to, x), sg[x] = sg[to] + 1;\n        return;\n    }\n    for(auto to : G[x]){\n        if(to == fa) continue;\n        dfs(to, x);\n        sg[x] ^= sg[to];\n    }\n}\n\nint main()\n{\n    int n, x, y;\n    cin>>n;\n    for(int i = 1; i < n; i++){\n        scanf(\"%d %d\", &x, &y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1, 1);\n    if(G[1].size() == 1) sg[1] = sg[G[1][0]] + 1;\n    else {\n        sg[1] = 0;\n        for(auto to : G[1]) sg[1] ^= sg[to];\n    }\n    if(sg[1]) cout<<\"Alice\";\n    else cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = (sz(v[u]) - (u ? 1: 0)) % 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= d[h];\n    }\n    if (sz(v[u]) - (u ? 1: 0) == 1) {\n        d[u] = 1;\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n#define rep2(i, m, n) for(int i=int(m); i<int(n); i++)\n#define rep(i, n) rep2(i, 0, n)\n#define all(a) a.begin(), a.end()\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\nconst int INF = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS = 1e-10;\nconst int MOD = int(1e9)+7;\ntemplate<typename T> inline bool chmin(T& a, T b) {if(a>b) {a=b; return true;} return false;}\ntemplate<typename T> inline bool chmax(T& a, T b) {if(a<b) {a=b; return true;} return false;}\n\nusing Graph = vector<vector<int>>;\nGraph G;\nint dfs(int u, int p=-1) {\n  int g = 0;\n  for (auto v : G[u]) {\n    if (v == p) continue;\n    g ^= (dfs(v, u) + 1);\n  }\n  return g;\n}\n\nint main() {\n  ll N; cin >> N;\n\n  G = Graph(N);\n  for (int i = 0; i < N-1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  cout << ((dfs(0) != 0) ? \"Alice\" : \"Bob\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nint n;\nint f[200005],g[200005];\nint tot,head[200005],nx[400005],to[400005];\nvoid jia(int aa,int bb)\n{\n\ttot++;\n\tnx[tot]=head[aa];\n\tto[tot]=bb;\n\thead[aa]=tot;\n\treturn;\n}\nvoid dfs(int rt,int fa)\n{\n\tint sum=0,cs=0;g[rt]=0;\n\tfor(int i=head[rt];i;i=nx[i])\n\t{\n\t\tint yy=to[i];\n\t\tif(yy==fa) continue;\n\t\tdfs(yy,rt);sum+=f[yy];cs++;\n\t\tg[rt]^=(g[yy]+1);\n\t}\n\tif(sum%2||cs%2) f[rt]=1;\n\treturn;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint x=read(),y=read();\n\t\tjia(x,y);jia(y,x);\n\t}\n\tdfs(1,1);\n\tif(g[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 100005\n#define N 1005\n#define ll long long\n#define oo 1000000000\n#define mod 5557\nusing namespace std;\nint n,m,res[M];\nvector<int >vec[M];\nvoid dfs(int now,int f){  \n\tfor(int i=0;i<vec[now].size();i++){\n\t\tint y=vec[now][i];\n\t\tif(y==f)continue;\n\t\tdfs(y,now);\n\t\tres[now]=res[now]^(1+res[y]);\n\t}\n}  \nint main(){\n\tint i,j,a,b;\n\tcin>>n;\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs(1,0);\n\tif(res[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tfor(c=_gc();c<'0'||c>'9';c=_gc());X=c&15;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=1E5+5;\n\nint N;\nstruct E{\n\tint v,nxt;\n}adj[Maxn<<1];\nint hed[Maxn],TE;\n\nvoid addedge(int u,int v){\nadj[++TE].v=v,adj[TE].nxt=hed[u],hed[u]=TE;}\n\nint Dfs(int u,int Fa){\n\tint Val=0;\n\tfor(int k=hed[u];~k;k=adj[k].nxt)\n\t\tif(adj[k].v!=Fa) Val^=(Dfs(adj[k].v,u)+1);\n\treturn Val;\n}\n\nint main(){\n\treadi(N);\n\tmemset(hed,-1,sizeof(hed));\n\tfor(int u,v,i=1;i<N;++i)\n\t\treadi(u),readi(v),\n\t\taddedge(u,v),addedge(v,u);\n\tif(Dfs(1,0)==0) puts(\"Bob\"); else puts(\"Alice\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long double ldo;\n\n#define pb push_back\nconst int MAX = 1e5 + 20;\nlong long n, a , b, c, d;\nvector<int> g[MAX];\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tif (g[0].size() == 1) return cout << \"Alice\" << endl, 0;\n\n\tcout << (n&1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                        #define ppa pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n              \n            void gya(){\n            \tpr[0]=1;\n            \tfor(int i=1;i<2000010;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<2000010;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\nvector<int> G2[100030];\nvector<int> G[100030];\nint n;\n\n\n\nint saiki2(int u,int oya){\n\t\n\tint r=0;\n\tfor(auto v:G[u])if(v!=oya){\n\t\tr^=(1+saiki2(v,u));\n\t}\n\treturn r;\n}\n      signed main(){\n  cin>>n;\n      \t\n      \tfor(int i=1;i<n;i++){\n      \t\tint yy,yyy;\n      \t\tcin>>yy>>yyy;\n      \t\tG[yy].pb(yyy);\n      \t\tG[yyy].pb(yy);\n      \t}\n      \t\n      \n      \tif(saiki2(1,-1)!=0)cout<<\"Alice\"<<endl;\n      \telse cout<<\"Bob\"<<endl;\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2000000000;//10^9\nll MOD  = 998244353;\nvector<vector<int>> edge(100010, vector<int>(0));\nvector<int> parent(100010, -1);\nvector<bool> vis(100010, 0);\nvector<int> child[100010];\n\nvoid makeParent(int N){\n    vis.at(N) = 1;\n    for(int i = 0; i < edge.at(N).size(); i++){\n        if(vis.at(edge.at(N).at(i)) == 0){\n            parent.at(edge.at(N).at(i)) = N;\n            makeParent(edge.at(N).at(i));\n            child[N].push_back(edge.at(N).at(i));\n        }\n    }\n}\nvector<int> memo(100010, -1);\n\nint grundy(int x){\n    if(memo.at(x) != -1) return memo.at(x);\n    \n    if(child[x].size() == 0)return 0;\n    if(child[x].size() == 1)return memo.at(x) = grundy(child[x][0]) + 1;\n    \n    int XOR = grundy(child[x][0]);\n    for(int i = 1; i < child[x].size(); i++){\n        XOR ^= grundy(child[x][i]);\n    }\n    \n    \n    return memo.at(x) = XOR;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N-1; i++){\n        int x,y;\n        cin >> x >> y;\n        x--,y--;\n        edge.at(x).push_back(y);\n        edge.at(y).push_back(x);\n    }\n    \n    makeParent(0);\n    \n    if(grundy(0)){\n        cout << \"Alice\" << endl;\n    }else{\n        cout << \"Bob\" << endl;\n    }\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<class T> using Tree = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define trav(t,a) for (auto& t: a)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) (int)(x).size()\n\nconst int MOD = 1000000007;\nconst double INF = 1e18;\nconst int MX = 100005;\n\nint N,t;\nvi adj[MX];\npi bound[MX];\n\nint get(pi p) {\n\tint res = 0;\n\tFOR(i,p.f,p.s+1) res ^= 1<<i;\n\treturn res;\n}\n\nmap<int,bool> m;\nvi ed;\n\nint dfs(int x, int y) {\n\tint res = 0;\n\tbound[x].f = t++;\n\ttrav(i,adj[x]) if (i != y) {\n\t\tint t = dfs(i,x)+1;\n\t\tres ^= t;\n\t}\n\tbound[x].s = t-1;\n\treturn res;\n}\n\nbool win(int x) {\n\tif (m.count(x)) return m[x];\n\ttrav(t,ed) if (x&t) if (!win(x^t)) return m[x] = 1;\n\treturn m[x] = 0;\n}\n\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin >> N;\n\tF0R(i,N-1) {\n\t\tint a,b; cin >> a >> b;\n\t\tadj[a].pb(b), adj[b].pb(a);\n\t}\n\tint x = dfs(1,0);\n\tif (x) cout << \"Alice\";\n\telse cout << \"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> edges[100000];\n\nint solve(int v, int p){\n    int ch = edges[v].size();\n    if(p >= 0) --ch;\n    if(ch == 0) return 0;\n    int ret = 0;\n    for(int u: edges[v]){\n        if(u == p) continue;\n        ret ^= solve(u, v) + 1;\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    cin >> n;\n    for(int i=1;i<n;++i){\n        int x, y;\n        cin >> x >> y;\n        --x; --y;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n    if(solve(0, -1) == 0) cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2017 Mstdream\n#include<bits/stdc++.h>\nusing namespace std;\ninline void splay(int &v){\n\tv=0;char c=0;int p=1;\n\twhile(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();}\n\tv*=p;\n}\nconst int N=200020;\nint nxt[N*2],fir[N],to[N*2],sz,n,dp[N];\nvoid add(int x,int y){\n\tnxt[++sz]=fir[x],fir[x]=sz,to[sz]=y;\n}\n//1先手0后手 \nvoid dfs(int x,int fa){\n\tint a=0,b=0; \n\tfor(int u=fir[x];u;u=nxt[u]){\n\t\tif(to[u]!=fa){\n\t\t\tdfs(to[u],x);\n\t\t\tif(dp[to[u]]==1)a++;\n\t\t\telse b++;\n\t\t} \n\t}\n\tif((b&1)==1)dp[x]=1;\n\telse{\n\t\tif((a&1)==1)dp[x]=1;\n\t\telse dp[x]=0;\n\t}\n}\nint main(){\n\tsplay(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;splay(x),splay(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tputs(dp[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <queue>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define ll long long\n#define maxn 500400\nusing namespace std;\ninline void read(int &x){\n    char ch;\n    bool flag=false;\n    for (ch=getchar();!isdigit(ch);ch=getchar())if (ch=='-') flag=true;\n    for (x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());\n    x=flag?-x:x;\n}\n\ninline void write(int x){\n    static const int maxlen=100;\n    static char s[maxlen];\n        if (x<0) {   putchar('-'); x=-x;}\n    if(!x){ putchar('0'); return; }\n    int len=0; for(;x;x/=10) s[len++]=x % 10+'0';\n    for(int i=len-1;i>=0;--i) putchar(s[i]);\n}\nlong long n,l,r,c,d;\n//int a[maxn];\n\n\nint main(){\n    if (n>10)\n        puts(\"Alice\");\n    else\n        puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, D[101000];\nvector<int>E[101000];\nvoid DFS(int a, int p){\n    int i;\n    for(i=0;i<E[a].size();i++){\n        if(E[a][i]==p)continue;\n        DFS(E[a][i], a);\n        D[a] ^= (D[E[a][i]] + 1);\n    }\n}\nint main(){\n    int i, a, b;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++){\n        scanf(\"%d%d\",&a,&b);\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    DFS(1, 0);\n    printf(D[1] ? \"Alice\\n\" : \"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"Alice\" << endl; else cout << \"Bob\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    int Grundy(int v, int par){\n        int g = 0;\n        REP(k, G[v].size()) if(G[v][k].to != par)\n            g ^= (1 + Grundy(G[v][k].to, v));\n        return g;\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    int x, y;\n    REP(i, N - 1){\n        cin >> x >> y;\n        G.add_edge2(x - 1, y - 1, 0);\n    }\n    ANS(G.Grundy(0, -1));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2e5 + 5;\n\nint other[MAXN + 5], last[MAXN + 5], pre[MAXN + 5];\nint dp[MAXN + 5];\nint N, all = -1;\n\nvoid build(int u, int v)\n{\n\tpre[++all] = last[u];\n\tlast[u] = all;\n\tother[all] = v;\n}\n\nint dfs(int ans, int fa)\n{\n\tint dt = last[ans], c = 0, sum = 0;\n\twhile(dt != -1){\n\t\tint dr = other[dt];\n\t\tif(dr != fa) c ^= dfs(dr, ans), sum++;\n\t\tdt = pre[dt];\n\t}\n\tif(fa == 1) return c;\n\treturn c ^ 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tmemset(last, -1, sizeof(last));\n\tfor(int i = 1; i < N; i++){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tbuild(u, v);\n\t\tbuild(v, u);\n\t}\n\tint check = dfs(1, 0) ^ 1;\n\tif(check) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nint beg[N],to[N],nex[N];\nint sg[N];\nint len,n;\ninline void Add(int a,int b){\n\tnex[++len]=beg[a],beg[a]=len,to[len]=b;\n\tnex[++len]=beg[b],beg[b]=len,to[len]=a;\n}\nvoid dfs(int p,int fa){\n\tint A=0,B=0;\n\tfor(int i=beg[p];i;i=nex[i]){\n\t\tif(to[i]!=fa){\n\t\t\tdfs(to[i],p);\n\t\t\tsg[p]^=sg[to[i]]+1;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tAdd(a,b);\n\t}\n\tdfs(1,-1);\n\tprintf(\"%s\\n\",sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 100005\nint n;\nvector<int>e[M];\nint sg[M];\nvoid dfs(int u,int f){\n\tint sum=0;\n\tfor(int i=0;i<e[u].size();i++){\n\t\tint v=e[u][i];\n\t\tif(v==f)continue;\n\t\tdfs(v,u);\n\t\tsum=sum^(sg[v]+1);\n\t}\n\tsg[u]=sum;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\n\nint solve(int now, int par);\n\nint main() {\n  cin >> n;\n  g.resize(n);\n  for (int i = 1; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    g[--a].push_back(--b);\n    g[b].push_back(a);\n  }\n  if (solve(0, -1))\n    cout << \"Alice\" << endl;\n  else\n    cout << \"Bob\" << endl;\n  return 0;\n}\n\nint solve(int now, int par) {\n  int cnt = 0, res = 0;\n  for (auto to : g[now])\n    if (to != par) {\n      res ^= solve(to, now);\n      ++cnt;\n    }\n  return res + (cnt == 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define ls i<<1\n#define rs ls | 1\n#define mid ((ll+rr)>>1)\n#define pii pair<int,int>\n#define MP make_pair\ntypedef long long LL;\nconst long long INF = 1e18+1LL;\nconst double pi = acos(-1.0);\nconst int N = 1e5+10, M = 1e3+20,inf = 2e9;\n\n\n\n\nvector<int > G[N];\nint sg[N];\nvoid dfs(int u,int f) {\n    int tmp = 0,noson = 0;\n    for(int i = 0; i < G[u].size(); ++i) {\n        int to = G[u][i];\n        if(to == f) continue;\n        dfs(to,u);\n        tmp ^= 1^sg[to];\n        noson++;\n    }\n    if(noson == 1) sg[u] = 1;\n    else sg[u] = tmp;\n}\nint n;\nint main() {\n    scanf(\"%d\",&n);\n    for(int i =1; i < n; ++i) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1,0);\n    if(sg[1]) puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;}\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;}\n    return false;\n}\n\nconst int MAX_N=1e5+10;\n\nint N;\nvector<vector<int>> G(MAX_N);\nvector<int> grundy(MAX_N,0);\n\nvoid dfs(int v,int p){\n    for (auto nv:G[v]){\n        if (nv==p) continue;\n        dfs(nv,v);\n        grundy[v]^=grundy[nv]+1;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    rep(i,N-1){\n        int x,y; cin >> x >> y; --x,--y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(0,-1);\n    if (grundy[0]!=0) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint n;\nvector < int > tree[100005];\nint ddd = 0;\nbool dfs(int now, int parent);\n\nmain()\n{\n  cin >> n;\n\n  for(int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b; --a, --b;\n    tree[a].push_back(b);\n    tree[b].push_back(a);\n  }\n\n  if(dfs(0, -1) && ddd > 0) {\n    cout << \"Alice\" << endl;\n  } else {\n    cout << \"Bob\" << endl;\n  }\n\n  return (0);\n}\n  \nbool dfs(int now, int parent)\n{\n  bool ret = 0;\n  //cout << now + 1 << \" \" << parent + 1 << endl;\n  int cnt = 0; //奇数だとxorする用\n  for(int i = 0; i < tree[now].size(); i++) {\n    if(tree[now][i] != parent) {\n      cnt++;\n    }\n  }\n  for(int i = 0; i < tree[now].size(); i++) {\n    int u = tree[now][i];\n    if(u != parent) {\n      if(cnt == 1) ret |= dfs(u, now);\n      else ret ^= dfs(u, now);\n    }\n  }\n\n  if(now == 0) cout << ret << endl;\n  if(cnt == 1) ret = true;\n  else if(ret && cnt % 2) ddd++;\n  else if(cnt % 2) ret ^= true;\n  // cout << \" \" << cnt << \" \" << ret << endl;\n  return (ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint x,y,n;\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    v[x].push_back(y);\n  }\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if((int)v[i].size()%2)ans++;\n  }\n  if(ans%2||(int)v[1].size()==1)cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2&&false) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int odd = 0;\n        FORE(e, ch) odd += e % 2;\n        cout << ((((odd & 1) ^ (oneCnt & 1)) & ((N - 1 - oneCnt) & 1)) ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b)  for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n#define ll long long\n\nusing namespace std;\n\nint rez[100100];\nvector <int> child[100100];\nint par[100100];\n\nvoid dfs(int x) {\n  int out = 0;\n  REP(i, child[x].size()) {\n    int ne = child[x][i];\n    if (ne == par[x]) continue;\n    par[ne] = x;\n    dfs(ne);\n    out ^= 1 + rez[ne];\n  }\n//  if (child[x].size() == 2 && x != 0) out = 1;\n  rez[x] = out;\n  return;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    child[x].push_back(y);\n    child[y].push_back(x);\n  }\n  par[0] = -1;\n  dfs(0);\n  if (child[0].size() == 1) {\n    cout << \"Alice\\n\";\n    return 0;\n  }\n  if (rez[0] == 1) cout << \"Alice\\n\";\n  else             cout << \"Bob\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define FORD(i,b,a) for (int i = (int)(b) - 1; i >= a; --i)\n#define REP(i,N) FOR(i,0,N)\n#define st first\n#define nd second\n#define pb push_back\n\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\nint added_edge[222222];\nvector<int> adj[222222];\n\nint nim(int v, int p = -1) {\n  int result = 0;\n  for (auto u: adj[v]) if (u != p) {\n    int r = nim(u, v);\n    result ^= r + 1;\n  }\n  return result;\n}\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n\n  REP(i,N-1) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x, --y;\n    adj[x].pb(y);\n    adj[y].pb(x);\n  }\n\n  bool alice = nim(0);\n  printf(alice ? \"Alice\\n\" : \"Bob\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\n  typedef long long ll;\n  typedef pair<int,int> PII;\n  typedef pair<char,char> PCC;\n  typedef pair<ll,ll> PLL;\n  typedef pair<char,int> PCI;\n  typedef pair<int,char> PIC;\n  typedef pair<ll,int> PLI;\n  typedef pair<int,ll> PIL; \n  typedef pair<ll,char> PLC; \n  typedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\nconst int VMAX =1e5+10;\nvector<vector<int> >G(VMAX);\n\nint dfs(int v, int p){\n  int ret = 0;\n  for(const int& u:G[v]){\n    if(u==p)continue;\n    ret ^= dfs(u,v)+1;\n  }\n  return ret;\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  int V;cin >> V;\n  rep(i,V-1){\n    int x,y;cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  if(dfs(1,-1))cout << \"Alice\" << endl;\n  else cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nvector<vec>G(N);\nint dfs(int x,int p){\n  int g=0;\n  for(auto e:G[x]){\n    if(e!=p){\n    g^=(dfs(e,x)+1);}\n  }\n}\nmain(){\n    int n=in();\n  rep(i,n-1){\n  int a=in(),b=in();\n  G[a].pb(b);\n  G[b].pb(a);}\n  cout<<((dfs(1,0)!=0)?\"Alice\":\"Bob\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>graph[114514];\nusing ULL = unsigned long long;\n\nULL P = 1000000007;\nULL seed(int prev, int now)\n{\n\tvector<ULL>cash;\n\tULL ret = 1;\n\n\tfor (int ch : graph[now])\n\t{\n\t\tif (ch == prev)continue;\n\t\tcash.push_back(seed(now, ch));\n\t\tret += cash.back() * P;\n\t}\n\n\tsort(cash.begin(),cash.end());\n\n\twhile (cash.size() > 1 &&\n\t\tcash[cash.size() - 1] == cash[cash.size() - 2])\n\t{\n\t\tcash.pop_back();\n\t\tcash.pop_back();\n\t}\n\n\tif (cash.empty())\n\t{\n\t\treturn 1;\n\t}\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tULL S = seed(-1, 0);\n\n\n\n\tif (S == 1)\n\t{\n\t\tcout << \"Bob\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint main(){\n\tdouble ans;\n\tll n,A,B,C,D,flag;\n\tcin>>n>>A>>B>>C>>D;\n\tif(D*n >= ) flag = 1;\n\tif(flag) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\treturn 0;\n}\n*/\n#include<iostream> \n#include<cstdio> \n#include<cstring> \n#include<cmath> \n#include<vector> \n#include<algorithm> \n#define N 10005 \n#define LL long long \n#define inf 1<<29 \n#define eps 1e-7 \nusing namespace std; \nvector<int>v[100005]; \nint get_sg(int u,int pre){ \n    int ret=0; \n    for(int i=0;i<v[u].size();i++){ \n        if(v[u][i]!=pre) \n            ret^=(1+get_sg(v[u][i],u)); \n    } \n    return ret; \n} \nint main(){ \n    int t,n; \n  \n\tscanf(\"%d\",&n); \n    for(int i=1;i<=n;i++) \n          v[i].clear(); \n    for(int i=1;i<n;i++){ \n           int x,y; \n           scanf(\"%d%d\",&x,&y); \n            v[x].push_back(y); \n            v[y].push_back(x); \n        } \n        if(get_sg(1,-1)) \n            puts(\"Alice\"); \n        else \n            puts(\"Bob\"); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1234567;\n\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tint res = 0;\n\tfor (auto u : g[v])\n\t\tif (u != r)\n\t\t\tres ^= dfs (u, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i =  0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tcout << (dfs (0,-1)==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint sg[N],n;\nvi g[N];\n\nvoid dfs(int c,int fa=0){\n    for(auto t : g[c]) {\n        if(t == fa) continue;\n        dfs(t , c);\n        sg[c] ^= sg[t] + 1;\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    puts(sg[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstruct Tree{\n\tint V;\n\tvector<int> G[100010];\n\tint dp[100010];\n\tint dfs(int v,int p){\n\t\tdp[v] = 0;\n\t\tfor(int u: G[v]){\n\t\t\tif(u == p)continue;\n\t\t\tdp[v] ^= dfs(u,v);\n\t\t}\n\t\treturn dp[v]+1;\n\t}\n}tree;\n\nint main(){\n\tstatic int n;\n\tstatic int x[100010],y[100010];\n\tscanf(\"%d\",&n);\n\trep1(i,n-1)scanf(\"%d%d\",&x[i],&y[i]);\n\t\n\ttree.V = n;\n\trep1(i,n-1){\n\t\ttree.G[x[i]].pb(y[i]);\n\t\ttree.G[y[i]].pb(x[i]);\n\t}\n\ttree.dfs(1,0);\n\tif(tree.dp[1] == 0)puts(\"Bob\");\n\telse puts(\"Alice\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst int mod = 200003;//1e9 + 7;//786433;//998244353;//1e9 + 7\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nint g[100005];\nvector <int> Adj[100005];\n\nvoid DFS(int node, int p = -1)\n{\n\tfor(auto x : Adj[node])\n\t{\n\t\tif(x == p)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tDFS(x, node);\n\t\tg[node] ^= (g[x] + 1);\n\t}\n}\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tAdj[u].eb(v);\n\t\tAdj[v].eb(u);\n\t}\n\tDFS(1);\n\tif(g[1])\n\t{\n\t\tcout << \"Alice\";\n\t}\n\telse\n\t{\n\t\tcout << \"Bob\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nll n, x, y;\nvector<ll> e[100000];\n\nll dfs(ll x, ll par) {\n  ll ans = 0;\n  for (ll i : e[x]) if (i != par) {\n    ans = ans xor (dfs(i, x) + 1);\n  }\n  return ans;\n}\n\nint main() {\n  scanf(\"%lld\", &n);\n  for (ll i = 0; i < n-1; i++) {\n    scanf(\"%lld%lld\", &x, &y);\n    x--; y--;\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  printf(\"%s\\n\", dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * じょえチャンネル\n * 高評価・チャンネル登録よろしくおねがいします！\n * https://www.youtube.com/channel/UCRXsI3FL_kvaVL9zoolBfbQ\n */\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n\n\n\n//here!!!\n// define int long long !!!!!\n\n#define int long long\n\n// define int long long !!!!!\n\n\n#define mod 1000000007ll\n//constexpr int mod = 998244353ll;\n\ntypedef long long ll;\n\n#ifdef int\n#define inf (int)(3e18)\n#else\n#define inf (int)(5e8)\n#endif\n\n#define intt long long\n#define itn long long\n#define innt long long\n#define P pair<long long,long long>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define rev_rep(i,n) for(int i=n-1;i>=0;i--)\n#define REV_REP(i,n) for(int i=n;i>=1;i--)\n\n#define ALL(v) v.begin(),v.end()\n\n#define smallpriority_queue(x) priority_queue<x,vector<x>,greater<x>>\n\nusing namespace std;\n\n//Library\n//モッドパウ\ninline int modpow(int x, int y, int m = mod) {\n    int res = 1;\n    while (y) {\n        if (y & 1) {\n            res *= x;\n            res %= m;\n        }\n        x = x * x % m;\n        y /= 2;\n    }\n    return res;\n}\n\nint mypow(int x, int y) {\n    int res = 1;\n    while (y) {\n        if (y % 2) {\n            res *= x;\n        }\n        x = x * x;\n        y /= 2;\n    }\n    return res;\n}\n//is the number (x) a prime number?\nbool prime(int x) {\n    if (!x || x == 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= x; i++) {\n        if (!(x % i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//saidai-kouyakusuu\ninline int gcd(int x, int y) {\n    if (!y) {\n        return x;\n    }\n    return gcd(y, x % y);\n}\n\n\n//number of keta\nint keta(int x) {\n    int ans = 0;\n    while (x) {\n        x /= 10;\n        ans++;\n    }\n    return ans;\n}\n\n//number of 2shinsuu keta\nint bitketa(int x) {\n    int ans = 0;\n    while (x) {\n        x >>= 1;\n        ans++;\n    }\n    return ans;\n}\n\n//sum of keta\nint ketasum(int x) {\n    int ans = 0;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ninline int lcm(int x, int y) {\n    int ans = x / gcd(x, y) * y;\n    return ans;\n}\nint twobeki(int x) {\n    int ans = 0;\n    while (1) {\n        if (!(x & 1)) {\n            ans++;\n            x >>= 1;\n        }\n        else {\n            break;\n        }\n    }\n    return ans;\n}\n\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n    if (lhs < rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n    if (lhs > rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\nvoid Yes(){\n    cout<<\"Yes\"<<endl;\n}\nvoid No(){\n    cout<<\"No\"<<endl;\n}\nvoid YES(){\n    cout<<\"YES\"<<endl;\n}\nvoid NO(){\n    cout<<\"NO\"<<endl;\n}\n\n\n#define fin(i) scanf(\"%lld\",&i)\n#define fout(i) printf(\"%lld\",i)\n#define fendl printf(\"\\n\")\n\nint kai(int x, int y) {\n    int res = 1;\n    for (int i = x - y + 1; i <= x; i++) {\n        res *= i; res %= mod;\n    }\n    return res;\n}\n\nint comb(int x, int y) {\n    if (y > x)return 0;\n    //    cout<<kai(x, y)<<' '<<modpow(kai(y, y), mod - 2)<<endl;\n    return kai(x, y) * modpow(kai(y, y), mod - 2) % mod;\n}\n\n\n\n#define vecin(v) for(int i=0;i<v.size();i++)scanf(\"%lld\",&v[i]);\n#define vecout(v) {for(int i=0;i<(int)v.size();i++)printf(\"%lld \",v[i]);printf(\"\\n\");}\n\n\ntemplate<typename T>\nclass kaageSegTree {\nprotected:\n    unsigned int n = 1, rank = 0;\n    std::vector<T> node;\n    T nodee;\n    virtual T nodef(const T&, const T&)const = 0;\npublic:\n    kaageSegTree(unsigned int m, T init, T nodee):nodee(nodee) {\n        while (n < m) {\n            n *= 2;\n            rank++;\n        }\n        node.resize(2 * n);\n        for (unsigned int i = n; i < 2 * n; i++)node[i] = init;\n    }\n    kaageSegTree(const std::vector<T>& initvec, T nodee):nodee(nodee) {\n        unsigned int m = initvec.size();\n        while (n < m) {\n            n *= 2;\n            rank++;\n        }\n        node.resize(2 * n);\n        for (unsigned int i = n; i < 2 * n; i++) {\n            if (i - n < m)node[i] = initvec[i - n];\n        }\n    }\n    virtual void update(int i, T x) {\n        i += n;\n        node[i] = x;\n        while (i != 1) {\n            i >>= 1;\n            node[i] = nodef(node[2 * i], node[2 * i + 1]);\n        }\n    }\n    virtual T query(int l, int r) {\n        l += n; r += n;\n        T ls = nodee, rs = nodee;\n        while (l < r) {\n            if (l & 1) {\n                ls = nodef(ls, node[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                rs = nodef(node[r], rs);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return nodef(ls, rs);\n    }\n    virtual T operator[](const int& x) {\n        return node[n + x];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n};\nclass RSQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return lhs+rhs;}\npublic:\n    RSQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, 0) {}\n    RSQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, 0) {}\n};\nclass RMiQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return std::min(lhs,rhs);}\npublic:\n    RMiQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, inf) {}\n    RMiQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, inf) {}\n};\nclass RMaQ :public kaageSegTree<int> {\n    int nodef(const int& lhs,const int& rhs)const{return std::max(lhs,rhs);}\npublic:\n    RMaQ(int size, const int& def = 0) :kaageSegTree<int>(size, def, -inf) {}\n    RMaQ(const std::vector<int>& initvec) :kaageSegTree<int>(initvec, -inf) {}\n};\ntemplate<typename T, typename U>\nclass IntervalSegTree :public kaageSegTree<T> {\nprotected:\n    using kaageSegTree<T>::n;\n    using kaageSegTree<T>::rank;\n    using kaageSegTree<T>::node;\n    using kaageSegTree<T>::nodef;\n    using kaageSegTree<T>::nodee;\n    std::vector<U> lazy;\n    std::vector<bool> lazyflag;\n    std::vector<int> width;\n    virtual void lazyf(U&, const U&) = 0;\n    virtual void updf(T&, const U&, const unsigned int&) = 0;\n    void eval(int k) {\n        for (int i = rank; i > 0; i--) {\n            int nk = k >> i;\n            if (lazyflag[nk]) {\n                updf(node[2 * nk], lazy[nk], width[2 * nk]);\n                updf(node[2 * nk + 1], lazy[nk], width[2 * nk + 1]);\n                if (lazyflag[2 * nk])lazyf(lazy[2 * nk], lazy[nk]);\n                else lazy[2 * nk] = lazy[nk];\n                if (lazyflag[2 * nk + 1])lazyf(lazy[2 * nk + 1], lazy[nk]);\n                else lazy[2 * nk + 1] = lazy[nk];\n                lazyflag[2 * nk] = lazyflag[2 * nk + 1] = true;\n                lazyflag[nk] = false;\n            }\n        }\n    }\npublic:\n    IntervalSegTree(unsigned int m, T init, T nodee) :kaageSegTree<T>(m, init, nodee) {\n        lazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n        width[1] = n;\n        for (unsigned int i = 2; i < 2 * n; i++) {\n            width[i] = width[i >> 1] >> 1;\n        }\n    }\n    IntervalSegTree(T nodee, const std::vector<T>& initvec) :kaageSegTree<T>(initvec, nodee) {\n        lazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n        width[1] = n;\n        for (unsigned int i = 2; i < 2 * n; i++) {\n            width[i] = width[i >> 1] >> 1;\n        }\n    }\n    void update(int i, U x) {\n        i += n;\n        eval(i);\n        updf(node[i], x, width[i]);\n        if (lazyflag[i])lazyf(lazy[i], x);\n        else {\n            lazyflag[i] = true;\n            lazy[i] = x;\n        }\n        while (i /= 2)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    void update(int l, int r, U x) {\n        l += n; r += n;\n        int nl = l, nr = r;\n        while (!(nl & 1))nl >>= 1;\n        while (!(nr & 1))nr >>= 1;\n        nr--;\n        eval(nl); eval(nr);\n        while (l < r) {\n            if (l & 1) {\n                updf(node[l], x, width[l]);\n                if (lazyflag[l])lazyf(lazy[l], x);\n                else {\n                    lazyflag[l] = true;\n                    lazy[l] = x;\n                }\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                updf(node[r], x, width[r]);\n                if (lazyflag[r])lazyf(lazy[r], x);\n                else {\n                    lazyflag[r] = true;\n                    lazy[r] = x;\n                }\n            }\n            l >>= 1; r >>= 1;\n        }\n        while (nl >>= 1)node[nl] = nodef(node[2 * nl], node[2 * nl + 1]);\n        while (nr >>= 1)node[nr] = nodef(node[2 * nr], node[2 * nr + 1]);\n    }\n    T query(int l, int r) {\n        l += n; r += n;\n        eval(l); eval(r - 1);\n        int ls = nodee, rs = nodee;\n        while (l < r) {\n            if (l & 1) {\n                ls = nodef(ls, node[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                rs = nodef(node[r], rs);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return nodef(ls, rs);\n    }\n    T operator[](const int& x) {\n        eval(n + x);\n        return node[n + x];\n    }\n    T queryForAll() {\n        return node[1];\n    }\n};\nclass RAQRSQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return a + b; }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += width * b; }\npublic:\n    RAQRSQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, 0) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRSQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>((int)0, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RAQRMiQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::min(a, b); }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += b; }\npublic:\n    RAQRMiQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRMiQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RAQRMaQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::max(a, b); }\n    void lazyf(int& a, const int& b) { a += b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a += b; }\npublic:\n    RAQRMaQ(unsigned int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, -inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RAQRMaQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(-inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRSQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return a + b; }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = width * b; }\npublic:\n    RUQRSQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, 0) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRSQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>((int)0, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRMiQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::min(a, b); }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n    RUQRMiQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRMiQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\nclass RUQRMaQ :public IntervalSegTree<int, int> {\n    int nodef(const int& a, const int& b)const { return std::max(a, b); }\n    void lazyf(int& a, const int& b) { a = b; }\n    void updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n    RUQRMaQ(int size, const int& def = 0) :IntervalSegTree<int, int>(size, def, -inf) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n    RUQRMaQ(const std::vector<int>& initvec) :IntervalSegTree<int, int>(-inf, initvec) {\n        for (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n    }\n};\n\n////SegTree\n//template <class T>\n//class SegTree {\n//    int n;                       // 葉の数\n//    vector<T> node;              // データを格納するvector\n//    T def;                       // 初期値かつ単位元\n//    function<T(T, T)> operation; // 区間クエリで使う処理\n//    function<T(T, T)> update;    // 点更新で使う処理\n//\n//    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n//    T _query(int a, int b, int k, int l, int r) {\n//        if (r <= a || b <= l) return def; // 交差しない\n//        if (a <= l && r <= b)\n//            return node[k]; // a,l,r,bの順で完全に含まれる\n//        else {\n//            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n//            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n//            return operation(c1, c2);\n//        }\n//    }\n//\n//public:\n//    // _n:必要サイズ, _def:初期値かつ単位元, _operation:クエリ関数,\n//    // _update:更新関数\n//    SegTree(size_t _n, T _def, function<T(T, T)> _operation,\n//            function<T(T, T)> _update)\n//    : def(_def), operation(_operation), update(_update) {\n//        n = 1;\n//        while (n < _n) {\n//            n *= 2;\n//        }\n//        node = vector<T>(2 * n , def);\n//    }\n//\n//    // 場所i(0-indexed)の値をxで更新\n//    void change(int i, T x) {\n//        i += n - 1;\n//        node[i] = update(node[i], x);\n//        while (i > 0) {\n//            i = (i - 1) / 2;\n//            node[i] = operation(node[i * 2 + 1], node[i * 2 + 2]);\n//        }\n//    }\n//\n//    // [a, b)の区間クエリを実行\n//    T query(int a, int b) {\n//        return _query(a, b, 0, 0, n);\n//    }\n//\n//    // 添字でアクセス\n//    T operator[](int i) {\n//        return node[i + n - 1];\n//    }\n//};\n\ntemplate <class T>\nclass SegTree {\n    int n;\n    vector<T> node;\n    T def;\n    function<T(T,T)> operation;\n    function<T(T,T)> update;\n    \npublic:\n    SegTree(unsigned int _n, T _def, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    : def(_def), operation(_operation), update(_update) {\n        n=1;\n        while (n < _n) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n    }\n    SegTree(vector<int>& initvec, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    :  operation(_operation), update(_update) {\n        n=1;\n        while (n < initvec.size()) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n        for(int i=n;i<n+initvec.size();i++){\n            node[i]=initvec[i-n];\n        }\n        for(int i=n-1;i>=1;i--){\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    void change(int i,T x){\n        i+=n;\n        node[i]=update(node[i],x);\n        while (i>=1) {\n            i>>=1;\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    T query(int l, int r){\n        l+=n;\n        r+=n;\n        T rx=def,lx=def;\n        while(l<r){\n            if (l&1) {\n                lx=operation(lx,node[l]);\n                l++;\n            }\n            if (r&1) {\n                r--;\n                rx=operation(node[r],rx);\n            }\n            l>>=1; r>>=1;\n        }\n        return operation(lx,rx);\n    }\n    T operator [] (const int& x){\n        return node[x+n];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n    \n};\n\n#define R_MIN ([](long long a, long long b) { return min(a, b); })\n#define R_MAX ([](long long a, long long b) { return max(a, b); })\n#define R_SUM ([](long long a, long long b) { return a + b; })\n\n#define NORMAL_UPDATE ([](long long a, long long b) { return b; })\n#define ADD_UPDATE ([](long long a, long long b) { return a + b; })\n#define MINUS_UPDATE ([](long long a, long long b) { return a - b; }\n\nclass Union_Find {\n    vector<int> par;\n    vector<int> rankmy;\n    vector<int> ookisa;\n    \npublic:\n    Union_Find(int size) {\n        par = vector<int>(size);\n        rankmy = vector<int>(size);\n        ookisa=vector<int>(size);\n        for (int i = 0; i < size; i++) {\n            par[i] = i;\n            ookisa[i]=1;\n        }\n    }\n    \n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n    \n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return;\n        }\n        if (rankmy[x] < rankmy[y]) {\n            par[x] = y;\n            ookisa[y]+=ookisa[x];\n            ookisa[x]=0;\n        }\n        else {\n            par[y] = x;\n            ookisa[x]+=ookisa[y];\n            ookisa[y]=0;\n            if (rankmy[x] == rankmy[y]) {\n                rankmy[x]++;\n            }\n        }\n    }\n    int size(int i){\n        i=find(i);\n        return ookisa[i];\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n};\n\nclass BIT {\n    vector<int> data;\n    int size=0;\npublic:\n    BIT(int _size){\n        data=vector<int>(_size+1);\n        size=_size;\n    }\n    void add(int i,int x){\n        while (i<=size) {\n            data[i]+=x;\n            i += i & -i;\n        }\n    }\n    int sum(int i){\n        assert(i<=size);\n        int s=0;\n        while(i>0){\n            s+=data[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    int lower_bound(int x){\n        if(x<=0){\n            return 0;\n        }else{\n            int i=0;int r=1;\n            while(r<size) r=r<<1;\n            for(int len=r;len>0;len=len>>1) {\n                if(i+len<size && data[i+len]<x){\n                    x-=data[i+len];\n                    i+=len;\n                }\n            }\n            return i+1;\n        }\n    }\n};\n\n//Union-Find-End\n\nint perm[2000005];\nvoid init_perm() {\n    perm[0] = 1;\n    REP(i, 2000004) {\n        perm[i] = perm[i - 1] * i % mod;\n    }\n}\n\nint nCk(int x, int y) {\n    if (y>x) {\n        return 0;\n    }\n    if (x<0) {\n        return 0;\n    }\n    return perm[x] * modpow(perm[x - y], mod - 2) % mod * modpow(perm[y], mod - 2) % mod;\n}\n\ndouble kyori(pair<int, int> f, pair<int, int> s) {\n    double ans = 0;\n    double t = fabs(f.first - s.first);\n    double y = fabs(f.second - s.second);\n    ans = sqrt(t * t + y * y);\n    return ans;\n}\n\ninline string stringmax(string& x,string& y){\n    if (x.size()>y.size()) {\n        return x;\n    }\n    if (x.size()<y.size()) {\n        return y;\n    }\n    rep(i,x.size()){\n        if (x[i]>y[i]) {\n            return x;\n        }\n        if (x[i]<y[i]) {\n            return y;\n        }\n    }\n    return x;\n}\n\n//vector<int>  RollingHash(string &s, string& t){\n//    vector<int> ans;\n//    __int128 h=0,hamod=0,ki=0,kim=0,hikaku=0,one=0;\n//    one=1;\n//    ki=1000000007ll;\n//    hamod=(one<<61)-1;\n//    kim=1;\n//    rep(i,t.size()){\n//        hikaku*=ki;\n//        h*=ki;\n//        kim*=ki;\n//        hikaku+=t[i];\n//        h+=s[i];\n//        hikaku%=hamod;\n//        h%=hamod;\n//        kim%=hamod;\n//    }\n//    rep(i,(int)s.size()-(int)t.size()+1){\n//        if (h==hikaku) {\n//            ans.emplace_back(i);\n//        }\n//        h*=ki;\n//        h%=hamod;\n//        h+=s[i+(int)t.size()];\n//        h%=hamod;\n//        h+=hamod;\n//        h-=s[i]*kim%hamod;\n//        h%=hamod;\n//    }\n//    return ans;\n//}\nstruct edge {\n    int to;\n    int length;\n    edge(int _to, int _length){\n        to=_to;\n        length=_length;\n    }\n};\nvector<int> djkstra(vector<vector<edge>> &road,int start){\n    vector<int> kyo(road.size(),inf);\n    smallpriority_queue(P) q;\n    q.push({0,start});\n    kyo[start]=0;\n    while (q.size()) {\n        int x=q.top().second;\n        itn now=q.top().first;\n        q.pop();\n        if (kyo[x]<now) {\n            continue;\n        }\n        for(auto&i:road[x]){\n            if (kyo[i.to]>now+i.length) {\n                kyo[i.to]=now+i.length;\n                q.push({kyo[i.to],i.to});\n            }\n        }\n    }\n    return kyo;\n}\n\ntemplate <class T>\nvoid change_to_unique(vector<T> &v){\n    std::sort(ALL(v));\n    auto k=unique(ALL(v));\n    if(k!=v.end())v.erase(k,v.end());\n}\n\n#define endl \"\\n\" //interactive の時に注意！！！\n#define Endl \"\\n\" //interactive の時に注意！！！\n#define printd cout<<fixed<<setprecision(10)\n#define rrep(i,f,s) for(int i=f;i<s;i++)\n#define RREP(i,f,s) for(int i=f;i<=s;i++)\n/*------------------Library Zone!------------------*/\n\nint n,x[100004],y[100004],ans;\nvector<itn> road[100004];\nint solve(int x,int par){\n    int now=0;\n    for(auto&i:road[x]){\n        if (i==par) {\n            continue;\n        }\n        now^=solve(i,x)+1;\n    }\n    return (now!=0);\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    cin>>n;\n    rep(i,n-1){\n        cin>>x[i]>>y[i];\n        road[x[i]].emplace_back(y[i]);\n        road[y[i]].emplace_back(x[i]);\n    }\n    if (solve(1, 0)) {\n        cout<<\"Alice\"<<endl;\n    }else{\n        cout<<\"Bob\"<<endl;\n    }\n}\n \n \n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y){ return y > x ? x = y, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &x, const T &y){ return y < x ? x = y, 1 : 0; }\n\n#ifdef ONLINE_JUDGE\n#define debug(...) ;\n#else\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define DEBUG\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 2e5 + 100;\n\nint n;\nint sg[maxn];\nvi g[maxn];\n\nvoid dfs(int u, int p)\n{\n\tsg[u] = 0;\n\tfor(int v: g[u]) if(v != p) dfs(v, u), sg[u] ^= (sg[v] + 1);\n\treturn;\n}\n\nint main()\n{\n\tscf(n);\n\trep(i, n - 1)\n\t{\n\t\tint u, v; scf(u, v);\n\t\tg[u].pb(v); g[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\ntemplate<class T>\nvoid read_1d(std::vector<T>& a,int64_t num){\n\ta.reserve(num);\n\tfor(int64_t i1=0;i1<num;i1++){\n\t\tT temp;\n\t\tcin>>temp;\n\t\ta.push_back(temp);\n\t}\n}\ntemplate<class T>\nvoid read_2d(std::vector<std::vector<T> >&a,int64_t x,int64_t y ){\n\ta.resize(x);\n\tfor(int64_t i1=0;i1<x;i1++){\n\t\ta[i1].reserve(y);\n\t\tfor(int64_t i2=0;i2<y;i2++){\n\t\t\tT temp;\n\t\t\tcin>>temp;\n\t\t\ta[i1].push_back(temp);\n\t\t}\n\t}\n}\ntemplate<class InputIterator>\nvoid debug(InputIterator first,InputIterator last){\n\tfor(auto i1=first;i1!=last;i1++){\n\t\tcout<<(*i1)<<endl;\n\t}\n}\n#include <limits>\n#include <vector>\n#include <queue>\nclass Vertex;\nclass Edge{\npublic:\n\tfriend class Vertex;\n\tfriend class Graph;\n\tVertex* from;\n\tVertex* to;\n\tint64_t cost;\npublic:\n\tEdge(Vertex* from,Vertex* to,int64_t cost=0){\n\t\tthis->from=from;\n\t\tthis->to=to;\n\t\tthis->cost=cost;\n\t}\n\n};\nstruct Dijkstra{\n\tint64_t d;\n\tVertex* parent;\n\tbool searched;\n};\n\nclass Vertex{\n\tfriend class Graph;\npublic:\n\n\tstd::vector<Edge*> departure;\n\tstd::vector<Edge*> arrival;\n\tbool searched=false;\n\n\tDijkstra dijk_data;\n\tint32_t id;\n\tbool count_finish=false;\n\tvoid add_edge(Edge* d){\n\t\tdeparture.push_back(d);\n\t\td->to->arrival.push_back(d);\n\t}\n\tvoid initialize_Dijkstra(){\n\t\tdijk_data.d=std::numeric_limits<int64_t>::max();\n\t\tdijk_data.parent=NULL;\n\t\tdijk_data.searched=false;\n\t}\n\tint32_t count_union(Edge* e1,Edge* e2){\n\t\tint32_t retval=1;\n\t\tcount_finish=true;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(temp==e1||temp==e2||temp->to->count_finish){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tretval+=temp->to->count_union(e1,e2);\n\t\t}\n\t\treturn retval;\n\t}\n\tint64_t game(){\n\t\tsearched=true;\n\t\tint64_t size=0;\n\t\tint64_t xor_num=0;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(!temp->to->searched){\n\t\t\t\tsize++;\n\t\t\t\tint64_t c_ans=temp->to->game();\n\t\t\t\txor_num=xor_num^c_ans;\n\t\t\t}\n\t\t}\n\t\tif(size==0){\n\t\t\treturn 1;\n\t\t}else if(size==1){\n\t\t\treturn xor_num+1;\n\t\t}else if(xor_num==0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 2;\n\t\t}\n\t}\n};\nclass dijkstra_calc{\npublic:\n\tint64_t current_cost;\n\tVertex* from;\n\tVertex* to;\n\tdijkstra_calc(const int64_t cost, Vertex* c1,Vertex* c2):current_cost(cost),from(c1),to(c2){\n\n\t}\n};\nbool operator<(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost<b.current_cost;\n}\nbool operator>(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost>b.current_cost;\n}\n\n\nclass Graph{\nprivate:\n\tstd::vector<Vertex*> v;\n\tstd::vector<Edge*> e;\n\tint64_t **WF;\n\tvoid initialize_Dijkstra(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tVertex *temp=(*i);\n\t\t\ttemp->initialize_Dijkstra();\n\t\t}\n\t}\n\tstatic void dijkstra(Vertex* source,Vertex* goal=NULL){\n\t\tstd::priority_queue<dijkstra_calc,std::vector<dijkstra_calc>,std::greater<dijkstra_calc> > queue;\n\t\tqueue.push(dijkstra_calc(0,NULL,source));\n\t\twhile(true){\n\t\t\tconst dijkstra_calc temp=queue.top();\n\t\t\tqueue.pop();\n\t\t\tif(!(temp.to->dijk_data.searched)){\n\t\t\t\ttemp.to->dijk_data.searched=true;\n\t\t\t\ttemp.to->dijk_data.parent=temp.from;\n\t\t\t\ttemp.to->dijk_data.d=temp.current_cost;\n\n\t\t\t\tfor(auto i=temp.to->departure.begin();i!=temp.to->departure.end();i++){\n\t\t\t\t\tconst Edge *j=(*i);\n\t\t\t\t\tif(!j->to->dijk_data.searched){\n\t\t\t\t\t\tdijkstra_calc a(temp.current_cost+(j->cost),j->from,j->to);\n\t\t\t\t\t\tqueue.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.to==goal){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue.empty()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tstatic const int64_t INF=1000000000000000;\n\tGraph(int32_t num_v){\n\t\tv.reserve(num_v);\n\t\tfor(int32_t i1=0;i1<num_v;i1++){\n\t\t\tVertex* temp=new Vertex();\n\t\t\ttemp->id=i1;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\tWF=new int64_t*[num_v];\n\t\tfor(int64_t i1=0;i1<num_v;i1++){\n\t\t\tWF[i1]=new int64_t[num_v];\n\t\t}\n\t}\n\tvoid add_edge(int32_t from,int32_t to,int32_t cost=0){\n\t\tEdge *temp=new Edge(v[from],v[to],cost);\n\t\te.push_back(temp);\n\t\tv[from]->add_edge(temp);\n\t}\n\tvoid dijkstra(int32_t start){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start]);\n\t}\n\tvoid dijkstra(int32_t start,int32_t goal){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start],v[goal]);\n\t}\n\tint64_t** WarshallFloid(){\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tWF[i1][i2]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(auto i2=v[i1]->departure.begin();i2!=v[i1]->departure.end();i2++){\n\t\t\t\tEdge *temp=(*i2);\n\t\t\t\tif(WF[i1][temp->to->id]>temp->cost){\n\t\t\t\t\tWF[i1][temp->to->id]=temp->cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tWF[i1][i1]=0;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tfor(int64_t i3=0;i3<v.size();i3++){\n\t\t\t\t\tWF[i2][i3]=min(WF[i2][i3],WF[i2][i1]+WF[i1][i3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn WF;\n\t}\n\tVertex* getVertex(int place) const{\n\t\treturn v[place];\n\t}\n\tbool isBridge(Edge* e1,Edge* e2){\n\t\tfor(auto i1=v.begin();i1!=v.end();i1++){\n\t\t\tVertex* temp=(*i1);\n\t\t\ttemp->count_finish=false;\n\t\t}\n\t\tint32_t r=v[0]->count_union(e1,e2);\n\t\treturn v.size()!=r;\n\t}\n\tvector<Edge*> getEdge(){\n\t\treturn e;\n\t}\n\tvirtual ~Graph(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(auto i=e.begin();i!=e.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tdelete[] WF[i1];\n\t\t}\n\t\tdelete[] WF;\n\t}\n};\nint main(){\n\tint64_t n;\n\tcin>>n;\n\tGraph graph(n);\n\tfor(int64_t i1=0;i1<n-1;i1++){\n\t\tint64_t temp1,temp2;\n\t\tcin>>temp1>>temp2;\n\t\tgraph.add_edge(temp1-1,temp2-1);\n\t\tgraph.add_edge(temp2-1,temp1-1);\n\t}\n\tif(graph.getVertex(0)->departure.size()==1){\n\t\tcout<<\"Alice\"<<endl;\n\t}else{\n\t\tif(graph.getVertex(0)->game()==1){\n\t\t\tcout<<\"Bob\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Alice\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int N = 100000 + 10;\n\nint n;\nstd::vector<int> adj[N];\n\nint dfs(int a, int fa = -1) {\n  int res = 0;\n  for (auto b : adj[a]) if (b != fa) res ^= dfs(b, a) + 1;\n  return res;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = n - 1; i--;) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  puts(dfs(1) ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, l, r) for (int i = (int)(l); i < (int)(r); i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)x.size())\ntemplate <class T> bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <class T> using V = vector<T>;\nusing P = pair<int, int>;\n\n/*\n */\n\nint n;\nV<int> es[101010];\n\nint dfs(int v, int p){\n  set<int> s;\n  for(int to : es[v]){\n    if(to == p) continue;\n    s.insert(dfs(to, v));\n  }\n\n  int res = 0;\n  while(s.count(res)) res++;\n  return res;\n}\n\nsigned main() {\n  cin >> n;\n  rep(i, 0, n-1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    es[x].emplace_back(y);\n    es[y].emplace_back(x);\n  }\n\n  int g = 0;\n  for(int to : es[0]){\n    g ^= dfs(to, 0);\n  }\n\n  cout << (g ? \"Alice\" : \"Bob\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint sg[MAXN];\nvector<int> E[MAXN];\n\nvoid dfs(int u, int fa){\n\tsg[u] = 0;\n\tfor (int v, i = 0; i < E[u].size(); i++){\n\t\tif ((v = E[u][i]) != fa){\n\t\t\tdfs(v, u);\n\t\t\tsg[u] ^= (sg[v] + 1);\n\t\t}\n\t}\n}\n\nvoid solve(int casi){\n//\tcout << \"Case #\" << casi << \": \";\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tputs(sg[1] ? \"Alice\" : \"Bob\");\n}\n\nvoid printans(){\n\n}\n\nint main(){\n//\tstd::ios::sync_with_stdio(false);\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#define inf 20021225\n#define ll long long\n#define N 100010\nusing namespace std;\nint read()\n{\n\tint f=1,s=0; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn f*s;\n}\nstruct edge{int to,lt;}e[N<<1];\nint f[N],in[N],cnt,n;\nvoid add(int x,int y)\n{\n\te[++cnt].to=y; e[cnt].lt=in[x]; in[x]=cnt;\n\te[++cnt].to=x; e[cnt].lt=in[y]; in[y]=cnt;\n}\nvoid dfs(int x,int fr)\n{\n\tfor(int i=in[x];i;i=e[i].lt)\n\t{\n\t\tint y=e[i].to; if(y==fr)\tcontinue;\n\t\tdfs(y,x); f[x]^=(f[y]+1);\n\t}\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\tadd(read(),read());\n\tdfs(1,0); puts(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*-----8<-----library-----8<-----*/\n\nll dfs(vector<vector<ll>> &g, ll v, ll p) {\n\tvector<ll> a;\n\tfor(ll nextv : g[v]){\n\t\tif(nextv==p) continue;\n\t\tll t=dfs(g, nextv, v);\n\t\ta.push_back(1+t);\n\t}\n\n\tif(a.size()==0)return 0;\n\tll ans=0;\n\tfor(ll t:a){\n\t\tans^=t;\n\t}\n\treturn ans;\n\t\n}\nvoid solve() {\n\tll N;\n\tcin>>N;\n\tvector<vector<ll>> g(N);\n\trep(i,N-1){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll x=dfs(g,0,-1);\n\tif(x)p(\"Alice\");\n\telse p(\"Bob\");\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\n\nint dfs(vector<vi>& g, int x, int p) {\n\tint res = 0;\n\tfor (auto w : g[x])\n\t{\n\t\tif (w != p) res ^= dfs(g, w, x) + 1;\n\t}\n\treturn res;\n}\n\nint main() \n{\n\tcin >> n;\n\tvector<vi> g(n);\n\tREP(i, n - 1)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tif (dfs(g, 0, -1) != 0) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define all(a) a.begin(), a.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nusing namespace std;\ntypedef long long ll;\n\nvector<int> tree[100000];\nint dfs(int v, int p){\n    int res = 0, cnt = 0;\n    for(int u : tree[v])if(u != p){\n        res ^= dfs(u, v);\n        cnt++;\n    }\n    return (cnt == 1 ? 1 : 0) + res;\n}\n\nint main(){\n\n    int N;\n    cin >> N;\n\n    rep(i, N - 1){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n    }\n\n    cout << (dfs(0, -1) ? \"Alice\\n\" : \"Bob\\n\");\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nll mh[101010];\n\nll tree_normalize(set<ll> T) {\n\tstatic ll momo[2]={1000000007,1000000009};\n\tstatic vector<ll> prim = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79};\n\t\n\tint id=0,id2=1;\n\tll a=1,b=1;\n\tFORR(r,T) {\n\t\tll h=r>>32, l=r-(h<<32);\n\t\t(a+=h*prim[(id++)%prim.size()])%=momo[0];\n\t\t(b+=l*prim[(id2++)%prim.size()])%=momo[1];\n\t}\n\treturn (a<<32)+b;\n}\n\nvoid dfs(int cur,int pre) {\n\tset<ll> hh;\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tif(hh.count(mh[e])) hh.erase(mh[e]);\n\t\telse hh.insert(mh[e]);\n\t}\n\t\n\tif(cur==0) {\n\t\tif(hh.size()) cout<<\"Alice\"<<endl;\n\t\telse cout<<\"Bob\"<<endl;\n\t}\n\t\n\tmh[cur]=tree_normalize(hh);\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tdfs(0,0);\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cmath>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 100050\n#define ll long long\n#define inf int(1e9)\n#define mm 1000000007\n#define low(x) x&(-x)\nusing namespace std;\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nstruct data{int obj,pre;\n}e[maxn*2];\nint head[maxn],sg[maxn],flag[maxn],n,tot;\nvoid insert(int x,int y){\n\te[++tot].obj=y; e[tot].pre=head[x]; head[x]=tot;\n}\nvoid dfs(int u,int f){\n\tint ans=0; sg[u]=0;\n\tfor (int j=head[u];j;j=e[j].pre){\n\t\tint v=e[j].obj;\n\t\tif (v!=f) {\n\t\t\tdfs(v,u); ans=ans^(sg[v]+1);\n\t\t}\n\t}\n\tsg[u]=ans;\n}\nint main(){\n\tn=read();\n\trep(i,1,n-1){\n\t\tint x=read(),y=read();\n\t\tinsert(x,y); insert(y,x);\n\t}\n\tdfs(1,0);\n\tif (sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\nint N;\nvector<vector<int>> tree;\n\nint dfs(int v = 0, int p = -1) {\n    int ret = 0;\n    for (auto c : tree[v]) {\n        if (c != p) {\n            int tmp = dfs(c, v);\n            ret ^= (tmp + 1);\n        }\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    cin >> N;\n    tree.resize(N);\n    REP(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    int g = dfs();\n    if (g == 0) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n\n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint N;\nvi adj[100001];\n\nint dfs(int p, int node) {\n    int win = 0;\n    for (int i: adj[node]) if (i != p) win ^= (dfs(node,i)+1);\n    return win;\n}\n\nint main() {\n\tcin >> N;\n\tF0R(i,N-1) {\n\t    int a,b; cin >> a >> b;\n\t    adj[a].pb(b);\n\t    adj[b].pb(a);\n\t}\n\tif (dfs(0,1) != 0) cout << \"Alice\";\n\telse cout << \"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn (rand()<<16|rand())%x;\n}\nconst int N=100005;\nint n;\nvector<int> v[N];\nint dfs(int p,int fa){\n\t//if(fa)cout<<p<<\" \"<<*lower_bound(v[p].begin(),v[p].end(),fa)<<\" \"<<fa<<endl;\n\tint son=v[p].size()-(fa>0);\n\tif(son==0)return 0;\n\tint sum=0;\n\tfor(unsigned i=0;i<v[p].size();i++)if(v[p][i]!=fa){\n\t\tif(son>1)sum^=dfs(v[p][i],p);\n\t\telse {return dfs(v[p][i],p)+1;}\n\t}\n\t//cout<<p<<\" \"<<sum<<endl;\n\treturn sum;\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint s=read(),t=read();\n\t\tv[s].push_back(t); v[t].push_back(s);\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nvector <int> tr[N];\nint p[N], SG[N];\n\nvoid dfs(int x, int f){\n\tp[x] = f;\n\tfor (int i = 0; i < (int)tr[x].size(); i++){\n\t\tif (tr[x][i] == f) continue;\n\t\tdfs(tr[x][i], x);\n\t\tSG[x] ^= SG[tr[x][i]] + 1;\n\t}\n}\n\nint main(){\n\tint n, u, v;\n\tscanf(\"%d\",&n);\n\tfor (int i = 1; i <= n - 1; i++){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tmemset(SG, 0, sizeof(SG));\n\tdfs(1, 0);\n\tif (SG[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\n\nvector<int> G[100020];\n\nint dfs(int r,int p){\n\tint d=0;\n\tfor(auto v:G[r])if(v!=p){\n\t\td^=1+dfs(v,r);\n\t}\n\treturn d;\n}\n\nsigned main(){\n\n   cin.tie(0);\n\tios::sync_with_stdio(false);\nint n;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\tG[y].pb(yy);\n\t\tG[yy].pb(y);\n\t}\n\t\n\tif(dfs(1,1))cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/ACM/output.txt\", \"w\", stdout);\n  //freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n    //cout << \"Case #\" << testNum++ << \": \";\n    //cerr << testNum << endl;\n    solve(true);\n    //cerr << testNum - 1 << endl;\n  }\n  cout.flush();\n#ifdef AIM1\n  while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\n//#define int li\n//const int mod = 1000000007;\n\nvector<vector<int>> g;\n\nint dfs(int v, int p) {\n  int res = 0;\n  for (int to : g[v]) {\n    if (to == p) {\n      continue;\n    }\n    res ^= (1 + dfs(to, v));\n  }\n  return res;\n}\n\nvoid solve(bool read) {\n  int n;\n  cin >> n;\n  g.resize(n);\n  for (int i = 1; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a; --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  int res = dfs(0, 0);\n  if (res) {\n    cout << \"Alice\\n\";\n  } else {\n    cout << \"Bob\\n\";\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nll d[1000000];\n\nvoid addedge(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\n//根付き木を作る。parentVectorに親nodeの番号が入る。\n//parentVector[root] = -1\n//treeRankVectorにはnodeのrankが入る。rootのrankは0\nvector<ll> par;\nvector<ll> treeRank;\nvoid makeRootedTree(vector<ll> &parentVector, vector<ll> &treeRankVector, ll vecSize, ll root) {\n    parentVector = vector<ll>(vecSize);\n    treeRankVector = vector<ll>(vecSize);\n    assert(root < (ll)parentVector.size());\n    parentVector[root] = -1;\n    treeRankVector[root] = 0;\n    queue<ll> que;\n    que.push(root);\n    while (!que.empty()) {\n        ll node = que.front();\n        que.pop();\n        REP (i, 0, G[node].size()) {\n            edge e = G[node][i];\n            if (e.to != parentVector[node]) {\n                parentVector[e.to] = node;\n                treeRankVector[e.to] = treeRankVector[node] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nvector<ll> grundy;\n//根付き木の葉から根に向かって何か処理をする\nvoid leafToRoot(vector<ll> &parentVector, ll root) {\n    queue<ll> que;\n    vector<ll> used(parentVector.size());\n    fill(used.begin(), used.end(), 0);\n    REP(i, 0, parentVector.size()) {\n        if (i != root && G[i].size() == 1) {\n            que.push(i);\n            used[i] = 1;\n        }\n    }\n    grundy = vector<ll>(parentVector.size(), 0);\n    while (!que.empty()) {\n        ll node = que.front();\n        que.pop();\n\n        //rootも含めて子だけのときに何かやりたいときはここに書く\n\n        if (node == root) {\n            break;\n        }\n        ll parent = parentVector[node];\n        used[parent]++;\n\n        //ここに書く\n        grundy[parent] ^= grundy[node] + 1;\n\n        if ((parent == root && used[parent] == (ll)G[parent].size()) ||\n            (parent != root && used[parent] == (ll)G[parent].size() - 1)) {\n            que.push(parent);\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    V = N;\n    REP(i, 0, N - 1) {\n        ll x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        addedge(x, y, 1);\n        addedge(y, x, 1);\n    }\n    makeRootedTree(par, treeRank, N, 0);\n    leafToRoot(par, 0);\n    ll ans = grundy[0];\n    if (ans != 0) {\n        cout << \"Alice\" << endl;\n    } else {\n        cout << \"Bob\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll N;\nll v[100009];\nstring calc() {\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        v[a]++;\n        v[b]++;\n    }\n\n    if (v[1] == 1) {\n        return \"Alice\";\n    } else {\n        if (v[1] == 2) {\n            if ((N) & 1) {\n                return \"Alice\";\n            } else return \"Bob\";\n        } else {\n            // v[1] == 3\n            return \"Alice\";\n        }\n    }\n\n}\n\nint main () {\n    cout << calc() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, ta, tb;\nvector< int > x[100005];\n\nint dfs(int a, int b) {\n\tint re = 0;\n\tfor (int i = 0; i < x[a].size(); i++)\n\t\tif (x[a][i] != b)\n\t\t\tre ^= dfs(x[a][i], a) + 1;\n\treturn re;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tx[ta].push_back(tb);\n\t\tx[tb].push_back(ta);\n\t}\n\tprintf(dfs(1, 0) ? \"Alice\\n\" : \"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, X, Y;\nvector<ll> E[100000];\n\nll dfs(ll v, ll p) {\n  ll sum = 1;\n  for(ll u : E[v]) if(u != p) sum += dfs(u, v);\n  return sum;\n}\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N - 1) {\n    cin >> X >> Y; X--; Y--;\n    E[X].push_back(Y);\n    E[Y].push_back(X);\n  }\n\n  ll cnt = 0;\n  for(ll v : E[0]) if(dfs(v, 0) % 2 == 0) cnt++;\n  cout << (cnt % 2 == 0 ? \"Bob\" : \"Alice\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(t[i]%2&&b[i]){\n      ans++;\n    }\n  }\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#include<math.h>\n#include<memory>\n#include<vector>\n#include<bitset>\n#include<fstream>\n#include<stdio.h>\n#include<utility>\n#include<sstream>\n#include<string.h>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nstruct edge\n{\n    int y;\n    edge * next;\n};\nedge * li[100005];\nedge * new_edge()\n{\n    static edge a[200005];\n    static int top=0;\n    return &a[top++];\n}\nvoid inserts(int x,int y)\n{\n    edge * t=new_edge();\n    t->y=y;\n    t->next=li[x];\n    li[x]=t;\n}\nvoid insert_edge(int x,int y)\n{\n    inserts(x,y);\n    inserts(y,x);\n}\nbool vis[100005];\nbool dfs(int x)\n{\n    vis[x]=true;\n    edge * t;\n    bool lose=true;\n    bool win=false;\n    for (t=li[x];t!=0;t=t->next)\n    {\n        if (vis[t->y]) continue;\n        bool x=dfs(t->y);\n        if (x)\n        {\n            lose^=true;\n        }\n        else\n        {\n            win^=true;\n        }\n    }\n    if (win) return false;\n    return lose;\n}\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    int n;\n    scanf(\"%d\",&n);\n    int i;\n    for (i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        x--;\n        y--;\n        insert_edge(x,y);\n    }\n    if (!dfs(0)) puts(\"Alice\"); else puts(\"Bob\");\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvector <int> v[100005];\n\nint dfs(int node, int par, int d) {\n\tif (v[node].size()==1 and par) {\n\t\treturn 0;\n\t}\n\tint sol = 0;\n\tfor (int i=0 ; i<v[node].size() ; i++) {\n\t\tif (v[node][i] == par) continue ;\n\t\tsol ^= dfs(v[node][i], node, d+1)+1;\n\t}\n\treturn sol;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i=0 ; i<n-1 ; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif (dfs(1, 0, 0)) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tvector<vector<UL>> E(N);\n\t\tvector<UL> P(N, (UL)-1);\n\t\tvector<UL> S;\n\t\trep(i, N - 1) {\n\t\t\tUL a, b; cin >> a >> b; a--; b--;\n\t\t\tE[a].push_back(b);\n\t\t\tE[b].push_back(a);\n\t\t}\n\t\tqueue<UL> Q; Q.push(0);\n\t\twhile (Q.size()) {\n\t\t\tUL p = Q.front(); Q.pop();\n\t\t\tS.push_back(p);\n\t\t\tfor (UL e : E[p]) {\n\t\t\t\tif (P[p] == e) continue;\n\t\t\t\tP[e] = p;\n\t\t\t\tQ.push(e);\n\t\t\t}\n\t\t}\n\t\tvector<vector<UL>> dp(N + 1);\n\t\treverse(S.begin(), S.end());\n\t\tP[0] = N;\n\t\trep(i, S.size()) {\n\t\t\tUL p = S[i];\n\t\t\tUL ans = 0;\n\t\t\tif (dp[p].size() % 2 == 0) {\n\t\t\t\tUL s = 0; for (UL d : dp[p]) s += d;\n\t\t\t\tans = (s + 1) % 2;\n\t\t\t}\n\t\t\telse ans = 0;\n\t\t\tdp[P[p]].push_back(ans);\n\t\t}\n\t\tif (dp[N][0]) cout << \"Bob\" << endl;\n\t\telse cout << \"Alice\" << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nll N;\n\nvector<vector<ll>> g;\n\nll dfs(ll u, ll v) {\n\tll ret = 0;\n\n\tfor (ll w : g[v]) {\n\t\tif (u == w) { continue; }\n\t\tret ^= dfs(v, w) + 1;\n\t}\n\n\treturn ret;\n}\n\n\nint main() {\n\n\tcin >> N;\n\tg.resize(N + 1);\n\n\trepn(i, N - 1) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tll b = dfs(0, 1);\n\n\tif (b == 0) { cout << \"Bob\"; }\n\telse { cout << \"Alice\"; }\n\t\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" \" << x << endl\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n\n#define fst first\n#define snd second\n\ntypedef long long llint;\ntypedef pair<int, int> pii;\n\nconst int B = 27397, MOD = 1e9 + 7;\nconst int B1 = 33941, MOD1 = 1e9 + 9;\n\nconst int MAXN = 1e5+10;\n\nint n;\n\nvector<int> v[MAXN];\n\nint get_sum(int node, int p) {\n  int ret = 0, cnt = 0;\n  for (int nxt : v[node]) {\n    if (nxt == p) continue;\n    ret ^= get_sum(nxt, node);\n    ++cnt;\n  }\n  ret += cnt == 1;\n  return ret;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b); --a; --b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n\n  if (get_sum(0, -1) == 0)\n    printf(\"Bob\\n\");\n  else\n    printf(\"Alice\\n\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvector<int> v[101010];\nint dfs(int x,int p){\n    int ret=0;\n    for(auto to:v[x]){\n        if(to==p)continue;\n        ret^=dfs(to,x)+1;\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<cstdlib>\n#include<algorithm>\n#include<bitset>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<iomanip>\n#include<ctime>\n#include<complex>\n#include<functional>\n#include<climits>\n#include<cassert>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n \n \n \nint n;\n#define MAX 100002\n \nvector<int> v[MAX];\nint gr[MAX];\n \ninline void dfs(int b,int pr=-1) {\n\tif (v[b].size() == 1 ) {\n\t\tgr[b] = 0;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < v[b].size(); i++) {\n\t\tint go = v[b][i];\n\t\tif (go != pr) {\n\t\t\tdfs(go,b);\n\t\t\tgr[b] ^= (gr[go] + 1);\n\t\t}\n\t}\n}\n \nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tif (gr[0]) {\n\t\tputs(\"Alice\");\n\t}\n\telse {\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace IO\n{\n    const int __S=(1<<20)+5;char __buf[__S],*__H,*__T;\n    inline char getc()\n    {\n        if(__H==__T) __T=(__H=__buf)+fread(__buf,1,__S,stdin);\n        if(__H==__T) return -1;return *__H++;\n    }\n    template <class __I>inline void read(__I &__x)\n    {\n        __x=0;int __fg=1;char __c=getc();\n        while(!isdigit(__c)&&__c!='-') __c=getc();\n        if(__c=='-') __fg=-1,__c=getc();\n        while(isdigit(__c)) __x=__x*10+__c-'0',__c=getc();\n        __x*=__fg;\n    }\n    inline void readd(double &__x)\n    {\n        __x=0;double __fg=1.0;char __c=getc();\n        while(!isdigit(__c)&&__c!='-') __c=getc();\n        if(__c=='-') __fg=-1.0,__c=getc();\n        while(isdigit(__c)) __x=__x*10.0+__c-'0',__c=getc();\n        if(__c!='.'){__x=__x*__fg;return;}else while(!isdigit(__c)) __c=getc();\n        double __t=1e-1;while(isdigit(__c)) __x=__x+1.0*(__c-'0')*__t,__t=__t*0.1,__c=getc();\n        __x=__x*__fg;\n    }\n    inline void reads(char *__s,int __x)\n    {\n        char __c=getc();int __tot=__x-1;\n        while(__c<'!'||__c>'~') __c=getc();\n        while(__c>='!'&&__c<='~') __s[++__tot]=__c,__c=getc();\n        __s[++__tot]='\\0';\n    }\n    char __obuf[__S],*__oS=__obuf,*__oT=__oS+__S-1,__c,__qu[55];int __qr;\n    inline void flush(){fwrite(__obuf,1,__oS-__obuf,stdout);__oS=__obuf;}\n    inline void putc(char __x){*__oS++ =__x;if(__oS==__oT) flush();}\n    template <class __I>inline void print(__I __x)\n    {\n        if(!__x) putc('0');\n        if(__x<0) putc('-'),__x=-__x;\n        while(__x) __qu[++__qr]=__x%10+'0',__x/=10;\n        while(__qr) putc(__qu[__qr--]);\n    }\n    inline void prints(const char *__s,const int __x)\n    {\n        int __len=strlen(__s+__x);\n        for(int __i=__x;__i<__len+__x;__i++) putc(__s[__i]);\n    }\n    inline void printd(double __x,int __d)\n    {\n        long long __t=(long long)floor(__x);print(__t);putc('.');__x-=(double)__t;\n        while(__d--)\n        {\n            double __y=__x*10.0;__x*=10.0;\n            int __c=(int)floor(__y);\n            putc(__c+'0');__x-=floor(__y);\n        }\n    }\n    inline void el(){putc('\\n');}inline void sp(){putc(' ');}\n}using namespace IO;\nint n,x,y,sg[100005];vector<int>e[100005];void add(int x,int y){e[x].push_back(y);e[y].push_back(x);}\nvoid dfs(int x,int fa){for(int i=0;i<e[x].size();i++) if(e[x][i]!=fa) dfs(e[x][i],x),sg[x]^=(sg[e[x][i]]+1);}\nint main(){read(n);for(int i=1;i<n;i++) read(x),read(y),add(x,y);dfs(1,0);puts(sg[1]?\"Alice\":\"Bob\");}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100001];\nint dp[100001];\nbool used[100001];\nint cnt[100001];\n\nint dfs(int v,int p){\n\tint res=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tres^=(dfs(G[v][i],v)+1);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tG[f].push_back(t);\n\t\tG[t].push_back(f);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(used,false,sizeof(used));\n\tprintf(\"%s\\n\",dfs(0,-1)!=0?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nvector<int> G[100000];\nvector<int> C[100000];\nint n; bool used[100000];\nint dfs(int k) {\n\tint res = 0;\n\tint len = G[k].size();\n\trep(i, len) {\n\t\tint v = G[k][i];\n\t\tres ^= dfs(v)+1;\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tC[x].push_back(y);\n\t\tC[y].push_back(x);\n\t}\n\tfill(used, used + n, false);\n\tqueue<int> q; q.push(0); used[0] = true;\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tint len = C[x].size();\n\t\trep(i, len) {\n\t\t\tint v = C[x][i];\n\t\t\tif (used[v])continue;\n\t\t\tused[v] = true; q.push(v); G[x].push_back(v);\n\t\t}\n\t}\n\tif (dfs(0))cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define TEMPLATE_USED\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) for(ll i=0;i<(n);++i)\n#define _rep3(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2)(__VA_ARGS__)\n#define _repe2(i,n) for(ll i=0;i<=(n);++i)\n#define _repe3(i,a,b) for(ll i=(a);i<=(b);++i)\n#define repe(...) _overload3(__VA_ARGS__,_repe3,_repe2)(__VA_ARGS__)\n#define _rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntemplate<class T>\nusing pq=priority_queue<T,vector<T>,greater<T>>;\n\nll N;\nvl x;\nvl y;\n\nvoid solve();\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin >> N;\n    x = vl(N-1);\n    y = vl(N-1);\n    for(int i = 0; i < N-1; ++i){\n        cin >> x[i];\n        cin >> y[i];\n    }\n    solve();\n}\n\n// 2 <= N <= 100000\n// 1 <= x_i, y_i <= N\n// 与えられるグラフは木である．\n\nvvl g;\nll f(ll x=0,ll p=-1){\n    ll ret=0;\n    for(ll to:g[x]){\n        if(to==p)continue;\n        ret^=f(to,x)+1;\n    }\n    return ret;\n}\n\n// ll N, vl x, vl y\n// Alice が勝つなら Alice を，Bob が勝つなら Bob を出力せよ．\nvoid solve(){\n    /* (´~`) */\n    g.resize(N);\n    rep(i,N-1){\n        g[x[i]-1].push_back(y[i]-1);\n        g[y[i]-1].push_back(x[i]-1);\n    }\n\n    cout<<(f()?\"Alice\":\"Bob\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nconst int N = 2e5;\nusing namespace std;\nint n,edge[N * 2 + 5],nxt[N * 2 + 5],head[N + 5],edge_cnt,sg[N + 5];\nvoid add_edge(int u,int v)\n{\n    edge[++edge_cnt] = v;\n    nxt[edge_cnt] = head[u];\n    head[u] = edge_cnt;\n}\nvoid dfs(int u,int fa)\n{\n    for (int i = head[u];i;i = nxt[i])\n    {\n        int v = edge[i];\n        if (v == fa)\n            continue;\n        dfs(v,u);\n        sg[u] ^= sg[v] + 2;\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    int u,v;\n    for (int i = 1;i < n;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    dfs(1,0);\n    if (sg[1])\n        cout<<\"Alice\"<<endl;\n    else\n        cout<<\"Bob\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#define ld long double\n#define MN 210000\nusing namespace std;\n\nint read_p,read_ca;\ninline int read(){\n    read_p=0;read_ca=getchar();\n    while(read_ca<'0'||read_ca>'9') read_ca=getchar();\n    while(read_ca>='0'&&read_ca<='9') read_p=read_p*10+read_ca-48,read_ca=getchar();\n    return read_p;\n}\nstruct na{int y,ne;}b[MN];\nint n,m,l[MN],num=0,x,y,s[MN];\ninline void in(int x,int y){\n\tb[++num].y=y;b[num].ne=l[x];l[x]=num;\n}\nvoid dfs(int x,int f){\n\tint u=0;s[x]=0;\n\tfor (int i=l[x];i;i=b[i].ne)\n\tif (b[i].y!=f){\n\t\tdfs(b[i].y,x);u^=s[b[i].y];\n\t}\n\t\n\ts[x]=u;\n\t/*for (int i=l[x];i;i=b[i].ne)\n\tif (b[i].y!=f){\n\t\tif ((u^s[b[i].y])==0) s[x]=1;\n\t}*/\n\t//printf(\"%d %d\\n\",x,s[x]);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<n;i++) x=read(),y=read(),in(x,y),in(y,x); \n\t\n\tdfs(1,0);\n\tputs(s[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nconst int N = 2e5;\nusing namespace std;\nint n,edge[N * 2 + 5],nxt[N * 2 + 5],head[N + 5],edge_cnt,sg[N + 5];\nvoid add_edge(int u,int v)\n{\n    edge[++edge_cnt] = v;\n    nxt[edge_cnt] = head[u];\n    head[u] = edge_cnt;\n}\nvoid dfs(int u,int fa)\n{\n    for (int i = head[u];i;i = nxt[i])\n    {\n        int v = edge[i];\n        if (v == fa)\n            continue;\n        dfs(v,u);\n        sg[u] ^= sg[v] + 3;\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    int u,v;\n    for (int i = 1;i < n;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    dfs(1,0);\n    if (sg[1])\n        cout<<\"Alice\"<<endl;\n    else\n        cout<<\"Bob\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ph push\n#define ptc putchar\n#define enter putchar('\\n')\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef long long lnt;\ninline int read(){\n\t   int x = 0;char c = getchar();\n\t   while (!isdigit(c)) c = getchar();\n\t   while (isdigit(c)) x = (x << 1) + (x << 3) + c - '0' , c = getchar();\n\t   return x;\n}\ninline void write(int x){\n\t   if (!x){\n          ptc('0');\n          return;\n\t   }\n\t   int dg[20] , len = 0;\n\t   while (x) dg[len++] = x % 10 , x /= 10;\n\t   while (len--) ptc(dg[len]+'0');\n}\ninline void writeln(int x){\n\t   write(x);\n\t   ptc('\\n');\n}\nconst int N = 1e5 + 10;\n\nstruct Edge{\n\tint to , nex;\n}e[N << 1];int head[N] , ecnt; \n\nvoid adde(int fr,int to){\n\te[++ecnt] = (Edge){to , head[fr]};\n\thead[fr] = ecnt;\n}\n\nvoid addedge(int fr,int to){\n\tadde(fr,to);\n\tadde(to,fr);\n}\n\nint f[N];\nvoid dfs(int x,int par){\n\tfor (int j = head[x];j;j=e[j].nex)\n\tif (e[j].to != par){\n\t\tdfs(e[j].to , x);\n\t\tf[x] ^= f[e[j].to] + 1;\n\t}\n}\nint n;\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i = 1;i < n;i++){\n\t\tint u , v;scanf(\"%d%d\",&u,&v);\n\t\taddedge(u , v);\n\t}\n\tdfs(1 , 0);\n\tcout<< (f[1] ? \"Alice\" : \"Bob\"); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<vector>\ninline int getint() {\n\tregister char ch;\n\twhile(!isdigit(ch=getchar()));\n\tregister int x=ch^'0';\n\twhile(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');\n\treturn x;\n}\nconst int N=1e5+1;\nstd::vector<int> e[N];\ninline void add_edge(const int &u,const int &v) {\n\te[u].push_back(v);\n\te[v].push_back(u);\n}\nbool dfs(const int &x,const int &par) {\n\tint sg=0;\n\tfor(auto &y:e[x]) {\n\t\tif(y==par) continue;\n\t\tsg^=dfs(y,x)+1;\n\t}\n\treturn sg;\n}\nint main() {\n\tconst int n=getint();\n\tfor(register int i=1;i<n;i++) {\n\t\tadd_edge(getint(),getint());\n\t}\n\tputs(dfs(1,0)?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100100\nusing namespace std;\nstruct edge{\n\tint r,nxt;\n}e[maxn<<1];\nint head[maxn],esz,size[maxn],n;\nvoid addedge(int u,int v){\n\te[++esz].r=v;e[esz].nxt=head[u];head[u]=esz;\n\te[++esz].r=u;e[esz].nxt=head[v];head[v]=esz;\n}\nvoid dfs(int u,int f){\n\tfor(int t=head[u];t;t=e[t].nxt)if(e[t].r!=f)\n\t\tdfs(e[t].r,u),size[u]^=size[e[t].r]+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),addedge(u,v);\n\tdfs(1,0);\n\tif(size[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=300010;\nvector<int>e[N]; int n,dp[N];\nvoid dfs(int x,int fa){ for (int i=0;i<e[x].size();i++) if (e[x][i]!=fa){ dfs(e[x][i],x); dp[x]^=dp[e[x][i]]+1; } }\nint main(){\n\tscanf(\"%d\",&n); for (int i=1;i<n;i++){ int x,y; scanf(\"%d%d\",&x,&y); e[x].push_back(y);e[y].push_back(x); }\n\tdfs(1,-1); printf(\"%s\\n\",dp[1]?\"Alice\":\"Bob\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include <random>\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end());\n#define ll long long\n#define pb(a) push_back(a)\n#define print(x) cout<<x<<'\\n';\n#define pe(x) cout<<x<<\" \";\n#define lb(v,n) lower_bound(v.begin(), v.end(), n);\n#define ub(v,n) upper_bound(v.begin(), v.end(), n);\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \");\n//#define double long double\n\n\n\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a>b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a<b) a = b; }\n\nconst int MOD = 1e9 + 7;\nconst ll INF = 1e17;\nconst int INT_INF = 1e9;\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ntypedef pair<int, int>P;\nconst int MAX = 200020;\n\n\n\nbool vis[100010];\nvector<int>G[100010];\n\nint grundy(int n, int pre) {\n\t//print(n);\n\tif (pre == -1) {\n\t\tif (G[n].size() == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tres ^= grundy(nex, n);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\telse {\n\t\tif (G[n].size() == 2) {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tif (nex == pre)continue;\n\t\t\t\tres = grundy(nex, n);\n\t\t\t}\n\t\t\tres++;\n\t\t\treturn res;\n\t\t}\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tfor (auto nex : G[n]) {\n\t\t\t\tif (nex == pre)continue;\n\t\t\t\tres ^= grundy(nex, n);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N; cin >> N;\n\tREP(i, N-1) {\n\t\tint x, y; cin >> x >> y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tll res = grundy(1, -1);\n\tif (res == 0) {\n\t\tprint(\"Bob\");\n\t}\n\telse print(\"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\nconst int MAXN = 100000 + 10;\n\nint N;\nvector <int> Adj[MAXN];\n\nint DFS(int cur, int fa)\n{\n\tint SG = 0;\n\n\tfor(const int & x : Adj[cur])\n\t\tif(x != fa)\n\t\t\tSG ^= (1 + DFS(x, cur));\n\n\treturn SG;\n}\n\nint main()\n{\n\tcin >> N ;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v ;\n\t\tAdj[u].push_back(v);\n\t\tAdj[v].push_back(u);\n\t}\n\n\tcout << (DFS(1, 0) == 0 ? \"Bob\" : \"Alice\") << endl ;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,a[100005];\nvector<int> v[100005];\nvoid dfs(int x,int y){\n    int cnt=0;\n    for(int i=0;i<v[x].size();++i){\n        int z=v[x][i];\n        if(y==z) continue;\n        dfs(z,x);\n        a[x]^=a[z];\n        ++cnt;\n    }\n    if(cnt==1)++a[x];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    dfs(1,0);\n    if(a[1])puts(\"Alice\");\n    else puts(\"Bob\");\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define N 100003\nusing namespace std;\n\nvector<int> adj[N];\nint a[N];\nint n;\n\nvoid dfs(int u,int fa){\n    a[u] = 0;\n    int v,l = adj[u].size();\n    for(int i=0;i<l;++i){\n        v = adj[u][i];\n        if(v==fa) continue;\n        dfs(v,u);\n        a[u] ^= a[v]+1;\n    }\n}\n\ninline void read(int &x){\n    x = 0;\n    char c = getchar();\n    while(c<'0'||c>'9') c = getchar();\n    while(c>='0'&&c<='9'){\n        x = (x<<3)+(x<<1)+(c^48);\n        c = getchar();\n    }\n}\n\nint main(){\n    int u,v;\n    read(n);\n    for(int i=1;i<n;++i){\n        read(u),read(v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1,0);\n    printf(a[1]?\"Alice\\n\":\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN (100010)\n\nint n;\nstd::vector<int> vec[MAXN]; \nbool vis[MAXN];\nint sg[MAXN];\n\nvoid dfs(int u){\n\tvis[u] = true;\n\tbool mark = false;\n\tfor(auto v : vec[u]){\n\t\tif(vis[v]) continue;\n\t\tmark = true;\n\t\tdfs(v);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++ i){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tvec[u].push_back(v);\n\t\tvec[v].push_back(u);\n\t}\n\tdfs(1);\n\tprintf(sg[1]? \"Alice\\n\" : \"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                        #define ppa pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n              \n            void gya(){\n            \tpr[0]=1;\n            \tfor(int i=1;i<2000010;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<2000010;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\nvector<int> G2[100030];\nvector<int> G[100030];\nint n;\n\n\nvoid saiki1(int u,int oya){\n\tfor(auto v:G[u])if(v!=oya){\n\t\tG2[u].pb(v);\n\t\tsaiki1(v,u);\n\t}\n}\n\nint saiki2(int u){\n\tif(G2[u].size()==0) return 0;\n\tint r=0;\n\tfor(auto v:G2[u]){\n\t\tr^=(1+saiki2(v));\n\t}\n\treturn r;\n}\n      signed main(){\n  cin>>n;\n      \t\n      \tfor(int i=1;i<n;i++){\n      \t\tint yy,yyy;\n      \t\tcin>>yy>>yyy;\n      \t\tG[yy].pb(yyy);\n      \t\tG[yyy].pb(yy);\n      \t}\n      \t\n      \tsaiki1(1,-1);\n     \n      \tif(saiki2(1)!=0)cout<<\"Alice\"<<endl;\n      \telse cout<<\"Bob\"<<endl;\n        \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "// Ala be zekrellah tatmaenolgholoob ...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n#define MP make_pair\nconst int maxn = 1e5+9;\nconst ll mod = 1e9+7;\n\nvector <int> g[maxn];\nint grundy[maxn];\n\nvoid dfs (int v, int parent = -1) {\n\tint num = 0;\n\tfor (auto u : g[v]) {\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tdfs(u, v);\n\t\tgrundy[v] ^= grundy[u] + 1;\n\t}\n\tif (grundy[v])\n\t\tgrundy[v] = 1;\n}\n\nint main () {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\t--v; --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t\t}\n\tdfs(0);\n\tif (grundy[0])\n\t\tcout << \"Alice\\n\";\n\telse\n\t\tcout << \"Bob\\n\";\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint n, x, y;\nvector<int> g[100100];\n\nbool Dfs(int x, int fa) {\n\tbool ans = 0, c1 = 0;\n\tfor(int i = 0; i < (int)g[x].size(); i++) {\n\t\tint v = g[x][i];\n\t\tif(v == fa) continue;\n\t\tif(Dfs(v, x)) c1 ^= 1;\n\t\tans ^= 1;\n\t}\n//\tprintf(\"%d : %d\\n\", x, ans ^ c1);\n\treturn max((bool)(ans ^ c1), ans);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tDfs(1, 0) ? puts(\"Alice\") : puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            res ^= dfs(e, now);\n        }\n    }\n    return res + 1;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        cout << (dfs(0, -1) == 0 ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n// #include \"../debug/debug.cpp\"\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nVV<ll> edges;\n\nll dfs(ll cur, ll pre) {\n    ll ret = 0;\n    for(ll nxt : edges[cur]) {\n        if(nxt == pre) continue;\n        ret ^= (dfs(nxt, cur) + 1);\n    }\n    return ret;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    edges.resize(N);\n    for(ll i = 1; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        x--; y--;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n    cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nvector<int>V[N];\nint n, tim[N], tid, sg[N];\n\nvoid Dfs (int u, int fa) {\n\tfor (auto v : V[u]) if (v != fa) Dfs(v, u);\n\t++tid;\n\tfor (auto v : V[u]) if (v != fa) tim[sg[v]] = tid;\n\twhile (tim[sg[u]] == tid) ++sg[u];\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tV[u].emplace_back(v);\n\t\tV[v].emplace_back(u);\n\t}\n\tint nim = 0;\n\tfor (auto v : V[1]) {\n\t\tDfs(v, 1);\n\t\tnim ^= sg[v];\n\t}\n\tputs(nim ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>\nvoid read(T &x)\n{\n    char ch=getchar();\n    int f=1;\n    for (x=0;ch!='-'&&(ch<'0'||ch>'9');ch=getchar());\n    if (ch=='-') f=-1,ch=getchar();\n    for (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n    x*=f;\n}\ntypedef long long ll; \n#define MAXN 100010\nstruct edge{\n\tint s,t,next;\n}e[MAXN<<1];\nint head[MAXN],cnt;\nvoid addedge(int s,int t)\n{\n\te[cnt].s=s;e[cnt].t=t;e[cnt].next=head[s];head[s]=cnt++;\n\te[cnt].s=t;e[cnt].t=s;e[cnt].next=head[t];head[t]=cnt++;\n}\nint n,u,v;\nll sg[MAXN];\nvoid dfs(int node,int lastfa)\n{\n\tsg[node]=0;\n\tfor (int i=head[node];i!=-1;i=e[i].next)\n\t\tif (e[i].t!=lastfa)\n\t\t{\n\t\t\tdfs(e[i].t,node);\n\t\t\tsg[node]^=(sg[e[i].t]+1);\n\t\t}\n}\nint main()\n{\n\tread(n);\n\tmemset(head,0xff,sizeof(head));\n\tcnt=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tread(u),read(v);\n\t\taddedge(u,v);\n\t}\n\tdfs(1,1);\n\tputs(sg[1]==0 ? \"BoB\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<cstdlib>\n#include<algorithm>\n#include<bitset>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<iomanip>\n#include<ctime>\n#include<complex>\n#include<functional>\n#include<climits>\n#include<cassert>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n\n\nint n;\n#define MAX 100002\n\nvector<int> v[MAX];\nint gr[MAX];\n\ninline void dfs(int b,int pr=-1) {\n\tif (v[b].size() == 1 && pr != -1) {\n\t\tgr[b] = 0;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < v[b].size(); i++) {\n\t\tint go = v[b][i];\n\t\tif (go != pr) {\n\t\t\tdfs(go,b);\n\t\t\tgr[b] ^= (gr[go] + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tif (gr[0]) {\n\t\tputs(\"Alice\");\n\t}\n\telse {\n\t\tputs(\"Bob\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> G[100000];\n\nint calc(int v,int par){\n\tint g = 0;\n\tfor(int to : G[v]){\n\t\tif(to != par) g ^= calc(to,v);\n\t}\n\tif(par != -1) g++;\n\treturn g;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif(calc(0,-1)) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#define inf 2147483647\n#define eps 1e-9\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint v,next;\n}a[200001];\nint n,u,v,tot=0,head[100001];\nvoid add(int u,int v){\n\ta[++tot].v=v;\n\ta[tot].next=head[u];\n\thead[u]=tot;\n}\nint dfs(int u,int fa){\n\tint ret=0;\n\tfor(int tmp=head[u];tmp!=-1;tmp=a[tmp].next){\n\t\tint v=a[tmp].v;\n\t\tif(v!=fa){\n\t\t\tret^=(dfs(v,u)+1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tif(dfs(1,-1))puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void ri(int &x){\n\tx=0; static char c; bool t=0;\n\twhile(c=getchar(),c<'0'||c>'9') if(c=='-') t=1; else t=0;\n\tdo x=x*10+c-'0'; while(c=getchar(),c>='0'&&c<='9');\n\tif(t) x=-x;\n}\nconst int N=200024;\nint val[35],tot;\nint a[N],f[N],nf[N];\nint l[N],r[N],L[N],R[N],gs;\nint nl[N],nr[N],nL[N],nR[N],ngs;\nint ans[N];\npair<int,int> b[N];\nint main(){\n\tint i,j,n,v; ri(n); ri(v);\n\tfor(i=1;i<=n;++i) ri(a[i]);\n\twhile(v){\n\t\tval[++tot]=v;\n\t\tv>>=1;\n\t}\n\tfor(i=1;i<=n;++i) f[i]=1,l[i]=r[i]=a[i],L[i]=i,R[i]=i; gs=n;\n\tfor(i=tot;i;--i){\n\t\tngs=0;\n\t\tfor(j=1;j<=gs;){\n\t\t\tint h=j+1,s=f[j],mn=f[j];\n\t\t\twhile(h<=gs&&l[h]-r[h-1]<=val[i]){\n\t\t\t\ts+=f[h]; mn=min(mn,f[h]);\n\t\t\t\t++h;\n\t\t\t}\n\t\t\tnl[++ngs]=l[j]; nr[ngs]=r[h-1]; nf[ngs]=s-mn+1;\n\t\t\tnL[ngs]=L[j]; nR[ngs]=R[h-1];\n\t\t\tj=h;\n\t\t}\n\t\tgs=ngs;\n\t\tfor(j=1;j<=gs;++j){\n\t\t\tl[j]=nl[j]; r[j]=nr[j]; f[j]=nf[j];\n\t\t\tL[j]=nL[j]; R[j]=nR[j];\n\t\t}\n\t}\n\tint s=0;\n\tfor(i=1;i<=gs;++i) s+=f[i];\n\tfor(i=1;i<=gs;++i)\n\tif(s-f[i]+1<=tot+1)\n\tfor(j=L[i];j<=R[i];++j) ans[j]=1;\n\tfor(i=1;i<=n;++i)\n\tif(ans[i]) puts(\"Possible\");\n\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n///////////// マクロ, エイリアス /////////////////\n#pragma region macros_and_aliases\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing mii = map<int, int>;\nusing pqll = priority_queue<long long>;\nusing pqllg = priority_queue<long long, vector<long long>, greater<long long>>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n#pragma endregion\n\n///////////// 定数など /////////////////\n#pragma region constants\n\nlong long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\nlong long const dekai = 1e15;\nconst long double pi = acos(-1);\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nint ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\n#pragma endregion\n\n// // 多倍長テンプレ\n// /* ---------------------- ここから ---------------------- */\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// // 任意長整数型\n// using Bint = mp::cpp_int;\n// // 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n// using Real = mp::number<mp::cpp_dec_float<1024>>;\n// /* ---------------------- ここまで ---------------------- */\n\n/////////////////// 基本処理系 ////////////////////\n#pragma region basic_procedure\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#pragma endregion\n\n//////////////// 数学処理系 ///////////////////////\n#pragma region math\n\ntemplate <class T>\nT divup(T a, T b) {\n\t//端数繰りあがり割り算\n\tassert(b != 0);\n\tT x = abs(a);\n\tT y = abs(b);\n\tT z = (x + y - 1) / y;\n\tif((a < 0 && b > 0) || (a > 0 && b < 0))\n\t\treturn -z;\n\telse if(a == 0)\n\t\treturn 0;\n\telse\n\t\treturn z;\n}\n\nlong long POW(long long a, long long n) {\n\t// 整数のとき限定の普通のPOW関数\n\t//標準機能のpow(a,n)は整数だとバグるのでこちらを使う\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ntemplate <class T>\nbool prime(T N) {\n\t//素数判定\n\t//素数ならばtrue、素数以外の整数にはfalse\n\t//負数は全てfalse\n\t//検証済み\n\tif(N <= 1) return false;\n\tT p = sqrt(N);\n\tfor(long long i = 2; i <= p; i++)\n\t\tif(N % i == 0) return false;\n\treturn true;\n}\n\nvector<long long> eratos(long long n) {\n\t//エラトステネスのふるい\n\t//素数なら1,素数でないなら0\n\tassert(n >= 0);\n\tvll v(n + 1, 1);\n\tif(n >= 0) v[0] = 0;\n\tif(n >= 1) v[1] = 0;\n\tRep(i, 2, n + 1) {\n\t\tif(v[i]) {\n\t\t\tfor(ll k = i * 2; k < n + 1; k += i) {\n\t\t\t\tv[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nvector<long long> primevec(long long n) {  // n以下の素数のみを入れたvector\n\tvll v = eratos(n);\n\tvll ret;\n\tRep(i, 2, n + 1) if(v[i]) ret.push_back(i);\n\treturn ret;\n}\n\nset<long long> primeset(long long n) {\t// n以下の素数を全て詰めたset\n\tvll v = eratos(n);\n\tsll s;\n\tRep(i, 2, n + 1) if(v[i]) s.insert(i);\n\treturn s;\n}\n\nvector<long long> yakusuu(long long n) {  // nの約数を列挙\n\tvector<long long> ret;\n\tlong long sq = sqrt(n);\n\tfor(long long i = 1; i <= sq; ++i) {\n\t\tif(n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif(i * i != n) {\n\t\t\t\tret.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\n\nmap<long long, long long> soinsuu(long long n) {  // map<素因数,個数>\n\tmap<long long, long long> m;\n\tlong long p = sqrt(n);\n\twhile(n % 2 == 0) {\n\t\tn /= 2;\n\t\tif(m.count(2)) {\n\t\t\tm[2]++;\n\t\t} else {\n\t\t\tm[2] = 1;\n\t\t}\n\t}\n\tfor(long long i = 3; i * i <= n; i += 2) {\n\t\twhile(n % i == 0) {\n\t\t\tn /= i;\n\t\t\tif(m.count(i)) {\n\t\t\t\tm[i]++;\n\t\t\t} else {\n\t\t\t\tm[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(n != 1) m[n] = 1;\n\treturn m;\n}\n\nvector<long long> keta(ll x) {\n\t// 10進法でn桁の整数xに対して、大きい方の位から、その位の1桁の数字を\n\t//収納した長さnのベクトルを返す\n\t// 0に対しては{}を返す\n\tvll w;\n\twhile(x > 0) {\n\t\tw.push_back(x % 10);\n\t\tx /= 10;\n\t}\n\treverse(all(w));\n\treturn w;\n}\n\nlong long ketasum(ll x) {  //各桁の和\n\tll ret = 0;\n\twhile(x > 0) {\n\t\tret += x % 10;\n\t\tx /= 10;\n\t}\n\treturn ret;\n}\n\nstring bits(long long n, long long k) {\t // nをk桁のbitで表示したstringを返す\n\tstring s = \"\";\n\trep(i, k) {\n\t\tchar c = '0' + (n % 2);\n\t\ts += c;\n\t\tn /= 2;\n\t}\n\treverse(all(s));\n\treturn s;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\t // a^n mod\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlong long modinv(long long a, long long mod) {\t// a^{-1} mod\n\t// modとaが互いに素のときのみ有効(数学的に逆元が一意に定まるのがそのときのみ)\n\treturn modpow(a, mod - 2, mod);\n}\n\nvvll comb(100, vll(100, -1));\nlong long com(long long n, long long k) {  //普通の二項計数(overflowに注意)\n\tassert(n < 100 && k < 100);\n\tif(n < k || k < 0 || n < 0) return 0;\n\tif(comb[n][k] != -1) return comb[n][k];\n\tll res;\n\tif(n - k < k)\n\t\tres = com(n, n - k);\n\telse if(k == 0)\n\t\tres = 1;\n\telse\n\t\tres = com(n - 1, k - 1) + com(n - 1, k);\n\tcomb[n][k] = res;\n\treturn res;\n}\n\n// nCk modを求める\nconst ll MAX = 510000;\n// この値は求める二項計数の値に応じて変える\n// MAX=3*10^7のとき1900msほど、ほぼ比例\n// MAX=5*10^6程度ならそれほど気にしなくてよい(300ms程)\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid cominit() {\n\t// テーブルを作る前処理\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nlong long commod(ll n, ll k) {\t// 二項係数計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nlong long pmod(ll n, ll k) {  //順列計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[n - k] % mod;\n}\nlong long hmod(ll n, ll k) {  // nHk計算\n\t// n個の区別しないoを区別するk個の箱に入れる方法の総数\n\t//(n+k-1)C(k-1)と等しい\n\treturn commod(n + k - 1, n);\n}\n\nlong long next_combination(long long sub) {\t //次の組み合わせをbitで返す\n\tlong long x = sub & -sub, y = sub + x;\n\treturn (((sub & ~y) / x) >> 1) | y;\n}\n\n#pragma endregion\n\n//////////////// vector処理系 ///////////////////////\n#pragma region vector\nvector<long long> vin(long long n) {  //整数n個の入力を受け取ってベクトルに突っ込んで返す\n\tvector<long long> v(n);\n\tfor(long long i = 0; i < n; i++) {\n\t\tcin >> v[i];\n\t}\n\treturn v;\n}\n\n//ベクトルの出力(検証済)\n// vectorの中身を出力する 答えの出力に利用可能\ntemplate <class T>\nvoid vout(vector<T> &v) {\n\tif(v.size() > 0) {\n\t\tfor(auto it = v.begin(); it < v.end(); it++) {\n\t\t\tcout << *it;\n\t\t\tif(it != v.end() - 1) cout << \" \";\n\t\t}\n\t}\n\tcout << endl;\n}\n\n//引数ベクトルに同一要素が複数あるとき、先頭を残し他は削除したベクトルを返す\n//ベクトル長も変化する\n// O(nlogn)くらい\ntemplate <class T>\nvector<T> singlized(vector<T> &v) {\n\tset<T> s;\n\tvector<T> ret;\n\tfor(auto seg : v) {\n\t\tif(!s.count(seg)) {\n\t\t\tret.push_back(seg);\n\t\t\ts.insert(seg);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//配列圧縮(検証済)\n//{1,36,1,3,8,-2,-92}を\n//{2, 5,2,3,4, 1,  0}にする\ntemplate <class T>\nvector<long long> press(vector<T> &v) {\n\tlong long n = v.size();\n\tvector<long long> w(n);\n\tmap<T, long long> m;\n\tfor(T &p : v) m[p] = 0;\n\tlong long i = 0;\n\tfor(auto &p : m) {\n\t\tp.second = i;\n\t\ti++;\n\t}\n\tfor(long long i = 0; i < n; i++) w.at(i) = m[v.at(i)];\n\treturn w;\n}\n\n//配列圧縮(同順位なし)\n//{1,36,1,3,8,-2,-92}を\n//{2, 6,3,4,5, 1,  0}にする\ntemplate <class T>\nvector<long long> ranking(vector<T> &v) {\n\tvector<pair<T, long long>> r;\n\tlong long n = v.size();\n\trep(i, n) r.push_back({v[i], i});\n\tsort(all(r));\n\tvll res(n);\n\trep(i, n) { res[r[i].second] = i; }\n\treturn res;\n}\n\n//着順配列\n// (sortedplace(v)).[i] = i番目に小さい要素が入っている箇所\ntemplate <class T>\nvector<long long> sortedplace(vector<T> &v) {\n\tauto w = ranking(v);\n\tll n = v.size();\n\tvll res(n);\n\trep(i, n) res[w[i]] = i;\n\treturn res;\n}\n\n// vectorの中身を数える map<要素,個数>を返す\ntemplate <class T>\nmap<T, long long> countv(vector<T> v) {\n\tmap<T, long long> m;\n\tfor(auto &g : v) {\n\t\tif(m.count(g))\n\t\t\tm[g]++;\n\t\telse\n\t\t\tm[g] = 1;\n\t}\n\treturn m;\n}\n\ntemplate <class T>\t// WarshallFloyd\nvoid warshall(vector<vector<T>> &v) {\n\tll n = v.size();\n\trep(i, n) rep(j, n) rep(k, n) v[j][k] = min(v[j][k], v[j][i] + v[i][k]);\n\treturn;\n}\n\n#pragma endregion\n\n//////////////// 累積和処理系 ///////////////////////\n#pragma region ruisekiwa\n\n// 1次元累積和\ntemplate <class T>\nvector<T> barsuminit(vector<T> &v) {\n\tll h = v.size();\n\tV<T> ret(h + 1);\n\tret[0] = 0;\n\trep(i, h) ret[i + 1] = v[i] + ret[i];\n\treturn ret;\n}\ntemplate <class T>\nT barsum(vector<T> &v, ll x0, ll x1) {\n\tif(x1 <= x0) return 0;\n\treturn v[x1] - v[x0];\n}\n// 2次元累積和\ntemplate <class T>\nvector<vector<T>> sheetsuminit(vector<vector<T>> &v) {\n\tll h = v.size();\n\tassert(h != 0);\n\tll w = v.at(0).size();\n\tVV<T> ret(h + 1, V<T>(w + 1));\n\trep(i, h + 1) ret[i][0] = 0;\n\trep(i, w + 1) ret[0][i] = 0;\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] = v[i][j];\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] += ret[i + 1][j];\n\trep(i, h) rep(j, w) ret[i + 1][j + 1] += ret[i][j + 1];\n\treturn ret;\n}\n//[x0,y0],(x1,y1)で囲まれた領域内の和\n//端点は(x,y)のみ含む.面積は(x1-x0)*(y1-y0);\ntemplate <class T>\nT sheetsum(vector<vector<T>> &v, ll x0, ll y0, ll x1, ll y1) {\n\tif(x0 >= x1 || y0 >= y1) return 0;\n\treturn v[x0][y0] + v[x1][y1] - v[x0][y1] - v[x1][y0];\n}\n// 3次元累積和\ntemplate <class T>\nvector<vector<vector<T>>> cubiodsuminit(vector<vector<vector<T>>> &v) {\n\tll h = v.size();\n\tassert(h != 0);\n\tll w = v[0].size();\n\tassert(w != 0);\n\tll z = v[0][0].size();\n\tVVV<T> ret(h + 1, VV<T>(w + 1, V<T>(z + 1)));\n\trep(i, h + 1) rep(j, w + 1) rep(k, z + 1) { ret[i][j][k] = (i == 0 || j == 0 || k == 0 ? 0 : v[i - 1][j - 1][k - 1]); }\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i + 1][j + 1][k];\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i + 1][j][k + 1];\n\trep(i, h) rep(j, w) rep(k, z) ret[i + 1][j + 1][k + 1] += ret[i][j + 1][k + 1];\n\treturn ret;\n}\n//[x0,y0],(x1,y1)で囲まれた領域内の和\n//端点は(x,y)のみ含む.面積は(x1-x0)*(y1-y0);\ntemplate <class T>\nT cubiodsum(vector<vector<vector<T>>> &v, ll x0, ll y0, ll z0, ll x1, ll y1, ll z1) {\n\tif(x0 >= x1 || y0 >= y1 || z0 >= z1) return 0;\n\treturn v[x1][y1][z1] - v[x1][y1][z0] - v[x1][y0][z1] - v[x0][y1][z1] + v[x1][y0][z0] + v[x0][y1][z0] + v[x0][y0][z1] - v[x0][y0][z0];\n}\n\n#pragma endregion\n\n////////////// 構造体 ///////////////////////////\n#pragma region objects\n\nstruct mint {\n\t// auto mod int\n\t// https://youtu.be/L8grWxBlIZ4?t=9858\n\t// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n\t// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\n\tll x;  // typedef long long ll;\n\tmint(ll x = 0) : x((x % mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint &operator+=(const mint a) {\n\t\tif((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint a) {\n\t\tif((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint a) {\n\t\t(x *= a.x) %= mod;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif(!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif(t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint &operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream &operator>>(istream &is, const mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\nstruct UF {\t\t\t\t\t\t// Union_Find木(sizeあり)\n\tvector<long long> par, sz;\t// par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\t// sizeはiを根とする木のサイズ\n\tUF(long long N) : par(N), sz(N) {  //最初は全てが根であるとして初期化\n\t\tfor(long long i = 0; i < N; i++) {\n\t\t\tpar[i] = i;\n\t\t\tsz[i] = 1;\n\t\t}\n\t}\n\n\tlong long root(long long x) {  // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(long long x, long long y) {\t// xとyの木を併合\n\t\tlong long rx = root(x);\t\t\t\t// xの根をrx\n\t\tlong long ry = root(y);\t\t\t\t// yの根をry\n\t\tif(rx == ry) return;\t\t\t\t// xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry;\t\t\t\t\t\t// xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t\tsz[ry] += sz[rx];\n\t\tsz[rx] = 0;\t //サイズの処理 根じゃなくなったらサイズは0になる\n\t}\n\n\tbool same(long long x, long long y) {  // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tlong long rx = root(x);\n\t\tlong long ry = root(y);\n\t\treturn rx == ry;\n\t}\n\tlong long size(long long x) { return sz[root(x)]; }\n};\n\ntemplate <class T = ll>\nstruct BIT {\n\t//もとの配列a[i]はBIT内部ではvec[i+1]に対応\n\tvector<T> vec;\n\tll n;\n\tBIT(long long sz) : vec(sz + 1, 0), n(sz) {}\n\t//元の値に足す\n\tvoid add(long long place, T val, bool index = 0) {\n\t\tif(!index) place++;\n\t\tfor(long long x = place; x <= n; x += x & -x) vec[x] += val;\n\t\treturn;\n\t}\n\t//端からの合計値計算\n\tT sum0(long long a, bool index = 0) {\n\t\t// if(index == 0) a++;\n\t\tif(index) a--;\n\t\tT ret = 0;\n\t\tfor(int x = a; x > 0; x -= x & -x) ret += vec[x];\n\t\treturn ret;\n\t}\n\t//クエリ\n\tT sum(long long a, long long b) { return sum0(b) - sum0(a); }\n\t//更新 クエリと併用で可能にした\n\tvoid update(long long place, T val, bool index = 0) {\n\t\tT old = sum(place, place + 1);\n\t\tadd(place, val - old);\n\t\treturn;\n\t}\n};\n\ntemplate <class T = ll>\nstruct edge {\n\tT len;\n\tll to;\n};\n\ntemplate <class T = ll>\nstruct graph {\t// 0-indexed\n\tvector<vector<edge<T>>> edges;\n\tbool directed, weight;\n\tlong long ver;\n\n\t// constructor\n\tgraph(long long vertex, bool direction = 0, bool weigh = 0) : edges(vertex) {\n\t\tver = vertex;\n\t\tdirected = direction;\n\t\tweight = weigh;\n\t\tedges.resize(vertex);\n\t}\n\n\t//辺の追加 (0-indexed)\n\tvoid update(long long from, long long to, T len = 1, bool direction = 1) {\n\t\tedge<T> e;\n\t\te.to = to;\n\t\te.len = len;\n\t\tedges[from].push_back(e);\n\t\tif(!direction) {\n\t\t\te.to = from;\n\t\t\tedges[to].push_back(e);\n\t\t}\n\t}\n\n\t//入力受取 (1-indexed)\n\tvoid input(long long edge_num, long long index = 1) {\n\t\trep(i, edge_num) {\n\t\t\tll a;\n\t\t\tll b;\n\t\t\tcin >> a >> b;\n\t\t\ta -= index;\n\t\t\tb -= index;\n\t\t\tT c;\n\t\t\tif(weight)\n\t\t\t\tcin >> c;\n\t\t\telse\n\t\t\t\tc = 1;\n\t\t\tupdate(a, b, c, directed);\n\t\t}\n\t}\n\n\t//長さが負のpathがないときの単一始点最短経路<vll> O((ver)log(ver)+(edge))\n\tvector<T> dijkstra(long long start) {\n\t\tvector<T> ret(ver, (T)dekai);\n\t\tpqup<pair<T, long long>> p;\t //{dist,place}\n\t\tp.push({0, start});\n\t\tret[start] = 0;\n\n\t\twhile(!p.empty()) {\n\t\t\tT dist = p.top().first;\n\t\t\tll place = p.top().second;\n\t\t\tp.pop();\n\t\t\tif(ret[place] < dist) continue;\n\t\t\tfor(auto &next : edges[place]) {\n\t\t\t\tll nextplace = next.to;\n\t\t\t\tT dis = next.len;\n\t\t\t\tif(chmin(ret[nextplace], dist + dis)) {\n\t\t\t\t\tp.push({ret[nextplace], nextplace});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//単一始点最短経路 O((ver)*(edge))\n\t//ある頂点までのコストが無限に小さくなり得るとき→ ret[i] = -dekai;\n\tvector<T> BellmanFord(long long start) {\n\t\tvector<T> ret(ver, dekai);\n\t\tret[start] = 0;\n\t\trep(loop, ver - 1) {\n\t\t\trep(v, ver) {\n\t\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\t\tchmin(ret[e.to], ret[v] + e.len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//無限降下点の検索\n\t\tqueue<ll> q;\n\t\tvb chk(ver, 0);\n\t\trep(v, ver) {\n\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\tif(chmin(ret[e.to], ret[v] + e.len)) {\n\t\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, ver) if(chk[i]) ret[i] = -dekai;\n\n\t\treturn ret;\n\t}\n\n\t//閉路に含まれない頂点列挙\n\t//要素数がver未満なら閉路が存在、そうでなければ閉路は存在しない\n\tvector<long long> topo_sort() {\n\t\tassert(directed);\n\t\tvector<long long> num_input(ver);\n\t\t// 入次数\n\t\tfor(long long i = 0; i < ver; i++) {\n\t\t\tfor(auto e : edges[i]) {\n\t\t\t\tnum_input[e.to]++;\n\t\t\t}\n\t\t}\n\t\t// 入次数が0のノードをqueueで管理する\n\t\tqueue<long long> que;\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(num_input[i] == 0) {\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t\tvector<long long> ans;\n\t\twhile(!que.empty()) {\n\t\t\tauto node = que.front();\n\t\t\tque.pop();\n\t\t\tans.push_back(node);\n\t\t\t// 頂点の削除\n\t\t\tfor(auto e : edges[node]) {\n\t\t\t\tnum_input[e.to]--;\n\t\t\t\t// 行き先の入次数が0になったらqueueに追加\n\t\t\t\tif(num_input[e.to] == 0) {\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//無向木構造を根から葉に伸びる有向木構造に書き換える\n\tgraph<T> RootToLeaf(ll root) {\t// 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvb chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(now, e.to, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//無向木構造を葉から根に伸びる有向木構造に書き換える\n\tgraph<T> LeafToRoot(ll root) {\t// 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvb chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(e.to, now, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\tret.update(root, root, 0);\n\t\treturn ret;\n\t}\n\n\t// LeafToRootのvector版.par[i]=iの親の頂点\n\tvector<long long> par(ll root) {  // 0-indexed\n\t\tvll ret(ver, -1);\n\t\tret[root] = root;  // rootの親はroot\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != -1) continue;\n\t\t\t\tret[e.to] = now;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\tvector<edge<T>> ParentAndDistance(ll root) {  // 0-indexed\n\t\tV<edge<T>> ret(ver);\n\t\trep(i, ver) ret[i].to = -1;\n\t\tret[root].to = root;  // rootの親はroot\n\t\tret[root].len = 0;\t  // rootの親との距離は0\n\t\tfunction<void(ll)> dfs = [&](ll now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to].to != -1) continue;\n\t\t\t\tret[e.to].to = now;\n\t\t\t\tret[e.to].len = e.len;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\tpair<pair<long long, long long>, T> DiameterOfTree() {\t//{{端点、端点},直径の大きさ}\n\t\tll v1, v2;\t\t\t\t\t\t\t\t\t\t\t// 0ともっとも遠い点、v1と最も遠い点\n\t\tV<T> dis(ver, -1);\n\t\tdis[0] = 0;\n\t\tqueue<ll> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(dis[e.to] != -1) continue;\n\t\t\t\tdis[e.to] = dis[now] + e.len;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t\tif(q.empty()) v1 = now;\n\t\t}\n\t\trep(i, ver) dis[i] = -1;\n\t\tdis[v1] = 0;\n\t\tq.push(v1);\n\t\twhile(!q.empty()) {\n\t\t\tll now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(dis[e.to] != -1) continue;\n\t\t\t\tdis[e.to] = dis[now] + e.len;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t\tif(q.empty()) v2 = now;\n\t\t}\n\t\tpair<pll, T> ans = {{v1, v2}, dis[v2]};\n\t\treturn ans;\n\t}\n\n\t//隣接sheet.主にwarshall用\n\tVV<T> GraphArray(void) {\n\t\tVV<T> ret(ver, V<ll>(ver, dekai));\n\t\trep(from, ver) {\n\t\t\tfor(auto &e : edges[from]) {\n\t\t\t\tret[from][e.to] = e.len;\n\t\t\t}\n\t\t\tret[from][from] = 0;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n#pragma region Segment_Trees\n\ntemplate <class T = ll>\nstruct STmax {\t//最大値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTmax(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\t\trep(i, size) { seg.push_back(-99999999977); }\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\t\t\tseg[v] = max(seg[v * 2 + 1], seg[v * 2 + 2]);\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での最大値を求める\n\t\tif(r <= a || b <= l) return -99999999977;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n\tT largest(ll a, ll b) {\n\t\tif(a >= b) return -99999999977;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct STmin {\t//最小値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTmin(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\t\trep(i, size) { seg.push_back(99999999977); }\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\t\t\tseg[v] = min(seg[v * 2 + 1], seg[v * 2 + 2]);\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での最大値を求める\n\t\tif(r <= a || b <= l) return 99999999977;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\tT smallest(ll a, ll b) {\n\t\tif(a >= b) return 99999999977;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct STsum {\t//区間の合計値を測るセグ木\n\tll size;\t// treeの葉の数=m*2-1\n\tll m;\t\t// tree最下段の数\n\tvector<T> seg;\n\tSTsum(long long n) : size(n), m(n), seg(0) {\n\t\tm = 1;\n\t\twhile(m < n) {\n\t\t\tm *= 2;\n\t\t}\n\t\tsize = m * 2 - 1;\n\n\t\trep(i, size) { seg.push_back(0); }\n\t\t//改造時はここをまず変える\n\t}\n\tvoid update(ll i, T k) {  // i番目をkに更新\n\t\tll v = i + m - 1;\n\t\tseg[v] = k;\n\t\twhile(v > 0) {\n\t\t\tv = (v - 1) / 2;\n\n\t\t\tseg[v] = seg[v * 2 + 1] + seg[v * 2 + 2];\n\t\t\t//改造時はここを変える\n\t\t}\n\t}\n\tT query(ll a, ll b, ll k, ll l, ll r) {\t //区間[a,b)での合計値を求める\n\t\tif(r <= a || b <= l) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\t// cout << \"#\" << a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn vl + vr;\t //改造時はここを変える\n\t}\n\tT sum(ll a, ll b) {\n\t\tif(a >= b) return 0;\n\t\treturn query(a, b, 0, 0, m);\n\t}\n};\n\ntemplate <class T = ll>\nstruct ST {\t //セグ木まとめ\n\tSTmax<T> stmax;\n\tSTmin<T> stmin;\n\tSTsum<T> stsum;\n\tST(long long n) : stmax(n), stmin(n), stsum(n) {}\n\tvoid update(ll place, T val) {\n\t\tstmax.update(place, val);\n\t\tstmin.update(place, val);\n\t\tstsum.update(place, val);\n\t}\n\tT largest(ll a, ll b) { return stmax.largest(a, b); }\n\tT smallest(ll a, ll b) { return stmin.smallest(a, b); }\n\tT sum(ll a, ll b) { return stsum.sum(a, b); }\n};\n\n#pragma endregion\n#pragma endregion\n\n////////////// 工事中 ////////////////////////\n#pragma region making\n// //ダブリング\n// // reach : 2^reach 先まで検索\n// VV<edge> doublize(vll &v, ll reach) {  // vは子から親へのvector\n// \tll n = v.size();\n// \tVV<long long> ret(n, 20);\n// }\n#pragma endregion\n\n////////////////// メモ //////////////////////\n#pragma region memo\n#pragma region update_memo\n// ilb9からの変更点\n//:STmin,STmax,STsumの型を一般化 #pragmaによる畳み込み\n//:STをまとめたSTallの作成\n\n//更新予定\n//:幾何ライブラリ作成\n//ダブリング/木の最短経路検索\n//有理数class\n//範囲更新セグ木(LazyST?)\n//文字列Algorithm(Z,KMP)\n#pragma endregion\n#pragma region programming_memo\n// Ctrl+Shift+[：折りたたみ\n// Ctrl+Shift+]：展開\n// Ctrl+k Ctrl+l：折り畳み／展開のトグル\n// Ctrl+k Ctrl+[：再帰的に折りたたみ\n// Ctrl+k Ctrl+]：再帰的に展開\n// Ctrl+k Ctrl+0：すべて折りたたみ\n// Ctrl+k Ctrl+j：すべて展開\n// Ctrl+k Ctrl+1：レベル1で折りたたみ\n// Ctrl+k Ctrl+2：レベル2で折りたたみ\n// Ctrl+k Ctrl+3：レベル3で折りたたみ\n// Ctrl+k Ctrl+8：すべての領域（region）の折りたたみ\n// Ctrl+k Ctrl+9：すべての領域（region）の展開\n// Ctrl+k Ctrl+/：すべてのブロックコメントの折りたたみ\n\n// long long intとして表示 (印字対象データの最上位ビットが立っているので負数とみなされる)\n// printf(\"case3: %lld\\n\", a);\n\n// c char 文字\n// s char *文字列\n// d int, short 10進の整数\n// u unsigned int, unsigned short 10進の符号なし整数\n// o int, short, unsigned int,unsigned short 8進の整数\n// x int, short, unsigned int,unsigned short 16進の整数\n// f float 浮動小数点数\n// e float 浮動小数点数の指数表示\n// g float %eもしくは %fのどちらか最適な形式の浮動小数点数\n// ld long 10進の倍精度整数\n// lu unsinged long 10進の符号なし倍精度整数\n// lo long,unsinged long 8進の倍精度整数\n// lf double 倍精度浮動小数点数\n// a double 16進の倍精度浮動小数点数\n// lld long long\n#pragma endregion\n#pragma endregion\n\nint main() {\n\tll n;\n\tcin >> n;\n\tgraph<> tr(n);\n\ttr.input(n - 1);\n\tauto g = tr.RootToLeaf(0);\n\n\tfunction<ll(ll)> dfs = [&](ll now) {\n\t\tll res = 0;\n\t\tfor(auto &e : g.edges[now]) {\n\t\t\tres ^= dfs(e.to) + 1;\n\t\t}\n\t\t//cout << now << \" \" << res << endl;\n\t\treturn res;\n\t};\n\n\tcout << (dfs(0) ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ninline void read(int &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n;\nvi g[N];\nbool tag[N],vis[N];\n\null dfs(int x){\n\tvis[x]=1;\n\tvector<ull> Hash;Hash.clear();\n\tull h=1,du=1;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tHash.pb(dfs(y));\n\t}\n\tif(!Hash.size()){\n\t\th+=1284743ull*du*du*du;\n\th^=91348377ull*du;\n\t\treturn h;\n\t}\n\tsort(Hash.begin(),Hash.end());\n\tfor(int i=0;i<Hash.size()-1;i++)\n\t\tif(Hash[i]==Hash[i+1]) tag[i]=tag[i+1]=1,i++;\n\tfor(int i=0;i<Hash.size();i++)\n\t\tif(!tag[i]) h=h*Hash[i],du++;\n\tfor(int i=0;i<Hash.size();i++) tag[i]=0;\n\th+=1284743ull*du*du*du;\n\th^=91348377ull*du;\n\treturn h;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tvector<ull> Hash;Hash.clear();\n\tvis[1]=1;\n\tfor(int i:g[1])\n\t\tHash.pb(dfs(i));\n//\tdebuge;\n\tsort(Hash.begin(),Hash.end());\n\tif(Hash.size()&1){puts(\"Alice\");return 0;}\n\tfor(int i=0;i<Hash.size();i+=2)\n\t\tif(Hash[i]!=Hash[i+1]){puts(\"Alice\");return 0;}\n\tputs(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvector <int> v[100000];\n\nint dfs(int x, int y) {\n    int g = 0, i;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        if (v[x][i] == y) continue;\n        \n        g ^= dfs(v[x][i], x) + 1;\n    }\n    \n    return g;\n}\n\nint main() {\n    int n, i;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n - 1; i++) {\n        int x, y;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        x--;\n        y--;\n        \n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    \n    if (dfs(0, -1) == 0) {\n        puts(\"Bob\");\n    } else {\n        puts(\"Alice\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\n\nvoid input() {\n\tcin >> n;\n\tg.resize(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n}\n\nint grundy(int s = 0, int p = -1) {\n\tint res = 0;\n\tfor (auto c : g[s]) {\n\t\tif (c != p) {\n\t\t\tint tmp = grundy(c, s);\n\t\t\tres ^= (tmp + 1);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tinput();\n\tcout << (grundy() ? \"Alice\" : \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nvector<int> e[ten(5)];\nll hs[ten(5)];\n\nll dfs(int v, int par) {\n\tmap<ll, int> dm;\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tll tmp = dfs(to, v);\n\t\tdm[tmp] ^= 1;\n\t}\n\tll pv = 1;\n\tll h = 1;\n\tfor (auto kv : dm) {\n\t\tif (kv.second == 0) continue;\n\t\th *= ten(8) + 7;\n\t\tpv += kv.first * h;\n\t}\n\n\treturn hs[v] = pv % (ten(9) + 7);\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tll ret = dfs(0, -1);\n\tputs(ret == 1 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n, a, b; vector<int>x[125000]; bool used[125000];\nint dfs(int pos) {\n\tused[pos] = true;\n\tint s = 0;\n\tfor (int i = 0; i < x[pos].size(); i++) {\n\t\tif (used[x[pos][i]] == true)continue;\n\t\ts ^= (dfs(x[pos][i]) + 1);\n\t}\n\treturn s;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b;\n\t\tx[a].push_back(b);\n\t\tx[b].push_back(a);\n\t}\n\tint G = dfs(1);\n\tif (G == 0)cout << \"Bob\" << endl;\n\telse cout << \"Alice\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,head[MN+5],cnt=0,f[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)\n\t\t{\n\t\t\tdfs(e[i].to,x);\n\t\t\tf[x]^=f[e[i].to]+1;\t\t\t\n\t\t}\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nint Next[220000],h[220000],v[220000],tot,sg[220000];\nint n;\nint add(int x,int y){\n\ttot++;\n\tNext[tot]=h[x];\n\tv[tot]=y;\n\th[x]=tot;\n}\nint dfs(int x,int fa){\n\tfor(int i=h[x];i;i=Next[i]){\n\t\tif(v[i]==fa)continue;\n\t\tdfs(v[i],x);\n\t\tsg[x]^=sg[v[i]];\n\t}\n\tif(x!=1)sg[x]++;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs(1,0);\n\tif(sg[1])printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define mp make_pair\n#define pb push_back\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define rep(i, x, y) for(int (i) = (x); (i) <= (y); (i) ++)\n#define eps 1e-9\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int N = 100010;\nstruct edge\n{\n\tint s,t,next;\n}e[N << 1];\nint head[N], cnt;\nvoid insert(int s,int t)\n{\n\te[cnt].s = s;\n\te[cnt].t = t;\n\te[cnt].next = head[s];\n\thead[s] = cnt ++;\n\te[cnt].s = t;\n\te[cnt].t = s;\n\te[cnt].next = head[t];\n\thead[t] = cnt ++;\n}\nint n, u, v;\nint sg[N];\nvoid dfs(int x, int fa)\n{\n\tsg[x] = 0;\n\tfor (int i = head[x]; i != -1; i = e[i].next)\n\t\tif (e[i].t != fa)\n\t\t{\n\t\t\tdfs(e[i].t, x);\n\t\t\tsg[x] ^= (sg[e[i].t] + 1);\n\t\t}\n}\nint main()\n{\n\tn = read();\n\tmemset(head, 0xff, sizeof(head));\n\tcnt = 0;\n\trep(i, 1, n - 1)\n\t{\n\t\tu = read();\n\t\tv = read();\n\t\tinsert(u, v);\n\t}\n\tdfs(1,1);\n\tputs(sg[1] == 0 ? \"Bob\" : \"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=500050;\n\nint head[N],to[N],nex[N],sg[N],n,tot;\n\nvoid addedge(int u,int v){\n\ttot++;to[tot]=v,nex[tot]=head[u],head[u]=tot;\n\ttot++;to[tot]=u,nex[tot]=head[v],head[v]=tot;\n}\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=nex[i]){\n\t\tif(to[i]!=fa){\n\t\t\tdfs(to[i],x);\n\t\t\tsg[x]^=sg[to[i]]+1;\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\taddedge(j,k);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, int> P;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nint x[100100], y[100100];\n\nvector<int> G[100100];\n\nint calc(int v, int prev) {\n    int g = 0;\n    for (int u : G[v]) {\n        if (u == prev)\n            continue;\n        g ^= (calc(u, v) + 1);\n    }\n    return g;\n}\n\nbool solve() {\n    for (int i = 0; i < n-1; i++) {\n        G[x[i]].push_back(y[i]);\n        G[y[i]].push_back(x[i]);\n    }\n\n    return (calc(0, -1) > 0);\n}\n\nvoid input() {\n    cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        cin >> x[i] >> y[i];\n        x[i]--;\n        y[i]--;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << (solve()?\"Alice\":\"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef long double ldo;\n\n#define pb push_back\nconst int MAX = 1e5 + 20;\nlong long n, x, res;\nvector<int> g[MAX];\n\nint dfs (int v, int r) {\n\tres = 0;\n\tfor (auto i : g[v])\n\t\tif (i != r)\n\t\t\tres ^= dfs (i, v);\n\n\treturn res + 1;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tx = dfs (0,0);\n\n\tcout << (x==1 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint n;\nvector<int > e[maxn];\n\nint dfs(int x,int fa) {\n    int s=0;\n    for(auto v:e[x])\n        if(v!=fa) s^=dfs(v,x)+1;\n    return s;\n}\n\nint main() {\n    read(n);\n    for(int i=1,x,y;i<n;i++) read(x),read(y),e[x].pb(y),e[y].pb(x);\n    puts(dfs(1,0)?\"Alice\":\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nvector<int> g[100010];\nbool used[100010];\n\nint dfs(int now){\n    used[now]=true;\n    int res=0;\n    for(int i=0;i<g[now].size();i++){\n        int next=g[now][i];\n        if(used[next]) continue;\n\n        res^=dfs(next);\n    }\n    return(res+1);\n}\n\nint main(){\n  cin>>N;\n  for(int i=1;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      x--;\n      y--;\n      g[x].push_back(y);\n      g[y].push_back(x);\n  }\n\n  used[0]=true;\n  int ans=0;\n  for(int i=0;i<g[0].size();i++){\n      int grundy=dfs(g[0][i]);\n      //grundy--;\n      ans^=grundy;\n  }\n\n  if(ans==0) cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\n\nint n;\nvector<int>e[maxn];\n\nint dfs(int x,int fa){\n  int ret=0;\n  for(int i=0;i<e[x].size();i++){\n    int v=e[x][i];\n    if(v==fa)continue;\n    ret^=(1+dfs(v,x));\n  }\n  return ret;\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"in.cpp\",\"r\",stdin);\n#endif\n  cin>>n;\n  for(int i=1;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  if(dfs(1,0))cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100010;\nint n, f[maxn];\nvector<int> G[maxn];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d %d\", &u, &v);\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    function<void(int, int)> dfs = [&](int v, int fa) {\n        for (int u : G[v]) if (u ^ fa) {\n            dfs(u, v), f[v] ^= f[u] + 1;\n        }\n    };\n    dfs(1, 0), printf(\"%s\\n\", f[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <queue>\n#include <limits>\n#include <deque>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#define mp make_pair\n#define fs first\n#define se second\n#define memset(a,t) memset(a,t,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define MN 0LL\n#define Mx 200000005\n#define Mn -Mx\n#define MX 20000000000000005\nusing namespace std;\nint readint(){\n\tchar c;\n\twhile(c=getchar(),(c<'0'||c>'9')&&c!='-');\n\tbool flag=(c=='-');\n\tif(flag)c=getchar();\n\tint x=0;\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn flag?-x:x;\n}\ninline string tos(int x){\n\tstring s;\n\twhile(x) s=(char)(x%10+'0')+s,x/=10;\n\treturn s;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n,x=0,a,b,i;\n\tcin>>n;\n\tn--; \n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b;\n\t\tif(a==1||b==1) x++;\n\t}\n\tif(x==1){\n\t\tcout<<\"Alice\"<<endl;\n\t\treturn 0;\n\t}\n\tif(x%2==0) cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n  \n  function<Int(Int, Int) > dfs=\n    [&](Int v,Int p)->Int{\n      Int res=0;\n      for(Int u:G[v])\n        if(u!=p) res^=dfs(u,v)+1;\n      return res;\n    };\n  \n  cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 100010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint gr[MAXN];\nint mark[MAXN];\nvector<int> G[MAXN];\n\nvoid dfs(int node, int par){\n\tfor (int v:G[node]) if (v!=par){\n\t\tdfs(v, node);\n\t\tgr[node]^=gr[v]+1;\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tcin>>u>>v;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tdfs(1, 1);\n\t\n\tif (gr[1]) kill(\"Alice\")\n\tkill(\"Bob\")\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SegtreeMin {\n    int n;\n    long long inf;\n    vector<long long> dat;\n\n    void initialize(int n_input, long long inf_input){\n        inf = inf_input;\n        n = 1;\n        while(n < n_input)n <<= 1;\n        dat.resize(2*n-1);\n        for(int i = 0; i<2*n-1; i++) dat[i] = inf;\n    }\n\n    void update(int k, long long a){\n        k += n - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1)/2;\n            dat[k] = min(dat[2*k+1], dat[2*k+2]);\n        }\n    }\n\n    long long min_between(int a, int b){\n        return query(a, b+1, 0, 0, n);\n    }\n\n    long long query(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l)return inf;\n        if(a<=l && r<=b)return dat[k];\n        long long vl = query(a, b, 2*k+1, l, (l+r)/2);\n        long long vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\n\nint N;\nconst int MAX = 100000;\nvector<int> edges[MAX];\nint grundy[MAX];\nint gnum[MAX];\nSegtreeMin st;\n\nint dfs(int i, int prev){\n    int gr = st.min_between(0, N-1);\n    gnum[gr]++;\n    st.update(gr, MAX);\n\n    int ret = gr;\n    for(auto j : edges[i]){\n        if(j == prev) continue;\n        ret ^= dfs(j, i);\n    }\n    \n    gnum[gr]--;\n    if(gnum[gr] == 0) st.update(gr, gr);\n    return ret;\n}\n\nint main(){\n    int i, j, k;\n    cin >> N;\n    for(i=0; i<N-1; i++){\n        int x, y;\n        cin >> x >> y;\n        edges[x-1].push_back(y-1);\n        edges[y-1].push_back(x-1);\n    }\n    st.initialize(N, MAX);\n    for(i=0; i<N; i++) st.update(i, i);\n\n    int gr = dfs(0, -1);\n    cout << (gr!=0 ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// In the name of God\n#include <bits/stdc++.h>\n//#define int long long\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\n\n#define y1 def1\n#define X first\n#define Y second\n#define endl '\\n'\n#define all(o) o.begin(), o.end()\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\nconst int maxn = 1e5 + 10;\nvi adj[maxn];\nint dfs(int v,int p){\n    int res = 0;\n    for(auto u : adj[v])\n        if(u != p) res ^= (dfs(u, v) + 1);\n    return res;\n}\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0; i<n-1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    if(dfs(0, 0))\n        cout << \"Alice\" << endl;\n    else\n        cout << \"Bob\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define LL long long\n#define PB push_back\n#define MP make_pair\n#define I insert\n \nconst LL N = 1e5+5, mod = 1000000007;\n \nusing namespace std;\n \nLL n, m, i, j, k, l, r, t, ans, a[N];\nvector < LL > v[N];\n\nvoid go ( LL u, LL par = 0 ){\n\tfor ( LL i = 0; i < v[u].size(); ++i ){\n\t\tif ( v[u][i] == par ) continue;\n\t\tgo ( v[u][i], u );\n\t\ta[u] ^= (a[v[u][i]]+1);\n\t}\n\t//if ( u == 1 && v[u].size() == 1 || u != 1 && v[u].size() == 2 ) a[u]++;\n}\n\nint main(){\n\tcin >> n;\n\tfor ( i = 1; i < n; ++i ){\n\t\tcin >> l >> r;\n\t\tv[l].PB(r);\n\t\tv[r].PB(l);\n\t}\n\t\n\tgo(1);\n\t\n\tif ( a[1] ) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\t\n\treturn 0;\n}\n \n/**/\n//      IIIIIIIII      OOOOO             A          NN        N    EEEEEEEEEE\n//          I         O     O           A A         N N       N    E\n//          I        O        O         A   A        N  N      N    E\n//          I        O       O        A     A       N   N     N    E\n//          I        O       O       AAAAAAAAA      N    N    N    EEEEEEEE\n//          I        O       O      A         A     N     N   N    E\n//          I        O       O     A           A    N      N  N    E\n//          I         O     O     A             A   N       N N    E\n//      IIIIIIIII      OOOOO     A               A  N        NN    EEEEEEEEEE ___ KAPANADZE"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \")\n{ if (!v.size()) puts(\"\"); rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nint n;\nvector<vi> G;\nbool used[101010] = {true};\n\nbool f(int v = 0) {\n\n  bool ret = false;\n  int cnt = 0;\n\n  for (int i = 0; i < G[v].size(); ++i) {\n    if (used[G[v][i]]) continue;\n    used[G[v][i]] = true;\n    cnt++;\n    ret ^= f(G[v][i]);\n  }\n\n  if (cnt == 1) return true;\n  if (cnt == 0) return false;\n\n  return ret;\n}\n\nsigned main() {\n  cin >> n;\n\n  G.resize(n);\n\n  rep(i, n - 1) {\n    int a = in() - 1, b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  cout << (f() ? \"Alice\" : \"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nvector <int> g[N];\nint dp[N];\n\nvoid dfs(int v, int pr)\n{\n    for (int to : g[v])\n    {\n        if (to != pr)\n        {\n            dfs(to, v);\n            dp[v] ^= dp[to] + 1;\n        }\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1, -1);\n    if (dp[1] == 0)\n    {\n        cout << \"Bob\" << '\\n';\n    }\n    else\n    {\n        cout << \"Alice\" << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n\nconst int mxN= 100010;\nvector<int> tree[mxN];\n\nint dfs(int v = 0,int p = -1) {\n\tint res = 0;\n\tfor(auto u : tree[v]) if(u != p) res ^= dfs(u,v);\n\tif(v) res ++;\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint N,u,v;\n\tcin>>N;\n\tfor(int i = 1;i < N;i++) {\n\t\tcin>>u>>v;\n\t\tu--,v--;\n\t\ttree[u].push_back(v);\n\t\ttree[v].push_back(u);\n\t}\n\tint res = dfs();\n\tcout<<(res?\"Alice\":\"Bob\")<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nint n;\nvector<vector<int>> g;\n\nint dfs(int pre,int now){\n    int ret=0;\n    for(auto to:g[now])if(to!=pre) ret^=1+dfs(now,to);\n    return ret;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    cin>>n;\n    g.resize(n);\n    rep(i,n-1){\n        int u,v;cin>>u>>v;u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int res=dfs(-1,0);\n    if(res==0) cout<<\"Bob\\n\";\n    else cout<<\"Alice\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max<int>(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max<int>(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\nstruct fix_point: private T {\n  explicit constexpr fix_point(T &&func): T(std::forward<T>(func)) { }\n  template <class... Args>\n  constexpr decltype(auto) operator () (Args &&... args) const {\n    return T::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T>\nconstexpr decltype(auto) make_fix_point(T &&func) {\n  return fix_point<T>{std::forward<T>(func)};\n}\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<std::vector<int>> graph(N);\n  for (int i: range(0, N - 1)) {\n    int x, y;\n    std::cin >> x >> y;\n    --x; --y;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  std::cout << (make_fix_point([&](auto &&dfs, int u, int p) -> int {\n    int grundy = 0;\n    for (int v: graph[u]) {\n      if (v != p) {\n        grundy ^= dfs(v, u) + 1;\n      }\n    }\n    return grundy;\n  })(0, -1) > 0 ? \"Alice\" : \"Bob\") << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n \ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n \ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n \nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n \n \nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n \nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n \nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n \ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n \ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n \ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n \ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n \ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n \ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint n,q[100005];\nvi g[100005];\nvoid dfs(int v,int p){\n\tint ch=0;\n\tfor(auto &i:g[v]){\n\t\tif(i==p)continue;\n\t\tdfs(i,v);\n\t\tch++;\n\t\tq[v]^=(!q[i]);\n\t}\n\tif(ch==1)q[v]=1;\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[--a].eb(--b);\n\t\tg[b].eb(a);\n\t}\n\tdfs(0,-1);\n\tif(q[0])cout<<\"Alice\\n\";\n\telse cout<<\"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2017 Mstdream\n#include<bits/stdc++.h>\nusing namespace std;\ninline void splay(int &v){\n\tv=0;char c=0;int p=1;\n\twhile(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();}\n\tv*=p;\n}\nconst int N=200020;\nint nxt[N*2],fir[N],to[N*2],sz,n,dp[N];\nvoid add(int x,int y){\n\tnxt[++sz]=fir[x],fir[x]=sz,to[sz]=y;\n}\n//1先手0后手\nint q[N],fa[N];\nint main(){\n\t//freopen(\"xxx.in\",\"r\",stdin);\n\tsplay(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;splay(x),splay(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tint l=0,r=1;q[1]=1;\n\twhile(l!=r){\n\t\tl++;\n\t\tint v=q[l];\n\t\tfor(int u=fir[v];u;u=nxt[u]){\n\t\t\tif(to[u]!=fa[v]){\n\t\t\t\tq[++r]=to[u];\n\t\t\t\tfa[to[u]]=v;\n\t\t\t} \n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tint x=q[i];\n\t\tint a=0,b=0;\n\t\tfor(int u=fir[x];u;u=nxt[u]){\n\t\t\tif(to[u]!=fa[x]){\n\t\t\t\tif(dp[to[u]]==1)a++;\n\t\t\t\telse b++;\n\t\t\t} \n\t\t}\n\t\tif((b&1)==1)dp[x]=1;\n\t\telse{\n\t\t\tif((a&1)==1)dp[x]=1;\n\t\t\telse dp[x]=0;\n\t\t}\n\t}\n\tputs(dp[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=1e7;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; std::swap(a, b);\n        u -= t * v; std::swap(u, v);\n    }\n    u %= m; \n    if (u < 0) u += m;\n    return u;\n}\nvoid dfs(ll X,vi &subtree,vii &edge){\n    subtree[X]=1;\n    rep(i,0,edge[X].size()){\n        ll Y=edge[X][i];\n        if(!subtree[Y]){\n            dfs(Y,subtree,edge);\n            subtree[X]+=subtree[Y];\n        }\n    }\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N; cin>>N;\n    vii edge(N);\n    rep(i,1,N){\n        ll X,Y; cin>>X>>Y;\n        edge[X-1].pb(Y-1);\n        edge[Y-1].pb(X-1);\n    }\n    vi subtree(N);\n    ll sum=0;\n    dfs(0,subtree,edge);\n    string ans=\"Bob\";\n    rep(i,0,N){\n        if(edge[i].size()>2&&subtree[i]%2==0) ans=\"Alice\";\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  //dfs(1);\n  int ans=0;\n  for(int i=0;i<n+111;i++){\n    if((int)v[i].size()%2){\n      ans++;\n    }else ans--;\n  }\n  ans=abs(ans);\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<cstdio>\nusing namespace std;\nint n[100005]={0};\nint N,M;\nint main()\n{\n\twhile(scanf(\"%d\",&N)!=EOF)\n\t{\n\t\tmemset(n,0,sizeof(n));\n\t\tint ans=0;\n\t\tfor(int i=1;i<=N-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==1||y==1)\n\t\t\t{\n\t\t\t\tif(x+y-1!=1&&n[x+y-1]!=1)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tn[x+y-1]=1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans%2==1)\n\t\tcout<<\"Alice\"<<endl;\n\t\telse\n\t\tcout<<\"Bob\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 101000;\n\nint n, sg[N];\n\nstruct Edge\n{\n    int nxt, to;\n} eg[N << 1];\nint head[N], en;\n\nvoid setEdge(int u, int v)\n{\n    eg[++en] = (Edge){head[u], v};\n    head[u] = en;\n}\n\nvoid dfs(int u, int fa)\n{\n    for (int e = head[u]; e; e = eg[e].nxt)\n    {\n        int v = eg[e].to;\n        if (v == fa) continue;\n        sg[u] ^= (sg[v] + 1);\n    }\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        setEdge(u, v);\n        setEdge(v, u);\n    }\n    dfs(1, 0);\n    puts(sg[1] ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstatic const int MAXN = 100000 + 10;\n\nstruct TreeNode{\n    vector<int> sons;\n} trees[MAXN];\n\nint dfs(int root, int fa) {\n    int cnt = 0;\n    int val = 0;\n    for (int son : trees[root].sons) {\n        if (son == fa) continue;\n        val = val ^ dfs(son, root);\n        cnt++;\n    }\n    if (cnt == 1) return val+1;\n    else return val;\n\n}\n\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    int n;\n    scanf(\"%d\", &n);\n    int x, y;\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        trees[x].sons.push_back(y);\n        trees[y].sons.push_back(x);\n    }\n    int val = dfs(1, 0);\n    if (val != 0) {\n        cout << \"Alice\" << endl;\n    }\n    else cout << \"Bob\" << endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll Size(vector<T> &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvvll cinGraph(ll nodeNum, ll edgeNum, bool isDirected){//無向false、有向true\n\tvvll to(nodeNum);\n\tREP(i, edgeNum){\n\t\tll v, u; cin >> v >> u;\n\t\tv--; u--;\n\t\tto[v].push_back(u);\n\t\tif (!isDirected) to[u].push_back(v);\n\t}\n\treturn move(to);\n}\n\nvvll to;\n\n\nvll gr;\n\nvoid dfs(ll v, ll p){\n\t\n\tEACH(u, to[v]){\n\t\tif (u==p) continue;\n\n\t\tdfs(u, v);\n\t\tgr[v] ^= gr[u];\n\t}\n\n\tif (p!=-1) gr[v]++;\n}\n\n\nvoid solve()\n{\n\tll N;  cin >> N;\n\tto = cinGraph(N, N-1, false);\n\t\n\tgr.resize(N);\n\n\tdfs(0, -1);\n\n\tif (gr[0] == 0) cout << \"Bob\" << '\\n';\n\telse            cout << \"Alice\" << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 110000;\n\nint n,m;\nstruct edge{int y,nex;}a[maxn<<1]; int len,fir[maxn];\ninline void ins(const int x,const int y){a[++len]=(edge){y,fir[x]};fir[x]=len;}\n\nint sg[maxn];\n\nvoid dp(const int x,const int fa)\n{\n\tsg[x]=0;\n\tfor(int k=fir[x],y=a[k].y;k;k=a[k].nex,y=a[k].y) if(y!=fa)\n\t{\n\t\tdp(y,x); sg[x]^=(sg[y]+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tins(x,y); ins(y,x);\n\t}\n\t\n\tdp(1,0);\n\tif(sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N=1e5+100;\nvi g[N];\n\nbool dfs(int v, int pr){\n    int tr=0,fl=0;\n    for(auto to:g[v]){\n        if(to==pr)\n            continue;\n        bool u=dfs(to,v);\n        if(u)\n            tr++;\n        else\n            fl++;\n    }\n    if(tr%2==0&&fl%2==0)\n        return false;\n    return true;\n}\n\n\nvoid smain() {\n\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    bool u=dfs(1,1);\n    if(u)\n        cout<<\"Alice\";\n    else\n        cout<<\"Bob\";\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 1;\n    } else {\n        vector<int> tomex;\n        {\n            int cx = 0;\n            for (auto t : sons) {\n                cx ^= gr[t];\n            }\n            tomex.push_back(cx);\n            if (sons.size() > 1) {\n                for (auto t : sons) {\n                    tomex.push_back(cx ^ gr[t]);\n                }\n            }\n        }\n        gr[cur] = mexx(tomex);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    if (gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdlib> \n#include<stdio.h> \n#include<memory.h> \n#include<vector> \nusing namespace std; \nvector<int>v[100005]; \nint dfs(int x,int pre) \n{ \n    int ans=0; \n    for(int i=0;i<v[x].size();i++) \n    { \n       \n        if(v[x][i]!=pre) \n        { \n            ans^=(1+dfs(v[x][i],x)); \n        } \n    } \n    return ans; \n} \nint main() \n{ \n    int t,a,b,n; \n    scanf(\"%d\",&t); \n    while(t--) \n    { \n        scanf(\"%d\",&n); \n        for(int i=1;i<=n;i++) \n        v[i].clear(); \n        n--; \n        while(n--) \n        { \n            scanf(\"%d%d\",&a,&b); \n            v[a].push_back(b); \n            v[b].push_back(a); \n        } \n       \n        if(dfs(1,-1)) puts(\"Alice\"); \n        else puts(\"Bob\"); \n    } \n} "
  },
  {
    "language": "C++",
    "code": "/****** BISMILLAH HIR RAHMANIR RAHIM ******/\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<string,string> mss;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef map <int, vector<string> > mvis;\ntypedef map <string, vector<int> > mvsi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define INF 2000000000\n#define pb push_back\n#define MAX 100002\n#define debug cout<<\"A\"<<\"\\n\"\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=b; i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define ClearQ(x); while(!x.empty()) x.pop()\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n; vi graph[MAX];\n\nint dfs(int u, int p)\n{\n\tint ret=0;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tif(v==p) continue;\n\t\tret^=(dfs(v,u)+1);\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    cin>>n;\n\n    int u, v;\n\n    FOR(i,0,n-1)\n    {\n    \tcin>>u>>v;\n\n    \tgraph[u].pb(v);\n    \tgraph[v].pb(u);\n    }\n\n    if(dfs(1,0)) prnt(\"Alice\");\n    else prnt(\"Bob\");\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\") \nusing namespace std;\ntypedef long long lint;\ntypedef long double ldb;\ntypedef unsigned long long uli;\n\n#define X first\n#define Y second\n#define F(i, l, r) for(auto i = l; i != r; i++)\n#define Df(i, l, r) for(auto i = l; i != r; i--)\n#define I(i, a) for(auto i : a)\n#define pb push_back\n#define rs resize\n#define mk make_pair\n#define asg assign\n#define all(x) x.begin(),x.end()\n#define ret return\n#define cont continue\n#define brk break\n#define ins insert\n#define era erase\n#define fi0(x) memset(x, 0, sizeof(x))\n#define finf(x) memset(x, 127, sizeof(x))\n#define acpy(y, x) memcpy(y, x, sizeof(y))\n#define y1 adjf\n#define tm afhdhn\n\nconst int MAXN = 1e5 + 5;\n\nint n;\nvector<int> gr[MAXN];\nint g[MAXN];\n\nvoid dfs(int v, int p = -1){\n\tg[v] = 0;\n\tI(u, gr[v]){\n\t\tif(u == p)cont;\n\t\tdfs(u, v);\n\t\tg[v] ^= (g[u] + 1);\n\t}\n}\n\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tscanf(\"%d\", &n);\n\tF(i, 0, n - 1){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--; u--;\n\t\tgr[v].pb(u); gr[u].pb(v);\n\t}\n\tdfs(0);\n\tif(g[0] == 0)printf(\"Bob\"); else printf(\"Alice\");\n\tret 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\ntemplate<class T>\nvoid read_1d(std::vector<T>& a,int64_t num){\n\ta.reserve(num);\n\tfor(int64_t i1=0;i1<num;i1++){\n\t\tT temp;\n\t\tcin>>temp;\n\t\ta.push_back(temp);\n\t}\n}\ntemplate<class T>\nvoid read_2d(std::vector<std::vector<T> >&a,int64_t x,int64_t y ){\n\ta.resize(x);\n\tfor(int64_t i1=0;i1<x;i1++){\n\t\ta[i1].reserve(y);\n\t\tfor(int64_t i2=0;i2<y;i2++){\n\t\t\tT temp;\n\t\t\tcin>>temp;\n\t\t\ta[i1].push_back(temp);\n\t\t}\n\t}\n}\ntemplate<class InputIterator>\nvoid debug(InputIterator first,InputIterator last){\n\tfor(auto i1=first;i1!=last;i1++){\n\t\tcout<<(*i1)<<endl;\n\t}\n}\n#include <limits>\n#include <vector>\n#include <queue>\nclass Vertex;\nclass Edge{\npublic:\n\tfriend class Vertex;\n\tfriend class Graph;\n\tVertex* from;\n\tVertex* to;\n\tint64_t cost;\npublic:\n\tEdge(Vertex* from,Vertex* to,int64_t cost=0){\n\t\tthis->from=from;\n\t\tthis->to=to;\n\t\tthis->cost=cost;\n\t}\n\n};\nstruct Dijkstra{\n\tint64_t d;\n\tVertex* parent;\n\tbool searched;\n};\n\nclass Vertex{\n\tfriend class Graph;\npublic:\n\n\tstd::vector<Edge*> departure;\n\tstd::vector<Edge*> arrival;\n\tbool searched=false;\n\n\tDijkstra dijk_data;\n\tint32_t id;\n\tbool count_finish=false;\n\tvoid add_edge(Edge* d){\n\t\tdeparture.push_back(d);\n\t\td->to->arrival.push_back(d);\n\t}\n\tvoid initialize_Dijkstra(){\n\t\tdijk_data.d=std::numeric_limits<int64_t>::max();\n\t\tdijk_data.parent=NULL;\n\t\tdijk_data.searched=false;\n\t}\n\tint32_t count_union(Edge* e1,Edge* e2){\n\t\tint32_t retval=1;\n\t\tcount_finish=true;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(temp==e1||temp==e2||temp->to->count_finish){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tretval+=temp->to->count_union(e1,e2);\n\t\t}\n\t\treturn retval;\n\t}\n\tint64_t game(){\n\t\tsearched=true;\n\t\tint64_t size=0;\n\t\tint64_t xor_num=0;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(!temp->to->searched){\n\t\t\t\tsize++;\n\t\t\t\tint64_t c_ans=temp->to->game();\n\t\t\t\txor_num=xor_num^c_ans;\n\t\t\t}\n\t\t}\n\t\tif(size==0){\n\t\t\treturn 1;\n\t\t}else if(size==1){\n\t\t\treturn xor_num+1;\n\t\t}else if(xor_num==0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 2;\n\t\t}\n\t}\n};\nclass dijkstra_calc{\npublic:\n\tint64_t current_cost;\n\tVertex* from;\n\tVertex* to;\n\tdijkstra_calc(const int64_t cost, Vertex* c1,Vertex* c2):current_cost(cost),from(c1),to(c2){\n\n\t}\n};\nbool operator<(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost<b.current_cost;\n}\nbool operator>(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost>b.current_cost;\n}\n\n\nclass Graph{\nprivate:\n\tstd::vector<Vertex*> v;\n\tstd::vector<Edge*> e;\n\tint64_t **WF;\n\tvoid initialize_Dijkstra(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tVertex *temp=(*i);\n\t\t\ttemp->initialize_Dijkstra();\n\t\t}\n\t}\n\tstatic void dijkstra(Vertex* source,Vertex* goal=NULL){\n\t\tstd::priority_queue<dijkstra_calc,std::vector<dijkstra_calc>,std::greater<dijkstra_calc> > queue;\n\t\tqueue.push(dijkstra_calc(0,NULL,source));\n\t\twhile(true){\n\t\t\tconst dijkstra_calc temp=queue.top();\n\t\t\tqueue.pop();\n\t\t\tif(!(temp.to->dijk_data.searched)){\n\t\t\t\ttemp.to->dijk_data.searched=true;\n\t\t\t\ttemp.to->dijk_data.parent=temp.from;\n\t\t\t\ttemp.to->dijk_data.d=temp.current_cost;\n\n\t\t\t\tfor(auto i=temp.to->departure.begin();i!=temp.to->departure.end();i++){\n\t\t\t\t\tconst Edge *j=(*i);\n\t\t\t\t\tif(!j->to->dijk_data.searched){\n\t\t\t\t\t\tdijkstra_calc a(temp.current_cost+(j->cost),j->from,j->to);\n\t\t\t\t\t\tqueue.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.to==goal){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue.empty()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tstatic const int64_t INF=1000000000000000;\n\tGraph(int32_t num_v){\n\t\tv.reserve(num_v);\n\t\tfor(int32_t i1=0;i1<num_v;i1++){\n\t\t\tVertex* temp=new Vertex();\n\t\t\ttemp->id=i1;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\t/*WF=new int64_t*[num_v];\n\t\tfor(int64_t i1=0;i1<num_v;i1++){\n\t\t\tWF[i1]=new int64_t[num_v];\n\t\t}*/\n\t}\n\tvoid add_edge(int32_t from,int32_t to,int32_t cost=0){\n\t\tEdge *temp=new Edge(v[from],v[to],cost);\n\t\te.push_back(temp);\n\t\tv[from]->add_edge(temp);\n\t}\n\tvoid dijkstra(int32_t start){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start]);\n\t}\n\tvoid dijkstra(int32_t start,int32_t goal){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start],v[goal]);\n\t}\n\tint64_t** WarshallFloid(){\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tWF[i1][i2]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(auto i2=v[i1]->departure.begin();i2!=v[i1]->departure.end();i2++){\n\t\t\t\tEdge *temp=(*i2);\n\t\t\t\tif(WF[i1][temp->to->id]>temp->cost){\n\t\t\t\t\tWF[i1][temp->to->id]=temp->cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tWF[i1][i1]=0;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tfor(int64_t i3=0;i3<v.size();i3++){\n\t\t\t\t\tWF[i2][i3]=min(WF[i2][i3],WF[i2][i1]+WF[i1][i3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn WF;\n\t}\n\tVertex* getVertex(int place) const{\n\t\treturn v[place];\n\t}\n\tbool isBridge(Edge* e1,Edge* e2){\n\t\tfor(auto i1=v.begin();i1!=v.end();i1++){\n\t\t\tVertex* temp=(*i1);\n\t\t\ttemp->count_finish=false;\n\t\t}\n\t\tint32_t r=v[0]->count_union(e1,e2);\n\t\treturn v.size()!=r;\n\t}\n\tvector<Edge*> getEdge(){\n\t\treturn e;\n\t}\n\tvirtual ~Graph(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(auto i=e.begin();i!=e.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\t/*for(int64_t i1=0;i1<v.size();i1++){\n\t\t\tdelete[] WF[i1];\n\t\t}\n\t\tdelete[] WF;*/\n\t}\n};\nint main(){\n\tint64_t n;\n\tcin>>n;\n\tGraph graph(n);\n\tfor(int64_t i1=0;i1<n-1;i1++){\n\t\tint64_t temp1,temp2;\n\t\tcin>>temp1>>temp2;\n\t\tgraph.add_edge(temp1-1,temp2-1);\n\t\tgraph.add_edge(temp2-1,temp1-1);\n\t}\n\tif(graph.getVertex(0)->departure.size()==1){\n\t\tcout<<\"Alice\"<<endl;\n\t}else{\n\t\tif(graph.getVertex(0)->game()==1){\n\t\t\tcout<<\"Bob\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Alice\"<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define y1 __zzd001\nusing namespace std;\ntypedef long long LL;\nLL read(){\n    LL x=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return x;\n}\nconst int N=100005;\nint n,sg[N];\nvector <int> e[N];\nvoid solve(int x,int pre){\n    sg[x]=0;\n    for (auto y : e[x])\n        if (y!=pre){\n            solve(y,x);\n            sg[x]^=sg[y]+1;\n        }\n}\nint main(){\n    n=read();\n    for (int i=1;i<n;i++){\n        int x=read(),y=read();\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    solve(1,0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t\tif (edge[i].size() > 2)dis[i]--;\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nvector<int> e[ten(5)];\nll hs[ten(5)];\n\nll dfs(int v, int par) {\n\tmap<ll, int> dm;\n\tfor (auto to : e[v]) {\n\t\tif (to == par) continue;\n\t\tll tmp = dfs(to, v);\n\t\tdm[tmp] ^= 1;\n\t}\n\tll pv = 1;\n\tll h = 1;\n\tfor (auto kv : dm) {\n\t\tif (kv.second == 0) continue;\n\t\th *= ten(9) + 7;\n\t\tpv += kv.first * h;\n\t}\n\n\treturn hs[v] = pv;\n}\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n - 1) {\n\t\tint a, b; reader(a, b);\n\t\ta--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tll ret = dfs(0, -1);\n\tputs(ret == 1 ? \"Bob\" : \"Alice\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <bitset>\n#include <cstdio>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define PII pair<LL,LL>\n#define FOR(i,a,b) for (LL i=(a);i<=(b);++i)\n#define ROF(i,b,a) for (LL i=(b);i>=(a);--i)\ntypedef long long LL;\ninline LL read(){\n\tLL x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\twhile (ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn x*f;\n}\n\nconst LL MAXN=500005;\nconst double eps=1e-8,INF=1e20,PI=3.141592653589793238462;\nint n,m,f[MAXN];\nstruct list{\n\tint l,lt[MAXN],nt[MAXN],x[MAXN];\n\tvoid clear(){ l=0; memset(lt,0,sizeof(lt)); }\n\tvoid addedge(int a,int b){ l++; nt[l]=lt[a]; lt[a]=l; x[l]=b; }\n}E;\nvoid dfs(int x,int fa){\n\tf[x]=0;\n\tfor (int i=E.lt[x];i;i=E.nt[i]) {\n\t\tint j=E.x[i];\n\t\tif (j!=fa) {\n\t\t\tdfs(j,x);\n\t\t\tf[x]^=(f[j]+1);\n\t\t}\n\t}\n}\nint main(){\n\tn=read();\n\tFOR(i,1,n-1) {\n\t\tint x,y;\n\t\tx=read(); y=read();\n\t\tE.addedge(x,y);\n\t\tE.addedge(y,x);\n\t}\n\tdfs(1,0);\n\tif (f[1]) printf(\"Alice\\n\"); else printf(\"Bob\\n\");\n\treturn 0;\n}\n\n/*\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a),i##_end=(b);i<=i##_end;i++)\n#define per(i,b,a) for(int i=(b),i##_st=(a);i>=i##_st;i--)\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<#x\" = \"<<x<<endl\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n#define Es(x,i) for(Edge *i=G[x];i;i=i->nex)\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int inf=~0u>>1,MOD=1e9+7;/*\nchar *TT,*mo,but[(1<<15)+2];\n#define getchar() ((TT==mo&&(mo=(TT=but)+fread(but,1,1<<15,stdin),TT==mo))?-1:*TT++)//*/\ninline int rd() {\n\tint x=0,c=0,f=1;\n\tfor(; c<'0'||c>'9'; c=getchar())f=c!='-';\n\tfor(; c>='0'&&c<='9'; c=getchar())x=x*10+c-'0';\n\treturn f?x:-x;\n}\nconst int N=1e5+11;\nstruct Edge{\n\tint v;Edge *nex;\n} pl[N<<1],*cur=pl,*G[N];\nvoid ins(int u,int v){\n\tcur->v=v,cur->nex=G[u],G[u]=cur++;\n}\nint n;\nint dfs(int x,int fa=0){\n\tint k=0;\n\tEs(x,i)if(i->v!=fa){\n\t\tk^=dfs(i->v,x)+1;\n\t}\n\treturn k;\n}\nint main(){\n\tn=rd();\n\trep(i,2,n){\n\t\tint u=rd(),v=rd();\n\t\tins(u,v),ins(v,u);\n\t}\n\tputs(dfs(1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0X3F3F3F3F\n#define N 200005\n#define M 200005\n#define LL long long\n#define FF(i, a, b) for(int i = a; i <= b; ++i)\n#define RR(i, a, b) for(int i = a; i >= b; --i)\n#define FJ(i, a, b) for(int i = a; i < b; ++i)\n#define SC(x) scanf(\"%d\", &x)\n#define SCC(x, y) scanf(\"%d%d\", &x, &y)\n#define SCCC(x, y, z) scanf(\"%d%d%d\", &x, &y, &z)\n#define SS(x) scanf(\"%s\", x)\n#define PR(x) printf(\"%d\\n\", x)\n#define CL(a, x) memset(a, x, sizeof(a))\n#define _P fd[rt]\n#define _L fd[rt << 1]\n#define _R fd[rt << 1 | 1]\n#define MID int mid = ((l + r) >> 1)\n#define lson rt<<1 ,l, mid\n#define rson rt<<1 | 1, mi d + 1, r\n#define PII pair<int, int>\n#define PLL pair<long long, long long>\n#define MP make_pair\n#define IN freopen(\"in.txt\", \"r\", stdin)\n#define OUT freopen(\"out.txt\", \"w\", stdout)\nusing namespace std;\nconst int MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-8;\ninline void II(int &n){char ch = getchar(); n = 0; bool t = 0;\nfor(; ch < '0'; ch = getchar()) if(ch == '-') t = 1;\nfor(; ch >= '0'; n = n * 10 + ch - '0', ch = getchar()); if(t) n =- n;}\ninline void OO(int a){if(a < 0) {putchar('-'); a = -a;}\nif(a >= 10) OO(a / 10); putchar(a % 10 + '0');}\ninline int sgn(double x){return (x > EPS) - (x < -EPS);}\nstruct EE{int v, nx;}E[M * 2 + N * 2]; int hd[N], EN;\nvoid init_edge(int num){EN = 0; memset(hd, -1, (num + 2) << 2);}\nvoid add_edge(int u, int v){\n    E[EN].v = v; E[EN].nx = hd[u]; hd[u] = EN++;\n    E[EN].v = u; E[EN].nx = hd[v]; hd[v] = EN++;\n}\nvector<int> G[N];\nint go(int u){\n    int s = 0;\n    for(int i = 0; i < G[u].size(); ++i){\n        int v = G[u][i];\n        s ^= (go(v) + 1);\n    }\n    return s;\n}\nint dis[N];\nint p[N][2], n, u, v;\nint main(){\n    //IN;\n    SC(n);\n    init_edge(n + 3);\n    FF(i, 1, n - 1){\n        SCC(u, v);\n        add_edge(u, v);\n     //   add_edge(v, u);\n        p[i][0] = u;\n        p[i][1] = v;\n    }\n    queue<int>q;\n    q.push(1);\n    dis[1] = 1;\n    while(!q.empty()){\n        int u = q.front();\n        q.pop();\n        for(int k = hd[u]; ~k; k = E[k].nx){\n            int v = E[k].v;\n            if(dis[v] == 0){\n                dis[v] = dis[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    FF(i, 1, n - 1){\n        if(dis[p[i][0]] > dis[p[i][1]]) G[p[i][1]].push_back(p[i][0]);\n        else  G[p[i][0]].push_back(p[i][1]);\n    }\n    int s = go(1);\n    puts(s ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplece_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define Edge pair< i_i, int>\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n#define int2(x, y) int x, y; scanf(\"%lld %lld\", &x, &y);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvvi nt;\nvvi tree;\nint n;\n\nint dfs(int p, int par, int dep)\n{\n    int ret = dep;\n    rep(i, tree[p].size()) {\n        if (tree[p][i] != par) {\n            int tmp = dfs(tree[p][i], p, 1)+1;\n            ret = max(dep, tmp);\n            nt[p].pb(tmp);\n        }\n    }\n    int sum = 0;\n    rep(i, nt[p].size()) {\n        sum ^= nt[p][i];\n    }\n    return sum;\n}\n\nsigned main()\n{\n    cin >> n;\n    nt = vvi(n+1);\n    tree = vvi(n+1);\n    rep(i, n-1) {\n        int2(a, b);\n        tree[a].pb(b);\n        tree[b].pb(a);\n    }\n\n    if (dfs(1, 0, 0)) {\n        cout << \"Alice\" << endl;\n    } else {\n        cout << \"Bob\" << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100010\nusing namespace std;\nint u,v,n,m,d[maxn];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n-1;i++){\n\t\tcin>>u>>v;\n\t\tif(u>v) swap(u,v);\n\t\td[u]++;\n\t}\n\tif(d[1]==1){\n\t\tcout<<\"Alice\";\n\t\treturn 0;\n\t}\n\tint ans=d[1];\n\tfor(int i=2;i<=n;i++){\n\t\tans^=d[i];\n\t}\n\tif(ans==1){\n\t\tcout<<\"Alice\";\n\t}\n\telse \n\t\tcout<<\"Bob\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\nvector<int> G[100010];\nint childs[100010]={0}, par[100010];\n\nint grundy(int i=0) {\n    int ans = 0;\n    for (auto g:G[i]) {\n        if (childs[g]) continue;\n        childs[i]++;\n        par[g] = i;\n        if (i > 0) ans += grundy(g);\n        else ans ^= grundy(g);\n    }\n    if (i > 0) {\n        int cnt = 0;\n        for (auto g:G[i]) {\n            if (par[i] == g) continue;\n            if (childs[g]) cnt++;\n        }\n        if (cnt > 1) ans = 0;\n        ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i=1, x, y; i<n; i++) {\n        cin >> x >> y;\n        x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    cout << (grundy() ? \"Alice\" : \"Bob\") << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> v[100005];\nint a[100005];\n\nint dfs(int n  , int p)\n{\n    a[n] = 0;\n\n    for(auto it : v[n])\n    {\n        if(it!=p)\n        {\n            a[n] = a[n]^dfs(it , n);\n        }\n    }\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    for(int i = 1 ; i<n ; i++)\n    {\n        int x , y;\n        cin >> x >> y;\n\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    dfs(1 , 0);\n\n    if(a[1])\n    {\n        cout << \"Alice\";\n        return 0;\n    }\n    cout << \"Bob\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 101000;\n\nint n, sg[N];\n\nstruct Edge\n{\n    int nxt, to;\n} eg[N << 1];\nint head[N], en;\n\nvoid setEdge(int u, int v)\n{\n    eg[++en] = (Edge){head[u], v};\n    head[u] = en;\n}\n\nvoid dfs(int u, int fa)\n{\n    for (int e = head[u]; e; e = eg[e].nxt)\n    {\n        int v = eg[e].to;\n        if (v == fa) continue;\n        dfs(v, u);\n        sg[u] ^= (sg[v] + 1);\n    }\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        setEdge(u, v);\n        setEdge(v, u);\n    }\n    dfs(1, 0);\n    puts(sg[1] ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint N;\nset<int> cand;\nint x[100005], y[100005];\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n\n  int root = 0;\n  int edge = 0;\n\n  rep(i, N - 1) {\n      cin >> x[i] >> y[i];\n      x[i]--; y[i]--;\n      if (x[i] > y[i]) swap(x[i], y[i]);\n      if (x[i] == 0) {\n          root += 1;\n          cand.insert(y[i]);\n      } \n  }\n\n  rep(i, N) {\n    if (HAS(cand, x[i])) {\n        edge += 1;\n        root -= 1;\n        cand.erase(x[i]);\n    }\n    if (HAS(cand, y[i])) {\n        edge += 1;\n        root -= 1;\n        cand.erase(y[i]);\n    }\n  }\n\n  int hand = 0;\n  while (true) {\n    if (edge == 0) {\n        root -= 1;\n    }\n    else {\n        if (root%2 == 1) {\n            edge -= 1;\n        } else {\n            root -= 1;\n        }\n    }\n    if (root == 0) {\n      cout << (hand == 1 ? \"Bob\":\"Alice\") << endl;\n      break;\n    }\n\n    hand = (hand + 1)%2;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> adia[100010];\n\nint calc(int nod, int tata)\n{\n    vector <int> fii;\n    for (auto i : adia[nod]) {\n        if (i == tata)\n            continue;\n        fii.push_back(calc(i, nod));\n    }\n\n    if (fii.size() == 0)\n        return 0;\n    sort(fii.begin(), fii.end());\n\n    int mex = 0;\n    for (auto i : fii) {\n        if (i == mex)\n            mex++;\n        else if (i > mex)\n            return mex;\n    }\n    return mex;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    cout << (!calc(1, 0) ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define R register\n#define maxn 100010\nstruct Edge\n{\n\tEdge *next;\n\tint to;\n} *last[maxn], e[maxn << 1], *ecnt = e;\ninline void link(R int a, R int b)\n{\n\t*++ecnt = (Edge) {last[a], b}; last[a] = ecnt;\n\t*++ecnt = (Edge) {last[b], a}; last[b] = ecnt;\n}\nint dfs(R int x, R int fa)\n{\n\tR int ans = 0;\n\tfor (R Edge *iter = last[x]; iter; iter = iter -> next)\n\t\tif (iter -> to != fa)\n\t\t\tans ^= (dfs(iter -> to, x) + 1);\n\treturn ans;\n}\nint main()\n{\n\tR int n; scanf(\"%d\", &n);\n\tfor (R int i = 1; i < n; ++i)\n\t{\n\t\tR int a, b; scanf(\"%d%d\", &a, &b); link(a, b);\n\t}\n\tputs(dfs(1, 0) ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nvector<int> g[100100];\n\nint dfs(int s,int p){\n    int k=0;\n    for(int r:g[s]){\n        if(r!=p){\n            k^=(1+dfs(r,s));\n        }\n    }\n    return k;\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n    for(int i=0;i<n-1;i++){\n        int x,y; cin >> x >> y;\n        x--; y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if(dfs(0,-1)){\n        cout << \"Alice\" << endl;\n    }\n    else{\n        cout << \"Bob\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> nt[maxn];\nint n, sg[maxn];\n\nvoid dfs(int x, int fa)\n{\n\tfor (auto v:nt[x])\n\t{\n\t\tif (v!=fa) dfs(v,x);\n\t\tsg[x]^=(sg[v]+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i = 0; i < n-1; i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tnt[x].push_back(y);\n\t\tnt[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tif (sg[1]) puts(\"Alice\");else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint DP[100005];\nvector <int> G[100005], V;\nint N;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n}\n\nvoid DFS(int node, int father)\n{\n\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father)\n            continue;\n        DFS(neighb, node);\n\n    }\n    V.clear();\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father)\n            continue;\n        V.push_back(DP[neighb]);\n    }\n    V.push_back(0);\n    sort(V.begin(), V.end());\n    int val = -1;\n    for(int i = 0; i < V.size() - 1; i++)\n    {\n        if(V[i + 1] > V[i] + 1)\n        {\n            val = V[i] + 1;\n            break;\n        }\n    }\n    if(val == -1)\n        val = V.back() + 1;\n    DP[node] = val;\n}\nint main()\n{\n    Read();\n    DFS(1, 0);\n    int S = 0;\n    for(int i = 0; i < G[1].size(); i++)\n    {\n        S = (S ^ DP[G[1][i]]);\n    }\n    if(S == 0)\n    {\n        cout << \"Bob\\n\";\n    }\n    else\n        cout << \"Alice\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nclass DGameOnTree {\npublic:\n\n    vector<int> graph[100005];\n    vector<bool> used;\n\n    int dfs(int p) {\n      used[p] = true;\n      int ret = 0;\n      for(auto& e: graph[p]) {\n        if (used[e]) continue;\n        ret ^= (dfs(e)+1);\n      }\n      return ret;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      used.resize(n);\n      rep(i, n-1) {\n        int x, y; cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n      }\n      if (dfs(0) == 0) {\n        cout << \"Bob\" << endl;\n      } else {\n        cout << \"Alice\" << endl;\n      }\n    }\n};\n\nsigned main() {\n  DGameOnTree solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=100010;\nstruct Edge{int to,next;} e[N<<1];\nint h[N],sum=0,n;\n\nvoid add_edge(int u,int v)\n{\n    e[++sum].to=v;\n    e[sum].next=h[u];\n    h[u]=sum;\n}\n\nint dfs(int u,int fa)\n{\n    int res=0;\n    for(int tmp=h[u];tmp;tmp=e[tmp].next)\n        if(e[tmp].to!=fa) res^=dfs(e[tmp].to,u)+1;\n    return res;\n}\n\nint main()\n{\n    int u,v;n=read();\n    for(int i=1;i<n;i++)\n    {\n        u=read();v=read();\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    puts(dfs(1,0)?\"Alice\":\"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=100005,M=N<<1;\n\nint v[M],nxt[M];\nint head[N];\nbool ans[N];\nint n;\n\nil void addedge(int p,int x,int y){\n\tv[p]=y,nxt[p]=head[x],head[x]=p;\n}\n\nil void dfs(int u,int p){\n\tans[u]=0;\n\tint tot=0;\n\tfor(int e=head[u];e;e=nxt[e]){\n\t\tif(v[e]==p) continue;\n\t\t++tot; \n\t\tdfs(v[e],u);\n\t\tans[u]^=ans[v[e]]^1;\n\t}\n\tif(tot==1) ans[u]=1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(lch(i),x,y);\n\t\taddedge(rch(i),y,x);\n\t} \n\tdfs(1,0);\n\tputs(ans[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int nmax=100005;\nvector<int> v[nmax];\nint viz[nmax],sg[nmax];\nint n,i,a,b;\nvoid dfs(int x)\n{\n    viz[x]=1;\n    for(int i=0;i<v[x].size();i++)\n        if(!viz[v[x][i]])\n    {\n        dfs(v[x][i]);\n        sg[x]^=(sg[v[x][i]]+1);\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin>>n;\n    for(i=1;i<=n-1;i++)\n    {\n        cin>>a>>b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(1);\n    if(sg[1]) cout<<\"Alice\";\n    else cout<<\"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint D[100001], G[100001];\nvector<int> E[100001];\nint dfs(int A) {\n\tif (!D[A]) {\n\t\tint g = 0;\n\t\tD[A] = 1;\n\t\tfor (auto i : E[A]) {\n\t\t\tg ^= dfs(i);\n\t\t}\n\t\tG[A] = g + 1;\n\t}\n\treturn G[A];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\trep(i, N - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\n\tdfs(1);\n\n\trep1(i, N) co(G[i]);\n\n\tif (G[1] - 1) co(\"Alice\");\n\telse co(\"Bob\");\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\n#define ll long long\nauto start_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n\n/*@formatter:off*/\n//[-n, n)にアクセスできる\n//また、外部関数resizeに渡せる\n\n//sizeは[-n, n)でnを返す\ntemplate<class T> class mvec {    vector<T> v;    int n;public:    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, T val) : n(n), v(n * 2, val) {}    auto &operator[](int i) { return v[i + n]; }    auto size() { return n; }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\n//[]でboolは参照を返さないため特殊化が必要\ntemplate<> struct mvec<bool> {    vector<bool> v;    int n;    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, bool val) : n(n), v(n * 2, val) {}    auto operator[](int i) { return v[i + n]; }    auto size() { return v.size(); }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\ntemplate<class T>ostream &operator<<(ostream &os, mvec<T>& a) {    int spa = 3;    for(auto&&v : a){        spa = max(spa,(int)(to_string(v).size())+1);    }    int n = (int)a.size();    os<<endl;    for (int i = -n; i < n; i++){        int need = spa - ((int)to_string(i).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(a[i]).size()));        }        while(need--){            os<<\" \";        }        os<<i;    }    os<<endl;    int i=-n;    for(auto&&v : a){        int need = spa - ((int)to_string(v).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(i).size()));        }        while(need--){            os<<\" \";        }        os<<v;        i++;    }    return os;}\n#define mv mvec\n#define MV mvec\nusing mvi = mvec<ll>;\nusing mvb = mvec<bool>;\nusing mvs = mvec<string>;\nusing mvd = mvec<double>;\nusing mvc = mvec<char>;\n\n#define o_mvvt(o1, o2, o3, o4, name, ...) name\n#define mvvt0(t) mvec<mvec<t>>\n#define mvvt1(t,a) mvec<mvec<t>>a\n#define mvvt2(t,a, b) mvec<mvec<t>>a(b)\n#define mvvt3(t,a, b, c) mvec<mvec<t>> a(b,mvec<t>(c))\n#define mvvt4(t,a, b, c, d) mvec<mvec<t>> a(b,mvec<t>(c,d))\n\n#define mvvi(...) o_mvvt(__VA_ARGS__,mvvt4,mvvt3,mvvt2 ,mvvt1,mvvt0)(ll,__VA_ARGS__)\ntemplate<typename T> mvec<T> make_mv(size_t a) { return mvec<T>(a); }\ntemplate<typename T, typename... Ts> auto make_mv(size_t a, Ts... ts) {return mvec<decltype(make_mv<T>(ts...))>(a, make_mv<T>(ts...));}\n#define mvni(name, ...) auto name = make_mv<ll>(__VA_ARGS__)\n\n\n#ifdef _DEBUG\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {cerr << a.size() << \" \";return deb_v(a.at(0), v + 1);}\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }if ((int) a.size() > 15) { cerr << \"...\"; }cerr << endl;}\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }return this->at(n);}\n};\n#define vector debtor\n#endif\n\n#ifdef _DEBUG\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T,class U> struct my_unordered_map{    unordered_map<T,U> m;    my_unordered_map(){};    auto begin(){        return m.begin();    }    auto end(){return m.end();}    auto cbegin(){return m.cbegin();}    auto cend(){return m.cend();}    template<class V>auto erase(V v){return m.erase(v);}    void clear(){m.clear();}    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V>auto find(V v){return m.find(v);}    template<class V>auto & operator [](V n) { return m[n] ;}};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapip unordered_map<ll,P>\n\n#else\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n\n#endif\nstruct xorshift {    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }    size_t operator()(std::pair<ll, ll> x) const {        ll v=((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }};\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\nF mf(ll a, ll b, ll c, ll d) {return F(a, b, c, d);}\n\n\n\n//@マクロ省略系 型,構造\n#define double long double\n#define pow powl\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing mvp = mvec<P>;\nusing mvt = mvec<T>;\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](auto& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t,a) vector<vector<t>>a\n#define vvt2(t,a, b) vector<vector<t>>a(b)\n#define vvt3(t,a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t,a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type,...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type,name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_,v1_,v2_,v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n#define o_rep(o1, o2, o3, o4, name, ...) name\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss1(i, I) for (int i = 0; i < I; i++)\n#define repss2(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss3(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss4(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss5(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n#define o_repss(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n//i,j,k...をnまで見る\n#define reps1(i, n) repss1(i, n)\n#define reps2(i, j, n) repss2(i, j, n, n)\n#define reps3(i, j, k, n) repss3(i, j, k, n, n, n)\n#define reps4(i, j, k, l, n) repss4(i, j, k, l, n, n, n, n)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n\ntemplate<class T>void nex_repv2(int&i,int&j,int&I, int&J,vector<vector<T>>&s){    while(1){        j++;        if(j >= J){            j=0;            i++;            if(i < I){                J = (int)s[i].size();            }        }        if(i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n#define repv_1(i,a) repss1(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_2(i, j, a) for (int I = (int)a.size(), J = (int)a[0].size(), i = 0, j = 0; i < I; nex_repv2(i,j,I,J,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_3(i, j, k, a) for (int I = (int)a.size(), J = (int)a[0].size(), K =(int)a[0][0].size(), i = 0, j = 0, k=0; i < I; nex_repv3(i,j,k,I,J,K,a))\n#define repv_4(i, j, k, l, a) repss4(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_5(i, j, k, l, m, a) repss5(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n#define o_repv(o1, o2, o3, o4, o5, o6, name, ...) name\n\ntemplate<typename T>struct has_rbegin_rend {private:template<typename U>static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value;};template<typename T>constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;template<typename Iterator>class Range {public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept {return m_begin;}Iterator end() const noexcept {return m_end;}private:const Iterator m_begin;const Iterator m_end;};template<typename Iterator>static inline Range<Iterator>makeRange(Iterator &&begin, Iterator &&end) noexcept {return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)};}template<typename T>static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept {return makeRange(std::rbegin(iniList), std::rend(iniList));}template<typename T,typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr>static inline decltype(auto)makeReversedRange(T &&c) noexcept {return makeRange(std::rbegin(c), std::rend(c));}/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T,typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr>static inline void makeReversedRange(T &&) noexcept {static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\");}\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define o_form(a, b, c, d, e, name, ...) name\n\ntemplate<class U> vector<U>to1d(vector<U>& a){return a;}\ntemplate<class U> vector<U>to1d(V<V<U>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)res.push_back(a2);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<U>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) res.push_back(a3);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<V<U>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)res.push_back(a4);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<V<V<U>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)res.push_back(a5);return res;}\ntemplate<class U> vector<U>to1d(V<V<V<V<V<V<U>>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)for(auto&& a6 : a5)res.push_back(a6);return res;}\n\n#define fora_init_2(a, A) ;\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define o_fora_init(a, b, c, d, e, f, g, h, name, ...) name\n#define fora_init(...) o_fora_init(__VA_ARGS__, fora_init_8, a, fora_init_6, a, fora_init_4, a, fora_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define o_forr_init(a, b, c, d, e, f, g, h, name, ...) name\n#define forr_init(...) o_forr_init(__VA_ARGS__, forr_init_8, a, forr_init_6, a, forr_init_4, a, forr_init_2)(__VA_ARGS__)\n\n\n#define forp_init(k, v, ...) auto &&k = (*forp_it).fi;auto &&v = (*forp_it).se;\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,reps1,)(__VA_ARGS__)\n#define repss(...) o_repss(__VA_ARGS__, repss5, a, repss4, a, repss3, a, repss2, a, repss1) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) o_repv(__VA_ARGS__,repv_5,repv_4,repv_3,repv_2,repv_1,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define o_fora(a, b, c, d, e, f, g, h, name, ...) name\n#define fora(...) o_fora(__VA_ARGS__, fora_8, a, fora_6, a, fora_4, a, fora_2)(__VA_ARGS__)\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define o_forr(a, b, c, d, e, f, g, h, name, ...) name\n#define forr(...) o_forr(__VA_ARGS__, forr_8, a, forr_6, a, forr_4, a, forr_2)(__VA_ARGS__)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#define forv(a, b) for(auto a : to1d(b))\n\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n//                  0の左と nの右\n#define forlr(v, d) for (auto prev = -1_, next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?-1_:d[index_+1]))\n\n\n#define form(...) o_form(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forp(k, v, st) for (auto &&forp_it = st.begin(); forp_it != st.end(); ++forp_it)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:on*/\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {\n    os << p.fi << \" \" << p.se;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {\n    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {\n    for (ll i = 0; i < vec.size(); ++i) {\n        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {\n    for (auto &&v:m) os << v;\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {\n    fora(v, a)os << v << \" \";\n    return os;\n}\nostream &operator<<(ostream &os, vector<vector<char>> &vec) {\n    rep(h, sz(vec)) {\n        rep(w, sz(vec[0])) { os << vec[h][w]; }\n        os << endl;\n    }\n    return os;\n}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\n/*@formatter:off*/\ntemplate<typename W, typename H> void resize(W &vec, const H head) { vec.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\n//template<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }\n//template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n//削除された要素の数を返す\ntemplate<typename T, typename F> int erase_if2(vector<T> &v, F f) {vector<T> nv;int cou = 0;rep(i, sz(v)) {if (f(v[i])) {cou++;} else {nv.push_back(v[i]);}}v = nv;return cou;}\ntemplate<typename T, typename F> int erase_if2(vector<vector<T>> &v, F f) {int cou = 0;rep(i, sz(v)) {cou += erase_if2(v[i], f);}return cou;}\n#define all_of(a,right) all_of2(a,lam(right))\n#define all_of_f(a,f) all_of2(a,f)\n#define any_of(a,right) any_of2(a,lam(right))\n#define any_of_f(a,f) any_of2(a,f)\n#define none_of(a,right) none_of2(a,lam(right))\n#define none_of_f(a,f) none_of2(a,f)\n#define find_if(a,right) find_if2(a,lam(right))\n#define find_if_f(a,f) find_if2(a,f)\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define rfind_if_f(a,f) rfind_if2(a,f)\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define contains_if_f(a,f) contains_if2(a,f)\n#define count_if(a, right) count_if2(a,lam(right))\n#define count_if_f(a, f) count_if2(a,f)\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_f(a, f) do{fora(v,a){f(v);}}while(0)\n#define erase_if(a,right) erase_if2(a,lam(right))\n#define erase_if_f(a,f) erase_if2(a,f)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,ll len,const T v) {rep(i, len)xx[i]=v;}\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<class T,class U>void fill(vector<T> &a,vi& ind,U val) {fora(v,ind)a[v]=val;}\ntemplate<class W,class T>void fill(mvec<W> &xx,const T v){\n    fora(x,xx)fill(x,v);\n}\n\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, o5, o6, name, ...) name\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) o_din(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dins(o1, o2, o3, o4, o5, o6, name, ...) name\n#define dins1(a) str a;cin>>a\n#define dins2(a, b) str a,b;cin>>a>> b\n#define dins3(a, b, c) str a,b,c;cin>>a>>b>>c\n#define dins4(a, b, c, d) str a,b,c,d;cin>>a>>b>>c>>d\n#define dins5(a, b, c, d, e) str a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define dins6(a, b, c, d, e, f) str a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define dins(...) o_dins(__VA_ARGS__,dins6,dins5,dins4,dins3,dins2 ,dins1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) {    cerr << head  << endl;}\nvoid err() {    cerr << \"\"  << endl;}\n/*@formatter:on*/\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {\n    stringstream ss;\n    if (W == inf)W = min(sz(a), 12ll);\n    if (sz(a) == 0)return ss.str();\n    rep(i, W) {\n        ss << a[i];\n        if (typeid(a[i]) == typeid(P)) {\n            ss << endl;\n        } else {\n            ss << \" \";\n        }\n    }\n    return ss.str();\n}\n/*@formatter:off*/\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}return ss.str();}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }       return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) {        b[i] = a[i];    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) {        rep(j, M) {            b[i][j] = a[i][j];        }    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) {        rep(j, M) {            rep(k, O) {                b[i][j][k] = a[i][j][k];            }        }    }    return out_m2(b);}\nstring out_m2(int a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<T> > &a, ll H = inf, ll W = inf, int key = inf) {\n    H = min({H, sz(a), 6ll});\n    W = min({W, sz(a[0]), 6ll});\n    stringstream ss;\n    ss << endl;\n//    if (key == inf)ss << \" *|\"; else ss << \" \" << key << \"|\";\n    if (key == inf)ss << \" *|\";\n    else {\n        ss << std::right << std::setw(2) << key;\n        ss << \"|\";\n    }\n    rep(w, -W, W)ss << std::right << std::setw(4) << w;\n    ss << \"\" << endl;\n    rep(w, W * 8 + 3)ss << \"_\";\n    ss << \"\" << endl;\n    rep(h, -H, H) {\n        ss << std::right << std::setw(2) << h << \"|\";\n        int NW = min(sz(a[h]), 6ll);\n        rep(w, -NW, NW) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }\n        ss << \"\" << endl;\n    }\n    return ss.str();\n}/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<mvec<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {\n    stringstream ss;\n    if (H == inf)H = 6;\n    H = min(H, sz(a));\n    rep(i, -H, H) {\n        ss << endl;\n        ss << out_m2(a[i], W, U, i);\n    }\n    return ss.str();\n}\n\n/*@formatter:off*/\ntemplate<class T> string out_m2(T &a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {\n    stringstream ss;\n    if (W == inf)W = min(sz(a), 12ll);\n    if (sz(a) == 0)return ss.str();\n    rep(i, W) { ss << a[i] << \" \"; }\n    ss << \"\" << endl;\n    return ss.str();\n}\n/*@formatter:off*/\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}ss << endl;return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> string out_m(T &a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W=inf) {cout << out_m(a,W) << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf,int key=-1) {    cout << out_m(a,H,W,key) << endl;}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf,ll U = linf) {cout << out_m(a,H,W,U)<< endl;}\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {\n    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }\n    cout << \"\" << endl;\n}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n#endif\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>>&a){    rep(i,sz(a)){        rep(j,sz(a[i])){            cout<<a[i][j];        }        cout<<endl;    }}\n//int型をbit表記で出力\nvoid outb(int a){cout << bitset<20>(a) << endl;}\ntemplate<class T> void na(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\n#define dnad(a, n) vi a(n); rep(dnai,n) cin >> a[dnai],a[dnai]--;\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i];\n#define dna4d(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i],--a[dna4i] ,-- b[dna4i],-- c[dna4i],--d[dna4i];\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\n//graphでredefineしているため、書き換えたら向こうも書き換える\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing bll =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void){static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;unsigned long t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T>vector<pair<T,int>> run_length(vector<T> &a) {vector<pair<T,int>> ret;ret.eb(a[0], 1);rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {\n    bool han = true;\n    if (ok < ng)\n        while (ng - ok > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        while (ok - ng > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\ntemplate<class F> dou mgrd(dou ok, dou ng, F f) {\n    bool han = true;\n    if (ok < ng)\n        rep(i,100) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            if(i<30)deb(mid,han);\n        }\n    else\n        rep(i,100) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            if(i<30)deb(mid,han);\n        }\n    return ok;\n}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; }    else if (sz(a) > sz(b)) { return a; }    else if (a < b)return b;    else return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) > sz(b)) { return b; }    else if (sz(a) < sz(b)) { return a; }    else if (a > b)return b;    else return a;}\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n//stringも書く\nint find(string& s, const string key){    int klen = sz(key);    rep(i,sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, int l, const string key){    int klen = sz(key);    rep(i, l, sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, const char key){    rep(i,sz(s)){        if(s[i]==key)return i;    }    return -1;}\nint find(string& s, int l, const char key){    rep(i, l, sz(s)){        if(s[i]==key)return i;    }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) {        if (ma < v)ma = v;    }    vi res(ma + 1);    fora(v, a) {        res[v]++;    }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nvi count(str &a) {    vi cou(26);    char c = 'a';    if ('A' <= a[0] && a[0] <= 'Z')c = 'A';    rep(i, sz(a))++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nll get(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//0は0桁\nll keta(ll v) {    if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}}    else {        if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }}        else {            if (v < p10[15]) {                if (v < p10[14]) return 14;                else return 15;            } else {                if (v < p10[17]) {                    if (v < p10[16]) return 16;                    else return 17;                } else {                    if (v < p10[18])return 18;                    else return 19;                }            }        }    }}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T& a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T& a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class T>  T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T>  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T>  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T>  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s, ll t) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\ntemplate<class T> T sum(vector<T> &v, ll t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<T> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int t = inf) { return sum(v, 0, t); }\n\ntemplate<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvi v_i(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) {        ret[a[i]] = i;    }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int>&q) { q = priority_queue<int>();}\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\n//template<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\n//template<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin(){return rui.begin();}\n    auto end(){return rui.end();}\n};\ntemplate<class T> struct ruimax {template<typename Monoid>struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN(T), -1);        Monoid f(Monoid a, Monoid b) {            return max(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) {                index = i;            }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {        return operator()(0, r);    }\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\ntemplate<class T> struct ruimin {template<typename Monoid>    struct SegmentTree {  /*pairで処理*/         int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MAX(T), -1);        Monoid f(Monoid a, Monoid b) {            return min(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) {                index = i;            }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {return operator()(0, r);}\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\n\n\ntemplate<class T>ostream &operator<<(ostream &os, ruiC<T> a) {fora(v,a.rui)os<<v<<\" \";return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic() {return ruiC<T>();}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) {        rep(i, sz(a)) {            res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1);        }    }    return res;}\nvector<ruiC<int>> ruibc(vi &a) {    vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) {            res[k][i] = (a[i] >> k) & 1;        }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\n\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {vector<T> ret(sz(v));rep(h,sz(ret)){ret[h] = v[h][w];}rep(i, sz(ret) - 1){ret[i + 1] += ret[i];}return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {vector<T> ret(sz(v) + 1);rep(h, sz(v)) { ret[h + 1] = v[h][w]; }rep(i, sz(v)) { ret[i + 1] += ret[i]; }return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {vector<T> ret = ruih(a, w);return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {    const vector<T> rui;    ruixC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T>  &a) {vi ret = ruix(a);return ruixC<ll>(ret);}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {rui.resize(n + 1);rer(i, n - 1) {rui[i] = rui[i + 1] + a[i];}}\n    /*[r l)*/\n    T operator()(int r, int l) {r++;l++;assert(l <= r && l >= 0 && r <= n);return rui[l] - rui[r];}\n    T operator()(int l) {return operator()(n - 1, l);}\n    T operator[](int i) {return operator()(i);}\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {fora(v, a.rui)os << v << \" \";return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {rv.resize(n + 1);rv[0] = 1;rep(i, n) { rv[i + 1] = a[i] * rv[i]; }}\n    ruimulC() : n(0) {rv.resize(n + 1);rv[0] = 1;}\n    void operator+=(T v) {rv.push_back(rv.back()*v);n++;}\n    T operator()(int l, int r) {assert(l <= r && 0 <= l && r <= n);return rv[r] / rv[l];}\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {vector<T> a; return ruimulC<T>(a); }\n/*@formatter:off*/\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(pair<T,U> &a, U v = 1) { a.first += v,a.second+=v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T,class U, class W> void dec(vector<T> &a,vector<U> &b, W v = 1) { for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v); }\ntemplate<class T,class U,class W> void dec(vector<T> &a,vector<U> &b,vector<W>&c ) { for (auto &u :a)dec(u, 1);for (auto &u :b)dec(u, 1);for (auto &u :c)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\n#define inside ins\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\n/*@formatter:on*/\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {\n    auto lim = milliseconds(time - 20);\n    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {\n        auto s = system_clock::now();\n        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;\n        ll nr = l + haba;\n        rep(i, k) {\n            ll ni = goldd_l(nl, nr, calc);\n            if (chmi(minv, calc(ni))) mini = ni;\n            nl = nr;\n            nr = nl + haba;\n        }\n        auto end = system_clock::now();\n        auto part = duration_cast<milliseconds>(end - s);\n        auto elapsed = duration_cast<milliseconds>(end - start_time);\n        if (elapsed + part * 2 >= lim) { break; }\n    }\n    return mini;\n}\n/*@formatter:off*/\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\nconstexpr bool bget(ll m, ll keta) {\n    #ifdef _DEBUG\n        assert(keta<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (m >> keta) & 1; }\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n    #ifdef _DEBUG\n        assert(n<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll biti(vi&a){    int m=0;    for(auto&& v:a) m|=bit(v);    return m;}\n//{1, 1, 0} -> 011\nll bitb(vi&a){    int m=0;    rep(i,sz(a)) if(a[i])m|=bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\nll lbiti(ll n) { return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n){return log2(hbit(n));}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n//masの立ってるindexを見る\n#define forbit(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {auto it = lower_bound(a.begin(), a.end(), v);if (it == a.end())return banpei; else return *it;}template<class T, class U, class W> T lowerBound(ruiC<T> &a, U v, W banpei) {return lowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T upperBound(vector<T>& a, U v, W banpei){    auto it = upper_bound(a.begin(),a.end(),v);    if(it==a.end())return banpei;    else return *it;}template<class T, class U, class W> T upperBound(ruiC<T> &a, U v, W banpei) {return upperBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rlowerBound(ruiC<T> &a, U v, W banpei) {return rlowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rupperBound(ruiC<T> &a, U v, W banpei) {return rupperBound(a.rui, v, banpei);}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class T> void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(ll t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\ntemplate<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs += to_string(rv);}template<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    lhs += to_string(rv);}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {auto bek = s;s = \"\";for (; num; num >>= 1) {if (num & 1) {s += bek;}bek += bek;}}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector <T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector <T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(const vector <T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, const vector <T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector <T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T,U> &b) {fora(bv,b){        a[bv.first] += bv.second;    }    return a;}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\nvi inds_(vi &a) {    int n = sz(a);    vb was(n);    vi res(n);    rep(i, n) {        assert(!was[a[i]]);        res[a[i]] = i;        was[a[i]] = true;    }    return res;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;//@formatter:on\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {\n    while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }\n    return i;\n}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define o_getid(a, b, name, ...) name\n#define getid(...) o_getid(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n#define shuffle(a) std::random_device seed_gen;std::mt19937 engine(seed_gen());std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n#undef getid\n/*@formatter:off*/\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0, f, t, c,wasp = (p != -1 && ve[gi].t == p) ? 1 : 0; (wasp = wasp ? 1 : (p != -1 && ve[gi].t == p) ? 1 : 0,gi + wasp < ve.size()) &&(tie(f, t, c) = wasp ?  make_tuple(ve[gi + 1].f, ve[gi + 1].t, ve[gi + 1].c) : make_tuple(ve[gi].f, ve[gi].t, ve[gi].c), true); ++gi)\n#define fore(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n\ntemplate<class T> struct edge {    int f, t;    T c;    edge(int f, int t, T c = 1) : f(f), t(t), c(c) {}    bool operator<(const edge &b) const { return c < b.c; }    bool operator>(const edge &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {os << e.f << \" \" << e.t << \" \" << e.c;return os;}\ntemplate<typename T> class graph {\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    explicit graph(int n) : n(n) { g.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {this->n = n;g.resize(n);}\n    int size() { return n; }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    explicit digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {debugline(\"digraph add\");deb(f, t, c);ole();}\n        g[f].emplace_back(f, t, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges() override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;    using graph<T>::n;    using graph<T>::edges;\n    explicit undigraph(int n) : graph<T>(n) {}\n    // f < t\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"undigraph add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n        edges.emplace_back(t, f, c);\n    }\n    void add(edge<T> &e) {        int f = e.f, t = e.t;        T c = e.c;        add(f, t, c);    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges () override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\n#define dijkstra_path dis_path\ntemplate<class T> vi dis_path(digraph<T> &g, vector<T> &dis, int s, int t, int init_value) {    assert(dis[t] != init_value);    auto rg = rev(g);    int now = t;    vi path;    path.push_back(now);    T cost = 0;    while (now != s) {        rep(gi, sz(rg[now])) {            int m = rg[now][gi].t;            if (dis[m] == init_value)continue;            if (dis[m] + rg[now][gi].c + cost == dis[t]) {                cost += rg[now][gi].c;                now = m;                break;            }        }        path.push_back(now);    }    rev(path);    return path;}\ntemplate<class T> vi dis_path(undigraph<T> &g, vector<T> &dis, int s, int t, int init_value) {    assert(dis[t] != init_value);    int now = t;    vi path;    path.push_back(now);    T cost = 0;    while (now != s) {        rep(gi, sz(g[now])) {            int m = g[now][gi].t;            if (dis[m] == init_value)continue;            if (dis[m] + g[now][gi].c + cost == dis[t]) {                cost += g[now][gi].c;                now = m;                break;            }        }        path.push_back(now);    }    rev(path);    return path;}\ntemplate<class T> vi dis_path(digraph<T> &g, vector<vector<T>> &dis, int s, int t, int init_value) { return dis_path(g, dis[s], s, t, init_value); }\ntemplate<class T> vi dis_path(undigraph<T> &g, vector<vector<T>> &dis, int s, int t, int init_value) { return dis_path(g, dis[s], s, t, init_value); }\n//O(N^2)\ntemplate<class T> vector<T> dijkstra_mitu(graph<T> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra_mitu\");        deb(s, g.n);        ole();    }    int n = g.n;    int initValue = MAX(int);    vector<T> dis(n, initValue);    dis[s] = 0;    vb used(n);    while (true) {        int v = -1;        rep(u, n) { if (!used[u] && (v == -1 || dis[u] < dis[v]))v = u; }        if (v == -1)break;        if (dis[v] == initValue)break;        used[v] = true;        rep(u, sz(g[v])) {            auto e = g[v][u];            dis[e.t] = min(dis[e.t], dis[v] + e.c);        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) { if (d == initValue) { d = init_value; }}    return dis;}\ntemplate<typename T> struct radixheap {    vector<pair<u64, T> > v[65];    u64 size, last;    radixheap() : size(0), last(0) {}    bool empty() const { return size == 0; }    int getbit(int a) { return a ? 64 - __builtin_clzll(a) : 0; }    void push(u64 key, const T &value) {        ++size;        v[getbit(key ^ last)].emplace_back(key, value);    }    pair<u64, T> pop() {        if (v[0].empty()) {            int idx = 1;            while (v[idx].empty()) ++idx;            last = min_element(begin(v[idx]), end(v[idx]))->first;            for (auto &p : v[idx]) v[getbit(p.first ^ last)].emplace_back(p);            v[idx].clear();        }        --size;        auto ret = v[0].back();        v[0].pop_back();        return ret;    }};\n/*radix_heap こっちの方が早い*/\n//O((N+M) log N)\nvi dijkstra(graph<int> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    /*O((N+M) log N) vs O(N^2)*/    if ((g.n + sz(g.edges)) * log2(N) > g.n * g.n) {        return dijkstra_mitu(g, s, init_value);    }    int initValue = MAX(int);    vi dis(g.n, initValue);    radixheap<int> q;    dis[s] = 0;    q.push(0, s);    while (!q.empty()) {        int nowc, i;        tie(nowc, i) = q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            int c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.push(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/   for (auto &&d :dis) if (d == initValue)d = init_value;    return dis;}\ntemplate<class T> vector<T> dijkstra_normal(graph<T> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    if ((g.n + sz(g.edges)) * 20 > g.n * g.n) {        return dijkstra_mitu(g, s, init_value);    }    T initValue = MAX(T);    vector<T> dis(g.n, initValue);    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;    dis[s] = 0;    q.emplace(0, s);    while (q.size()) {        T nowc = q.top().fi;        int i = q.top().se;        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.emplace(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) if (d == initValue)d = init_value;    return dis;}\ntemplate<class T> vector<T> dijkstra_01(graph<T> &g, int s, int init_value) {    int N = g.n;    vi dis(N, linf);    dis[s] = 0;    deque<int> q;    q.push_back(s);    vb was(N);    while (!q.empty()) {        int f = q.front();        q.pop_front();        if (was[f])continue;        was[f] = true;        fora(e, g[f]) {            if (dis[e.t] > dis[f] + e.c) {                if (e.c) {                    dis[e.t] = dis[f] + 1;                    q.push_back(e.t);                }                else {                    dis[e.t] = dis[f];                    q.push_front(e.t);                }            }        }    }    rep(i, N)if(dis[i]==linf)dis[i]=init_value;    return dis;}\n//dijkstra_cou<mint> : 数える型で書く return vp(dis,cou)\ntemplate<class COU,class T=int> auto dijkstra_cou(const graph<T> &g, int s, int init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    err(\"count by type COU \");    err(\"int or mint\");    T initValue = MAX(T);    vector<T> dis(g.n, initValue);    vector<COU> cou(g.n);    cou[s] = 1;    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;    dis[s] = 0;    q.emplace(0, s);    while (q.size()) {        T nowc = q.top().fi;        int i = q.top().se;        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                cou[to] = cou[e.f];                q.emplace(dis[to], to);            }            else if (dis[to] == c) { cou[to] += cou[e.f]; }        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) if (d == initValue)d = init_value;    return vtop(dis, cou);}\n//密グラフの時、warshallに投げる\ntemplate<class T> vector<vector<T>> dijkstra_all(const graph<T> &g, int init_value) {int n = g.n;assert(n < 1e4);if (n * n < (n + sz(g.edges)) * 14) {        /*O(N^3) vs O(N (N+M)log N)*/        return warshall(g, init_value); }vector<vector<T>> dis(n);rep(i, n) { dis[i] = dijkstra(g, i, init_value); }return dis;}\n//コストを無限に減らせる := -linf\n//たどり着けない := linf\ntemplate<class T> vector<T> bell(graph<T> &g, int s) {    if (g.n >= 1e4) {        cout << \"bell size too big\" << endl;        exit(0);    }    vector<T> res(g.n, linf);    res[s] = 0;    vb can(g.n);    /*頂点から行けない頂点を持つ、辺を消しておく */    fix([&](auto ds, int p, int i) -> void {        if (can[i])return;        can[i] = true;        forg(gi, g[i])if (t != p)ds(i, t);    })(-1, 0);    vector<edge<T>> es;    fora(e, g.edges) { if (can[e.f])es += e; }    rep(i, g.n) {        bool upd = false;        fora(e, es) {            if (res[e.f] != linf && res[e.t] > res[e.f] + e.c) {                upd = true;                res[e.t] = res[e.f] + e.c;            }        }        if (!upd)break;    }    rep(i, g.n * 2) {        bool upd = 0;        fora(e, g.edges) {            if (res[e.f] != linf && res[e.t] != -linf && res[e.t] > res[e.f] + e.c) {                upd = 1;                res[e.t] = -linf;            }        }        if (!upd)break;    }    return res;}\n//コストを無限に増やせる := linf\n//たどり着けない := -linf\ntemplate<class T> vector<T> bell_far(graph<T> &g, int s) {    if (g.n >= 1e4) {        cout << \"bell_far size too big\" << endl;        exit(0);    }    vector<T> res(g.n, linf);    res[s] = 0;    vb can(g.n);    /*頂点から行けない頂点を持つ、辺を消しておく*/    fix([&](auto ds, int p, int i) -> void {        if (can[i])return;        can[i] = true;        forg(gi, g[i])if (t != p)ds(i, t);    })(-1, 0);    vector<edge<T>> es;    fora(e, g.edges) { if (can[e.f])es += e; }    rep(i, g.n) {        bool upd = false;        fora(e, es) {            if (res[e.f] != linf && res[e.t] > res[e.f] - e.c) {/*-c*/                upd = true;                res[e.t] = res[e.f] - e.c;/*-c*/            }        }        if (!upd)break;    }    rep(i, g.n * 2) {        bool upd = 0;        fora(e, g.edges) {            if (res[e.f] != linf && res[e.t] != -linf && res[e.t] > res[e.f] - e.c) {/*-c*/                upd = 1;                res[e.t] = -linf;            }        }        if (!upd)break;    }    rep(i, g.n)res[i] *= -1;    return res;}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int init_value) {    int n = g.n;    assert(n < 1e4);    vector<vector<T> > dis(n, vector<T>(n, linf));    rep(i, n)fora(e, g.g[i]) {            if (dis[e.f][e.t] > e.c) {                dis[e.f][e.t] = e.c;            }        }    rep(i, n)dis[i][i] = 0;    rep(k, n)        rep(i, n)            rep(j, n) {                if (dis[i][j] > dis[i][k] + dis[k][j]) {                    dis[i][j] = dis[i][k] + dis[k][j];                }            }    rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = init_value;    return dis;}\ntemplate<class T> class MinOp { public: T operator()(T a, T b) { return min(a, b); }};\ntemplate<typename OpFunc> struct SparseTable {    OpFunc op;    signed size;    vector<signed> lg;    vector<vector<pair<signed, signed>>> table;    void init(const vector<pair<signed, signed>> &array, OpFunc opfunc) {        signed n = array.size();        op = opfunc;        lg.assign(n + 1, 0);        for (signed i = 1; i <= n; i++) { lg[i] = 31 - __builtin_clz(i); }        table.assign(lg[n] + 1, array);        for (signed i = 1; i <= lg[n]; i++) { for (signed j = 0; j < n; j++) { if (j + (1 << (i - 1)) < n) { table[i][j] = op(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]); } else { table[i][j] = table[i - 1][j]; }}}    }    pair<signed, signed> query(signed l, signed r) {        assert(l < r);        return op(table[lg[r - l]][l], table[lg[r - l]][r - (1 << lg[r - l])]);    }};\nstruct PMORMQ {    vector<signed> a;    SparseTable<MinOp<pair<signed, signed> > > sparse_table;    vector<vector<vector<signed> > > lookup_table;    vector<signed> block_type;    signed block_size, n_block;    void init(const vector<signed> &array) {        a = array;        signed n = a.size();        block_size = std::max(1, (31 - __builtin_clz(n)) / 2);        while (n % block_size != 0) {            a.push_back(a.back() + 1);            n++;        }        n_block = n / block_size;        vector<pair<signed, signed> > b(n_block, make_pair(INT_MAX, INT_MAX));        for (signed i = 0; i < n; i++) { b[i / block_size] = min(b[i / block_size], make_pair(a[i], i)); }        sparse_table.init(b, MinOp<pair<signed, signed> >());        block_type.assign(n_block, 0);        for (signed i = 0; i < n_block; i++) {            signed cur = 0;            for (signed j = 0; j < block_size - 1; j++) {                signed ind = i * block_size + j;                if (a[ind] < a[ind + 1]) { cur |= 1 << j; }            }            block_type[i] = cur;        }        lookup_table.assign(1 << (block_size - 1), vector<vector<signed> >(block_size, vector<signed>(block_size + 1)));        for (signed i = 0; i < (1 << (block_size - 1)); i++) {            for (signed j = 0; j < block_size; j++) {                signed res = 0;                signed cur = 0;                signed pos = j;                for (signed k = j + 1; k <= block_size; k++) {                    lookup_table[i][j][k] = pos;                    if (i & (1 << (k - 1))) { cur++; } else { cur--; }                    if (res > cur) {                        pos = k;                        res = cur;                    }                }            }        }    }    signed query(signed l, signed r) {        assert(l < r);        signed lb = l / block_size;        signed rb = r / block_size;        if (lb == rb) { return lb * block_size + lookup_table[block_type[lb]][l % block_size][r % block_size]; }        signed pl = lb * block_size + lookup_table[block_type[lb]][l % block_size][block_size];        signed pr = rb * block_size + lookup_table[block_type[rb]][0][r % block_size];        signed pos = pl;        if (r % block_size > 0 && a[pl] > a[pr]) { pos = pr; }        if (lb + 1 == rb) { return pos; }        signed spv = sparse_table.query(lb + 1, rb).second;        if (a[pos] > a[spv]) { return spv; }        return pos;    }};\n\ntemplate<class T=int> class tree : public undigraph<T> {\n    PMORMQ rmq;    int cnt;    vector<signed> id, in;    bool never = true;    bool never_hld = true;\n    void dfs(int x, int p, int d, int dis = 0) {        id[cnt] = x;        par_[x] = p;        rmq_dep.push_back(d);        disv[x] = dis;        in[x] = cnt++;        forg(gi, g[x]) {            if (t == p) { continue; }            dfs(t, x, d + 1, dis + c);            id[cnt] = x;            rmq_dep.push_back(d);            cnt++;        }    }    void precalc() {        never = false;        cnt = 0;        rmq_dep.clear();        disv.assign(n, 0);        in.assign(n, -1);        id.assign(2 * n - 1, -1);        par_.assign(n, -1);        dfs(root, -1, 0);        rmq.init(rmq_dep);\n#ifdef _DEBUG\n        if(n>=100)return;cerr << \"---tree---\" << endl;        rep(i, n) {            if (!(i == root || sz(g[i]) > 1))continue;            cerr << i << \" -> \";            vi ts;            forg(gi, g[i]) { if (t != par_[i])ts.push_back(t); }            rep(i, sz(ts) - 1)cerr << ts[i] << \", \";            if(sz(ts))cerr << ts.back() << endl;        }        cerr << endl;\n#endif\n    }    int pos;    void hld_build() {        never_hld = false;        if (never)precalc();        g.resize(n);        vid.resize(n, -1);        head.resize(n);        heavy.resize(n, -1);        depth.resize(n);        inv.resize(n);        subl.resize(n);        subr.resize(n);        dfs(root, -1);        t = 0;        dfs_hld(root);\n#ifdef _DEBUG\n        if (n >= 100)return;        cerr << \"---hld_index---\" << endl;        vi inds;        rep(i, n) if (sz(g[i]))inds.push_back(i);        rep(i, sz(inds)) {            str s = tos(bel(inds[i]));            cerr << std::right << std::setw(sz(s) + (i ? 1 : 0)) << inds[i];        }        cerr << endl;        rep(i, sz(inds)) { cerr << bel(inds[i]) << \" \"; }        cerr << endl << endl;        cerr << \"---hld_edge_index---\" << endl;        fora(e, edges) { if (e.f <= e.t) cerr << e.f << \"-\" << e.t << \" \" << bel(e) << endl; }        cerr << endl << endl;        cerr << \"!!query!! edge or not edge carefull!!\" << endl;\n#endif\n    }    int dfs(int curr, int prev) {        int sub = 1, max_sub = 0;        heavy[curr] = -1;        forg(i, g[curr]) {            int next = t;            if (next != prev) {                depth[next] = depth[curr] + 1;                int sub_next = dfs(next, curr);                sub += sub_next;                if (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;            }        }        return sub;    }    int t = 0;\n#ifndef __CLION_IDE__\n    void dfs_hld(int v = 0) {        vid[v] = subl[v] = t;        t++;        inv[subl[v]] = v;        if (0 <= heavy[v]) {            head[heavy[v]] = head[v];            dfs_hld(heavy[v]);        }        forg(i, g[v])if (depth[v] < depth[t])                if (t != heavy[v]) {                    head[t] = t;                    dfs_hld(t);                }        subr[v] = t;    }\n#endif//__CLION_IDE__\n    vector<signed> rmq_dep;\n    vi par_, depth, disv;\n    vi childs;\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;\n    int root;\n    //部分木の  [左端、右端)  index\n    //部分木の辺に加算する場合\n    //add(subl[i],subr[i],x)\n    //add(sub[i],sub[i+1],-x)\n    vector<int> vid, head, heavy, inv, subl, subr;\n    tree(int n_, int root = 0) : undigraph<T>(n_), root(root) { n = n_; }\n    void change_root(int roo){root = roo;precalc();}\n    int lca(int a, int b) {        if (never)precalc();        int x = in[a];        int y = in[b];        if (x > y) { swap(x, y); }        int pos = rmq.query(x, y + 1);        return id[pos];    }\n    int dis(int a, int b) {        if (never)precalc();        int x = in[a];        int y = in[b];        if (x > y) { swap(x, y); }        int pos = rmq.query(x, y + 1);        int p = id[pos];        return disv[a] + disv[b] - disv[p] * 2;    }\n    int dep(int a){if (never)precalc(); return disv[a];}\n    int par(int a){if (never)precalc(); return par_[a];}\n    bool isleaf(int i){if(never)precalc();return(sz(g[i])==1 && i!=root);}\n    vi child(int r) {        vi res;        res.push_back(r);        queue<int> q;        q.push(r);        while (!q.empty()) {            int i = q.front();            res.push_back(i);            q.pop();            forg(gi, g[i]) {                if (t != par(i))q.push(t);            }        }        return res;    }\n    vb child_ex(int r) {        vb res(n);        res[r] = true;        queue<int> q;        q.push(r);        while (!q.empty()) {            int i = q.front();            res[i] = true;            q.pop();            forg(gi, g[i]) {                if (t != par(i))q.push(t);            }        }        return res;    }int dfs_count_subtree(int p,int i){        childs[i] =1;        fort(gi, g[i]){            childs[i] += dfs_count_subtree(i,t);        }        return childs[i];    }\n    #define count_child count_subtree\n    int count_subtree(int f){        if(sz(childs)==0){            if(never)precalc();            childs.resize(n);            dfs_count_subtree(-1,root);        }        return childs[f];    }\n    //fからtの辺を切った時のtの大きさ\n    int count_subtree(int f,int t){        if(par(f)==t)    {            return n - count_subtree(f);        }else{            return count_subtree(t);        }    }\n    vi path(int a, int b) {        vi res;        for_each_l(a, b, [&](int i) { res.push_back(i); });        return res;    }\n    /*O(N) hldを使わず木を普通にたどる liteの意*/\n    void for_each_l(int u, int v, function<void(int)> fnode) {        int r = lca(u, v);        while (u != r) {            fnode(u);            u = par_[u];        }        fnode(r);        vi a;        while (v != r) {            a.push_back(v);            v = par_[v];        }        while(sz(a)){            fnode(a.back());            a.pop_back();        }    }\n    void for_each_edge_l(int u, int v, function<void(edge<int> &)> fedge) {        int r = lca(u, v);        while (u != r) {                forg(gi, g[u]) {                    if (t == par_[u]) {                        fedge(g[u][gi]);                        u = par_[u];                        break;                    }                }            }        vector<edge<int>> qs;        while (v != r) {                forg(gi, g[v]) {                    if (t == par_[v]) {                        qs.push_back(g[v][gi]);                        v = par_[v];                        break;                    }                }            }        while(sz(qs)){            fedge(qs.back());            qs.pop_back();        }    }\n    //Fは半開 (u,v)は木の頂点\n    //中ではhldの頂点を見るため、seg木のupdateはhldのindexで行なう\n    void for_each_/*[l,r)*/(int u, int v, const function<void(int, int)> &f) {        if (never_hld)hld_build();        while (1) {            if (vid[u] > vid[v]) swap(u, v);            int l = max(vid[head[v]], vid[u]);            int r = vid[v] + 1;            f(l, r);            if (head[u] != head[v]) v = par_[head[v]]; else break;        }    }\n    void for_each_edge/*[l,r) O(log(N)) 辺を頂点として扱っている 上と同じ感じで使える*/(int u, int v, const function<void(int, int)> &f) {        if (never_hld)hld_build();        while (1) {            if (vid[u] > vid[v]) swap(u, v);            if (head[u] != head[v]) {                int l = vid[head[v]];                int r = vid[v] + 1;                f(l, r);                v = par_[head[v]];            } else {                if (u != v) {                    int l = vid[u] + 1;                    int r = vid[v] + 1;                    f(l, r);                }                break;            }        }    }\n    int bel(int v) {        /*hld内での頂点番号を返す*/        if (never_hld)hld_build();return vid[v];}\n    //下の頂点に辺のクエリを持たせている\n    int bel(int f, int t) {        /*辺のクエリを扱うときどの頂点に持たせればいいか(vidを返すのでそのままupd出来る)*/        if (never_hld)hld_build();return depth[f] > depth[t] ? vid[f] : vid[t];}\n    int bel(edge<T> &e) {        /*辺のクエリを扱うときどの頂点に持たせればいいか(vidを返すのでそのままupd出来る)*/        if (never_hld)hld_build();return depth[e.f] > depth[e.t] ? vid[e.f] : vid[e.t];}\n    template<class ... U> int operator()(U ... args) { return bel(args...); }\n    //path l -> r += v\n    template<class S> void seg_add(S &seg, int lhei, int rhei, int v) {for_each_(lhei, rhei, [&](int l, int r) { seg.add(l, r, v); });}\n    template<class S> void seg_update(S &seg, int lhei, int rhei, int v) {for_each_(lhei, rhei, [&](int l, int r) { seg.update(l, r, v); });}\n    template<class S> T seg_get(S &seg, int lhei, int rhei) {        T res = seg.e;        for_each_(lhei, rhei, [&](int l, int r) { res = seg.f(res, seg.get(l, r)); });        return res;    }\n    template<class S> void seg_add_edge(S &seg, int lhei, int rhei, int v) { for_each_edge(lhei, rhei, [&](int l, int r) { seg.add(l, r, v); }); }\n    template<class S> void seg_update_edge(S &seg, int lhei, int rhei, int v) { for_each_edge(lhei, rhei, [&](int l, int r) { seg.update(l, r, v); }); }\n    template<class S> T seg_get_edge(S &seg, int lhei, int rhei) {        T res = seg.e;        for_each_edge(lhei, rhei, [&](int l, int r) { res = seg.f(res, seg.get(l, r)); });        return res;    }\n    //単体   edgeは上で処理できる\n    template<class S> void seg_add(S &seg, int i, int v) { seg.add(bel(i), v); }\n    template<class S> void seg_update(S &seg, int i, int v) { seg.update(bel(i), v); }\n    template<class S> T seg_get(S &seg, int i) { return seg[i]; }\n    template<class S> void seg_del(S &seg, int i) { seg.del(bel(i)); }\n\n    //部分木iに対するクエリ\n    template<class S> void seg_add_sub(S &seg, int i, int v) {if (never_hld)hld_build();seg.add(subl[i], subr[i], v);}\n    template<class S> void seg_update_sub(S &seg, int i, int v) {if (never_hld)hld_build();seg.update(subl[i], subr[i], v);}\n    template<class S> T seg_get_sub(S &seg, int i, int v) {if (never_hld)hld_build();return seg.get(subl[i], subr[i], v);}\n    template<class S> void seg_add_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/seg.add(subl[i] + 1, subr[i], v);}\n    template<class S> void seg_update_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/seg.update(subl[i] + 1, subr[i], v);}\n    template<class S> T seg_get_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/return seg.get(subl[i] + 1, subr[i], v);}\n};\n//辺が多いのでedgesを持たない\n//cost oo, ox, xo, xx 渡す\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\n    vi costs;\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;\n    int H, W;\n    vector<vector<char>> ba;\n    char wall;\n\n    void add(int f, int t, T c = 1){\n        cout << \"grid\" << endl;\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"grid_k6 add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        //undigraphと違い、edgesを持たない\n    }\n    int getid(int h, int w) {        assert(ins(h, w, H, W));        return W * h + w;    }\n    int getid(P p) { return getid(p.first, p.second); }\n    P get2(int id) { return mp(id / W, id % W); }\n    P operator()(int id) { return get2(id); }\n    int operator()(int h, int w) { return getid(h, w); }\n    int operator()(P p) { return getid(p); }\n    //辺は無い\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {}\n    grid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) { add(f, getid(h, w + 1)); }                if (h + 1 < H && ba[h + 1][w] != wall) { add(f, getid(h + 1, w)); }            }        }    }\n    /*o -> o, o -> x, x-> x*/\n    grid_k6(vector<vector<char>> ba, int oo, int ox, int xo, int xx, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])), costs({oo, ox, xo, xx}), ba(ba), wall(wall) {        rep(h, H) {            rep(w, W) {                add(h, w, h + 1, w);                add(h, w, h - 1, w);                add(h, w, h, w + 1);                add(h, w, h, w - 1);            }        }    }\n    void add(int fh, int fw, int th, int tw) {        if (ins(fh, fw, H, W) && ins(th, tw, H, W)) {            int cm = 0;            if (ba[fh][fw] == wall) { cm += 2; }            if (ba[th][tw] == wall) { cm++; }            int f = getid(fh, fw);            int t = getid(th, tw);            g[f].emplace_back(f, t, costs[cm]);        }    }\n    void set_edges() { rep(i, n)fora(e, g[i])if (e.f < e.t)edges.push_back(e); }\n};\n\n//辺によりメモリを大量消費ためedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    int H, W;\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"digrid_k6 add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        /*digraphと違いedgesを持たない*/\n    }\n    int getid(int h, int w) {        if (!ins(h, w, H, W))return -1;        return W * h + w;    }\n    P get2(int id) { return mp(id / W, id % W); }\n    P operator()(int id) { return get2(id); }\n    int operator()(int h, int w) { return getid(h, w); }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W){}\n    digrid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) { add(f, getid(h, w + 1)); }                if (h + 1 < H && ba[h + 1][w] != wall) { add(f, getid(h + 1, w)); }            }        }    }\n    void add(int fh, int fw, int th, int tw) { add(getid(fh, fw), getid(th, tw)); }\n    void set_edges() { rep(i, n)fora(e, g[i])edges.push_back(e); }\n};\n//edgesを持たない\n//dijkstra(g,0)[t] とかける (t+n-1等とする必要はない)\ntemplate<class T=int>class segdi : public digraph<T>{int getid(int k){        if(k >= len*2-1){            return k;        }        else if(k < len - 1){            return k + len;        }else{            return k - len + 1;        }    }void add(int f, int t, T c = 1) {        f = getid(f);        t = getid(t);        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"segdi add\");            deb(f, t, c);            ole();        }        g[f].emplace_back(f, t, c);        /*digraphと違いedgesを持たない*/    }int mid;int len;\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    //頂点が足りなくなったらresize\n    segdi(int n_) : digraph<T>(1) {        int nn = 1;        while (nn < n_)nn *= 2;        n_ = nn;        len = n_;        this->resize(n_ + (n_ - 1) * 2 + n_);        mid = n_ + (n_ - 1) * 2;        int ad = len * 2 - 1;        rep(i, len - 1) {            add(i, i * 2 + 1, 0);            add(i, i * 2 + 2, 0);            if (i * 2 + 1 >= len - 1) {                add(i * 2 + 1, i + ad, 0);                add(i * 2 + 2, i + ad, 0);            } else {                add(i * 2 + 1 + ad, i + ad, 0);                add(i * 2 + 2 + ad, i + ad, 0);            }        }    }\n    void dfs(vi &list, int nl, int nr, int k, int l, int r) {        if (r <= nl || nr <= l)return;        if (l <= nl && nr <= r) {            list += k;        } else {            dfs(list, nl, (nl + nr) / 2, k * 2 + 1, l, r);            dfs(list, (nl + nr) / 2, nr, k * 2 + 2, l, r);        }    }\n    void rekkyo(vi &list, int l, int r) {        l += len - 1;        r += len - 1;        while (l < r) {            if (!(l & 1)) { list.push_back(l); }            if (!(r & 1)) { list.push_back(r - 1); }            l >>= 1;            r = (r - 1) >> 1;        }    }\n    //半開\n    void add(int fl, int fr, int tl, int tr, int cost) {        /*fは下側*/        int ad = 2 * len - 1;        if (mid >= n) { this->resize(n + 100); }        {            int l = fl, r = fr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) {                    if (l - len + 1 < 0)add(l + ad, mid, cost);                    else add(l, mid, cost);                }                if (!(r & 1)) {                    if (r - 1 - len + 1 < 0)add(r - 1 + ad, mid, cost);                    else add(r - 1, mid, cost);                }                l >>= 1;                r = (r - 1) >> 1;            }        }        {            int l = tl, r = tr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) { add(mid, l, 0); }                if (!(r & 1)) { add(mid, r - 1, 0); }                l >>= 1;                r = (r - 1) >> 1;            }        }        mid++;    }\n};\n//edgesを持たない\n//dijkstra(g,0)[t] とかける (t+n-1等とする必要はない)\ntemplate<class T=int>class segun : public undigraph<T>{int getid(int k){        if(k >= len*2-1){            return k;        }        else if(k < len - 1){            return k + len;        }else{            return k - len + 1;        }    }void add(int f, int t, T c = 1) {        f = getid(f);        t = getid(t);        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"segun add\");            deb(f, t, c);            ole();        }        g[f].emplace_back(f, t, c);        /*digraphと違いedgesを持たない*/            g[t].emplace_back(t, f, c);        /*digraphと違いedgesを持たない*/    }    int mid;    int len;\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    //頂点が足りなくなったらresize\n    segun(int n_) : digraph<T>(1) {        int nn = 1;        while (nn < n_)nn *= 2;        n_ = nn;        len = n_;        this->resize(n_ + (n_ - 1) * 2 + n_);        mid = n_ + (n_ - 1) * 2;        int ad = len * 2 - 1;        rep(i, len - 1) {            add(i, i * 2 + 1, 0);            add(i, i * 2 + 2, 0);            if (i * 2 + 1 >= len - 1) {                add(i * 2 + 1, i + ad, 0);                add(i * 2 + 2, i + ad, 0);            } else {                add(i * 2 + 1 + ad, i + ad, 0);                add(i * 2 + 2 + ad, i + ad, 0);            }        }    }\n    void dfs(vi &list, int nl, int nr, int k, int l, int r) {        if (r <= nl || nr <= l)return;        if (l <= nl && nr <= r) {            list += k;        } else {            dfs(list, nl, (nl + nr) / 2, k * 2 + 1, l, r);            dfs(list, (nl + nr) / 2, nr, k * 2 + 2, l, r);        }    }\n    void rekkyo(vi &list, int l, int r) {        l += len - 1;        r += len - 1;        while (l < r) {            if (!(l & 1)) { list.push_back(l); }            if (!(r & 1)) { list.push_back(r - 1); }            l >>= 1;            r = (r - 1) >> 1;        }    }\n    //半開\n    void add(int fl, int fr, int tl, int tr, int cost) {        /*fは下側*/        int ad = 2 * len - 1;        if (mid >= n) { this->resize(n + 100); }        {            int l = fl, r = fr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) {                    if (l - len + 1 < 0)add(l + ad, mid, cost);                    else add(l, mid, cost);                }                if (!(r & 1)) {                    if (r - 1 - len + 1 < 0)add(r - 1 + ad, mid, cost);                    else add(r - 1, mid, cost);                }                l >>= 1;                r = (r - 1) >> 1;            }        }        {            int l = tl, r = tr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) { add(mid, l, 0); }                if (!(r & 1)) { add(mid, r - 1, 0); }                l >>= 1;                r = (r - 1) >> 1;            }        }        mid++;    }\n};\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define o_getid(a,b,name,...) name\n#define getid(...) o_getid(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n\n#define unionfind unionfind_graph\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    template<class T>unionfind(graph<T>& g) : n(g.n), trees(g.n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }        add(g);    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    template<class T>void add(graph<T>&g){fora(e,g.edges){unite(e.f,e.t);}}\n    template<class T>void unite(graph<T>&g){add(g);}\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\n//@出力\ntemplate<class T> ostream &operator<<(ostream &os, digraph<T> &g) {    os << endl << g.n << \" \" << sz(g.edges) << endl;    fore(gi, g.edges) { os << f << \" \" << t << \" \" << c << endl; }    return os;}template<class T> ostream &operator<<(ostream &os, undigraph<T> &g) {    os << endl << g.n << \" \" << sz(g.edges)/2 << endl;    fore(gi, g.edges) { if (f < t)os << f << \" \" << t << \" \" << c << endl; }    return os;}\n\n//@判定\ntemplate<class T> bool nibu( graph<T> &g) {    int size = 0;    rep(i, g.n)size += sz(g.g[i]);    if (size == 0)return true;    unionfind uf(g.n * 2);    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);    rep(i, g.n)if (uf.same(i, i + g.n))return 0;    return true;}\n//頂点ではなく辺の数に依存した計算量 O(E)\ntemplate<class T> bool nibu_sub( graph<T> &g) {    umapi col;/*0なら無色 */   queue<int> q;    /*色は01か11 */    fora(e, g.edegs) {        /*fとtの色を持つか否かは同じ*/        if (col[e.f] == 0)q.push(e.f);        while (!q.empty()) {            int f = q.front();            q.pop();            int fc = col[f];            forg(gi, g[f]) {                int &tc = col[t];                /*fcには色がある*/                if (fc == tc)return false;                /*違う色*/                if (tc)continue;                /*無色*/                tc = fc ^ 2;                q.push(tc);            }        }    }    return true;}\n    //二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {    vp cg;    if (!nibu(g)) {        debugline(\"nibu\");        ole();    }    int n = g.size();    vb was(n);    queue<P> q;    rep(i, n) {        if (was[i])continue;        q.push(mp(i, 1));        was[i] = 1;        int red = 0;        int coun = 0;        while (q.size()) {            int now = q.front().fi;            int col = q.front().se;            red += col;            coun++;            q.pop();            forg(gi, g[now]) {                if (was[t])continue;                q.push(mp(t, col ^ 1));                was[t] = 1;            }        }        cg.push_back(mp(red, coun - red));    }    return cg;}\n    //連結グラフが与えられる 閉路があるか\ntemplate<class T> bool close(undigraph<T> &g) {    int n = 0;    int e = 0;    rep(i, g.n) {        if (sz(g[i]))n++;        forg(gi, g[i]) { e++; }    }    return (e >> 1) >= n;}\ntemplate<class T> bool close(undigraph<T> &g, int v) {    unionfind uf(g.n);    rep(i, g.n) {        forg(gi, g[i]) {            if (f < t)break;            if (f == t && f == v)return true;            if (uf.same(f, v) && uf.same(t, v))return true;            uf.unite(f, t);        }    }    return false;}template<class T> bool close(digraph<T> &g) {    vi res;    return topo(res, g);}\n\n//@変形\n//条件(f!=0等 f,t,cが使える)を満たすsubgraphをg2に代入\n#define sub_di(g, g2, zhouken) {g2.resize(g.n);fore(gi, g.edges){if(zhouken){g2.add(f,t,c);}}}\n#define sub_un(g, g2, zhouken) {g2.resize(g.n);fore(gi, g.edges){bool ok = zhouken; /*片方がアウトなら駄目という扱い*/swap(f,t); ok &= zhouken;if(ok && f < t){g2.add(f,t,c);}}}\n#define sub_tree sub_un\n    //閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    queue<int> st;    rep(i, n)if (nyu[i] == 0)st.push(i);    while (st.size()) {        int v = st.front();        st.pop();        res.push_back(v);        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);    }    return res.size() == n;}\n    //辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    /*小さい順*/    priority_queue<int, vector<int>, greater<int> > q;    rep(i, n)if (nyu[i] == 0)q.push(i);    while (q.size()) {        int i = q.top();        q.pop();        res.push_back(i);        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);    }    return res.size() == n;}\ntemplate<class T> digraph<T> rev(digraph<T> &g) {    digraph<T> r(g.n);    rep(i, g.n) { forg(gi, g[i]) { r.add(t, f, c); }}    return r;}\n    //lc,rcは子を持つ中で一番左、右\n    //(g,ind,l,r)\ntemplate<class T> tree<T> get_bfs_tree(tree<T> &g, vi &ind, vi &l, vi &r) {if (sz(ind)) {cerr << \"ind must be empty\" << endl;exit(0);}int N = sz(g);ind.resize(N);l.resize(N, inf);r.resize(N, -1);tree<T> h(N);queue<P> q;q.emplace(-1, 0);int c = 0;while (sz(q)) {int p = q.front().first;int i = q.front().second;q.pop();ind[i] = c;if (~p)chmi(l[ind[p]], c);if (~p)chma(r[ind[p]], c);c++;forg(gi, g[i]) {if (t != p)q.emplace(i, t);}}fora(e, g.edges) {if (e.f < e.t) {h.add(ind[e.f], ind[e.t], e.c);}}rep(i, N) {if (l[i] == inf)l[i] = -1;}return h;}\n    //lc,rcは子を持つ中で一番左、右\n    // たとえばl[lc[x]は2段下の最左\n    //(g,ind,l,r,lc,rc)\ntemplate<class T> tree<T> get_bfs_tree(tree<T> &g, vi &ind, vi &l, vi &r, vi &lc, vi &rc) {    if (sz(ind)) {        cerr << \"ind must be empty\" << endl;        exit(0);    }    int N = sz(g);    ind.resize(N);    l.resize(N, inf);    lc.resize(N, inf);    r.resize(N, -1);    rc.resize(N, -1);    tree<T> h(N);    queue<P> q;    q.emplace(-1, 0);    int c = 0;    while (sz(q)) {        int p = q.front().first;        int i = q.front().second;        q.pop();        ind[i] = c;        if (~p) {            chmi(l[ind[p]], c);            chma(r[ind[p]], c);            if (sz(g[i]) > 1) {                chmi(lc[ind[p]], c);                chma(rc[ind[p]], c);            }        }        c++;        forg(gi, g[i]) {            if (t != p)q.emplace(i, t);        }    }    fora(e, g.edges) {        if (e.f < e.t) {            h.add(ind[e.f], ind[e.t], e.c);        }    }    rep(i, N) {        if (l[i] == inf)l[i] = -1;        if (lc[i] == inf)lc[i] = -1;    }    return h;}\n\n//@集計\ntemplate<class T> vi indegree(graph<T> &g) {vi ret(g.size());rep(i, g.size()) { forg(gi, g[i]) { ret[t]++; }}return ret;}\ntemplate<class T> vi outdegree(graph<T> &g) {vi ret(g.size());rep(i, g.size()) { ret[i] = g[i].size(); }return ret;}\n#define kansetu articulation\n//private\n/*private*/  P farthest____(tree<> &E, int cur, int pre, int d, vi &D) {    D[cur] = d;    P r = {d, cur};    forg(gi, E[cur]) if (t != pre) {            P v = farthest____(E, t, cur, d + 1, D);            r = max(r, v);        }    return r;}\n//dagでなければ-1を返す\nint diameter(digraph<> &g) {    vi per;    if (!topo(per, g))return -1;    int n = g.n;    vi dp(n, 1);    fora(v, per) { forg(gi, g[v]) { chma(dp[t], dp[f] + 1); }}    return max(dp);}\n//iから最も離れた距離\nvi diameters(tree<> &E) { /* diameter,center*/vi D[3];    D[0].resize(E.size());    D[1].resize(E.size());    auto v1 = farthest____(E, 0, 0, 0, D[0]);    auto v2 = farthest____(E, v1.second, v1.second, 0, D[0]);    farthest____(E, v2.second, v2.second, 0, D[1]);    int i;    rep(i, D[0].size()) D[2].push_back(max(D[0][i], D[1][i]));    return D[2];}\n//iに対応するjと距離\nvp diameters_p(tree<> &E) { /* diameter,center*/vector<int> D[3];    D[0].resize(E.size());    D[1].resize(E.size());    auto v1 = farthest____(E, 0, 0, 0, D[0]);    auto v2 = farthest____(E, v1.second, v1.second, 0, D[0]);    farthest____(E, v2.second, v2.second, 0, D[1]);    int i;    vp res(E.size());    rep(i, D[0].size()) { if (D[0][i] > D[1][i])res[i] = mp(v1.second, D[0][i]); else res[i] = mp(v2.second, D[1][i]); }    return res;}\nint diameter(tree<> &E) {    vi d = diameters(E);    return max(d);}\n//最も離れた二点を返す\nP diameter_p(tree<> &E) {    auto d = diameters_p(E);    int dis = -1;    int l = -1, r = -1;    rep(i, sz(d)) {        if (chma(dis, d[i].se)) {            l = i;            r = d[i].fi;        }    }    return mp(l, r);}\n//@列挙 取得\n//閉路がある時linfを返す\ntemplate<class T> int longest_path(digraph<T> &g) {    vi top;    if (!topo(top, g)) { return linf; }    int n = sz(top);    vi dp(n, 0);    for (auto &&i : top) { forg(gi, g[i]) { chma(dp[t], dp[i] + 1); }}    return max(dp);}\ntemplate<class T> vi longest_path_v(digraph<T> &g) {    vi top;    if (!topo(top, g)) { return vi(); }    int n = sz(top);    vi dp(n, 0);    vi pre(n, -1);    for (auto &&i : top) { forg(gi, g[i]) { if (chma(dp[t], dp[i] + 1)) { pre[t] = i; }}}    int s = std::max_element(dp.begin(), dp.end()) - dp.begin();    vi path;    while (s != -1) {        path.push_back(s);        s = pre[s];    }    std::reverse(path.begin(), path.end());    return path;}\n//橋を列挙する (取り除くと連結でなくなる辺)\ntemplate<class T> vp bridge(graph<T> &G) {    static bool was;    vp brid;    vi articulation;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) brid.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) { low[v] = min(low[v], ord[G[v][i].t]); }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) articulation.push_back(v);    };    int k = 0;    rep(i, G.n) { if (!vis[i]) dfs(i, -1, k); }    sort(brid.begin(), brid.end());    return brid;}\n//間接点を列挙する (取り除くと連結でなくなる点)\ntemplate<class T> vi articulation(undigraph<T> &G) {    static bool was;    vp bridge;    vi arti;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) bridge.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) { low[v] = min(low[v], ord[G[v][i].t]); }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) arti.push_back(v);    };    int k = 0;    rep(i, G.n) { if (!vis[i]) dfs(i, -1, k); }    sort(arti.begin(), arti.end());    return arti;}\n//閉路パスを一つ返す\nvi close_path(digraph<> &g) {    int n = g.n;    vi state(n);    vi path;    rep(i, n) if (!state[i]) {            if (fix([&](auto dfs, int v) -> bool {                if (state[v]) {                    if (state[v] == 1) {                        path.erase(path.begin(), find(path.begin(), path.end(), v));                        return true;                    }                    return false;                }                path.push_back(v);                state[v] = 1;                forg(gi, g[v]) { if (dfs(t))return true; }                state[v] = -1;                path.pop_back();                return false;            })(i)) { return path; }        }    return vi();}\nvi close_path_min(digraph<> &g) {    int n = g.n;    vvi(dis, n);    rep(i, n)dis[i] = dijkstra(g, i, linf);    int mind = linf;    int f = 0, t = 0;    rep(i, n) {        rep(j, n) {            if (i == j)continue;            if (chmi(mind, dis[i][j] + dis[j][i])) {                f = i;                t = j;            }        }    }    vi path;    auto add = [&](int f, int t) {        int now = f;        while (now != t) {            rep(i, n) {                if (dis[now][i] == 1 && dis[f][i] + dis[i][t] == dis[f][t]) {                    path.push_back(i);                    now = i;                    break;                }            }        }    };    add(f, t);    add(t, f);    return path;}\n//iを含む最短閉路 https://atcoder.jp/contests/abc022/tasks/abc022_c\n/*閉路が1つしかない場合、その閉路に含まれる頂点を1としたvectorを返す*/;\ntemplate<class T> vi get_close1(digraph<T> &g) {    int n = g.n;    queue<int> q;    vi d = outdegree(g);    vi res(n, 1);    rep(i, n) {        if (d[i] == 0) {            q += i;            res[i] = 0;        }    }    auto rg = rev(g);    while (q.size()) {        auto now = q.front();        q.pop();        forg(gi, rg[now]) {            if (--d[t] == 0) {                q += t;                res[t] = 0;            }        }    }    return res;}\n\n//@アルゴリズム\ntemplate<class T> int krus(undigraph<T> &g) {    int res = 0;    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res += e.c; }}    return res;}\ntemplate<class T> vector<edge<T>> krus_ed(undigraph<T> &g) {    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    vector<edge<T>> res;    fora(e, E) { if (uf.unite(e.f, e.t)) { res.push_back(e); }}    return res;}\ntemplate<class T> tree<T> krus_tr(undigraph<T> &g) {    tree<T> res(g.n);    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res.add(e.f, e.t); }}    return res;}\ntemplate<class T> int krus(const vector<edge<T>> &g) {int n=0;    fora(e,g){chma(n,max(e.f,e.t)+1);};    int res = 0;    unionfind uf(n);    auto E = g;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res += e.c; }}    return res;}\ntemplate<class T> vector<edge<T>> krus_ed(const vector<edge<T>> &g) {    int n=0;    fora(e,g){chma(n,max(e.f,e.t)+1);};    vector<edge<T>> res;    unionfind uf(n);    auto E = g;    sort(E);    fora(e, E) { if (uf.unite(e.f, e.t)) { res += e; }}    return res;};\ntemplate<class T> vi krus_i(const vector<edge<T>> &g) {    int n=0;    fora(e,g){chma(n,max(e.f,e.t)+1);};    vi res;    unionfind uf(n);    auto E = g;    sort(E);    int i = 0;    fora(e, E) {        if (uf.unite(e.f, e.t)) { res += i; }        i++;    }    return res;}\n//@実験\ndigraph<> rang_di(int n, int m, bool zibun = 0, bool taju = 0) {    umapp was;    digraph<> g(n);    was[mp(-1, -2)] = 1;    while (m) {        int f = -1, t = -2;        while (f < 0 || (!taju && was[mp(f, t)])) {            f = rand(0, n - 1);            t = rand(0, n - 1);            if (!zibun && f == t)f = -1;        }        g.add(f, t);        was[mp(f, t)] = 1;        m--;    }    return g;}\ndigraph<> perfect_di(int n, bool zibun = 0) {    digraph<> g(n);    rep(i, n) {        rep(j, n) {            if (!zibun && i == j)con;            g.add(i, j);        }    }    return g;}\nundigraph<> rang_un(int n, int m, bool zibun = 0, bool taju = 0) {    umapp was;    undigraph<> g(n);    was[mp(-1, -2)] = 1;    while (m) {        int f = -1, t = -2;        while (f < 0 || (!taju && was[mp(min(f, t), max(f, t))])) {            f = rand(0, n - 1);            t = rand(0, n - 1);            if (!zibun && f == t)f = -1;        }        g.add(f, t);        was[mp(min(f, t), max(f, t))] = 1;        m--;    }    return g;}\nundigraph<> perfect_un(int n, bool zibun = 0){    undigraph<> g(n);    rep(i, n) {        rep(j, i, n) {            if (!zibun && i == j)con;            g.add(i, j);        }    }    return g;}\n/*頂点数がkの木を一つ返す サイズが0の木が帰ったら終了*/\ntree<int> next_tree(int k) {    assert(2 <= k && k < 11);    static str name;    static ifstream ina;    static int rem;    static vp edges;    static int pk = -1;/*前回見たk*/    if (pk != k) {        if (~pk)ina.close();        edges.clear();        pk = k;        name = (k == 6) ? \"C:\\\\Users\\\\kaout\\\\Desktop\\\\trees_sizek\\\\nazeka6.txt\" : \"C:\\\\Users\\\\kaout\\\\Desktop\\\\trees_sizek\\\\tree_size\" + tos(k) + \".txt\";        ina = ifstream(name);        rem = pow(k, k - 2);/*Cayleyの定理*/        rep(i, k)rep(j, i + 1, k)edges.emplace_back(i, j);        pk = k;    }    tree<int> g(k);    if (rem == 0) {        g.resize(0);        return g;    }    int m;    ina >> m;    while (m) {        int lb = lbit(m);        int id = log2(lb);        g.add(edges[id].first, edges[id].second);        m ^= lb;    }    rem--;    return g;}\nundigraph<int> next_undi(int k) {    assert(2 <= k && k < 9);    static str name;    static ifstream ina;    static int rem;    static vp edges;    static vi lims = {-1, -1, 1, 4, 38, 728, 26704, 1866256};    static int pk = -1;/*前回見たk*/    if (pk != k) {        if (~pk)ina.close();        edges.clear();        pk = k;        name = (k == 6) ? \"C:\\\\Users\\\\kaout\\\\Desktop\\\\undi_sizek\\\\roku.txt\" : \"C:\\\\Users\\\\kaout\\\\Desktop\\\\undi_sizek\\\\undi_size\" + tos(k) + \".txt\";        ina = ifstream(name);        rem = lims[k];        rep(i, k)rep(j, i + 1, k)edges.emplace_back(i, j);        pk = k;    }    undigraph<int> g(k);    if (rem == 0) {        g.resize(0);        return g;    }    int m;    ina >> m;    while (m) {        int lb = lbit(m);        int id = log2(lb);        g.add(edges[id].first, edges[id].second);        m ^= lb;    }    rem--;    return g;}\nvector<tree<int>> trees(int k) {    vector<tree<int>> res;    while (1) {        tree<int> g = next_tree(k);        if (sz(g) == 0)break;        res.push_back(g);    }    return res;}\nvector<undigraph<int>> undis(int k) {    vector<undigraph<int>> res;    while (1) {        undigraph<int> g = next_undi(k);        if (sz(g) == 0)break;        res.push_back(g);    }    return res;}\ntemplate<class T> vector<vector<int>> table(graph<T> &g,int init_value) {    vvi(res, g.n, g.n,init_value);    rep(i, g.n) { forg(gi, g[i]) { res[i][t] = c; }}    return res;}\n//type,idが使いたい場合はgraty\n/*@formatter:on*/\n\nvoid solve(){\n    in(N);\n    tree<> g(2 * k5);;\n    g.ing(N,N-1);\n    vi v(N);\n    fix([&](auto ds, int p, int i) -> int {\n        fort(gi, g[i]){\n            v[i]^=ds(i,t)+1;\n        }\n        return v[i];\n    })(-1, 0);\n    deb(v);\n    if(v[0]){\n        out(\"Alice\");\n    }else{\n        out(\"Bob\");\n    }\n\n}\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    if (cur.empty()) return 0;\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 0;\n    } else {\n        for (auto t : sons) {\n            gr[cur] ^= gr[t];\n        }\n        if (sons.size() == 1) {\n            gr[cur]++;\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    for (int i = 0; i < n; i++) {\n        cerr << i + 1 << ' ' << gr[i] << endl;\n    }\n    if (gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5+1;\nvector<int> g[maxn];\nint n;\nint sg[maxn];\nvoid dfs(int cur, int p)\n{\n    sg[cur] = 0;\n    for (int i = 0; i < g[cur].size(); ++i)\n    {\n        int nxt = g[cur][i];\n        if (nxt != p)\n        {\n            dfs(nxt, cur);\n            sg[cur] ^= (1+sg[nxt]);\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n-1; ++i)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1, 0);\n    puts(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "//marico el que lo lea\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\nusing namespace std;\n\n#define FOR(i,f,t) for(int i=f; i<(int)t; i++)\n#define FORR(i,f,t) for(int i=f; i>(int)t; i--)\n#define pb push_back\n#define ms(obj, val) memset(obj, val, sizeof(obj))\n#define ms2(obj, val, sz) memset(obj, val, sizeof(obj[0])*sz)\n#define ri(x) scanf(\"%d\",&x)\n#define rl(x) scanf(\"%lld\",&x)\n#define rii(x,y) ri(x), ri(y)\n#define rll(x,y) rl(x), rl(y)\n\n#define fst first\n#define snd second\n#define dprintf debug && printf\n#define debug false\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> ii;\n\nconst int MAXN = 1e5+5;\nint N;\nvi G[MAXN], T[MAXN];\nint f[MAXN];\n\nvoid make_T(int v, int p){\n\tFOR(i,0,G[v].size()){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tT[v].pb(u);\n\t\tmake_T(u,v);\n\t}\n}\n\nvoid solve(int v){\n\tFOR(i,0,T[v].size()) solve(T[v][i]);\n\tif(T[v].size()==0) return;\n\telse{\n\t\tf[v] = f[T[v][0]]+1;\n\t\tFOR(i,1,T[v].size()) f[v] ^= (f[T[v][i]]+1);\n\t}\n}\n\nint main(){\n\tri(N);\n\tFOR(i,0,N-1){\n\t\tint v, u; rii(v,u); v--; u--;\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tmake_T(0,-1);\n\tsolve(0);\n\tprintf(f[0]?\"Alice\\n\":\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\nusing namespace std;\nusing ll = long long;\n\n\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nclass UnionFind {\npublic:\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvector<bool> b;\n\nvoid dfs(vector<vector<int>>&z,vector<int>&ans,int v){\n    b[v] = true;\n    int x = 0;\n    for (auto next_v : z[v]) {\n        if (b[next_v]) continue;\n        dfs(z,ans,next_v);\n        x = x ^ (ans.at(next_v) + 1);\n    }\n    ans.at(v) = x;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>>z(n);\n    for (int i = 0; i < n-1; i++) {\n        ll a, b;\n        cin >> a >> b;\n        z.at(a-1).push_back(b-1);\n        z.at(b-1).push_back(a-1);\n    }\n    vector<int>ans(n);\n    b.assign(n, false);\n    dfs(z, ans, 0);\n    if (ans.at(0) == 0)cout << \"Bob\" << endl;\n    else cout << \"Alice\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\nusing namespace std;\nstruct node\n{\n\tint to;\n\tnode *nxt;\n}edges[MAXN*2+5];\nnode *ncnt=&edges[0],*Adj[MAXN+5];\nint N;\nvoid AddEdge(int u,int v)\n{\n\tnode *p=++ncnt;\n\tp->to=v;\n\tp->nxt=Adj[u];\n\tAdj[u]=p;\n\t\n\tnode *q=++ncnt;\n\tq->to=u;\n\tq->nxt=Adj[v];\n\tAdj[v]=q;\n}\nint DFS(int u,int fa)\n{\n\tint ret=0;\n\tfor(node *p=Adj[u];p!=NULL;p=p->nxt)\n\t{\n\t\tint v=p->to;\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tret^=(DFS(v,u)+1);\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tint u,v;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tAddEdge(u,v);\n\t}\n\tif(DFS(1,-1)==0)\n\t\tprintf(\"Bob\\n\");\n\telse\n\t\tprintf(\"Alice\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7; bool fl[N];\nint n,ans,fa[N],len[N],val[N],cnt[N]; vector<int>v[N];\ninline int read(){\n\tint num=0; char g=getchar(); while(g<48||57<g) g=getchar();\n\twhile(47<g&&g<58) num=(num<<1)+(num<<3)+g-48,g=getchar(); return num;\n}\ninline void find(int u){\n\tfl[u]=1;\n\tfor(int i=0;i<len[u];i++){\n\t\tint x=v[u][i]; if(fl[x]) continue; fa[x]=u,find(x);\n\t}\n\tfor(int i=0;i<len[u];i++){\n\t\tint x=v[u][i]; if(x==fa[u]) continue; cnt[val[x]]++;\n\t}\n\tfor(int i=2;i<=n;i++) if(!cnt[i]) {val[u]=i; break;}\n\tfor(int i=0;i<len[u];i++){\n\t\tint x=v[u][i]; if(x==fa[u]) continue; cnt[val[x]]--;\n\t}\n}\nint main(){\n\tn=read(); int u,t;\n\tfor(int i=1;i<n;i++) u=read(),t=read(),v[u].push_back(t),v[t].push_back(u),len[u]++,len[t]++; find(1);\n\tfor(int i=0;i<len[1];i++) ans^=val[v[1][i]]; if(!ans) puts(\"Bob\"); else puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\ndouble pi=2*acos(0);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nint main(){\n  int n;cin>>n;\n  vector<int> v[n+1];\n  rep(i,0,n-1){\n    int a,b;cin>>a>>b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  queue<int> q;\n  int par[n+1];\n  par[1]=-1;\n  q.push(1);\n  bool used[n+1];\n  fill(used,used+n+1,false);\n  while(q.size()>0){\n    int now=q.front();q.pop();\n    rep(i,0,v[now].size()){\n      int ne=v[now][i];\n      if(par[now]==ne)continue;\n      par[ne]=now;\n      used[now]=true;\n      q.push(ne);\n    }\n  }\n  rep(i,1,n+1){\n    if(used[i]==false)q.push(i);\n  }\n  int d[n+1];\n  int cnt[n+1];\n  fill(cnt,cnt+n+1,0);\n  v[1].push_back(-1);\n  while(q.size()>0){\n    int now=q.front();q.pop();\n    int u=0;\n    rep(i,0,v[now].size()){\n      int ne=v[now][i];\n      if(par[now]==ne)continue;\n      u^=d[ne];\n    }\n    if(u==0)d[now]=1;\n    else d[now]=2;\n    if(now==1)break;\n    int p=par[now];\n    cnt[p]++;\n    if(cnt[p]==v[p].size()-1)q.push(p);\n  }\n  if(d[1]==0)cout<<\"Bob\"<<endl;\n  else cout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << endl;}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << endl;\n}\n#define INT_MAX 1<<30\nconst ll mod = 1e9+7;\n\nvvl G;\nbool visit[100005];\n\nll dfs(ll u){\n\tll res = 0;\n\tvisit[u] = true;\n\tfor(auto v : G[u]){\n\t\tif(visit[v]) continue;\n\t\tres ^= dfs(v) + 1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tll n; cin >> n;\n\tG.resize(n);\n\trep(i,n-1){\n\t\tll a,b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tll ans = dfs(0);\n\tif(ans) puts(\"Alice\");\n\telse puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) ((int) (x).size())\n\nconst int N = 123456;\n\nint n;\nvector<int> e[N];\n\nint grundy(int u, int p = -1) {\n    int deg = 0;\n    for (int v: e[u]) {\n        if (v == p) continue;\n        deg++;\n    }\n\n    int g = 0;\n    for (int v: e[u]) {\n        if (v == p) continue;\n        if (deg == 1) {\n            return grundy(v, u) + 1;\n        } else {\n            g ^= grundy(v, u);\n        }\n    }\n    return g;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n-1; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n\n    int g = grundy(1);\n    puts(g ? \"Alice\" : \"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x,int y) {if (x<y) x=y;}\nvoid qmin(int &x,int y) {if (x>y) x=y;}\ninline int read()\n{\n\tchar s;\n\tint k=0,base=1;\n\twhile((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));\n\tif(s==EOF)exit(0);\n\tif(s=='-')base=-1,s=getchar();\n\twhile(isdigit(s)){k=k*10+(s^'0');s=getchar();}\n\treturn k*base;\n}\ninline void write(int x)\n{\n\tstatic char cnt,num[15];cnt=0;\n\tif (!x)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor (;x;x/=10) num[++cnt]=x%10;\n\tfor (;cnt;putchar(num[cnt--]+48));\n}\nconst int maxn=100000;\nint n,id,X,Y;\nint to[maxn<<1],ne[maxn<<1],po[maxn];\nint sg[maxn];\nvoid add(int x,int y)\n{\n\tid++;\n\tto[id]=y;ne[id]=po[x];po[x]=id;\n}\nvoid dfs(int x,int fa)\n{\n\tfor (int i=po[x];i;i=ne[i])\n\t{\n\t\tif (to[i]!=fa) \n\t\t{\n\t\t\tdfs(to[i],x);\n\t\t\tsg[x]^=(sg[to[i]]+1);\n\t\t}\n\t}\n}\nint main()\n{\n#ifdef ylx\n\tfreopen(\"agc017d.in\",\"r\",stdin);\n\tfreopen(\"agc017d.out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tX=read();Y=read();\n\t\tadd(X,Y);\n\t\tadd(Y,X);\n\t}\n\tdfs(1,-1);\n\tif (sg[1])\n\t{\n\t\tprintf(\"Alice\");\n\t} else printf(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define FOR(i,c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define F first\n#define S second\nusing namespace std;\n\nconst LL mod = 1e9 + 7;\n\ntemplate<typename T> T gcd(T a, T b) { return b == 0?a: gcd(b, a % b); }\ntemplate<typename T> T LCM(T a, T b) { return a*(b/gcd(a, b)); }\ntemplate<typename T> T expo(T base, T e, T mod) { T res = 1;\n  while(e > 0) { if(e&1) res = res * base % mod; base = base * base % mod; e >>= 1; }\n  return res;\n}\ntemplate<typename T, typename S> T expo(T b, S e){if(e <= 1)return e == 0?1: b;\\\n\treturn (e&1) == 0?expo((b*b), e>>1): (b*expo((b*b), e>>1));}\ntemplate<typename T, typename S> T modinv(T a, S mod) { return expo(a, mod-2, mod); }\ntemplate<class T, class S> std::ostream& operator<<(std::ostream &os, const std::pair<T, S> &t) {\n\tos<<\"(\"<<t.first<<\", \"<<t.second<<\")\";\n\treturn os;\n}\ntemplate<class T> std::ostream& operator<<(std::ostream &os, const std::vector<T> &t) {\n\tos<<\"[\"; FOR(it,t) { if(it != t.begin()) os<<\", \"; os<<*it; } os<<\"]\";\n\treturn os;\n}\n\nconst int MAXN = 1e5 + 100;\n\nint n;\nvector<int> adj[MAXN];\nLL g[MAXN];\n\nvoid go(int r, int p) {\n\tg[r] = 0;\n\tint cnt = 0;\n\tfor(auto &elem: adj[r]) {\n\t\tif(elem != p) {\n\t\t\tgo(elem, r);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt == 0) {\n\t\tg[r] = 0;\n\t} else if(cnt == 1) {\n\t\tfor(auto &elem: adj[r]) {\n\t\t\tif(elem != p) {\n\t\t\t\tg[r] = g[elem] + 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(auto &elem: adj[r]) {\n\t\t\tif(elem != p) {\n\t\t\t\tg[r] = g[r] ^ g[elem];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\tint a, b;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(b); adj[b].push_back(a);\n\t}\n\tgo(1, 0);\n\tif(g[1] > 0) cout << \"Alice\" << endl;\n\telse cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint mex[101010];\n\n\nint dfs(int cur,int pre) {\n\t\n\tFORR(e,E[cur]) if(e!=pre) mex[cur]^=dfs(e,cur)+1;\n\treturn mex[cur];\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tif(dfs(0,-1)) cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nvector<vector<int>> G;\nvector<int> grundy;\n\nvoid dfs(int cur = 0, int par = -1){\n    int sz = 0;\n    int vv = -1;\n//    cout << cur << \",\" << par << endl;\n    rep(i, G[cur].size()){\n        if(G[cur][i] != par){\n            vv = i;\n            sz++;\n        }\n    }\n    if(sz == 1){\n        dfs(G[cur][vv], cur);\n        grundy[cur] = grundy[G[cur][vv]] + 1;\n    }\n    else{\n        for(int v: G[cur]){\n            if(v == par) continue;\n            dfs(v, cur);\n            grundy[cur] ^= grundy[v];\n        }\n    }\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    int N;\n    cin >> N;\n    G.resize(N);\n    grundy.resize(N);\n    rep(i, N - 1){\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    dfs();\n    output(grundy[0] ? \"Alice\" : \"Bob\");\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nvector<vector<int> > G, T;\n\nvoid build(int a, int p) {\n\tfor (int i = 0;i < G[a].size();i++) {\n\t\tif (G[a][i] == p) continue;\n\t\tT[a].push_back(G[a][i]);\n\t\tbuild(G[a][i], a);\n\t}\n\treturn;\n}\n\nint cal(int x) {\n\tint nim = 0;\n\tfor (int i = 0;i < T[x].size();i++) nim ^= cal(T[x][i]);\n\tnim++;\n    return nim;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    G.resize(N);\n    T.resize(N);\n    for (int i = 1;i < N;i++) {\n    \tint a, b;\n    \tcin >> a >> b;\n    \ta--;\n    \tb--;\n    \tG[a].push_back(b);\n    \tG[b].push_back(a);\n    }\n    build(0, -1);\n    int nim = 0;\n    for (int i = 0;i < T[0].size();i++) {\n    \tnim ^= cal(T[0][i]);\n    }\n    if (nim) cout << \"Alice\" << endl;\n    else cout << \"Bob\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 200020\n\nusing namespace std;\n\nstruct EDGE {\n\tint adj, next;\n} edge[N * 2];\n\nint n, gh[N], sg[N], top;\n\nvoid addedge(int x, int y) {\n\tedge[++top].adj = y;\n\tedge[top].next = gh[x];\n\tgh[x] = top;\n}\n\nvoid dfs(int x, int root = 0) {\n\tsg[x] = 0;\n\tfor (int p = gh[x]; p; p = edge[p].next)\n\t\tif (edge[p].adj != root) {\n\t\t\tdfs(edge[p].adj, x);\n\t\t\tsg[x] ^= sg[edge[p].adj];\n\t\t}\n\tsg[x] += 1;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\taddedge(x, y);\n\t\taddedge(y, x);\n\t}\n\tdfs(1);\n\tputs(sg[1] != 1 ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\nusing ll = long long;\n\nvector< vector<int> > tree;\n\nint grundy(int x, int prev) {\n    int g = 0;\n    for (int v : tree[x]) {\n        if (v != prev)\n            g ^= grundy(v, x);\n    }\n    return g + 1;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        --v1;\n        --v2;\n        tree[v1].push_back(v2);\n        tree[v2].push_back(v1);\n    }\n\n    printf(grundy(0, -1) == 0 ? \"Bob\\n\" : \"Alice\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\nconst int mx=1e5+10;\nint f[mx];\nvector<int>g[mx];\nvoid dfs(int u,int pu=0){\n  f[u]=0;\n  for(int v:g[u])if(v!=pu){\n    dfs(v,u);\n    f[u]^=f[v];\n  }\n  f[u]++;\n}\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n-1;i++){\n    int u,v;\n    scanf(\"%d %d\",&u,&v);\n    g[--u].push_back(--v);\n    g[v].push_back(u);\n  }\n  dfs(0);\n  int x=0;\n  for(int v:g[0])x^=f[v];\n  if(x==0)puts(\"Bob\");\n  else puts(\"Alice\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define rt return 0;\n#define elif else if\n#define len(v) ((int)v.size())\n\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(\" \");\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(\"\\n\");\n\t\tfast_print(v[i]);\n\t}\n}\n\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a % b == 0) return 0;\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\nint n;\nvector<vector<int>> vertices;\n\nint calc(int v, int _p) {\n\tint rez = 0;\n\tfor (int subv : vertices[v]) {\n\t\tif (subv == _p) continue;\n\t\trez ^= calc(subv, v);\n\t}\n\treturn rez + 1;\n}\n\nint calc() {\n\tint rez = 0;\n\tfor (int subv : vertices[0]) {\n\t\trez ^= calc(subv, 0);\n\t}\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tvertices.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tscan a, b;\n\t\ta--;b--;\n\t\tvertices[a].pb(b);\n\t\tvertices[b].pb(a);\n\t}\n\n\tif (calc()) {\n\t\tprint \"Alice\";\n\t} else {\n\t\tprint \"Bob\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn=100000+5;\nint h[maxn],mem;\nstruct\n{\n    int v,next;\n}e[maxn<<1];\nvoid add(int u,int v)\n{\n    e[mem].v=v;\n    e[mem].next=h[u];\n    h[u]=mem++;\n}\nint sg[maxn];\nvoid dfs(int u,int fa)\n{\n    sg[u]=0;\n    for(int i=h[u];i+1;i=e[i].next)\n    {\n        int v=e[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n        sg[u]^=(sg[v]+1);\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\",&n);\n    memset(h,-1,sizeof(h));mem=0;\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);add(y,x);\n    }\n    dfs(1,1);\n    int ans=0;\n    for(int i=h[1];i+1;i=e[i].next)\n    {\n        int v=e[i].v;\n        ans^=sg[v];\n    }\n    printf(\"%s\\n\",ans!=0?\"Alice\":\"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i = a; i < b; i++)\n#define S(x) scanf(\"%d\",&x)\n#define S2(x,y) scanf(\"%d%d\",&x,&y)\n#define P(x) printf(\"%d\\n\",x)\n#define all(v) v.begin(),v.end()\n#define FF first\n#define SS second\n#define pb push_back\n#define mp make_pair\n\ntypedef long long int LL;\ntypedef pair<int, int > pii;\ntypedef vector<int > vi;\n\nconst int N = 100001;\n\nvi g[N];\nint G[N];\n\nint dfs(int c, int p) {\n  rep(i,0,g[c].size()) {\n    int u = g[c][i];\n    if(u != p) {\n      G[c] ^= 1 + dfs(u, c);\n    }\n  }\n  return G[c];\n}\n\nint main() {\n  int n;\n  S(n);\n  rep(i,0,n-1) {\n    int u,v;\n    S2(u,v);\n    g[u].pb(v);\n    g[v].pb(u);\n  }\n  int x = dfs(1, -1);\n  if(x) {\n    printf(\"Alice\\n\");\n  } else {\n    printf(\"Bob\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nvector<vector<int>> edges;\n\nint dfs(int i,int p = -1) {\n    int g = 0;\n    for (int& j : edges[i]) if (j != p) {\n        g ^= dfs(j,i)+1;\n    }\n    return g;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    edges.resize(n);\n    for (int i = 0;i < n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n    cout << (dfs(0) ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define debugv(v) {printf(\"L%d %s => \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debugm(m) {printf(\"L%d %s is..\\n\",__LINE__,#m);for(auto v:m){for(auto e:v){cout<<e<<\" \";}cout<<endl;}}\n#define debuga(m,w) {printf(\"L%d %s is => \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,w,h) {printf(\"L%d %s is..\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[x][y]<<\" \";}cout<<endl;}}\n#define debugaar(m,w,h) {printf(\"L%d %s is..\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(l) for(auto cnt=0;cnt<(l);++cnt)\n#define iterate(b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2>\nostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\n\nmt19937 mt(8901016);\ninline int rand_int(int l, int h) {\n    return uniform_int_distribution<>(l, h)(mt);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiablechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiablechar(cc); cc = getchar_unlocked());\n            for (; isvisiablechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\n\n// 隣接頂点を保持する無向グラフ\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\n// ll n, aa, bb, cc, dd;\n\nint n;\nGraph graph(1);\n\nll dfs(int idx = 0, int from = -1, int depth = 1) {\n    ll deg = graph.vertex_to[idx].size();\n    if (deg == 1) return 1;\n\n    ll nim = depth-1;\n    for (int to : graph.vertex_to[idx]) {\n        if (to == from) continue;\n        nim ^= dfs(to, idx, depth+1);\n    }\n    return nim;\n}\n\nint main() {\n\n    \n    scanner >> n;\n    graph.resize(n);\n    repeat(n-1) {\n        int a, b;\n        scanner >> a >> b;\n        graph.connect(a - 1, b - 1);\n    }\n    \n    \n    ll nim = dfs();\n    //cout << nim << endl;\n    \n    if ( nim == 0){\n        cout << \"Bob\" << endl;\n    }else{\n        cout << \"Alice\" << endl;\n    }\n\n    /*\n    scanner >> n >> aa >> bb >> cc >> dd;\n\n    if (dd == 0) {\n        if (aa == bb)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n        return 0;\n    }\n\n    ll dist = bb - aa;\n\n    ll nh = dist / dd;\n    ll nl = dist / cc;\n\n    if (dist%dd == 0 && dist / dd <= n && (n - dist / dd) % 2 == 0) {\n        cout << \"YES\" << endl;\n        return 0;\n    }\n\n    if (dist / dd > n) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    ll tc = (dist + dd - 1) / dd;\n    if (tc % 2 == n % 2) {\n        if (tc*dd-(n*(dd-cc)) <= dist && dist <= tc*dd) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    else {\n        if ((tc+1)*dd - (n*(dd - cc)) <= dist && dist <= (tc + 1)*dd) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    cout << \"NO\" << endl;\n    */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb emplace_back\n#define fi first\n#define se second\n#define mp make_pair\n#define SZ(x) ((int)(x.size()))\n#define FOI(i,a,n) for(int (i)=int(a);(i)<=int(n);++(i))\n#define FOD(i,a,n) for(int (i)=int(a);(i)>=int(n);--(i))\n#define IN(x,y) ((y).find((x))!=(y).end())\n#define ALL(t) t.begin(),t.end()\n#define MSET(tabl,i) memset(tabl, i, sizeof(tabl))\n#define PSET(x,y) fixed<<setprecision(y)<<lf(x)\n#define DBG(c) cout<<#c<<\" = \"<<c<<endl;\n#define RTIME ((double)clock()/(double)CLOCKS_PER_SEC)\n\ntemplate<typename T,typename S>inline bool REMIN(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool REMAX(T&a,const S&b){return a<b?a=b,1:0;}\n\ntypedef long long ll;\ntypedef long double lf;\ntypedef pair<int, int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint bit(ll x, int pos){ return (x >> pos) & 1; }\nll power(ll base, ll exp, ll c = 1e9 + 7) { if(!exp) return 1; ll r = power(base, exp >> 1, c); r=(r*r)%c; if(exp&1) r=(r*base)%c; return r; }\n\nll T,N,M,K;  \nint a,b,c;\nstring s1,s2;\n\nconst lf PI = 2*acos(0);\nconst ll INF = 1e9 + 4;\nconst int NMAX = 3e5+5;\nconst ll MOD = 1000000007;\n\nvi eds[NMAX];\n\nint dfs(int cur, int par, int tillnow = 1) {\n\tif(SZ(eds[cur]) == 1) return tillnow;\n\tif(SZ(eds[cur]) == 2) {\n\t\tfor(int v : eds[cur]) if(v != par) return dfs(v, cur, tillnow + 1);\n\t}\n\tint ret = 0;\n\tfor(int v : eds[cur]) if(v != par) ret ^= dfs(v, cur, 1);\n\treturn ret + tillnow;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tcin >> N;\n\tFOI(i, 1, N - 1) {\n\t\tcin >> a >> b;\n\t\teds[a].pb(b);\n\t\teds[b].pb(a);\n\t}\n\n\tint ans = 0;\n\tfor(int x : eds[1]) {\n\t\tans ^= dfs(x, 1);\n\t}\n\n\tcout << (ans ? \"Alice\" : \"Bob\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,cnt,last[N],sg[N];\nstruct edge{int to,next;}e[N*2];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid addedge(int u,int v)\n{\n\te[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;\n\te[++cnt].to=u;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x,int fa)\n{\n\tfor (int i=last[x];i;i=e[i].next)\n\t{\n\t\tif (e[i].to==fa) continue;\n\t\tdfs(e[i].to,x);\n\t\tsg[x]^=sg[e[i].to]+1;\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y);\n\t}\n\tdfs(1,0);\n\tif (sg[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define ll long long\n#define INF 1000000000\n#define clr(x) memset(x,0,sizeof(x))\nusing namespace std;\n\ninline int read()\n{\n\tregister int ret=0,c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile(isdigit(c))ret=ret*10+c-'0',c=getchar();\n\treturn ret;\n}\n\n#define M 100005\n\nint n,fa[M],sg[M];\nint first[M],next[M<<1],to[M<<1],t;\n\nvoid addedge(int s,int v)\n{\n\tnext[++t]=first[s];\n\tfirst[s]=t;\n\tto[t]=v;\n}\n\nvoid dfs(int x)\n{\n\tfor(int i=first[x];i;i=next[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa[x])continue;\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t\tsg[x]^=sg[v]+1;\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(1);\n\tif(sg[1]==0)puts(\"Bob\");\n\telse puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n \nint N;\nvector<int> E[101010];\n//---------------------------------------------------------------------------------------------------\nint cnt[101010];\nint dfs(int cu, int pa = -1) {\n    cnt[cu] = 1;\n    int g = 0;\n    for (int to : E[cu]) if (to != pa) {\n        g ^= dfs(to, cu);\n        cnt[cu] += cnt[to];\n    }\n\n    if (cnt[cu] == 1) return 1;\n    else return g + 1;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        rep(i, 0, N + 1) E[i].clear();\n\n        rep(i, 0, N - 1) {\n            int a, b; cin >> a >> b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        int g = 0;\n        for (int to : E[1]) g ^= dfs(to, 1);\n\n        if (g == 0) printf(\"Bob\\n\");\n        else printf(\"Alice\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nconst int N=1e5+5;\nvector<int>lk[N];\nint sg[N];\n\nvoid dfs(int x,int fr)\n{\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tdfs(y,x);\n\t\tsg[x]^=sg[y]+1;\n\t}\n}\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint n;\n\tcin>>n;\n\trep(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlk[x].push_back(y);\n\t\tlk[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nconst int M = 1e9 + 7;\nconst ll MLL = 1e18L + 9;\n#pragma unused(M)\n#pragma unused(MLL)\n#ifdef LOCAL\n#include\"rprint.hpp\"\n#else\ntemplate <ostream& out = cout, class... T> void prints(T&&...){ }\ntemplate <ostream& out = cout, class... T> void printd(T&&...){ }\ntemplate <ostream& out = cout, class... T> void printb(T&&...){ }\ntemplate <ostream& out = cout, class... T> void printArr(T&&...){ }\n#endif\n\nstruct Node{\n    vector<Node*> dests;\n    void add(Node* n){\n        dests.push_back(n);\n    }\n    void add2(Node* n){\n        add(n);\n        n->add(this);\n    }\n    bool dfs(Node* from = nullptr, bool b = true){\n        int num = 0;\n        int n1 = 0, n2 = 0;\n        for(Node* d : dests){\n            if(d == from){ continue; }\n            if(d -> dfs(this, !b)){\n                n1++;\n            }else{\n                n2++;\n            }\n        }\n        // printd(n1, n2);\n        return (n1 & 1) || (n2 & 1);\n        // return (n1 == 0 && (n2 & 1)) || (n1 == 1) || (n1 == 2 && n2 & 1);\n        // return ((n1 & 1) ^ (n2 & 1));\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<Node> nodes(n);\n    for(int i = 0; i < n - 1; i++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        nodes[x].add2(&nodes[y]);\n    }\n    cout << (nodes[0].dfs() ? \"Alice\" : \"Bob\") << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#define N 100005\nusing namespace std;\nvector<int> G[N];\nint n,f[N];\nvoid dfs(int t,int fa)\n{\n\tint i;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(G[t][i]!=fa)\n\t\t\tdfs(G[t][i],t),f[t]^=(f[G[t][i]]+1);\n}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t  }\n\tdfs(1,0);\n\tprintf(f[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  //dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(v[i].size()==1){\n      ans++;\n    }\n  }\n\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\nstruct yuansu\n{\n    int x,y;\n}bian[500005];\nint cmp (yuansu a,yuansu b)\n{\n    return a.x<b.x;\n}\nint sum[500005],n,x,y,cnt;\nint dfs(int dian,int fa)\n{\n    if(sum[dian]==sum[dian-1]+1)\n    {\n        return 1;\n    }\n    int ans(0);\n    for(int i=sum[dian-1]+1;i<=sum[dian];i++)\n    {\n        if(bian[i].y==fa)\n        {\n            ans^=dfs(bian[i].y,dian)+1;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    cin>>n;\nfor(int i=1;i<n;i++)\n{\n    cin>>x>>y;\n    bian[++cnt].x=x;\n    bian[cnt].y=y;\n    bian[++cnt].x=y;\n    bian[cnt].y=x;\n}\nsort(bian+1,bian+cnt+1,cmp);\nfor(int i=1;i<=cnt;i++)\n{\n    if(bian[i].x!=bian[i+1].x)\n    {\n        sum[bian[i].x]=i;\n    }\n}\nif(dfs(1,0))cout<<\"Alice\";\nelse cout<<\"Bob\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define per(i,n) for ((i)=n;(i)>=(1);(i)--)\nusing namespace std;\nint n,i,sg[200005];\nvector<int> adj[200005];\nvoid dfs(int x,int fa)\n{\n\tint i;\n\tfor(i=0;i<adj[x].size();i++)if(adj[x][i]!=fa)\n\t{\n\t\tdfs(adj[x][i],x);\n\t\tsg[x]^=(sg[adj[x][i]]+1);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\trep(i,n-1)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tif(sg[1]) puts(\"Alice\");else puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint dp[111111];\nvi adj[111111];\n\nvoid dfs(int u, int p)\n{\n\tint xr=0;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t\txr^=(dp[v]+1);\n\t}\n\tdp[u]=xr;\n}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tdfs(0,-1);\n\tcout<<(dp[0]>0?\"Alice\":\"Bob\")<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: test.cpp\n    > Author: Akira \n    > Mail: qaq.febr2.qaq@gmail.com \n ************************************************************************/\n\n#include<bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*4\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1E9+7;\nconst double eps = 1e-6;\n#define bug cout<<88888888<<endl;\n#define debug(x) cout << #x\" = \" << x << endl;\ntemplate<typename T> T abs(T val){return val>0?val:-val;}\nint N;\nstruct Edge\n{\n    int v,next;\n}edge[MaxM];\nint cont,head[MaxN];\nvoid add(int u, int v)\n{\n    edge[cont].v = v, edge[cont].next = head[u], head[u] = cont++;\n}\n\nint DFS(int u, int pre)\n{\n    bool flag = 0;\n    for(int i=head[u];i!=-1;i=edge[i].next)\n    {\n        int v = edge[i].v;\n        if(v==pre) continue;\n        flag ^= DFS(v,u);\n    }\n    return flag+1;\n}\nvoid solve()\n{\n    if(DFS(1,0)!=1) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n\nvoid init()\n{\n    cont = 0;\n    MST(head,-1);\n}\nint main()\n{\n    //std::ios::sync_with_stdio(false);\n    while(scanf(\"%d\", &N)!=EOF)\n    {\n        init();\n        int a,b;\n        for(int i=1;i<N;i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            add(a,b);add(b,a);\n        }\n        solve();\n    }\n    //system(\"pause\");\n    //printf(\"%lld\\n\", (x%mod+mod)%mod );\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint n;\nvector<vector<int>> g;\n\nint dfs(int v, int p) {\n    int res = 0;\n    for(int nv: g[v]) {\n        if(nv == p) continue;\n        res ^= (dfs(nv, v) + 1);\n    }\n    return res;\n}\n\nvoid solve() {\n\tcin >> n;\n    g.assign(n, vector<int>());\n    rep(i, n - 1) {\n        int u, v; cin >> u >> v;\n        -- u, -- v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int tot = dfs(0, -1);\n    if(tot == 0) {\n        cout << \"Bob\" << endl;\n    } else {\n        cout << \"Alice\" << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep3(i,m,n) for(int (i)=m;(i)<=(n);(i)++)\n#define rep3rev(i,m,n) for(int (i)=m;(i)>=(n);(i)--)\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing P = pair<int, int>;\n\nint n;\nvvi to;\nvi grn;\n\nvoid dfs(int v = 0, int p = -1){\n    for(auto u : to[v]){\n        if(u == p) continue;\n        dfs(u, v);\n        grn[v] ^= (grn[u] + 1);\n    }\n}\n\nvoid Main(){\n    cin >> n;\n    to.resize(n); grn.resize(n, 0);\n    rep(i, n-1){\n        int x, y; cin >> x >> y; x--; y--;\n        to[x].pb(y);\n        to[y].pb(x);\n    }\n    dfs();\n    cout << (grn[0] == 0 ? \"Bob\" : \"Alice\") << endl;\n    return;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst llint mod=1000000007;\nconst llint big=1e17-10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nvector<vector<int>> ko;\nvector<int> oya;\nvoid make_tree(int per,int ter){\n\tif(ter!=0){\n\tko[ter].erase(find(ko[ter].begin(),ko[ter].end(),per));}\n\tfor(auto it=ko[ter].begin();it!=ko[ter].end();it++){\n\t\tmake_tree(ter,*it);\n\t}\n}\n//make_tree(-1,root);で木を作れる\nint solve(int ter){\n\tint ans=0;\n\tfor(int i=0;i<ko[ter].size();i++){\n\t\tans^=(solve(ko[ter][i])+1);\n\t}\n\treturn ans;\n}\nint main(void){\n\tint i,j,n;cin>>n;\n\tko.res(n);\n\toya.res(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tko[a].pub(b);\n\t\tko[b].pub(a);\n\t}\n\tmake_tree(-1,0);\n\tif(0==solve(0)){cout<<\"Bob\"<<endl;}\n\telse{cout<<\"Alice\"<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nstruct edge{\n\tint d,nex;\n}e[200010];\nint sg[100010],n,efree,q[100010],mex;\ntemplate<class T>\ninline void read(T&a){\n\tchar c=getchar();\n\tfor(a=0;c<'0'||c>'9';c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';\n}\ninline void add(int x,int y){e[++efree]=(edge){y,q[x]};q[x]=efree;}\nvoid dfs(int x,int y,int d){\n\tfor(int i=q[x];i;i=e[i].nex)\n\t\tif(e[i].d!=y)dfs(e[i].d,x,d+1);\n\tsg[d]++;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x),read(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0,1);\n\tfor(int i=2;i<=n;i++)\n\t\tif(sg[i]&1){puts(\"Alice\");return 0;}\n\tputs(\"Bob\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace fastIO {\n\ttemplate<typename T> inline void read(T &x) {\n\t\tregister char c = getchar();\n\t\tregister bool flag = 0;\n\t\twhile (!isdigit(c)) {\n\t\t\tflag |= c == '-';\n\t\t\tc = getchar();\n\t\t}\n\t\tx = c - '0';\n\t\tc = getchar();\n\t\twhile (isdigit(c)) {\n\t\t\tx = x * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t\tif (flag) {\n\t\t\tx = -x;\n\t\t}\n\t}\n}\nusing namespace fastIO;\n\nint n;\nvector<int> adj[100010];\n\nint dfs(int x, int pre) {\n\tint adjx_size = adj[x].size(), ret = 0;\n\tfor (int i = 0; i < adjx_size; ++i) {\n\t\tint y = adj[x][i];\n\t\tif (y != pre) {\n\t\t\tret ^= dfs(y, x) + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tputs(dfs(1, 0) ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n\tint n,ji=0,cha[100001];\n\tint x,y;\n\tcin>>n;\n\tfor(int var1=1;var1<=n-1;var1++)\n\t{\n\t\tcin>>x>>y;\n\t\tif(x==1) ji++;\n\t}\n\tif(ji%2==0) cout<<\"Bob\";\n\telse cout<<\"Alice\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100010;\nint n, f[maxn];\nvector<int> G[maxn];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d %d\", &u, &v);\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    function<void(int, int)> dfs = [&](int v, int fa) {\n        for (int u : G[v]) if (u ^ fa) {\n            dfs(u, v), f[v] ^= f[u] + 1;\n        }\n    };\n    dfs(1, 0), printf(\"%s\\n\", f[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n#include <cassert>\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nvector<vector<int> > g;\n\nint dfs(int id,int pre){\n\tint res = 0;\n\tfor(auto x:g[id]){\n\t\tif(x!=pre){\n\t\t\tres ^=dfs(x,id)+1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tif(dfs(0,0)==0){\n\t\tcout << \"Bob\" << endl;\n\t}else{\n\t\tcout << \"Alice\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;  \nconst int N = 2e5+5;\n\nint tot,n,m,point[N],nxt[N],v[N];  \n\nvoid add(int x,int y) {  \n\ttot++; nxt[tot]=point[x]; point[x]=tot; v[tot]=y;  \n\ttot++; nxt[tot]=point[y]; point[y]=tot; v[tot]=x;  \n}  \n\nint dfs(int x,int fa) {  \n\tint sg=0;  \n\tfor (int i=point[x];i;i=nxt[i])  \n\t\tif (v[i]!=fa)   \n\t  \t\tsg^=(dfs(v[i],x)+1);  \n\treturn sg;  \n}  \n\nint main() {  \n\tscanf(\"%d\",&n);  \n\tfor (int i=1;i<n;i++){  \n\t\tint x,y; scanf(\"%d%d\",&x,&y);  \n\t\tadd(x,y);  \n\t}  \n\tint ans=dfs(1,0);  \n\tif (ans) printf(\"Alice\\n\");  \n\telse printf(\"Bob\\n\");  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> adjl[100005];\n\nint func(int node,int parent){\n    int children = 0;\n    for (int x : adjl[node]){\n        if (x==parent) continue;\n        children++;\n    }\n    if (children%2==1) return 1;\n    else{\n        int sum = 0;\n        for (int x : adjl[node]){\n            if (x==parent) continue;\n            sum += func(x,node);\n        }\n        return sum%2;\n    }\n}\n\nint main(){\nint n;\nscanf(\"%d\",&n);\nfor (int x = 0; x<n-1; x++){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    adjl[a].push_back(b);\n    adjl[b].push_back(a);\n}\nprintf(func(1,-1)==1?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n\n#ifdef PRINTERS\n#include \"printers.hpp\"\nusing namespace printers;\n#define tr(a)\t\tcerr<<#a<<\": \"<<a<<endl;\n#else\n#define tr(a)    \n#endif\n\n#define ll          long long\n#define pb          push_back\n#define mp          make_pair\n#define pii         pair<int,int>\n#define vi          vector<int>\n#define all(a)      (a).begin(),(a).end()\n#define F           first\n#define S           second\n#define sz(x)       (int)x.size()\n#define hell        1000000007\n#define endl        '\\n'\n#define rep(i,a,b)\tfor(int i=a;i<b;i++)\nusing namespace std;\nvi adj[100005];\nint dfs(int u,int p){\n\tint cur=0;\n\tfor(auto i:adj[u])if(i!=p){\n\t\tcur^=dfs(i,u);\n\t}\n\treturn cur+1;\n}\nvoid solve(){\n\tint N;\n\tcin>>N;\n\trep(i,1,N){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\tif(dfs(1,0)-1==0){\n\t\tcout<<\"Bob\";\n\t}\n\telse{\n\t\tcout<<\"Alice\";\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t=1;\n//\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b)  for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n#define ll long long\n\nusing namespace std;\n\nint rez[100100];\nvector <int> child[100100];\nint par[100100];\n\nvoid dfs(int x) {\n  int out = -1;\n  REP(i, child[x].size()) {\n    int ne = child[x][i];\n    if (ne == par[x]) continue;\n    par[ne] = x;\n    dfs(ne);\n    out *= rez[ne];\n  }\n//  if (child[x].size() == 2 && x != 0) out = 1;\n  rez[x] = out;\n  return;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    child[x].push_back(y);\n    child[y].push_back(x);\n  }\n  par[0] = -1;\n  dfs(0);\n  if (child[0].size() == 1) {\n    cout << \"Alice\\n\";\n    return 0;\n  }\n  if (rez[0] == 1) cout << \"Alice\\n\";\n  else             cout << \"Bob\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e6+5;\nstruct node{\n    int u,v,nxt;\n}edge[N];\nint head[N],mcnt;\nvoid add_edge(int u,int v){\n    mcnt++;\n    edge[mcnt].u=u;\n    edge[mcnt].v=v;\n    edge[mcnt].nxt=head[u];\n    head[u]=mcnt;\n}\nint g[N];\nint SG(int u,int fa=0){\n    g[u]=0;\n    for(int i=head[u];i;i=edge[i].nxt){\n        int v=edge[i].v;\n        if(v==fa)\n            continue ;\n        g[u]^=SG(v,u)+1;\n    }\n    return g[u];\n}\nint n;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    puts(SG(1)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nvector<int> es[100010];\n\nint dfs(int now, int par) {\n\tint ret = 0LL;\n\tfor(auto& to : es[now]) {\n\t\tif(to == par) continue;\n\t\tret ^= (dfs(to, now) + 1);\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\trep(i, n-1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;y--;\n\t\tes[x].pb(y);\n\t\tes[y].pb(x);\n\t}\n\tcout << (dfs(0, -1) ? \"Alice\": \"Bob\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#define ld long double\n#define MN 210000\nusing namespace std;\n\nint read_p,read_ca;\ninline int read(){\n    read_p=0;read_ca=getchar();\n    while(read_ca<'0'||read_ca>'9') read_ca=getchar();\n    while(read_ca>='0'&&read_ca<='9') read_p=read_p*10+read_ca-48,read_ca=getchar();\n    return read_p;\n}\nstruct na{int y,ne;}b[MN];\nint n,m,l[MN],num=0,x,y,s[MN];\ninline void in(int x,int y){\n\tb[++num].y=y;b[num].ne=l[x];l[x]=num;\n}\nvoid dfs(int x,int f){\n\tint u=0;s[x]=0;\n\tfor (int i=l[x];i;i=b[i].ne)\n\tif (b[i].y!=f){\n\t\tdfs(b[i].y,x);u^=s[b[i].y]+1;\n\t}\n\t\n\ts[x]=u;\n\t/*for (int i=l[x];i;i=b[i].ne)\n\tif (b[i].y!=f){\n\t\tif ((u^s[b[i].y])==0) s[x]=1;\n\t}*/\n\t//printf(\"%d %d\\n\",x,s[x]);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<n;i++) x=read(),y=read(),in(x,y),in(y,x); \n\t\n\tdfs(1,0);\n\tputs(s[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nvector<int> g[100111];\nint n,sg[100111];\nvoid dfs(int x,int f=0)\n{\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f)\n\t\t{\n\t\t\tdfs(g[x][i],x);\n\t\t\tsg[x]^=sg[g[x][i]]+1;\n\t\t}\n}\nint main()\n{\n\tget1(n);\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tget2(u,v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(1);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n \ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n \ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n \nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n \n \nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n \nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n \nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n \ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n \ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n \ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n \ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n \ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n \ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint n,q[100005],x[100005];\nvi g[100005];\nvoid dfs(int v,int p){\n\tint ch=0;\n\tfor(auto &i:g[v]){\n\t\tif(i==p)continue;\n\t\tdfs(i,v);\n\t\tch++;\n\t\tx[v]^=q[i];\n\t\tif(ch==1)q[v]=1;\n\t\telse if(ch==2)q[v]=x[v];\n\t\telse{\n\t\t\tif(q[v]==0)q[v]=1;\n\t\t\telse q[v]=x[v];\n\t\t}\n\t}\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[--a].eb(--b);\n\t\tg[b].eb(a);\n\t}\n\tdfs(0,-1);\n\tif(q[0])cout<<\"Alice\\n\";\n\telse cout<<\"Bob\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nconst int BLOCKS = 330;\nvector<int> lst[N + 5];\nint grundy[N + 5];\n\nvoid dfs(int idx,int pre) {\n\tfor(auto x: lst[idx]) {\n\t\tif(x == pre) continue;\n\t\tdfs(x, idx);\n\t}\n\tfor(auto x: lst[idx]) {\n\t\tif(x == pre) continue;\n\t\tgrundy[idx] ^= (grundy[x] + 1);\n\t}\n}\n\nvoid hora(int tc) {\n\tint n;\n\tcin>>n;\n\tfor(int i = 1;i < n;i++) {\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tlst[u].PB(v);\n\t\tlst[v].PB(u);\n\t}\n\tdfs(1, 1);\n\tif(grundy[1] == 0) cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint dfs(int now, int par, vii &G) {\n  int g = 0;\n  rep (i, G[now].size()) {\n    if (G[now][i] == par) continue;\n    g ^= (dfs(G[now][i], now, G) + 1);\n  }\n  return g;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vii G(n);\n  rep (i, n - 1) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  if (dfs(0, -1, G) == 0) {\n    cout << \"Bob\" << endl;\n  }\n  else {\n    cout << \"Alice\" << endl;\n  }\n}\n  \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> v[100005];\nint a[100005];\n\nint dfs(int n  , int p)\n{\n    a[n] = 0;\n\n    for(int it : v[n])\n    {\n        if(it==p)\n            continue;\n        dfs(it , n);\n        a[n] ^= a[it]+1;\n    }\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    for(int i = 1 ; i<n ; i++)\n    {\n        int x , y;\n        cin >> x >> y;\n\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    dfs(1 , 0);\n\n    if(a[1]==0)\n    {\n        cout << \"Bob\";\n        return 0;\n    }\n    else\n    cout << \"Alice\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nint n,tot=0,head[100001];\nstruct data {\n    int next,num;\n}edge[200001];\nvoid add(int u,int v) {\n    edge[++tot].next=head[u];\n    edge[tot].num=v;\n    head[u]=tot;\n}\nint dfs(int x,int fa) {\n    int ans=0;\n    for (int i=head[x];i!=-1;i=edge[i].next) {\n\tint kx=edge[i].num;\n\tif (kx==fa) continue;\n\tans^=dfs(kx,x)+1;\n    }\n    return ans;\n}\nint main() {\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++) {\n\tint u,v;\n\tscanf(\"%d%d\",&u,&v);\n\tadd(u,v);\n\tadd(v,u);\n    }\n    int ans=dfs(1,-1);\n    if (ans) printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7 ;\nint dp[N];\nvector<int> g[N];\nint sz[N];\nint n, u, v, cnt[N];\nint ans;\n\ninline int mex(vector<int> q)\n{\n\tif(q.size() == 0) return 0;\n\tsort(q.begin(), q.end());\n\tif(q[0] != 0)\n\t\treturn 0;\n\tfor(int i = 1; i < q.size(); ++i)\n\t{\n\t\tif(q[i] != q[i - 1] + 1)\n\t\t\treturn q[i - 1] + 1;\n\t}\n\treturn q.back() + 1;\n}\nvector<int> q;\n\ninline void  dfs(int v, int p =-1)\n{\n\tsz[v] = 0;\n\tfor(int to : g[v])\n\t\tif(to != p)\n\t\t{\n\t\t\tdfs(to, v);\n\t\t\tsz[v] ^= sz[to] ^ 1;\n\t\t}\n\tq.pb(sz[v]);\n/*\tdp[v] = mex(q);\n\tcerr<<\"vertex: \" << v << \"\\n\";\n\tfor(int x : q)\n\t\tcerr<<x <<' ';\n\tcerr<< \" mex is \" << dp[v] << endl;\n\t*/\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfo(i, n - 1)\n\t{\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(1);\n\tif(g[1].size() == 1)\n\t\tcout << \"Alice\";\n\telse\n\t{\n\t\tif(sz[1] == 1)\n\t\t\tcout << \"Alice\";\n\t\telse\n\t\t\tcout << \"Bob\"; \n\t}\n\t\n\treturn 0;\n}\n               "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nint depth[100005];\nvoid dfs(int current, int parent)\n{\n    int i,l,x;\n    l = v[current].size();\n    depth[current] = depth[parent] + 1;\n    for(i=0;i<l;i++)\n    {\n        x = v[current][i];\n        if(x!=parent)\n            dfs(x,current);\n    }\n    \n}\nint main()\n{\n    int n,i,x,y;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    depth[0] = -1;\n    dfs(1,0);\n    int ans = 0;\n    for(i=1;i<=n;i++)ans ^= depth[i];\n    if(ans)printf(\"Alice\\n\");\n    else printf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <queue>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define ll long long\n#define maxn 500400\nusing namespace std;\ninline void read(int &x){\n    char ch;\n    bool flag=false;\n    for (ch=getchar();!isdigit(ch);ch=getchar())if (ch=='-') flag=true;\n    for (x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());\n    x=flag?-x:x;\n}\n\ninline void write(int x){\n    static const int maxlen=100;\n    static char s[maxlen];\n        if (x<0) {   putchar('-'); x=-x;}\n    if(!x){ putchar('0'); return; }\n    int len=0; for(;x;x/=10) s[len++]=x % 10+'0';\n    for(int i=len-1;i>=0;--i) putchar(s[i]);\n}\nlong long n,l,r,c,d;\n//int a[maxn];\n\n\nint main(){\n    puts(\"Alice\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n5\n1 2\n2 3\n1 4\n4 5\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nvector<int> edge[maxn];\nbool vis[maxn];\nint dfs(int u){\n\tvis[u]=1;\n\tint ret=0;\n\tfor(int v:edge[u]) if(!vis[v]){\n\t\tret^=1+dfs(v);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tIOS;\n\tint n;\n\tcin>>n;\n\tREP(i,n-1){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tif(dfs(0)) cout<<\"Alice\\n\";\n\telse cout<<\"Bob\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n\nusing namespace std;\n\nint cnt[100001];\nvector<int> tree[1000001];\nbool used[100001];\n\nbool winner(vector<int> index){\n    int counter =0;\n    vector<int> nextindex;\n    if(index.size()==0)return false;\n    for(int i=0;i<index.size();i++){\n        int k=index[i];\n        used[k]=true;\n        counter+=cnt[k];\n        for(int j=0;j<tree[k].size();j++){\n            if(!used[tree[k][j]]){\n                nextindex.push_back(tree[k][j]);\n            }\n        }\n    }\n\n    if(counter%2==1){\n        return true;\n    }else{\n        return winner(nextindex);\n    }\n\n}\n\n\n\nint main(){\n\n    int N;\n    cin>>N;\n    fill_n(cnt,100001,0);\n    fill_n(used,100001,false);\n    REP(i,N-1){\n        int x,y;\n        cin>>x>>y;\n        cnt[x]++;\n        cnt[y]++;\n        tree[x].push_back(y);\n        tree[y].push_back(x);\n\n    }\n\n\n    vector<int> a;\n    a.push_back(1);\n    if(winner(a)){\n        cout<<\"Alice\"<<endl;\n    }else{\n        cout<<\"Bob\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2017 Mstdream\n#include<bits/stdc++.h>\nusing namespace std;\ninline void splay(int &v){\n\tv=0;char c=0;int p=1;\n\twhile(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();}\n\tv*=p;\n}\nconst int N=200020;\nint nxt[N*2],fir[N],to[N*2],sz,n,dp[N];\nvoid add(int x,int y){\n\tnxt[++sz]=fir[x],fir[x]=sz,to[sz]=y;\n}\n//1先手0后手 \nvoid dfs(int x,int fa){\n\tint a=0,b=0; \n\tfor(int u=fir[x];u;u=nxt[u]){\n\t\tif(to[u]!=fa){\n\t\t\tdfs(to[u],x);\n\t\t\tif(dp[to[u]]==1)a++;\n\t\t\telse b++;\n\t\t} \n\t}\n\tif((b&1)==1)dp[x]=1;\n\telse{\n\t\tif((a&1)==1)dp[x]=1;\n\t\telse dp[x]=0;\n\t}\n}\nint main(){\n\tint _q=20<<20;\n\tchar *_p=(char*)malloc(_q)+_q;\n\t__asm__(\"movl %0, %%esp\\n\"::\"r\"(_p));\n\tsplay(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;splay(x),splay(y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tputs(dp[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define maxn 111111\nvector<int> g[maxn];\nint n;\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    if (g[1].size() == 1)\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        if ((n - 1 - g[1].size()) % 2 == g[1].size())\n        {\n            cout << \"Alice\" << endl;\n        }\n        else\n        {\n            cout << \"Bob\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>          \n#include <map>           \n#include <list>\n#include <ctime>\n#include <deque>         \n#include <bitset>        \n#include <vector>\n#include <list>\n#include <stack>\n#include <random>\t\t \n#include <string>       \n#include <numeric>      //  needed for  accumulate\n#include <utility>      // needed for std:: move\n#include <iterator> \n#include <iostream>   \n#include <algorithm> \n#include <functional>    \n#include <cmath>         \n#pragma warning(disable:4996) // ignore this\n#define ve vector\n#define pb push_back\n#define mp make_pair                     \n#define srt(x) sort(x.begin(),x.end())         \n#define mod static_cast<long long> (1e9+7)     \n#define sumx(x) accumulate(x.begin(),x.end(),0LL)\n#define pi 3.14159265358979323846\nusing namespace std;\ntemplate<typename T>\nistream& operator >> (istream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin >> x;\n\treturn in;\n}\ntemplate<typename T>\nostream& operator<<(ostream& in, ve<T> &v)\n{\n\tfor (auto &x : v)\n\t\tin << x << \" \";\n\treturn in;\n}\nclass solve\n{\n\tlong long n;\n\tve<bool > vis;\n\tve<ve<int> > adj;\n\tve<ve<int> > adj2;\n\tvoid dfs(int c=0)\n\t{\n\t\tvis[c]=true;\n\t\tfor(auto &x:adj[c])\n\t\t{\n\t\t\tif(!vis[x])\n\t\t\t{\n\t\t\t\tadj2[c].pb(x);\n\t\t\t\tdfs(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tint winner(int c=0)\n\t{\n\t\tvis[c]=false;\n\t\tint ans=0;\n\t\tfor(auto &x:adj2[c])\n\t\t{\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tans^=winner(x);\n\t\t\t}\n\t\t}\n\t\treturn !ans;\n\t}\npublic:\n\tsolve()\n\t{\n\t\tcin >> n;\n\t\tvis.resize(n);\n\t\tadj.resize(n);\n\t\tadj2.resize(n);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\t--x,--y;\n\t\t\tadj[x].pb(y);\n\t\t\tadj[y].pb(x);\n\t\t}\n\t\tdfs();\n\t\tint p=winner(0);\n\t\tif(p)\n\t\t{\n\t\t\tcout << \"Alice\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout <<\"Bob\\n\";\n\t\t}\n\t}\n};\n \nint main()\n{\n\tint t = 1, i = 1;\n\t//scanf(\"%d\", &t);\n \n\twhile (t--)\n\t{\n\t\tnew solve;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\n#define N (ll)(1e6+3)\n#define INF (ll)(1e18+3)\n#define MOD (ll)(1e9+7)\n\n#define ll long long\n#define rep(i,a,n) for(ll i = a; i < n; i++)\n#define per(i,a,n) for(ll i = n-1; i >= a; i--)\n\n//using namespace __gnu_pbds;\nusing namespace std;\n \n// typedef\n// tree<\n//     pair<ll,ll>,\n//     null_type,\n//     less<pair<ll,ll>>,\n//     rb_tree_tag,\n//     tree_order_statistics_node_update>\n// ordered_set;\n\n\nll n;\nll par[N];\nvector<ll> g[N];\nll d[N];\n\nvoid dfs(ll u, ll p) {\n    vector<ll> v;\n\n    rep(i,0,g[u].size()) {\n        ll ch = g[u][i];\n        if (ch == p) continue;\n        dfs(ch,u);\n        v.push_back(d[ch]);\n    }\n\n    if (v.size() == 1)\n        d[u] = v[0];\n    else if (v.size() > 1) {\n        ll mask = 0;\n        rep(i,0,v.size()) {\n            mask ^= v[i];\n        }\n        d[u] = !!mask;\n    }\n    d[u] += 1;\n}\n\nvoid solve() {\n    cin >> n;\n    rep(i,0,n-1) {\n        ll a, b; cin >> a >> b; a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0,0);\n    if (d[0] != 1) {\n        cout << \"Alice\" << endl;\n    }\n    else {\n        cout << \"Bob\" << endl;\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<1];\nint n,home[N],cnt=-1,f[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k,int F){\n\tfor(int i=home[k];~i;i=e[i].next) if(e[i].k!=F){\n\t\tdfs(e[i].k,k);\n\t\tf[k]^=f[e[i].k]+1==1?2:1;\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tif(f[1]) puts(\"Alice\");\n\telse puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\n//作者:中国江苏南京丁天行\nusing namespace std;\n//数组不要开小了\n//数组不要开反了\nint n,f[2][100005];\nvector<int> v[100005];\nint cty(int x,int p){\n    int cnt[2]={};\n    for(int i=0;i<v[x].size();i++){\n            if(v[x][i]==p) continue;\n            cnt[cty(v[x][i],x)]++;\n    }\n    if(cnt[1]%2==0&&cnt[0]%2==0) return 0;\n    return 1;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].pb(y),v[y].pb(x);\n    }\n    if(cty(1,0))puts(\"Alice\");\n    else puts(\"Bob\");\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n _    _    _______   _    _\n| |  / /  |  _____| | |  / /\n| | / /   | |       | | / /\n| |/ /    | |_____  | |/ /\n| |\\ \\    |  _____| | |\\ \\\n| | \\ \\   | |       | | \\ \\\n| |  \\ \\  | |_____  | |  \\ \\\n|_|   \\_\\ |_______| |_|   \\_\\\n\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define right(x) x << 1 | 1\n#define left(x) x << 1\n#define forn(x, a, b) for (ll x = a; x <= b; ++x)\n#define for1(x, a, b) for (ll x = a; x >= b; --x)\n#define mkp make_pair\n#define sz(a) (int)a.size()\n#define all(a) a.begin(), a.end()\n#define y1 kekekek\n\nconst ll ool = 1e18 + 9;\nconst int oo = 1e9 + 9, base = 1e9 + 7;\nconst ld eps = 1e-7;\nconst int N = 2e6 + 6;\n\nint n, ans;\nvector < int > g[N];\n\nint dfs(int v, int par) {\n    vector < int > vec;\n    vec.eb(0);\n    for (auto to : g[v]) {\n        if (to == par) continue;\n        vec.eb(dfs(to, v));\n    }\n    sort(all(vec));\n    int mex = vec.back() + 1;\n    forn(i, 1, sz(vec) - 1) {\n        if (vec[i] != vec[i - 1] + 1) {\n            mex = vec[i - 1] + 1;\n            break;\n        }\n    }\n    return mex;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    forn(i, 1, n - 1) {\n        int x, y;\n        cin >> x >> y;\n        g[x].eb(y);\n        g[y].eb(x);\n    }\n\n    for (auto to : g[1]) {\n        ans ^= dfs(to, 1);\n    }\n\n    cout << (ans ? \"Alice\" : \"Bob\") << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define Min(x,y) (x<y)?x:y\nusing namespace std;\nconst int MAXN=100005,MAXM=200005;\nint N;\nint en[MAXM],las[MAXN],nex[MAXM],tot;\nvoid ADD(int x,int y)\n{\n\ten[++tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nint DFS(int p,int f)\n{\n\tint ans=0,i,y,cnt=0;\n\tfor(i=las[p];i;i=nex[i])\n\t{\n\t\ty=en[i];\n\t\tif(y==f)continue;\n\t\tcnt++;\n\t\tans^=DFS(y,p);\n\t}\n\tif(cnt&1)cnt=1;\n\telse cnt=0;\n\treturn ans^cnt;\n}\nint main()\n{\n\tint i,x,y,t;\n\tscanf(\"%d\",&N);\n\t\n\tfor(i=1;i<N;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tADD(x,y);ADD(y,x);\n\t}\n\t\n\tt=DFS(1,0);\n\tif(t)printf(\"Alice\");\n\telse printf(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 2147483647 / 2;\nconst long long int llINF = 9223372036854775807 / 2;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VV(T, a, b, c) vector<vector<T>>(a, vector<T>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define VVV(T, a, b, c, d)                                                     \\\n  vector<vector<vector<T>>>(a, vector<vector<T>>(b, vector<T>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll dfs(vvl &G, ll now, ll par) {\n  ll po = 0;\n  ll count = 0;\n  AUTO(g, G[now]) {\n    if (g == par)\n      continue;\n    po ^= dfs(G, g, now);\n    count++;\n  }\n  if (count == 1)\n    po++;\n  // cout << now + 1 << po << endl;\n  return po;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ll N;\n  cin >> N;\n  vector<vector<ll>> G(N);\n  REP(i, N - 1) {\n    ll x, y;\n    cin >> x >> y;\n    G[x - 1].push_back(y - 1);\n    G[y - 1].push_back(x - 1);\n  }\n  if (dfs(G, 0, -1))\n    cout << \"Alice\" << endl;\n  else\n    cout << \"Bob\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 10000000000000000\n\nint dfs(auto &E,int now,int p){\n\tint ret = 0;\n\tfor(int i=0;i<E[now].size();i++){\n\t\tif(E[now][i]==p)continue;\n\t\tret ^= dfs(E,E[now][i],now);\n\t}\n\treturn ret+1;\n}\n\nint main(){\n\t\n\tint N;\n\tcin>>N;\n\t\n\tvector<vector<int>> E(N,vector<int>());\n\t\n\tfor(int i=0;i<N-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\t\n\tif(dfs(E,0,-1)==1)cout<<\"Bob\"<<endl;\n\telse cout<<\"Alice\"<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvector<int> g[100010];\n\nint dfs(int v, int p = 0)\n{\n    int r = 0;\n    for (int nv : g[v])\n    {\n        if (nv == p)\n            continue;\n        r ^= dfs(nv, v) + 1;\n    }\n    return r;\n}\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int grundy = 0;\n    for (int v : g[0])\n    {\n        grundy ^= dfs(v) + 1;\n    }\n    cout << (grundy ? \"Alice\" : \"Bob\") << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node { int t,next; }a[200010];\n\nint head[100010],f[100010],n,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n\ninline void dfs(int x,int y)\n{\n\tf[x]=0;\n\tfor (int i=head[x];i;i=a[i].next)\n\t{\n\t\tint t=a[i].t;\n\t\tif (t==y) continue;\n\t\tdfs(t,x);f[x]^=f[t]+1;\n\t}\n}\n\nint main()\n{\n\tn=rd();tot=0;\n\tfor (int i=1;i<n;i++) { int x=rd(),y=rd();add(x,y);add(y,x); }\n\tdfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Grand Contest 017\n// D - Game on Tree\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\n\nconst int MAX_N = 100000;\n\nint N;\nvector<int> G[MAX_N];\n\nint calc_grundy(int v = 0, int par = -1) {\n    int grundy = 0;\n\n    for (int to : G[v]) {\n        if (to == par) {\n            continue;\n        }\n        grundy ^= (calc_grundy(to, v) + 1);\n    }\n\n    return grundy;\n}\n\nint main() {\n\n    int x, y;\n\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        cin >> x >> y; x--; y--;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n\n    cout << (calc_grundy() != 0 ? \"Alice\" : \"Bob\") << endl;\n\n    return 0;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\n\n\nstruct Problem{\n    int n,cnt,b;\n    vector<vector<int>> t;\n    vector<int> vis,dep;\n    set<int> od;\n    Problem(LL n):n(n),cnt(0),t(n),vis(n),dep(n){};\n    void dfs(int cur){\n        od.erase(cur);\n        if((int)t[cur].size()==1 and cur!=0){\n            return;\n        }\n        for(auto x:t[cur]){\n            if(dep[x]>dep[cur]){\n                dfs(x);\n            }\n        }\n    }\n    void solve(){\n        for(int i=0; i<n-1; ++i){\n            int a,b;\n            cin >> a >>b;\n            --a;--b;\n            t[a].push_back(b);\n            t[b].push_back(a);\n        }\n        queue<int> Q;\n        Q.push(0);\n        while(!Q.empty()){\n            int tmp=Q.front();\n            vis[tmp]=1;\n            Q.pop();\n            if(((int)t[tmp].size()-(tmp!=0))%2==1){\n                od.insert(tmp);\n                if(od.size()==1) b=tmp;\n            }\n            for(auto x:t[tmp]){\n                if(vis[x]==0){\n                    Q.push(x);\n                    dep[x]=dep[tmp]+1;\n                }\n            }\n        }\n        if(od.empty()){\n            cout << \"Bob\"<<\"\\n\";\n            return;\n        }\n        DBG(od)\n        od.erase(b);\n        int aa=od.size();\n        for(auto y:t[b]){\n            if(dep[y]>dep[b]){\n                dfs(y);\n                DBG(od)\n                if(od.size()<aa and od.size()>0){\n                    cout << \"Bob\"<<\"\\n\";\n                    return ;\n                }else if(od.empty()){\n                    cout << \"Alice\"<<\"\\n\";\n                    return ;\n                }\n            }\n        }\n        if(od.empty())cout << \"Alice\"<<\"\\n\";\n        else cout << \"Bob\"<<\"\\n\";\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int N = 101234;\nvii G(N);\n\nint dfs(int now, int par) {\n    int res = 0;\n    for (int ch: G[now]) {\n        if (ch == par) continue;\n        res ^= (dfs(ch, now) + 1);\n    }\n    // DEBUG(pii(now, res));\n    return res;\n}\n\nsigned main() {\n    fio();\n\n    int n;\n    cin >> n;\n    rep (i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    if (dfs(0, -1)) {\n        cout << \"Alice\" << endl;\n    }\n    else {\n        cout << \"Bob\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\nint N;\nvector<int> G[1005];\n\nint dfs(int v, int p){\n  int res = 0;\n  for(int u : G[v]){\n    if(u == p) continue;\n    res ^= dfs(u, v) + 1;\n  }\n  return res;\n}\n\nint main(){\n  cin >> N;\n  REP(i,N-1){\n    int x, y;\n    cin >> x >> y;\n    x--;y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<string, string>;\nll MOD = 1e9+7;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> d(n);\n    for(int i = 0; i < n-1; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--;y--;\n        d[x].push_back(y);\n        d[y].push_back(x);\n    }\n    int size = d[0].size();\n    if(size == 1)\n    {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    function<int(int, int)> dfs = [&](int v, int pre)\n    {\n        int grundy = 0;\n        for(int cand : d[v])\n        {\n            if(cand == pre) continue;\n            grundy ^= dfs(cand, v) + 1;\n        }\n        return grundy;\n    };\n    int x = 0;\n    for(int i = 0; i < size; i++)\n    {\n        int grundy = dfs(d[0][i], 0);\n        x ^= grundy;\n    }\n    if(x != 0)\n    {\n        cout << \"Alice\" << endl;\n    }\n    else\n    {\n        cout << \"Bob\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:64777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <stdio.h>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <cassert>\n#include <complex>\n#include <time.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long Int;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nconst int MAX = 1000007;\nconst int CNT = 17;\n\nint n;\nVI G[MAX];\nint R[MAX];\n\nvoid dfs(int v, int p)\n{\n\tFOR (i,0,SZ(G[v]))\n\t{\n\t\tint to = G[v][i];\n\t\tif (to == p) continue;\n\t\tdfs(to, v);\n\t\tR[v] ^= R[to];\n\t}\n\t++ R[v];\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tFOR (i,0,n-1)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t-- u;\n\t\t-- v;\n\t\tG[u].PB(v);\n\t\tG[v].PB(u);\n\t}\n\n\tdfs(0, -1);\n\n\t-- R[0];\n\n\tcout << (R[0] == 0 ? \"Bob\" : \"Alice\") << endl;\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=1e5+10;\nint n;\nVI e[N];\n\nvoid dfs( int p ) {\n    for ( int i:e[p] ) {\n        e[i].erase(find(ALL(e[i]),p));\n        dfs(i);\n    }\n}\n\nint go( int p ) {\n    int s=0;\n    for ( int i:e[p] ) s^=go(i)+1;\n    return s;\n}\n\nint main() {\n    R(n);\n    REP(i,n-1) {\n        int a,b;\n        R(a,b);\n        e[a].PB(b);\n        e[b].PB(a);\n    }\n    dfs(1);\n    int sg=go(1);\n    W(sg ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7 ;\nint dp[N];\nvector<int> g[N];\nint sz[N];\nint n, u, v, cnt[N];\nint ans;\n\ninline int mex(vector<int> q)\n{\n\tif(q.size() == 0) return 0;\n\tsort(q.begin(), q.end());\n\tif(q[0] != 0)\n\t\treturn 0;\n\tfor(int i = 1; i < q.size(); ++i)\n\t{\n\t\tif(q[i] != q[i - 1] + 1)\n\t\t\treturn q[i - 1] + 1;\n\t}\n\treturn q.back() + 1;\n}\nvector<int> q;\nint res;\n\ninline void  dfs(int v, int p =-1)\n{\n\tsz[v] = 0;\n\tfor(int to : g[v])\n\t\tif(to != p)\n\t\t{\n\t\t\tdfs(to, v);\n\t\t\tsz[v] ^= sz[to] ^ 1;\n\t\t}\n\tq.pb(sz[v]);\n\tres^=sz[v];\n//\tcerr<<v<<' '<<sz[v]<<endl;\n/*\tdp[v] = mex(q);\n\tcerr<<\"vertex: \" << v << \"\\n\";\n\tfor(int x : q)\n\t\tcerr<<x <<' ';\n\tcerr<< \" mex is \" << dp[v] << endl;\n\t*/\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfo(i, n - 1)\n\t{\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(1);\n\tif(g[1].size() == 1)\n\t\tcout << \"Alice\";\n\telse\n\t{\n\t\tif(res == 1)\n\t\t\tcout << \"Alice\";\n\t\telse\n\t\t\tcout << \"Bob\"; \n\t}\n\t\n\treturn 0;\n}\n               "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200100;\n\nvector<int>v[maxn];\nint n;\n\nint dfs(int x,int fa)\n{\n\tint ans=0;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif(y==fa)continue;\n\t\tans^=(dfs(y,x)+1);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif(dfs(1,0))cout<<\"Alice\";\n\telse cout<<\"Bob\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    sg[i]=0;\n    set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        s.insert(sg[g[i][j]]);\n    }\n    for(long j=0,l=s.size();j<l;j++)\n    {\n        if(sg[i]==*s.begin()){s.erase(s.begin());sg[i]++;}\n        else break;\n    }\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    //for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1]||g[1].size()==1)cout<<\"Alice\";\n    else cout<<\"Bob\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\nusing ll = long long;\n\nvector<int> tree[100000];\n\nint grundy(int x, int prev) {\n    int g = 0;\n    for (int v : tree[x]) {\n        if (v != prev)\n            g ^= grundy(v, x);\n    }\n    return g + 1;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        --v1;\n        --v2;\n        tree[v1].push_back(v2);\n        tree[v2].push_back(v1);\n    }\n\n    printf(grundy(0, -1) == 1 ? \"Bob\\n\" : \"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tlist<int>edge[100001];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tqueue<int>Q;\n\tfor (auto i : edge[1])Q.push(i);\n\tint dis[100001] = {};\n\tbool used[100001] = {};\n\tused[1] = true;\n\twhile (!Q.empty()) {\n\t\tint c = Q.front();\n\t\tif (used[c]) {\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tif (edge[c].size() > 3)dis[c] = 1;\n\t\tused[c] = true;\n\t\tbool add = true;\n\t\tfor (auto i : edge[c]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tadd = false;\n\t\t\t\tdis[i] = dis[c] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t\tif (add)ans ^= dis[c];\n\t\tQ.pop();\n\t}\n\tif (ans)cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1e5+5,M=2*N;\nint n,i,et,he[N],sg[N];\nstruct edge{int l,to;}e[M];\nint read(){\n\tchar c=getchar();int k=0;for (;c<48||c>57;c=getchar());\n\tfor (;c>47&&c<58;c=getchar()) k=(k<<3)+(k<<1)+c-48;return k;\n}\nvoid dfs(int x,int fa){\n\tfor (int i=he[x];i;i=e[i].l) if (e[i].to!=fa)\n\t\tdfs(e[i].to,x),sg[x]^=sg[e[i].to]+1;\n}\nint main(){\n\tfor (n=read(),i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\te[++et].l=he[x];he[x]=et;e[et].to=y;\n\t\te[++et].l=he[y];he[y]=et;e[et].to=x;\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nvector<vector<ll>> edge;\n\nll dfs(ll w,ll p){\n    ll ret=0;\n    for(auto &I:edge[w]){\n        if(I!=p){ret^=dfs(I,w)+1;}\n    }\n    return ret;\n}\n\n\n\nint main(){\n    ll n;\n    cin>>n;\n    edge.resize(n);\n    for(int i=1;i<n;i++){\n        ll x,y;\n        cin>>x>>y;\n        x--; y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    cout<<(dfs(0,-1)==0?\"Bob\":\"Alice\")<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\n\n\nstruct Problem{\n    int n,cnt,b;\n    vector<vector<int>> t;\n    vector<int> vis,dep;\n    set<int> od;\n    Problem(LL n):n(n),cnt(0),t(n),vis(n),dep(n){};\n    void dfs(int cur){\n        od.erase(cur);\n        if((int)t[cur].size()==1 and cur!=0){\n            return;\n        }\n        for(auto x:t[cur]){\n            if(dep[x]>dep[cur]){\n                dfs(x);\n            }\n        }\n    }\n    void solve(){\n        for(int i=0; i<n-1; ++i){\n            int a,b;\n            cin >> a >>b;\n            --a;--b;\n            t[a].push_back(b);\n            t[b].push_back(a);\n        }\n        queue<int> Q;\n        Q.push(0);\n        while(!Q.empty()){\n            int tmp=Q.front();\n            vis[tmp]=1;\n            Q.pop();\n            if(((int)t[tmp].size()-(tmp!=0))%2==1){\n                od.insert(tmp);\n                if(od.size()==1) b=tmp;\n            }\n            for(auto x:t[tmp]){\n                if(vis[x]==0){\n                    Q.push(x);\n                    dep[x]=dep[tmp]+1;\n                }\n            }\n        }\n        int aa=od.size();\n        if(od.empty()){\n            cout << \"Alice\"<<\"\\n\";\n            return;\n        }\n        DBG(od)\n        od.erase(b);\n        for(auto y:t[b]){\n            if(dep[y]>dep[b]){\n                dfs(y);\n        DBG(od)\n                if(od.size()<aa and od.size()>0){\n                    cout << \"Bob\"<<\"\\n\";\n                    return ;\n                }\n            }\n        }\n        if(od.empty())cout << \"Alice\"<<\"\\n\";\n        else cout << \"Bob\"<<\"\\n\";\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n#include <bitset>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <climits>\n#include <ctype.h>\nusing namespace std;\n\n#define PI acos(-1.0)\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define fi first\n#define se second\n\n#define eps 1e-8\n#define mod 1000000007\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<vector<int>> vvi;\n\nstruct Matrix {\n    vector<vector<int>> data;\n    int r, c;\n    Matrix(int row, int col, bool identity = false) : r(row), c(col) {\n        data.assign(row, vector<int>(col, 0));\n        if (identity) {\n            for (int i = 0; i < r; ++i) {\n                data[i][i] = 1;\n            }\n        }\n    }\n    Matrix operator * (Matrix& other) {\n        int m = r, n = c, p = other.c;\n        Matrix res(m, p);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < p; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    res.data[i][j] += data[i][k] * other.data[k][j];\n                }\n            }\n        }\n        return res;\n    }\n};\n\n// 扩展欧几里得算法 res[1] * a + res[2] * b = res[0] = gcd(a, b)\nvector<int> extendGcd(int a, int b) {\n    if (b == 0) {\n        return {a, 1, 0};\n    } else {\n        vector<int> tmp = extendGcd(b, a % b);\n        return {tmp[0], tmp[2], tmp[1] - (a / b) * tmp[2]};\n    }\n}\n\n// 矩阵快速幂\nMatrix matrix_power(Matrix base, ll exp) {\n    int n = base.r;\n    Matrix res(n, n, true);\n    while (exp) {\n        if (exp & 1) {\n            res = res * base;\n        }\n        base = base * base;\n        exp >>= 1;\n    }\n    return res;\n}\n\n// 带模快速幂\nll power_mod(ll base, int exp) {\n    ll res = 1;\n    while (exp) {\n        if (exp & 1) res = res * base % mod;\n        base = base * base % mod;\n        exp >>= 1;\n    }\n    return res;\n}\n\n// 快速幂\nll power(ll base, int exp) {\n    ll res = 1;\n    while (exp) {\n        if (exp & 1) res *= base;\n        base *= base;\n        exp >>= 1;\n    }\n    return res;\n}\n\n// 求逆元\nll inv(ll a) {\n    return power_mod(a, mod - 2);\n}\n\n#define MAXFAC 100010\n\nll fac[MAXFAC];\n\nvoid initFac() {\n    fac[0] = 1;\n    for (int i = 1; i < MAXFAC; ++i) {\n        fac[i] = i * fac[i - 1] % mod;\n    }\n}\n\nll Combine(ll a, ll b) {\n    return (fac[a] * inv(fac[b]) % mod) * inv(fac[a - b]) % mod;\n}\n\n/******************************** template ********************************/\n#define MAXN 100005\nint n;\nvector<int> edges[MAXN];\n\nint dfs(int cur, int pre) {\n    int res = 0;\n    for (int i : edges[cur]) {\n        if (i == pre) continue;\n        res ^= 1 + dfs(i, cur);\n    }\n    return res;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n - 1; ++i) {\n        int x, y;\n        cin >> x >> y;\n        edges[x].pb(y);\n        edges[y].pb(x);\n    }\n\n    cout << (dfs(1, -1) ? \"Alice\" : \"Bob\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"avx2\")  //Enable AVX\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(),a.end()\n#define F first\n#define S second\n#define pb push_back\n#define ll long long\n#define vi vector<int>\n#define pi pair<int,int>\n#define mp make_pair\n \n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...) 42\n#endif\n \nint mod=1e9+7;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint mul(int a,int b)\n{\n\treturn ((a)*1ll*(b))%mod;\n}\n \nvoid add(int &a,int b)\n{\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n \nint sub(int a,int b){\n\ta-=b;\n\tif(a<0){\n\t\ta+=mod;\n\t}\n\treturn a;\n}\n \nint powz(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1){\n\t\t\tres=mul(res,a);\n\t\t}\n\t\tb/=2;\n\t\ta=mul(a,a);\n\t}\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nistream& operator>>(istream& input,pair<A,B>& x) {\n\tinput>>x.F>>x.S;\n\treturn input;\n}\n \ntemplate <typename A>\nistream& operator>>(istream& input,vector<A>& x) {\n\tfor(auto& i:x)\n\t\tinput>>i;\n\treturn input;\n}\n \ntemplate<typename A>\nostream& operator<<(ostream& output,vector<A>& x) {\n\tfor(auto& i:x)\n\t\toutput<<i<<' ';\n\treturn output;\n}\n \nconst int N=1000002;\n \nvector<int>adj[N];\nint dp[N];\n \nint dfs(int u,int p){\n\tint sum=0;\n\tfor(auto i:adj[u]){\n\t\tif(i!=p){\n\t\t\tsum^=dfs(i,u);\n\t\t}\n\t}\n\treturn dp[u]=sum+1;\n}\n \nvoid solve(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tadj[x].pb(y);\n\t\tadj[y].pb(x);\n\t}\n\tdfs(0,-1);\n\tint val=dp[0];\n\tif(val){\n\t\tcout<<\"Alice\";\n\t}\n\telse{\n\t\tcout<<\"Bob\";\n\t}\n}\n \nsigned main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tc=1;\n\t//~ cin>>tc;\n\tfor(int _=0;_<tc;_++){\n\t\t//~ cout<<\"Case #\"<<_+1<<\": \";\n\t\tsolve();\n\t\tif(_!=tc-1)\n\t\tcout<<\"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define fore(e, u, v) for (int p = e(u), v = e[p].y; p; v = e[p = e[p].nxt].y)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 1e5 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n;\n\nstruct vec {\n\tstatic const int maxE = maxN;\n\tint g[maxN], te;\n\tstruct edge {int y, nxt;} e[maxE << 1];\n\tinline void push(int x, int y) {e[++te] = (edge){y, g[x]}; g[x] = te;}\n\tinline void link(int x, int y) {push(x, y), push(y, x);}\n\tinline int& operator () (int x) {return g[x];}\n\tinline edge& operator [] (int x) {return e[x];}\n}e;\n\nint sg[maxN];\n\nvoid dfs(int x, int fa) {\n\tfore (e, x, y) if (y != fa) {\n\t\tdfs(y, x);\n\t\tsg[x] ^= sg[y];\n\t}\n\tsg[x] += 1;\n}\n\nint main() {\n\n\tn = ri();\n\tFor (i, 1, n) e.link(ri(), ri());\n\tdfs(1, 0);\n\tputs(sg[1] != 1 ? \"Alice\" : \"Bob\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"-O3\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define NumberOfOnes __builtin_popcount\n#define LSOne(S) (S & (-S))\n#define ll long long\n#define two pair<int,int>\n#define twoll pair<ll,ll>\n#define four pair<two,two>\n#define pb push_back\n#define eb emplace_back\n#define mk make_pair\n#define y1 y1922\n#define INF 1000000000000000000\n#define P 1000000007\n#define lmax 1000000000\n#define nn 1000003\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\n#define f first\n#define s second\n#define vi vector<int>\n#define vll vector<ll>\n#define vtwo vector<two>\n#define ALL(container) (container).begin(), (container).end()\n#define sz(container) (int)(container.size())\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define mid(a,b) (a+b>>1)\n#define minN 0\n#define maxN 10000000\n#define na(x) ((x)<P?(x):(x)-P)\n#define ab(a) (-(a)<(a)?(a):-(a))\n#define FAST std::ios::sync_with_stdio(false)\n#define xRand mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define rnd rng\n#define IT iterator\ntypedef\ntree<\n  int,// aq pair<int,int> shegidzlia\n  null_type,\n  less/*_equal*/<int>,// aqac\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n// '_equal' mashin ginda roca multiset gchirdeba\ntemplate<class key, class value,class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\nordered_map<int, int> my_map;\ninline int rin(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\ninline int bin(){\n\tint x=0;char ch=getchar();\n\twhile (ch<'0'||ch>'9') ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,ans,a,b,w[100004];\nvector<int>v[100004];\nvoid go(int sad,int saidan){\n\tint e=0,o=0;\n\tfor(auto i:v[sad]){\n\t\tif(i==saidan) continue;\n\t\tgo(i,sad);\n\t}\n\tif(sz(v[sad])==1){\n\t\tw[sad]=0;\n\t}else\n\tif(sz(v[sad])==2&&saidan!=-1){\n\t\tfor(auto i:v[sad]){\n\t\t\tif(i==saidan) continue;\n\t\t\tw[sad]=w[i]+1;\n\t\t}\n\t}else{\n\t\tfor(auto i:v[sad]){\n\t\t\tif(i==saidan) continue;\n\t\t\tw[sad]^=w[i];\n\t\t}\n\t}\n\n}\nint main(){FAST;xRand;\ncin>>n;\nfor(int i=1;i<n;i++){\n\tcin>>a>>b;\n\tv[a].pb(b);\n\tv[b].pb(a);\n\t\n}\ngo(1,-1);\nif(w[1]==0){\n\tcout<<\"Bob\"<<endl;\n}else{\n\tcout<<\"Alice\"<<endl;\n}\n}\n/*\n\n                   *         *\n                  * *       * *\n                 *   *     *   *\n                *     *   *     *\n                 *   *   * *   *\n                  *   *   *   *\n                   *   * *   *\n                     *  *   *\n\t\t\t\t\t   *  *\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int maxn = 1000000 + 10;\n \ntemplate<typename T> T read() {\n\tT n(0), f(1);\n\tchar ch = getchar();\n\tfor( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n\tfor( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nint n;\nint sg[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int f = 0) {\n    sg[u] = 0;\n    for(int i = 0; i < int(G[u].size()); i++) {\n        int v = G[u][i];\n        if(v == f) continue;\n\n        dfs(v, u);\n        sg[u] ^= sg[v] + 1;\n    }\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n\n    dfs(1);\n    puts(sg[1] ? \"Alice\" : \"Bob\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\ntemplate<class T>\nvoid read_1d(std::vector<T>& a,int64_t num){\n\ta.reserve(num);\n\tfor(int64_t i1=0;i1<num;i1++){\n\t\tT temp;\n\t\tcin>>temp;\n\t\ta.push_back(temp);\n\t}\n}\ntemplate<class T>\nvoid read_2d(std::vector<std::vector<T> >&a,int64_t x,int64_t y ){\n\ta.resize(x);\n\tfor(int64_t i1=0;i1<x;i1++){\n\t\ta[i1].reserve(y);\n\t\tfor(int64_t i2=0;i2<y;i2++){\n\t\t\tT temp;\n\t\t\tcin>>temp;\n\t\t\ta[i1].push_back(temp);\n\t\t}\n\t}\n}\ntemplate<class InputIterator>\nvoid debug(InputIterator first,InputIterator last){\n\tfor(auto i1=first;i1!=last;i1++){\n\t\tcout<<(*i1)<<endl;\n\t}\n}\n#include <limits>\n#include <vector>\n#include <queue>\nclass Vertex;\nclass Edge{\npublic:\n\tfriend class Vertex;\n\tfriend class Graph;\n\tVertex* from;\n\tVertex* to;\n\tint64_t cost;\npublic:\n\tEdge(Vertex* from,Vertex* to,int64_t cost=0){\n\t\tthis->from=from;\n\t\tthis->to=to;\n\t\tthis->cost=cost;\n\t}\n\n};\nstruct Dijkstra{\n\tint64_t d;\n\tVertex* parent;\n\tbool searched;\n};\n\nclass Vertex{\n\tfriend class Graph;\npublic:\n\n\tstd::vector<Edge*> departure;\n\tstd::vector<Edge*> arrival;\n\tbool searched=false;\n\n\tDijkstra dijk_data;\n\tint32_t id;\n\tbool count_finish=false;\n\tvoid add_edge(Edge* d){\n\t\tdeparture.push_back(d);\n\t\td->to->arrival.push_back(d);\n\t}\n\tvoid initialize_Dijkstra(){\n\t\tdijk_data.d=std::numeric_limits<int64_t>::max();\n\t\tdijk_data.parent=NULL;\n\t\tdijk_data.searched=false;\n\t}\n\tint32_t count_union(Edge* e1,Edge* e2){\n\t\tint32_t retval=1;\n\t\tcount_finish=true;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(temp==e1||temp==e2||temp->to->count_finish){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tretval+=temp->to->count_union(e1,e2);\n\t\t}\n\t\treturn retval;\n\t}\n\tint64_t game(){\n\t\tsearched=true;\n\t\tint64_t size=0;\n\t\tint64_t xor_num=0;\n\t\tfor(auto i1=departure.begin();i1!=departure.end();i1++){\n\t\t\tEdge *temp=(*i1);\n\t\t\tif(!temp->to->searched){\n\t\t\t\tsize++;\n\t\t\t\tint64_t c_ans=temp->to->game();\n\t\t\t\txor_num=xor_num^c_ans;\n\t\t\t}\n\t\t}\n\t\tif(size==0){\n\t\t\treturn 0;\n\t\t}else if(size==1){\n\t\t\treturn xor_num+1;\n\t\t}else{\n\t\t\treturn xor_num;\n\t\t}\n\t}\n};\nclass dijkstra_calc{\npublic:\n\tint64_t current_cost;\n\tVertex* from;\n\tVertex* to;\n\tdijkstra_calc(const int64_t cost, Vertex* c1,Vertex* c2):current_cost(cost),from(c1),to(c2){\n\n\t}\n};\nbool operator<(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost<b.current_cost;\n}\nbool operator>(const dijkstra_calc& a,const dijkstra_calc& b){\n\treturn a.current_cost>b.current_cost;\n}\n\n\nclass Graph{\nprivate:\n\tstd::vector<Vertex*> v;\n\tstd::vector<Edge*> e;\n\tint64_t **WF;\n\tvoid initialize_Dijkstra(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tVertex *temp=(*i);\n\t\t\ttemp->initialize_Dijkstra();\n\t\t}\n\t}\n\tstatic void dijkstra(Vertex* source,Vertex* goal=NULL){\n\t\tstd::priority_queue<dijkstra_calc,std::vector<dijkstra_calc>,std::greater<dijkstra_calc> > queue;\n\t\tqueue.push(dijkstra_calc(0,NULL,source));\n\t\twhile(true){\n\t\t\tconst dijkstra_calc temp=queue.top();\n\t\t\tqueue.pop();\n\t\t\tif(!(temp.to->dijk_data.searched)){\n\t\t\t\ttemp.to->dijk_data.searched=true;\n\t\t\t\ttemp.to->dijk_data.parent=temp.from;\n\t\t\t\ttemp.to->dijk_data.d=temp.current_cost;\n\n\t\t\t\tfor(auto i=temp.to->departure.begin();i!=temp.to->departure.end();i++){\n\t\t\t\t\tconst Edge *j=(*i);\n\t\t\t\t\tif(!j->to->dijk_data.searched){\n\t\t\t\t\t\tdijkstra_calc a(temp.current_cost+(j->cost),j->from,j->to);\n\t\t\t\t\t\tqueue.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp.to==goal){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue.empty()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tstatic const int64_t INF=1000000000000000;\n\tGraph(int32_t num_v){\n\t\tv.reserve(num_v);\n\t\tfor(int32_t i1=0;i1<num_v;i1++){\n\t\t\tVertex* temp=new Vertex();\n\t\t\ttemp->id=i1;\n\t\t\tv.push_back(temp);\n\t\t}\n\t\t/*WF=new int64_t*[num_v];\n\t\tfor(int64_t i1=0;i1<num_v;i1++){\n\t\t\tWF[i1]=new int64_t[num_v];\n\t\t}*/\n\t}\n\tvoid add_edge(int32_t from,int32_t to,int32_t cost=0){\n\t\tEdge *temp=new Edge(v[from],v[to],cost);\n\t\te.push_back(temp);\n\t\tv[from]->add_edge(temp);\n\t}\n\tvoid dijkstra(int32_t start){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start]);\n\t}\n\tvoid dijkstra(int32_t start,int32_t goal){\n\t\tinitialize_Dijkstra();\n\t\tdijkstra(v[start],v[goal]);\n\t}\n\tint64_t** WarshallFloid(){\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tWF[i1][i2]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(auto i2=v[i1]->departure.begin();i2!=v[i1]->departure.end();i2++){\n\t\t\t\tEdge *temp=(*i2);\n\t\t\t\tif(WF[i1][temp->to->id]>temp->cost){\n\t\t\t\t\tWF[i1][temp->to->id]=temp->cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tWF[i1][i1]=0;\n\t\t}\n\t\tfor(int64_t i1=0;i1<v.size();i1++){\n\t\t\tfor(int64_t i2=0;i2<v.size();i2++){\n\t\t\t\tfor(int64_t i3=0;i3<v.size();i3++){\n\t\t\t\t\tWF[i2][i3]=min(WF[i2][i3],WF[i2][i1]+WF[i1][i3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn WF;\n\t}\n\tVertex* getVertex(int place) const{\n\t\treturn v[place];\n\t}\n\tbool isBridge(Edge* e1,Edge* e2){\n\t\tfor(auto i1=v.begin();i1!=v.end();i1++){\n\t\t\tVertex* temp=(*i1);\n\t\t\ttemp->count_finish=false;\n\t\t}\n\t\tint32_t r=v[0]->count_union(e1,e2);\n\t\treturn v.size()!=r;\n\t}\n\tvector<Edge*> getEdge(){\n\t\treturn e;\n\t}\n\tvirtual ~Graph(){\n\t\tfor(auto i=v.begin();i!=v.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\tfor(auto i=e.begin();i!=e.end();i++){\n\t\t\tdelete *i;\n\t\t}\n\t\t/*for(int64_t i1=0;i1<v.size();i1++){\n\t\t\tdelete[] WF[i1];\n\t\t}\n\t\tdelete[] WF;*/\n\t}\n};\nint main(){\n\tint64_t n;\n\tcin>>n;\n\tGraph graph(n);\n\tfor(int64_t i1=0;i1<n-1;i1++){\n\t\tint64_t temp1,temp2;\n\t\tcin>>temp1>>temp2;\n\t\tgraph.add_edge(temp1-1,temp2-1);\n\t\tgraph.add_edge(temp2-1,temp1-1);\n\t}\n\tif(graph.getVertex(0)->departure.size()==1){\n\t\tcout<<\"Alice\"<<endl;\n\t}else{\n\t\tif(graph.getVertex(0)->game()==0){\n\t\t\tcout<<\"Bob\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Alice\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n\nvector <int> conn[100050];\nvector <int> son[100050];\nint gr[100050];\nbool dchk[100050];\nvoid DFS(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) {\n\t\tif (dchk[it]) continue;\n\t\tson[n].push_back(it);\n\t\tDFS(it);\n\t}\n\n\tfor (auto it : son[n]) gr[n] ^= gr[it] + 1;\n}\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i < N; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tconn[t1].push_back(t2);\n\t\tconn[t2].push_back(t1);\n\t}\n\tDFS(1);\n\tif (gr[1]) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 200010;\nint f[N];\nstruct node {\n\tint to, nxt;\n} g[N];\nint lst[N], gl;\nvoid add(int x, int y) { g[++gl] = (node) {y, lst[x]}; lst[x] = gl; }\nvoid dfs(int u, int ff) {\n\tint c1 = 0, c2 = 0;\n\tfor (int i = lst[u]; i; i = g[i].nxt) {\n\t\tint v = g[i].to; if (v == ff) continue;\n\t\tdfs(v, u);\n\t\tf[u] ^= f[v] + 1;\n//if (f[v]) c1++;\n\t\t//else c2++;\n\t}\t\n/*\tif (!c1) {\n\t\tif (c2) f[u] = c2 & 1;\t\t\n\t}\n\telse f[u] = c1 & 1;*/\n//\tprintf(\"[%d] %d\\n\", u, f[u]);\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = gi<int>(), y = gi<int>();\n\t\tadd(x, y); add(y, x);\n\t}\n\tdfs(1, 0);\n\tputs(f[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\n//#include<ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vll vector<ll>\n#define vpll vector<pll>\n#define vpii vector<pii>\n#define pb push_back\n#define eb emplace_back\n#define mt make_tuple\n#define MP make_pair\n#define fs first\n#define sc second\n#define F first\n#define S second\n#define nl \"\\n\"\n#define asche cerr<<\"Ekhane asche\\n\";\n#define pf printf\n#define sf scanf\n#define mem(a,x) memset(a,x,sizeof(a))\n#define SZ(v) (int)v.size()\n#define all(v) v.begin(),v.end()\n#define one(x) __builtin_popcount(x)\n#define fout(x) fixed<<setprecision(x)\n#define BeatMeScanf ios_base::sync_with_stdio(false)\n//int dx[]={1,0,-1,0,1,-1,-1,1};\n//int dy[]={0,1,0,-1,1,1,-1,-1};\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define debug(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); deb(_it, args); }\nvoid deb(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid deb(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    deb(++it, args...);\n}\n//template <typename T> using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nnamespace IO\n{\n    #define in() ( { int a ; scanf(\"%d\",&a); a; } )\n    #define LL() ( { ll a ; scanf(\"%lld\",&a); a; } )\n    #define ULL() ( { ull a ; scanf(\"%llu\",&a); a; } )\n    #define DD() ({ double a; scanf(\"%lf\", &a); a;})\n    #define CC() ( { char a ; scanf(\"%c\",&a); a; } )\n    #define pf1(a) printf(\"%d\\n\",a)\n    #define pf1ll(a) printf(\"%lld\\n\",a)\n}\nusing namespace IO;\n\nconst int mod=1e9+7;\nconst int N=3e5+9;\nconst double eps=1e-9;\nconst double PI=acos(-1.0);\nll qpow(ll n,ll k) {ll ans=1;assert(k>=0);n%=mod;while(k>0){if(k&1) ans=(ans*n)%mod;n=(n*n)%mod;k>>=1;}return ans%mod;}\n\nvi g[N];\nint dfs(int u,int pre)\n{\n    int ans=0;\n    for(auto v:g[u]) if(v!=pre) ans^=(1+dfs(v,u));\n    return ans;\n}\nint32_t main()\n{\n    int n=in();\n    for(int i=1;i<n;i++){\n        int u=in(),v=in();\n        g[u].eb(v);\n        g[v].eb(u);\n    }\n    int ans=dfs(1,0);\n    if(ans) puts(\"Alice\");\n    else puts(\"Bob\");\n    return 0;\n}\n///Before submit=>\n///    *check for integer overflow,array bounds\n///    *check for n=1\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n // dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(t[i]%2){\n      ans++;\n    }else ans--;\n  }\n  ans=abs(ans);\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: test.cpp\n    > Author: Akira \n    > Mail: qaq.febr2.qaq@gmail.com \n ************************************************************************/\n\n#include<bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*4\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1E9+7;\nconst double eps = 1e-6;\n#define bug cout<<88888888<<endl;\n#define debug(x) cout << #x\" = \" << x << endl;\ntemplate<typename T> T abs(T val){return val>0?val:-val;}\nint N;\nstruct Edge\n{\n    int v,next;\n}edge[MaxM];\nint cont,head[MaxN];\nvoid add(int u, int v)\n{\n    edge[cont].v = v, edge[cont].next = head[u], head[u] = cont++;\n}\n\nbool DFS(int u, int pre)\n{\n    bool flag = false;\n    int son = 0;\n    for(int i=head[u];i!=-1;i=edge[i].next)\n    {\n        int v = edge[i].v;\n        if(v==pre) continue;\n        flag ^= DFS(v,u);\n        son++;\n        //debug(u)\n        //debug(flag)\n    }\n    if(son>1) return flag;\n    else if(son==1) return true;\n    else return false;\n}\nvoid solve()\n{\n    if(DFS(1,0)) puts(\"Alice\");\n    else puts(\"Bob\");\n}\n\nvoid init()\n{\n    cont = 0;\n    MST(head,-1);\n}\nint main()\n{\n    //std::ios::sync_with_stdio(false);\n    while(scanf(\"%d\", &N)!=EOF)\n    {\n        init();\n        int a,b;\n        for(int i=1;i<N;i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            add(a,b);add(b,a);\n        }\n        solve();\n    }\n    //system(\"pause\");\n    //printf(\"%lld\\n\", (x%mod+mod)%mod );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1e5+3;\nstruct edge{int v,nxt;}g[N+N];\nint n,head[N],k,f[N];\ninline void Insert(int u,int v){g[++k]=(edge){v,head[u]};head[u]=k;}\nvoid Dfs(int u,int fa){\n\tint v;\n\tfor(int i=head[u];i;i=g[i].nxt)if((v=g[i].v)!=fa)\n\t  Dfs(v,u),f[u]^=f[v]+1;\n}\nint main(){\n\tint u,v;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t  scanf(\"%d%d\",&u,&v),Insert(u,v),Insert(v,u);\n\tDfs(1,0);\n\tputs(f[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n// #include <bits/extc++.h>\nusing namespace std;\n\n#define debug(s) cout << #s << \" = \" << s << endl\n#define all(v) (v).begin(), (v).end()\n#define KeepUnique(v) (v).erase( unique(all(v)), v.end() )\n#define MEMSET(a, val) memset(a, val, sizeof (a))\n#define PB push_back\n#define endl '\\n'\ntypedef long long ll;\n\ninline int myrand(int l, int r) {\n\tint ret = rand(); ret <<= 15; ret ^= rand();\n\tif(ret < 0) ret = -ret; ret %= (r-l+1); ret += l;\n\treturn ret;\n}\n\ntemplate <typename F, typename S>\nostream& operator << (ostream& os, const pair< F, S>& p) {\n\treturn os<<\"(\" <<p.first<<\", \"<<p.second<<\")\"; }\n\ntypedef pair<int, int> ii;\n\ntemplate<typename T> using min_pq =\n\tstd::priority_queue<T, vector<T>, greater<T> >;\n\n//int dx[] = {-1, +0, +1, +0};\n//int dy[] = {+0, +1, +0, -1};\n\nconst int maxn = 100005;\n\nint n;\nvector<int> g[maxn];\nint grundy[maxn], ok[maxn];\n\nvoid dfs(int u, int par) {\n\tfor(int v : g[u]) {\n\t\tif(v - par) {\n\t\t\tdfs(v, u);\n\t\t\tgrundy[u] ^= grundy[v];\n\t\t}\n\t}\n}\n\nint32_t main () {\n    // freopen(\"in\", \"r\", stdin);\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n    \tint u, v; cin >> u >> v;\n    \tg[u].push_back(v);\n    \tg[v].push_back(u);\n    }\n    dfs(1, -1);\n    int s = 0;\n    for(int v : g[1]) {\n    \ts ^= grundy[v];\n    }\n    puts(s ? \"Alice\" : \"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> g(N);\n    REP(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    auto dfs = [&](auto f, int v, int p) -> int {\n        int ret = 0;\n        FORE(w, g[v]) {\n            if (w == p) continue;\n            ret ^= f(f, w, v) + 1;\n        }\n        return ret;\n    };\n    cout << (dfs(dfs, 0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read()\n{int x=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') c=getchar();\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nreturn x;\n}\nint sg[100005],head[100005],nxt[200005],v[200005],n,tot=0;\ninline void add(int a,int b)\n{tot++;nxt[tot]=head[a];head[a]=tot;v[tot]=b;}\nvoid dfs(int pos,int f)\n{for (int i=head[pos];i;i=nxt[i])\n{if (v[i]==f) continue;\ndfs(v[i],pos);\nsg[pos]^=(sg[v[i]]+1);\n}\n}\nint main (){\n\tint i,a,b;\n\tn=read();\n\tfor (i=1;i<n;i++)\n\t{a=read();b=read();\n\tadd(a,b);add(b,a);\n\t}\n\tdfs(1,0);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\nint N;\nvector<int> G[100005];\n\nint dfs(int v, int p){\n  int res = 0;\n  for(int u : G[v]){\n    if(u == p) continue;\n    res ^= dfs(u, v) + 1;\n  }\n  return res;\n}\n\nint main(){\n  cin >> N;\n  REP(i,N-1){\n    int x, y;\n    cin >> x >> y;\n    x--;y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii; \n\nconst int N = 2e5 + 10; \nvector<int> adj[N]; \n\nint dfs(int u, int par = -1) {\n\tint g = 0; \n\tfor(int v : adj[u]) if(v - par) \n\t\tg ^= dfs(v, u) + 1; \n\treturn g; \n}\nint main(int argc, char const *argv[]) {\n\tint n; cin >> n; \n\tfor(int i = 1; i < n; i++) {\n\t\tint u, v; \n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\t\n\tputs(dfs(1) ? \"Alice\" : \"Bob\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 0;\n    } else {\n        for (auto t : sons) {\n            gr[cur] ^= (gr[t] + 1);\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    if (!gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\n\nvi g[N];\n\nint dfs(int v, int par = -1) {\n    int ret = 0;\n    for (int to : g[v]) {\n        if (to == par)\n            continue;\n        ret ^= (dfs(to, v) + 1);\n    }\n    return ret;\n}\n\nvoid smain() {\n    int n;\n    cin >> n;\n    fori (i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if (dfs(1)) {\n        cout << \"Alice\\n\";\n    } else {\n        cout << \"Bob\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define rf(i, a, b) for(int i = a; i >= b; i--)\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)x.size()\n#define lb lower_bound\n#define ub upper_bound\n\ntypedef long long ll;\ntypedef long double f80;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint pct(int x) { return __builtin_popcount(x); }\nint pct(ll x) { return __builtin_popcountll(x); }\nint bt(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\nint bt(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x))\nint cdiv(int a, int b) { return a / b + !(a < 0 || a % b == 0); }\nll cdiv(ll a, ll b) { return a / b + !(a < 0 || a % b == 0); }\nint nxt_C(int x) { int c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\nll nxt_C(ll x) { ll c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\n\nvector<int> get_bits(int mask) {\n\tvector<int> bb;\n\twhile(mask) { int b = bt(mask); bb.pb(b); mask ^= (1 << b); }\n\treverse(all(bb));\n\treturn bb;\n}\n\nint get_mask(vector<int> v) {\n\tint mask = 0;\n\tfor(int x : v) { mask ^= (1 << x); }\n\treturn mask;\n}\n\ntemplate<typename T>\nvoid uniq(vector<T> &v) { sort(all(v)); v.resize(unique(all(v)) - v.begin()); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll rand(ll l, ll r){\n\tuniform_int_distribution<ll> uid(l, r);\n\treturn uid(rng);\n}\n\nvoid sc() {}\n\ntemplate <typename Head, typename... Tail>\nvoid sc(Head &H, Tail &... T) { cin >> H; sc(T...); }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[L:\" << __LINE__ << \"][\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// #ifndef LOCAL\n// string to_string(__int128 x) {\n// \tstring s = \"\";\n// \tbool neg = 0;\n// \tif(x < 0) { s += \"-\"; neg = 1; x = -x; }\n// \tif(!x) s += '0';\n// \twhile(x) {\n// \t\tint rem = x % 10;\n// \t\ts += to_string(rem);\n// \t\tx /= 10;\n// \t}\n// \treverse(s.begin() + neg, s.end());\n// \treturn s;\n// }\n// #endif\n\nconst int mod = 1e9 + 7; // 998244353;\n\nint pwr(int a,ll b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans * 1LL * a) % mod;\n\t\ta = (a * 1LL * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\n/*\n\tLookout for overflows!!\n\tCheck array sizes!!\n\tClear before test cases!!\n\tUse the correct modulo!!\n\tCheck for corner cases!!\n\tAre you forgetting something?!\n\tRead problem statement carefully!!!\n*/\n\nconst int N = 1e5 + 5;\nvector<int> g[N];\n\nint dfs(int u,int p) {\n    int ans = 0;\n    for(int v : g[u]) {\n        if(v != p) {\n            ans ^= (dfs(v, u) + 1);\n        }\n    }\n    return ans;\n}\n\nvoid solve() {\n\tint n;\n    sc(n);\n    fr(i, 1, n - 1) {\n        int u, v;\n        sc(u, v);\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    int ans = dfs(1, 0);\n    cout << ((ans) ? \"Alice\" : \"Bob\");\n}\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t = 1;\n\t// cin >> t;\n\tfor(int tt = 1; tt <= t; tt++) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\ntemplate<typename T>\nvoid fin(T const& t){ std::cout << t << std::endl; exit(0); }\n\nint main() {\n  std::cin.tie(0); std::ios::sync_with_stdio(false);\n  int N; std::cin >> N;\n  std::vector<std::vector<int>> G(N);\n  for(int i = 0; i < N-1; ++i) {\n    int x, y; std::cin >> x >> y; --x; --y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  auto dfs = [&](auto&& f, int v, int p)->int {\n    int res = 0;\n    for(int c: G[v])if(c != p) res ^= f(f, c, v);\n    return res+1;\n  };\n  int ans = dfs(dfs, 0, -1);\n  fin(ans==1? \"Bob\": \"Alice\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int Nmax=114514;\nvi g[Nmax];\nint dfs(int v,int p){\n\tint res=0;\n\tfor(auto ch:g[v])if(ch!=p)\n\t\tres^=dfs(ch,v);\n\treturn res+1;\n}\n\nsigned main(){\n\tint n=read();\n\tREP(i,n-1){\n\t\tint x=read()-1,y=read()-1;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t}\n\tif(dfs(0,-1)==1)\n\t\tcout<<\"Bob\"<<endl;\n\telse\n\t\tcout<<\"Alice\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nvector<int> a[100005];\nint d[100005],f[100005];\nbool v[100005];\nvoid dfs (int x) {\n\tif (v[x]) return;\n\tv[x]=true;\n\tint i;\n\tfor (i=0;i<(int)a[x].size();i++) {\n\t\tif (!v[a[x][i]]) d[a[x][i]]=d[x]+1;dfs(a[x][i]);\n\t}\n}\nint main ( ) {\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ta[x].push_back(y);a[y].push_back(x);\n\t}\n\td[1]=1;\n\tfor (i=1;i<=n;i++) dfs(i);\n\tfor (i=1;i<=n;i++) f[d[i]]++;\n\tfor (i=2;i<=n;i++) {\n\t\tif (f[i]%2==1) {puts(\"Alice\");return 0;}\n\t}\n\tputs(\"Bob\");\n\treturn 0;\n}\n/*\nSample Input 1\n5\n1 2\n2 3\n2 4\n4 5\nSample Output 1\nAlice\nSample Input 2\n5\n1 2\n2 3\n1 4\n4 5\nSample Output 2\nBob\nSample Input 3\n6\n1 2\n2 4\n5 1\n6 3\n3 2\nSample Output 3\nAlice\nSample Input 4\n7\n1 2\n3 7\n4 6\n2 3\n2 4\n1 5\nSample Output 4\nBob\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\nint dp[100005],N;\nint sz[100005];\nvector<int> G[100005];\nbitset<100005> U;\nvoid dfs(int nod,int tata)\n{\n    sz[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(it==tata)continue;\n        dfs(it,nod);\n    }\n    U.reset();\n    for(auto it:G[nod])\n    {\n        if(it==tata)continue;\n        sz[nod]+=sz[it];\n        U[dp[it]]=1;\n    }\n    U[sz[nod]]=1;\n    while(U[dp[nod]])++dp[nod];\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<N;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1,0);\n    int rez=0;\n    for(auto it:G[1])\n    {\n        rez^=dp[it];\n    }\n    if(rez!=0)cout<<\"Alice\";\n    else cout<<\"Bob\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nvector<vector<int>> G;\n\nint dp[100001];\n\nint grundy(int v, int pre)\n{\n    if (~dp[v]) return dp[v];\n\n    int g = 0;\n    for (auto u : G[v]) {\n        if (u == pre) continue;\n        g ^= (grundy(u, v) + 1);\n    }\n\n    return dp[v] = g;\n}\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    G.resize(N);\n    rep(i, N-1) {\n        int X, Y;\n        cin >> X >> Y;\n        X--, Y--;\n        G[X].push_back(Y);\n        G[Y].push_back(X);\n    }\n\n    memset(dp, -1, sizeof(dp));\n    cout << (grundy(0, -1) != 0 ? \"Alice\" : \"Bob\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 42;\nint mx[maxn];\nvector<int> g[maxn];\n\nvoid dfs(int v = 0, int p = 0)\n{\n    set<int> lol;\n    int c = 0;\n    for(auto u: g[v])\n    {\n        if(u == p)\n            continue;\n        dfs(u, v);\n        c++;\n        mx[v] ^= 1 + mx[u];\n    }\n    //if(c == 1)\n    //    mx[v] = 1;\n}\n\nsigned main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    for(int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        g[u - 1].push_back(v - 1);\n        g[v - 1].push_back(u - 1);\n    }\n    dfs();\n    cout << (mx[0] == 0 ? \"Bob\" : \"Alice\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nvi g[125252];\nvi children[125252];\n\nvoid dfs(int p,int bef){\n  for(int to : g[p])if(to!=bef){\n    children[p].push_back(to);\n    dfs(to,p);\n  }\n}\n\nint gru(int p){\n  int ret = 0;\n  for(int to : children[p]){\n    ret ^= (gru(to)+1);\n  }\n  return ret;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n-1){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    --x;--y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(0,-1);\n  if(children[0].size()==1){\n    puts(\"Alice\");\n    return 0;\n  }\n  int a = gru(0);\n  puts(a==0?\"Bob\":\"Alice\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int maxn = 1e5 +100;\nvector<int> G[maxn];\nint sg[maxn];\nvoid dfs(int x, int fa){\n    sg[x] = 0;\n    for(auto to : G[x]){\n        if(to == fa) continue;\n        dfs(to, x);\n        sg[x] ^= (sg[to]+1);\n    }\n}\n\nint main()\n{\n    int n, x, y;\n    cin>>n;\n    for(int i = 1; i < n; i++){\n        scanf(\"%d %d\", &x, &y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1, 1);\n    if(sg[1]) cout<<\"Alice\";\n    else cout<<\"Bob\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <cmath>\nconst int MaxN = 1e6;\nusing namespace std;\nint pre[2 * MaxN + 5] , last[MaxN + 5] , other[MaxN + 5];\nint all , n , res[MaxN + 5];\nvoid Build(int u , int v){\n\tpre[++all] = last[u];\n\tlast[u] = all;\n\tother[all] = v;\n}\nvoid dfs(int x , int fa){\n\tint ed = last[x];\n\twhile(ed != -1){\n\t\tint dr = other[ed];\n\t\tif(dr != fa){\n\t\t\tdfs(dr , x);\n\t\t\tres[x] ^= res[dr] + 1;\n\t\t}\n\t\ted = pre[ed];\n\t}\n}\nint main()\n{\n\twhile(~scanf(\"%d\" , &n)){\n\t\tall = -1;\n\t\tmemset(last , -1 , sizeof(last));\n\t\tmemset(res , 0 , sizeof(res));\n\t\tfor(int i = 1;i <= n - 1;i++){\n\t\t\tint u , v;\n\t\t\tscanf(\"%d%d\" , &u , &v);\n\t\t\tBuild(u , v); Build(v , u);\n\t\t}\n\t\tdfs(1 , 0);\n\t\tif(res[1]) printf(\"Alice\\n\");\n\t\telse printf(\"Bob\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n#define mat vector<vector<int>>\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\nconst db EPS = 1e-7;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nint N;\nvector<int> G[100010];\n\nint dfs(int v, int p){\n    int res = 0;\n    int son = 0;\n    for(auto u : G[v]){\n        if(u != p) res ^= dfs(u, v), son++; \n    }\n    return res + (son == 1 ? 1 : 0);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    for(int i = 1; i < N; i++){\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n \n    }\n    cout << (dfs(1, 0) == 0 ? \"Bob\" : \"Alice\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dp[100005],N;\nvector<int> G[100005];\nvoid dfs(int nod,int tata)\n{\n    int cate=0,val=1;\n    for(auto it:G[nod])\n    {\n        int tmp;\n        if(it==tata)continue;\n        dfs(it,nod);tmp=dp[it];\n        cate+=tmp;\n        val^=(!tmp);\n    }\n    dp[nod]=((!val)||(cate%2==1));\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<N;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1,0);\n    int cate=0,val=0;\n    for(auto it:G[1])\n    {\n        cate+=(dp[it]);\n        val^=(!dp[it]);\n    }\n    if(cate%2==0&&val==1)cout<<\"Alice\";\n    else if(cate%2==1)cout<<\"Alice\";\n    else cout<<\"Bob\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao on 2019/11/19.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nll cmp(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    int n;\n    cin>>n;\n    int ans=0;\n    for(int i=0;i<n-1;i++){\n        int x,y;\n        cin>>x>>y;\n        if(x==1||y==1)\n            ans++;\n    }\n    if(ans==1)\n        cout<<\"Alice\"<<endl;\n    else if(ans%2==0&&(n-1)%2==0)\n        cout<<\"Bob\"<<endl;\n    else if(ans%2==0&&(n-1)%2!=0)\n        cout<<\"Alice\"<<endl;\n    else if(ans%2!=0&&(n-1)%2!=0)\n        cout<<\"Bob\"<<endl;\n    else if(ans%2!=0&&(n-1)%2==0)\n        cout<<\"Alice\"<<endl;\n//-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nvector<int> g[100111];\nint n,sg[100111];\nvoid dfs(int x,int f=0)\n{\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f)\n\t\t{\n\t\t\tdfs(g[x][i],x);\n\t\t\tsg[x]^=sg[g[x][i]]+1;\n\t\t}\n}\nint main()\n{\n\tget1(n);\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tget2(u,v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(1);\n\tputs(sg[1]?\"Alice\":\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n;\nvector<int>edge[1000005];\nint dfs(int v,int u){\n\tvector<int>vec; int X = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint Y = dfs(edge[v][i],v);\n\t\tvec.pb(Y); X^=(Y+1); \n\t}\n\treturn X;\n}\nint main(){\n\tcin >> n ;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b; cin >> a >> b;\n\t\tedge[a].pb(b); edge[b].pb(a);\n\t}\n\tif(dfs(1,-1)) puts(\"Alice\"); else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<int> gr[114514];\nint cal(int v,int u){\n\t//cout<<v<<' '<<u<<endl;\n\tint ret=0;\n\trep(i,gr[v].size()){\n\t\tint w=gr[v][i];\n\t\tif(w==u) continue;\n\t\tret^=cal(w,v);\n\t}\n\treturn ret+1;\n}\nint main()\n{\n\tint n,x,y;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>x>>y;x--;y--;\n\t\tgr[x].pb(y);gr[y].pb(x);\n\t}\n\tif(cal(0,-1)==1) cout<<\"Bob\"<<endl;else cout<<\"Alice\"<<endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <iterator>\n#include <functional>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <stdio.h>\n#include <unordered_set>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LD, LD> PDD;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VCH;\ntypedef vector<LD> VLD;\ntypedef vector<string> VS;\ntypedef vector<VS> VSS;\ntypedef vector<VI> VVI;\ntypedef vector<VLL> VVLL;\ntypedef vector<VCH> VVCH;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<PDD> VPDD;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n#define next fake_next\n#define prev fake_prev\n#define left fake_left\n#define right fake_right\n\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LD PI = acos(-1.0);\nconst LL mod = 1000000007;\nconst LL INF = 1e9;\nconst LL LINF = 1e18;\nconst LL MAXN = 100 + 1;\nconst LL MAXS = 100 + 1;\nconst LL MAXT = 100 + 1;\n\nvoid ok()\n{\n\tcout << \"YES\";\n\texit(0);\n}\n\nvoid bad()\n{\n\tcout << \"NO\";\n\texit(0);\n}\n\nint n;\nVVI g;\nVCH used;\nVI grundy;\n\nvoid dfs(int v)\n{\n\tused[v] = 1;\n\tVI h;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\tdfs(i);\n\t\t\th.push_back(grundy[i]);\n\t\t}\n\t\n\tfor (auto i : h)\n\t\tgrundy[v] ^= (i + 1);\n\n\t++grundy[v];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"In.txt\", \"w\", stdout);\n\n\tcin >> n;\n\tg.resize(n);\n\tint u, v;\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tused.assign(n, 0);\n\tgrundy.assign(n, 0);\n\n\tdfs(0);\n\tif (grundy[0] > 1)\n\t\tcout << \"Alice\";\n\telse\n\t\tcout << \"Bob\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link renamelink\n#define next renamenext\n#define prev renameprev\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string& fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 1e5 + 100;\n\nint n;\nvector<int> G[N];\nint val[N];\nint f[N];\n\nvoid dfs(int u, int p) {\n  int cnt = 0;\n  int tot = 0;\n  for (auto v : G[u]) {\n    if (v == p) continue;\n    dfs(v, u);\n    if (f[v]) ++cnt;\n    ++tot;\n  }\n  tot -= cnt;\n  if(tot & 1) {\n    f[u]=1;\n  } else {\n    if(cnt&1) f[u] = 1;\n  }\n}\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n  dfs(0, -1);\n  if (f[0]) {\n    puts(\"Alice\");\n  } else {\n    puts(\"Bob\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int N = 100000 + 10;\n\nint n;\nstd::vector<int> adj[N];\n\nbool dfs(int a, int fa = -1) {\n  int cnt[2] = {0, 0};\n  for (auto b : adj[a]) if (b != fa) ++cnt[dfs(b, a)];\n  return (cnt[0] | cnt[1]) & 1;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = n - 1; i--;) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  puts(dfs(1) ? \"Alice\" : \"Bob\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nvector<int> g[100100];\n\nbool calc(int v, int prev) {\n    int w = 0, l = 0;\n    for (int i = 0; i < g[v].size(); i++) {\n        if (g[v][i] != prev) {\n            if (calc(g[v][i], v)) w++;\n            else l++;\n        }\n    }\n    return !(w % 2 == 0 && l % 2 == 0);\n}\n\nbool solve() {\n    return calc(1, -1);\n}\n\nvoid input() {\n    cin >> n;\n    int x, y;\n    for (int i = 0; i < n-1; i++) {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << (solve()?\"Alice\":\"Bob\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, sg[N];\nvector<int> nxt[N];\n\nvoid dfs(int x, int fa) {\n    for (int i = 0; i < nxt[x].size(); i++) {\n        int y = nxt[x][i];\n        if (y == fa) continue;\n        dfs(y, x);\n        sg[x] ^= (sg[y] + 1);\n    }\n}\n\nint main() {\n    cin >> n;\n    rep(i, 1, n - 1) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        nxt[x].push_back(y), nxt[y].push_back(x);\n    }\n    dfs(1, 0);\n    puts(sg[1] ? \"Alice\" : \"Bob\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<int>E[200000];\n\nint dfs(int v,int p){\n\tint x=0;\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tx^=dfs(u,v);\n\t}\n\tif(v==0)return x;\n\treturn x+1;\n}\nint main(){\n\tint n;scanf(\"%d\",&n);\n\trep(i,n-1){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);a--;b--;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tputs(dfs(0,-1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long N;\nvector<vector<long long> > V;\n\nlong long DFS(long long P, long long Q) {\n\tlong long COUNT = 0;\n\tfor (long long NP : V[P]) {\n\t\tif (NP != Q) {\n\t\t\tCOUNT ^= DFS(NP, P);\n\t\t}\n\t}\n\treturn COUNT + 1;\n}\n\nint main() {\n\tcin >> N;\n\tV.resize(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tlong long X, Y;\n\t\tcin >> X >> Y;\n\t\tX--, Y--;\n\t\tV[X].push_back(Y);\n\t\tV[Y].push_back(X);\n\t}\n\tlong long XOR = 0;\n\tfor (long long P : V[0]) {\n\t\tXOR ^= DFS(P, 0);\n\t}\n\tcout << (XOR == 0 ? \"Bob\" : \"Alice\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint mex[101010];\n\n\nint dfs(int cur,int pre) {\n\t\n\tFORR(e,E[cur]) if(e!=pre) mex[cur]^=dfs(e,cur)+1;\n\treturn mex[cur];\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tif(dfs(0,-1)) cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <atcoder/all>\nusing namespace std;\n// using namespace atcoder;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n#ifdef __LOCAL\n#define debug(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n#define debugArray(x, n)                                      \\\n  cerr << __LINE__ << \": \" << #x << \" = {\";                   \\\n  for (long long hoge = 0; (hoge) < (long long)(n); ++(hoge)) \\\n    cerr << ((hoge) ? \",\" : \"\") << x[hoge];                   \\\n  cerr << \"}\" << '\\n'\n#define debugMatrix(x, h, w)                                         \\\n  cerr << __LINE__ << \": \" << #x << \" =\\n\";                          \\\n  for (long long hoge = 0; (hoge) < (long long)(h); ++(hoge)) {      \\\n    cerr << ((hoge ? \" {\" : \"{{\"));                                  \\\n    for (long long fuga = 0; (fuga) < (long long)(w); ++(fuga))      \\\n      cerr << ((fuga ? \", \" : \"\")) << x[hoge][fuga];                 \\\n    cerr << \"}\" << (hoge + 1 == (long long)(h) ? \"}\" : \",\") << '\\n'; \\\n  }\n#else\n#define debug(x) (void(0))\n#define debugArray(x, n) (void(0))\n#define debugMatrix(x, h, w) (void(0))\n#endif\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int N;\n  cin >> N;\n  vector<int> tree[N];\n  for (int i = 0; i < N - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    tree[x].push_back(y);\n    tree[y].push_back(x);\n  }\n  int grundy[N];\n  function<int(int, int)> dfs = [&](int v, int p) {\n    grundy[v] = 0;\n    for (int u : tree[v])\n      if (u != p) {\n        grundy[v] ^= dfs(u, v) + 1;\n      }\n    return grundy[v];\n  };\n  cout << (dfs(0, -1) == 0 ? \"Bob\" : \"Alice\") << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> edge[100010];\n\nint dfs(int from, int par) {\n\tint ret = 0;\n\tfor(int to : edge[from]) {\n\t\tif(to == par) continue;\n\t\tret ^= dfs(to, from) + 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n; cin >> n;\n\tfor(int i = 0; i < n - 1; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\t--x, --y;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tif(dfs(0, -1) == 0) {\n\t\tcout << \"Bob\" << '\\n';\n\t} else {\n\t\tcout << \"Alice\" << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <ios>\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int> > adjlist;\nstd::vector<std::vector<int> > children;\nbool vis[100005] = {};\n\nvoid dfs(int x)\n{\n    for (std::vector<int>::iterator it = adjlist[x].begin(); it != adjlist[x].end(); it++)\n    {\n        if (!vis[*it])\n        {\n            vis[*it] = true;\n            children[x].push_back(*it);\n            dfs(*it);\n        }\n    }\n}\n\nint nim(int x)\n{\n    if (children[x].size() == 0)\n        return 0;\n    else if (children[x].size() == 1)\n        return nim(*children[x].begin())+1;\n    else\n    {\n        int nm = 0;\n        for (std::vector<int>::iterator it = children[x].begin(); it != children[x].end(); it++)\n            nm ^= nim(*it)+1;\n        return nm;\n    }\n}\n\nint main()\n{\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    std::cout.tie(NULL);\n    int n, x, y;\n    std::cin >> n;\n    adjlist.resize(n+5);\n    children.resize(n+5);\n    for (int i = 0; i < n-1; i++)\n    {\n        std::cin >> x >> y;\n        x--; y--;\n        adjlist[x].push_back(y);\n        adjlist[y].push_back(x);\n    }\n    vis[0] = true;\n    dfs(0);\n    std::cout << (nim(0) == 0 ? \"Bob\" : \"Alice\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\nusing namespace std;\nint n,x,y,cnt[maxn];\nvector<int> m[maxn];\nint ans;\nvoid dfs(int u,int p) {\n\tcnt[u]=0;\n\tfor (int i=0;i<m[u].size();i++) {\n\t\tint v=m[u][i];\n\t\tif (v!=p) {\n\t\t\tdfs(v,u);\n\t\t\tcnt[u]++;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tm[x].push_back(y);\n\t\tm[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (cnt[i]%2==1)\n\t\t\tans++;\n\tif (ans%2==1||cnt[1]%2==1)\n\t\tprintf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nvector<int> v[1000001];\nint t[1000001];\nbool b[100001];\nint x,y,n;\nvoid dfs(int x){\n  b[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!b[v[x][i]])dfs(v[x][i]);\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>x>>y;\n    t[x]++;\n    t[y]++;\n    v[x].push_back(y);\n  }\n  b[1]=1;\n  dfs(1);\n  int ans=0;\n  for(int i=0;i<n+1;i++){\n    if(t[i]%2&&b[i]){\n      ans++;\n    }else ans--;\n  }\n  ans=abs(ans);\n  if(ans%2||(int)v[1].size()==1&&(int)v[1].size())cout<<\"Alice\"<<endl;\n  else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, l, r) for (int i = (int)(l); i < (int)(r); i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)x.size())\ntemplate <class T> bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <class T> using V = vector<T>;\nusing P = pair<int, int>;\n\n/*\n */\n\nint n;\nV<int> es[101010];\n\nint dfs(int v, int p){\n  int g = 0;\n  for(int to : es[v]){\n    if(to == p) continue;\n    g ^= dfs(to, v) + 1;\n  }\n\n  return g;\n}\n\nsigned main() {\n  cin >> n;\n  rep(i, 0, n-1){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    es[x].emplace_back(y);\n    es[y].emplace_back(x);\n  }\n\n  cout << (dfs(0, -1) ? \"Alice\" : \"Bob\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100010;\n\nint head[N], num, i, n, x, y;\nstruct edge {\n\tint to, nxt;\n} e[N * 2];\n\nint rd() {\n\tint x = 0; char c = getchar();\n\twhile (c > '9' || c < '0') c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();\n\treturn x;\n}\n\nvoid add_edge(int x, int y) {\n\te[++num].nxt = head[x], e[head[x] = num].to = y;\n}\n\nint sg(int x, int p) {\n\tint now = 0, i, y;\n\tfor (i = head[x]; i; i = e[i].nxt) {\n\t\ty = e[i].to;\n\t\tif (y == p) continue;\n\t\tnow ^= (sg(y, x) + 1);\n\t}\n\treturn now;\n}\n\nint main() {\n\tn = rd();\n\tfor (i = 1; i < n; i++) {\n\t\tx = rd(), y = rd();\n\t\tadd_edge(x, y), add_edge(y, x);\n\t}\n\tif (sg(1, 1)) puts(\"Alice\"); else puts(\"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<stack>\n#include<set>\n#include<unordered_set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<algorithm>\n#include<list>\n#include<functional>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define y0 y12\n#define y1 y22\n#define INF 1987654321\n#define PI 3.141592653589793238462643383279502884\n#define fup(i,a,b,c) for(int (i)=(a);(i)<=(b);(i)+=(c))\n#define fdn(i,a,b,c) for(int (i)=(a);(i)>=(b);(i)-=(c))\n#define MEM0(a) memset((a),0,sizeof(a));\n#define MEM_1(a) memset((a),-1,sizeof(a));\n#define ALL(a) a.begin(),a.end()\n#define SYNC ios_base::sync_with_stdio(false);cin.tie(0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ld, ld> Pd;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<double> Vd;\ntypedef vector<Pi> VPi;\ntypedef vector<Pll> VPll;\ntypedef vector<Pd> VPd;\ntypedef tuple<int, int, int> iii;\ntypedef tuple<int,int,int,int> iiii;\ntypedef tuple<ll, ll, ll> LLL;\ntypedef vector<iii> Viii;\ntypedef vector<LLL> VLLL;\ntypedef complex<double> base;\nconst ll MOD = 1000000007;\nll POW(ll a, ll b, ll MMM = MOD) {ll ret=1; for(;b;b>>=1,a=(a*a)%MMM)if(b&1)ret=(ret*a)% MMM; return ret; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\nll lcm(ll a, ll b) { if (a == 0 || b == 0)return a + b; return a*(b / gcd(a, b)); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1 }, dy[] = { 1,0,-1,0,1,-1,1,-1 };\n\nVi v[100001];\nint dfs(int N,int p)\n{\n\tint res=0;\n\tfor(int next:v[N])\n\t{\n\t\tif(next==p)continue;\n\t\tres^=dfs(next,N)+1;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfup(i,1,n-1,1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tputs(dfs(1,-1)?\"Alice\":\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nint n;\nstd::vector<int> G[100000];\n\nint solve(int x, int p, int z){\n  int r = 0;\n  for(auto y: G[x]){\n    if(y == p || y == z) continue;\n    r ^= solve(y, -1, x)+1;\n  }\n  return r;\n}\n\nint main(){\n  scanf(\"%d\", &n);\n  for(int i=0;i<n-1;i++){\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  if(solve(0, -1, -1)) puts(\"Alice\");\n  else puts(\"Bob\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=100005;\nusing namespace std;\nint n,tot,sg[N],head[N];\nstruct Edge{int u,v,next;}G[N<<1];\ninline int read(){\n\tint f=1,x=0;char ch;\n\tdo{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n\tdo{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n\treturn f*x;\n}\ninline void addedge(int u,int v){\n\tG[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;\n\tG[++tot].u=v;G[tot].v=u;G[tot].next=head[v];head[v]=tot;\n}\ninline int dfs(int u,int f){\n\tsg[u]=0;\n\tfor(int i=head[u];i;i=G[i].next){\n\t\tint v=G[i].v;if(v==f)continue;\n\t\tsg[u]=sg[u]^(dfs(v,u)+1);\n\t}\n\treturn sg[u];\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint u=read(),v=read();\n\t\taddedge(u,v);\n\t}\n\tdfs(1,0);\n\tif(sg[1])puts(\"Alice\");else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint n;fscanf(file_in,\"%d\",&n);\n\t\t\tREP(i,n){\n\t\t\t\tT t;*this>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t}\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\n//}}}\n\n//{{{ Graph\ntypedef int Weight;\nstruct Edge {\n\tint src, dst, rev;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\n//typedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct Graph:vector<Edges>{\n\tGraph(){}\n\tGraph(const int &n){this->assign(n,Edges());}\n\t//add bi-directional edge\n\tvoid addBiEdge(int from ,int to, Weight w=1){\n\t\twhile(this->size()<max(from,to)+1)this->push_back(Edges());\n\t\tthis->at(from).push_back(Edge(from,to,w,this->at(to).size()));\n\t\tthis->at(to).push_back(Edge(to,from,w,this->at(from).size()-1));\n\t}\n\t//add directional edge\n\tvoid addEdge(int from ,int to, Weight w=1){\n\t\twhile(this->size()<from+1)this->push_back(Edges());\n\t\tthis->at(from).push_back(Edge(from,to,w));\n\t}\n};\n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\nint N;\nGraph G;\n\nint dfs(int u=0,int p=-1){\n\tint s = 0;\n\tfor(const auto &e:G[u]){\n\t\tif(p==e.dst)continue;\n\t\ts^=(dfs(e.dst,u)+1);\n\t}\n\treturn s;\n}\n\n\nint main(){\n\tfin>>N;\n\tG.assign(N,{});\n\tREP(i,N-1){\n\t\tint x,y;\n\t\tfin>>x>>y;\n\t\tx--;y--;\n\t\tG.addBiEdge(x,y);\n\t}\n\tauto u(dfs());\n\tif(u==0){\n\t\tfout<<\"Bob\"<<endl;\n\t}else{\n\t\tfout<<\"Alice\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b)  for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n#define ll long long\n\nusing namespace std;\n\nint rez[100100];\nvector <int> child[100100];\nint par[100100];\n\nvoid dfs(int x) {\n  int out = -1;\n  REP(i, child[x].size()) {\n    int ne = child[x][i];\n    if (ne == par[x]) continue;\n    par[ne] = x;\n    dfs(ne);\n    out *= rez[ne];\n  }\n//  if (child[x].size() == 1) out = 1;\n  rez[x] = out;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n - 1) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    child[x].push_back(y);\n    child[y].push_back(x);\n  }\n  par[0] = -1;\n  dfs(0);\n  if (child[0].size() == 1) {\n    cout << \"Alice\\n\";\n    return 0;\n  }\n  if (rez[0] == 1) cout << \"Alice\\n\";\n  else             cout << \"Bob\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <climits>\n\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define fast_cin() ios_base::sync_with_stdio(false)\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int max_N = 1e5 + 10;\nvector<int> E[max_N];\nint spgn[max_N], vis[max_N];\n\nvoid dfs(int node);\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\n\tdfs(1);\n\tif (spgn[1]) {\n\t\tcout << \"Alice\" << endl;\n\t} else {\n\t\tcout << \"Bob\" << endl;\n\t}\n}\n\nvoid dfs(int node)\n{\n\tvis[node] = 1;\n\tint cnt = 0;\n\tint temp = 0;\n\tfor (auto &v : E[node]) {\n\t\tif (!vis[v]) {\n\t\t\tdfs(v);\n\t\t\ttemp ^= spgn[v];\n\t\t\t++cnt;\n\t\t}\n\t}\n\tif (cnt > 1) {\n\t\tspgn[node] = temp;\n\t} else if (cnt == 1) {\n\t\tspgn[node] = temp + 1;\n\t} else {\n\t\tspgn[node] = 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 200005;\n\nLL ec = 0,to[N << 1],nxt[N << 1],hed[N];\nvoid add_edge(LL f,LL t){\n\t++ ec; to[ec] = t; nxt[ec] = hed[f]; hed[f] = ec;\n}\n\nLL sg[N];\nvoid dfs(LL u,LL f){\n\tsg[u] = 0;\n\tfor(LL i = hed[u];i;i = nxt[i]){\n\t\tLL v = to[i];\n\t\tif(v == f) continue;\n\t\tdfs(v,u);\n\t\tsg[u] ^= (sg[v] + 1);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL n,u,v;\n\tcin >> n;\n\tfor(LL i = 1;i < n;i ++){\n\t\tcin >> u >> v;\n\t\tadd_edge(u,v); add_edge(v,u);\n\t} dfs(1,0);\n\tcout << (sg[1] ? \"Alice\" : \"Bob\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// RESTRICTED AREA\n#include <bits/stdc++.h>\nusing namespace std;\n \n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"Os\")\n\n/*\t\t\t\tAs you call 'em, they call you when they need something\n\t\t\t\tTrees for the blunt, the G's for the front\n\t\t\t\tI found a way to get peace of mind for years and left the hell alone\n\t\t\t\tTurn a deaf ear to the cellular phone\n\t\t\t\tSend me a letter or better, we could see each other in real life\n\t\t\t\tJust so you could feel me like a steel knife\n\t\t\t\tAt least so you could see the white of they eyes\n\t\t\t\tBright with surprise, once they finish spitting lies\n\t\t\t\tAsssociates, is your boys, your girls, bitches, niggas, homies\n\t\t\t\tClose, but really don't know me\n\t\t\t\tMom, dad, comrade, peeps, brothers, sisters, duns, dunnies\n\t\t\t\tSome come around when they need some money\n\t\t\t\tOthers make us laugh like the Sunday funnies\n\t\t\t\tFam be around whether you paid or bummy\n\t\t\t\tYou could either ignore this advice or take it from me\n\t\t\t\tBe too nice and people take you for a dummy\n\t\t\t\tSo nowadays he ain't so friendly\n\t\t\t\tActually they wouldn’t have made a worthy enemy\n\t\t\t\tRead the signs: \"No feeding the baboon\"\n\t\t\t\tSeein' as how they got ya back bleeding from the stab wounds\n\t\t\t\tY'all know the dance, they smile in ya face, y'all know the glance\n\t\t\t\tTry to put 'em on, they blow the chance\n\t\t\t\tNever let your so-called mans know your plans\n\t\t\t\t(How many of us have them?) A show of hands\n\t\t\t\t(Friends) is a term some people use loosely\n\t\t\t\tI'm real choosy on what I choose to let crews see\n\t\t\t\tYou telling me; I try to act broke\n\t\t\t\tJealousy the number one killer among black folk\n\t\t\t\tFellas be under some type of spell like crack smoke\n\t\t\t\tGhetto Cinderellas, lead 'em right to your stack, loc\n\t\t\t\tJust another way a chick'll lead to your end\n\t\t\t\tI check the dictionary for the meaning of friend\n\t\t\t\tIt said: person, one who likes to socialize with\n\t\t\t\tSympathiser, helper, and that's about the size of it\n\t\t\t\tMost of the time these attributes is one-sided\n\t\t\t\tTo bolster the crime, they're apt to shoot you through your eyelid\n\t\t\t\tAnd they can't hide it, going wild like a white bitch\t\t\t\t*/\n\n/*\t\t\t\tWho knew evil girls had the prettiest face\t\t\t\t\t*/\n\n/*\t\t\t\tMe-meet me at The London\n\t\t\t\tIf you find time, we can run one\n\t\t\t\tTalk about some things we can't undo\n\t\t\t\tYou just send the pin, I can find you\n\t\t\t\t6'1\", on the money, 9'2\"\n\t\t\t\tYou just say the word and I'll run through\n\t\t\t\tTwo texts, no reply, that's when I knew\n\t\t\t\tI knew, I knew, yeah, I knew\n\t\t\t\t\n\t\t\t\tYeah, circumnavigate the globe as the cash grows\n\t\t\t\tGet a nigga whacked like you get the grass mowed\n\t\t\t\tI'm talkin' slick when I'm with the Big Slime, nigga\n\t\t\t\tCould hit your bitch, you could never hit mine, nigga\n\t\t\t\tIn my DM, they electric slide, nigga\n\t\t\t\tNo catfishin', this is not a fish fry, nigga\n\t\t\t\tNever switch sides on my dog\n\t\t\t\tCatch a contact, hitch a ride, go to Mars\n\t\t\t\tEverybody sing\n\t\t\t\tHow could you come up out your face\n\t\t\t\tAnd say I ain't the hottest nigga you done ever heard?\n\t\t\t\tI left a flock of rappers dead and buried\n\t\t\t\tA verse from me is like eleven birds\n\t\t\t\tJust did the math, that's like two thousand dollars every word\n\t\t\t\tI'm on the verge, I'll beat the charge\n\t\t\t\tI killed some niggas and I walked away from it\n\t\t\t\tThen I observe, just how you curve\n\t\t\t\tThen told the nigga that they gotta wait for it\n\t\t\t\t\"I know—I know you in high demand\"\n\t\t\t\tI'm ballin' on a pussy nigga like Juwanna Mann\n\t\t\t\tI'm drownin' all inside the pussy like I never swam\n\t\t\t\tAyy, fuck your IG, I put somethin' on your sonogram\n\t\t\t\tI'm the man, ayy, ayy\t\t\t\t\t\t\t\t\t\t*/\n\n/*\t\t\t\tI'm not god, baby / I don't forgive, baby\t\t\t\t\t*/\n\n/*\t\t\t\tI'm like \"Hey, what's up? Hello\"\n\t\t\t\tSeen yo pretty ass soon as you came in the door\n\t\t\t\tI just wanna chill, got a sack for us to roll\n\t\t\t\tMarried to the money, introduced her to my stove\n\t\t\t\tShowed her how to whip it, now she remixin' for low\n\t\t\t\tShe my trap queen, let her hit the bando\n\t\t\t\tWe be countin' up, watch how far them bands go\n\t\t\t\tWe just set a goal, talkin' matchin' Lambos\n\t\t\t\tAt fifity six a gram, five a hundred grams though\n\t\t\t\tMan, I swear I love her, how she work the damn pole\n\t\t\t\tHit the strip club, we be lettin' bands go\n\t\t\t\tEverybody hatin', we just call them fans, though\n\t\t\t\tIn love with the money, I ain't never lettin' go\t\t\t*/\n\n/*\t\t\t\tWe pop out at your party, I'm with the gang\n\t\t\t\tAnd it's gon' be a robbery, so tuck ya chain\n\t\t\t\tI'm a killer girl, I'm sorry, but I cannot change\n\t\t\t\tWe ain't aiming for your body, shots hit you brain\n\t\t\t\tWe come from poverty, man, we ain't have a thing\n\t\t\t\tIt's a lot of animosity, but they won't say my name\n\t\t\t\tThem killers rock with me, lil' nigga, don't get banged\n\t\t\t\t'Cause they'll do that job for me while I hop on a plane\t*/\n\n/*\t\t\t\tI take you to the candy shop\t\t\t\t\t\t\t\t*/\n\n/*\t\t\t\tBaby, let me put your panties to the side\n\t\t\t\tI'ma make you feel alright\n\t\t\t\t'Cause I'ma give you what you need, yeah\t\t\t\t\t*/\n\n/*\t\t\t\tOoooh ooh, it's me, myself and I\n\t\t\t\tSolo ride until I die, 'cause I got me for life\t\t\t\t*/\n\n/*\t\t\t\tSo I ball So hard, muh'fuckas wanna find me\t\t\t\t\t*/\n\n/*\t\t\t\tBitch, where you when I was walkin'?\n\t\t\t\tNow I run the game, got the whole world talkin'\t\t\t\t*/\n \n/*\t\t\t\tNiggas been counting me out\n\t\t\t\tI'm counting my bullets, I'm loading my clips\n\t\t\t\tI'm writing down names, I'm making a list\t\t\t\t\t*/\n\n/*\t\t\t\tFuck your friendship, I meant it\t\t\t\t\t\t\t*/\n\n/*\t\t\t\tThe Chanel or Balenciaga, Louis and Vuitton\n\t\t\t\tShe know I got Fendi, Prada when I hit Milan\t\t\t\t*/\n\n/*\t\t\t\tI ran away, I don't think I'm coming back home\t\t\t\t*/ \n \n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e5+10, maxm=3e3+10, lg=61, mod=998244353, inf=1e18;\n\nll n;\nvector<ll> g[maxn];\nll dfs(ll v=1,ll p=0){\n\tll xo=0; for(auto u:g[v])if(u!=p) xo^=(dfs(u,v)+1);\n\treturn xo;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tg[v].pb(u), g[u].pb(v);\n\t}\n\tcout<<(dfs(1)==0 ? \"Bob\":\"Alice\");\n\t\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\n    int n;\n    scanf(\"%d\", &n);\n    \n    vector<vector<int> > g(n);\n\n    for(int i = 0;i < n-1;i++){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x -= 1;\n        y -= 1;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    vector<int> tmp(n);\n\n    function<int (int, int)> go = [&](int i, int par) {\n        int xx = 0;\n        for (int j : g[i]) if (j != par) {\n            xx ^= go(j, i) + 1;\n        }\n        return xx;\n    };\n\n    int ret = go(0, -1);\n    if(ret)\n    \tprintf(\"Alice\\n\");\n    else\n    \tprintf(\"Bob\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//21:16-23:16\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n;\nvector<int>edge[1000005];\nint dfs(int v,int u){\n    vector<int>vec;\n    set<int>S; int X = 0;\n    for(int i=0;i<edge[v].size();i++){\n        if(edge[v][i] == u) continue;\n        int Y = dfs(edge[v][i],v);\n        vec.pb(Y); X^=Y; \n    }\n    for(int i=0;i<vec.size();i++){\n        for(int j=0;j<max(1,vec[i]);j++){\n            S.insert(X^vec[i]^j);\n        }\n    }\n    if(v==1) puts(X?\"Alice\":\"Bob\");\n    for(int x=0;;x++){\n        if(S.find(x) == S.end()){\n            //cout << v << \" \" << x << endl;\n            return x;\n        }\n    }\n}\nint main(){\n    cin >> n ;\n    for(int i=1;i<n;i++){\n        int a,b; cin >> a >> b;\n        edge[a].pb(b); edge[b].pb(a);\n    }\n    dfs(1,-1);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h&& j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Exponential.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Geometric2D.h\"\n#include \"Geometric2DFloat.h\"\n#include \"Geometric3D.h\"\n#include \"Geometric3DFloat.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"Interpolation.h\"\n#include \"IntMod.h\"\n#include \"KDTree.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"List.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Random.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Timer.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint n;\nvector<int> G[100000];\n\nint rec(int from, int prev) {\n\tint sum = 0;\n\tfor (int to : G[from]) {\n\t\tif (to == prev) continue;\n\t\tsum ^= rec(to, from);\n\t}\n\treturn sum + (prev == -1 ? 0 : 1);\n}\n\nint main() {\n\tcin >> n;\n\tREP(j, 1, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tcout << (rec(0, -1) == 0 ? \"Bob\" : \"Alice\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int> v[111111];\nint dfs(int u,int fa)\n{\n\tint i,s,sg;\n\ts=v[u].size();\n\tsg=0;\n\tfor(i=0;i<s;i=i+1){\n\t\tif(v[u][i]!=fa)\n\t\t\tsg^=dfs(v[u][i],u);\n\t}\n\treturn sg+1;\n}\n\nint main()\n{\n\tint n,i,x,y;\n\tcin>>n;\n\tfor(i=1;i<n;i=i+1){\n\t\tcin>>x>>y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif(dfs(1,0)==1)\n\t\tcout<<\"Bob\\n\";\n\telse\n\t\tcout<<\"Alice\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define all(a) a.begin(),a.end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define mp make_pair\n#define endl '\\n'\n#define vec vector<ll>\n#define mat vector<vector<ll> >\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\nconst ll inf=998244353;\nconst ll mod=1e9+7;\nvector<vector<ll> >G(100010);\nvector<ll>d(100010);\nvoid dfs(ll i,ll p,ll c){\n    d[i]=c;\n    for(auto e:G[i]){\n        if(e==p)continue;\n        dfs(e,i,c+1);\n    }\n    return;\n}\nsigned main(){\n    ll n;cin>>n;\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    dfs(0,-1,0);\n    vector<ll>s(100010);\n    REP(i,1,n){\n        s[d[i]]++;\n    }\n    bool ans=0;\n    rep(i,n+1){\n        ans|=(s[i]%2);\n    }\n    if(ans)cout<<\"Alice\"<<endl;\n    else cout<<\"Bob\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nll dist[100010] = {};\nvector<ll> tree[100010];\n\nvoid dfs(ll cur, ll par, ll d){\n    dist[cur] = d;\n    for(auto &e: tree[cur]){\n        if(e == par) continue;\n        dfs(e, cur, d+1);\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    rep(i,0,N-1){\n        ll a,b;\n        cin >> a >> b;\n        a--; b--;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    dfs(0,-1,0);\n    ll res = 0;\n    rep(i,0,N) res ^= dist[i];\n    if(res == 0){\n        print(\"Bob\");\n    }else{\n        print(\"Alice\");\n    }\n\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,n) for(ll i=(ll)a;i<(ll)n;i++)\n#define rep(i,n) FOR(i,0,n)\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>bool chmax(T &a,const T &b){\n    if(a>b)return false;\n    a=b;\n    return true;\n}\ntemplate<class T>bool chmin(T &a,const T &b){\n    if(a<b)return false;\n    a=b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n,x,y;\nvector<int> e[100009];\nbool visited[100009];\n\nint dfs(int m){\n    visited[m]=true;\n    int re=0,cnt=0;\n    rep(i,e[m].size()){\n        if(!visited[e[m][i]]){\n            cnt++;\n            re^=dfs(e[m][i]);\n        }\n    }\n    return re+(cnt==1);\n}\n\nint main(){\n    cin>>n;\n    rep(i,n-1){\n        cin>>x>>y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    cout<<(dfs(1)?\"Alice\\n\":\"Bob\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            ++res;\n            res += dfs(e, now);\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    if (oneCnt == 2) {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        cout << (ch[0] % 2 == ch[1] % 2 ? \"Bob\" : \"Alice\") << endl;\n        return 0;\n    }\n    else {\n        int odd = 0;\n        FORE(e, graph[0]) odd += (dfs(e, 0) + 1) % 2;\n        if (odd == 0) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 3) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 1) {\n            cout << \"Alice\" << endl;\n        } else if (odd == 2) {\n            cout << \"Alice\" << endl;\n        } else {\n            assert(false);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> g[100000];\nint n;\n\nint dfs(int v, int p) {\n\tint currXor = 0;\n\tfor (int to : g[v]) {\n\t\tif (to == p) continue;\n\t\tcurrXor ^= dfs(to, v) + 1;\n\t}\n\treturn currXor;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"game.in\", \"r\", stdin);\n\t//freopen(\"game.out\", \"w\", stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tb--;\n\t\ta--;\n\t\tg[b].push_back(a);\n\t\tg[a].push_back(b);\n\t}\n\t\n\tint currXor = dfs(0, -1);\n\tif (currXor == 0) {\n\t\tcout << \"Bob\";\n\t} else {\n\t\tcout << \"Alice\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define long long long\n#define pll pair < long , long >\n#define vll vector < pll >\n#define ml map < long , long >\n#define mll map < pll , long >\n#define x first\n#define y second\n#define vl vector < long >\n#define io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nvl a[100005];\nlong g[100005]={0};\nvoid dfs(long node , long par)\n{\n    long i;\n    for(i=0;i<a[node].size();++i)\n    if(a[node][i]!=par)\n    dfs(a[node][i],node);\n    if((a[node].size()==2 && par!=-1) || (a[node].size()==1&& par==-1))\n    {\n        if(a[node][0]!=par)\n        g[node]=g[a[node][0]]+1;\n        else g[node]=g[a[node][1]]+1;\n    }\n    else\n    {\n        for(i=0;i<a[node].size();++i)\n        if(a[node][i]!=par)\n        g[node]^=g[a[node][i]];\n    }\n}\nint main()\n{\n    io\n    long n,x,y,i;\n    cin>>n;\n    n--;\n    while(n--)\n    {\n        cin>>x>>y;\n        a[x].pb(y);\n        a[y].pb(x);\n    }\n    dfs(1,-1);\n    if(g[1]==0) cout<<\"Bob\";\n    else cout<<\"Alice\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <bitset>\n#include <fstream>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pii> vii;\n\n#define INF 1000000007ll\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n#define Min(a,b) (((a) < (b))?(a):(b))\n#define Max(a,b) (((a) > (b))?(a):(b))\n#define Abs(a) (((a) > 0)?(a):(-1)*(a))\n#define cil(a,b) ( ((a)%(b) == 0)?((a)/(b)):((a)/(b)+1) )\n#define SIZE 100010\n\nvi adj[SIZE];\n\nint dfs (int v, int p) {\n   if (adj[v].size() == 1) {\n      if (v != p) return 0;\n      else return 1;\n   }\n   int x = 0;\n   for (int i = 0 ; i < adj[v].size() ; ++i) {\n      int t = adj[v][i];\n      if (t == p) continue;\n      x ^= (1 + dfs (t, v));\n   }\n   return x;\n}\n\nint main() {\n   int n;\n   cin >> n;\n   for (int i = 1 ; i < n ; ++i) {\n      int u, v;\n      cin >> u >> v;\n      adj[u].PB(v);\n      adj[v].PB(u);\n   }\n   int t = dfs (1, 1);\n   if (t == 0) cout << \"Bob\" << endl;\n   else cout << \"Alice\" << endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, f[100000];\nvector<int> g[100000];\n\nvoid dfs(int v, int p) {\n\tfor(int to : g[v]) {\n\t\tif(to == p)\n\t\t\tcontinue;\n\t\tdfs(to, v);\n\t\tf[v] ^= (f[to] + 1);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0, -1);\n\tcout << (f[0] == 0 ? \"Bob\" : \"Alice\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int N = 1e5 + 100;\nconst int M = N << 1;\nint n, h[N], to[M], nx[M], e;\n\nint grundy(int u, int f = -1) {\n\tint r = 0;\n\tfor (int i = h[u]; i != -1; i = nx[i]) {\n\t\tif (to[i] != f) {\n\t\t\tr ^= 1 + grundy(to[i], u);\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\te = 0;\n\tmemset(h, -1, sizeof h);\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tto[e] = v, nx[e] = h[u], h[u] = e++;\n\t\tto[e] = u, nx[e] = h[v], h[v] = e++;\n\t}\n\tint t = grundy(1);\n\tif (t == 0) {\n\t\tputs(\"Bob\");\n\t} else puts(\"Alice\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb push_back\n#define mp std::make_pair\n//#define endl \"\\n\"\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\nusing std::endl;\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\n//const ll MOD=100000;\nconst ll MAX=1e7;\nconst ll INF=(1ll<<50);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nll modpow(ll X,ll Y){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=MOD;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=MOD;\n        }\n    }\n    return ret;\n}\nll fac[MAX],finv[MAX],inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r];\n}\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N; cin>>N;\n    ll cnt=0;\n    rep(i,1,N){\n        ll X,Y; cin>>X>>Y;\n        if(X==1||Y==1) cnt++;\n    }\n    string ans=\"Bob\";\n    if(cnt==1) ans=\"Alice\";\n    if(N%2==0) ans=\"Alice\";\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n;\nvi a[100010];\ninline int dp(int i,int j)\n{\n\tint p=0;\n\tfor(auto k:a[i])\n\t  if(k!=j)\n\t    p^=dp(k,i)+1;\n\treturn p;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   a[j].pb(k);\n\t   a[k].pb(j);\n\t  }\n\tif(dp(1,0))\n\t  printf(\"Alice\");\n\telse\n\t  printf(\"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 100010;\nint N;\nint x[MAX], y[MAX];\nVI graph[MAX];\n\nint dfs(int now, int prev) {\n    int res = 0;\n    FORE(e, graph[now]) {\n        if (e != prev) {\n            res ^= dfs(e, now) + 1;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d\", &N);\n    int oneCnt = 0;\n    REP(i, N - 1) {\n        scanf(\"%d%d\", x + i, y + i);\n        oneCnt += ((x[i] == 1) || (y[i] == 1));\n        x[i]--;\n        y[i]--;\n        graph[x[i]].EB(y[i]);\n        graph[y[i]].EB(x[i]);\n    }\n    if (oneCnt == 1) {\n        cout << \"Alice\" << endl;\n        return 0;\n    }\n    else {\n        VI ch;\n        FORE(e, graph[0]) ch.EB(dfs(e, 0) + 1);\n        int f = 0;\n        FORE(e, ch) f ^= (e & 1);\n        cout << (f ? \"Alice\" : \"Bob\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>pat[100000];\nbool flag[100000];\nint dfs(int node)\n{\n\tif (flag[node])return -1;\n\tflag[node] = true;\n\tint ans = 0;\n\tfor (int i = 0; i < pat[node].size(); i++)ans ^= dfs(pat[node][i]) + 1;\n\treturn ans;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tif (dfs(0) == 0)printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nvector<int> V[MC];\n\nint dfs(int p , int q){\n\tint g = 0;\n\tfor(auto u : V[q]){\n\t\tif(u == p) continue;\n\t\tg ^= dfs(q,u)+1;\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin >> N;\n\trepp(i,1,N){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tV[x].PB(y);\n\t\tV[y].PB(x);\n\t}\n\tcout << (dfs(-1,1)?\"Alice\":\"Bob\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\n\nint last[MAXN + 5], other[MAXN + 5], pre[MAXN + 5];\n\nint N, all = -1;\n\nvoid build(int u, int v)\n{\n\tpre[++all] = last[u];\n\tlast[u] = all;\n\tother[all] = v;\n}\n\nint dfs(int ans, int fa)\n{\n\tint cnt = 0;\n\tint dt = last[ans];\n\twhile(dt != -1){\n\t\tint dr = other[dt];\n\t\tif(dr != fa) cnt ^= dfs(dr, ans);\n\t\tdt = pre[dt];\n\t}\n\tif(ans == 1) return cnt;\n\treturn cnt + 1;\n}\n\nint main()\n{\n\tmemset(last, -1, sizeof(last));\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tbuild(u, v);\n\t\tbuild(v, u);\n\t}\n\tint check = dfs(1, 0);\n\tif(check) printf(\"Alice\\n\");\n\telse printf(\"Bob\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\n\nint n, g[MAXN], nxt[MAXN << 1], to[MAXN << 1], edgeSize;\n\nvoid addEdge(int u, int v){\n\tnxt[++ edgeSize] = g[u];\n\tto[g[u] = edgeSize] = v;\n}\nint dfs(int x, int f){\n\tint p, s = 0, c = 0;\n\tfor(p = g[x]; p; p = nxt[p])\n\t\tif(to[p] != f)\n\t\t\ts ^= dfs(to[p], x), ++ c;\n\treturn s + int(c == 1);\n}\nint main(){\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v), addEdge(v, u);\n\t} printf(\"%s\\n\", dfs(1, -1) ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n\nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,k;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>a>>b>>c;\n    ans=b/a;\n    Cout(min(ans,c));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+7;\nint n,m,cnt,hd[N],v[N*2],nxt[N*2];\nvoid add(int x,int y){v[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;}\nint dfs(int x,int fa)\n{\n\tint l=0;\n\tfor(int i=hd[x];i;i=nxt[i])\n\tif(v[i]!=fa)l^=dfs(v[i],x)+1;\n\treturn l;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++)scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tif(dfs(1,0))puts(\"Alice\");else puts(\"Bob\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<locale>\nusing namespace std;\nvector<long>g[100001];\nlong sg[100001];\nlong f[100001];\nvoid fsg(long i)\n{\n    //cout<<i;\n    //if(f[i]!=0)return;\n    f[i]=1;\n    sg[i]=0;\n    set<long>s;\n    for(long j=0,l=g[i].size();j<l;j++)\n        if(!f[g[i][j]])\n    {\n        fsg(g[i][j]);\n        s.insert(sg[g[i][j]]);\n    }\n    for(long j=0,l=s.size();j<l;j++)\n    {\n        if(sg[i]==*s.begin()){s.erase(s.begin());sg[i]++;}\n        else break;\n    }\n}\nint main()\n{\n    long n;\n    cin>>n;\n    memset(f,0,sizeof(f));\n    for(long i=0;i<n-1;i++)\n    {\n        long x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    fsg(1);\n    for(long i=1;i<=n;i++)cout<<sg[i]<<' ';cout<<endl;\n    if(sg[1]||g[1].size()==1)cout<<\"Bob\";\n    else cout<<\"Alice\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); ++i)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); --i)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); ++i)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define dec(i, n)  decID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define SI(v) static_cast<int>(v.size())\n#define RF(e, v) for(auto & e: v)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\n#define IN(T, ...) T __VA_ARGS__; IN_(__VA_ARGS__);\nvoid IN_() { };\ntemplate<typename T, typename ... U> void IN_(T & a, U & ... b) { cin >> a; IN_(b ...); };\ntemplate<typename T> void OUT(T && a) { cout << a << endl; }\ntemplate<typename T, typename ... U> void OUT(T && a, U && ... b) { cout << a << \" \"; OUT(b ...); }\n\n// ---- ----\n\nint main() {\n\tIN(int, n);\n\tvector<vector<int>> g(n);\n\tinc(i, n - 1) {\n\t\tIN(int, a, b);\n\t\ta--; b--;\n\t\tg[a].PB(b);\n\t\tg[b].PB(a);\n\t}\n\t\n\tfunction<int(int, int)> dfs = [&](int v, int p) {\n\t\tint x = 0;\n\t\tRF(e, g[v]) {\n\t\t\tif(e == p) { continue; }\n\t\t\tx ^= dfs(e, v) + 1;\n\t\t}\n\t\treturn x;\n\t};\n\t\n\tOUT(dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint N, par[101010], grd[101010];\nvector<int> con[101010];\n\nvoid dfs(int ix){\n\tfor(auto e : con[ix]){\n\t\tif(par[ix] == e) continue;\n\t\tpar[e]=ix;\n\t\tdfs(e);\n\t\tgrd[ix] ^= grd[e]+1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i=0; i<N-1; i++){\n\t\tint s, e;\n\t\tscanf(\"%d%d\", &s, &e);\n\t\tcon[s].push_back(e), con[e].push_back(s);\n\t}\n\tdfs(1);\n\tputs(grd[1] ? \"Alice\" : \"Bob\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvector<int> v[101010];\nint dfs(int x,int p){\n    int ret=0,cnt=0;\n    for(auto to:v[x]){\n        if(to==p)continue;\n        ++cnt;\n        ret^=dfs(to,x);\n    }\n    if(cnt==1)ret++;\n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    cout<<(dfs(0,-1)?\"Alice\":\"Bob\")<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint G[100001];\npair<int, int> E[200001];\npair<int, int>* P[100002];\nint dfs(int A) {\n\tif (G[A] == 0) {\n\t\tint g = 0;\n\t\tG[A] = -1;\n\t\tfor (auto p = P[A]; p < P[A + 1]; p++) {\n\t\t\tg ^= dfs((*p).second);\n\t\t}\n\t\treturn G[A] = g + 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N + N - 2; i += 2) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tE[i] = mp(x, y);\n\t\tE[i + 1] = mp(y, x);\n\t}\n\tsort(E, E + N + N - 2);\n\tint k = 0;\n\trep(i, N + N - 2) {\n\t\tif (k != E[i].first) {\n\t\t\tk++;\n\t\t\tP[k] = E + i;\n\t\t}\n\t}\n\tP[N + 1] = E + N + N - 2;\n\n\tdfs(1);\n\n\tif (G[1] - 1) co(\"Alice\");\n\telse co(\"Bob\");\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF (long long) 1e18//1234567890987654321\n#define INF 1234567890\n#define pb push_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos(-1))\n#define MAXN 300006\n#define MAXK 26\n#define MAXX 15000006\n#define ll long long int\n#define ld long double\n#define rep0(kk, l1, l2)for(ll kk = l1; kk < l2; kk++)\n#define rep1(kk, l1, l2)for(ll kk = l1; kk <= l2; kk++)\n#define foritr(itr, A) for(set<ll>::iterator itr = A.begin(); itr != A.end(); itr++)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = ss; ii < ee; ii++)\n#define cr(x) cerr << #x << \" = \" << x << \"\\n\";\n#define crA(x, A) cerr << #x << \" = \" << A[x] << \"\\n\";\n#define spacing cout << \" \";\n#define mmst(x, v) memset((x), v, sizeof ((x)));\n#define bg(ms) (*ms.begin())\n#define ed(ms) (*prev(ms.end(), 1))\n#define addedge(a, b, c, v) v[(a)].pb(pi((b), (c))); v[(b)].pb(pi((a), (c)))\n#define ph push\n#define btinpct(x) __builtin_popcountll(x)\n#define p2(x) (1LL<<(x))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nll n, vt;\nvector <ll> v[MAXN];\nvoid dfs(ll x, ll p, ll d)\n{\n\tif(d > 1) vt ++;\n\tfor(auto i : v[x]) { if(i!=p) dfs(i, x, d+1); }\n}\nint main()\n{\n\tcin >> n; \n\tFOR(i,1,n)\n\t{\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tv[a].pb(b);\n\t\tv[b].pb(a);\n\t}\n\tdfs(1, 1, 0);\n\tif(vt % 2 || v[1].size() == 1) cout << \"Alice\\n\";\n\telse cout << \"Bob\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <bitset>\n#include <complex>\n#include <climits>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\ntypedef pair<double, double> dd;\n#define mp make_pair\n#define pb push_back\n#define debug(x) cerr << #x << \" = \" << x << \" \"\n\n\nconst int N = 1e5+1;\nvector<int> g[N];\nint n;\nint dfs(int cur, int p)\n{\n  vector<int> sgs;\n  for (auto nxt : g[cur])\n    if (nxt != p)\n      sgs.pb(dfs(nxt, cur));\n  if (sgs.size() == 1)\n    return 1 + sgs.front();\n  int ret = 0;\n  for (auto e : sgs) ret ^= e;\n  return ret;\n }\nint main()\n{\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n-1; ++i)\n    {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      g[u].pb(v);\n      g[v].pb(u);\n    }\n  puts(dfs(1, 1)?\"Alice\":\"Bob\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#define inf 0x3f3f3f3f\n#define esp 1e-7\nusing namespace std;\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nstruct Tree{\n\tint sg;\n\tint visited;\n}t[100050];\nint n;\nvector<int> to[10050];\n\nvoid dfs(int index){\n\tfor (unsigned int i=0;i<to[index].size();i++){\n\t\tif (t[to[index][i]].visited==0){\n\t\t\tt[to[index][i]].visited=1;\n\t\t\tdfs(to[index][i]);\n\t\t\tt[index].sg^=(t[to[index][i]].sg+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++)\tto[i].clear();\n\tfor (int i=1,tmp1,tmp2;i<n;i++){\n\t\ttmp1=read();tmp2=read();\n\t\tto[tmp1].push_back(tmp2);\n\t\tto[tmp2].push_back(tmp1);\n\t}\n\tt[1].visited=1;\n\tdfs(1);\n\tif (t[1].sg==0)\tcout<<\"Bob\"<<endl;\n\telse\t\t\tcout<<\"Alice\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\n\nvector<int> t_parent;\nvi t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile (!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor (int j = (int)g[i].size() - 1; j >= 0; j--) {\n\t\t\tint c = g[i][j];\n\t\t\tif (t_parent[c] == -1 && c != root)\n\t\t\t\tstk.push_back(c);\n\t\t\telse\n\t\t\t\tt_parent[i] = c;\n\t\t}\n\t}\n}\n\nint main() {\n\t\tint N;\n\t\tscanf(\"%d\", &N);\n\t\tvector<vector<int> > g(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), --u, --v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<int> grundy(N);\n\t\tfor (int ix = (int)t_ord.size() - 1; ix > 0; --ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tgrundy[p] ^= grundy[i] + 1;\n\t\t}\n\t\tbool ans = grundy[0] != 0;\n\t\tputs(ans ? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <list>\n#include <map>\n#include <queue>\n#include <iterator>\n#include <iomanip>\n#include <stdio.h>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define ld long double\n#define infinity (ll)1e18+1\n#define PI 3.14159265358979\n\n#define pdd pair<ld,ld>\n#define pll pair<ll, ll>\n#define pii pair<int,int>\n\n#define MP make_pair\n#define SZ size()\n#define PB push_back\n\n#define vi vector<int>//ll\n#define vll vector<ll>\n#define vpll vector<pll>\n#define vpii vector<pii>\n#define vch vector<char>\n#define vb vector<bool>\n#define vld vector<ld>\n\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(ll i = (b) - 1; i >= (a); --i)\n#define REPEAT(i) FOR(counter1234,0,i)\n#define ALL(a) a.begin(), a.end()\n#define X first\n#define Y second\n#define MAXN 100001\nclock_t startTime;\n\nint n;\nvi g[MAXN];\n\nvi sons;\nint c = 0;\nvch used;\n\nvoid dfs(int v)\n{\n\tint s = c;\n\tused[v] = 1;\n\tfor (auto i : g[v])\n\t\tif (used[i] == 0)\n\t\t\tdfs(i), c++;\n\tsons[v] = c - s;\n}\nint d[MAXN];\n\nvoid bfs()\n{\n\td[1] = 0;\n\tused.assign(n + 1, 0);\n\tused[1] = 1;\n\tqueue<int> q;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor(auto i: g[t])\n\t\t\tif (used[i] == 0)\n\t\t\t{\n\t\t\t\tused[i] = 1;\n\t\t\t\td[i] = d[t] + 1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n}\n\nvch win;\n\nvoid do_all(int v)\n{\n\tint cc = 0, cv = 0;\n\tfor(auto i: g[v])\n\t\tif (d[v] < d[i])\n\t\t{\n\t\t\tcv++;\n\t\t\tif (win[i] == 0)\n\t\t\t\tdo_all(i);\n\t\t\tif (win[i] == 2)\n\t\t\t\tcc++;\n\t\t}\n\n\tif (cv == 1)\n\t\twin[v] = 2;\n\telse\n\t{\n\t\tif (cc % 2 == 0)\n\t\t\twin[v] = 1;\n\t\telse\n\t\t\twin[v] = 2;\n\t}\n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tstartTime = clock();\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\t//ifstream in(\"In.txt\");\n\n\tcin >> n;\n\tint a, b;\n\tsons.assign(n + 1, 0);\n\tused.assign(n + 1, 0);\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll XOR_ALL = 0;\n\tdfs(1);\n\tbfs();\n\twin.assign(n + 1, 0);\n\tdo_all(1);\n\n\tif (win[1] == 2)\n\t\tcout << \"Alice\";\n\telse\n\t\tcout << \"Bob\";\n\treturn 0;\n}\n//don't forget about MAXN, mod and infinity "
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n     \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n     \n/** Read */\n     \nstatic const int buf_size = 4096;\n     \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n     \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n     \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n     \n/** Write */\n     \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n     \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n     \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n     \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n     \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n     \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n   \n   \n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228\nconst int MAXN = 100001;\n\n\nint n;\nvector<int> v[MAXN];\nint d[MAXN];\n\n\nvoid dfs(int u, int pr = -1) {\n    d[u] = 0;//(sz(v[u]) - (u ? 1: 0)) % 2;\n    for (auto h: v[u]) {\n        if (h == pr) {\n            continue;\n        }\n        dfs(h, u);\n        d[u] ^= d[h];\n    }\n    if (sz(v[u]) - (u ? 1: 0) == 1) {\n        d[u] = 1;\n    }\n}\n\n\nint main() {\n    n = readInt();\n    for (int i = 0; i < n - 1; i++) {\n        int x = readInt(), y = readInt();\n        x--, y--;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    dfs(0);\n    if (d[0]) {\n        cout << \"Alice\" << endl; \n    } else {\n        cout << \"Bob\" << endl;\n    }\n    return 0;               \n}                                     \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200005;\nint sun[MAXN];\nint n;\nvector<int>G[MAXN];\nint dfs(int x, int f){\n\tint p, s = 0;\n\tfor(int i = 0; i<G[x].size(); i++){\n\tp=G[x][i];\n\t\tif(p!= f)\n\t\t\ts ^= dfs(p, x) + 1;\n\t\t} \n\treturn s;\n}\nint main(){\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t} printf(\"%s\\n\", (G[1].size()==1||dfs(1, -1) )? \"Alice\" : \"Bob\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\n\nint gr[N];\nint used[N];\nvector<int> g[N];\n\nint mexx(vector<int> cur) {\n    sort(cur.begin(), cur.end());\n    if (cur.front() != 0) {\n        return 0;\n    }\n    for (int i = 0; i + 1 < (int)cur.size(); i++) {\n        if (cur[i] + 1 < cur[i + 1]) {\n            return cur[i] + 1;\n        }\n    }\n    return cur.back() + 1;\n}\n\nvoid dfs(int cur) {\n    used[cur] = 1;\n    vector<int> sons;\n    for (auto t : g[cur]) {\n        if (!used[t]) {\n            dfs(t);\n            sons.push_back(t);\n        }\n    }\n    if (sons.empty()) {\n        gr[cur] = 1;\n    } else {\n        vector<int> tomex;\n        {\n            int cx = 0;\n            for (auto t : sons) {\n                cx ^= gr[t];\n            }\n            // tomex.push_back(cx);\n            if (sons.size() > 1) {\n                for (auto t : sons) {\n                    tomex.push_back(cx ^ gr[t]);\n                }\n            }\n        }\n        gr[cur] = mexx(tomex);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i + 1 < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(0);\n    if (gr[0]) {\n        cout << \"Bob\\n\"; \n    } else {\n        cout << \"Alice\\n\";\n    }\n}       \n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\")\n%:pragma GCC optimize(\"inline\")\n#include<bits/stdc++.h>\n#define fo(i, n) for(int i = 1; i <= (n); i ++)\n#define out(x) cout << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\ntemplate<typename tp> inline void arr(tp *a, int n) {\n  for(int i = 1; i <= n; i ++)\n    cout << a[i] << \" \";\n  puts(\"\");\n}\nconst int N = 3e5 + 233;\nint n;\nvector<int> g[N];\n\ninline int dfs(int u, int fat, int fff) {\n  int t = 0;\n  vector<int> vec;\n  for(auto v: g[u]) if(v != fat) t ^= 1 + dfs(v, u, fff ^ 1);\n  return t;\n}\n\nmain(void) {\n  read(n);\n  for(int i = 1; i <= n - 1; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  cout << (dfs(1, 0, 1) ? \"Alice\" : \"Bob\") << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nstruct bian{\n\tint next,point;\n}b[210000];\nint p[110000],len;\nvoid ade(int k1,int k2){\n\tb[++len]=(bian){p[k1],k2}; p[k1]=len;\n}\nvoid add(int k1,int k2){\n\tade(k1,k2); ade(k2,k1);\n}\nint sg[110000];\nvoid dfs(int k1,int k2){\n\tsg[k1]=0;\n\tfor (int i=p[k1];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (j!=k2){\n\t\t\tdfs(j,k1); sg[k1]^=(sg[j]+1);\n\t\t}\n\t}\n}\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2); add(k1,k2);\n\t}\n\tdfs(1,0);\n\tif (sg[1]==0) printf(\"Bob\\n\"); else printf(\"Alice\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100100;\n\nvector<int> edges[MAXN];\n\nint dfs(int i = 0, int par = 0)\n{\n\tint sol = 0;\n\tfor (int j: edges[i]) if (j != par)\n\t{\n\t\tsol ^= dfs(j, i) + 1;\n\t}\n\t\n\treturn sol;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint n, i;\n\tint a, b;\n\t\n\tcin>>n;\n\t\n\tfor (i = 1; i < n; ++i)\n\t{\n\t\tcin>>a>>b;\n\t\t--a, --b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\t\n\tcout<<(dfs() ? \"Alice\" : \"Bob\")<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define N 10005\n#define LL long long\n#define inf 1<<29\n#define eps 1e-7\n#define rep(i,a,b) for (int i=a;i<=b;i++)\nusing namespace std;\nvector<int>v[100005];\nint get_sg(int u,int pre){\n    int ret=0;\n    for(int i=0;i<v[u].size();i++){\n        if(v[u][i]!=pre)\n            ret^=(1+get_sg(v[u][i],u));\n    }\n    rep(i,1,1000);\n    return ret;\n}\nint main(){\n    rep(i,1,1000);\n    int t,n;\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            v[i].clear();\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        if(get_sg(1,-1))\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node_sub{\n\tint val;\n\tstruct node_sub *next;\n}node;\n\ntypedef struct {\n\tint parent;\n\tint num;\n\tnode *near;\n}vertex;\n\nint main(){\n\tint N, i, x, y;\n\tnode *new, *now;\n\tint near1, near2;\n\tscanf(\"%d\", &N);\n\tvertex *V = (vertex *)malloc(sizeof(vertex) * N);\n\tfor(i = 0; i < N; i++){\n\t\tV[i].parent = 0;\n\t\tV[i].num = 0;\n\t\tV[i].near = NULL;\n\t}\n\tfor(i = 0; i < N - 1; i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tnew = (node *)malloc(sizeof(node));\n\t\tnew->val = y;\n\t\tnew->next = V[x].near;\n\t\tV[x].near = new;\n\t\tV[x].num++;\n\t\tnew = (node *)malloc(sizeof(node));\n\t\tnew->val = x;\n\t\tnew->next = V[y].near;\n\t\tV[y].near = new;\n\t\tV[y].num++;\n\t}\n\twhile(1){\n\t\tif(V[0].num == 0){\n\t\t\tprintf(\"Bob\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(V[0].num == 1){\n\t\t\tprintf(\"Alice\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnear1 = (V[0].near)->val;\n\t\tnear2 = ((V[0].near)->next)->val;\n\t\tV[0].near = ((V[0].near)->next)->next;\n\t\tV[0].num -= 2;\n\t\tnow = V[near1].near;\n\t\twhile(now != NULL){\n\t\t\tif(now->val != V[near1].parent){\n\t\t\t\tV[now->val].parent = near1;\n\t\t\t\tnew = (node *)malloc(sizeof(node));\n\t\t\t\tnew->val = now->val;\n\t\t\t\tnew->next = V[0].near;\n\t\t\t\tV[0].near = new;\n\t\t\t\tV[0].num++;\n\t\t\t}\n\t\t\tnow = now->next;\n\t\t}\n\t\tnow = V[near2].near;\n\t\twhile(now != NULL){\n\t\t\tif(now->val != V[near2].parent){\n\t\t\t\tV[now->val].parent = near2;\n\t\t\t\tnew = (node *)malloc(sizeof(node));\n\t\t\t\tnew->val = now->val;\n\t\t\t\tnew->next = V[0].near;\n\t\t\t\tV[0].near = new;\n\t\t\t\tV[0].num++;\n\t\t\t}\n\t\t\tnow = now->next;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint x[100000], y[100000];\nint cnt[100000], cnts[100000], *tree[100000];\nint dfs(int a, int b){\n    int ans = 0, i;\n    for(i = 0; i < cnt[a]; i++){\n        if(tree[a][i] == b){\n            continue;\n        }\n        ans ^= dfs(tree[a][i], a) + 1;\n    }\n    return ans;\n}\n\nint main(void){\n    int n, i, j;\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++){\n        cnt[i] = 0;\n        cnts[i] = 0;\n    }\n    for(i = 0; i < n-1; i++){\n        scanf(\"%d%d\", &x[i], &y[i]);\n        x[i]--;\n        y[i]--;\n        cnt[x[i]]++;\n        cnt[y[i]]++;\n    }\n    for(i = 0; i < n; i++){\n        tree[i] = malloc((cnt[i] + 1) * sizeof(int));\n    }\n    for(i = 0; i < n-1; i++){\n        tree[x[i]][cnts[x[i]]++] = y[i];\n        tree[y[i]][cnts[y[i]]++] = x[i];\n    }\n\n    int ans = dfs(0, -1);\n    if(ans == 0){\n        printf(\"Bob\\n\");\n    }else{\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint x[100000], y[100000];\nint cnt[100000], cnts[100000], *tree[100000];\nint dfs(int a, int b){\n    if(cnt[a] == 1){//何も繋がっていない頂点,\n        return 0;\n    }\n    int i;\n    int g_list[100000];\n    for(i = 0; i < 100000; i++){\n        g_list[i] = 0;\n    }\n    for(i = 0; i < cnt[a]; i++){\n        if(tree[a][i] == b){\n            continue;\n        }\n        g_list[dfs(tree[a][i], a)] = 1;\n    }\n    for(i = 0; i < 100000; i++){\n        if(g_list[i] == 0){\n            return i;\n        }\n    }\n}\nint main(void){\n    int n, i, j;\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++){\n        cnt[i] = 0;\n        cnts[i] = 0;\n    }\n    for(i = 0; i < n-1; i++){\n        scanf(\"%d%d\", &x[i], &y[i]);\n        x[i]--;\n        y[i]--;\n        cnt[x[i]]++;\n        cnt[y[i]]++;\n    }\n    for(i = 0; i < n; i++){\n        tree[i] = malloc((cnt[i] + 1) * sizeof(int));\n    }\n    for(i = 0; i < n-1; i++){\n        tree[x[i]][cnts[x[i]]++] = y[i];\n        tree[y[i]][cnts[y[i]]++] = x[i];\n    }\n    int ans = 0;\n    for(i = 0; i < cnt[0]; i++){\n        ans ^= dfs(tree[0][i], 0);\n    }\n\n\n    if(ans == 0){\n        printf(\"Bob\\n\");\n    }else{\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "//tree DP\n//ABC036-D\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val > ((sd*)b)->val){return -1;}\nif(((sd*)a)->val < ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    long long st;\n    long long fi;\n    long long kr;\n}rs;\n\ntypedef struct{\n    long long st;\n    long long kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st == ((rs*)b)->st){return 0;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nreturn 1;\n}\n\nvoid makemkj(rs g[],mkj x[],long long n){\n    long long i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\nlong long dist[524288],par[524288];\nvoid dfs(long long t,long long l,long long bp,rs g[],mkj x[]){\n  long long i;\n  if(dist[t]<=l){return;}\n  dist[t]=l;\n  par[t]=bp;\n  for(i=x[t].st;i<x[t].st+x[t].kz;i++){\n    dfs(g[i].fi,l+1,t,g,x);\n  }\n}\n\nint main(void){\n    long long i,j,n,m,k,a,b,c,h,w,r=0,l,t,ng;\n    long long bk,wk;\n    long long res=0;\n    long long grundy[524288]={0};\n    rs g[524288];\n    mkj x[524288];\n    sd dat[524288];\n    scanf(\"%lld\",&n);\n    for(i=0;i<(n-1);i++){\n      scanf(\"%lld%lld\",&a,&b);\n      g[2*i].st=a;\n      g[2*i].fi=b;\n      g[2*i].kr=1;\n      g[2*i+1].st=b;\n      g[2*i+1].fi=a;\n      g[2*i+1].kr=1;\n    }\n    qsort(g,2*(n-1),sizeof(g[0]),sortfnc);\n    makemkj(g,x,2*(n-1));\n    for(i=0;i<=n;i++){\n      dist[i]=inf;\n    }\n    dfs(1,0,-1,g,x);\n    for(i=0;i<n;i++){\n      dat[i].node=i+1;\n      dat[i].val=dist[i+1];\n    }\n    qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n    for(i=0;i<n;i++){\n      w=dat[i].node;\n      ng=0;\n      for(j=x[w].st;j<x[w].st+x[w].kz;j++){\n        if(par[w]==g[j].fi){continue;}\n        ng^=(grundy[g[j].fi]+1);\n      }\n      grundy[w]=ng;\n    }\n    if(grundy[1]){printf(\"Alice\\n\");}\n    else{printf(\"Bob\\n\");}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nint main()\n{\n\tint i, N, u, w;\n\tlist *adj[100001] = {}, e[200001];\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N - 1; i++) {\n\t\tscanf(\"%d %d\", &u, &w);\n\t\te[i*2].v = w;\n\t\te[i*2+1].v = u;\n\t\te[i*2].next = adj[u];\n\t\te[i*2+1].next = adj[w];\n\t\tadj[u] = &(e[i*2]);\n\t\tadj[w] = &(e[i*2+1]);\n\t}\n\t\n\tint par[100001] = {}, q[100001], head, tail;\n\tlist *p;\n\tpar[1] = 1;\n\tq[0] = 1;\n\tfor (head = 0, tail = 1; head < tail; head++) {\n\t\tu = q[head];\n\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\tw = p->v;\n\t\t\tif (par[w] == 0) {\n\t\t\t\tpar[w] = u;\n\t\t\t\tq[tail++] = w;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[100001] = {};\n\tfor (head--; head > 0; head--) {\n\t\tu = q[head];\n\t\tans[u]++;\n\t\tans[par[u]] ^= ans[u];\n\t}\n\t\n\tif (ans[1] == 0) printf(\"Bob\\n\");\n\telse printf(\"Alice\\n\");\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define datatype int\n\ntypedef struct edge_sub {\n\tint v;\n\tstruct edge_sub *next;\n}edge;\n\ntypedef struct {\n\tint num;\n\tint parent;\n\tint grundy;\n\tedge *e;\n}vertex;\n\ntypedef enum{\n\tfalse,\n\ttrue\n}Boolean;\n\ntypedef struct node_sub{\n\tdatatype data;\n\tstruct node_sub *next;\n}node;\n\ntypedef struct {\n\tnode *fst;\n\tnode *last;\n\tint num;\n}queue;\n\nqueue *make_queue(){\n\tqueue *q = (queue *)malloc(sizeof(queue));\n\tq->fst = NULL;\n\tq->last = NULL;\n\tq->num = 0;\n\treturn q;\n}\n\nBoolean is_empty_q(queue *q){\n\tif(q->num == 0){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid add_data_q(datatype val, queue *q){\n\tnode *last = (node *)malloc(sizeof(node));\n\tlast->data = val;\n\tlast->next = NULL;\n\tif(is_empty_q(q) == true){\n\t\tq->fst = last;\n\t}\n\telse{\n\t\tq->last->next = last;\n\t}\n\tq->last = last;\n\tq->num++;\n}\n\ndatatype take_data_q(queue *q){\n\tif(q->num == 0){\n\t\tprintf(\"no data in the queue\\n\");\n\t}\n\tdatatype ans = q->fst->data;\n\tnode *fst = q->fst;\n\tif(q->num == 1){\n\t\tq->fst = NULL;\n\t\tq->last = NULL;\n\t}\n\telse{\n\t\tq->fst = fst->next;\n\t}\n\tfree(fst);\n\tq->num--;\n\treturn ans;\n}\n\nvoid add_edge(int x, int y, vertex *V){\n\tedge *new;\n\tnew = (edge *)malloc(sizeof(edge));\n\tnew->v = y;\n\tnew->next = V[x].e;\n\tV[x].e = new;\n\tnew = (edge *)malloc(sizeof(edge));\n\tnew->v = x;\n\tnew->next = V[y].e;\n\tV[y].e = new;\n}\n\ntypedef struct {\n\tnode *fst;\n\tint num;\n}stack;\n\nstack *make_stack(){\n\tstack *s = (stack *)malloc(sizeof(stack));\n\ts->fst = NULL;\n\ts->num = 0;\n\treturn s;\n}\n\nBoolean is_empty_s(stack *s){\n\tif(s->num == 0){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid add_data_s(datatype val, stack *s){\n\tnode *fst = (node *)malloc(sizeof(node));\n\tfst->data = val;\n\tfst->next = s->fst;\n\ts->fst = fst;\n\ts->num++;\n}\n\ndatatype take_data_s(stack *s){\n\tif(s->num == 0){\n\t\tprintf(\"no data in the stack\\n\");\n\t}\n\tdatatype ans = s->fst->data;\n\tnode *fst = s->fst;\n\ts->fst = fst->next;\n\tfree(fst);\n\ts->num--;\n\treturn ans;\n}\n\nint main(){\n\tint N, x, y, i;\n\tvertex v;\n\tedge *e;\n\tscanf(\"%d\", &N);\n\tvertex *V = (vertex *)malloc(sizeof(vertex) * N);\n\tfor(i = 0; i < N; i++){\n\t\tV[i].num = i;\n\t\tV[i].parent = -1;\n\t\tV[i].grundy = 0;\n\t\tV[i].e = NULL;\n\t}\n\tfor(i = 1; i < N; i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd_edge(x - 1, y - 1, V);\n\t}\n\tqueue *q = make_queue();\n\tstack *s = make_stack();\n\tadd_data_q(0, q);\n\tadd_data_s(0, s);\n\twhile(is_empty_q(q) == false){\n\t\tv = V[take_data_q(q)];\n\t\t//printf(\"v.num = %d\\n\", v.num);\n\t\t//printf(\"v.parent = %d\\n\", v.parent);\n\t\te = v.e;\n\t\twhile(e != NULL){\n\t\t\tif(e->v != v.parent){\n\t\t\t\t//printf(\"e->v = %d\\n\", e->v);\n\t\t\t\tV[e->v].parent = v.num;\n\t\t\t\tadd_data_q(e->v, q);\n\t\t\t\tadd_data_s(e->v, s);\n\t\t\t}\n\t\t\te = e->next;\n\t\t}\n\t}\n\twhile(1){\n\t\tv = V[take_data_s(s)];\n\t\t//printf(\"v.num = %d\\n\", v.num);\n\t\t//printf(\"v.grundy = %d\\n\", v.grundy);\n\t\tif(v.parent == -1){\n\t\t\tbreak;\n\t\t}\n\t\tV[v.parent].grundy ^= (v.grundy + 1);\n\t}\n\tif(V[0].grundy == 0){\n\t\tprintf(\"Bob\\n\");\n\t}\n\telse{\n\t\tprintf(\"Alice\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 200000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 300000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n\n// using namespace std; // HELL\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nsize_t slen;\nsize_t tlen;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nvoid printUquotient (ull left, ull right) {\n\tconst int32_t digits = 20;\n\n\tprintf(\"%llu.\", left / right);\n\tleft %= right;\n\tfor (int32_t i = 0; i < digits; i++) {\n\t\tleft *= 10;\n\t\tprintf(\"%1d\", left / right);\n\t\tleft %= right;\n\t}\n\tputs(\"\");\n\n\treturn;\n}\n\nvoid printSquotient (sll left, sll right) {\n\tif (left * right < 0) putchar('-');\n\tprintUquotient(sdiff(left, 0), sdiff(right, 0));\n\n\treturn;\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#ifdef __cplusplus\n\nbool setfind (set<ull> s, ull x) {\n\treturn (s.find(x) != s.end());\n}\n\n#endif\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\null parent[N_MAX];\null rank[N_MAX];\nvoid uf_init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\trank[i] = 0;\n\t}\n}\null uf_find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = uf_find(parent[x]);\n}\nbool uf_union (ull a, ull b) {\n\ta = uf_find(a);\n\tb = uf_find(b);\n\tif (a == b) return false;\n\n\tif (rank[a] > rank[b]) {\n\t\tparent[b] = a;\n\t} else {\n\t\tparent[a] = b;\n\t\tif (rank[a] == rank[b]) {\n\t\t\trank[b]++;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll c[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// hwll xy[N_MAX];\n\null path[N_MAX * 2];\null pathi[N_MAX * 2];\null pathilen[N_MAX * 2];\null pathitmp[N_MAX * 2];\n\nbool iswatched[N_MAX];\null grundy (ull v) {\n\tiswatched[v] = true;\n\n\tsll i;\n\tull xored = 0;\n\tfor (i = 0; i < pathilen[v]; i++) {\n\t\tull u = path[pathi[v] + i];\n\t\tif (iswatched[u]) continue;\n\n\t\txored ^= (grundy(u) + 1);\n\t}\n\n\treturn xored;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\tpathilen[a[i]]++;\n\t\tpathilen[b[i]]++;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tpathi[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tpathi[i] = pathi[i - 1] + pathilen[i - 1];\n\t}\n\tfor (i = 0; i < n - 1; i++) {\n\t\tpath[pathi[a[i]] + pathitmp[a[i]]++] = b[i];\n\t\tpath[pathi[b[i]] + pathitmp[b[i]]++] = a[i];\n\t}\n\n\tputs(grundy(0) ? \"Alice\" : \"Bob\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Takahashi\");\n\treturn 0;\n\n\tfail:\n\tputs(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Aoki\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%lf%lf\", &vda, &vdb, &vdc);\n\t// scanf(\"%lld%lld\", &vsa, &vsb, &vsc, &vsd);\n\t// scanf(\"%llu%llu%llu%llu\", &vua, &vub, &vuc, &vud);\n\t// scanf(\"%*llu%*llu\");\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n);\n\t// scanf(\"%llu%llu%llu%llu\", &vua, &vub, &vuc, &vud, &vue, &vuf);\n\t// vua--;\n\t// vub--;\n\t// vuc--;\n\t// vud--;\n\t// scanf(\"%lld%lld\", &vsa, &vsb, &vsc);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n - 1; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%llu\", &c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t}\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%llu\", &a[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\n\ntypedef struct directed_edge {\n  int32_t vertex;\n  int32_t next;\n} graph_edge;\n\ntypedef struct directedGraph {\n  graph_edge *edge;\n  int32_t *start;\n  int32_t pointer;\n  int32_t vertex_num;\n  int32_t edge_max_size;\n} graph;\n\ngraph* new_graph (const int vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->edge = (graph_edge *) calloc (1, sizeof (graph_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->vertex_num = vertex_num;\n  g->edge_max_size = 1;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph *g, int32_t from, int32_t to) {\n  if (g->pointer == g->edge_max_size) {\n    g->edge_max_size *= 2;\n    g->edge = (graph_edge *) realloc (g->edge, sizeof (graph_edge) * g->edge_max_size);\n  }\n  g->edge[g->pointer] = (graph_edge) {to, g->start[from]};\n  g->start[from] = g->pointer++;\n}\n\nvoid BFS_graph (graph *g, int32_t src, i32 *q, i32 *parent) {\n  uint8_t *used = (uint8_t *) calloc (g->vertex_num, sizeof (uint8_t));\n  int32_t front = 0;\n  int32_t last = 0;\n  used[src] = 1;\n  q[last++] = src;\n  parent[src] = -1;\n  while (front < last) {\n    const int32_t v = q[front++];\n    for (int32_t p = g->start[v]; p != -1; p = g->edge[p].next) {\n      const int32_t u = g->edge[p].vertex;\n      //hoge\n      if (!used[u]) {\n        used[u] = 1;\n        q[last++] = u;\n        parent[u] = v;\n      }\n    }\n  }\n  free(used);\n}\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  graph *g = new_graph (n);\n  for (i32 i = 1; i < n; ++i) {\n    i32 a, b;\n    scanf (\"%\" SCNi32 \"%\" SCNi32, &a, &b);\n    a--; b--;\n    add_edge (g, a, b);\n    add_edge (g, b, a);\n  }\n  i32 *q = ALLOC (n, i32);\n  i32 *parent = ALLOC (n, i32);\n  BFS_graph (g, 0, q, parent);\n  i32 *dp = ALLOC (n, i32);\n  for (i32 i = n - 1; i >= 0; --i) {\n    i32 v = q[i];\n    for (i32 p = g->start[v]; p != -1; p = g->edge[p].next) {\n      i32 u = g->edge[p].vertex;\n      if (u == parent[v]) continue;\n      dp[v] ^= 1 + dp[u];\n    }\n  }\n  puts (dp[0] > 0 ? \"Alice\" : \"Bob\");\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint x[100000], y[100000];\nint cnt[100000], cnts[100000], *tree[100000];\nint dfs(int a, int b){\n    if(cnt[a] == 1){//何も繋がっていない頂点,\n        return 0;\n    }\n    int i;\n    int g_list[100000];\n    for(i = 0; i < cnt[a]; i++){\n        g_list[i] = 0;\n    }\n    for(i = 0; i < cnt[a]; i++){\n        if(tree[a][i] == b){\n            continue;\n        }\n        g_list[dfs(tree[a][i], a)] = 1;\n    }\n    for(i = 0; i < 100000; i++){\n        if(g_list[i] == 0){\n            return i;\n        }\n    }\n}\nint main(void){\n    int n, i, j;\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++){\n        cnt[i] = 0;\n        cnts[i] = 0;\n    }\n    for(i = 0; i < n-1; i++){\n        scanf(\"%d%d\", &x[i], &y[i]);\n        x[i]--;\n        y[i]--;\n        cnt[x[i]]++;\n        cnt[y[i]]++;\n    }\n    for(i = 0; i < n; i++){\n        tree[i] = malloc((cnt[i] + 1) * sizeof(int));\n    }\n    for(i = 0; i < n-1; i++){\n        tree[x[i]][cnts[x[i]]++] = y[i];\n        tree[y[i]][cnts[y[i]]++] = x[i];\n    }\n    int ans = 0;\n    for(i = 0; i < cnt[0]; i++){\n        ans ^= dfs(tree[0][i], 0);\n    }\n\n\n    if(ans == 0){\n        printf(\"Bob\\n\");\n    }else{\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "Julia",
    "code": "parseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\n\nfunction main()\n\tn = readline() |> parseInt\n\te = [Int[] for i in 1:n]\n\tfor i in 1:n-1\n\t\tx,y = readline() |> split |> parseMap\n\t\tpush!(e[x],y)\n\t\tpush!(e[y],x)\n\tend\n\tv = -ones(Int,n)\n\tt = -ones(Int,n)\n\tt[1] = 0\n\tv[1] = 0\n\tstack = Int[1]\n\twhile !isempty(stack)\n\t\tnow = shift!(stack)\n\t\tfor i in e[now]\n\t\t\tif t[i] == -1\n\t\t\t\tt[i] = t[now]+1\n\t\t\t\tv[i] = now\n\t\t\t\tpush!(stack,i)\n\t\t\tend\n\t\tend\n\tend\n\tm = maximum(t)\n\tz = Tuple{Int,Int}[(t[i],i) for i in 1:n]\n\tz = sort(z,by=x->x[1],rev=true)\n\tval = -ones(Int,n)\n\tfor key in 1:n\n\t\ti = z[key][2]\n\t\tif i!=1&&length(e[i]) == 1\n\t\t\tval[i] = 0\n\t\telse\n\t\t\tif i!=1&&length(e[i])==2 || i==1&&length(e[i])==1\n\t\t\t\tfor j in 1:length(e[i])\n\t\t\t\t\tif e[i][j] != v[i]\n\t\t\t\t\t\tval[i] = val[e[i][j]] + 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tval[i] = 0\n\t\t\t\tfor j in 1:length(e[i])\n\t\t\t\t\tif e[i][j] != v[i]\n\t\t\t\t\t\tval[i] = val[e[i][j]]$val[i]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tprintln(val[1]>0?\"Alice\":\"Bob\")\nend\n\nmain()\n"
  },
  {
    "language": "Julia",
    "code": "parseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\n\nfunction main()\n\tn = readline() |> parseInt\n\te = [Int[] for i in 1:n]\n\tfor i in 1:n-1\n\t\tx,y = readline() |> split |> parseMap\n\t\tpush!(e[x],y)\n\t\tpush!(e[y],x)\n\tend\n\tv = -ones(Int,n)\n\tt = -ones(Int,n)\n\tt[1] = 0\n\tv[1] = 0\n\tstack = Int[1]\n\twhile !isempty(stack)\n\t\tnow = shift!(stack)\n\t\tfor i in e[now]\n\t\t\tif t[i] == -1\n\t\t\t\tt[i] = t[now]+1\n\t\t\t\tv[i] = now\n\t\t\t\tpush!(stack,i)\n\t\t\tend\n\t\tend\n\tend\n\tm = maximum(t)\n\tz = Tuple{Int,Int}[(t[i],i) for i in 1:n]\n\tz = sort(z,by=x->x[1],rev=true)\n\tval = -ones(Int,n)\n\tfor key in 1:n\n\t\ti = z[key][2]\n\t\tif i!=1&&length(e[i]) == 1\n\t\t\tval[i] = 0\n\t\telse\n\t\t\tif i!=1&&length(e[i])==2 || i==1&&length(e[i])==1\n\t\t\t\tfor j in 1:length(e[i])\n\t\t\t\t\tif e[i][j] != v[i]\n\t\t\t\t\t\tval[i] = val[e[i][j]] + 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tval[i] = 0\n\t\t\t\tfor j in 1:length(e[i])\n\t\t\t\t\tif e[i][j] != v[i]\n\t\t\t\t\t\tval[i] = (val[e[i][j]]+1)$val[i]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tprintln(val[1]>0?\"Alice\":\"Bob\")\nend\n\nmain()\n"
  },
  {
    "language": "Julia",
    "code": "parseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\n\nfunction main()\n\tn = readline() |> parseInt\n\te = [Int[] for i in 1:n]\n\tfor i in 1:n-1\n\t\tx,y = readline() |> split |> parseMap\n\t\tpush!(e[x],y)\n\t\tpush!(e[y],x)\n\tend\n\tt = -ones(Int,n)\n\tt[1] = 0\n\tstack = Int[1]\n\twhile !isempty(stack)\n\t\tnow = shift!(stack)\n\t\tfor i in e[now]\n\t\t\tif t[i] == -1\n\t\t\t\tt[i] = t[now]+1\n\t\t\t\tpush!(stack,i)\n\t\t\tend\n\t\tend\n\tend\n\td = Dict{Int,Int}()\n\tfor i in 2:n\n\t\tif haskey(d,t[i])\n\t\t\td[t[i]] += 1\n\t\telse\n\t\t\td[t[i]] = 1\n\t\tend\n\tend\n\tf = 0\n\tfor v in values(d)\n\t\tif v%2==1\n\t\t\tf = 1\n\t\tend\n\tend\n\tprintln(f==1?\"Alice\":\"Bob\")\nend\n\nmain()\n"
  },
  {
    "language": "Pascal",
    "code": "var\n  con,temp,i,j:longint;\n  fin:array[1..7500]of boolean;\n  b,a,fa:array[1..7500]of integer;\nbegin\n  {$IFNDEF ONLINE_JUDGE}\n  assign(input,'input.in');reset(input);\n  assign(output,'output.out');rewritE(output);\n  {$ENDIF}\n  reaD(temp);\n  con:=0;\n  while temp<>0 do\n    begin\n      inc(con);\n      a[con]:=temp;\n      inc(b[temp]);\n      read(temp);\n    end;\n  for i := 1 to con do\n    for j := 1 to con+1 do\n      if (not fin[j])and(b[j]=0) then\n        begin\n          fin[j]:=true;\n          fa[j]:=a[i];\n          deC(b[a[i]]);\n          break;\n        end;\n  for i := 1 to con+1 do\n    begin\n      write(i,':');\n      for j := 1 to con+1 do\n        if (fa[j]=i)or(fa[i]=j) then\n          write(' ',j);\n      writeln;\n    end;\nend."
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DGameOnTree solver = new DGameOnTree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DGameOnTree {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                Node a = nodes[in.readInt() - 1];\n                Node b = nodes[in.readInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n\n            dfs(nodes[0], null);\n            if (nodes[0].sg == 0) {\n                out.println(\"Bob\");\n            } else {\n                out.println(\"Alice\");\n            }\n        }\n\n        public void dfs(Node root, Node p) {\n            for (Node node : root.adj) {\n                if (node == p) {\n                    continue;\n                }\n                dfs(node, root);\n                root.sg ^= node.sg + 1;\n            }\n        }\n\n    }\n\n    static class Node {\n        List<Node> adj = new ArrayList<>();\n        int sg;\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic class Tree {\n\t\tpublic class Edge {\n\t\t\tint to, rev;\n\n\t\t\tpublic Edge(int to, int rev) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint V;\n\t\tArrayList<ArrayList<Edge>> G;\n\t\tint root;\n\t\tint[] p;\n\t\t\n\t\tpublic Tree(int[] a, int[] b) {\n\t\t\tthis.V = a.length+1;\n\t\t\tp = new int[V];\n\t\t\t\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0; i<V; i++) {\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<V-1; i++) {\n\t\t\t\tG.get(a[i]).add(new Edge(b[i], G.get(b[i]).size()));\n\t\t\t\tG.get(b[i]).add(new Edge(a[i], G.get(a[i]).size()-1));\n\t\t\t}\n\t\t\tsetRoot(0);\n\t\t}\n\t\t\n\t\tpublic void setRoot(int root) {\n\t\t\tthis.root = root;\n\t\t\tsetRoot(root, -1);\n\t\t}\n\t\tpublic void setRoot(int cur, int parent) {\n\t\t\tp[cur] = parent;\n\t\t\tfor(int i=0; i<G.get(cur).size(); i++) {\n\t\t\t\tint next = G.get(cur).get(i).to;\n\t\t\t\tif(next!=parent) {\n\t\t\t\t\tsetRoot(next, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int getXor() {\n\t\t\tint xor = 0;\n\t\t\tfor(Edge e : G.get(root)) {\n\t\t\t\txor ^= getXor(e.to);\n\t\t\t}\n\t\t\treturn xor;\n\t\t}\n\t\t\n\t\tint getXor(int cur) {\n\t\t\tint ans = 1;\n\t\t\twhile(true) {\n\t\t\t\tif(G.get(cur).size()!=2)\n\t\t\t\t\treturn ans;\n\t\t\t\tif(G.get(cur).get(0).to==p[cur])\n\t\t\t\t\tcur = G.get(cur).get(1).to;\n\t\t\t\telse\n\t\t\t\t\tcur = G.get(cur).get(0).to;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N-1];\n\t\tint[] b = new int[N-1];\n\t\tfor(int i=0; i<N-1; i++) {\n\t\t\ta[i] = sc.nextInt()-1;\n\t\t\tb[i] = sc.nextInt()-1;\n\t\t}\n\t\t\n\t\tTree tree = new Tree(a, b);\n\t\t\n\t\tint xor = tree.getXor();\n\t\t\n\t\tSystem.out.println(xor==0 ? \"Bob\" : \"Alice\");\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nclass Main{\n    static int grundy(int v, int pare){\n        int res = 0;\n        for(int u : Edge[v])if(u!=pare)res^=(1+grundy(u,v));\n        return res;\n    }\n\n    static List<Integer> Edge[];\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        Edge = new ArrayList[N];\n        for(int i=0;i<N;++i)Edge[i]=new ArrayList<>();\n        for(int i=0;i<N-1;++i){\n            int x = scan.nextInt()-1;\n            int y= scan.nextInt()-1;\n            Edge[x].add(y);\n            Edge[y].add(x);\n        }\n        if(grundy(0,-1)==0){\n            System.out.println(\"Bob\");\n        }else{\n            System.out.println(\"Alice\");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tint[] head;\n\tint[] next;\n\tint[] to;\n\t\n\tvoid addEdge(int v, int u, int idx) {\n\t\tto[idx] = u;\n\t\tnext[idx] = head[v];\n\t\thead[v] = idx;\n\t}\n\t\n\tint dfs(int v, int p) {\n\t\tint ret = 0;\n\t\tfor (int e = head[v]; e >= 0; e = next[e]) {\n\t\t\tint u = to[e];\n\t\t\tif (u != p) {\n\t\t\t\tret ^= dfs(u, v) + 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\thead = new int[n];\n\t\tArrays.fill(head, -1);\n\t\tnext = new int[2 * n - 2];\n\t\tto = new int[2 * n -2];\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint v = nextInt() - 1;\n\t\t\tint u = nextInt() - 1;\n\t\t\taddEdge(v, u, 2 * i);\n\t\t\taddEdge(u, v, 2 * i + 1);\n\t\t}\n\t\t\n\t\tint ret = dfs(0, -1);\n\t\tout.println(ret == 0 ? \"Bob\" : \"Alice\");\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "/**\n * @author Finn Lidbetter\n */\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\n\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringBuilder sb = new StringBuilder();\n\n    int n = Integer.parseInt(br.readLine());\n    Node[] nodes = new Node[n];\n    for (int i=0; i<n; i++) {\n      nodes[i] = new Node(i);\n    }\n    for (int i=0; i<n-1; i++) {\n      String[] s = br.readLine().split(\" \");\n      int a = Integer.parseInt(s[0])-1;\n      int b = Integer.parseInt(s[1])-1;\n      nodes[a].adj.add(nodes[b]);\n      nodes[b].adj.add(nodes[a]);\n    }\n    if (solve(nodes[0],-1)!=0) {\n      System.out.println(\"Alice\");\n    } else {\n      System.out.println(\"Bob\");\n    }\n\n\n  }\n  static int solve(Node a, int from) {\n    if (a.adj.size()==1 && a.i!=0) {\n      return 0;\n    }\n    int ans = 0;\n    for (Node n:a.adj) {\n      if (n.i!=from) {\n        ans ^= 1+solve(n,a.i);\n      }\n    }\n    //System.out.println(\"Answer for \"+a.i+\": \"+ans);\n    return ans;\n  }\n}\nclass Node {\n  int i;\n  ArrayList<Node> adj;\n  public Node(int ii) {\n    i = ii;\n    adj = new ArrayList<Node>();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main implements Runnable {\n\tprivate static BufferedReader in;\n\tprivate static PrintWriter out;\n\tprivate static StringTokenizer st;\n\tprivate static Random rnd;\n\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tList<Integer>[] tree = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttree[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint u = nextInt() - 1;\n\t\t\tint v = nextInt() - 1;\n\t\t\ttree[u].add(v);\n\t\t\ttree[v].add(u);\n\t\t}\n\t\tint res = dfs(0, -1, tree);\n\t\tout.println(res == 1 ? \"Alice\" : \"Bob\");\n\t}\n\n\n\tprivate int dfs(int u, int p, List<Integer>[] tree) {\n\t\tList<Integer> childs = tree[u];\n\t\tint childsCount = childs.size() + ((p == -1) ? 0 : -1);\n\t\tif (childsCount == 0) {\n\t\t\treturn 0;\n\t\t} else if (childsCount == 1) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tint x = 0;\n\t\t\tfor (int v : childs) {\n\t\t\t\tif (v != p)\n\t\t\t\t\tx ^= dfs(v, u, tree);\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  static ArrayList[] edge;\n  \n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int N = sc.nextInt();\n    edge = new ArrayList[N + 1];\n    for(int i = 1; i < N + 1; i++) {\n      edge[i] = new ArrayList<Integer>();\n    }\n    for(int i = 0; i < N - 1; i++) {\n      int x = sc.nextInt();\n      int y = sc.nextInt();\n      edge[x].add(y);\n      edge[y].add(x);\n    }\n    String ans = \"Alice\";\n    if(dfs(1, 0) == 0) ans = \"Bob\";\n    System.out.println(ans);\n  }\n\n  public static int dfs(int v, int p) {\n    ArrayList<Integer> list = edge[v];\n    int ret = 0;\n    for(int i = 0; i < list.size(); i++) {\n      int u = list.get(i);\n      if(u != p) {\n        ret = (ret ^ (dfs(u, v) + 1));\n      }\n    }\n    return ret;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.OptionalInt;\nimport java.util.PrimitiveIterator;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int n = sc.nextInt();\n        var builder = new TreeBuilder(n);\n        for (int i = 1; i < n; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            builder.addEdge(u, v);\n        }\n        var t = builder.build();\n        int[] p = t.parent();\n        int[] ord = Trees.postorder(t);\n        int[] grundy = new int[n];\n        for (int u : ord) {\n            t.getEdges(u).iterator().forEachRemaining((int v) -> {\n                if (v != p[u]) {\n                    grundy[u] ^= grundy[v] + 1;\n                }\n            });;\n        }\n        out.writeln(grundy[0] == 0 ? \"Bob\" : \"Alice\");\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair {\n    public int fst, snd;\n    public IntPair(final int fst, final int snd) {this.fst = fst; this.snd = snd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair)) return false;\n        final IntPair p = (IntPair) o;\n        return this.fst == p.fst && this.snd == p.snd;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 1;\n        hash = hash * 31 + fst;\n        hash = hash * 31 + snd;\n        return hash;\n    }\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \")\";}\n}\n\n\n\nclass Trees {\n    public static int diameter(Tree t) {\n        final int n = t.n;\n        final int[] dep = t.dep();\n        int maxd = 0, maxv = t.root;\n        for (int v = 0; v < n; v++) if (maxd < dep[v]) {maxd = dep[v]; maxv = v;}\n        final IntDeque q = new IntDeque(n);\n        q.addLast(maxv);\n        final int[] d = new int[n];\n        while (q.size() > 0) {\n            final int u = q.removeFirst();\n            final PrimitiveIterator.OfInt iter = t.getEdges(u).iterator();\n            while (iter.hasNext()) {\n                final int v = iter.nextInt();\n                if (v != t.parent(u)) {\n                    q.addLast(v);\n                    maxd = Math.max(maxd, d[v] = d[u] + 1);\n                }\n            }\n        }\n        return maxd;\n    }\n    public static int[] preorderInv(Tree t) {\n        final int[] ret = new int[t.n];\n        final int[] par = t.parent();\n        final IntDeque st = new IntDeque(t.n);\n        st.addLast(t.root);\n        for (int k = 0; st.size() > 0;) {\n            final int v = st.removeLast();\n            ret[v] = k++;\n            t.getEdges(v).iterator().forEachRemaining((int u) -> {if (u != par[v]) st.addLast(u);});\n        }\n        return ret;\n    }\n    public static int[] preorder(Tree t) {\n        final int[] ret = new int[t.n];\n        final int[] par = t.parent();\n        final IntDeque st = new IntDeque(t.n);\n        st.addLast(t.root);\n        for (int k = 0; st.size() > 0;) {\n            final int v = st.removeLast();\n            ret[k++] = v;\n            t.getEdges(v).iterator().forEachRemaining((int u) -> {if (u != par[v]) st.addLast(u);});\n        }\n        return ret;\n    }\n    public static int[] postorderInv(Tree t) {\n        final int[] ret = new int[t.n];\n        final int[] par = t.parent();\n        final IntDeque st = new IntDeque(t.n);\n        st.addLast(~t.root); st.addLast( t.root);\n        for (int k = 0; st.size() > 0;) {\n            final int v = st.removeLast();\n            if (v >= 0) {\n                t.getEdges(v).iterator().forEachRemaining((int u) -> {\n                    if (u != par[v]) {st.addLast(~u); st.addLast(u);}\n                });\n            } else ret[v] = k++;\n        }\n        return ret;\n    }\n    public static int[] postorder(Tree t) {\n        final int[] ret = new int[t.n];\n        final int[] par = t.parent();\n        final IntDeque st = new IntDeque(t.n);\n        st.addLast(~t.root); st.addLast( t.root);\n        for (int k = 0; st.size() > 0;) {\n            final int v = st.removeLast();\n            if (v >= 0) {\n                t.getEdges(v).iterator().forEachRemaining((int u) -> {\n                    if (u != par[v]) {st.addLast(~u); st.addLast(u);}\n                });\n            } else ret[k++] = ~v;\n        }\n        return ret;\n    }\n    public static int[] subTreeSize(Tree t) {\n        int[] sub = new int[t.n];\n        subTreeSizeDFS(t, t.root, sub);\n        return sub;\n    }\n    private static int subTreeSizeDFS(Tree t, int u, int[] sub) {\n        sub[u] = 1;\n        t.getEdges(u).iterator().forEachRemaining((int v) -> {\n            if (v != t.parent(u)) sub[u] += subTreeSizeDFS(t, v, sub);\n        });\n        return sub[u];\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\nclass TreeBuilder {\n    private final Tree t;\n    public TreeBuilder(int n, int root) {this.t = new Tree(n, root);}\n    public TreeBuilder(int n) {this.t = new Tree(n);}\n    public void addEdge(final int from, final int to) {t.addEdge(from, to);}\n    public Tree build() {t.build();return t;}\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n    private static final int DEFAULT_SIZE = 64;\n    public IntArrayList(final int capacity) {this.a = new int[Math.max(1, capacity)];}\n    public IntArrayList() {this(DEFAULT_SIZE);}\n    public void add(final int v) {\n        if (tail == a.length) grow();\n        a[tail++] = v;\n    }\n    public int removeLast() {return a[--tail];}\n    public int get(final int i) {\n        if (i >= tail) throw new IndexOutOfBoundsException(\"Index \" + i + \" out of bounds for length \" + size());\n        return a[i];\n    }\n    public void set(final int i, final int v) {\n        if (i >= tail) throw new IndexOutOfBoundsException(\"Index \" + i + \" out of bounds for length \" + size());\n        a[i] = v;\n    }\n    private void grow() {\n        final int[] b = new int[a.length << 1];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n    public int size() {return tail;}\n    public void clear() {tail = 0;}\n    public void reverse(final int begin, final int end) {IntArrays.reverse(a, begin, end);}\n    public void reverse() {IntArrays.reverse(a, 0, tail);}\n    public int[] toArray() {\n        final int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n    public void sort() {Arrays.sort(a, 0, tail);}\n    public boolean addIf(final int v, final IntPredicate p) {\n        if (p.test(v)) {add(v); return true;}\n        return false;\n    }\n    public PrimitiveIterator.OfInt iterator() {return new IntArrayListIterator();}\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n        public boolean hasNext() {return i < tail;}\n        public int nextInt() {return a[i++];}\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nfinal class IntArrays {\n    private IntArrays(){}\n    public static void swap(final int[] a, final int u, final int v) {\n        final int tmp = a[u]; a[u] = a[v]; a[v] = tmp;\n    }\n    public static void reverse(final int[] a, int begin, int end) {\n        while (end - begin > 1) swap(a, begin++, --end);\n    }\n    public static void reverse(final int[] a) {reverse(a, 0, a.length);}\n    public static void sortDescending(final int[] a) {Arrays.sort(a); reverse(a);}\n    public static int fold(final int[] a, final IntBinaryOperator op) {\n        int ret = a[0]; for (int i = 1; i < a.length; i++) ret = op.applyAsInt(ret, a[i]);\n        return ret;\n    }\n    public static int sum(final int[] a) {return fold(a, Integer::sum);}\n    public static int max(final int[] a) {return fold(a, Integer::max);}\n    public static int min(final int[] a) {return fold(a, Integer::min);}\n    public static IntPair maxWithIndex(final int[] a) {\n        int max = max(a); return new IntPair(find(a, max), max);\n    }\n    public static IntPair minWithIndex(final int[] a) {\n        int min = min(a); return new IntPair(find(a, min), min);\n    }\n    public static int find(final int[] a, final int v) {\n        for (int i = 0; i < a.length; i++) if (a[i] == v) return i;\n        return -1;\n    }\n    public static void map(final int[] a, final IntUnaryOperator op) {Arrays.setAll(a, i -> op.applyAsInt(a[i]));}\n    public static int filter(final int[] src, final int[] dst, final IntPredicate p) {\n        int idx = 0;\n        for (final int e : src) if (p.test(e)) dst[idx++] = e;\n        return idx;\n    }\n    public static int filterIndex(final int[] dst, final int beginIndex, final int endIndex, final IntPredicate p) {\n        int idx = 0;\n        for (int i = beginIndex; i < endIndex; i++) if (p.test(i)) dst[idx++] = i;\n        return idx;\n    }\n    public static int filterIndex(final int dst[], final int endIndex, final IntPredicate p) {\n        return filterIndex(dst, 0, endIndex, p);\n    }\n    public static void accumulate(final int[] a, final IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) a[i] = op.applyAsInt(a[i - 1], a[i]);\n    }\n    public static void accumulate(final int[] a) {\n        for (int i = 1; i < a.length; i++) a[i] += a[i - 1];\n    }\n    public static void permute(int[] p, int[] a) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                int tmp = a[j]; a[j] = a[p[j]]; a[p[j]] = tmp;\n                settled[j] = true;\n            }\n        }\n    }\n    public static void permute2(int[] p, int[] a, int[] b) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                int tmp;\n                tmp = a[j]; a[j] = a[p[j]]; a[p[j]] = tmp;\n                tmp = b[j]; b[j] = b[p[j]]; b[p[j]] = tmp;\n                settled[j] = true;\n            }\n        }\n    }\n    public static void permute3(int[] p, int[] a, int[] b, int[] c) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                int tmp;\n                tmp = a[j]; a[j] = a[p[j]]; a[p[j]] = tmp;\n                tmp = b[j]; b[j] = b[p[j]]; b[p[j]] = tmp;\n                tmp = c[j]; c[j] = c[p[j]]; c[p[j]] = tmp;\n                settled[j] = true;\n            }\n        }\n    }\n    public static void permuteN(int[] p, int[]... as) {\n        for (int[] a : as) permute(p, a);\n    }\n    public static int lowerBound(int[] sorted, int key) {\n        int n = sorted.length;\n        int l = -1, r = n;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (sorted[m] < key) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    public static int upperBound(int[] sorted, int key) {\n        int n = sorted.length;\n        int l = -1, r = n;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (sorted[m] <= key) l = m;\n            else r = m;\n        }\n        return r;\n    }\n    public static int countRange(int[] sorted, int fromKey, int toKey) {\n        return lowerBound(sorted, toKey) - lowerBound(sorted, fromKey);\n    }\n    public static int compare(final int[] a, final int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (i >= b.length) return -1;\n            if (a[i] > b[i]) return 1;\n            if (a[i] < b[i]) return -1;\n        }\n        return a.length < b.length ? 1 : 0;\n    }\n    public static boolean equals(final int[] a, final int[] b) {return compare(a, b) == 0;}\n    public static String join(final int[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String joinWithPrefixAndSuffix(final int[] a, final IntFunction<String> idxToPre, final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class Tree {\n    public final int n;\n    public final int root;\n    private final IntArrayList[] adj;\n    private final int[] par;\n    private final int[] dep;\n    Tree(final int n, final int root) {\n        this.n = n;\n        this.root = root;\n        this.adj = new IntArrayList[n];\n        for (int i = 0; i < n; i++) adj[i] = new IntArrayList();\n        this.par = new int[n];\n        this.dep = new int[n];\n    }\n    Tree(final int n) {this(n, 0);}\n    public IntArrayList getEdges(final int i) {return adj[i];}\n    public int   parent(final int i) {return par[i];}\n    public int[] parent()            {return par;}\n    public int   dep   (final int i) {return dep[i];}\n    public int[] dep   ()            {return dep;}\n    void addEdge(final int from, final int to) {adj[from].add(to); adj[to].add(from);}\n    void build() {\n        final IntDeque que = new IntDeque(n);\n        que.addLast(root);\n        par[root] = root;\n        while (que.size() > 0) {\n            final int v = que.removeFirst();\n            adj[v].iterator().forEachRemaining((int u) -> {\n                if (u != par[v]) {\n                    dep[u] = dep[v] + 1;\n                    par[u] = v;\n                    que.addLast(u);\n                }\n            });\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * Implementation of deque for primitive int type, using Ring Buffer.\n */\nfinal class IntDeque implements Iterable<Integer> {\n    static final int DEFAULT_CAPACITY = 1 << 6;\n    int[] buf;\n    int len = 1;\n    int mask;\n    int head = 0;\n    int tail = 0;\n    public IntDeque(int capacity) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\n                String.format(\"Capacity %d is negative.\", capacity)\n            );\n        }\n        while (this.len < capacity) {\n            this.len <<= 1;\n        }\n        this.mask = this.len - 1;\n        this.buf = new int[len];\n    }\n    public IntDeque() {\n        this(DEFAULT_CAPACITY);\n    }\n    public int getLast() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[(tail - 1) & mask];\n    }\n    public int getFirst() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[head];\n    }\n    public int get(int index) {\n        if (index < 0 || index >= size()) {\n            throw new IndexOutOfBoundsException(\n                String.format(\"Index %d out of bounds for length %d.\", index, size())\n            );\n        }\n        return buf[(head + index) & mask];\n    }\n    public void addLast(int v) {\n        if (size() == len) grow();\n        buf[tail++ & mask] = v;\n    }\n    public void addFirst(int v) {\n        if (size() == len) grow();\n        buf[--head & mask] = v;\n    }\n    public int removeLast() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[--tail & mask];\n    }\n    public int removeFirst() {\n        if (size() == 0) throw new NoSuchElementException();\n        return buf[head++ & mask];\n    }\n    public OptionalInt pollLast() {\n        if (size() == 0) return OptionalInt.empty();\n        return OptionalInt.of(removeLast());\n    }\n    public OptionalInt pollFirst() {\n        if (size() == 0) return OptionalInt.empty();\n        return OptionalInt.of(removeFirst());\n    }\n    public int size() {\n        return tail - head;\n    }\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n    public void clear() {\n        head = tail = 0;\n    }\n    public int[] toArray() {\n        int[] ret = new int[size()];\n        PrimitiveIterator.OfInt it = iterator();\n        Arrays.setAll(ret, i -> it.nextInt());\n        return ret;\n    }\n    private void grow() {\n        int[] newBuf = new int[len << 1];\n        head &= mask;\n        tail &= mask;\n        int len1 = len - head;\n        int len2 = head;\n        System.arraycopy(buf, head, newBuf, 0, len1);\n        System.arraycopy(buf, 0, newBuf, len1, len2);\n        this.head = 0;\n        this.tail = this.len;\n        this.len <<= 1;\n        this.mask = this.len - 1;\n        this.buf = newBuf;\n    }\n    public PrimitiveIterator.OfInt iterator() {\n        return new PrimitiveIterator.OfInt(){\n            int it = head;\n            public boolean hasNext() {return it < tail;}\n            public int nextInt() {return buf[it++ & mask];}\n        };\n    }\n    public PrimitiveIterator.OfInt descendingIterator() {\n        return new PrimitiveIterator.OfInt(){\n            int it = tail;\n            public boolean hasNext() {return it > head;}\n            public int nextInt() {return buf[--it & mask];}\n        };\n    }\n\n    /***************************** DEBUG *********************************/\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append('[');\n        PrimitiveIterator.OfInt it = iterator();\n        while (it.hasNext()) {\n            sb.append(it.next().toString());\n            if (it.hasNext()) sb.append(',');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PrimitiveIterator;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        int n = In.ni();\n        ArrayList<IntArrayList> g = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            g.add(new IntArrayList());\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int x = In.ni() - 1;\n            int y = In.ni() - 1;\n            g.get(x).add(y);\n            g.get(y).add(x);\n        }\n        int[] cnt = new int[n];\n        int[] par = new int[n];\n        int[] dep = new int[n];\n        IntQueue q = new IntQueue(n);\n        q.add(0);\n        while (q.size() > 0) {\n            int u = q.poll();\n            cnt[dep[u]]++;\n            g.get(u).iterator().forEachRemaining((int v) -> {\n                if (v != par[u]) {\n                    par[v] = u;\n                    dep[v] = dep[u] + 1;\n                    q.add(v);\n                }\n            });\n        }\n        for (int i = 1; i < n; i++) {\n            if ((cnt[i] & 1) != 0) {\n                out.append(\"Alice\");\n                return;\n            }\n        }\n        out.append(\"Bob\");\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n    public static int ni() {return fsc.nextInt();}\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();\n        return a;\n    }\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());\n        return a;\n    }\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m);\n        return a;\n    }\n    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m, f);\n        return a;\n    }\n    public static long nl() {return fsc.nextLong();}\n    public static long[] nl(final int n) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();\n        return a;\n    }\n    public static long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());\n        return a;\n    }\n    public static long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m);\n        return a;\n    }\n    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m, f);\n        return a;\n    }\n    public static char[] nc() {return fsc.next().toCharArray();}\n    public static char[][] nc(final int n) {\n        final char[][] c = new char[n][];\n        for (int i = 0; i < n; i++) c[i] = nc();\n        return c;\n    }\n    public static double nd() {return fsc.nextDouble();}\n    public static double[] nd(final int n) {\n        final double[] a = new double[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();\n        return a;\n    }\n    public static double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        for (int i = 0; i < n; i++) a[i] = nd(m);\n        return a;\n    }\n    public static String ns() {return fsc.next();}\n    public static String[] ns(final int n) {\n        final String[] s = new String[n];\n        for (int i = 0; i < n; i++) s[i] = fsc.next();\n        return s;\n    }\n    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buffer);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        for (; ; b = readByte()) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n    private static final int DEFAULT_SIZE = 64;\n    public IntArrayList(final int capacity) {this.a = new int[Math.max(1, capacity)];}\n    public IntArrayList() {this(DEFAULT_SIZE);}\n    public void add(final int v) {\n        if (tail == a.length) grow();\n        a[tail++] = v;\n    }\n    public int removeLast() {return a[tail--];}\n    public int get(final int i) {\n        if (i >= tail) throw new IndexOutOfBoundsException(\"Index \" + i + \" out of bounds for length \" + size());\n        return a[i];\n    }\n    public void set(final int i, final int v) {\n        if (i >= tail) throw new IndexOutOfBoundsException(\"Index \" + i + \" out of bounds for length \" + size());\n        a[i] = v;\n    }\n    private void grow() {\n        final int[] b = new int[a.length << 1];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n    public int size() {return tail;}\n    public void reverse(final int begin, final int end) {IntArrays.reverse(a, begin, end);}\n    public void reverse() {IntArrays.reverse(a, 0, tail);}\n    public int[] toArray() {\n        final int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n    public boolean addIf(final int v, final IntPredicate p) {\n        if (p.test(v)) {add(v); return true;}\n        return false;\n    }\n    public void clear() {tail = 0;}\n    public PrimitiveIterator.OfInt iterator() {return new IntArrayListIterator();}\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n        public boolean hasNext() {return i < tail;}\n        public int nextInt() {return a[i++];}\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nfinal class IntArrays {\n    private IntArrays(){}\n    public static void swap(final int[] a, final int u, final int v) {\n        final int tmp = a[u]; a[u] = a[v]; a[v] = tmp;\n    }\n    public static void reverse(final int[] a, final int begin, final int end) {\n        for (int i = begin; i < begin + (end - begin) / 2; i++) swap(a, i, begin + end - i - 1);\n    }\n    public static void reverse(final int[] a) {reverse(a, 0, a.length);}\n    public static void sortDescending(final int[] a) {Arrays.sort(a); reverse(a);}\n    public static int reduce(final int[] a, final IntBinaryOperator op) {\n        int ret = a[0]; for (int i = 1; i < a.length; i++) ret = op.applyAsInt(ret, a[i]);\n        return ret;\n    }\n    public static void map(final int[] a, final IntUnaryOperator op) {Arrays.setAll(a, i -> op.applyAsInt(a[i]));}\n    public static int filter(final int[] src, final int[] dst, final IntPredicate p) {\n        int idx = 0;\n        for (final int e : src) if (p.test(e)) dst[idx++] = e;\n        return idx;\n    }\n    public static int filterIndex(final int[] dst, final int beginIndex, final int endIndex, final IntPredicate p) {\n        int idx = 0;\n        for (int i = beginIndex; i < endIndex; i++) if (p.test(i)) dst[idx++] = i;\n        return idx;\n    }\n    public static int filterIndex(final int dst[], final int endIndex, final IntPredicate p) {\n        return filterIndex(dst, 0, endIndex, p);\n    }\n    public static void accumulate(final int[] a, final IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) a[i] = op.applyAsInt(a[i - 1], a[i]);\n    }\n    public static void accumulate(final int[] a) {\n        for (int i = 1; i < a.length; i++) a[i] += a[i - 1];\n    }\n    public static void permute(int[] a, int[] p) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                swap(a, j, p[j]);\n                settled[j] = true;\n            }\n        }\n    }\n    public static int compare(final int[] a, final int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (i >= b.length) return -1;\n            if (a[i] > b[i]) return 1;\n            if (a[i] < b[i]) return -1;\n        }\n        return a.length < b.length ? 1 : 0;\n    }\n    public static boolean equals(final int[] a, final int[] b) {return compare(a, b) == 0;}\n    public static String join(final int[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String joinWithPrefixAndSuffix(final int[] a, final IntFunction<String> idxToPre, final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * Queue for int type.\n */\nfinal class IntQueue implements Iterable<Integer> {\n    private static final int DEFAULT_SIZE = 64;\n    private int[] q;\n    private int head = 0, tail = 0;\n    public IntQueue(final int capacity) {this.q = new int[capacity];}\n    public IntQueue() {this(DEFAULT_SIZE);}\n    public int peek() {\n        if (head == tail) throw new NoSuchElementException(\"No Elements.\");\n        return q[head];\n    }\n    public int getFromHead(int index) {\n        if (head + index >= tail || index < 0) throw new NoSuchElementException(\"Index out of bounds.\");\n        return q[head + index];\n    }\n    public int getFromTail(int index) {\n        if (head + index >= tail || index < 0) throw new NoSuchElementException(\"Index out of bounds.\");\n        return q[tail - 1 - index];\n    }\n    public void add(final int v) {\n        if (tail == q.length) grow();\n        q[tail++] = v;\n    }\n    public void add(final int... vals) {for (int v : vals) add(v);}\n    public int poll() {\n        if (head == tail) throw new NoSuchElementException(\"No Elements.\");\n        int ret = q[head++];\n        if (head == tail) head = tail = 0;\n        else if (head >= 1e7) relocate();\n        return ret;\n    }\n    private void relocate() {\n        final int[] newQ = new int[q.length];\n        System.arraycopy(q, head, newQ, 0, tail - head);\n        q = newQ;\n        tail -= head;\n        head = 0;\n    }\n    public int size() {return tail - head;}\n    public void clear() {head = tail = 0;}\n    private void grow() {\n        final int[] grown = new int[q.length << 1];\n        final int len = size();\n        System.arraycopy(q, head, grown, 0, len);\n        q = grown;\n        tail = len;\n        head = 0;\n    }\n    public PrimitiveIterator.OfInt iterator() {return new IntQueueIterator();}\n    private class IntQueueIterator implements PrimitiveIterator.OfInt {\n        private int i = head;\n        public boolean hasNext() {return i < tail;}\n        public int nextInt() {return q[i++];}\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main implements Runnable {\n  public static void main(String[] args)  {\n    new Thread(null, new Main(), \"\", 64 * 1024 * 1024).start();\n  }\n  \n  public void run() {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int[] from = new int[N - 1];\n    int[] to = new int[N - 1];\n    for (int i = 0; i < N - 1; i ++) {\n      from[i] = sc.nextInt() - 1;\n      to[i] = sc.nextInt() - 1;\n    }\n    \n    int[][] tree = packU(N, from, to);\n    int ret = dfs(0, -1, tree);\n    if (ret == 1) {\n      System.out.println(\"Bob\");\n    } else {\n      System.out.println(\"Alice\");\n    }\n  }\n\n  private static int dfs(int now, int pre, int[][] tree) {\n    int ret = 0;\n    for (int v : tree[now]) {\n      if (v != pre) {\n        ret ^= dfs(v, now, tree);\n      }\n    }\n    return ret + 1;\n  }\n  \n  private static int[][] packU(int n, int[] from, int[] to) {\n    int[][] g = new int[n][];\n    int[] p = new int[n];\n    for (int f : from)\n        p[f]++;\n    for (int t : to)\n        p[t]++;\n    for (int i = 0; i < n; i++)\n        g[i] = new int[p[i]];\n    for (int i = 0; i < from.length; i++) {\n        g[from[i]][--p[from[i]]] = to[i];\n        g[to[i]][--p[to[i]]] = from[i];\n    }\n    return g;\n}\n}\n\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc017;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        graph = buildGraph(in, n, n-1);\n\n        out.println(dfs(0, -1) > 0 ? \"Alice\" : \"Bob\");\n        out.flush();\n    }\n\n    static int[][] graph;\n\n    static int dfs(int now, int par) {\n        int g = 0;\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            g ^= dfs(to, now) + 1;\n        }\n        return g;\n    }\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main implements Runnable {\n  public static void main(String[] args)  {\n    new Thread(null, new Main(), \"\", 64 * 1024 * 1024).start();\n  }\n  \n  public void run() {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int[] from = new int[N - 1];\n    int[] to = new int[N - 1];\n    for (int i = 0; i < N - 1; i ++) {\n      from[i] = sc.nextInt() - 1;\n      to[i] = sc.nextInt() - 1;\n    }\n    \n    int[][] tree = packU(N, from, to);\n    int ret = dfs(0, -1, tree);\n    if (ret == 0) {\n      System.out.println(\"Bob\");\n    } else {\n      System.out.println(\"Alice\");\n    }\n  }\n\n  private static int dfs(int now, int pre, int[][] tree) {\n    int ret = 0;\n    for (int v : tree[now]) {\n      if (v != pre) {\n        ret ^= dfs(v, now, tree);\n      }\n    }\n    if (now == 0 && tree[now].length == 1 || now > 0 && tree[now].length == 2) {\n      ret += 1;\n    }\n\n    return ret;\n  }\n  \n  private static int[][] packU(int n, int[] from, int[] to) {\n    int[][] g = new int[n][];\n    int[] p = new int[n];\n    for (int f : from)\n        p[f]++;\n    for (int t : to)\n        p[t]++;\n    for (int i = 0; i < n; i++)\n        g[i] = new int[p[i]];\n    for (int i = 0; i < from.length; i++) {\n        g[from[i]][--p[from[i]]] = to[i];\n        g[to[i]][--p[to[i]]] = from[i];\n    }\n    return g;\n}\n}\n\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint x = io.nextInt() - 1;\n\t\t\t\tint y = io.nextInt() - 1;\n\t\t\t\tg[x].add(y);\n\t\t\t\tg[y].add(x);\n\t\t\t}\n\t\t\t\n\t\t\tio.out.println(dfs(0, -1) ? \"Alice\" : \"Bob\");\n\t\t}\n\t}\n\t\n\tList<Integer>[] g;\n\tboolean dfs(int v, int p) {\n\t\tint w = 0, l = 0, c = 0;\n\t\tfor (int t : g[v]) if (t != p) {\n\t\t\tif (dfs(t, v)) w++;\n\t\t\telse l++;\n\t\t\tc++;\n\t\t}\n\t\tif (w % 2 == 1) return true;\n\t\treturn l%2 == 1;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class Main {\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int N = ni();\n        int[] from = new int[N-1], to = new int[N-1];\n        for(int i = 0; i< N-1; i++){\n            from[i] = ni()-1;\n            to[i] = ni()-1;\n        }\n        int[][] g = make(N, N-1, from, to, true);\n        if(win(g, 0, -1) > 0)pn(\"Alice\");\n        else pn(\"Bob\");\n    }\n    int win(int[][] g, int u, int p){\n        TreeSet<Integer> set = new TreeSet<>();\n        int xor = 0;\n        for(int v:g[u])if(v != p){\n            xor ^= 1+win(g, v, u);\n//            xor ^= w;\n//            set.add(win(g, v, u));\n//            xor ^= 1;\n        }\n        return xor;\n//        int ans = 0;\n//        while(set.contains(ans))ans++;\n//        return ans;\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    static void dbg(Object... o){System.err.println(Arrays.deepToString(o));}\n    final long IINF = (long)2e18;\n    final int INF = (int)1e9+2;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-8;\n    static boolean multipleTC = false, memory = true, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        long ct = System.currentTimeMillis();\n        if (fileIO) {\n            in = new FastReader(\"\");\n            out = new PrintWriter(\"\");\n        } else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = multipleTC? ni():1;\n        pre();\n        for (int t = 1; t <= T; t++) solve(t);\n        out.flush();\n        out.close();\n        System.err.println(System.currentTimeMillis() - ct);\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    int[][] make(int n, int e, int[] from, int[] to, boolean f){\n        int[][] g = new int[n][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = to[i];\n            if(f)g[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return g;\n    }\n    int[][][] makeS(int n, int e, int[] from, int[] to, boolean f){\n        int[][][] g = new int[n][][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]][];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = new int[]{to[i], i, 0};\n            if(f)g[to[i]][--cnt[to[i]]] = new int[]{from[i], i, 1};\n        }\n        return g;\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object... o){for(Object oo:o)out.print(oo+\" \");}\n    void pn(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();}\n    void pni(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str;\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }\n            return str;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskD.Vertex[] vs = new TaskD.Vertex[n];\n            for (int i = 0; i < n; ++i) vs[i] = new TaskD.Vertex();\n            for (int i = 0; i < n - 1; ++i) {\n                TaskD.Vertex x = vs[in.nextInt() - 1];\n                TaskD.Vertex y = vs[in.nextInt() - 1];\n                x.adj.add(y);\n                y.adj.add(x);\n            }\n            int z = vs[0].solve(null);\n            if (z == 0) {\n                out.println(\"Bob\");\n            } else {\n                out.println(\"Alice\");\n            }\n        }\n\n        static class Vertex {\n            List<TaskD.Vertex> adj = new ArrayList<>();\n\n            public int solve(TaskD.Vertex parent) {\n                int res = 0;\n                for (TaskD.Vertex v : adj)\n                    if (v != parent) {\n                        res ^= 1 + v.solve(this);\n                    }\n                return res;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tint[] dp = new int[n];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\tdp[cur] ^= dp[e] + 1;\n\t\t\t}\n\t\t}\n\t\tout.println(dp[0] != 0 ? \"Alice\" : \"Bob\");\n\t}\n\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Program\n{\n\tpublic static void main(String[] args) {\n\t\tScanner sc =new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tn--;\n\t\tint a[][] = new int[2][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t    for(int j = 0;j < 2;j++){\n\t\t        a[j][i] = sc.nextInt();\n\t\t    }\n\t\t}\n\t\tsc.close();\n\t\tint counter = 0;\n\t\tint counter_ = 0;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(a[0][j] == 1 || a[1][j]==1){counter++;}\n\t\t\telse {counter_++;}\n\t\t}\n\t\tif(counter == 1){System.out.println(\"Alice\");}\n\t\telse if ((counter % 2 == 1 && counter_ % 2 == 0)||(counter % 2 == 0 && counter_ % 2 == 1)){System.out.println(\"Alice\");}\n\t\telse {System.out.println(\"Bob\");}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint x = io.nextInt() - 1;\n\t\t\t\tint y = io.nextInt() - 1;\n\t\t\t\tg[x].add(y);\n\t\t\t\tg[y].add(x);\n\t\t\t}\n\t\t\t\n\t\t\tio.out.println(dfs(0, -1) ? \"Alice\" : \"Bob\");\n\t\t}\n\t}\n\t\n\tList<Integer>[] g;\n\tboolean dfs(int v, int p) {\n\t\tint w = 0, l = 0, c = 0;\n\t\tfor (int t : g[v]) if (t != p) {\n\t\t\tif (dfs(t, v)) w++;\n\t\t\telse l++;\n\t\t\tc++;\n\t\t}\n\t\tif (w == c) return w % 2 == 1;\n\t\tif (l == c) return l % 2 == 1;\n\t\treturn true;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tstatic int n;\n\tstatic List<List<Integer>> list;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] sa = br.readLine().split(\" \");\n\t\tn = Integer.parseInt(sa[0]);\n\t\tlist = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist.add(new ArrayList<>());\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tsa = br.readLine().split(\" \");\n\t\t\tint x = Integer.parseInt(sa[0]) - 1;\n\t\t\tint y = Integer.parseInt(sa[1]) - 1;\n\t\t\tlist.get(x).add(y);\n\t\t\tlist.get(y).add(x);\n\t\t}\n\t\tbr.close();\n\n\t\tif (dfs(0, -1) == 1) {\n\t\t\tSystem.out.println(\"Bob\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Alice\");\n\t\t}\n\t}\n\n\tstatic int dfs(int x, int p) {\n\t\tint ret = 0;\n\t\tfor (int next : list.get(x)) {\n\t\t\tif (next != p) {\n\t\t\t\tint c = dfs(next, x);\n\t\t\t\tret ^= c;\n\t\t\t}\n\t\t}\n\t\treturn ret + 1;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main\n{\n\tint n;\n\tArrayList<Integer> list[];\n\tprivate void solve()throws IOException\n\t{\n\t\tn=nextInt();\n\t\tlist=new ArrayList[n+1];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tlist[i]=new ArrayList<>();\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u=nextInt();\n\t\t\tint v=nextInt();\n\t\t\tlist[u].add(v);\n\t\t\tlist[v].add(u);\n\t\t}\n\t\tout.println(dfs(1,-1)==0?\"Bob\":\"Alice\");\n\t}\n\tint dfs(int v,int p)\n\t{\n\t\tint ret=0;\n\t\tfor(int vv:list[v])\n\t\t\tif(vv!=p)\n\t\t\t\tret^=dfs(vv,v)+1;\n\t\treturn ret;\n\t}\n\n\t \n\t///////////////////////////////////////////////////////////\n\n\tpublic void run()throws IOException\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\tst=null;\n\t\tout=new PrintWriter(System.out);\n\n\t\tsolve();\n\t\t\n\t\tbr.close();\n\t\tout.close();\n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tnew Main().run();\n\t}\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\tString nextToken()throws IOException{\n\t\twhile(st==null || !st.hasMoreTokens())\n\t\tst=new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tString nextLine()throws IOException{\n\t\treturn br.readLine();\n\t}\n\tint nextInt()throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong()throws IOException{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble()throws IOException{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  static ArrayList[] edge;\n  \n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int N = sc.nextInt();\n    edge = new ArrayList[N + 1];\n    for(int i = 1; i < N + 1; i++) {\n      edge[i] = new ArrayList<Integer>();\n    }\n    for(int i = 0; i < N - 1; i++) {\n      int x = sc.nextInt();\n      int y = sc.nextInt();\n      edge[x].add(y);\n      edge[y].add(x);\n    }\n    String ans = \"Alice\";\n    if(dfs(1, 0) == 0) ans = \"Bob\";\n    System.out.println(ans);\n  }\n\n  public static int dfs(int v, int p) {\n    ArrayList<Integer> list = edge[v];\n    int ret = 0;\n    for(int i = 0; i < list.size(); i++) {\n      int u = list.get(i);\n      if(u != p) {\n        ret = (ret ^ (dfs(u, v) + 1));\n      }\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n    private FastScanner in = new FastScanner(System.in);\n    private PrintWriter out = new PrintWriter(System.out);\n    final int MOD = (int)1e9+7;\n    long ceil(long a, long b){return (a + b - 1) / b;}\n    long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    long lcm(long a, long b){\n        return a / gcd(a, b) * b; //オーバーフローに注意\n    }\n\n    int N;\n    ArrayList<ArrayList<Integer>> G;\n\n    void solve(){\n        N = in.nextInt();\n        G = new ArrayList<>();\n        for(int i = 0; i < N; i++) G.add(new ArrayList<>());\n        for(int i = 0; i < N-1; i++){\n            int x = in.nextInt()-1, y = in.nextInt()-1;\n            G.get(x).add(y);\n            G.get(y).add(x);\n        }\n        int g = dfs(0, -1);\n        out.println(g != 0 ? \"Alice\" : \"Bob\");\n    }\n\n    int dfs(int v, int p){\n        int g = 0;\n        for(int child : G.get(v)){\n            if(child == p) continue;\n            g ^= (dfs(child, v) + 1);\n        }\n        return g;\n    }\n    //end solve\n\n    public static void main(String[] args) {\n        new Main().m();\n    }\n\n    private void m() {\n        solve();\n        out.flush();\n    }\n\n    static class FastScanner {\n        Reader input;\n\n        FastScanner() {this(System.in);}\n        FastScanner(InputStream stream) {this.input = new BufferedReader(new InputStreamReader(stream));}\n\n        int nextInt() {return (int) nextLong();}\n\n        long nextLong() {\n            try {\n                int sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                long ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) return ret * sign;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }\n\n        double nextDouble() {\n            try {\n                double sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                double ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) break;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n                if (b != '.') return sign * ret;\n                double div = 1;\n                b = input.read();\n                while ('0' <= b && b <= '9') {\n                    ret *= 10;\n                    ret += b - '0';\n                    div *= 10;\n                    b = input.read();\n                }\n                return sign * ret / div;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return Double.NaN;\n            }\n        }\n\n        char nextChar() {\n            try {\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                return (char) b;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        String nextStr() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                while (b != -1 && !Character.isWhitespace(b)) {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[] nextIntArrayDec(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt() - 1;\n            }\n            return res;\n        }\n\n        public int[] nextIntArray1Index(int n) {\n            int[] res = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextInt();\n            }\n            return res;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongArrayDec(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong() - 1;\n            }\n            return res;\n        }\n\n        public long[] nextLongArray1Index(int n) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextLong();\n            }\n            return res;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] res = new double[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint x = io.nextInt() - 1;\n\t\t\t\tint y = io.nextInt() - 1;\n\t\t\t\tg[x].add(y);\n\t\t\t\tg[y].add(x);\n\t\t\t}\n\t\t\t\n\t\t\tio.out.println(dfs(0, -1) ? \"Alice\" : \"Bob\");\n\t\t}\n\t}\n\t\n\tList<Integer>[] g;\n\tboolean dfs(int v, int p) {\n\t\tint w = 0, l = 0;\n\t\tfor (int t : g[v]) if (t != p) {\n\t\t\tif (dfs(t, v)) w++;\n\t\t\telse l++;\n\t\t}\n\t\tif (w % 2 == 1 && l % 2 == 0 || w % 2 == 0 && l % 2 == 1) return true;\n//\t\treturn l%2 == 1;\n\t\treturn false;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main implements Runnable {\n\tprivate static BufferedReader in;\n\tprivate static PrintWriter out;\n\tprivate static StringTokenizer st;\n\tprivate static Random rnd;\n\t\n\tstatic class State {\n\t\tint result;\n\t\tint size;\n\t\t\n\t\tpublic State(int result, int size) {\n\t\t\tthis.result = result;\n\t\t\tthis.size = size;\n\t\t}\n\t}\n\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tList<Integer>[] tree = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttree[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint u = nextInt() - 1;\n\t\t\tint v = nextInt() - 1;\n\t\t\ttree[u].add(v);\n\t\t\ttree[v].add(u);\n\t\t}\n\t\tState result = dfs(0, -1, tree);\n\t\tout.println(result.result == 1 ? \"Alice\" : \"Bob\");\n\t}\n\n\n\tprivate State dfs(int u, int p, List<Integer>[] tree) {\n\t\tList<Integer> childs = tree[u];\n\t\tState result = new State(0, 1);\n\t\tList<State> belows = new ArrayList<>();\n\t\tfor (int v : childs) {\n\t\t\tif (v != p) {\n\t\t\t\tState below = dfs(v, u, tree);\n\t\t\t\tresult.result ^= (below.result);\n\t\t\t\tresult.size += below.size;\n\t\t\t\tbelows.add(below);\n\t\t\t}\n\t\t}\n\t\tfor (State below : belows) {\n\t\t\tint x = (result.size % 2) == (below.size % 2) ? 0 : 1;\n\t\t\tresult.result ^= x;\n\t\t}\n\t\treturn result;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null)\n\t\t\t\treturn null;\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DGameOnTree solver = new DGameOnTree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DGameOnTree {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n            }\n            for (int i = 0; i < n - 1; i++) {\n                Node a = nodes[in.readInt() - 1];\n                Node b = nodes[in.readInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n\n            dfs(nodes[0], null);\n            if (nodes[0].sg == 0) {\n                out.println(\"Bob\");\n            } else {\n                out.println(\"Alice\");\n            }\n        }\n\n        public void dfs(Node root, Node p) {\n            for (Node node : root.adj) {\n                if (node == p) {\n                    continue;\n                }\n                dfs(node, root);\n                root.sg ^= node.sg + 1;\n            }\n        }\n\n    }\n\n    static class Node {\n        List<Node> adj = new ArrayList<>();\n        int sg;\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        graph = buildGraph(in, n, n-1);\n\n        out.println(dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n        out.flush();\n    }\n\n    private static int dfs(int now, int par) {\n        int xor = 0;\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            xor ^= dfs(to, now) + 1;\n        }\n        return xor;\n    }\n\n    static int[][] graph;\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  static boolean[] flg;\n  static ArrayList[] edge;\n  \n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int N = sc.nextInt();\n    flg = new boolean[N + 1];\n    edge = new ArrayList[N + 1];\n    for(int i = 1; i < N + 1; i++) {\n      edge[i] = new ArrayList<Integer>();\n    }\n    for(int i = 0; i < N - 1; i++) {\n      int x = sc.nextInt();\n      int y = sc.nextInt();\n      edge[x].add(y);\n      edge[y].add(x);\n    }\n    String ans = \"Alice\";\n    if(dfs(1) == 0) ans = \"Bob\";\n    System.out.println(ans);\n  }\n\n  public static int dfs(int v) {\n    flg[v] = true;\n    ArrayList<Integer> list = edge[v];\n    int num = 0;\n    int ret = 0;\n    int w = 0;\n    for(int i = 0; i < list.size(); i++) {\n      int u = list.get(i);\n      if(!flg[u]) {\n        num++;\n        w = u;\n        ret = (ret ^ (dfs(u) + 1));\n      }\n    }\n    if(num == 0) {\n      return 0;\n    } else if(num == 1) {\n      return dfs(w) + 1;\n    } else {\n      return ret;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        init(n);\n        for (int i = 0; i < n - 1; i++) {\n            addEdge(nextInt() - 1, nextInt() - 1);\n        }\n        if (dfs(0, -1) > 0) {\n            out.println(\"Alice\");\n        } else {\n            out.println(\"Bob\");\n        }\n    }\n\n    void init(int n) {\n        this.n = n;\n        this.m = (n - 1) * 2;\n        last = 0;\n        head = new int[n];\n        nx = new int[m];\n        dst = new int[m];\n        Arrays.fill(head, -1);\n    }\n\n\n    void addEdge(int x, int y) {\n        nx[last] = head[x];\n        dst[last] = y;\n        head[x] = last;\n        last++;\n        nx[last] = head[y];\n        dst[last] = x;\n        head[y] = last;\n        last++;\n    }\n\n    private int dfs(int x, int p) {\n        int j = head[x];\n        int res = 0;\n        while (j >= 0) {\n            int y = dst[j];\n            if (y != p) {\n                res ^= dfs(y, x) + 1;\n            }\n            j = nx[j];\n        }\n        return res;\n    }\n\n    int n, m;\n    int[] head;\n    int[] nx;\n    int[] dst;\n    int last;\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int[] from = new int[N - 1];\n    int[] to = new int[N - 1];\n    for (int i = 0; i < N - 1; i ++) {\n      from[i] = sc.nextInt() - 1;\n      to[i] = sc.nextInt() - 1;\n    }\n    \n    int[][] tree = packU(N, from, to);\n    int ret = dfs(0, -1, tree);\n    if (ret == 0) {\n      System.out.println(\"Bob\");\n    } else {\n      System.out.println(\"Alice\");\n    }\n  }\n  \n  private static int dfs(int now, int pre, int[][] tree) {\n    int ret = 0;\n    for (int v : tree[now]) {\n      if (v != pre) {\n        ret ^= dfs(v, now, tree);\n      }\n    }\n    if (now == 0 && tree[now].length == 1 || now > 0 && tree[now].length == 2) {\n      ret += 1;\n    }\n\n    return ret;\n  }\n  \n  private static int[][] packU(int n, int[] from, int[] to) {\n    int[][] g = new int[n][];\n    int[] p = new int[n];\n    for (int f : from)\n        p[f]++;\n    for (int t : to)\n        p[t]++;\n    for (int i = 0; i < n; i++)\n        g[i] = new int[p[i]];\n    for (int i = 0; i < from.length; i++) {\n        g[from[i]][--p[from[i]]] = to[i];\n        g[to[i]][--p[to[i]]] = from[i];\n    }\n    return g;\n}\n}\n\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t\tScanner sc =new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tn--;\n\t\tint a[][] = new int[2][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t    for(int j = 0;j < 2;j++){\n\t\t        a[j][i] = sc.nextInt();\n\t\t    }\n\t\t}\n\t\tsc.close();\n\t\tint counter = 0;\n\t\tint counter_ = 0;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(a[0][j] == 1 || a[1][j]==1){counter++;}\n\t\t\telse {counter_++;}\n\t\t}\n\t\tif(counter == 1){System.out.println(\"Alice\");}\n\t\telse if ((counter % 2 == 1 && counter_ % 2 == 0)||(counter % 2 == 0 && counter_ % 2 == 1)){System.out.println(\"Alice\");}\n\t\telse {System.out.println(\"Bob\");}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n\n    ArrayList<Integer>[] g;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt() - 1;\n        int y = in.nextInt() - 1;\n        g[x].add(y);\n        g[y].add(x);\n      }\n      int res = dfs(0, -1);\n      out.printLine(res == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    private int dfs(int x, int p) {\n      int res = 0;\n      for (int y : g[x]) {\n        if (y == p) {\n          continue;\n        }\n        res ^= 1 + dfs(y, x);\n      }\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\n  private void solve(FastScanner in, PrintWriter out) {\n    int N = in.nextInt();\n    ArrayList<Integer>[] tree = new ArrayList[N];\n    for (int i = 0; i < N; i++) {\n      tree[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < N - 1; i++) {\n      int x = in.nextInt() - 1;\n      int y = in.nextInt() - 1;\n      tree[x].add(y);\n      tree[y].add(x);\n    }\n\n    if (tree[0].size() == 1) {\n      out.println(\"Alice\");\n    } else {\n      if (N % 2 == 0) {\n        out.println(\"Alice\");\n      } else {\n        out.println(\"Bob\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tgr = new int[N];\n\t\tdfs(0,-1);\n\t\tConsole.WriteLine(gr[0] == 0 ? \"Bob\" : \"Alice\" );\n\t\t\n\t\t\n\t}\n\t\n\tint[] gr;\n\tvoid dfs(int now, int pre){\n\t\tif(E[now].Count == 0){\n\t\t\tgr[now] = 0;\n\t\t\treturn;\n\t\t}\n\t\tint g = 0;\n\t\tforeach(var nxt in E[now]){\n\t\t\tif(nxt == pre) continue;\n\t\t\tdfs(nxt,now);\n\t\t\tg ^= (gr[nxt] + 1);\n\t\t}\n\t\tgr[now] = g;\n\t\treturn;\n\t}\n\t\n\t\n\tint N;\n\tList<int>[] E;\n\tpublic Sol(){\n\t\tN = ri();\n\t\tE = new List<int>[N];\n\t\tfor(int i=0;i<N;i++) E[i] = new List<int>();\n\t\t\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tvar d = ria();\n\t\t\tE[d[0] - 1].Add(d[1] - 1);\n\t\t\tE[d[1] - 1].Add(d[0] - 1);\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        int s = 0;\n        for (int i = 0; i < N; i++)\n        {\n            //WriteLine(A[i]);\n            t ^= A[i];\n            s = (s + A[i]) % 2;\n            if(s % 2 == 1) { WriteLine(\"Alice\"); return; }\n            //if (t == 1) { WriteLine(\"Alice\"); return; }\n        }\n\n        // (t != 0) WriteLine(\"Alice\");\n       WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    List<int>[] G;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        G = new List<int>[N];\n        for(int i=0;i<N;i++){\n            G[i] = new List<int>();\n        }\n        for(int i=0;i<N-1;i++){\n            string[] str = Console.ReadLine().Split(' ');\n            int x = int.Parse(str[0])-1;\n            int y = int.Parse(str[1])-1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        int count = dfs(0,-1);\n        if(count == 0){\n            sb.Append(\"Bob\\n\");\n        }\n        else{\n            sb.Append(\"Alice\\n\");\n        }\n    }\n    int dfs(int v,int f){\n        int x = 0;\n        for(int i=0;i<G[v].Count;i++){\n            int t = G[v][i];\n            if(t != f){\n                x ^= dfs(t,v)+1;\n            }\n        }\n        return x;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int n = sc.Int;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            edge[u].Add(v);\n            edge[v].Add(u);\n        }\n        Prt(dfs(0, -1) == 0 ? \"Bob\" : \"Alice\");\n    }\n    List<int>[] edge;\n    int dfs(int p, int par) {\n        int res = 0;\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            res ^= dfs(item, p) + 1;\n        }\n        return res;\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AGC017\n{\n    public class D\n    {\n        private void Run()\n        {\n            var N = int.Parse(Console.ReadLine().Trim());\n            var edges = Enumerable.Range(0, N).Select(_ => new List<int>()).ToArray();\n            foreach (var _ in Enumerable.Range(0, N - 1))\n            {\n                var input = Console.ReadLine().Trim().Split();\n                var x = int.Parse(input[0]) - 1;\n                var y = int.Parse(input[1]) - 1;\n                edges[x].Add(y);\n                edges[y].Add(x);\n            }\n\n            var childCount = new int[N];\n            bool same = false;\n            Func<int, int, int> dfs = null;\n            dfs = (prev, current) =>\n            {\n                int count = 1;\n                foreach (var e in edges[current])\n                {\n                    if (e != prev)\n                    {\n                        count += dfs(current, e);\n                    }\n                }\n                if (edges[current].Count >= 2)\n                {\n                    var nim = edges[current]\n                        .Where(e => e != prev)\n                        .Select(e => childCount[e])\n                        .Aggregate(0, (a, b) => a ^ b);\n                    same |= (nim == 0);\n                }\n                childCount[current] = count;\n                return count;\n            };\n\n            dfs(-1, 0);\n            Console.WriteLine(same ? \"Bob\" : \"Alice\");\n        }\n\n        public static void Main()\n        {\n            var old = Console.Out;\n            using (var writer = new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false })\n            {\n                Console.SetOut(writer);\n                new D().Run();\n                Console.Out.Flush();\n                Console.SetOut(old);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.ForYellow\n{\n    class AGC017_D\n    {\n        static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false };\n            SetOut(sw);\n\n            Method(args);\n\n            Out.Flush();\n        }\n\n        static void Method(string[] args)\n        {\n            int n = ReadInt();\n            List<int>[] graph = new List<int>[n];\n            for(int i = 0; i < n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n            for(int i = 0; i < n - 1; i++)\n            {\n                int[] xy = ReadInts();\n                int x = xy[0] - 1;\n                int y = xy[1] - 1;\n\n                graph[x].Add(y);\n                graph[y].Add(x);\n            }\n\n            if (DFS(graph, 0, -1) > 0)\n            {\n                WriteLine(\"Alice\");\n            }\n            else\n            {\n                WriteLine(\"Bob\");\n            }\n        }\n\n        static int DFS(List<int>[] graph,int now,int parent)\n        {\n            if (parent >= 0 && graph[now].Count == 1)\n            {\n                return 0;\n            }\n\n            int val = 0;\n            for(int i = 0; i < graph[now].Count; i++)\n            {\n                int to = graph[now][i];\n                if (to == parent)\n                {\n                    continue;\n                }\n\n                val ^= DFS(graph, to, now) + 1;\n            }\n\n            return val;\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nclass Program\n{\n    static int N;\n    static List<int>[] E;\n\n    static void Main()\n    {\n        D();\n    }\n\n    static void D()\n    {\n        N = int.Parse(Console.ReadLine());\n        E = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            E[i] = new List<int>();\n        }\n        for (long i = 0; i < N - 1; i++)\n        {\n            var XY = Console.ReadLine().Split(' ');\n            E[int.Parse(XY[0]) - 1].Add(int.Parse(XY[1]) - 1);\n        }\n\n        Console.WriteLine(Grundy(0) == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    static int Grundy(long root)\n    {\n        var s = new Stack<int>();\n        \n        foreach (var n in E[root])\n        {\n            s.Push(Grundy(n));\n        }\n\n        if (s.Count() == 0)\n        {\n            return 0;\n        }\n        else if (s.Count() == 1)\n        {\n            return s.Pop() + 1;\n        }\n        \n        int ans = 0;\n        while (s.Count > 0)\n        {\n            ans ^= s.Pop();\n        }\n        return ans;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        //int s = 0;\n        for (int i = 0; i < N; i++)\n        {\n            if (i != 0) A[i] = Math.Min(A[i] - A[i - 1], 0);\n            //Write(A[i] + \" \");\n\n            t ^= A[i];\n            if (t % 2 ==  1) { WriteLine(\"Alice\"); return; }\n            //WriteLine(t);\n        }\n\n\n\n        //if(t % 2 != 0) WriteLine(\"Alice\");\n         WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        //int s = 0;\n        for (int i = 0; i < N; i++)\n        {\n            if (i != 0) A[i] += A[i - 1];\n            //Write(A[i] + \" \");\n\n            t ^= A[i];\n            if (t % 2 ==  1) { WriteLine(\"Alice\"); return; }\n            //WriteLine(t);\n        }\n\n\n\n        //if(t % 2 != 0) WriteLine(\"Alice\");\n         WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic class Program\n{\n    private int N;\n    private List<int>[] Edge;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        N = sc.NextInt();\n        Edge = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            Edge[i] = new List<int>();\n        }\n\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = sc.NextInt() - 1;\n            int y = sc.NextInt() - 1;\n            Edge[x].Add(y);\n            Edge[y].Add(x);\n        }\n        \n        Console.WriteLine(Win(0,-1) > 0?\"Alice\":\"Bob\");\n    }\n\n    private int Win(int pos, int parent)\n    {\n        int result = 0;\n        foreach (int i in Edge[pos])\n        {\n            if (i == parent) continue;\n            result ^= 1+Win(i, pos);\n        }\n\n        return result;\n    }\n\n    public static void Main(string[] args)\n    {\n        new Program().Solve();\n    }\n}\n\nclass Scanner\n{\n    public Scanner()\n    {\n        _pos = 0;\n        _line = new string[0];\n    }\n\n    const char Separator = ' ';\n    private int _pos;\n    private string[] _line;\n\n    #region スペース区切りで取得\n\n    public string Next()\n    {\n        if (_pos >= _line.Length)\n        {\n            _line = Console.ReadLine().Split(Separator);\n            _pos = 0;\n        }\n\n        return _line[_pos++];\n    }\n\n    public int NextInt()\n    {\n        return int.Parse(Next());\n    }\n\n    public long NextLong()\n    {\n        return long.Parse(Next());\n    }\n\n    public double NextDouble()\n    {\n        return double.Parse(Next());\n    }\n\n    #endregion\n\n    #region 型変換\n\n    private int[] ToIntArray(string[] array)\n    {\n        var result = new int[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = int.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    private long[] ToLongArray(string[] array)\n    {\n        var result = new long[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = long.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    private double[] ToDoubleArray(string[] array)\n    {\n        var result = new double[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = double.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    #endregion\n\n    #region 配列取得\n\n    public string[] Array()\n    {\n        if (_pos >= _line.Length)\n            _line = Console.ReadLine().Split(Separator);\n\n        _pos = _line.Length;\n        return _line;\n    }\n\n    public int[] IntArray()\n    {\n        return ToIntArray(Array());\n    }\n\n    public long[] LongArray()\n    {\n        return ToLongArray(Array());\n    }\n\n    public double[] DoubleArray()\n    {\n        return ToDoubleArray(Array());\n    }\n\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nclass Program\n{\n    static int N;\n    static List<int>[] E;\n\n    static void Main()\n    {\n        D();\n    }\n\n    static void D()\n    {\n        // Nの入力\n        N = int.Parse(Console.ReadLine());\n\n        // XYの入力\n        E = new List<int>[N];\n        for (int i = 0; i < N; i++) E[i] = new List<int>();\n        for (long i = 0; i < N - 1; i++)\n        {\n            var XY = Console.ReadLine().Split(' ').Select(x => int.Parse(x) - 1);\n            E[XY.ElementAt(0)].Add(XY.ElementAt(1));\n            E[XY.ElementAt(1)].Add(XY.ElementAt(0));\n        }\n\n        Console.WriteLine(Grundy(0, 0) == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    static int Grundy(int root, int prev)\n    {\n        var s = new Stack<int>();\n        \n        foreach (var n in E[root])\n        {\n            if (n != prev) s.Push(Grundy(n, root));\n        }\n\n        if (s.Count() == 0)\n        {\n            return 0;\n        }\n        else if (s.Count() == 1)\n        {\n            return s.Pop() + 1;\n        }\n        \n        int ans = 0;\n        while (s.Count > 0)\n        {\n            ans ^= s.Pop();\n        }\n        return ans;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        //int s = 0;\n        for (int i = 0; i < N; i++)\n        {\n            if (i != 0) A[i] = Math.Max(A[i] - A[i - 1], 0);\n            //Write(A[i] + \" \");\n\n            t ^= A[i];\n            if (t % 2 ==  1) { WriteLine(\"Alice\"); return; }\n            //WriteLine(t);\n        }\n\n\n\n        //if(t % 2 != 0) WriteLine(\"Alice\");\n         WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        int s = 0;\n        for (int i = 0; i < N; i++)\n        {\n            //WriteLine(A[i]);\n            t ^= A[i];\n            s = (s + A[i]) % 2;\n            if(s == 1) { WriteLine(\"Alice\"); return; }\n            if (t == 1) { WriteLine(\"Alice\"); return; }\n        }\n\n        // (t != 0) WriteLine(\"Alice\");\n       WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar G = Enumerate(n, x => new List<int>());\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tvar u = ri - 1;\n\t\t\t\tvar v = ri - 1;\n\t\t\t\tG[u].Add(v); G[v].Add(u);\n\t\t\t}\n\t\t\tFunc<int, int, int> dfs = null;\n\t\t\tdfs = (p, c) => {\n\t\t\t\tvar ret = 0;\n\t\t\t\tforeach (var t in G[c])\n\t\t\t\t\tif (p != t) ret ^= dfs(c, t) + 1;\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t\tvar ans = dfs(-1, 0);\n\t\t\tDebug.WriteLine(ans);\n\t\t\tif (ans == 0) Console.WriteLine(\"Bob\");\n\t\t\telse Console.WriteLine(\"Alice\");\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t/* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t*/\n\t\tsolver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nclass Program\n{\n    static int N;\n    static List<int>[] E;\n\n    static void Main()\n    {\n        D();\n    }\n\n    static void D()\n    {\n        N = int.Parse(Console.ReadLine());\n        \n        E = new List<int>[N];\n        for (int i = 0; i < N; i++) E[i] = new List<int>();\n        for (long i = 0; i < N - 1; i++)\n        {\n            var XY = Console.ReadLine().Split(' ').Select(x => int.Parse(x) - 1);\n            E[XY.ElementAt(0)].Add(XY.ElementAt(1));\n            E[XY.ElementAt(1)].Add(XY.ElementAt(0));\n        }\n\n        Console.WriteLine(Grundy(0, 0) == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    static int Grundy(int root, int prev)\n    {\n        int ans = 0;\n        \n        foreach (var n in E[root])\n        {\n            if (n != prev) ans ^= Grundy(n, root) + 1;\n        }\n\n        return ans;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nclass Program\n{\n    static long N;\n    static bool[,] E;\n    static bool[] visited;\n\n    static void Main()\n    {\n        D();\n    }\n\n    static void D()\n    {\n        N = long.Parse(Console.ReadLine());\n        E = new bool[N, N];\n        visited = new bool[N];\n        for (long i = 0; i < N - 1; i++)\n        {\n            var XY = Console.ReadLine().Split(' ').Select(x => long.Parse(x) - 1);\n            E[XY.ElementAt(0), XY.ElementAt(1)] = true;\n            E[XY.ElementAt(1), XY.ElementAt(0)] = true;\n        }\n\n        Console.WriteLine(Grundy(1) == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    static long Grundy(long root)\n    {\n        visited[root - 1] = true;\n        var s = new Stack<long>();\n        \n        foreach (var n in Next(root))\n        {\n            if (!visited[n - 1])\n            {\n                s.Push(Grundy(n));\n            }\n        }\n        if (s.Count() == 0) return 0;\n        else if (s.Count() == 1) return s.Pop() + 1;\n        \n        long ans = 0;\n        while (s.Count > 0)\n        {\n            ans ^= s.Pop();\n        }\n        return ans;\n    }\n\n    static IEnumerable<long> Next(long root)\n    {\n        for (int i = 0; i < N; i++)\n        {\n            if (E[root - 1, i] && !visited[i]) yield return i + 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        //int s = 0;\n        for (int i = 0; i < N; i++)\n        {\n            //WriteLine(A[i]);\n            t ^= A[i];\n            if (t % 2 == 1) { WriteLine(\"Alice\"); return; }\n        }\n        //WriteLine(t);\n       //if(t % 2 != 0) WriteLine(\"Alice\");\n         WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.ForYellow\n{\n    class AGC017_D\n    {\n        static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false };\n            SetOut(sw);\n\n            Method(args);\n\n            Out.Flush();\n        }\n\n        static void Method(string[] args)\n        {\n            int n = ReadInt();\n            List<int>[] graph = new List<int>[n];\n            for(int i = 0; i < n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n            for(int i = 0; i < n - 1; i++)\n            {\n                int[] xy = ReadInts();\n                int x = xy[0] - 1;\n                int y = xy[1] - 1;\n\n                graph[x].Add(y);\n                graph[y].Add(x);\n            }\n\n            List<List<int>> depthIndexes = new List<List<int>>();\n            List<bool> state = new List<bool>();\n            int[] parents = new int[n];\n            int[] depthes = new int[n];\n            var que = new Queue<int>();\n            que.Enqueue(0);\n            depthIndexes.Add(new List<int>());\n            depthIndexes[0].Add(0);\n            state.Add(true);\n            parents[0] = -1;\n            depthes[0] = 0;\n            while (que.Count > 0)\n            {\n                int now = que.Dequeue();\n                int nextDepth = depthes[now] + 1;\n                for(int i = 0; i < graph[now].Count; i++)\n                {\n                    int to = graph[now][i];\n                    if (to == parents[now])\n                    {\n                        continue;\n                    }\n\n                    que.Enqueue(to);\n                    if (nextDepth>= depthIndexes.Count)\n                    {\n                        depthIndexes.Add(new List<int>());\n                        state.Add(false);\n                    }\n                    depthIndexes[nextDepth].Add(to);\n                    state[nextDepth] = !state[nextDepth];\n                    parents[to] = now;\n                    depthes[to] = nextDepth;\n                }\n            }\n\n            int firstI = 1;\n            while(firstI<state.Count&& !state[firstI])\n            {\n                firstI++;\n            }\n\n            if (firstI >= state.Count)\n            {\n                WriteLine(\"Bob\");\n                return;\n            }\n\n            int lastI = state.Count - 1;\n            while (lastI >= 0 && !state[lastI])\n            {\n                lastI--;\n            }\n\n            for(int i = 0; i < depthIndexes[firstI].Count; i++)\n            {\n                var queTmp = new Queue<int>();\n                queTmp.Enqueue(depthIndexes[firstI][i]);\n                int tmpI = firstI;\n                bool ok = true;\n                while (queTmp.Count > 0)\n                {\n                    int cnt = queTmp.Count;\n                    if (state[tmpI] != (cnt % 2 == 1))\n                    {\n                        ok = false;\n                        break;\n                    }\n\n                    var queNext = new Queue<int>();\n                    while (queTmp.Count > 0)\n                    {\n                        int now = queTmp.Dequeue();\n                        for(int j = 0; j < graph[now].Count; j++)\n                        {\n                            int to = graph[now][j];\n                            if (to == parents[now])\n                            {\n                                continue;\n                            }\n\n                            queNext.Enqueue(to);\n                        }\n                    }\n                    queTmp = queNext;\n                    tmpI++;\n                }\n\n                if (ok && tmpI > lastI)\n                {\n                    WriteLine(\"Alice\");\n                    return;\n                }\n            }\n\n            WriteLine(\"Bob\");\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\nusing static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    readonly string ALFA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    int N;\n    List<int>[] G;\n    bool[] B;\n    void solve()\n    {\n        N = cin.nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.nextint - 1;\n            int y = cin.nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        B = new bool[N];\n        int ret = calc(0);\n        WriteLine(ret == 0 ? \"Bob\" : \"Alice\");\n    }\n    int calc(int u)\n    {\n        B[u] = true;\n\n        int xor = 0;\n        int item = 0;\n        foreach (var v in G[u])\n        {\n            if (B[v]) continue;\n            xor ^= calc(v);\n            item++;\n        }\n        if (item == 1) xor++;\n        return xor;\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int N;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.Nextint - 1;\n            int y = cin.Nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        var A = new int[N];\n        var B = new bool[N];\n\n        var Q = new Queue<int>();\n        Q.Enqueue(0);\n        var R = new Queue<int>();\n        R.Enqueue(0);\n        B[0] = true;\n\n        while (Q.Any())\n        {\n            int u = Q.Dequeue();\n            int d = R.Dequeue();\n            A[d] += G[u].Count - Math.Min(d, 1);\n            foreach (var v in G[u])\n            {\n                if (B[v]) continue;\n                B[v] = true;\n                Q.Enqueue(v);\n                R.Enqueue(d + 1);\n            }\n        }\n\n        int t = 0;\n        for (int i = 0; i < N; i++)\n        {\n            //WriteLine(A[i]);\n            t ^= A[i];\n            if (t == 1) { WriteLine(\"Alice\"); return; }\n        }\n\n        // (t != 0) WriteLine(\"Alice\");\n       WriteLine(\"Bob\");\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\nusing static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    readonly string ALFA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    int N;\n    List<int>[] G;\n    void solve()\n    {\n        N = cin.nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int x = cin.nextint - 1;\n            int y = cin.nextint - 1;\n            G[x].Add(y);\n            G[y].Add(x);\n        }\n        int ret = calc(0, -1);\n        WriteLine(ret == 0 ? \"Bob\" : \"Alice\");\n    }\n    int calc(int u, int par)\n    {\n        int xor = 0;\n        foreach (var v in G[u])\n        {\n            if (v == par) continue;\n            xor ^= (calc(v, u) + 1);\n        }\n        return xor;\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nclass Program\n{\n    static int N;\n    static List<int>[] E;\n\n    static void Main()\n    {\n        D();\n    }\n\n    static void D()\n    {\n        // Nの入力\n        N = int.Parse(Console.ReadLine());\n\n        // XYの入力\n        E = new List<int>[N];\n        for (long i = 0; i < N - 1; i++)\n        {\n            var XY = Console.ReadLine().Split(' ').Select(x => int.Parse(x) - 1);\n            E[XY.ElementAt(0)].Add(XY.ElementAt(1));\n            E[XY.ElementAt(1)].Add(XY.ElementAt(0));\n        }\n\n        Console.WriteLine(Grundy(0, 0) == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    static int Grundy(int root, int prev)\n    {\n        var s = new Stack<int>();\n        \n        foreach (var n in E[root])\n        {\n            if (n != prev) s.Push(Grundy(n, root));\n        }\n\n        if (s.Count() == 0)\n        {\n            return 0;\n        }\n        else if (s.Count() == 1)\n        {\n            return s.Pop() + 1;\n        }\n        \n        int ans = 0;\n        while (s.Count > 0)\n        {\n            ans ^= s.Pop();\n        }\n        return ans;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nclass Program\n{\n    static int N;\n    static List<int>[] E;\n\n    static void Main()\n    {\n        D();\n    }\n\n    static void D()\n    {\n        N = int.Parse(Console.ReadLine());\n        \n        E = new List<int>[N];\n        for (int i = 0; i < N; i++) E[i] = new List<int>();\n        for (long i = 0; i < N - 1; i++)\n        {\n            var XY = Console.ReadLine().Split(' ').Select(x => int.Parse(x) - 1);\n            E[XY.ElementAt(0)].Add(XY.ElementAt(1));\n            E[XY.ElementAt(1)].Add(XY.ElementAt(0));\n        }\n\n        Console.WriteLine(Grundy(0, 0) == 0 ? \"Bob\" : \"Alice\");\n    }\n\n    static int Grundy(int root, int prev)\n    {\n        var s = new Stack<int>();\n        \n        foreach (var n in E[root])\n        {\n            if (n != prev) s.Push(Grundy(n, root));\n        }\n\n        if (s.Count() == 0)\n        {\n            return 0;\n        }\n        else if (s.Count() == 1)\n        {\n            return s.Pop() + 1;\n        }\n        \n        int ans = 0;\n        while (s.Count > 0)\n        {\n            ans ^= s.Pop() + 1;\n        }\n        return ans;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<int>[] li;\n\tstatic bool[] b;\n\tstatic int[] h;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint n=s[0],m=n-1;\n\t\tli=new List<int>[n+1];\n\t\tb=new bool[n+1];\n\t\th=new int[n+1];\n\t\tfor(int i=1;i<=n;i++){li[i]=new List<int>();}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvar e=sc.Ia;\n\t\t\tli[e[0]].Add(e[1]);\n\t\t\tli[e[1]].Add(e[0]);\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",Fu(1)!=0?\"Alice\":\"Bob\");\n\t}\n\tstatic int Fu(int a){\n\t\tb[a]=true;\n\t\tint g=0;\n\t\tfor(int i=0;i<li[a].Count;i++){\n\t\t\tif(!b[li[a][i]]){g^=Fu(li[a][i])+1;}\n\t\t}\n\t\treturn g;\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),double.Parse);}\n\tpublic double[] Da3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n    List<int>[] es;\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        es = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            es[i] = new List<int>();\n        }\n\n        for (int i = 0; i < N - 1; i++)\n        {\n            int A = cin.nextInt() - 1;\n            int B = cin.nextInt() - 1;\n            es[A].Add(B);\n            es[B].Add(A);\n        }\n\n        if (dfs(0, -1) == 0) Console.WriteLine(\"Bob\");\n        else Console.WriteLine(\"Alice\");\n        \n    }\n\n    int dfs(int a, int pre)\n    {\n        int ans = 0;\n        foreach (var next in es[a])\n        {\n            if (next == pre) continue;\n            ans ^= dfs(next, a) + 1;\n        }\n        return ans;\n    }\n    \n}\n\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing static Template;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\n\nclass Solver\n{\n    Scanner sc = new Scanner();\n    //\n    List<int>[] edge;\n    public void Solve()\n    {\n        var N = sc.Int;\n\n        edge = Create(N, () => new List<int>());\n        for (var i = 0; i < N - 1; i++)\n        {\n            int a, b;\n            sc.Make(out a, out b);\n            a--; b--;\n            edge[a].Add(b);\n            edge[b].Add(a);\n        }\n        WriteLine(dfs(0, -1) == 1 ? \"Bob\" : \"Alice\");\n    }\n    int dfs(int idx, int p)\n    {\n        var c = 0;\n        foreach (var e in edge[idx])\n            if (e != p)\n                c ^= dfs(e, idx);\n        return c + 1;\n    }\n}\n\n#region Template\npublic class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve();\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == 1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == -1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T v1, ref T v2)\n    { var t = v2; v2 = v1; v1 = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f)\n    {\n        var rt = new T[n];\n        for (var i = 0; i < rt.Length; ++i)\n            rt[i] = f();\n        return rt;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<int, T> f)\n    {\n        var rt = new T[n];\n        for (var i = 0; i < rt.Length; ++i)\n            rt[i] = f(i);\n        return rt;\n    }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\n\npublic class Scanner\n{\n    public string Str => ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    public Pair<T1, T2> PairMake<T1, T2>() => new Pair<T1, T2>(Next<T1>(), Next<T2>());\n    public Pair<T1, T2, T3> PairMake<T1, T2, T3>() => new Pair<T1, T2, T3>(Next<T1>(), Next<T2>(), Next<T3>());\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Tie(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n    public void Tie(out T1 a, out T2 b, out T3 c) { Tie(out a, out b); c = v3; }\n}\n#endregion\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (graph (make-array n :element-type 'list :initial-element nil)))\n    (dotimes (i (- n 1))\n      (let ((x (- (read-fixnum) 1))\n            (y (- (read-fixnum) 1)))\n        (push x (aref graph y))\n        (push y (aref graph x))))\n    (write-line\n     (if (zerop (sb-int:named-let dfs ((v 0) (parent -1))\n                  (let ((res 0))\n                    (dolist (child (aref graph v))\n                      (unless (= child parent)\n                        (xorf res (+ 1 (dfs child v)))))\n                    res)))\n         \"Bob\"\n         \"Alice\"))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"5\n1 2\n2 3\n2 4\n4 5\n\"\n    \"Alice\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"5\n1 2\n2 3\n1 4\n4 5\n\"\n    \"Bob\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6\n1 2\n2 4\n5 1\n6 3\n3 2\n\"\n    \"Alice\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7\n1 2\n3 7\n4 6\n2 3\n2 4\n1 5\n\"\n    \"Bob\n\")))\n"
  },
  {
    "language": "Ruby",
    "code": "Z,*P=->i,q{x=0;P[i].map{|j|j!=q&&x^=Z[j,i]};x+1};$<.map{|l|x,y=l.split.map &:to_i;y&&(P[x]=*P[x],y;P[y]=*P[y],x)};puts Z[1,1]>1?:Alice: :Bob"
  },
  {
    "language": "Ruby",
    "code": "ENV[Z='RUBY_THREAD_VM_STACK_SIZE']||exec({Z=>?5*8},'ruby',$0)\nR=Hash.new 0\nE=Hash.new{|h,k|h[k]=[]}\ndef f(x,q)\nE[x].each{|v|(f(v,x);R[x]^=R[v]+1)if v!=q}\nend\ngets;$<.each{|e|\nu,v=e.split.map &:to_i\nE[u]<<v;E[v]<<u\n}\nf(1,0)\nputs R[1]>0 ? :Alice : :Bob"
  },
  {
    "language": "Ruby",
    "code": "R=Hash.new 0\nE=Hash.new{|h,k|h[k]=[]}\ndef f(x,q)\nE[x].each{|v|(f(v,x);R[x]^=R[v]+1)if v!=q}\ngets;$<.each{|e|\nu,v=e.split.map &:to_i\nE[u]<<v;E[v]<<u\n}\nf(1,0)\nputs R[1]>0 ? :Alice : :Bob"
  },
  {
    "language": "Ruby",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(int _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(int _##i = (t), i = (f); i <  _##i; i++)\n#define downto(f, t, i)  for(int _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(int _##i = (t), i = (f); i >  _##i; i--)\ntypedef long double ld;\n#define long long long\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n    #define debug true\n    #define ln << endl\n#else\n    #define debug false\n    #define ln << '\\n'\n#endif\n#define tb << '\\t'\n#define sp << ' '\n\nconst int MOD = 1e9+7;\n\nint N;\nset<int> P[100010];\n\nint pyon(int i, int q) {\n    int x = 0;\n    for(int j: P[i]) if(j != q) {\n        x ^= pyon(j, i);\n    }\n    return x + 1;\n}\n\nsigned main() { // long: 64bit\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n\n    scanf(\"%d\",&N);\n    times(N-1, i) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        P[x-1].insert(y-1);\n        P[y-1].insert(x-1);\n    }\n\n    cout << (pyon(0, 0) != 1 ? \"Alice\" : \"Bob\") ln;\n\n    return 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "R=Hash.new 0\nE=Hash.new{|h,k|h[k]=[]}\ndef f(x,q)\nE[x].each{|v|(f(v,x);R[x]^=R[v]+1)if v!=q}\nend\ngets;$<.each{|e|\nu,v=e.split.map &:to_i\nE[u]<<v;E[v]<<u\n}\nf(1,0)\nputs R[1]>0 ? :Alice : :Bob"
  },
  {
    "language": "Ruby",
    "code": "Z,*P=->i,q{x=0;P[i].map{|j|j!=q&&x^=Z[j,i]};x+1};$<.map{|l|eval\"X,Y=\"+l.split*?,;Y&&(P[X]=*P[X],Y;P[Y]=*P[Y],X)};puts Z[1,1]>1?:Alice: :Bob"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc Grundy (T *[][]int, P *[]int, r int) int {\n  if len((*T)[r]) < 2 { return 0 }\n  G := 0\n  for _, adj := range (*T)[r] {\n    if adj == (*P)[r] { continue }\n    G = G ^ (Grundy(T, P, adj) + 1)\n  }\n  return G\n}\n\nfunc Solve() {\n  N := NextInt()\n  T := make([][]int, N)\n  for i := range T {\n    T[i] = make([]int, 0)\n  }\n  for i := 1; i < N; i++ {\n    XY := NextIntVec()\n    x, y := XY[0] - 1, XY[1] - 1\n    T[x] = append(T[x], y)\n    T[y] = append(T[y], x)\n  }\n  P := make([]int, N)\n  for i := range P {\n    P[i] = -1\n  }\n  P[0] = N\n  Q := make([]int, N)\n  pos := 1\n  for _, q := range Q {\n    for _, adj := range T[q] {\n      if 0 <= P[adj] { continue }\n      P[adj] = q\n      Q[pos] = adj\n      pos++\n    }\n  }\n  T[0] = append(T[0], N)\n  ans := \"Alice\"\n  if Grundy(&T, &P, 0) == 0 { ans = \"Bob\" }\n  Write(ans)\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc NextFloat() float64 {\n  n, _ := strconv.ParseFloat(NextLine(), 64)\n  return n\n}\nfunc NextFloatVec() []float64 {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]float64, len(L))\n  for i := range N {\n    N[i], _ = strconv.ParseFloat(L[i], 64)\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MinInt(A ...int) int {\n  min := A[0]\n  for _, a := range A {\n    if a < min { min = a }\n  }\n  return min\n}\nfunc SumInt(A ...int) int {\n  sum := 0\n  for _, a := range A {\n    sum += a\n  }\n  return sum\n}\n\nfunc Grundy (T *[][]int, P *[]int, r int) int {\n  G := 0\n  switch len((*T)[r]) {\n  case 1:\n  case 2:\n    for _, adj := range (*T)[r] {\n      if adj == (*P)[r] { continue }\n      G = Grundy(T, P, adj) + 1\n    }\n  default:\n    for _, adj := range (*T)[r] {\n      if adj == (*P)[r] { continue }\n      G = G ^ Grundy(T, P, adj)\n    }\n  }\n  return G\n}\n\nfunc Solve() {\n  N := NextInt()\n  T := make([][]int, N)\n  for i := range T {\n    T[i] = make([]int, 0)\n  }\n  for i := 1; i < N; i++ {\n    XY := NextIntVec()\n    x, y := XY[0] - 1, XY[1] - 1\n    T[x] = append(T[x], y)\n    T[y] = append(T[y], x)\n  }\n  P := make([]int, N)\n  for i := range P {\n    P[i] = -1\n  }\n  P[0] = N\n  Q := make([]int, N)\n  pos := 1\n  for _, q := range Q {\n    for _, adj := range T[q] {\n      if 0 <= P[adj] { continue }\n      P[adj] = q\n      Q[pos] = adj\n      pos++\n    }\n  }\n  T[0] = append(T[0], N)\n  ans := \"Alice\"\n  if Grundy(&T, &P, 0) == 0 { ans = \"Bob\" }\n  Write(ans)\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype IOTp struct {\n\tiBuffer []byte\n\tiPos int\n}\nfunc (this *IOTp) GetChar() byte {\n\tres:=this.iBuffer[this.iPos]\n\tthis.iPos++\n\treturn res\n}\nfunc (this *IOTp) ReadInt() int {\n\tres:=0\n\tk:=1\n\tfor ch:=this.iBuffer[this.iPos]; !(ch>='0' && ch<='9'); ch=this.iBuffer[this.iPos]{\n\t\tif ch=='-' {\n\t\t\tk=-1\n\t\t}\n\t\tthis.iPos++\n\t}\n\tfor ch:=this.iBuffer[this.iPos]; ch>='0' && ch<='9'; ch=this.iBuffer[this.iPos]{\n\t\tres=res*10+int(ch-'0')\n\t\tthis.iPos++\n\t}\n\tres*=k\n\treturn res\n}\nfunc NewIOTp() *IOTp {\n\tnow:=new(IOTp)\n\t//inputFile,_:=os.Open(\"in.txt\")\n\tinputFile:=os.Stdin\n\tnow.iBuffer,_=ioutil.ReadAll(inputFile)\n\tnow.iBuffer=append(now.iBuffer, '\\n')\n\tnow.iPos=0\n\treturn now\n}\nvar cin *bufio.Reader\nvar cout *bufio.Writer\nconst MAXN=100000\nvar sg [MAXN+10]int\nvar g [MAXN+10][]int\nfunc dfs(now,fa int) int{\n\tif len(g[now])==1 && g[now][0]==fa {\n\t\treturn 0\n\t}\n\tsg:=0\n\tfor _,v:=range g[now] {\n\t\tif v!=fa {\n\t\t\tsg^=1+dfs(v,now)\n\t\t}\n\t}\n\treturn sg\n}\nfunc main() {\n\tIO:=NewIOTp()\n\tcout=bufio.NewWriter(os.Stdout)\n\tn:=IO.ReadInt()\n\tfor i:=1; i<n; i++ {\n\t\ta,b:=IO.ReadInt(),IO.ReadInt()\n\t\tg[a]=append(g[a],b)\n\t\tg[b]=append(g[b],a)\n\t}\n\tif dfs(1,0)!=0 {\n\t\tfmt.Println(\"Alice\")\n\t} else {\n\t\tfmt.Println(\"Bob\")\n\t}\n\tcout.Flush()\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc Grundy (T *[][]int, P *[]int, r int) int {\n  G := 0\n  switch len((*T)[r]) {\n  case 1:\n    return 0\n  case 2:\n    for _, adj := range (*T)[r] {\n      if adj == (*P)[r] { continue }\n      G = Grundy(T, P, adj) + 1\n    }\n  default:\n    for _, adj := range (*T)[r] {\n      if adj == (*P)[r] { continue }\n      G = G ^ Grundy(T, P, adj)\n    }\n  }\n  return G\n}\n\nfunc Solve() {\n  N := NextInt()\n  T := make([][]int, N)\n  for i := range T {\n    T[i] = make([]int, 0)\n  }\n  for i := 1; i < N; i++ {\n    XY := NextIntVec()\n    x, y := XY[0] - 1, XY[1] - 1\n    T[x] = append(T[x], y)\n    T[y] = append(T[y], x)\n  }\n  P := make([]int, N)\n  for i := range P {\n    P[i] = -1\n  }\n  P[0] = N\n  Q := make([]int, N)\n  pos := 1\n  for _, q := range Q {\n    for _, adj := range T[q] {\n      if 0 <= P[adj] { continue }\n      P[adj] = q\n      Q[pos] = adj\n      pos++\n    }\n  }\n  T[0] = append(T[0], N)\n  ans := \"Alice\"\n  if Grundy(&T, &P, 0) == 0 { ans = \"Bob\" }\n  Write(ans)\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n := input.NextInt()\n  t := make([][]int,n)\n  for i:=0;i<n-1;i++ {\n    x,y := input.NextInts()\n    t[x-1] = append(t[x-1],y-1)\n    t[y-1] = append(t[y-1],x-1)\n  }\n  var dfs func(int,int) int\n  dfs = func(u,p int) int {\n    ret := 0\n    for _,v := range t[u] {\n      if v == p { continue }\n      ret ^= dfs(v,u)\n    }\n    return ret^1\n  }\n  if dfs(0,-1) == 1 {\n    fmt.Println(\"Alice\")\n  } else {\n    fmt.Println(\"Bob\")\n  }\n}\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) NextInts() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n := input.NextInt()\n  t := make([][]int,n)\n  for i:=0;i<n-1;i++ {\n    x,y := input.NextInts()\n    t[x-1] = append(t[x-1],y-1)\n    t[y-1] = append(t[y-1],x-1)\n  }\n  var dfs func(int,int) int\n  dfs = func(u,p int) int {\n    ret := 0\n    for _,v := range t[u] {\n      if v == p { continue }\n      ret ^= (dfs(v,u)+1)\n    }\n    return ret\n  }\n  if dfs(0,-1) != 0 {\n    fmt.Println(\"Alice\")\n  } else {\n    fmt.Println(\"Bob\")\n  }\n}\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) NextInts() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}"
  },
  {
    "language": "OCaml",
    "code": "Scanf.scanf \"%d\" (fun n ->\n    let nei = Array.make n [] in\n    for i = 1 to n - 1 do\n        Scanf.scanf \" %d %d\" (fun x y ->\n            let x = x - 1 in let y = y - 1 in\n            nei.(x) <- y :: nei.(x);\n            nei.(y) <- x :: nei.(y)\n        )\n    done;\n\n    let count node =\n        let rec dfs parent cur =\n            1 + List.fold_left (fun acc v ->\n                if v = parent then acc else acc lxor dfs cur v) 0 nei.(cur)\n        in\n        dfs 0 node\n    in\n\n    let r = List.fold_left (fun acc l -> acc lxor count l) 0 nei.(0) in\n    print_endline @@ if r <> 0 then \"Alice\" else \"Bob\"\n)"
  },
  {
    "language": "Perl",
    "code": "sub f{my($u,$p,$d)=@_;$d^=$_-$p&&1+f($_,$u)for@$u;$d}<>;map{push@$_,$_[--$|]for@_=glob}<>;print f(1)?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$d;$_-$_[1]&&($d^=1+f($_,\"@_\"))for@{$G[\"@_\"]};$d;}<>;/ /,push(@{$G[$`]},$'),push@{$G[$']},$`for<>;print f(1,0)?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my($u,$p,$d)=@_;$_-$u&&($d^=1+f($_,$u))for@$u;$d}<>;map{push@$_,$_[--$|]for glob}<>;print f(1)?Alice:Bob\n\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################"
  },
  {
    "language": "Perl",
    "code": "sub f{\n\tmy $d=0;\n\t$_-$_[1]&&($d^=1+f($_,$_[0]))for@{$G[$_[0]]};\n\t$d;\n}\n<>;\n/ /&&(push(@{$G[$`]},$'),push(@{$G[$']},$`))for<>;\nprint f(1,0)?Alice:Bob,$/"
  },
  {
    "language": "Perl",
    "code": "sub f{my$x;$v[$_//=1]++||map$x^=&f+1,@$_;$x//-1}map{push@$_,$_[$|--]for@_=glob}<>;print&f?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$d;$_-$_[1]&&($d^=1+f($_,\"@_\"))for@{$G[\"@_\"]};$d}<>;/ /,push(@{$G[$`]},$'),push@{$G[$']},$`for<>;print f(1,0)?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my($u,$p,$d)=@_;$_-$p&&($d^=1+f($_,$u))for@$u;$d}<>;map{push@$_,$_[--$|]for glob}<>;print f(1)?Alice:Bob\n\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################"
  },
  {
    "language": "Perl",
    "code": "sub f{my$x;$x^=!$$_++&&&f+1for@$_;$x}${--$_}=<>;map{push@{-$_},-$_[--$|]for@_=glob}<>;print&f?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$x;$v[$_]++||map$x^=&f+1,@$_;$x//-1}$_=1;map{push@$_,$_[$|--]for@_=glob}<>;print&f?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$x;$$_++or$x^=&f+1for@$_;$x}${--$_}=<>;map{push@{-$_},-$_[--$|]for@_=glob}<>;print&f?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$x;$v[$_+=!!map{push@$_,$_[$|--]for@_=glob}<>]++||map$x^=&f+1,@$_;$x//-1}print&f?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$d;$_-$_[1]&&($d^=1+f($_,$_[0]))for@{$G[$_[0]]};$d}<>;/ /,push(@{$G[$`]},$'),push@{$G[$']},$`for<>;print f(1,0)?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my$x;map{push@$_,$_[$|--]for@_=glob}<>;$v[$_]++||map$x^=&f+1,@$_;$x//-1}print$_+++f?Alice:Bob"
  },
  {
    "language": "Perl",
    "code": "sub f{my($u,$p,$d)=@_;$_-$p&&($d^=1+f($_,$u))for@$u;$d}<>;map{push@$_,$_[--$|]for@_=glob}<>;print f(1)?Alice:Bob\n\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################\n####################################"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n \nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto edges = new int[][](N);\n    foreach (_; 0..N-1) {\n        auto s = readln.split.map!(to!int);\n        edges[s[0] - 1] ~= s[1] - 1;\n        edges[s[1] - 1] ~= s[0] - 1;\n    }\n\n    int dfs(int n, int p) {\n        int ret = 0;\n        foreach (m; edges[n]) if (m != p) ret ^= (dfs(m, n) + 1);\n        return ret;\n    }\n\n    writeln( dfs(0, -1) ? \"Alice\" : \"Bob\" );\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.stdio;\n\nvoid main ()\n{\n\tint n;\n\twhile (readf (\" %s\", &n) > 0)\n\t{\n\t\tauto a = new int [] [n];\n\t\tforeach (i; 0..n - 1)\n\t\t{\n\t\t\tint u, v;\n\t\t\treadf (\" %s %s\", &u, &v);\n\t\t\tu -= 1;\n\t\t\tv -= 1;\n\t\t\ta[u] ~= v;\n\t\t\ta[v] ~= u;\n\t\t}\n\n\t\tint recur (int v, int p)\n\t\t{\n\t\t\tint res = 0;\n\t\t\tforeach (u; a[v])\n\t\t\t{\n\t\t\t\tif (u != p)\n\t\t\t\t{\n\t\t\t\t\tres ^= recur (u, v) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\twriteln (recur (0, -1) ? \"Alice\" : \"Bob\");\n\t}\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"D\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\n//ICPC Bangkok Regional 2016 F\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][](n);\n    foreach (i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    int dfs(int p, int b) {\n        int sm = 0;\n        foreach (d; g[p]) {\n            if (d == b) continue;\n            sm ^= dfs(d, p);\n        }\n        if (p != 0) sm++;\n        return sm;\n    }\n    if (dfs(0, -1)) {\n        writeln(\"Alice\");\n    } else {\n        writeln(\"Bob\");\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\n \n\n \n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 505;\nvector<int> adj[N];\n\nint dfs(int u, int par)\n{\n    int gr = 0;\n    for (auto v : adj[u])\n        if (v!=par)\n            gr ^= dfs(v, u);\n    return 1 + gr;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t;\n    t=1;\n\n    while(t--) {\n        fill(adj, adj+N, vector<int>());\n\n        int n;\n        cin>>n;\n\n        for (int i=1; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        int gr = dfs(1, -1) - 1;\n        cout<<(gr ? \"Alice\\n\" : \"Bob\\n\");\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[100100];\nint d[100100];\nvoid dfs(int v, int p)\n{\n    d[v] = 0; int z = 0, o = 0;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n        {\n            dfs(g[v][i], v);\n            if(d[g[v][i]] == 0)\n                z++;\n            else\n                o++;\n        }\n    }\n    if(z % 2 == 0)\n    {\n        if(o % 2 == 0)\n            d[v] = 0;\n        else\n            d[v] = 1;\n    }\n    else\n    {\n        if(o % 2 == 1)\n            d[v] = 1;\n        else\n            d[v] = 1;\n    }\n}\n\nint main()\n{\n    int n, i, x, y, ans = 0;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1, 0);\n    if(d[1] == 0)\n        cout << \"Bob\";\n    else\n        cout << \"Alice\";\n\nreturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nvector<int> adj[N];\n\nint dfs(int u, int par)\n{\n    int gr = 0;\n    for (auto v : adj[u])\n        if (v!=par)\n            gr ^= dfs(v, u);\n    return 1 + gr;\n}\n\nint main()\n{\n  //  ios::sync_with_stdio(0);\n  //  cin.tie(0);\n\n    int t;\n    t=1;\n\n    while(t--) {\n        fill(adj, adj+N, vector<int>());\n\n        int n;\n        cin>>n;\n\n        for (int i=1; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        int gr = dfs(1, -1) - 1;\n        cout<<(gr ? \"Alice\\n\" : \"Bob\\n\");\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+;\nvector<int> adj[N];\n\nint dfs(int u, int par)\n{\n    int gr = 0;\n    for (auto v : adj[u])\n        if (v!=par)\n            gr ^= dfs(v, u);\n    return 1 + gr;\n}\n\nint main()\n{\n  //  ios::sync_with_stdio(0);\n  //  cin.tie(0);\n\n    int t;\n    t=1;\n\n    while(t--) {\n        fill(adj, adj+N, vector<int>());\n\n        int n;\n        cin>>n;\n\n        for (int i=1; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        int gr = dfs(1, -1) - 1;\n        cout<<(gr ? \"Alice\\n\" : \"Bob\\n\");\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nchecked = [False]*N\ndef dfs(p):\n    checked[p] = True\n    g = 0\n    for np in graph[p]:\n        if not checked[np]:\n            g ^= dfs(np)+1\n    return g\n\nif dfs(0) == 0:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "#設定\nimport sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10**7)\n\n#ライブラリインポート\nfrom collections import defaultdict\n\n#入力受け取り\ndef getlist():\n\treturn list(map(int, input().split()))\n\nclass Graph(object):\n\tdef __init__(self):\n\t\tself.graph = defaultdict(list)\n\n\tdef __len__(self):\n\t\treturn len(self.graph)\n\n\tdef add_edge(self, a, b):\n\t\tself.graph[a].append(b)\n\n\tdef get_nodes(self):\n\t\treturn self.graph.keys()\n\ndef DFS(G, XOR, visit, node):\n\tfor i in G.graph[node]:\n\t\tif visit[i] != \"Yes\":\n\t\t\tvisit[i] = \"Yes\"\n\t\t\tDFS(G, XOR, visit, i)\n\t\t\tXOR[node] ^= XOR[i] + 1\n\n#処理内容\ndef main():\n\tN = int(input())\n\tG = Graph()\n\tfor i in range(N - 1):\n\t\tx, y = getlist()\n\t\tx -= 1\n\t\ty -= 1\n\t\tG.add_edge(x, y)\n\t\tG.add_edge(y, x)\n\n\t#計算\n\tXOR = [0] * N\n\tvisit = [\"No\"] * N\n\tvisit[0] = \"Yes\"\n\tDFS(G, XOR, visit, 0)\n\tif XOR[0] == 0:\n\t\tprint(\"Bob\")\n\telse:\n\t\tprint(\"Alice\")\n\t\n\nif __name__ == '__main__':\n\tmain()"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\n\nN = int(sys.stdin.buffer.readline())\nAB = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(N - 1)]\n\ngraph = [[] for _ in range(N)]\nfor a, b in AB:\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\n\ndef solve(v, parent=None):\n    # v を葉にした状態で相手に渡せるなら 2、渡せないなら 1 とすると\n    # 子の 2 を 1 に変えるか取り除くか選べるので Nim になる\n    xor = 0\n    for u in graph[v]:\n        if parent == u:\n            continue\n        xor ^= solve(u, parent=v)\n    return 2 if xor > 0 else 1\n\n\nans = solve(0)\nif ans == 2:\n    print('Alice')\nelse:\n    print('Bob')\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tx, y = map(int, input().split())\n\tadj[x-1].append(y-1)\n\tadj[y-1].append(x-1)\n\nnim = []\n\nfor i in adj[0]:\n\tdist = [10**10 for _ in range(n)]\n\tc = Counter()\n\tdist[0] = 0\n\tdist[i] = 1\n\ts = [i]\n\td_max = 1\n\twhile s:\n\t\tl = s.pop()\n\t\tfor v in adj[l]:\n\t\t\tif dist[v] == 10**10:\n\t\t\t\tdist[v] = dist[l]+1\n\t\t\t\tc[dist[v]] += 1\n\t\t\t\td_max = max(d_max, dist[v])\n\t\t\t\ts.append(v)\n\ttmp = 1\n\tfor j in range(d_max, 0, -1):\n\t\tif c[j]%2 == 0:\n\t\t\ttmp ^= 1\n\t\telse:\n\t\t\ttmp += 1\n\tnim.append(tmp)\n\nres = 0\nfor z in nim:\n\tres ^= z\n\nif res == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nN = int(readline())\nXY = [tuple(int(x) for x in line.split()) for line in readlines()]\n\ngraph = [[] for _ in range(N+1)]\nfor x,y in XY:\n    graph[x].append(y)\n    graph[y].append(x)\n\nvisited = [False] * (N+1)\nvisited[1] = True\nq = [1]\nord = [1]\npar = [0] * (N+1)\nwhile q:\n    x = q.pop()\n    for y in graph[x]:\n        if visited[y]:\n            continue\n        ord.append(y)\n        par[y] = x\n        visited[y] = True\n        q.append(y)\n\nG = [0] * (N+1)\nfor x in ord[::-1]:\n    p = par[x]\n    G[p] ^= (G[x]+1)\n\nanswer = 'Alice' if G[1] != 0 else 'Bob'\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "def main():\n    n = int(input())\n    ab = [list(map(int, input().split())) for _ in [0]*(n-1)]\n    g = [[] for _ in [0]*n]\n    [g[a-1].append(b-1) for a, b in ab]\n    [g[b-1].append(a-1) for a, b in ab]\n    root = 0  # 根\n    d = [-1]*n  # 根からの距離\n    d[root] = 0\n    q = [root]\n    cnt = 0\n    while q:  # BFS\n        cnt += 1\n        qq = []\n        while q:\n            i = q.pop()\n            for j in g[i]:\n                if d[j] == -1:\n                    d[j] = cnt\n                    qq.append(j)\n        q = qq\n    grundy = [0]*n\n\n    dd = [j for i, j in sorted([(j, i) for i, j in enumerate(d)])[::-1]]\n\n    for i in dd:\n        dist = d[i]\n        xorlist = []\n        xor = 0\n        for j in g[i]:\n            if d[j] > dist:\n                xorlist.append(grundy[j]+1)\n        for j in xorlist:\n            xor ^= j\n        grundy[i] = xor\n\n    if grundy[0]:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\ninput = sys.stdin.buffer.readline\n\nN = int(input())\nadj = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\nseen = [0] * (N+1)\nseen[1] = 1\nseq = []\nque = deque()\nque.append(1)\nchild = [[] for _ in range(N+1)]\nwhile que:\n    v = que.pop()\n    seq.append(v)\n    for u in adj[v]:\n        if seen[u] == 0:\n            seen[u] = 1\n            child[v].append(u)\n            que.appendleft(u)\n\ngrundy = [0] * (N+1)\nfor v in reversed(seq):\n    tmp = 0\n    for u in child[v]:\n        tmp ^= grundy[u] + 1\n    grundy[v] = tmp\n\nif grundy[1]:\n    print('Alice')\nelse:\n    print('Bob')\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\n\nN = int(sys.stdin.buffer.readline())\nAB = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(N - 1)]\n\ngraph = [[] for _ in range(N)]\nfor a, b in AB:\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\n\n# @debug\ndef solve(v, parent=None):\n    # 子供の grundy とったらいい\n    xor = 0\n    for u in graph[v]:\n        if parent == u:\n            continue\n        xor ^= solve(u, parent=v) + 1\n    return xor\n\n\nans = solve(0)\nif ans == 0:\n    print('Bob')\nelse:\n    print('Alice')\n"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, decrement=1):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.root = None\n        self.depth = [-1]*n\n        self.size = [1]*n       # 部分木のノードの数\n        self.decrement = decrement\n\n    def add_edge(self, u, v):\n        u, v = u-self.decrement, v-self.decrement\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def add_edges(self, edges):\n        for u, v in edges:\n            u, v = u-self.decrement, v-self.decrement\n            self.edges[u].append(v)\n            self.edges[v].append(u)\n\n    def set_root(self, root):\n        root -= self.decrement\n        self.root = root\n        self.par = [-1]*self.n\n        self.depth[root] = 0\n        self.order = [root]     # 帰りがけに使う\n        next_set = [root]\n        while next_set:\n            p = next_set.pop()\n            for q in self.edges[p]:\n                if self.depth[q] != -1: continue\n                self.par[q] = p\n                self.depth[q] = self.depth[p]+1\n                self.order.append(q)\n                next_set.append(q)\n        for p in self.order[::-1]:\n            for q in self.edges[p]:\n                if self.par[p] == q: continue\n                self.size[p] += self.size[q]\n\n\n#########################################################################################################\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nT = Tree(N, decrement=1)\nfor _ in range(N-1):\n    x, y = map(int, input().split())\n    T.add_edge(x, y)\nT.set_root(1)\n\ngrundy = [0]*N\nfor p in T.order[::-1]:\n    for q in T.edges[p]:\n        if T.par[p]==q: continue\n        grundy[p]^=grundy[q]+1\n\nprint(\"Alice\" if grundy[0]!=0 else \"Bob\")"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tx, y = map(int, input().split())\n\tadj[x-1].append(y-1)\n\tadj[y-1].append(x-1)\n\nnim = []\n\nfor i in adj[0]:\n\tdist = [10**10 for _ in range(n)]\n\tc = Counter()\n\tdist[0] = 0\n\tdist[i] = 1\n\tc[1] += 1\n\ts = [i]\n\td_max = 1\n\twhile s:\n\t\tl = s.pop()\n\t\tfor v in adj[l]:\n\t\t\tif dist[v] == 10**10:\n\t\t\t\tdist[v] = dist[l]+1\n\t\t\t\tc[dist[v]] += 1\n\t\t\t\td_max = max(d_max, dist[v])\n\t\t\t\ts.append(v)\n\ttmp = 0\n\tfor j in range(d_max, 0, -1):\n\t\ttmp += 1\n\t\tif c[j]%2 == 0:\n\t\t\ttmp ^= 1\n\tnim.append(tmp)\n\nres = 0\nfor z in nim:\n\tres ^= z\n\nif res == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n = I()\n    e = collections.defaultdict(set)\n    for _ in range(n-1):\n        x,y = LI()\n        e[x].add(y)\n        e[y].add(x)\n\n    def search(s):\n        d = collections.defaultdict(lambda: inf)\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            for uv in e[u]:\n                ud = 1\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n\n        return d\n\n    d = search(1)\n    dd = collections.defaultdict(int)\n    for i in range(2,n+1):\n        dd[d[i]] += 1\n    if dd[1] == 1:\n        return 'Alice'\n    k = 0\n    for i,c in dd.items():\n        if c % 2 == 1:\n            k += 1\n    if k % 2 == 1:\n        return 'Alice'\n    return 'Bob'\n\n\nprint(main())\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nn=input()\nsys.setrecursionlimit(n+1000)\nadj=[[] for i in range(n+1)]\nfor i in range(n-1):\n\tx, y=map(int, raw_input().split())\n\tadj[x].append(y)\n\tadj[y].append(x)\ndef dfs(cur, father):\n\tresult=0\n\tfor to in adj[cur]:\n\t\tif to!=father:\n\t\t\tresult^=dfs(to, cur)+1\n\treturn result\nprint \"Alice\" if dfs(1, -1) else \"Bob\""
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\ndef grundy(v,pv):\n    if v==0:\n        if len(edge[v])==1:\n            return grundy(edge[0][0],0)+1\n        else:\n            res=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    res^=grundy(nv,v)\n            return res\n    else:\n        if len(edge[v])==1:\n            return 0\n        elif len(edge[v])==2:\n            for nv in edge[v]:\n                if nv!=pv:\n                    return grundy(nv,v)+1\n        else:\n            res=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    res^=grundy(nv,v)\n            return res\n\n\nans=grundy(0,-1)\nif ans!=0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nN = int(input())\nXY = [tuple(map(int,input().split())) for i in range(N-1)]\nes = [[] for _ in range(N)]\nfor x,y in XY:\n    x,y = x-1,y-1\n    es[x].append(y)\n    es[y].append(x)\n\ndef grundy(v,p=-1):\n    x = 0\n    for to in es[v]:\n        if to==p: continue\n        x ^= (grundy(to,v) + 1)\n    return x\nprint('Alice' if grundy(0) else 'Bob')"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict, Counter\nfrom itertools import product, groupby, count, permutations, combinations\nfrom math import pi, sqrt, ceil, floor\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right\nfrom string import ascii_lowercase\nfrom functools import lru_cache, reduce\n\nINF = float(\"inf\")\nsys.setrecursionlimit(10 ** 7)\n\n# 4近傍（右, 下, 左, 上）\ndy = [0, -1, 0, 1]\ndx = [1, 0, -1, 0]\n\n\ndef inside(y: int, x: int, H: int, W: int) -> bool: return 0 <= y < H and 0 <= x < W\n\n\ndef dfs(n, p, grundy, graph):\n    g = 0\n    for x in graph[n]:\n        if x != p:\n            g ^= dfs(x, n, grundy, graph) + 1\n    grundy[n] = g\n    return g\n\n\ndef solve(N, graph):\n    grundy = [None] * (N + 1)\n    dfs(1, 0, grundy, graph)\n    return grundy[1] != 0\n\n\ndef main():\n    N = int(input())\n    graph = defaultdict(list)\n    for _ in range(N - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    print(\"Alice\" if solve(N, graph) else \"Bob\")\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n = I()\n    e = collections.defaultdict(set)\n    for _ in range(n-1):\n        x,y = LI()\n        e[x].add(y)\n        e[y].add(x)\n\n    def search(s):\n        d = collections.defaultdict(lambda: inf)\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            for uv in e[u]:\n                ud = 1\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n\n        return d\n\n    d = search(1)\n    dd = collections.defaultdict(int)\n    for i in range(2,n+1):\n        dd[d[i]] += 1\n    if dd[1] == 1:\n        return 'Alice'\n    k = 0\n    for i,c in dd.items():\n        if c % 2 == 1:\n            return 'Alice'\n    if k % 2 == 1:\n        return 'Alice'\n    return 'Bob'\n\n\nprint(main())\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ncnt = 0\nxy = [list(map(int, input().split())) for i in range(n - 1)]\nfor x,y in xy:\n\tif x == 1:\n\t\tcnt += 1\nprint([\"Bob\", \"Alice\"][cnt % 2])"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\ndef grundy(v,pv):\n    if v==0:\n        if len(edge[v])==1:\n            return grundy(edge[0][0],0)+1\n        else:\n            res=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    res^=grundy(nv,v)\n            return res\n    else:\n        if len(edge[v])==1:\n            return 0\n        elif len(edge[v])==2:\n            for nv in edge[v]:\n                if nv!=pv:\n                    return grundy(nv,v)+1\n        else:\n            res=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    res^=grundy(nv,v)\n            return res\n\n\nans=grundy(0,-1)\nif ans!=0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nEdges = list([] for _ in range(N))\nfor n in range (N-1):\n    x, y = map(int, input().split())\n    Edges[x-1].append(y-1)\n    Edges[y-1].append(x-1)\n\ndef dfs(cur_node, parent_node):\n    grundy = 0\n    for child_node in Edges[cur_node]:\n        if child_node == parent_node:\n            continue\n        else:\n            grundy ^= (dfs(child_node, cur_node) + 1)\n    return grundy\n\nG = dfs(0, -1)\nif G == 0:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nN = int(readline())\nXY = (tuple(int(x)-1 for x in line.split()) for line in readlines())\n\ngraph = [[] for _ in range(N)]\nfor x,y in XY:\n    graph[x].append(y)\n    graph[y].append(x)\n\nvisited = [True] + [False] * (N-1)\nq = [1]\nord = [1]\npar = [0] * N\nwhile q:\n    x = q.pop()\n    for y in graph[x]:\n        if visited[y]:\n            continue\n        ord.append(y)\n        par[y] = x\n        visited[y] = True\n        q.append(y)\n\nG = [0] * (N+1)\nfor x in ord[:0:-1]:\n    p = par[x]\n    G[p] ^= (G[x]+1)\n\nanswer = 'Alice' if G[0] != 0 else 'Bob'\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport random\n\n\nsys.setrecursionlimit(10 ** 5 + 5)\nrandom.seed = 1\n\n# sys.stdin = open('d1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\na = None\n\n\ndef dfs(root, parent):\n    res = 0\n    for i in a[root]:\n        if i != parent:\n            res ^= 1 + dfs(i, root)\n    return res\n\n\ndef read_tree(check=False):\n\n    if check:\n        n, p = gen()\n    else:\n        n = read_int()\n        p = [read_int_list() for i in range(n - 1)]\n\n    global a\n    a = [[] for _ in range(n)]\n    for x, y in p:\n        x -= 1\n        y -= 1\n        a[x].append(y)\n        a[y].append(x)\n\n\ndef gen():\n    n = random.randint(5, 30)\n\n    inside = [1]\n    outside = list(range(2, n + 1))\n    p = []\n    for i in range(n - 1):\n        x = random.choice(inside)\n        y = random.choice(outside)\n        p.append([x, y])\n        outside.remove(y)\n        inside.append(y)\n    return n, p\n\n\ndef solve():\n    read_tree(check=False)\n    return ['Bob', 'Alice'][dfs(0, -1) > 0]\n\n\ndef check():\n    for i in range(1000):\n        res = solve()\n        print(i, res)\n\n\ndef main():\n    # check()\n    res = solve()\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 6)\nN=int(input())\ng = [[] for i in range(N)]\nfor i in range(N-1):\n\ta,b=map(int,input().split())\n\ta -= 1\n\tb -= 1\n\tg[a].append(b)\n\tg[b].append(a)\n\nnim = [-1 for i in range(N)]\n\ndef dfs(cur,par):\n\tval = 0\n\tfor dst in g[cur]:\n\t\tif dst == par:\n\t\t\tcontinue\n\t\tval ^= dfs(dst,cur) + 1\n\tnim[cur] = val\n\treturn val\n\ndfs(0 , -1)\n#print(nim)\nif nim[0] == 0:\n\tprint('Bob')\nelse:\n\tprint('Alice')"
  },
  {
    "language": "Python",
    "code": "def topological_sort(tree: list, root) -> list:\n    \"\"\"根付き木をトポロジカルソートする\"\"\"\n    n = len(tree)\n    visited = [False] * n\n    visited[root] = True\n    tp_sorted = [root]\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        for nxt_v in tree[v]:\n            if visited[nxt_v]:\n                continue\n            visited[nxt_v] = True\n            stack.append(nxt_v)\n            tp_sorted.append(nxt_v)\n    return tp_sorted\n\n\ndef get_par(tree: list, root: int) -> list:\n    \"\"\"根付き木の頂点それぞれの親を求める\"\"\"\n    n = len(tree)\n    visited = [False] * n\n    visited[root] = True\n    par = [-1] * n\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        for nxt_v in tree[v]:\n            if visited[nxt_v]:\n                continue\n            visited[nxt_v] = True\n            stack.append(nxt_v)\n            par[nxt_v] = v\n    return par\n\n\nn = int(input())\nedges = [list(map(int, input().split())) for i in range(n - 1)]\n\n\ntree = [[] for i in range(n)]\nroot = 0\nfor a, b in edges:\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\ntp_sorted = topological_sort(tree, root)\npar = get_par(tree, root)\ngrandy = [0] * n\n\nfor v in tp_sorted[::-1]:\n    par_v = par[v]\n    if par_v == -1:\n        continue\n    grandy[par_v] ^= grandy[v] + 1\n\nif grandy[0] != 0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\ndef examB():\n    N, A, B, C, D = LI()\n    for i in range(N-1):\n        low = A + i*C - (N-1-i)*D\n        up = A + i*D - (N-1-i)*C\n        if low<=B<=up:\n            print(\"YES\")\n            return\n    print(\"NO\")\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    N = I()\n    V = [[]for _ in range(N)]\n    for _ in range(N-1):\n        x, y = LI()\n        x -= 1; y -= 1\n        V[x].append(y)\n        V[y].append(x)\n    def dfs(s,p):\n        grundy = 0\n        judge = len(V[s])\n        if p==-1:\n            judge += 1\n        if judge==1:\n            return grundy\n        if judge==2:\n            for v in V[s]:\n                if v == p:\n                    continue\n                cur = dfs(v, s)\n                grundy = cur+1\n            return grundy\n        for v in V[s]:\n            if v==p:\n                continue\n            cur = dfs(v,s)+1\n            #print(cur)\n            grundy ^= cur\n\n        return grundy\n    ans = \"Alice\"\n    if dfs(0,-1)==0:\n        ans = \"Bob\"\n    print(ans)\n    return\n\ndef examE():\n    N, H = LI()\n    A = [LI()for _ in range(N)]\n\n\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\n        \ndef getpar(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[0] = -1\n    par[p]  -1\n    stack = [p]\n    visited = set([p])\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            stack.append(vf)\n    return par\n\ndef topological_sort_tree(E, r):\n    Q = [r]\n    L = []\n    visited = set([r])\n    while Q:\n        vn = Q.pop()\n        L.append(vn)\n        for vf in E[vn]:\n            if vf not in visited:\n                visited.add(vf)\n                Q.append(vf)\n    return L\n\nN = int(input())\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, sys.stdin.readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\nP = getpar(Edge, 0)\nL = topological_sort_tree(Edge, 0)\n\ndp = [0]*N\nfor l in L[1:][::-1]:\n    p = P[l]\n    dp[p] ^= (dp[l] + 1)\n\n\nprint('Alice' if dp[0] else 'Bob')\n"
  },
  {
    "language": "Python",
    "code": "print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.buffer.readline())\nmp = map(int, sys.stdin.buffer.read().split())\nlinks = [set() for _ in range(n)]\nfor x, y in zip(mp, mp):\n    x -= 1\n    y -= 1\n    links[x].add(y)\n    links[y].add(x)\n\nstack = [(0, -2)]\ngrundy = [0] * n\nwhile stack:\n    v, p = stack.pop()\n    if p == -1:\n        g = 0\n        # second visit (aggregate children and calculate self grundy)\n        for u in links[v]:\n            g ^= grundy[u] + 1\n        grundy[v] = g\n    else:\n        # first visit (stack children and remove parent)\n        links[v].discard(p)\n        stack.append((v, -1))\n        for u in links[v]:\n            stack.append((u, v))\n\nif grundy[0] == 0:\n    print('Bob')\nelse:\n    print('Alice')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(9**9)\nn=int(input())\nT=[[]for _ in\"_\"*(n+1)]\nfor _ in range(n-1):a,b=map(int,input().split());T[a]+=b,;T[b]+=a,\ndef d(v,p):\n r=0\n for s in T[v]:\n  if s!=p:r^=d(s,v)+1\n return r\nprint(\"ABloibc e\"[d(1,1)<1::2])"
  },
  {
    "language": "Python",
    "code": "#設定\nimport sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10**7)\n\n#ライブラリインポート\nfrom collections import defaultdict\n\n#入力受け取り\ndef getlist():\n\treturn list(map(int, input().split()))\n\nclass Graph(object):\n\tdef __init__(self):\n\t\tself.graph = defaultdict(list)\n\n\tdef __len__(self):\n\t\treturn len(self.graph)\n\n\tdef add_edge(self, a, b):\n\t\tself.graph[a].append(b)\n\n\tdef get_nodes(self):\n\t\treturn self.graph.keys()\n\ndef DFS(G, XOR, visit, node):\n\tfor i in G.graph[node]:\n\t\tif visit[i] != \"Yes\":\n\t\t\tvisit[i] = \"Yes\"\n\t\t\tDFS(G, XOR, visit, i)\n\t\t\tXOR[node] = XOR[node] ^ (XOR[i] + 1)\n\n#処理内容\ndef main():\n\tN = int(input())\n\tG = Graph()\n\tfor i in range(N - 1):\n\t\tx, y = getlist()\n\t\tx -= 1\n\t\ty -= 1\n\t\tG.add_edge(x, y)\n\t\tG.add_edge(y, x)\n\n\t#計算\n\tXOR = [0] * N\n\tvisit = [\"No\"] * N\n\tvisit[0] = \"Yes\"\n\tDFS(G, XOR, visit, 0)\n\tif XOR[0] == 0:\n\t\tprint(\"Bob\")\n\telse:\n\t\tprint(\"Alice\")\n\t\n\nif __name__ == '__main__':\n\tmain()"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    A = LI()\n    D = defaultdict(int)\n    for a in A:\n        D[a] += 1\n    ans = 0\n    for key,d in D.items():\n        if key>d:\n            ans += d\n        else:\n            ans += d - key\n    print(ans)\n    return\n\ndef examB():\n    N = I()\n    A = LI()\n    S = [0]*(N+1)\n    for i in range(N):\n        S[i+1] = S[i]+A[i]\n    D = defaultdict(int)\n    for s in S:\n        D[s] += 1\n    ans = 0\n    for d in D.values():\n        ans += d*(d-1)//2\n    print(ans)\n    return\n\ndef examC():\n    N, A, B, C = LI()\n    L = [I()for _ in range(N)]\n    loop = (1<<(2*N))\n    ans = inf\n    for l in range(loop):\n        cost = 0\n        bamboo_A = 0\n        bamboo_B = 0\n        bamboo_C = 0\n        for j in range(N):\n            if l&(1<<(2*j))>0:\n                if l&(1<<(2*j+1))>0:\n                    cost += 10\n                    bamboo_A += L[j]\n                else:\n                    cost += 10\n                    bamboo_B += L[j]\n            else:\n                if l&(1<<(2*j+1))>0:\n                    cost += 10\n                    bamboo_C += L[j]\n        if bamboo_A==0 or bamboo_B==0 or bamboo_C==0:\n            continue\n        cost += abs(A-bamboo_A) + abs(B-bamboo_B) + abs(C-bamboo_C) - 30\n        ans = min(ans,cost)\n\n    print(ans)\n    return\n\ndef examD():\n    N = I()\n    P = LI()\n    O_ = [-1]*N\n    start = P[0]-1\n    for i in range(N):\n        O_[P[i]-1] = i\n    #print(O_,start)\n    A = [1]*N\n    B = [1]*N\n    for i in range(start+1,N):\n        cur = O_[i]-O_[i-1]\n        if cur>0:\n            A[i] = A[i-1] + (cur+1)\n            B[i] = B[i-1] - 1\n        else:\n            A[i] = A[i-1] + 1\n            B[i] = B[i-1] - (-cur+1)\n    for i in range(start)[::-1]:\n        cur = O_[i]-O_[i+1]\n        if cur>0:\n            B[i] = B[i+1] + (cur+1)\n            A[i] = A[i+1] - 1\n        else:\n            B[i] = B[i+1] + 1\n            A[i] = A[i+1] - (-cur+1)\n    if A[0]<1:\n        add = (1-A[0])\n        for i in range(N):\n            A[i] += add\n    if B[-1]<1:\n        add = (1-B[-1])\n        for i in range(N):\n            B[i] += add\n\n    print(\" \".join(map(str,A)))\n    print(\" \".join(map(str,B)))\n    return\n\ndef examE():\n    N = I()\n    V = [[]for _ in range(N)]\n    for _ in range(N-1):\n        x, y = LI()\n        x -= 1; y -= 1\n        V[x].append(y)\n        V[y].append(x)\n    def dfs(s,p=-1):\n        loop = 0\n        grundy = 0\n        children = []\n        for v in V[s]:\n            if v==p:\n                continue\n            loop += 1\n            children.append(dfs(v,s)+1)\n        if loop==1:\n            grundy = children[0]\n        elif loop>1:\n            for c in children:\n                grundy ^= c\n        return grundy\n    if dfs(0):\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\n\nfrom decimal import getcontext,Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = dec(\"0.000000000001\")\nalphabet = [chr(ord('a') + i) for i in range(26)]\nalphabet_convert = {chr(ord('a') + i): i for i in range(26)}\n\ngetcontext().prec = 28\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examE()\n\n\"\"\"\n9\n7 3 9 1 8 4 5 6 2\n\"\"\""
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    g = [0]*n\n    bfs = [1]*n\n    bfs[0] = 0\n    d = [0]*n\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if bfs[y]:\n                bfs[y] = 0\n                d[x] += 1\n                q.append(y)\n                q2.append((x,y))\n    while q2:\n        x,y = q2.pop()\n        g[x] ^= g[y]+1\n    ans = g[0]\n    if ans:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nN = int(readline())\nXY = (tuple(int(x)-1 for x in line.split()) for line in readlines())\n\ngraph = [[] for _ in range(N)]\nfor x,y in XY:\n    graph[x].append(y)\n    graph[y].append(x)\n\nvisited = [True] + [False] * (N-1)\nq = [0]\nord = [0]\npar = [0] * N\nwhile q:\n    x = q.pop()\n    for y in graph[x]:\n        if visited[y]:\n            continue\n        ord.append(y)\n        par[y] = x\n        visited[y] = True\n        q.append(y)\n\nG = [0] * (N+1)\nfor x in ord[:0:-1]:\n    p = par[x]\n    G[p] ^= (G[x]+1)\n\nanswer = 'Alice' if G[0] != 0 else 'Bob'\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    g = [0]*n\n    bfs = [1]*n\n    bfs[0] = 0\n    d = [0]*n\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if bfs[y]:\n                bfs[y] = 0\n                d[x] += 1\n                q.append(y)\n                q2.append((x,y))\n    while q2:\n        x,y = q2.pop()\n        if d[x] > 1:\n            g[x] ^= g[y]\n        else:\n            g[x] = g[y]+1\n    ans = g[0]\n    if ans:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(k:=2*n)\nn=int(input())\nT=[[]for _ in\"_\"*k]\nfor _ in range(n-1):a,b=map(int,input().split());T[a]+=b,;T[b]+=a,\ndef d(v,p):\n r=0\n for s in T[v]:\n  if s!=p:r^=d(s,v)+1\n return r\nprint(\"ABloibc e\"[d(1,1)<1::2])"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom collections import deque\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nG = [0] * N\nfor i in R[::-1]:\n    s = 0\n    for j in X[i]:\n        s ^= G[j]\n    G[i] = s + 1\n\nprint(\"Bob\" if G[0] == 1 else \"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(700000)\n\n\ndef main():\n\n    def nim(i, parent=None):\n        ret = 0\n        for j in edges[i]:\n            if j == parent:\n                continue\n            ret ^= nim(j, i) + 1\n        return ret\n\n    n = int(raw_input())\n    edges = [[] for i in xrange(n)]\n    for i in xrange(n - 1):\n        x, y = [int(_) - 1 for _ in raw_input().split()]\n        edges[x].append(y)\n        edges[y].append(x)\n    if nim(0) == 0:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n\n\nif __name__ == '__main__':\n    print(main())\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom collections import defaultdict\nN = int(input())\n\nXY = [list(map(int,input().split())) for _ in range(N-1)]\n\nnode_count = list(zip(*XY))[0]+list(zip(*XY))[1]\ncounter= Counter(node_count)\nd = defaultdict(list)\nfor x,y in XY:\n    d[x].append(y)\n    d[y].append(x)\n\n\ndef is_taisho(last,node):\n    nodes = list(set(d[node]) - set([last]))\n    #print(last,node,d[node],nodes)\n    if not nodes:\n        return 1\n    if len(nodes)%2 and len(nodes)>=3:\n        print(\"Alice\")\n        exit(0)\n    if not any(v%2 for v in Counter(is_taisho(node,new_node) for new_node in nodes).values()):\n        return is_taisho(node,nodes[0])+1\n    else:\n        print(\"Alice\")\n        exit(0)\n\n(is_taisho(0,1))\nprint(\"Bob\")\n\n\n\n\ndef check(node,last):\n    if last !=0:\n        pass\n\ndef check():\n    print(counter)\n    if counter[1]%2!=0:\n        return True\n    for i in range(2,N+1):\n        if counter[i]%2!=1:\n            return True\n    return False\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\nimport heapq\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n \nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\n\nN = int(input())\nadj = [[] for _ in range(N)]\nfor i in range(N - 1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    adj[x].append(y)\n    adj[y].append(x)\n\n\ndef dfs(v, p):\n    nim = 0\n    for u in adj[v]:\n        if u == p:\n            continue\n        nim ^= dfs(u, v)\n    if p == -1:\n        return nim\n    nim += 1\n    return nim\n\nres = dfs(0, -1)\n\nif res:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\ndef dfs(v,pv):\n    if v==0:\n        if len(edge[v])%2==1:\n            return True\n        else:\n            ans=0\n            for nv in edge[v]:\n                ans+=int(dfs(nv,v))\n            return ans%2==1\n    else:\n        if len(edge[v])%2==0:\n            return True\n        else:\n            ans=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    ans+=int(dfs(nv,v))\n            return ans%2==1\n\nans=dfs(0,-1)\nif ans:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "def dfs(u, fa = 0):\n\tglobal adj\n\tres = 0\n\tfor v in adj[u]:\n\t\tif v != fa:\n\t\t\tres ^= dfs(v, u) + 1\n\treturn res\n\nn = int(raw_input())\nadj = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n\tx, y = map(int, raw_input().split())\n\tadj[x].append(y)\n\tadj[y].append(x)\nprint 'Alice' if dfs(1) else 'Bob'"
  },
  {
    "language": "Python",
    "code": "import sys\nn=int(input())\nsys.setrecursionlimit(n)\nT=[[]for _ in\"_\"*(n+1)]\nfor _ in range(n-1):a,b=map(int,input().split());T[a]+=b,;T[b]+=a,\ndef d(v,p):\n r=0\n for s in T[v]:\n  if s!=p:r^=d(s,v)+1\n return r\nprint(\"ABloibc e\"[d(1,1)<1::2])"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom collections import defaultdict\nN = int(input())\n\nXY = [list(map(int,input().split())) for _ in range(N-1)]\n\nnode_count = list(zip(*XY))[0]+list(zip(*XY))[1]\ncounter= Counter(node_count)\nd = defaultdict(list)\nfor x,y in XY:\n    d[x].append(y)\n    d[y].append(x)\n\n\ndef is_taisho(last,node):\n    nodes = list(set(d[node]) - set([last]))\n    #print(last,node,d[node],nodes)\n    if not nodes:\n        return 1\n    if len(nodes)%2 and len(nodes)>=3:\n        print(\"Alice\")\n        exit(0)\n    if not any(v%2 for v in Counter(is_taisho(node,new_node) for new_node in nodes).values()):\n        return is_taisho(node,nodes[0])+1\n    else:\n        print(\"Alice\")\n        exit(0)\n\n(is_taisho(0,1))\nprint(\"Bob\")\n\n\n\n\ndef check(node,last):\n    if last !=0:\n        pass\n\ndef check():\n    print(counter)\n    if counter[1]%2!=0:\n        return True\n    for i in range(2,N+1):\n        if counter[i]%2!=1:\n            return True\n    return False\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(200000)\ndef dfs(u, fa = -1):\n\tres = 0\n\tfor v in adj[u]:\n\t\tif v != fa:\n\t\t\tres ^= dfs(v, u) + 1\n\treturn res\nn = int(raw_input())\nadj = [[] for i in xrange(n)]\nfor i in xrange(n - 1):\n\tx, y = [int(t) - 1 for t in raw_input().split()]\n\tadj[x].append(y)\n\tadj[y].append(x)\nprint 'Alice' if dfs(0) else 'Bob'"
  },
  {
    "language": "Python",
    "code": "#設定\nimport sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10**7)\n\n#ライブラリインポート\nfrom collections import defaultdict\n\n#入力受け取り\ndef getlist():\n\treturn list(map(int, input().split()))\n\nclass Graph(object):\n\tdef __init__(self):\n\t\tself.graph = defaultdict(list)\n\n\tdef __len__(self):\n\t\treturn len(self.graph)\n\n\tdef add_edge(self, a, b):\n\t\tself.graph[a].append(b)\n\n\tdef get_nodes(self):\n\t\treturn self.graph.keys()\n\ndef DFS(G, XOR, visit, node):\n\tfor i in G.graph[node]:\n\t\tif visit[i] != \"Yes\":\n\t\t\tvisit[i] = \"Yes\"\n\t\t\tDFS(G, XOR, visit, i)\n\t\t\tXOR[node] ^= XOR[i] + 1\n\n#処理内容\ndef main():\n\tN = int(input())\n\tG = Graph()\n\tfor i in range(N - 1):\n\t\tx, y = getlist()\n\t\tx -= 1\n\t\ty -= 1\n\t\tG.add_edge(x, y)\n\t\tG.add_edge(y, x)\n\n\t#計算\n\tXOR = [0] * N\n\tvisit = [\"No\"] * N\n\tvisit[0] = \"Yes\"\n\tDFS(G, XOR, visit, 0)\n\tif XOR[0] == 0:\n\t\tprint(\"Bob\")\n\telse:\n\t\tprint(\"Alice\")\n\t\n\nif __name__ == '__main__':\n\tmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport random\n\nrandom.seed = 1\n\n# sys.stdin = open('d1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\na = None\n\n\ndef dfs(root, parent):\n    res = 0\n    for i in a[root]:\n        if i != parent:\n            res ^= 1 + dfs(i, root)\n    return res\n\n\ndef read_tree(check=False):\n\n    if check:\n        n, p = gen()\n    else:\n        n = read_int()\n        p = [read_int_list() for i in range(n - 1)]\n\n    global a\n    a = [[] for _ in range(n)]\n    for x, y in p:\n        x -= 1\n        y -= 1\n        a[x].append(y)\n        a[y].append(x)\n\n\ndef gen():\n    n = random.randint(5, 30)\n\n    inside = [1]\n    outside = list(range(2, n + 1))\n    p = []\n    for i in range(n - 1):\n        x = random.choice(inside)\n        y = random.choice(outside)\n        p.append([x, y])\n        outside.remove(y)\n        inside.append(y)\n    return n, p\n\n\ndef solve():\n    read_tree(check=False)\n    return ['Bob', 'Alice'][dfs(0, -1) > 0]\n\n\ndef check():\n    for i in range(1000):\n        res = solve()\n        print(i, res)\n\n\ndef main():\n    # check()\n    res = solve()\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\ndef dfs(v,pv):\n    if v==0:\n        if len(edge[v])%2==1:\n            return True\n        else:\n            ans=0\n            for nv in edge[v]:\n                ans+=int(dfs(nv,v))\n            return ans%2==1\n    else:\n        if len(edge[v])%2==0:\n            return True\n        else:\n            ans=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    ans+=int(dfs(nv,v))\n            return ans%2==1\n\nanswer=dfs(0,-1)\nif answer:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nadj = [[] for _ in range(N)]\nfor i in range(N - 1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    adj[x].append(y)\n    adj[y].append(x)\n\n\ndef dfs(v, p):\n    nim = 0\n    for u in adj[v]:\n        if u == p:\n            continue\n        nim ^= dfs(u, v)\n    if p == -1:\n        return nim\n    nim += 1\n    return nim\n\nres = dfs(0, -1)\n\nif res:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n = I()\n    e = collections.defaultdict(set)\n    for i in range(n-1):\n        a,b = LI()\n        e[a].add(b)\n        e[b].add(a)\n\n    def f(i,c):\n        r = 0\n        for j in e[i]:\n            if j == c:\n                continue\n            t = f(j,i)\n            r ^= t\n        return r + 1\n\n    if f(1,-1) == 1:\n        return 'Bob'\n    return 'Alice'\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(pow(10,6))\n\nN = int(input())\nEdges = list([] for _ in range(N))\nfor n in range (N-1):\n    x, y = map(int, input().split())\n    Edges[x-1].append(y-1)\n    Edges[y-1].append(x-1)\n\ndef dfs(cur_node, parent_node):\n    grundy = 0\n    for child_node in Edges[cur_node]:\n        if child_node == parent_node:\n            continue\n        else:\n            grundy ^= (dfs(child_node, cur_node) + 1)\n    return grundy\n\nG = dfs(0, -1)\nif G == 0:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport heapq\n\nN = int(input())\n\ngr = [None] * N\nchild = [0] * N\ndic = {}\n\nq = []\n\n\nfor i in range(N-1):\n\n    x,y = map(int,input().split())\n    x -= 1\n    y -= 1\n\n    if x not in dic:\n        dic[x] = []\n    if y not in dic:\n        dic[y] = []\n\n    dic[x].append(y)\n    dic[y].append(x)\n    child[x] += 1\n    child[y] += 1\n\ndep = [float(\"inf\")] * N\ndep[0] = 0\ndq = deque([0])\nwhile len(dq) > 0:\n    n = dq.popleft()\n\n    for i in dic[n]:\n        if dep[i] > dep[n] + 1:\n            dep[i] = dep[n] + 1\n\n\nfor i in range(N):\n\n    if child[i] == 1:\n        child[i] = 0\n        gr[i] = 0\n        heapq.heappush(q,[-1 * dep[i] , i])\n\nwhile len(q) > 0:\n\n    ngr = 0\n    no = heapq.heappop(q)\n    now = no[1]\n\n    for i in dic[now]:\n        if gr[i] != None:\n            ngr ^= (gr[i] + 1)\n        else:\n            child[i] -= 1\n\n            if child[i] <= 1 and gr[i] == None:\n                heapq.heappush(q,[-1 * dep[i] , i])\n\n    gr[now] = ngr\n\n#print (gr)\n\nif gr[0] == 0:\n    print (\"Bob\")\nelse:\n    print (\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nn = int(input())\nab = [list(map(int,input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n+1)]\ndeg = [0]*(n+1)\nfor a,b in ab:\n  graph[a].append(b)\n  graph[b].append(a)\n  deg[a] += 1\n  deg[b] += 1\ndeg[1] += 1\ndp = [[] for i in range(n+1)]\nmark = [0]*(n+1)\nstack = []\nfor i in range(1,n+1):\n  if deg[i] == 1:\n    stack.append(i)\n    mark[i] = 1\nwhile stack:\n  x = stack.pop()\n  if dp[x]:\n    t = 0\n    for z in dp[x]:\n      t ^= z\n    mark[x] = t+1\n  if x == 1:\n    break\n  for y in graph[x]:\n    if deg[y] > 1:\n      dp[y].append(mark[x])\n      deg[y] -= 1\n      if deg[y] == 1:\n        stack.append(y)\nif mark[1] == 1:\n  print(\"Bob\")\nelse:\n  print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ng = [[] for i in range(N)]\nfor i in range(N-1):\n\ta,b=map(int,input().split())\n\ta -= 1\n\tb -= 1\n\tg[a].append(b)\n\tg[b].append(a)\n\nnim = [-1 for i in range(N)]\n\ndef dfs(cur,par):\n\tval = 0\n\tfor dst in g[cur]:\n\t\tif dst == par:\n\t\t\tcontinue\n\t\tval ^= dfs(dst,cur) + 1\n\tnim[cur] = val\n\treturn val\n\ndfs(0 , -1)\nprint(nim)\nif nim[0] == 0:\n\tprint('Bob')\nelse:\n\tprint('Alice')"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom collections import defaultdict\nN = int(input())\n\nXY = [list(map(int,input().split())) for _ in range(N-1)]\n\nnode_count = list(zip(*XY))[0]+list(zip(*XY))[1]\ncounter= Counter(node_count)\nd = defaultdict(list)\nfor x,y in XY:\n    d[x].append(y)\n    d[y].append(x)\n\n\ndef is_taisho(last,node):\n    nodes = list(set(d[node]) - set([last]))\n    #print(last,node,d[node],nodes)\n    if not nodes:\n        return 1\n    if len(nodes)%2 and len(nodes)>=3:\n        print(\"Alice\")\n        exit(0)\n    if all(is_taisho(node,new_node) for new_node in nodes):\n        return is_taisho(node,nodes[0])+1\n    else:\n        print(\"Alice\")\n        exit(0)\n\n(is_taisho(0,1))\nprint(\"Bob\")\n\ndef check(node,last):\n    if last !=0:\n        pass\n\ndef check():\n    print(counter)\n    if counter[1]%2!=0:\n        return True\n    for i in range(2,N+1):\n        if counter[i]%2!=1:\n            return True\n    return False\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nn=int(input())\nsys.setrecursionlimit(k:=2*n)\nT=[[]for _ in\"_\"*k]\nfor _ in range(n-1):a,b=map(int,input().split());T[a]+=b,;T[b]+=a,\ndef d(v,p):\n r=0\n for s in T[v]:\n  if s!=p:r^=d(s,v)+1\n return r\nprint(\"ABloibc e\"[d(1,1)<1::2])"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nx=[0]*n\ny = [0]*n\nflag = 0\nfor i in range(n-1):\n    x[i], y[i] = list(map(int,input().split(\" \")))\n    if x[i] == 1:\n        flag+=1\n    if y[i] == 1:\n        flag+=1\n\nif flag==2:\n    if n%2==0:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\nelse:\n    print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# sys.stdin = open('d1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\na = None\n\n\ndef dfs(root, parent):\n    res = 0\n    for i in a[root]:\n        if i != parent:\n            res ^= 1 + dfs(i, root)\n    return res\n\n\ndef solve():\n    n = read_int()\n    global a\n    a = [[] for _ in range(n)]\n    for i in range(n - 1):\n        x, y = read_int_list()\n        x -= 1\n        y -= 1\n        a[x].append(y)\n        a[y].append(x)\n    return ['Bob', 'Alice'][dfs(0, -1) > 0]\n\n\ndef main():\n    res = solve()\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n# hello\n\nprint \"Alice\""
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(pow(10,6))\n\nN = int(input())\nEdges = list([] for _ in range(N))\nfor n in range (N-1):\n    x, y = map(int, input().split())\n    Edges[x-1].append(y-1)\n    Edges[y-1].append(x-1)\n\ndef dfs(cur_node, parent_node):\n    grundy = 0\n    for child_node in Edges[cur_node]:\n        if child_node != parent_node:\n            grundy ^= (dfs(child_node, cur_node) + 1)\n    return grundy\n\nG = dfs(0, -1)\nif G == 0:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, edge, indexed=1):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0] - indexed].append(e[1] - indexed)\n            self.tree[e[1] - indexed].append(e[0] - indexed)\n\n    def setroot(self, root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.order = []\n        self.order.append(root)\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.order.append(adj)\n                    stack.append(adj)\n\nN = int(input())\nedge = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\ntree = Tree(N, edge)\ntree.setroot(0)\n\ngrundy = [0 for _ in range(N)]\n\nfor node in tree.order[::-1]:\n    for adj in tree.tree[node]:\n        if tree.parent[node] == adj:\n            continue\n        grundy[node] ^= grundy[adj] + 1\n\nprint('Alice' if grundy[0] != 0 else 'Bob')"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput=sys.stdin.readline\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\ndef grundy(v,pv):\n    if v==0:\n        if len(edge[v])==1:\n            return grundy(edge[0][0],0)+1\n        else:\n            res=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    res^=grundy(nv,v)\n            return res\n    else:\n        if len(edge[v])==1:\n            return 0\n        elif len(edge[v])==2:\n            for nv in edge[v]:\n                if nv!=pv:\n                    return grundy(nv,v)+1\n        else:\n            res=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    res^=grundy(nv,v)\n            return res\n\n\nans=grundy(0,-1)\nif ans!=0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tx, y = map(int, input().split())\n\tadj[x-1].append(y-1)\n\tadj[y-1].append(x-1)\n\nnim = []\n\nfor i in adj[0]:\n\tdist = [10**10 for _ in range(n)]\n\tc = Counter()\n\tdist[0] = 0\n\tdist[i] = 1\n\ts = [i]\n\td_max = 1\n\twhile s:\n\t\tl = s.pop()\n\t\tfor v in adj[l]:\n\t\t\tif dist[v] == 10**10:\n\t\t\t\tdist[v] = dist[l]+1\n\t\t\t\tc[dist[v]] += 1\n\t\t\t\td_max = max(d_max, dist[v])\n\t\t\t\ts.append(v)\n\ttmp = d_max\n\tsgn = -1\n\tfor j in range(d_max, 1, -1):\n\t\tif c[j]%2 == 0:\n\t\t\ttmp += sgn\n\t\telse:\n\t\t\tsgn *= -1\n\tnim.append(tmp)\n\nres = 0\nfor z in nim:\n\tres ^= z\n\nif res == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\ndef examB():\n    N, A, B, C, D = LI()\n    for i in range(N-1):\n        low = A + i*C - (N-1-i)*D\n        up = A + i*D - (N-1-i)*C\n        if low<=B<=up:\n            print(\"YES\")\n            return\n    print(\"NO\")\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    N = I()\n    V = [[]for _ in range(N)]\n    for _ in range(N-1):\n        x, y = LI()\n        x -= 1; y -= 1\n        V[x].append(y)\n        V[y].append(x)\n    def dfs(s,p):\n        grundy = 0\n        judge = len(V[s])\n        if p==-1:\n            judge += 1\n        if judge==1:\n            return grundy\n        if judge==2:\n            for v in V[s]:\n                if v == p:\n                    continue\n                cur = dfs(v, s)\n                grundy = cur+1\n            return grundy\n        for v in V[s]:\n            if v==p:\n                continue\n            cur = dfs(v,s)\n            grundy ^= cur\n\n        return grundy\n    ans = \"Alice\"\n    if dfs(0,-1)==0:\n        ans = \"Bob\"\n    print(ans)\n    return\n\ndef examE():\n    N, H = LI()\n    A = [LI()for _ in range(N)]\n\n\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nimport sys,copy,bisect,itertools,heapq,math\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LFI(): return list(map(float,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tx, y = map(int, input().split())\n\tadj[x-1].append(y-1)\n\tadj[y-1].append(x-1)\n\nvisited = [False for _ in range(n)]\ndef dfs(x):\n\tglobal visited\n\tnim = 0\n\tfor v in adj[x]:\n\t\tif visited[v] == False:\n\t\t\tvisited[v] = True\n\t\t\tnim ^= dfs(v)+1\n\treturn nim\n\nvisited[0] = True\nif dfs(0) == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 6)\nN=int(input())\ng = [[] for i in range(N)]\nfor i in range(N-1):\n\ta,b=map(int,input().split())\n\ta -= 1\n\tb -= 1\n\tg[a].append(b)\n\tg[b].append(a)\n\nnim = [-1 for i in range(N)]\n\ndef dfs(cur,par):\n\tval = 0\n\tfor dst in g[cur]:\n\t\tif dst == par:\n\t\t\tcontinue\n\t\tval ^= dfs(dst,cur) + 1\n\tnim[cur] = val\n\treturn val\n\ndfs(0 , -1)\n#print(nim)\nif nim[0] == 0:\n\tprint('Bob')\nelse:\n\tprint('Alice')\n"
  },
  {
    "language": "Python",
    "code": "def main():\n\n    def nim(i, parent=None):\n        ret = 0\n        for j in edges[i]:\n            if j == parent:\n                continue\n            ret ^= nim(j, i) + 1\n        return ret\n\n    n = int(raw_input())\n    edges = [[] for i in xrange(n)]\n    for i in xrange(n - 1):\n        x, y = [int(_) - 1 for _ in raw_input().split()]\n        edges[x].append(y)\n        edges[y].append(x)\n    if nim(0) == 0:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n\n\nif __name__ == '__main__':\n    print(main())\n"
  },
  {
    "language": "Python",
    "code": "#Game on Tree\nN = int(input())\na = []\nfor i in range(N-1):\n    a.append( list(map(int, input().split())) ) \n\nb = []\nfor s in a:\n    b.extend(s)\nt = b.count(1)\nif t:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  },
  {
    "language": "Python",
    "code": "import sys\nn=int(input())\nsys.setrecursionlimit(k:=2*n)\nT=[[]for _ in\"_\"*k]\nfor _ in range(n-1):a,b=map(int,input().split());T[a]+=b,;T[b]+=a,\ndef d(v,p):\n r=0\n for s in T[v]:\n  if s!=p:r^=d(s,v)+1\n return r\nprint(\"ABloibc e\"[d(1,1)<1::2])"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n = int(stdin.readline())\n    dat = map(int, stdin.read().split(), repeat(10, 2 * n - 2))\n    la = [None] * (n + 1)\n    xt = [None] * len(dat)\n    j = 0\n    for i in xrange(n - 1):\n        x, y = dat[j], dat[j+1]\n        xt[j] = la[y]\n        la[y] = j\n        j += 1\n        xt[j] = la[x]\n        la[x] = j\n        j += 1\n    g = [None] * (n + 1)\n    st = [1]\n    pu = st.append\n    po = st.pop\n    while st:\n        x = po()\n        if g[x] is None:\n            g[x] = -1\n            pu(x)\n            y = la[x]\n            while y is not None:\n                if g[dat[y]] is None:\n                    pu(dat[y])\n                y = xt[y]\n        else:\n            f = 0\n            y = la[x]\n            while y is not None:\n                if g[dat[y]] != -1:\n                    f ^= g[dat[y]] + 1\n                y = xt[y]\n            g[x] = f\n    print \"Alice\" if g[1] else \"Bob\"\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    x, y = map(lambda x: int(x) - 1, input().split())\n    G[x].append(y)\n    G[y].append(x)\n\nnim = [0] * N\n\ndef dfs(v, p):\n    for c in G[v]:\n        if c != p:\n            dfs(c, v)\n            nim[v] ^= nim[c]\n    nim[v] += 1\n\ndfs(0, -1)\nprint('Alice' if nim[0] > 1 else 'Bob')"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom collections import defaultdict\nN = int(input())\n\nXY = [list(map(int,input().split())) for _ in range(N-1)]\n\nnode_count = list(zip(*XY))[0]+list(zip(*XY))[1]\ncounter= Counter(node_count)\nd = defaultdict(list)\nfor x,y in XY:\n    d[x].append(y)\n    d[y].append(x)\n\n\ndef is_taisho(last,node):\n    nodes = list(set(d[node]) - set([last]))\n    #print(last,node,d[node],nodes)\n    if not nodes:\n        return 1\n    if len(nodes)%2 and len(nodes)>3:\n        print(\"Alice\")\n        exit(0)\n    if all(is_taisho(node,new_node) for new_node in nodes):\n        return is_taisho(node,nodes[0])+1\n    else:\n        print(\"Alice\")\n        exit(0)\n\n(is_taisho(0,1))\nprint(\"Bob\")\n\ndef check(node,last):\n    if last !=0:\n        pass\n\ndef check():\n    print(counter)\n    if counter[1]%2!=0:\n        return True\n    for i in range(2,N+1):\n        if counter[i]%2!=1:\n            return True\n    return False\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nn = int(input())\nedges = [[] for i in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    edges[x - 1].append(y - 1)\n    edges[y - 1].append(x - 1)\ndef grundy_dfs(cur, prev):\n    res = 0\n    for next_ in edges[cur]:\n        if next_ == prev:\n            continue\n        res ^= grundy_dfs(next_, cur) + 1\n    return res\nif grundy_dfs(0, -1) > 0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nc = 0\nfor i in range(n-1):\n    a,b = list(map(int,input().split()))\n    if a == 1:\n        c += 1\n\nif c%2 == 1:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    x, y = map(lambda x: int(x) - 1, input().split())\n    G[x].append(y)\n    G[y].append(x)\n\nnim = [0] * N\n\ndef dfs(v, p):\n    for c in G[v]:\n        if c != p:\n            dfs(c, v)\n            nim[v] ^= nim[c]\n    nim[v] += 1\n\ndfs(0, -1)\nprint('Alice' if nim[0] > 1 else 'Bob')"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\ndef dfs(v,pv):\n    if v==0:\n        if len(edge[v])%2==1:\n            return True\n        else:\n            ans=0\n            for nv in edge[v]:\n                ans+=int(dfs(nv,v))\n            return ans%2==1\n    else:\n        if len(edge[v])%2==0:\n            return True\n        else:\n            ans=0\n            for nv in edge[v]:\n                if nv!=pv:\n                    ans+=int(dfs(nv,v))\n                else:\n                    continue\n            return ans%2==1\n\nanswer=dfs(0,-1)\nif answer:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(500000)\nN = int(input())\nE = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    x, y = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\n\ndef dfs(v, p):\n    res = 0\n    for u in E[v]:\n        if u != p:\n            res ^= dfs(u, v) + 1\n    return res\n\nprint(\"Alice\" if dfs(1, 0) else \"Bob\")\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ng = [[] for i in range(N)]\nfor i in range(N-1):\n\ta,b=map(int,input().split())\n\ta -= 1\n\tb -= 1\n\tg[a].append(b)\n\tg[b].append(a)\n\nnim = [-1 for i in range(N)]\n\ndef dfs(cur,par):\n\tval = 0\n\tfor dst in g[cur]:\n\t\tif dst == par:\n\t\t\tcontinue\n\t\tval ^= dfs(dst,cur) + 1\n\tnim[cur] = val\n\treturn val\n\ndfs(0 , -1)\n#print(nim)\nif nim[0] == 0:\n\tprint('Bob')\nelse:\n\tprint('Alice')"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\ndef examB():\n    N, A, B, C, D = LI()\n    for i in range(N-1):\n        low = A + i*C - (N-1-i)*D\n        up = A + i*D - (N-1-i)*C\n        if low<=B<=up:\n            print(\"YES\")\n            return\n    print(\"NO\")\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    N = I()\n    V = [[]for _ in range(N)]\n    for _ in range(N-1):\n        x, y = LI()\n        x -= 1; y -= 1\n        V[x].append(y)\n        V[y].append(x)\n    def dfs(s,p):\n        grundy = 0\n        judge = len(V[s])\n        if p==-1:\n            judge += 1\n        if judge==1:\n            return grundy\n        if judge==2:\n            for v in V[s]:\n                if v == p:\n                    continue\n                cur = dfs(v, s)\n                grundy = cur+1\n            return grundy\n        for v in V[s]:\n            if v==p:\n                continue\n            cur = dfs(v,s)\n            grundy ^= cur\n\n        return grundy\n    ans = \"Alice\"\n    if dfs(0,-1)==0:\n        ans = \"Bob\"\n    print(ans)\n    return\n\ndef examE():\n    N, H = LI()\n    A = [LI()for _ in range(N)]\n\n\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nn = int(input())\nT = [[] for _ in range(n)]\nfor _ in range(n-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  T[a].append(b)\n  T[b].append(a)\ndef dfs(v, par=-1):\n  res = 0\n  for nv in T[v]:\n    if nv == par:\n      continue\n    res ^= dfs(nv, v)+1\n  return res\nif dfs(0) == 0:\n  print(\"Bob\")\nelse:\n  print(\"Alice\")"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\nN = input()\nE = [[] for i in range(N)]\n\nfor i in range(N - 1):\n    x, y = map(int, raw_input().split())\n    x, y = x - 1, y - 1\n    E[x].append(y)\n    E[y].append(x)\n\ndef func(pos, pre):\n    ret = 0\n    for to in E[pos]:\n        if to != pre:\n            ret ^= func(to, pos)\n    return ret + 1\n\nif func(0, -1) != 1:\n    print \"Alice\"\nelse:\n    print \"Bob\""
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\tx, y = map(int, input().split())\n\tadj[x-1].append(y-1)\n\tadj[y-1].append(x-1)\n\nnim = []\n\nfor i in adj[0]:\n\tdist = [10**10 for _ in range(n)]\n\tc = Counter()\n\tdist[0] = 0\n\tdist[i] = 1\n\ts = [i]\n\td_max = 1\n\twhile s:\n\t\tl = s.pop()\n\t\tfor v in adj[l]:\n\t\t\tif dist[v] == 10**10:\n\t\t\t\tdist[v] = dist[l]+1\n\t\t\t\tc[dist[v]] += 1\n\t\t\t\td_max = max(d_max, dist[v])\n\t\t\t\ts.append(v)\n\ttmp = d_max\n\tfor j in range(d_max, 1, -1):\n\t\tif c[j]%2 == 0:\n\t\t\tif (d_max-j)%2 == 0:\n\t\t\t\ttmp -= 1\n\t\t\telse:\n\t\t\t\ttmp += 1\n\t\t\td_max = j-1\n\tnim.append(tmp)\n\nres = 0\nfor z in nim:\n\tres ^= z\n\nif res == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let a = sc.read::<usize>() - 1;\n        let b = sc.read::<usize>() - 1;\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n    let g = dfs(0, 0, &graph);\n    if g == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn dfs(v: usize, p: usize, graph: &Vec<Vec<usize>>) -> usize {\n    let mut grundy = 0;\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        grundy ^= dfs(next, v, graph) + 1;\n    }\n    grundy\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let x = sc.read::<usize>() - 1;\n        let y = sc.read::<usize>() - 1;\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n\n    if dfs(0, 0, &graph) == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn dfs(v: usize, p: usize, graph: &Vec<Vec<usize>>) -> usize {\n    let mut grundy = 0;\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        grundy ^= dfs(next, v, graph) + 1;\n    }\n    grundy\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn grundy(cur: usize, parent: usize, graph: &Vec<Vec<usize>>) -> i64 {\n    let mut temp = 0;\n    for &to in graph[cur].iter() {\n        if to == parent {\n            continue;\n        }\n        temp ^= 1 + grundy(to, cur, graph);\n    }\n    temp\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut graph = vec![vec![]; n];\n    for _ in 0..n - 1 {\n        let v = read_vec::<usize>();\n        let (a, b) = (v[0] - 1, v[1] - 1);\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n    if grundy(0, 0, &graph) == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\n\nfn solve(g : &Vec<Vec<usize>>, pos : usize, prev : usize) -> u32 {\n    let mut res = 0;\n    for &t in &g[pos] {\n        if t == prev { continue }\n        res ^= solve(g, t, pos) + 1;\n    }\n    res\n}\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).ok();\n    let mut it = buf.split_whitespace();\n    let n = it.next().unwrap().parse::<usize>().unwrap();\n    let mut g = vec![Vec::new(); n];\n    for _ in 0..n-1 {\n        let x = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let y = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        g[x].push(y);\n        g[y].push(x);\n    }\n    println!(\"{}\", if solve(&g, 0, n) != 0 { \"Alice\" } else { \"Bob\" });\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        v: [(usize1, usize1); n - 1]\n    }\n    let mut t = vec![vec![]; n];\n    for &(a, b) in &v {\n        t[a].push(b);\n        t[b].push(a);\n    }\n    println!(\"{}\", if dfs(0, 0, &t) == 0 {\"Bob\"} else {\"Alice\"});\n}\n\nfn dfs(v: usize, p: usize, t: &Vec<Vec<usize>>) -> usize {\n    let mut g = 0;\n    for &c in &t[v] {\n        if c == p {\n            continue;\n        }\n        g ^= dfs(c, v, t) + 1;\n    }\n    g\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let n: usize = sc.read();\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let x = sc.read::<usize>() - 1;\n        let y = sc.read::<usize>() - 1;\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n\n    let ans = calc(0, 0, &graph);\n    if ans == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn calc(v: usize, p: usize, graph: &Vec<Vec<usize>>) -> usize {\n    let mut xor = 0;\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        xor ^= calc(next, v, graph) + 1;\n    }\n    xor\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros)]\n\nuse kyoproio::*;\nuse std::{\n    collections::*,\n    io::{self, prelude::*},\n    iter,\n    mem::{replace, swap},\n};\n\nfn main() -> io::Result<()> {\n    std::thread::Builder::new()\n        .stack_size(64 * 1024 * 1024)\n        .spawn(|| {\n            let stdin = io::stdin();\n            let stdout = io::stdout();\n            run(KInput::new(stdin.lock()), io::BufWriter::new(stdout.lock()))\n        })?\n        .join()\n        .unwrap();\n    Ok(())\n}\n\nfn run<I: Input, O: Write>(mut kin: I, mut out: O) {\n    macro_rules! output { ($($args:expr),+) => { write!(&mut out, $($args),+).unwrap(); }; }\n    macro_rules! outputln {\n        ($($args:expr),+) => { output!($($args),+); outputln!(); };\n        () => { output!(\"\\n\"); if cfg!(debug_assertions) { out.flush().unwrap(); } }\n    }\n\n    let n: usize = kin.input();\n    let mut g = vec![Vec::new(); n + 1];\n    for (x, y) in kin.iter::<(usize, usize)>().take(n - 1) {\n        g[x].push(y);\n        g[y].push(x);\n    }\n\n    let gr = dfs(&g, 1, 0) - 1;\n    if gr == 0 {\n        outputln!(\"Bob\");\n    } else {\n        outputln!(\"Alice\");\n    }\n}\n\nfn dfs(g: &[Vec<usize>], u: usize, p: usize) -> usize {\n    let mut gr = 0;\n    for &v in g[u].iter().filter(|&&v| v != p) {\n        gr ^= dfs(g, v, u);\n    }\n    gr + 1\n}\n\n// -----------------------------------------------------------------------------\npub mod kyoproio {\n    use std::io::prelude::*;\n    pub trait Input {\n        fn str(&mut self) -> &str;\n        fn input<T: InputParse>(&mut self) -> T {\n            T::input(self)\n        }\n        fn iter<T: InputParse>(&mut self) -> Iter<T, Self> {\n            Iter(self, std::marker::PhantomData)\n        }\n        fn seq<T: InputParse, B: std::iter::FromIterator<T>>(&mut self, n: usize) -> B {\n            self.iter().take(n).collect()\n        }\n    }\n    pub struct KInput<R> {\n        src: R,\n        buf: String,\n        pos: usize,\n    }\n    impl<R: BufRead> KInput<R> {\n        pub fn new(src: R) -> Self {\n            Self {\n                src,\n                buf: String::with_capacity(1024),\n                pos: 0,\n            }\n        }\n        pub fn src(&mut self) -> &mut R {\n            &mut self.src\n        }\n    }\n    impl<R: BufRead> Input for KInput<R> {\n        fn str(&mut self) -> &str {\n            loop {\n                if self.pos >= self.buf.len() {\n                    self.pos = 0;\n                    self.buf.clear();\n                    if self.src.read_line(&mut self.buf).expect(\"io error\") == 0 {\n                        return &self.buf;\n                    }\n                }\n                let range = self.pos\n                    ..self.buf[self.pos..]\n                        .find(|c: char| c.is_ascii_whitespace())\n                        .map(|i| i + self.pos)\n                        .unwrap_or_else(|| self.buf.len());\n                self.pos = range.end + 1;\n                if range.end > range.start {\n                    return &self.buf[range];\n                }\n            }\n        }\n    }\n    pub struct Iter<'a, T, I: ?Sized>(&'a mut I, std::marker::PhantomData<*const T>);\n    impl<'a, T: InputParse, I: Input + ?Sized> Iterator for Iter<'a, T, I> {\n        type Item = T;\n        fn next(&mut self) -> Option<T> {\n            Some(self.0.input())\n        }\n    }\n    pub trait InputParse: Sized {\n        fn input<I: Input + ?Sized>(src: &mut I) -> Self;\n    }\n    impl InputParse for Vec<u8> {\n        fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n            src.str().as_bytes().to_owned()\n        }\n    }\n    macro_rules! from_str_impl {\n        { $($T:ty)* } => {\n            $(impl InputParse for $T {\n                fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n                    src.str().parse::<$T>().expect(\"parse error\")\n                }\n            })*\n        }\n    }\n    from_str_impl! {\n        String char bool f32 f64 isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128\n    }\n    macro_rules! tuple_impl {\n        ($H:ident $($T:ident)*) => {\n            impl<$H: InputParse, $($T: InputParse),*> InputParse for ($H, $($T),*) {\n                fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n                    ($H::input(src), $($T::input(src)),*)\n                }\n            }\n            tuple_impl!($($T)*);\n        };\n        () => {}\n    }\n    tuple_impl!(A B C D E F G);\n    #[macro_export]\n    macro_rules! kdbg {\n        ($($v:expr),*) => {\n            if cfg!(debug_assertions) { dbg!($($v),*) } else { ($($v),*) }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules ! zero_one_impls {($ ({$ Trait : ident $ method : ident $ ($ t : ty ) *, $ e : expr } ) * ) => {$ ($ (impl $ Trait for $ t {# [inline ] fn $ method () -> Self {$ e } } ) * ) * } ; }\nzero_one_impls ! ({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 , 0 } {Zero zero f32 f64 , 0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 , 1 } {One one f32 f64 , 1. } );\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules ! iter_scan_impls {($ ($ t : ty ) * ) => {$ (impl IterScan for $ t {type Output = Self ; # [inline ] fn scan <'a , I : Iterator < Item = &'a str >> (iter : & mut I ) -> Option < Self > {iter . next () ?. parse ::<$ t > () . ok () } } ) * } ; }\n    iter_scan_impls ! (char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String );\n    macro_rules ! iter_scan_tuple_impl {($ ($ T : ident ) * ) => {impl <$ ($ T : IterScan ) ,*> IterScan for ($ ($ T , ) * ) {type Output = ($ (<$ T as IterScan >:: Output , ) * ) ; # [inline ] fn scan <'a , It : Iterator < Item = &'a str >> (_iter : & mut It ) -> Option < Self :: Output > {Some (($ (<$ T as IterScan >:: scan (_iter ) ?, ) * ) ) } } } ; }\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl ! (A B );\n    iter_scan_tuple_impl ! (A B C );\n    iter_scan_tuple_impl ! (A B C D );\n    iter_scan_tuple_impl ! (A B C D E );\n    iter_scan_tuple_impl ! (A B C D E F );\n    iter_scan_tuple_impl ! (A B C D E F G );\n    iter_scan_tuple_impl ! (A B C D E F G H );\n    iter_scan_tuple_impl ! (A B C D E F G H I );\n    iter_scan_tuple_impl ! (A B C D E F G H I J );\n    iter_scan_tuple_impl ! (A B C D E F G H I J K );\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules ! min {($ e : expr ) => {$ e } ; ($ e : expr , $ ($ es : expr ) ,+ ) => {std :: cmp :: min ($ e , min ! ($ ($ es ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! chmin {($ dst : expr , $ ($ src : expr ) ,+ ) => {{let x = std :: cmp :: min ($ dst , min ! ($ ($ src ) ,+ ) ) ; $ dst = x ; } } ; }\n#[macro_export]\nmacro_rules ! max {($ e : expr ) => {$ e } ; ($ e : expr , $ ($ es : expr ) ,+ ) => {std :: cmp :: max ($ e , max ! ($ ($ es ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! chmax {($ dst : expr , $ ($ src : expr ) ,+ ) => {{let x = std :: cmp :: max ($ dst , max ! ($ ($ src ) ,+ ) ) ; $ dst = x ; } } ; }\npub use sparse_graph::{\n    Adjacency, BidirectionalGraphScanner, BidirectionalSparseGraph, DirectedGraphScanner,\n    DirectedSparseGraph, SparseGraph, TreeGraphScanner, UndirectedGraphScanner,\n    UndirectedSparseGraph,\n};\npub mod sparse_graph {\n    use super::*;\n    use std::{iter, marker::PhantomData, ops, slice};\n    type Marker<T> = PhantomData<fn() -> T>;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct DirectedEdge;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct UndirectedEdge;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct BidirectionalEdge;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct Adjacency {\n        pub id: usize,\n        pub to: usize,\n    }\n    impl Adjacency {\n        pub fn new(id: usize, to: usize) -> Adjacency {\n            Adjacency { id, to }\n        }\n    }\n    /// Static Sparse Graph represented as Compressed Sparse Row.\n    #[derive(Debug, Clone)]\n    pub struct SparseGraph<D> {\n        vsize: usize,\n        pub start: Vec<usize>,\n        pub elist: Vec<Adjacency>,\n        pub edges: Vec<(usize, usize)>,\n        _marker: Marker<D>,\n    }\n    impl<D> SparseGraph<D> {\n        /// Return the number of vertices.\n        pub fn vertices_size(&self) -> usize {\n            self.vsize\n        }\n        /// Return the number of edges.\n        pub fn edges_size(&self) -> usize {\n            self.edges.len()\n        }\n        /// Return an iterator over graph vertices.\n        pub fn vertices(&self) -> ops::Range<usize> {\n            0..self.vertices_size()\n        }\n        /// Return a slice of adjacency vertices.\n        pub fn adjacencies(&self, v: usize) -> slice::Iter<'_, Adjacency> {\n            self.elist[self.start[v]..self.start[v + 1]].iter()\n        }\n    }\n    pub trait SparseGraphConstruction: Sized {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self>;\n    }\n    impl<D: SparseGraphConstruction> SparseGraph<D> {\n        /// Construct graph from edges.\n        pub fn from_edges(vsize: usize, edges: Vec<(usize, usize)>) -> Self {\n            D::construct_graph(vsize, edges)\n        }\n    }\n    impl SparseGraphConstruction for DirectedEdge {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self> {\n            let mut start: Vec<_> = iter::repeat(0).take(vsize + 1).collect();\n            let mut elist = Vec::with_capacity(edges.len());\n            unsafe { elist.set_len(edges.len()) }\n            for (from, _) in edges.iter().cloned() {\n                start[from] += 1;\n            }\n            for i in 1..=vsize {\n                start[i] += start[i - 1];\n            }\n            for (id, (from, to)) in edges.iter().cloned().enumerate() {\n                start[from] -= 1;\n                elist[start[from]] = Adjacency::new(id, to);\n            }\n            SparseGraph {\n                vsize,\n                start,\n                elist,\n                edges,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl SparseGraphConstruction for UndirectedEdge {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self> {\n            let mut start: Vec<_> = iter::repeat(0).take(vsize + 1).collect();\n            let mut elist = Vec::with_capacity(edges.len() * 2);\n            unsafe { elist.set_len(edges.len() * 2) }\n            for (from, to) in edges.iter().cloned() {\n                start[to] += 1;\n                start[from] += 1;\n            }\n            for i in 1..=vsize {\n                start[i] += start[i - 1];\n            }\n            for (id, (from, to)) in edges.iter().cloned().enumerate() {\n                start[from] -= 1;\n                elist[start[from]] = Adjacency::new(id, to);\n                start[to] -= 1;\n                elist[start[to]] = Adjacency::new(id, from);\n            }\n            SparseGraph {\n                vsize,\n                start,\n                elist,\n                edges,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl SparseGraphConstruction for BidirectionalEdge {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self> {\n            let mut start: Vec<_> = iter::repeat(0).take(vsize + 1).collect();\n            let mut elist = Vec::with_capacity(edges.len() * 2);\n            unsafe { elist.set_len(edges.len() * 2) }\n            for (from, to) in edges.iter().cloned() {\n                start[to] += 1;\n                start[from] += 1;\n            }\n            for i in 1..=vsize {\n                start[i] += start[i - 1];\n            }\n            for (id, (from, to)) in edges.iter().cloned().enumerate() {\n                start[from] -= 1;\n                elist[start[from]] = Adjacency::new(id * 2, to);\n                start[to] -= 1;\n                elist[start[to]] = Adjacency::new(id * 2 + 1, from);\n            }\n            SparseGraph {\n                vsize,\n                start,\n                elist,\n                edges,\n                _marker: PhantomData,\n            }\n        }\n    }\n    pub type DirectedSparseGraph = SparseGraph<DirectedEdge>;\n    pub type UndirectedSparseGraph = SparseGraph<UndirectedEdge>;\n    pub type BidirectionalSparseGraph = SparseGraph<BidirectionalEdge>;\n    pub struct SparseGraphScanner<U: IterScan<Output = usize>, T: IterScan, D> {\n        vsize: usize,\n        esize: usize,\n        _marker: Marker<(U, T, D)>,\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan, D> SparseGraphScanner<U, T, D> {\n        pub fn new(vsize: usize, esize: usize) -> Self {\n            Self {\n                vsize,\n                esize,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan, D: SparseGraphConstruction> MarkedIterScan\n        for SparseGraphScanner<U, T, D>\n    {\n        type Output = (SparseGraph<D>, Vec<<T as IterScan>::Output>);\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            let mut edges = Vec::with_capacity(self.esize);\n            let mut rest = Vec::with_capacity(self.esize);\n            for _ in 0..self.esize {\n                edges.push((U::scan(iter)?, U::scan(iter)?));\n                rest.push(T::scan(iter)?);\n            }\n            let graph = SparseGraph::from_edges(self.vsize, edges);\n            Some((graph, rest))\n        }\n    }\n    pub type DirectedGraphScanner<U, T> = SparseGraphScanner<U, T, DirectedEdge>;\n    pub type UndirectedGraphScanner<U, T> = SparseGraphScanner<U, T, UndirectedEdge>;\n    pub type BidirectionalGraphScanner<U, T> = SparseGraphScanner<U, T, BidirectionalEdge>;\n    pub struct TreeGraphScanner<U: IterScan<Output = usize>, T: IterScan> {\n        vsize: usize,\n        _marker: Marker<(U, T)>,\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan> TreeGraphScanner<U, T> {\n        pub fn new(vsize: usize) -> Self {\n            Self {\n                vsize,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan> MarkedIterScan for TreeGraphScanner<U, T> {\n        type Output = (UndirectedSparseGraph, Vec<<T as IterScan>::Output>);\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            UndirectedGraphScanner::<U, T>::new(self.vsize, self.vsize - 1).mscan(iter)\n        }\n    }\n}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules ! scan {() => {scan ! (usize ) } ; (($ ($ t : tt ) ,* ) ) => {($ (scan ! ($ t ) ) ,* ) } ; ([$ t : tt ; $ len : expr ] ) => {(0 ..$ len ) . map (| _ | scan ! ($ t ) ) . collect ::< Vec < _ >> () } ; ([$ t : ty ; $ len : expr ] ) => {scanner . scan_vec ::<$ t > ($ len ) } ; ([$ t : ty ] ) => {scanner . iter ::<$ t > () } ; ({$ e : expr } ) => {scanner . mscan ($ e ) } ; ($ t : ty ) => {scanner . scan ::<$ t > () } ; }\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules ! print {($ ($ arg : tt ) * ) => (:: std :: write ! (_out , $ ($ arg ) * ) . expect (\"io error\" ) ) }\n    macro_rules ! println {($ ($ arg : tt ) * ) => (:: std :: writeln ! (_out , $ ($ arg ) * ) . expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($ iter : expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($ iter : expr , $ sep : expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let (g, _) = scan!({ TreeGraphScanner::<marker::Usize1, ()>::new(n) });\n    let ans = dfs(0, n, &g);\n    println!(\"{}\", if ans == 0 { \"Bob\" } else { \"Alice\" });\n}\nfn dfs(u: usize, p: usize, g: &UndirectedSparseGraph) -> usize {\n    let mut x = 0;\n    for a in g.adjacencies(u).filter(|a| a.to != p) {\n        x ^= dfs(a.to, u, g) + 1;\n    }\n    x\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertexes(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n}\n#[derive(Debug)]\npub struct TreeRec {\n    pub n: usize,\n    pub dp: Vec<usize>,\n}\nimpl TreeRec {\n    pub fn new(n: usize) -> TreeRec {\n        TreeRec {\n            n: n,\n            dp: vec![0; n],\n        }\n    }\n    pub fn dfs(&mut self, u: usize, p: usize, graph: &Graph) {\n        let mut res = 0;\n        for v in graph.adjacency(u) {\n            if v.to != p {\n                self.dfs(v.to, u, graph);\n                res ^= self.dp[v.to] + 1;\n            }\n        }\n        self.dp[u] = res;\n    }\n}\nfn main() {\n    input! { n, xy: [(usize1, usize1); n-1] };\n    let mut graph = Graph::new(n);\n    let mut rec = TreeRec::new(n);\n    for &(x, y) in &xy {\n        graph.add_undirected_edge(x, y);\n    }\n    rec.dfs(0, n, &graph);\n    println!(\"{}\", if rec.dp[0] != 0 { \"Alice\" } else { \"Bob\" });\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    // G(T')\n    // G(0) = 0\n    // G(1) = 1\n    // G(S1) .. G(S N-1)\n    // G(S1) + 1 = G(S1')\n    // T => S1, S2, ...\n    // {G(S1), G(S2), ...} = {0, 1, ..., G(T)-1}\n    // T' => S1', S2', ..., 0\n    // {G(S1') ,G(S2'), ..., 0 } = {G(S1)+1, G(S2)+1, ..., 0 } = {1, 2, ..., G(T), 0 }\n    // G(T') = G(T) + 1\n\n    let n: usize = sc.read();\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let x = sc.read::<usize>() - 1;\n        let y = sc.read::<usize>() - 1;\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n\n    if grundy_dfs(0, 0, &graph) == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn grundy_dfs(v: usize, p: usize, graph: &Vec<Vec<usize>>) -> usize {\n    let mut grundy = 0;\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        grundy ^= grundy_dfs(next, v, graph) + 1;\n    }\n    grundy\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\n\nfn solve(g : &Vec<Vec<usize>>, pos : usize, prev : usize) -> bool {\n    let mut child = 0;\n    let mut win = 0;\n    for &t in &g[pos] {\n        if t == prev { continue }\n        child += 1;\n        if solve(g, t, pos) { win += 1 }\n    }\n    child%2 == 1 || win%2 == 1\n}\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).ok();\n    let mut it = buf.split_whitespace();\n    let n = it.next().unwrap().parse::<usize>().unwrap();\n    let mut g = vec![Vec::new(); n];\n    for _ in 0..n-1 {\n        let x = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let y = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        g[x].push(y);\n        g[y].push(x);\n    }\n    println!(\"{}\", if solve(&g, 0, n) { \"Alice\" } else { \"Bob\" });\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::BufRead;\n\nfn main() {\n    let mut sc = Scanner::new(std::io::stdin());\n    let n: usize = sc.next().unwrap();\n    let mut graph: Vec<Vec<usize>> = vec![vec![]; n];\n    for _ in 1..n {\n        let mut x: usize = sc.next().unwrap();\n        let mut y: usize = sc.next().unwrap();\n        x -= 1;\n        y -= 1;\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n    let res = recur(&graph, 0, n);\n    println!(\"{}\", if res == 0 { \"Bob\" } else { \"Alice\" });\n}\n\nfn recur(graph: &Vec<Vec<usize>>, i: usize, p: usize) -> usize {\n    let mut res = 0;\n    for j in graph[i].iter() {\n        if *j != p {\n            res ^= recur(graph, *j, i) + 1;\n        }\n    }\n    res\n}\n\n/// Scanner\n///\n/// # Example\n/// ```\n/// use contest::io::scanner;\n/// let mut sc = scanner::Scanner::new(\"1 2 \\n\\n \\r\\t \\n 3.5\".as_bytes());\n/// assert_eq!(\"1\".to_string(), sc.next::<String>().unwrap());\n/// assert_eq!(2, sc.next().unwrap());\n/// assert_eq!(3.5, sc.next().unwrap());\n/// assert_eq!(None, sc.next::<i32>());\n/// ```\n\npub struct Scanner<R: io::Read> {\n    br: io::BufReader<R>,\n    // Read tokens are stored in reversed order per line.\n    buf: Vec<String>,\n}\n\nimpl<R: io::Read> Scanner<R> {\n    pub fn new(r: R) -> Scanner<R> {\n        Scanner {\n            br: io::BufReader::new(r),\n            buf: vec![],\n        }\n    }\n    #[inline]\n    pub fn next<T>(&mut self) -> Option<T>\n        where T: std::str::FromStr,\n              T::Err: std::fmt::Debug\n    {\n        self.next_string().map(|s| s.parse::<T>().expect(\"Parse failed: \"))\n    }\n    fn next_string(&mut self) -> Option<String> {\n        self.buf.pop().or_else(|| match self.update() {\n            true => self.next_string(),\n            false => None,\n        })\n    }\n    #[inline]\n    fn update(&mut self) -> bool {\n        let mut s = String::new();\n        let res = self.br.read_line(&mut s);\n        match res.expect(\"I/O error.\") {\n            0 => false,\n            _ => {\n                self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                true\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules ! zero_one_impls {($ ({$ Trait : ident $ method : ident $ ($ t : ty ) *, $ e : expr } ) * ) => {$ ($ (impl $ Trait for $ t {# [inline ] fn $ method () -> Self {$ e } } ) * ) * } ; }\nzero_one_impls ! ({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 , 0 } {Zero zero f32 f64 , 0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 , 1 } {One one f32 f64 , 1. } );\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules ! iter_scan_impls {($ ($ t : ty ) * ) => {$ (impl IterScan for $ t {type Output = Self ; # [inline ] fn scan <'a , I : Iterator < Item = &'a str >> (iter : & mut I ) -> Option < Self > {iter . next () ?. parse ::<$ t > () . ok () } } ) * } ; }\n    iter_scan_impls ! (char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String );\n    macro_rules ! iter_scan_tuple_impl {($ ($ T : ident ) * ) => {impl <$ ($ T : IterScan ) ,*> IterScan for ($ ($ T , ) * ) {type Output = ($ (<$ T as IterScan >:: Output , ) * ) ; # [inline ] fn scan <'a , It : Iterator < Item = &'a str >> (_iter : & mut It ) -> Option < Self :: Output > {Some (($ (<$ T as IterScan >:: scan (_iter ) ?, ) * ) ) } } } ; }\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl ! (A B );\n    iter_scan_tuple_impl ! (A B C );\n    iter_scan_tuple_impl ! (A B C D );\n    iter_scan_tuple_impl ! (A B C D E );\n    iter_scan_tuple_impl ! (A B C D E F );\n    iter_scan_tuple_impl ! (A B C D E F G );\n    iter_scan_tuple_impl ! (A B C D E F G H );\n    iter_scan_tuple_impl ! (A B C D E F G H I );\n    iter_scan_tuple_impl ! (A B C D E F G H I J );\n    iter_scan_tuple_impl ! (A B C D E F G H I J K );\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules ! min {($ e : expr ) => {$ e } ; ($ e : expr , $ ($ es : expr ) ,+ ) => {std :: cmp :: min ($ e , min ! ($ ($ es ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! chmin {($ dst : expr , $ ($ src : expr ) ,+ ) => {{let x = std :: cmp :: min ($ dst , min ! ($ ($ src ) ,+ ) ) ; $ dst = x ; } } ; }\n#[macro_export]\nmacro_rules ! max {($ e : expr ) => {$ e } ; ($ e : expr , $ ($ es : expr ) ,+ ) => {std :: cmp :: max ($ e , max ! ($ ($ es ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! chmax {($ dst : expr , $ ($ src : expr ) ,+ ) => {{let x = std :: cmp :: max ($ dst , max ! ($ ($ src ) ,+ ) ) ; $ dst = x ; } } ; }\npub use sparse_graph::{\n    Adjacency, BidirectionalGraphScanner, BidirectionalSparseGraph, DirectedGraphScanner,\n    DirectedSparseGraph, SparseGraph, TreeGraphScanner, UndirectedGraphScanner,\n    UndirectedSparseGraph,\n};\npub mod sparse_graph {\n    use super::*;\n    use std::{iter, marker::PhantomData, ops, slice};\n    type Marker<T> = PhantomData<fn() -> T>;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct DirectedEdge;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct UndirectedEdge;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct BidirectionalEdge;\n    #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\n    pub struct Adjacency {\n        pub id: usize,\n        pub to: usize,\n    }\n    impl Adjacency {\n        pub fn new(id: usize, to: usize) -> Adjacency {\n            Adjacency { id, to }\n        }\n    }\n    /// Static Sparse Graph represented as Compressed Sparse Row.\n    #[derive(Debug, Clone)]\n    pub struct SparseGraph<D> {\n        vsize: usize,\n        pub start: Vec<usize>,\n        pub elist: Vec<Adjacency>,\n        pub edges: Vec<(usize, usize)>,\n        _marker: Marker<D>,\n    }\n    impl<D> SparseGraph<D> {\n        /// Return the number of vertices.\n        pub fn vertices_size(&self) -> usize {\n            self.vsize\n        }\n        /// Return the number of edges.\n        pub fn edges_size(&self) -> usize {\n            self.edges.len()\n        }\n        /// Return an iterator over graph vertices.\n        pub fn vertices(&self) -> ops::Range<usize> {\n            0..self.vertices_size()\n        }\n        /// Return a slice of adjacency vertices.\n        pub fn adjacencies(&self, v: usize) -> slice::Iter<'_, Adjacency> {\n            self.elist[self.start[v]..self.start[v + 1]].iter()\n        }\n    }\n    pub trait SparseGraphConstruction: Sized {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self>;\n    }\n    impl<D: SparseGraphConstruction> SparseGraph<D> {\n        /// Construct graph from edges.\n        pub fn from_edges(vsize: usize, edges: Vec<(usize, usize)>) -> Self {\n            D::construct_graph(vsize, edges)\n        }\n    }\n    impl SparseGraphConstruction for DirectedEdge {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self> {\n            let mut start: Vec<_> = iter::repeat(0).take(vsize + 1).collect();\n            let mut elist = Vec::with_capacity(edges.len());\n            unsafe { elist.set_len(edges.len()) }\n            for (from, _) in edges.iter().cloned() {\n                start[from] += 1;\n            }\n            for i in 1..=vsize {\n                start[i] += start[i - 1];\n            }\n            for (id, (from, to)) in edges.iter().cloned().enumerate() {\n                start[from] -= 1;\n                elist[start[from]] = Adjacency::new(id, to);\n            }\n            SparseGraph {\n                vsize,\n                start,\n                elist,\n                edges,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl SparseGraphConstruction for UndirectedEdge {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self> {\n            let mut start: Vec<_> = iter::repeat(0).take(vsize + 1).collect();\n            let mut elist = Vec::with_capacity(edges.len() * 2);\n            unsafe { elist.set_len(edges.len() * 2) }\n            for (from, to) in edges.iter().cloned() {\n                start[to] += 1;\n                start[from] += 1;\n            }\n            for i in 1..=vsize {\n                start[i] += start[i - 1];\n            }\n            for (id, (from, to)) in edges.iter().cloned().enumerate() {\n                start[from] -= 1;\n                elist[start[from]] = Adjacency::new(id, to);\n                start[to] -= 1;\n                elist[start[to]] = Adjacency::new(id, from);\n            }\n            SparseGraph {\n                vsize,\n                start,\n                elist,\n                edges,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl SparseGraphConstruction for BidirectionalEdge {\n        fn construct_graph(vsize: usize, edges: Vec<(usize, usize)>) -> SparseGraph<Self> {\n            let mut start: Vec<_> = iter::repeat(0).take(vsize + 1).collect();\n            let mut elist = Vec::with_capacity(edges.len() * 2);\n            unsafe { elist.set_len(edges.len() * 2) }\n            for (from, to) in edges.iter().cloned() {\n                start[to] += 1;\n                start[from] += 1;\n            }\n            for i in 1..=vsize {\n                start[i] += start[i - 1];\n            }\n            for (id, (from, to)) in edges.iter().cloned().enumerate() {\n                start[from] -= 1;\n                elist[start[from]] = Adjacency::new(id * 2, to);\n                start[to] -= 1;\n                elist[start[to]] = Adjacency::new(id * 2 + 1, from);\n            }\n            SparseGraph {\n                vsize,\n                start,\n                elist,\n                edges,\n                _marker: PhantomData,\n            }\n        }\n    }\n    pub type DirectedSparseGraph = SparseGraph<DirectedEdge>;\n    pub type UndirectedSparseGraph = SparseGraph<UndirectedEdge>;\n    pub type BidirectionalSparseGraph = SparseGraph<BidirectionalEdge>;\n    pub struct SparseGraphScanner<U: IterScan<Output = usize>, T: IterScan, D> {\n        vsize: usize,\n        esize: usize,\n        _marker: Marker<(U, T, D)>,\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan, D> SparseGraphScanner<U, T, D> {\n        pub fn new(vsize: usize, esize: usize) -> Self {\n            Self {\n                vsize,\n                esize,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan, D: SparseGraphConstruction> MarkedIterScan\n        for SparseGraphScanner<U, T, D>\n    {\n        type Output = (SparseGraph<D>, Vec<<T as IterScan>::Output>);\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            let mut edges = Vec::with_capacity(self.esize);\n            let mut rest = Vec::with_capacity(self.esize);\n            for _ in 0..self.esize {\n                edges.push((U::scan(iter)?, U::scan(iter)?));\n                rest.push(T::scan(iter)?);\n            }\n            let graph = SparseGraph::from_edges(self.vsize, edges);\n            Some((graph, rest))\n        }\n    }\n    pub type DirectedGraphScanner<U, T> = SparseGraphScanner<U, T, DirectedEdge>;\n    pub type UndirectedGraphScanner<U, T> = SparseGraphScanner<U, T, UndirectedEdge>;\n    pub type BidirectionalGraphScanner<U, T> = SparseGraphScanner<U, T, BidirectionalEdge>;\n    pub struct TreeGraphScanner<U: IterScan<Output = usize>, T: IterScan> {\n        vsize: usize,\n        _marker: Marker<(U, T)>,\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan> TreeGraphScanner<U, T> {\n        pub fn new(vsize: usize) -> Self {\n            Self {\n                vsize,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<U: IterScan<Output = usize>, T: IterScan> MarkedIterScan for TreeGraphScanner<U, T> {\n        type Output = (UndirectedSparseGraph, Vec<<T as IterScan>::Output>);\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            UndirectedGraphScanner::<U, T>::new(self.vsize, self.vsize - 1).mscan(iter)\n        }\n    }\n}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules ! scan {() => {scan ! (usize ) } ; (($ ($ t : tt ) ,* ) ) => {($ (scan ! ($ t ) ) ,* ) } ; ([$ t : tt ; $ len : expr ] ) => {(0 ..$ len ) . map (| _ | scan ! ($ t ) ) . collect ::< Vec < _ >> () } ; ([$ t : ty ; $ len : expr ] ) => {scanner . scan_vec ::<$ t > ($ len ) } ; ([$ t : ty ] ) => {scanner . iter ::<$ t > () } ; ({$ e : expr } ) => {scanner . mscan ($ e ) } ; ($ t : ty ) => {scanner . scan ::<$ t > () } ; }\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules ! print {($ ($ arg : tt ) * ) => (:: std :: write ! (_out , $ ($ arg ) * ) . expect (\"io error\" ) ) }\n    macro_rules ! println {($ ($ arg : tt ) * ) => (:: std :: writeln ! (_out , $ ($ arg ) * ) . expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($ iter : expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($ iter : expr , $ sep : expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let (g, _) = scan!({ TreeGraphScanner::<marker::Usize1, ()>::new(n) });\n    let ans = D {}.dfs(0, n, 0, &g);\n    println!(\"{}\", if ans == 0 { \"Bob\" } else { \"Alice\" });\n}\nstruct D {}\nimpl D {\n    fn dfs(&mut self, u: usize, p: usize, d: usize, g: &UndirectedSparseGraph) -> usize {\n        let mut x = d;\n        for a in g.adjacencies(u).filter(|a| a.to != p) {\n            x ^= self.dfs(a.to, u, d + 1, g);\n        }\n        x\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let x = sc.read::<usize>() - 1;\n        let y = sc.read::<usize>() - 1;\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n\n    if grundy_dfs(0, 0, &graph) == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn grundy_dfs(v: usize, p: usize, graph: &Vec<Vec<usize>>) -> usize {\n    let mut xor = 0;\n    for &next in graph[v].iter() {\n        if p == next {\n            continue;\n        }\n        xor ^= grundy_dfs(next, v, graph) + 1;\n    }\n    xor\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let n: usize = sc.read();\n    let mut graph = vec![vec![]; n];\n    for _ in 1..n {\n        let x = sc.read::<usize>() - 1;\n        let y = sc.read::<usize>() - 1;\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n\n    let g = grundy(0, 0, &graph);\n    if g == 0 {\n        println!(\"Bob\");\n    } else {\n        println!(\"Alice\");\n    }\n}\n\nfn grundy(v: usize, p: usize, graph: &Vec<Vec<usize>>) -> usize {\n    let mut g = 0;\n    for &next in graph[v].iter() {\n        if next == p {\n            continue;\n        }\n        g ^= grundy(next, v, graph) + 1;\n    }\n    g\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    size: usize,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            size: n,\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n        self.size -= 1;\n        return true;\n    }\n}\n\n/// `FenwickTree` is a data structure that can efficiently update elements\n/// and calculate prefix sums in a table of numbers.\n/// [https://en.wikipedia.org/wiki/Fenwick_tree](https://en.wikipedia.org/wiki/Fenwick_tree)\npub struct FenwickTree<T> {\n    n: usize,\n    data: Vec<T>,\n    init: T,\n}\n\nimpl<T: Copy + std::ops::AddAssign + std::ops::Sub<Output = T>> FenwickTree<T> {\n    /// Constructs a new `FenwickTree`. The size of `FenwickTree` should be specified by `size`.\n    pub fn new(size: usize, init: T) -> FenwickTree<T> {\n        FenwickTree {\n            n: size + 1,\n            data: vec![init; size + 1],\n            init: init,\n        }\n    }\n\n    pub fn add(&mut self, k: usize, value: T) {\n        let mut x = k;\n        while x < self.n {\n            self.data[x] += value;\n            x |= x + 1;\n        }\n    }\n\n    /// Returns a sum of range `[l, r)`\n    pub fn sum(&self, l: usize, r: usize) -> T {\n        self.sum_one(r) - self.sum_one(l)\n    }\n\n    /// Returns a sum of range `[0, k)`\n    pub fn sum_one(&self, k: usize) -> T {\n        assert!(k < self.n, \"k={} n={}\", k, self.n);\n\n        let mut result = self.init;\n        let mut x = k as i32 - 1;\n        while x >= 0 {\n            result += self.data[x as usize];\n            x = (x & (x + 1)) - 1;\n        }\n\n        result\n    }\n}\npub mod mod_int {\n    use super::MOD;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: Num) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "mod reader {\n    use std::fmt::Debug;\n    use std::str::FromStr;\n    use std::collections::VecDeque;\n    use std::io::{self, Read};\n\n    fn _read_line() -> String {\n        let mut buf = String::new();\n        let _ = io::stdin().read_to_string(&mut buf);\n        buf\n    }\n\n    fn _read_vec_deque_string() -> VecDeque<String> {\n        _read_line()\n            .split_whitespace()\n            .map(|s| s.to_string())\n            .collect()\n    }\n\n    #[allow(dead_code)]\n    pub struct Reader {\n        buf: VecDeque<String>,\n    }\n\n    #[allow(dead_code)]\n    impl Reader {\n        pub fn new() -> Reader {\n            Reader { buf: VecDeque::new() }\n        }\n\n        fn update_buf(&mut self) {\n            if self.buf.is_empty() {\n                self.buf = _read_vec_deque_string();\n            }\n        }\n\n        pub fn next<T>(&mut self) -> T\n            where\n                T: FromStr,\n                T::Err: Debug,\n        {\n            self.update_buf();\n            self.buf.pop_front().unwrap().parse::<T>().unwrap()\n        }\n\n        pub fn next_n<T>(&mut self, n: usize) -> Vec<T>\n            where\n                T: FromStr,\n                T::Err: Debug,\n        {\n            let mut vec: Vec<T> = Vec::with_capacity(n);\n\n            for _ in 0..n {\n                vec.push(self.next());\n            }\n            vec\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! p {\n    ([$($x:expr), *]) => {{\n        let mut f = true;\n        $(\n            print!(\"{}{}\", if f {\"\"} else {\" \"}, $x);\n            f = false;\n        )*\n        print!(\"\\n\");\n    }};\n    ($x:expr) => {{\n        let mut f = true;\n        for a in $x.iter() {\n            print!(\"{}{}\", if f {\"\"} else {\" \"}, a);\n            f = false;\n        }\n        print!(\"\\n\");\n    }};\n}\n\ntrait ToChars {\n    fn to_chars(&self) -> Vec<char>;\n}\n\nimpl ToChars for String {\n    fn to_chars(&self) -> Vec<char> {\n        self.chars().collect::<Vec<char>>()\n    }\n}\n\nfn with_large_stack(func: fn() -> ()) {\n    use std::thread::Builder;\n    let builder = Builder::new();\n    let th = builder.stack_size(10000000);\n\n    let _ = th.spawn(move || { func(); }).unwrap().join();\n}\n\nfn main() {\n    with_large_stack(_main);\n}\n\nuse std::cmp;\n\nfn dfs(g: &Vec<Vec<usize>>, v: usize, p: usize) -> i32 {\n    let mut x = 0;\n    for e in &g[v] {\n        if *e == p {\n            continue;\n        }\n        x ^= dfs(g, *e, v);\n    }\n//    p!([\"v=\", v + 1, \",g=\", cmp::max(x, 1)]);\n    x + 1\n}\n\nfn _main() {\n    let mut rd = reader::Reader::new();\n\n    let n = rd.next();\n    let mut g: Vec<Vec<usize>> = vec![vec![]; n];\n\n    for _ in 0..n - 1 {\n        let x = rd.next::<usize>() - 1;\n        let y = rd.next::<usize>() - 1;\n        g[x].push(y);\n        g[y].push(x);\n    }\n\n    let mut ans = 0;\n    for ch in &g[0] {\n        ans ^= dfs(&g, *ch, 0);\n    }\n    p!([if ans != 0 {\"Alice\"} else {\"Bob\"}]);\n}"
  }
]