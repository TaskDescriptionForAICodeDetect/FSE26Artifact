[
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines.map(_.split(\" \").map(_.toInt))\n    val x = List(Array(0, in.next.head-1, 2147483647))\n    in.foldLeft(x)((qs, q) => q match {\n        case Array(0, _*) => q.tail +: qs\n        case Array(1, i) => {\n            println((qs.find(y => y(0) <= i && y(1) >= i).get)(2))\n            qs\n        }\n    })\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines.map(_.split(\" \").map(_.toInt))\n    val x = Seq(Array(0, in.next.head-1, 2147483647))\n    in.foldLeft(x)((qs, q) => q match {\n        case Array(0, _*) => q.tail +: qs\n        case Array(1, i) => {\n            println((qs.find(y => y(0) <= i && y(1) >= i).get)(2))\n            qs\n        }\n    })\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines.map(_.split(\" \").map(_.toInt))\n    val x = scala.collection.mutable.Queue(Array(0, in.next.head-1, 2147483647))\n    in.foreach(_ match {\n        case q@Array(0, _*) => x.enqueue(q.tail)\n        case Array(1, i) => {\n            println((x.reverse.find(y => y(0) <= i && y(1) >= i).get)(2))\n        }\n    })\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines.map(_.split(\" \").map(_.toInt))\n    val a = Array.fill(in.next.head)(2147483647)\n    in.foreach {\n        case Array(0, s, t, x) => (s to t).foreach(i => a.update(i, x))\n        case Array(1, i) => println(a(i))\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n#include <algorithm>\nusing namespace std;\n\n#define SUQARE_SIZE  100000\n\nint block[SUQARE_SIZE];\nint blockSize;\nint n;\n\nvoid updateArr(int arr[],int left,int num){\n    for(int i = left;i < left + blockSize;++i){\n        if(i >= n){\n            break;\n        }\n        arr[i] = num;\n    }\n}\n\nvoid update(int arr[],int l, int r,int value)\n{\n    // 左端\n    if(l % blockSize != 0 && l != 0 && l < r){\n        int blockNumber = l / blockSize;\n        if(block[blockNumber] != __INT_MAX__){\n            updateArr(arr,blockNumber * blockSize,block[blockNumber]);\n            block[blockNumber] = __INT_MAX__;\n        }\n        do{\n            arr[l] = value;\n            l++;\n        }while(l % blockSize != 0 && l < r);\n    }\n    // blockに該当する部分\n    while ((l + blockSize) <= r)\n    {\n        block[l / blockSize] = value;\n        l += blockSize;\n    }\n    if(l <= r){\n        int blockNumber = r / blockSize;\n        if(block[blockNumber] != __INT_MAX__){\n            updateArr(arr,blockNumber * blockSize,block[blockNumber]);\n            block[blockNumber] = __INT_MAX__;\n        }\n        // 右端\n        do{\n            arr[l] = value;\n            l++;\n        }while(l <= r);\n    }\n}\n\nint query(int arr[],int index)\n{\n    int blockNumber = index / blockSize;\n    if(block[blockNumber] != __INT_MAX__){\n        return block[blockNumber];\n    }\n    else{\n        return arr[index];\n    }\n}\n\nint main(){\n    int q,command;\n    scanf(\"%d %d\",&n,&q);\n    int a[n];\n    blockSize = sqrt(n);\n    \n    for(int i = 0;i < n;++i){\n        a[i] = block[i] = __INT_MAX__;\n    }\n    \n    for(int i = 0;i < q;++i){\n        scanf(\"%d\",&command);\n        if(command == 0){\n            int l,r,value;\n            scanf(\"%d %d %d\",&l,&r,&value);\n            update(a,l,r,value);\n        }else{\n            int index;\n            scanf(\"%d\",&index);\n            printf(\"%d\\n\",query(a, index));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        cout << x[j] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\n// const double PI = atan(1.0) * 4.0;\nconst ll dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.1415\n\ntemplate <typename T, typename E> struct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, int)>;\n    int n;\n    // dat(蜃ｺ蜉�)縺ｮ繝槭�ｼ繧ｸ�ｼ域峩譁ｰ�ｼ�\n    F f;\n    // laz繧壇at縺ｫ蜿肴丐貍皮ｮ�\n    G g;\n    // laz(譖ｴ譁ｰ)縺ｮ繝代�ｼ繧ｸ�ｼ域峩譁ｰ�ｼ会ｼ井ｸ九↓莨晄眺�ｼ�\n    H h;\n    // laz繧壇at縺ｫ蜿肴丐貍皮ｮ�(縺ｾ縺ｨ繧�)\n    P p;\n    T e1;\n    E e2;\n    vector<T> dat;\n    vector<E> laz;\n    SegmentTree(int n_, F f, G g, H h, T e1, E e2, vector<T> v = vector<T>(),\n                P p = [](E a, int b) { return a; })\n        : f(f), g(g), h(h), e1(e1), e2(e2), p(p) {\n        init(n_);\n        if(n_ == (int)v.size()) build(n_, v);\n    }\n    void init(int n_) {\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.clear();\n        dat.resize(2 * n - 1, e1);\n        laz.clear();\n        laz.resize(2 * n - 1, e2);\n    }\n    void build(int n_, vector<T> v) {\n        for(int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for(int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n    inline void eval(int len, int k) {\n        if(laz[k] == e2) return;\n        if(k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = e2;\n    }\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if(r <= a || b <= l) return dat[k];\n        if(a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        eval(r - l, k);\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T update(int a, int b, E x) { return update(a, b, x, 0, 0, n); }\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if(r <= a || b <= l) return e1;\n        if(a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n    T query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\nsigned main() {\n    LCIN(N, Q);\n    auto f = [](ll a, ll b) { return a + b; };\n    auto g = [](ll a, ll b) { return b != -1 ? b : a; };\n    auto h = [](ll a, ll b) { return b != -1 ? b : a; };\n    ll e1 = 0, e2 = -1;\n    SegmentTree<ll, ll> seg(N + 1, f, g, h, e1, e2, VL(N + 1, (1LL << 31) - 1));\n    REP(i, Q) {\n        LCIN(x);\n        if(x) {\n            LCIN(idx);\n            cout << seg.query(idx, idx + 1) << \"\\n\";\n        } else {\n            LCIN(s, t, v);\n            seg.update(s, t + 1, v);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate <typename T,typename E>\nstruct LazySegmentTree{\n    typedef function<T(T,T)> F;\n    typedef function<T(T,E)> G;\n    typedef function<E(E,E)> H;\n    typedef function<E(E,int)> P;\n    int n;\n    F f;\n    G g;\n    H h;\n    P p;\n    T d1;\n    E d0;\n    vector<T> val;\n    vector<E> lazy;\n\n    LazySegmentTree(vector<T> a, F f_, G g_, H h_, T d1_, E d0_, P p_=[](E a,int b){return a;}):\n        f(f_),g(g_),h(h_),d1(d1_),d0(d0_),p(p_){\n\n        int sz = a.size();\n        n = 1;\n        while (n < sz) n <<= 1;\n        val.clear();\n        val.resize(2 * n - 1, d1);\n        lazy.clear();\n        lazy.resize(2 * n - 1, d0);\n        for (int i = 0; i < sz; i++) val[i + n - 1] = a[i];\n        for (int i = n - 2; i >= 0; i--) val[i] = f(val[i * 2 + 1], val[i * 2 + 2]);\n    }\n\n    inline void eval(int len,int k){\n        if(lazy[k]==d0) return;\n\n        if(2*k+1 < 2*n-1){\n            lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n        }\n        val[k] = g(val[k], p(lazy[k],len));\n        lazy[k] = d0;\n    }\n\n    void update(int a,int b,E x,int k=0,int l=0,int r=-1){\n        if(r < 0) r = n;\n        eval(r-l,k);\n        if(r<=a||b<=l) return;\n\n        if(a<=l&&r<=b){\n            lazy[k]=h(lazy[k],x);\n            eval(r-l, k);\n        }\n        else{\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            val[k] = f(val[2*k+1], val[2*k+2]);\n        }\n    }\n\n    T query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r < 0) r = n;\n        eval(r-l,k);\n        if(r <= a || b <= l) return d1;\n        if(a <= l && r <= b) return val[k];\n        T val_l = query(a, b , 2*k+1, l, (l+r)/2);\n        T val_r = query(a, b , 2*k+2, (l+r)/2, r);\n        return f(val_l, val_r);\n    }\n};\n\nint main(void){\n    auto f = [](int a, int b){return min(a,b);};\n    auto g = [](int a, int b){return b;};\n    auto h = [](int a, int b){return b;};\n\n    int n,q; cin >> n >> q;\n    VI a(n,INT_INF);\n    LazySegmentTree<int,int> st(a, f, g, h, INT_INF, -1);\n    REP(i,q){\n        int c; cin >> c;\n        if(c == 0){\n            int s, t, x; cin >> s >> t >> x;\n            st.update(s, t+1, x);\n        }\n        else{\n            int j; cin >> j;\n            cout << st.query(j,j+1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\nusing LL = long long;\t\tusing VB = vector<bool>;\nusing VI = vector<int>;\t\tusing VL = vector<LL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing VVI = vector<VI>;\t\tusing VVL = vector<VL>;\nusing PII = pair<int, int>;\tusing PLL = pair<LL, LL>;\nusing VP = vector<PII>;\t\tusing VPL = vector<PLL>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\ntemplate<class T>class RUQ {\n\tconst int N = 0, sqrtN = 320;\n\tint B;\n\tvector<T> A, Bucket;\n\tconst T Nil;\n\n\n\tvoid UpdateBucket(int i) {\n\t\tif (Bucket[i] != Nil) {\n\t\t\tint r = i * sqrtN, l = (i + 1) * sqrtN; // [r, l)\n\t\t\tfill(A.begin() + r, A.begin() + l, Bucket[i]);\n\t\t\tBucket[i] = Nil;\n\t\t}\n\t}\n\npublic:\n\tRUQ(int _n, T init_ = 0, T nil_ = numeric_limits<T>::min())\n\t\t: N(_n), B((_n + sqrtN - 1) / sqrtN), Nil(nil_) {\n\t\tA.resize(sqrtN * B, init_);\n\t\tBucket.resize(B, Nil);\n\t}\n\t//[s, t)\n\tvoid update(int s, int t, T x) {\n\t\tfor (int i = 0; i < Bucket.size(); i++) {\n\t\t\tint l = i * sqrtN, r = (i + 1) * sqrtN; // [l, r)\n\t\t\tif (r <= s || t <= l) {\n\t\t\t\tcontinue;\n\t\t\t} else if (s <= l && r <= t) {\n\t\t\t\tBucket[i] = x;\n\t\t\t} else {\n\t\t\t\tfor (int j = max(s, l); j < min(t, r); j++) {\n\t\t\t\t\tUpdateBucket(j / sqrtN);\n\t\t\t\t\tA[j] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tT operator()(int i) {\n\t\tUpdateBucket(i / sqrtN);\n\t\treturn A[i];\n\t}\n};\n\nint main() {\n\tint n = in, q = in;\n\tRUQ<int> r(n, INT_MAX);\n\trep(i, q) {\n\t\tint op = in;\n\t\tif (op == 0) {\n\t\t\tint s = in, t = in, x = in;\n\t\t\tr.update(s, t + 1, x);\n\t\t} else {\n\t\t\tint i = in;\n\t\t\tout(r(i));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  int a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  int lazy[nsq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+nsq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t  lazy[t/sq] = -1;\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sid = 1;\nstruct segtree {\n  int l, r, sl, sr, v;\n} s[1000005];\n\nint build(int l, int r) {\n  int u = sid++;\n  int m = l + r >> 1;\n\n  s[u].l = l;\n  s[u].r = r;\n  s[u].v = 0x7fffffff; // from problem statement\n\n  if (l != r) {\n    s[u].sl = build(l, m);\n    s[u].sr = build(m + 1, r);\n  }\n  \n  return u;\n}\n\nvoid update(int u, int l, int r, int v) {\n  if (l == s[u].l && r == s[u].r) {\n    s[u].v = v;\n    return;\n  }\n\n  if (s[u].v != -1) {\n    s[s[u].sl].v = s[u].v;\n    s[s[u].sr].v = s[u].v;\n    s[u].v = -1;\n  }\n  \n  int m = s[u].l + s[u].r >> 1;\n  if (r <= m) {\n    update(s[u].sl, l, r, v);\n  } else if (l > m) {\n    update(s[u].sr, l, r, v);\n  } else {\n    update(s[u].sl, l, m, v);\n    update(s[u].sr, m + 1, r, v);\n  }\n}\n\nint query(int u, int k) {\n  if (s[u].v != -1)\n    return s[u].v;\n\n  int m = s[u].l + s[u].r >> 1;\n  if (k <= m)\n    return query(s[u].sl, k);\n  else\n    return query(s[u].sr, k);\n}\n\nint main() {\n  int n, q; cin >> n >> q;\n  int T = build(0, n - 1);\n\n  for (int i = 0; i < q; i++) {\n    int t; cin >> t;\n    if (t == 0) {\n      int a, b, c; cin >> a >> b >> c;\n      update(T, a, b, c);\n    } else {\n      int k; cin >> k;\n      cout << query(T, k) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define loop(__x, __start, __end) for(ll __x = __start; __x < __end; __x++)\n\n/* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築\n    \n  using X = int;\n  using M = int;\n  auto fx = [](X x1, X x2) { return min(x1, x2); };\n  auto fa = [](X x, M m) { return m; };\n  auto fm = [](M m1, M m2) { return m2; };\n  int ex = numeric_limits<int>::max();\n  int em = numeric_limits<int>::max();\n  SegTreeLazy<X, M> seg(n, fx, fa, fm, ex, em);\n  set(int i, X x), build(): 初期化\n  update(int a, int b, X x) 更新\n*/\ntemplate <typename X, typename M>\nstruct SegTreeLazy {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazy(int n_, FX fx_, FA fa_, FM fm_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n    /* lazy eval */\n    void eval(int k) {\n        if (lazy[k] == em) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {            // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        // 自身を更新\n        dat[k] = fa(dat[k], lazy[k]);\n        lazy[k] = em;\n    }\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = fm(lazy[k], x);\n            eval(k);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return ex;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n};\n\nint main() {\n  int n, q; cin >> n >> q;\n  using X = ll;\n  using M = ll;\n  const ll INF = (1LL<<31)-1;\n  auto fx = [](X x1, X x2) { return x1 + x2; };\n  auto fa = [](X x, M m) { return m; };\n  auto fm = [](M m1, M m2) { return m2; };\n  int ex = 0;\n  int em = INF;\n  SegTreeLazy<X, M> seg(n+1, fx, fa, fm, ex, em);\n  loop(i,0,n+1) seg.set(i, INF);\n  seg.build();\n  vector<ll> ans;\n  loop(i,0,q) {\n    int com; cin >> com;\n    if (com == 0)  {\n      ll x, y, v; cin >> x >> y >> v;\n      seg.update(x, y+1, v);\n    }\n    else {\n      ll idx; cin >> idx;\n      ll a = seg.query(idx, idx+1);\n      cout << a << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long seg_tree[seg_size*4];\nlong long updates[seg_size*4];\nlong long seg_find(int now,int n_l,int n_r,int w_l,int w_r){\n    if(updates[now] != -1){\n        seg_tree[now] = updates[now];\n        updates[now*2] = updates[now];\n        updates[now*2+1] = updates[now];\n        updates[now] = -1;\n    }\n    if(w_l <= n_l&&n_r <= w_r) return seg_tree[now];\n    if(n_r <= w_l||w_r <= n_l) return (1LL << 31LL) - 1;\n    return min(seg_find(now*2,n_l,(n_l+n_r)/2,w_l,w_r),seg_find(now*2+1,(n_l+n_r)/2,n_r,w_l,w_r));\n}\nlong long seg_add(int now,int n_l,int n_r,int w_l,int w_r,int settings){\n    if(updates[now] != -1){\n        seg_tree[now] = updates[now];\n        updates[now*2] = updates[now];\n        updates[now*2+1] = updates[now];\n        updates[now] = -1;\n    }\n    if(w_l <= n_l&&n_r <= w_r){\n        updates[now] = settings;\n        seg_tree[now] = settings;\n        return seg_tree[now];\n    }\n    if(n_r <= w_l||w_r <= n_l) return (1LL << 31LL) - 1;\n    return min(seg_add(now*2,n_l,(n_l+n_r)/2,w_l,w_r,settings),seg_add(now*2+1,(n_l+n_r)/2,n_r,w_l,w_r,settings));\n}\nint main(){\n    int n,query;\n    cin >> n >> query;\n    for(int i = 0;i < seg_size*2;++i){\n        updates[i] = -1;\n        seg_tree[i] = (1LL << 31LL) - 1;\n    }\n    REP(i,query){\n        int a;\n        cin >> a;\n        if(a == 0){\n            int a,b,c;\n            cin >> a >> b >> c;\n            seg_add(1,0,seg_size,a,b+1,c);\n        }else{\n            int b;\n            cin >> b;\n            cout << seg_find(1,0,seg_size,b,b+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ では 1. C++14を選ぶ　gcdが無いので、lcmもテンプレから外す\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld  = long double;\nusing pint = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\nconst int INF=1e9+7;\nconst ll LINF=9223372036854775807;\nconst ll MOD=1e9+7;\nconst ld PI=acos(-1);\nconst ld EPS = 1e-10; //微調整用（EPSより小さいと0と判定など）\n\nint ii() { int x; if (scanf(\"%d\", &x)==1) return x; else return 0; }\nlong long il() { long long x; if (scanf(\"%lld\", &x)==1) return x; else return 0; }\nstring is() { string x; cin >> x; return x; }\nchar ic() { char x; cin >> x; return x; }\nvoid oi(int x) { printf(\"%d \", x); }\nvoid ol(long long x) { printf(\"%lld \", x); }\nvoid od_nosp(double x) { printf(\"%.15f\", x); } // 古い問題用\nvoid od(double x) { printf(\"%.15f \", x); }\n// long doubleで受け取り、fをLfなどに変えて出力すると、変な数値が出る\n// それをなんとかするには独自の出力を作らなければならなそう\nvoid os(const string &s) { printf(\"%s \", s.c_str()); }\nvoid oc(const char &c) { printf(\"%c \", c); }\n#define o_map(v){cerr << #v << endl; for(const auto& xxx: v){cout << xxx.first << \" \" << xxx.second << \"\\n\";}} //動作未確認\nvoid br() { putchar('\\n'); }\n\n// #define gcd __gcd //llは受け取らない C++17~のgcdと違うので注意\n// AOJでは外す int lcm(int a, int b){return a / gcd(a, b) * b;}\n#define begin_end(a) a.begin(),a.end() //sort(begin_end(vec));\n#define REP(i,m,n) for(ll i=(ll)(m) ; i < (ll) (n) ; i++ )\n#define rep(i,n) REP(i,0,n)\n#define m_p(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define p_b push_back\n#define SZ(x) ((int)(x).size) //size()がunsignedなのでエラー避けに\n\n\n// coutによるpairの出力（空白区切り）\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {return s << \"(\" << p.first << \" \" << p.second << \")\";}\n// coutによるvectorの出力（空白区切り）\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \" \"; //\"\\t\"に変えるとTabで見やすく区切る\n  }\n  return s;\n}\n// coutによる多次元vectorの出力（空白区切り）\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) {\n    s << vv[i] << endl;\n  }\n  return s;\n}\n\n//最大値、最小値の更新。更新したor等しければtrueを返す\ntemplate<typename T>\nbool chmax(T& a, T b){return (a = max(a, b)) == b;}\ntemplate<typename T>\nbool chmin(T& a, T b){return (a = min(a, b)) == b;}\n\n//4近傍（上下左右） rep(i, 2) にすると右・下だけに進む\nvector<int> dx_4 = {1, 0, -1, 0};\nvector<int> dy_4 = {0, 1, 0, -1};\n\n// -------- template end - //\n\n\n// - library ------------- //\n\n/* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築\n    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)\n    update(a,b,x)?: [a,b) 全てを x に更新。O(log(n))\n    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))\n*/\ntemplate <typename X, typename M>\nstruct SegTreeLazy {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazy(int n_, FX fx_, FA fa_, FM fm_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n    /* lazy eval */\n    void eval(int k) {\n        if (lazy[k] == em) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {            // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        // 自身を更新\n        dat[k] = fa(dat[k], lazy[k]);\n        lazy[k] = em;\n    }\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = fm(lazy[k], x);\n            eval(k);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return ex;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n};\n\n\n// --------- library end - //\n\n\nint main(){\n\n  ll N, Q;\n  cin >> N >> Q;\n\n  /* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築\n      set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)\n      update(a,b,x)?: [a,b) 全てを x に更新。O(log(n))\n      query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))\n  */\n  using X = ll;\n  using M = ll;\n  auto fx = [](X x1, X x2) -> X { return ( x2 == -1 ? x1 : x2 ); };\n  auto fa = [](X x, M m) -> X { return ( m == -1 ? x : m ); };\n  auto fm = [](M m1, M m2) -> M { return ( m2 == -1 ? m1 : m2 ); };\n  ll ex = -1;\n  ll em = -1;\n  SegTreeLazy<X, M> ruq(N, fx, fa, fm, ex, em);\n\n  rep(i, N){\n    ruq.set(i, 2147483647LL);\n  }\n  ruq.build();\n\n  rep(i, Q){\n    ll q = il();\n    if (q==0){\n      ll s, t, x;\n      cin >> s >> t >> x;\n      ruq.update(s, t+1, x);\n    }\n    else{\n      // q==1\n      ll j = il();\n      cout << ruq.query(j, j+1) << endl;\n    }\n  }\n\n\n\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct OwnNode\n{\n\tint num;\n\tint l, r;\n\tint left, right;\n\n\tOwnNode(int l,int r):l(l),r(r),num(2147483647),left(-1),right(-1){}\n};\n\nvector<OwnNode> nodes;\n\nint Build(int l, int r)\n{\n\tint id = nodes.size();\n\tnodes.push_back(OwnNode(l, r));\n\tint m = (l + r) / 2;\n\tif (l + 1 != r)\n\t{\n\t\tnodes[id].left = Build(l, m);\n\t\tnodes[id].right = Build(m, r);\n\t}\n\treturn id;\n}\n\nvoid update(int id, int s, int t, int v)\n{\n\tif (t <= nodes[id].l || nodes[id].r <= s)\n\t{\n\t\treturn;\n\t}\n\tif (s <= nodes[id].l&&nodes[id].r <= t)\n\t{\n\t\tnodes[id].num = v;\n\t\treturn;\n\t}\n\tint m = (nodes[id].l + nodes[id].r) / 2;\n\tif (nodes[id].right != -1)\n\t{\n\t\tif (nodes[id].num >= 0)\n\t\t{\n\t\t\tnodes[nodes[id].right].num = nodes[id].num;\n\t\t}\n\t\tif (m < t)\n\t\t{\n\t\t\tupdate(nodes[id].right, s, t, v);\n\t\t}\n\t}\n\tif (nodes[id].left != -1)\n\t{\n\t\tif (nodes[id].num >= 0)\n\t\t{\n\t\t\tnodes[nodes[id].left].num = nodes[id].num;\n\t\t}\n\t\tif (s < m)\n\t\t{\n\t\t\tupdate(nodes[id].left, s, t, v);\n\t\t}\n\t}\n\tnodes[id].num = -1;\n}\n\nint Find(int id,int s, int t)\n{\n\tif (t <= nodes[id].l || nodes[id].r <= s)\n\t{\n\t\treturn 2147483647;\n\t}\n\tif (nodes[id].num >= 0)\n\t{\n\t\treturn nodes[id].num;\n\t}\n\tint mini = 2147483647;\n\tint m = (nodes[id].l + nodes[id].r) / 2;\n\tif (nodes[id].right != -1)\n\t{\n\t\tif (m < t)\n\t\t{\n\t\t\tmini = min(mini, Find(nodes[id].right,s, t));\n\t\t}\n\t}\n\tif (nodes[id].left != -1)\n\t{\n\t\tif (s < m)\n\t\t{\n\t\t\tmini = min(mini, Find(nodes[id].left, s, t));\n\t\t}\n\t}\n\treturn mini;\n}\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tBuild(0, n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tupdate(0, s, t + 1, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << Find(0, s, s + 1) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nclass RUQ{\npublic:\n  int t[555555],v[555555],c;\n  void init(){\n    c=0;\n    memset(t,0,sizeof(t));\n    memset(v,0,sizeof(v));\n  }\n  void update(int a,int b,int x) {\n    c++;\n    v[c]=x;\n    update2(a,b,c);\n  }\n  void update2(int a,int b,int x,int k=0,int l=0,int r=1<<18){\n    if(b<=l||r<=a)return;\n    if(a<=l&&r<=b){t[k]=max(t[k],x);return;}\n    int m=(l+r)/2;\n    update2(a,b,x,k*2+1,l,m);\n    update2(a,b,x,k*2+2,m,r);\n  }\n  int query(int i){\n    i+=(1<<18)-1;\n    int res=t[i];\n    while(i){\n      i=(i-1)/2;\n      res=max(res,t[i]);\n    }\n    return v[res];\n  }\n};\n\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  RUQ r;\n  r.init();\n  r.v[0]=INT_MAX;\n  while(m--) {\n    int z,x;\n    cin >> z >> x;\n    if(!z) {\n      int y,w;\n      cin >> y >> w;\n      r.update(x,y+1,w);\n    } else pr(r.query(x));\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,s,e) for(int i=(s); i<(e);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n)\n#define repe(i,n) for(auto &&i:n)\n#define all(v) (v).begin(),(v).end()\n#define decimal fixed<<setprecision(20)\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\nusing namespace std;\nusing LL = long long;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 2e9;\n\n\n/*\n!) 0-indexed\n!) [a, b)に対する演算\n!) m0 / l0 : 初期化する値\n!) merge, updateNode, propagateを書く\n*/\ntemplate <typename Monoid>\nstruct LazySegtree {\n    int n;\n    vector<Monoid> dat, lazy;\n    Monoid M0, L0;\n\n    void init(int sz, Monoid m0, Monoid l0) {\n        n = 1;\n        M0 = m0;\n        L0 = l0;\n        while (n < sz) n *= 2;\n        dat.assign(2*n-1, M0);\n        lazy.assign(2*n-1, L0);\n    }\n\n    LazySegtree(int sz, Monoid m0, Monoid l0){\n        init(sz, m0, l0);\n    }\n\n    LazySegtree(int sz, Monoid m0) {\n        init(sz, m0, m0);\n    }\n\n    Monoid merge(Monoid a, Monoid b){\n        // ##### WRITE HERE #####\n        // 区間をマージする二項演算\n        return min(a, b);\n    }\n\n    void updateNode(int k, Monoid x){\n        // ##### WRITE HERE #####\n        // 区間を更新する二項演算\n        lazy[k] = x;\n    }\n\n    void propagate(int k){\n        // ##### WRITE HERE #####\n        // 遅延配列の伝搬のさせ方\n        dat[k] = lazy[k];\n    }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] == L0) return;\n        propagate(k);\n        if(r-l > 1) {\n            updateNode(2*k+1, lazy[k]);\n            updateNode(2*k+2, lazy[k]);\n        }\n        lazy[k] = L0;\n    }\n\n    void update(int a, int b, Monoid x, int k, int l, int r) {\n        eval(k, l, r);\n        // 範囲外\n        if (r <= a || b <= l) return;\n        // [a, b)が[l, r)を被覆\n        if (a <= l && r <= b) {\n            updateNode(k, x);\n            eval(k, l, r);\n        }else{\n            update(a, b, x, k*2+1, l, (l+r)/2);\n            update(a, b, x, k*2+2, (l+r)/2, r);\n            dat[k] = merge(dat[2*k+1], dat[2*k+2]);\n        }\n    }\n\n    void update(int a, int b, Monoid x) {\n        update(a, b, x, 0, 0, n);\n    }\n\n    Monoid query(int a, int b, int k, int l, int r) {\n        eval(k, l, r);\n        // 範囲外\n        if (r <= a || b <= l) return M0;\n        // [a, b)が[l, r)を被覆\n        if (a <= l && r <= b) return dat[k];\n        else {\n            Monoid L = query(a, b, k*2+1, l, (l+r)/2);\n            Monoid R = query(a, b, k*2+2, (l+r)/2, r);\n            return merge(L, R);\n        }\n    }\n\n    Monoid query(int a, int b){\n        return query(a, b, 0, 0, n);\n    }\n\n    Monoid operator[](const int &k){ return dat[k + n - 1]; }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    LazySegtree<int> seg(n, numeric_limits<int>::max());\n\n    rep(i, q){\n        int p;\n        cin >> p;\n        if(p == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }else{\n            int x;\n            cin >> x;\n            cout << seg.query(x, x+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass RUQ{\n\tint n,seg,init;\n\tvector<P> dat;\npublic:\n\tRUQ(int siz,int def) : n(siz),init(def),seg(1){\n\t\twhile(seg < n) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = P(-1,init);\n\t}\n\tvoid update(int a,int b,int x,int tim,int k = 0,int l = 0,int r = -1){\n\t\tif(r == -1) r = seg;\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdat[k] = P(tim,x);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,x,tim,k * 2 + 1,l,(l + r) / 2);\n\t\tupdate(a,b,x,tim,k * 2 + 2,(l + r) / 2,r);\n\t}\n\tP get(int i){\n\t\ti += seg - 1;\n\t\tP ret = dat[i];\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tret = max(ret,dat[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tint n,q;\n\tcin >> n >> q;\n\tRUQ ruq(n,(1 << 31) - 1);\n\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint s,t,x;\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s,t + 1,x,i);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << ruq.get(x).second << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            //if(i < s_min || i > t_max){\n            //    A[i] = INT_MAX;\n                cout << A[i] << endl;\n            //}else{\n            //    for(j = m; j >= 0; j--){\n            //        if(s[j] <= i && t[j] >= i){\n            //            A[i] = x[j];\n            //            cout << A[i] << endl;\n            //            break;\n            //        }\n            //    }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nstruct SD\n{\n\tint n;\n\tint lsize;\n\tint sn;\n\tvector<int> data;\n\tvector<int> lazyData;\n\n\tSD(int n) :n(n), lsize(sqrt(n)), sn(n / lsize + 1), data(n, 2147483647), lazyData(sn, -1){}\n\n\tvoid applyLazy(int k)\n\t{\n\t\tif (lazyData[k] == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = k*lsize; i < (min(n, (k + 1)*lsize)); i++)\n\t\t{\n\t\t\tdata[i] = lazyData[k];\n\t\t}\n\t\tlazyData[k] = -1;\n\t}\n\n\tvoid update(int t, int s, int v)\n\t{\n\t\tfor (int i = t / lsize; i < (s / lsize); i++)\n\t\t{\n\t\t\tint l = i*lsize;\n\t\t\tint r = (i + 1)*lsize - 1;\n\n\t\t\tif (s < l || r < t)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (t <= l&&r <= s)\n\t\t\t{\n\t\t\t\tlazyData[i] = v;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplyLazy(i);\n\t\t\t\tfor (int j = t; j <= s; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[j] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int index)\n\t{\n\t\tint k = index / lsize;\n\t\tapplyLazy(k);\n\t\treturn data[index];\n\t}\n};\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tSD sd(n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tsd.update(s, t, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << sd.find(s) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n\nclass SegmentTree {\n\tstd::vector<std::vector<int>> _array;\n\tstd::vector<int> _size;\n\tstatic constexpr int undefined = -1;\n\tvoid make_upper_undefined(int pos, int depth = 1) {\n\t\tif (depth == _array.size()) return;\n\t\tmake_upper_undefined(pos / 2, depth + 1);\n\t\tswitch (_array[depth][pos]) {\n\t\tcase undefined: return;\n\t\tdefault:\n\t\t\t_array[depth - 1][pos * 2] = _array[depth][pos];\n\t\t\tif (pos * 2 + 1 < _array[depth - 1].size()) _array[depth - 1][pos * 2 + 1] = _array[depth][pos];\n\t\t\t_array[depth][pos] = undefined;\n\t\t}\n\t}\npublic:\n\tSegmentTree(int size) :_array{}, _size{} {\n\t\tfor (auto i = size; i > 1; i = (i + 1) / 2) {\n\t\t\t_size.push_back(i);\n\t\t}\n\t\t_size.push_back(1);\n\t\t_array = std::vector<std::vector<int>>(_size.size());\n\t\tfor (auto i = 0; i < _array.size(); ++i) {\n\t\t\t_array[i] = std::vector<int>(_size[i], undefined);\n\t\t}\n\t\t_array[_array.size() - 1][0] = (1 << 31) - 1;\n\t}\n\tvoid update(int from, int to, int new_value) {\n\t\tauto depth = 0;\n\t\twhile (from < to) {\n\t\t\tif (from % 2 == 1) {\n\t\t\t\tmake_upper_undefined(from / 2, depth + 1);\n\t\t\t\t_array[depth][from] = new_value;\n\t\t\t\t++from;\n\t\t\t}\n\t\t\tif (to % 2 == 0) {\n\t\t\t\tmake_upper_undefined(to / 2, depth + 1);\n\t\t\t\t_array[depth][to] = new_value;\n\t\t\t\t--to;\n\t\t\t}\n\t\t\tfrom >>= 1; to >>= 1; ++depth;\n\t\t}\n\t\tif (from == to) {\n\t\t\tmake_upper_undefined(from / 2, depth + 1);\n\t\t\t_array[depth][from] = new_value;\n\t\t}\n\t}\n\tint find(int pos) const {\n\t\tfor (auto i = _array.size() - 1; i >= 0; --i) {\n\t\t\tswitch (_array[i][pos >> i]) {\n\t\t\tcase undefined: continue;\n\t\t\tdefault: return _array[i][pos >> i];\n\t\t\t}\n\t\t}\n\t}\n};\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tauto stree = SegmentTree(n);\n\tint query, s, t, x, i;\n\tfor (auto count = 0; count < q; ++count) {\n\t\tstd::cin >> query;\n\t\tswitch (query) {\n\t\tcase 0:\n\t\t\tstd::cin >> s >> t >> x;\n\t\t\tstree.update(s, t, x);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cin >> i;\n\t\t\tstd::cout << stree.find(i) << std::endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <queue>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> Pii;\n\nconst ll mod = 1000000007;\n\ntemplate <class T>\nstruct prop_segtree {\n  int n;\n  vector<T> data;\n  vector<bool> propFlag;\n\n  prop_segtree(const int s) {\n    init(s);\n  }\n\n  prop_segtree(const int s, const T u) {\n    init(s);\n    for (int i = 0; i < s; i++) {\n      data[i+n-1] = u;\n    }\n    for (int i = n-2; i >= 0; i--) {\n      data[i] = 0;\n    }\n  }\n\n  prop_segtree(const vector<T> &v) {\n    int s = v.size();\n    init(s);\n    for (int i = 0; i < s; i++) {\n      data[i+n-1] = v[i];\n    }\n    for (int i = n-2; i >= 0; i--) {\n      data[i] = 0;\n    }\n  }\n\n  void init(const int s) {\n    n = 1;\n    while (n < s) n <<= 1;\n    data = vector<T>(2*n-1);\n    propFlag = vector<bool>(2*n-1);\n  }\n\n  void propagate(int p, int a, int b) {\n    if (propFlag[p]) {\n      if (b - a > 1) {\n        data[p*2+1] = data[p];\n        data[p*2+2] = data[p];\n        propFlag[p*2+1] = true;\n        propFlag[p*2+2] = true;\n        data[p] = 0;\n      }\n      propFlag[p] = false;\n    }\n  }\n\n  void update(int l, int r, T v, int p = 0, int a = 0, int b = -1) {\n    if (b < 0) b = n; // init\n\n    // propagate value\n    propagate(p, a, b);\n\n    if (r <= a || b <= l) return; // out of range\n    if (l <= a && b <= r) { // fully covered\n      data[p] = v;\n      propFlag[p] = true;\n      propagate(p, a, b);\n    }\n    else {\n      update(l, r, v, p*2+1, a, (a + b) / 2); // left\n      update(l, r, v, p*2+2, (a + b) / 2, b); // right\n    }\n    return;\n  }\n\n  T query(int x, T p = 0, int a = 0, int b = -1) {\n    if (b < 0) b = n; // init\n\n    // propagate value\n    propagate(p, a, b);\n\n    if (b - a == 1) return data[p];// reached to bottom\n\n    if (x < (a + b) / 2) return query(x, p*2+1, a, (a + b) / 2); // left\n    else return query(x, p*2+2, (a + b) / 2, b); // right\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n  vector<vector<int> > query(q, vector<int>(4));\n  for (int i = 0; i < q; i++) {\n    cin >> query[i][0] >> query[i][1];\n    if (query[i][0] == 0) cin  >> query[i][2] >> query[i][3];\n  }\n\n  prop_segtree<int> pst(n, 0x7fffffff);\n  vector<ll> ans;\n  for (int i = 0; i < q; i++) {\n    if (query[i][0] == 0) { // update\n      pst.update(query[i][1], query[i][2]+1, query[i][3]);\n    }\n    else { // get\n      ans.push_back(pst.query(query[i][1]));\n    }\n  }\n\n  for (auto &x: ans) cout << x << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[105000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\tint k = node;\n\t\tint ope;\n\t\tif (node % 2 == 0)ope = 0;\n\t\telse ope = 1;\n\n\t\tnode /= 2;\n\t\twhile (node > 0) {\n\t\t\tif (ope == 0)m[2 * node + 1] = m[node];\n\t\t\telse m[2 * node] = m[node];\n\t\t\tm[node] = -INF;\n\t\t\tif (node % 2 == 0)ope = 0;\n\t\t\telse ope = 1;\n\t\t\tnode /= 2;\n\t\t}\n\t\treturn;\n\t}\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{\n\tcin >> n >> q;\n\n\tn=init(n);\n\tint a, s, t, x;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> i;\n\t\t\tcout << find(i) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass SegTree{\nprivate:\n  int n;\n  // 1-index (tree[0] is dummy), leaves are tree[n]-tree[2n-1]\n  vector<int> tree;\n  const int defVal = 2147483647;\npublic:\n  SegTree(int _n){\n    int t;\n    t = 1;\n    while (t<_n) t*=2;\n    n = t;\n    tree = vector<int>(2*n, defVal);\n    //cerr << \"finish init\" << endl;\n    //cerr << \"tree size is \" << 2*n << endl;\n  }\n  // stab function\n  void update(int l, int r, int x){ return _update(l,r,x,1,0,n);}\n  void _update(int l, int r, int x, int k, int kl, int kr){\n//    cerr << \"update: \"<<l<<\" \"<<r<<\" \"<<x<<\" \"<<k<<\" \"<<kl<<\" \"<<kr<<endl;\n    if (kr<=l || r<=kl) return;\n    else if (l<=kl && kr<=r){\n      tree[k] = x;\n      return;\n    } else {\n      if (tree[k]!=defVal){\n        tree[k*2]=tree[k]; tree[k*2+1]=tree[k];\n        tree[k]=defVal;\n      }\n      _update(l,r, x, k*2, kl,(kl+kr)/2);\n      _update(l,r, x, k*2+1, (kl+kr)/2,kr);\n    }\n  }\n  int find(int i){\n    return _find(i,1,0,n);\n  }\n  int _find(int i, int k, int kl, int kr){\n//    cerr << \"find: \"<<i<<\" \"<<k<<\" \"<<kl<<\" \"<<kr<<endl;\n    if (k>=n || tree[k]!=defVal) return tree[k];\n    if (i<(kl+kr)/2) return _find(i, k*2, kl,(kl+kr)/2);\n    else return _find(i, k*2+1, (kl+kr)/2,kr);\n  }\n  // debug\n  void print(){\n    cerr << \"debug: \";\n    for (int i=1; i<2*n; i++){\n      if (i==n) cout << \"| \";\n      if (tree[i]==defVal) cout << \"DV \";\n      else cout << tree[i] << \" \";\n    }\n    cout << endl;\n  }\n};\n\nint main(void){\n  int n,q;\n  SegTree *st;\n  \n  cin >> n >> q;\n  st = new SegTree(n);\n  for (int i=0; i<q; i++){\n    int c,s,t,x,id;\n    cin >> c;\n    if (c==0){\n      cin >> s >> t >> x;\n      st->update(s,t+1,x);\n    }\n    else if (c==1){\n      cin >> id;\n      cout << st->find(id) << endl;\n    }\n    else cout << \"illegal command\" << endl;\n    //st->print();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n\nint bucket[MAX/B][B];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && data[a/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n\t\t\tf1 = 0;data[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != 99){\n\t\tif(f2 && data[b/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n\t\t\tf2 = 0;data[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tdata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(data[x/B] != -1){\n\t\tfor(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n\t\tdata[x/B] = -1;\n\t}\n\tprintf(\"%d %d\\n\", x/B, x%B);\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(data, data+MAX/B, -1);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nconst int MAX_N = 1 << 17;\nconst int LAZY_INIT = -1;\nconst int VAL_INIT = INT_MAX;\nint N = 1;\nint mini[MAX_N*2], lazy[MAX_N*2];\n\nvoid init(int n_){\n\twhile(N < n_){\n\t\tN *= 2;\n\t}\n\tfor(int i = 0; i < N*2 - 1; ++i){\n\t\tlazy[i] = LAZY_INIT;\n\t\tmini[i] = VAL_INIT;\n\t}\n}\n\nvoid setLazy(int k, int v){\n\tlazy[k] = v;\n\tmini[k] = v;\n}\n\nvoid push(int k){\n\tif(lazy[k] == LAZY_INIT){\n\t\treturn;\n\t}\n\tsetLazy(k*2+1, lazy[k]);\n\tsetLazy(k*2+2, lazy[k]);\n\tlazy[k] = LAZY_INIT;\n}\n\nvoid fix(int k){\n\tmini[k] = min(mini[k*2+1], mini[k*2+2]);\n}\n\nvoid fill(int qL, int qR, int val, int k=0, int nL=0, int nR=N){\n\tif(nR<=qL || qR<=nL){\n\t\treturn;\n\t}\n\tif(qL<=nL && nR<=qR){\n\t\tsetLazy(k, val);\n\t\treturn;\n\t}\n\tpush(k);\n\tint nM = (nL+nR)/2;\n\tfill(qL, qR, val, k*2+1, nL, nM);\n\tfill(qL, qR, val, k*2+2, nM, nR);\n\tfix(k);\n}\n\nint minimum(int qL, int qR, int k=0, int nL=0, int nR=N){\n\tif(qR<=nL || nR <=qL){\n\t\treturn VAL_INIT;\n\t}\n\tif(qL<=nL && nR<=qR){\n\t\treturn mini[k];\n\t}\n\tpush(k);\n\tint nM = (nL+nR)/2;\n\tint vl = minimum(qL, qR, k*2+1, nL, nM);\n\tint vr = minimum(qL, qR, k*2+2, nM, nR);\n\treturn min(vl, vr);\n}\n\nvoid print(){\n\tcout << \"mini: \";\n\trep(i, 0, N-1+N){\n\t\tcout << mini[i] << \",\";\n\t}\n\tcout << endl;\n\tcout << \"lazy: \";\n\trep(i, 0, N-1+N){\n\t\tcout << lazy[i] << \",\";\n\t}\n\tcout << endl;\n}\n\nint n, q;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/AtCoder/jni/in.txt\");\n\tcin >> n >> q;\n\tinit(n);\n\trep(query_index, 0, q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(com==0){\n\t\t\tint s,t,x;\n\t\t\tcin >> s >> t >> x;\n\t\t\t//print();\n\t\t\tfill(s, t+1, x);\n\t\t\t//dbp4(N, s,t,x);\n\t\t\t//print();\n\t\t\t//cout << endl;\n\t\t}else{\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << minimum(i, i+1) << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=(1LL<<31)-1;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nclass SquareDivision{\n    private:\n        const int bucketSize = 256;\n        ll N, B;\n        vector<ll> data;\n        vector<bool> lazyFlag;\n        vector<int> lazyUpdate;\n\n    public:\n        void prepare(int n){\n            B = (n + bucketSize - 1)/ bucketSize;\n            N = B * bucketSize;\n            data.assign(N, INF);\n            lazyFlag.assign(B, false);\n            lazyUpdate.assign(B, 0);\n        }\n\n        void eval(int k){\n            if(lazyFlag[k]){\n                lazyFlag[k] = false;\n                for(int i=k*bucketSize; i<(k+1)*bucketSize; i++){\n                    data[i] = lazyUpdate[k];\n                }\n            }\n        }\n\n        void update(int s, int t, int x){\n            for(int k=0; k<B; k++){\n                int l = k * bucketSize;\n                int r = (k + 1) * bucketSize;\n\n                if(r <= s || t <= l) continue;\n\n                if(s <= l && r <= t){\n                    lazyFlag[k] = true;\n                    lazyUpdate[k] = x;\n                }\n                else{\n                    eval(k);\n                    for(int i=max(s, l); i<min(t, r); i++){\n                        data[i] = x;\n                    }\n                }\n            }\n        }\n\n        int find(int i){\n            int k = i / bucketSize;\n            eval(k);\n            return data[i];\n        }\n};\n\nint main(){\n    int n, q; cin>>n>>q;\n    SquareDivision ans;\n    ans.prepare(n);\n\n    while(q--){\n        int c; cin>>c;\n        if(c == 0){\n            int s, t, x; cin>>s>>t>>x;\n            ans.update(s, t+1, x);\n        }\n        else{\n            int i; cin>>i;\n            cout << ans.find(i) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate<typename T, typename F> class SegmentTree\n{\n   private:\n      int n;\n      vector<T> node;\n      F f;\n   public:\n      SegmentTree(int sz, const F& func, T inf) : f(func) {\n         n = 1; while(n < sz) n *= 2;\n         node.resize(2*n-1, inf);\n      }\n      SegmentTree(const vector<T>& v, const F& func, T inf) : f(func) {\n         int sz = v.size();\n         n = 1; while(n < sz) n *= 2;\n         node.resize(2*n-1, inf);\n         for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n      }\n      void update(int a, int b, T val, int k=0, int l=0, int r=-1) {\n         // update [a,b)\n         if(r < 0) r = n;\n         if(r <= a || b <= l) return;\n         if(a <= l && r <= b) { node[k] = val; return; }\n         update(a, b, val, 2*k+1, l, (l+r)/2);\n         update(a, b, val, 2*k+2, (l+r)/2, r);\n      }\n      T find(int i) {\n         i += (n - 1);\n         T res = node[i];\n         while (i > 0) {\n            i = (i - 1) / 2;\n            res = f(res, node[i]);\n         }\n         return res;\n      }\n};\ntemplate<typename T> class RUQ\n{\n   private:\n      int t = 0;\n      SegmentTree<P<T,T>,function<P<T,T>(P<T,T>,P<T,T>)>> st;\n   public:\n      RUQ(int sz, T init) : st(sz, [](P<T,T> a,P<T,T> b){return max(a,b);}, MP(-INF,init)) {}\n      RUQ(const vector<T>& v, T init) : st(v.size(), [](P<T,T> a,P<T,T> b){return max(a,b);}, MP(-INF,init)) {\n         for (int i = 0; i < v.size(); i++) {\n            st.update(i,i+1,make_pair(-1,v[i]));\n         }\n      }\n      void update(int a, int b, T val) {\n         // update [a,b)\n         st.update(a,b,MP(t++,val));\n      }\n      T find (int i) {\n         return st.find(i).second;\n      }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q), id(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> id[i];\n      }\n   }\n\n   RUQ<int> ruq(n, (1LL<<31)-1);\n   REP(i, q) {\n      if (c[i] == 0) {\n         ruq.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << ruq.find(id[i]) << endl;\n      }\n   }\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <limits>\n\ntemplate <class Data, class Operator>\nclass CoSegmentTree {\n    using OperatorMerger = std::function<Operator(Operator, Operator)>;\n    using Applier = std::function<Data(Data, Operator)>;\n\npublic:\n    int length;\n    std::vector<Operator> ope;\n    Data dat_id;\n    Operator ope_id;\n    OperatorMerger opem;\n    Applier app;\n\n    explicit CoSegmentTree(int N, Data dat_id, Operator ope_id, OperatorMerger opem, Applier app)\n        : length(1), dat_id(dat_id), ope_id(ope_id), opem(opem), app(app) {\n        while (length < N) length *= 2;\n        ope.assign(length * 2, ope_id);\n    }\n\n    // half-open interval [ql, qr)\n    void update(int ql, int qr, Operator e) { return update(ql, qr, e, 1, 0, length); }\n\n    void update(int ql, int qr, Operator e, int nidx, int nl, int nr) {\n        if (nr <= ql || qr <= nl) return;\n        if (ql <= nl && nr <= qr) {\n            ope[nidx] = opem(ope[nidx], e);\n            return;\n        }\n        // 子に作用素を伝播\n        ope[nidx * 2] = opem(ope[nidx * 2], ope[nidx]);\n        ope[nidx * 2 + 1] = opem(ope[nidx * 2 + 1], ope[nidx]);\n        ope[nidx] = ope_id;\n        // 子を再帰的に更新\n        update(ql, qr, e, nidx * 2, nl, (nl + nr) / 2);\n        update(ql, qr, e, nidx * 2 + 1, (nl + nr) / 2, nr);\n    }\n\n    Data query(int idx) {\n        int nidx = idx + length;\n        Data ret = app(dat_id, ope[nidx]);\n        while (nidx > 0) {\n            nidx /= 2;\n            ret = app(ret, ope[nidx]);\n        }\n        return ret;\n    }\n};\n\nconst int INF = std::numeric_limits<int>::max();\n\nint main() {\n    int N, Q;\n    std::cin >> N >> Q;\n\n    CoSegmentTree<int, int> seg(N, INF, INF,\n                                [](int a, int b) { return (b == INF ? a : b); },\n                                [](int a, int e) { return (e == INF ? a : e); });\n\n    for (int q = 0; q < Q; ++q) {\n        int k;\n        std::cin >> k;\n        if (k == 0) {\n            int l, r, x;\n            std::cin >> l >> r >> x;\n            seg.update(l, r + 1, x);\n        } else {\n            int i;\n            std::cin >> i;\n            std::cout << seg.query(i) << std::endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include <stdio.h>\nusing namespace std;\ntypedef pair<int,int> p;\n#define TREE_N (1<<17)\n\nint c,n;\np tree[ TREE_N * 2 -1],ans;\n\nvoid update(int i,int x,int t){\n  i+=TREE_N-1;\n  if(t==-1)tree[i]=p(-1,x);\n  else ans=tree[i];\n  while(i>0){\n    i=(i-1)/2;\n    if(t==-1)tree[i]=p(t,x);\n    else ans=max(ans,tree[i]);\n  }\n}\n\nvoid rec(int t,int a,int b,int k=0,int l=0,int r=TREE_N){\n  if((l<a&&a<r)||(l<b&&b<r)){\n    int m=(l+r)/2;\n    rec(t,a,b,k*2+1,l,m);\n    rec(t,a,b,k*2+2,m,r);\n  }else if(a<=l&&r<=b){\n    tree[k]=p(t,c);\n  }\n}\n\n/*int Rec(int a,int b,int k=0,int l=0,int r=TREE_N){\n  if((l<a&&a<r)||(l<b&&b<r)){\n    int m=(l+r)/2;\n    int left = Rec(a,b,k*2+1,l,m);\n    int right = Rec(a,b,k*2+2,m,r);\n    return min(left,right);\n    \n  }else if(a<=l&&r<=b){\n    return tree[k];\n  }else{\n    return 2147483647;\n  }\n  }*/\n\nint main(){\n  int q,com,a,b;\n  cin>>n>>q;\n  for(int i=0;i<n;i++)update(i,2147483647,-1);\n  for(int i=0;i<q;i++){\n    cin>>com;\n    if(com){\n      cin>>a;\n      update(a,0,0);\n      cout<<ans.second<<endl;\n    }\n    else {\n      cin>>a>>b>>c;\n      rec(i,a,b+1);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define FOR(i,a,b) for (int i=(a),for_##i##_max=(b);i<=(for_##i##_max);++i)\n#define RFOR(i,a,b) for (int i=(a),rfor_##i##_min=(b);i>=(rfor_##i##_min);--i)\n#define REP(i,n) for (int i=0,rep_##i##_len=(n);i<(rep_##i##_len);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nnamespace { // Basics\n\ntemplate<typename T>\nvoid chmin(T &x, T y) {\n  x = std::min(x, y);\n}\n\ntemplate<typename T>\nvoid chmax(T &x, T y) {\n  x = std::max(x, y);\n}\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto minimum = static_cast<T const &(*)(T const &, T const &)>(std::min);\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto maximum = static_cast<T const &(*)(T const &, T const &)>(std::max);\n\ntemplate<typename T>\n__attribute__((unused))\nT constexpr infty = std::numeric_limits<T>::max / 3;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<int> = 1'100'100'100;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<long long int> = 100'500'400'300'200'100LL;\n\nusing lli = long long int;\nusing ld = long double;\n\n} // namespace\n\nusing namespace std;\n\ntemplate <typename T>\nstruct service {\n  int side;\n  vector<T> dat;\n  vector<T> init;\n  service(int n, T x): side(csqrt(n)), dat(side * side, x), init(side, x) {\n  }\n  void discard_init(int alpha) {\n    if (init[alpha] < 0) { return; }\n    for (int i = alpha * side; i < (alpha + 1) * side; ++i) {\n      dat[i] = init[alpha];\n    }\n    init[alpha] = -1;\n  }\n  void update(int s, int t, T x) {\n    discard_init(s / side);\n    discard_init(t / side);\n    int i = s;\n    while (i < t && i % side != 0) {\n      dat[i] = x;\n      ++i;\n    }\n    while (i + side <= t) {\n      init[i / side] = x;\n      i += side;\n    }\n    while (i <= t) {\n      dat[i] = x;\n      ++i;\n    }\n  }\n  T find(int i) {\n    if (init[i / side] >= 0) {\n      return init[i / side];\n    } else {\n      return dat[i];\n    }\n  }\n\n  static int csqrt(int n) {\n    int k = 1;\n    while (k * k < n) { ++k; }\n    return k;\n  }\n};\n\nint main() {\n\n  int N, Q;\n  cin >> N >> Q;\n  service<lli> srv(N+10, (1LL<<31)-1);\n  REP(query, Q) {\n    int T; cin >> T;\n    // cerr << stringify(srv.dat, srv.init, srv.side) << endl;\n    if (T == 0) {\n      lli S, T, X; cin >> S >> T >> X;\n      // cerr << \"query: update \" << stringify(S, T, X) << endl;\n      srv.update(S, T, X);\n    } else {\n      int I; cin >> I;\n      // cerr << \"query: find \" << I << endl;\n      // cerr << \"answer: \" << srv.find(I) << endl;\n      cout << srv.find(I) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint arr[100005 << 2], value[100005], n, q;\n\nvoid update(int a, int b, int x, int k = 0, int l = 0, int r = (1 << 17)) {\n\tif (b <= l || r <= a)return;\n\tif (a <= l && r <= b) {\n\t\tarr[k] = max(arr[k], x);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tupdate(a, b, x, k * 2 + 1, l, m);\n\tupdate(a, b, x, k * 2 + 2, m, r);\n}\n\nint query(int x) {\n\tx += (1 << 17) - 1;\n\tint res = arr[x];\n\twhile (x) {\n\t\tx = (x - 1) / 2;\n\t\tres = max(res, arr[x]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tqueue<int> r;\n\tvalue[0] = 2147483647;\n\tcin >> n >> q;\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint ch, a, b;\n\t\tcin >> ch;\n\t\tif (ch) {\n\t\t\tcin >> a;\n\t\t\tr.push(value[query(a)]);\n\t\t}\n\t\telse {\n\t\t\tcin >> a >> b >> value[i];\n\t\t\t++b;\n\t\t\tupdate(a, b, i);\n\t\t}\n\t}\n\twhile (!r.empty())\n\t{\n\t\tcout << r.front() << endl;\n\t\tr.pop();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/DSL2D.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\"\n#include <iostream>\n#line 1 \"segment_tree/dual_segment_tree.hpp\"\n\n\n\n#include <vector>\n#include <cstdint>\n\n//===\ntemplate<class Monoid>\nstruct DualSegmentTree {\n    using T = typename Monoid::value_type;\n    std::vector<T> lazy;\n\n    DualSegmentTree() = default;\n    explicit DualSegmentTree(uint32_t n):\n        lazy(n << 1, Monoid::identity()) {};\n\n    inline int size() {\n        return (int)(lazy.size() >> 1);\n    };\n    \n    inline void propagate(uint32_t k) {\n        if (k >= size()) return;\n        lazy[(k << 1) | 0] = Monoid::operation(lazy[(k << 1) | 0], lazy[k]);\n        lazy[(k << 1) | 1] = Monoid::operation(lazy[(k << 1) | 1], lazy[k]);\n        lazy[k] = Monoid::identity();\n    };\n    inline void push_down(uint32_t k) {\n        for (uint32_t i = 31; i > 0; i--) propagate(k >> i);\n    };\n \n    // [l, r)\n    void update(uint32_t l, uint32_t r, T op) {\n        l += size();\n        r += size();\n        push_down(l);\n        push_down(r);\n         \n        while (l < r) {\n            if (l & 1) lazy[l] = Monoid::operation(lazy[l], op), l++;\n            if (r & 1) --r, lazy[r] = Monoid::operation(lazy[r], op);\n \n            l >>= 1;\n            r >>= 1;\n        }\n    };\n \n    T operator [] (uint32_t k) {\n        k += size();\n        push_down(k);\n        return lazy[k];\n    };\n};\n//===\n\n\n#line 4 \"test/aoj/DSL2D.test.cpp\"\nusing namespace std;\nusing llong = long long;\n\nstruct RUQ {\n    using value_type = long long;\n    using T = value_type;\n\n    inline static T identity() {\n        return (1ll << 31) - 1;\n    };\n    inline static T operation(T a, T b) {\n        if (a == identity()) return b;\n        else if (b == identity()) return a;\n        else return b;\n    };\n};\n\nint main() {\n    llong n, q;\n    llong com;\n    llong s, t, x;\n    llong idx;\n\n    cin >> n >> q;\n    DualSegmentTree<RUQ> seg(n);\n    for (int i = 0; i < q; i++) {\n        cin >> com;\n\n        if (com == 0) {\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n        else if (com == 1) {\n            cin >> idx;\n            cout << seg[idx] << '\\n';\n        }\n    }\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct dualsegtree{\n\tfunction<T(T,T)>lazycalcfn,updatefn;\n\tint n;\n\tT lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tdualsegtree(int n_=0,T defvalue=0,\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>updatefn_=[](T a,T b){return a+b;},\n\t\tT lazydefvalue_=0\n\t):lazydefvalue(lazydefvalue_),\n\t\tlazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(n,defvalue);\n\t\tlazy.assign(n-1,lazydefvalue);\n\t\tlazyflag.assign(n-1,false);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i]=v[i];\n\t\tlazy.assign(n-1,lazydefvalue);\n\t\tlazyflag.assign(n-1,false);\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tif(k<n-1)\n\t\t\t{\n\t\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\t\tlazyflag[k]=true;\n\t\t\t}\n\t\t\telse dat[k-n+1]=updatefn(dat[k-n+1],x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(lazyflag[k])\n\t\t\t{\n\t\t\t\tupdate(0,n,lazy[k],k*2+1,l,(l+r)/2);\n\t\t\t\tupdate(0,n,lazy[k],k*2+2,(l+r)/2,r);\n\t\t\t\tlazy[k]=lazydefvalue;\n\t\t\t\tlazyflag[k]=false;\n\t\t\t}\n\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\tT query(int i)\n\t{\n\t\tT ret=dat[i];\n\t\ti+=n-1;\n\t\twhile(i>0)\n\t\t{\n\t\t\ti=(i-1)/2;\n\t\t\tif(lazyflag[i])ret=updatefn(ret,lazy[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tint N,Q;\n\tcin>>N>>Q;\n\tdualsegtree<int>P(N,(int)((1LL<<31)-1),\n\t\t[](int a,int b){return b;},[](int a,int b){return b;});\n\tfor(;Q--;)\n\t{\n\t\tint q;cin>>q;\n\t\tif(q==0)\n\t\t{\n\t\t\tint s,t,x;cin>>s>>t>>x;\n\t\t\tP.update(s,t+1,x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint i;cin>>i;cout<<P.query(i)<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RU {\n\tusing t1 = int;\n\tusing t2 = int;\n\tstatic t2 id2() { return -1; }\n\tstatic t1 op2(const t1& l, const t2& r) { return r == id2() ? l : r; }\n\tstatic t2 op3(const t2& l, const t2& r) { return r == id2() ? l : r; }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tconst vector<T1> data;\n\tvector<T2> lazy;\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tlazy[node << 1] = M::op3(lazy[node << 1], lazy[node]);\n\t\tlazy[(node << 1) | 1] = M::op3(lazy[(node << 1) | 1], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\npublic:\n\tlazy_segment_tree(int n_, T1 v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n_, v1), lazy(n << 1, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(data_), lazy(n << 1, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\tT1 find(int p) const {\n\t\tT1 res = data[p]; p += n;\n\t\twhile (p) res = M::op2(res, lazy[p]), p >>= 1;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tlazy_segment_tree<RU> lst(n, INT_MAX);\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tlst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tprintf(\"%d\\n\", lst.find(p));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n\ntypedef std::pair<int,int> TV; // Time and Value\n\nvoid update(TV* A, int s, int t, int index, int l, int r, int time, int val)\n{\n\tif (t<l || r<=s) return; // no intersection\n\telse if (s<=l && r<=t+1) { // [l,r) is contained in [s,t] \n\t\tA[index].first = time;\n\t\tA[index].second = val;\n\t\treturn;\n\t}\n\telse { // at least one end exceeds the range\n\t\tint mid = (l+r)/2;\n\t\tupdate(A, s, t, 2*index+1, l, mid, time, val);\n\t\tupdate(A, s, t, 2*index+2, mid, r, time, val);\n\t}\n}\n\nTV find(TV* A, int k, int index, int l, int r)\n{\n\tif (l+1==r) return A[index];\n\t\n\tint mid = (l+r)/2;\n\tTV res;\n\tif (k<mid) res = find(A, k, 2*index+1, l, mid);\n\telse res = find(A, k, 2*index+2, mid, r);\n\t\n\treturn (res.first > A[index].first) ? res : A[index];\n}\n\nint main ()\n{\n\tint n, q;\n\tstd::cin >> n >> q;\n\t\n\tint a_size = 1;\n\tfor(; a_size<n; a_size<<=1);\n\tTV* A = new TV[2*a_size-1];\n\tfor (int i=0; i<2*a_size-1; i++) {\n\t\tA[i].first = -1;\n\t\tA[i].second = INT_MAX;\n\t}\n\t\n\t\n\tfor (int i=0; i<q; i++) {\n\t\tint op, s, t, x, k;\n\t\tstd::cin >> op;\n\t\tif (op==0) {\n\t\t\tstd::cin >> s >> t >> x;\n\t\t\tupdate(A, s, t, 0, 0, n, i, x);\n\t\t} else {\n\t\t\tstd::cin >> k;\n\t\t\tstd::cout << find(A, k, 0, 0, n).second << std::endl;\n\t\t}\n\t}\n\t\n\tdelete[] A;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntemplate<class T>\nstruct LazySegTree {\n    // tree: data structure\n    // INF: initilize value\n    // f: update function(old, new)\n    // g: get function(parent, child1, child2)\n\n    T INF;\n    size_t N;\n    std::vector<T> tree, lazy;\n\n    std::function<T(T,T)> F;\n    std::function<T(T,T,T)> G;\n\n    LazySegTree(size_t size, T inf, std::function<T(T,T)> f, std::function<T(T,T,T)> g) {\n        INF = inf;\n        F = f;\n        G = g;\n\n        N = 1;\n        while( N < size ) {\n            N <<= 1;\n        }\n        tree.resize(2*N-1, INF);\n        lazy.resize(2*N-1, INF);\n    }\n\n    void lazyEval(size_t k, size_t l, size_t r) {\n        if(lazy[k] != INF) {\n            tree[k] = F(tree[k], lazy[k]);\n            if(r - l > 1) {\n                lazy[2*k+1] = F(lazy[2*k+1], lazy[k]);\n                lazy[2*k+2] = F(lazy[2*k+2], lazy[k]);\n            }\n            lazy[k] = INF;\n        }\n    }\n\n    void update(size_t a, size_t b, T x) {\n        update(a, b, x, 0, 0, N);\n    }\n    void update(size_t a, size_t b, T x, size_t k, size_t l, size_t r) {\n        lazyEval(k, l, r);\n        if( r <= a || b <= l ) return;\n        if( a <= l && r <= b ) {\n            lazy[k] = x;\n            lazyEval(k, l, r);\n        } else {\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            tree[k] = G(tree[k], tree[2*k+1], tree[2*k+2]);\n        }\n    }\n\n    T query(size_t a, size_t b) {\n        auto x = query(a, b, 0, 0, N);\n        return x;\n    }\n    T query(size_t a, size_t b, size_t k, size_t l, size_t r) {\n        lazyEval(k, l, r);\n        \n        if( r <= a || b <= l ) {\n            return INF;\n        }\n        if( a <= l && r <= b ) {\n            return tree[k];\n        } else {\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return G(tree[k], vl, vr);\n        }\n    }\n    T get(size_t i) {\n        return tree[i+N-1];\n    }\n\n    void debug() {\n        std::cout << \"------\" << std::endl;\n        if(tree[0] != INF) {\n            std::cout << \"(\" << tree[0] << \",\";\n        } else {\n            std::cout << \"(,\";\n        }\n        if(lazy[0] != INF) {\n            std::cout << lazy[0] << \")\" << std::endl;\n        } else {\n            std::cout << \")\" << std::endl;\n        }\n\n        size_t r = 0;\n        while(r < N-1) {\n            size_t ch = r*2+2;\n            FOR(i, r+1, ch+1) {\n                if(i != r+1) std::cout << \" \";\n                if(tree[i] != INF) {\n                    std::cout << \"(\" << tree[i] << \",\";\n                } else {\n                    std::cout << \"(,\";\n                }\n                if(lazy[i] != INF) {\n                    std::cout << lazy[i] << \")\";\n                } else {\n                    std::cout << \")\";\n                }\n            }\n            std::cout << std::endl;\n            r = ch;\n        }\n        std::cout << \"------\" << std::endl;\n    }\n};\n\nint n, q;\nint main() {\n    std::cin >> n >> q;\n    LazySegTree<long> st = LazySegTree<long>(n, (1LL<<31) - 1, [&](long a, long b){return b;}, [&](long p, long a, long b){return p;});\n    REP(i, q) {\n        int a;\n        std::cin >> a;\n        if(a == 0) {\n            size_t s, t;\n            long x;\n            std::cin >> s >> t >> x;\n            st.update(s, t+1, x);\n        } else {\n            size_t i;\n            std::cin >> i;\n            st.query(i, i+1);\n            std::cout << st.get(i) << std::endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nstruct segtree {\n    vector<int> lazy, dat;\n    int n;\n\n    segtree(int n_, int init){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.assign(n*2, init);\n        lazy.assign(n*2, -1);\n    }\n\n    void set(int l, int r, int x){\n        queue<tuple<int,int,int>> q;\n        q.emplace(0, n, 1);\n        while(q.size()){\n            int segl, segr, n;\n            tie(segl, segr, n) = q.front();\n            q.pop();\n            push(segl, segr, n);\n            if(segr <= l || r <= segl);\n            else if(l <= segl && segr <= r) lazy[n] = x;\n            else {\n                int segm = (segl + segr) / 2;\n                q.emplace(segl, segm, n*2);\n                q.emplace(segm, segr, n*2+1);\n            }\n        }\n        set(l, r, x, 0, n, 1);\n    }\n\n    void set(int l, int r, int x, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segr <= l || r <= segl);\n        else if(l <= segl && segr <= r) lazy[n] = x;\n        else {\n            int segm = (segl + segr) / 2;\n            set(l, r, x, segl, segm, n*2);\n            set(l, r, x, segm, segr, n*2+1);\n        }\n    }\n\n    int get(int k){\n        return get(k, 0, n, 1);\n    }\n\n    int get(int k, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segl + 1 == segr) return dat[n];\n        int segm = (segl + segr) / 2;\n        if(k < segm) return get(k, segl, segm, n*2);\n        else return get(k, segm, segr, n*2+1);\n    }\n\n    void push(int segl, int segr, int node){\n        if(lazy[node] != -1){\n            dat[node] = lazy[node];\n            if(segl + 1 != segr){\n                lazy[node*2] = lazy[node];\n                lazy[node*2+1] = lazy[node];\n            }\n            lazy[node] = -1;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, q;\n    cin >> n >> q;\n    segtree st(n, 2147483647);\n    for(int iq = 0; iq < q; ++iq){\n        int t;\n        cin >> t;\n        // dump(t);\n        if(t == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            st.set(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.get(i) << '\\n';\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 2147483647;\n\nstruct SegmentTree {\n    int n;\n    vector<int> heap;\n    vector<bool> isLazy;\n    \n    SegmentTree(int n): n(n) {\n        heap.assign(4 * n, INF);\n        isLazy.assign(4 * n, true);\n    }\n    \n    void update(int nodeId, int l, int r, int ql, int qr, int v) {\n        if (qr < l || ql > r) {\n            return;\n        }\n        else if (ql <= l && r <= qr) {\n            heap[nodeId] = v;\n            isLazy[nodeId] = true;\n        }\n        else {\n            pushdown(nodeId);\n            int m = l + (r - l)/2;\n            update(nodeId * 2, l, m, ql, qr, v);\n            update(nodeId * 2 + 1, m + 1, r, ql, qr, v);\n        }\n    }\n    \n    int query(int nodeId, int l, int r, int q) {\n        if (q < l || q > r) {\n            return -INF;\n        }\n        else if (isLazy[nodeId]) {\n            return heap[nodeId];\n        }\n        else {\n            int m = l + (r - l)/2;\n            return max(query(nodeId * 2, l, m, q), query(nodeId * 2 + 1, m + 1, r, q));\n        }\n    }\n    \n    void pushdown(int nodeId) {\n        //cout << \"push: \" << nodeId << endl;\n        if (isLazy[nodeId]) {\n            heap[nodeId * 2] = heap[nodeId];\n            isLazy[nodeId * 2] = true;\n            \n            heap[nodeId * 2 + 1] = heap[nodeId];\n            isLazy[nodeId * 2 + 1] = true;\n            \n            heap[nodeId] = -INF;\n            isLazy[nodeId] = false;\n        }\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int ql, qr, v;\n            cin >> ql >> qr >> v;\n            st.update(1, 0, n -1, ql, qr, v);\n//            for (int i = 0; i < 4 * n; i++) {\n//                cout << i << \":\" << st.heap[i] << endl; \n//            }\n        }\n        else {\n            int pos;\n            cin >> pos;\n            cout << st.query(1, 0, n-1, pos) << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<functional>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll INF = 1LL << 60;\n\ntemplate <typename T> struct AbstractMonoid {\n  T d;\n  static const T e;\n  AbstractMonoid(T d = e) : d(d) {}\n  void operator=(const T& x) { d = x; }\n  void operator=(const AbstractMonoid& x) { d = x.d; }\n  bool operator==(const AbstractMonoid& x) { return d == x.d; }\n};\n\nstruct AddMonoid : public AbstractMonoid<ll> {\n  static const ll e = 0LL;\n  AddMonoid(ll d = e) : AbstractMonoid<ll>(d) {}\n  void operator^=(const AddMonoid& x) { d = operator^(x).d; }\n  AddMonoid operator^(const AddMonoid& x) { return AddMonoid(x.d + d); }\n};\n\nstruct MinMonoid : public AbstractMonoid<ll> {\n  static const ll e = INF;\n  MinMonoid(ll d = e) : AbstractMonoid<ll>(d) {}\n  void operator^=(const MinMonoid& x) { d = operator^(x).d; }\n  MinMonoid operator^(const MinMonoid& x) { return MinMonoid(min(x.d, d)); }\n};\n\nstruct MaxMonoid : public AbstractMonoid<ll> {\n  static const ll e = -INF;\n  MaxMonoid(ll d = e) : AbstractMonoid<ll>(d) {}\n  void operator^=(const MaxMonoid& x) { d = operator^(x).d; }\n  MaxMonoid operator^(const MaxMonoid& x) { return MaxMonoid(max(x.d, d)); }\n};\n\nstruct SubstituteMonoid : public AbstractMonoid<ll> {\n  static const ll e = INF - 1;\n  SubstituteMonoid(ll d = e) : AbstractMonoid<ll>(d) {}\n  void operator^=(const SubstituteMonoid& x) { d = operator^(x).d; }\n  SubstituteMonoid operator^(const SubstituteMonoid& x) { return SubstituteMonoid(x.d); }\n};\n\nstruct VectorMonoid : public AbstractMonoid<vector<P>> {\n  static const vector<P> e;\n  VectorMonoid(vector<P> _d = e) : AbstractMonoid<vector<P>>(_d) { copy(_d.begin(), _d.end(), back_inserter(d)); }\n  void operator=(const vector<P>& x) { copy(x.begin(), x.end(), back_inserter(d)); }\n  void operator=(const VectorMonoid& x) { copy(x.d.begin(), x.d.end(), back_inserter(d)); }\n  VectorMonoid operator^(const VectorMonoid& x) {\n    vector<P> temp;\n    merge(d.begin(), d.end(), x.d.begin(), x.d.end(), back_inserter(temp));\n    return VectorMonoid(temp);\n  }\n};\n\n// SegmentTreeFunction\ntemplate <typename T> function<T(T, ll)> _segmentTreeIdentity = [](T t, ll num) { return t; };\n\ntemplate <typename T1, typename T2> function<T1(T1, T2)> _segmentTreeSubstitute = [](T1 y, T2 x) {\n  return x.d == x.e ? y : T1(x.d);\n};\n\n// SegmentTree\ntemplate <typename Monoid1, typename Monoid2>\nclass AbstractSegmentTree {\n  using F = function<Monoid2(Monoid1, ll)>;\n  ll n;\n  vector<Monoid1> data;\n  F f;\npublic:\n  AbstractSegmentTree(const vector<Monoid1>& _data, F f) : f(f) {\n    n = 1;\n    while ((ll)_data.size() > n) n *= 2;\n    data.resize(2*n);\n    for (ll i = 0; i < (ll)_data.size(); i++) data[n+i] = _data[i];\n    for (ll i = n-1; i > 0; i--) data[i] = data[2*i] ^ data[2*i+1];\n  }\n  Monoid1 at(ll num) { return data[n+num]; }\n  void add(ll num, Monoid1 x) {\n    num += n;\n    data[num] ^= x;\n    num /= 2;\n    while (num > 0) data[num] = data[2*num] ^ data[2*num+1], num /= 2;\n  }\n  void update(ll num, Monoid1 x) {\n    num += n;\n    data[num] = x;\n    num /= 2;\n    while (num > 0) data[num] = data[2*num] ^ data[2*num+1], num /= 2;\n  }\n  // [a, b)\n  Monoid2 query(ll a, ll b, ll num = 1, ll s = 0, ll t = -1) {\n    if (t == -1) t = n;\n    if (b <= s || t <= a) return Monoid2::e;\n    if (a <= s && t <= b) return f(data[num], num);\n    ll mid = (s + t) / 2;\n    return query(a, b, 2*num, s, mid) ^ query(a, b, 2*num+1, mid, t);\n  }\n};\n\ntemplate <typename Monoid>\nclass SegmentTree : public AbstractSegmentTree<Monoid, Monoid> {\npublic:\n  SegmentTree(const vector<Monoid>& _data) : AbstractSegmentTree<Monoid, Monoid>(_data, _segmentTreeIdentity<Monoid>) {}\n};\n\ntemplate <typename Monoid, typename Action>\nclass AbstractLazySegmentTree {\n  using F = function<Monoid(Monoid, Action)>;\n  using P = function<Action(Action, ll)>;\n  ll n;\n  F f;\n  P p;\n  vector<Monoid> data;\n  vector<Action> lazy;\npublic:\n  AbstractLazySegmentTree(const vector<Monoid>& _data, F f, P p = _segmentTreeIdentity<Action>) : f(f), p(p) {\n    n = 1;\n    while ((ll)_data.size() > n) n *= 2;\n    data.resize(2*n);\n    lazy.resize(2*n);\n    for (ll i = 0; i < (ll)_data.size(); i++) data[n+i] = _data[i];\n    for (ll i = n-1; i > 0; i--) data[i] = data[2*i] ^ data[2*i+1];\n  }\n  inline void eval(ll k, ll len) {\n    if (lazy[k] == Action::e) return;\n    if (2*k + 1 < 2*n) {\n      lazy[2*k] ^= lazy[k];\n      lazy[2*k + 1] ^= lazy[k];\n    }\n    data[k] = f(data[k], p(lazy[k], len));\n    lazy[k] = Action::e;\n  }\n  Monoid update(ll a, ll b, Action x, ll k = 1, ll l = 0, ll r = -1) {\n    if (r == -1) r = n;\n    eval(k, r-l);\n    if (r <= a || b <= l) return data[k];\n    if (a <= l && r <= b) {\n      lazy[k] ^= x;\n      return f(data[k], p(lazy[k], r-l));\n    }\n    ll mid = (l + r) / 2;\n    return data[k] = update(a, b, x, 2*k, l, mid) ^ update(a, b, x, 2*k+1, mid, r);\n  }\n  Monoid query(ll a, ll b, ll k = 1, ll l = 0, ll r = -1) {\n    if (r == -1) r = n;\n    eval(k, r-l);\n    if (r <= a || b <= l) return Monoid::e;\n    if (a <= l && r <= b) return data[k];\n    ll mid = (l + r) / 2;\n    return query(a, b, 2*k, l, mid) ^ query(a, b, 2*k+1, mid, r);\n  }\n};\n\nint main() {\n  ll n, q, com, s, t, x;\n  scanf(\"%lld%lld\", &n, &q);\n  vector<AddMonoid> am(n, (1LL<<31) - 1);;\n  AbstractLazySegmentTree<AddMonoid, SubstituteMonoid> sgt(am, _segmentTreeSubstitute<AddMonoid, SubstituteMonoid>);\n  for (ll i = 0; i < q; i++) {\n    scanf(\"%lld\", &com);\n    if (com == 0) {\n      scanf(\"%lld%lld%lld\", &s, &t, &x);\n      sgt.update(s, t+1, SubstituteMonoid(x));\n    } else {\n      scanf(\"%lld\", &x);\n      printf(\"%lld\\n\", sgt.query(x, x+1).d);\n    }\n  }\n}\n\n/*\nll n, q, x[500000], y[500000], sx[200000], tx[200000], sy[200000], ty[200000];\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nint main() {\n  scanf(\"%d\", &n);\n  Zip<ll> zip; zip.add(INF);\n  for (ll i = 0; i < n; i++) scanf(\"%d%d\", &x[i], &y[i]), zip.add(x[i]);\n  vector<VectorMonoid> d(zip.size());\n  for (ll i = 0; i < n; i++) d[zip.getNum(x[i])].d.push_back(P(y[i], i));\n  for (ll i = 0; i < zip.size() - 1; i++) sort(d[i].d.begin(), d[i].d.end());\n\n  ll a, b;\n  priority_queue<ll, vector<ll>, greater<ll>> ans;\n  function<Monoid(VectorMonoid, ll)> _vectorMonoidCount = [&](VectorMonoid t, ll num) {\n    VectorMonoid temp;\n    for (auto i = lower_bound(t.d.begin(), t.d.end(), P(a, -INF)), end = lower_bound(t.d.begin(), t.d.end(), P(b, -INF)); i != end; i++) {\n      ans.push(i->second);\n    }\n    return Monoid(0);\n  };\n\n  AbstractSegmentTree<VectorMonoid, Monoid> sgt(d, _vectorMonoidCount);\n  scanf(\"%d\", &q);\n  for (ll i = 0; i < q; i++) {\n    scanf(\"%d%d%d%d\", &sx[i], &tx[i], &sy[i], &ty[i]);\n    a = sy[i], b = ty[i] + 1;\n    sgt.query(zip.getNum(sx[i]), zip.getNum(tx[i]+1));\n    while (!ans.empty()) printf(\"%d\\n\", ans.top()), ans.pop();\n    printf(\"\\n\");\n  }\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst ll INF = (1LL << 31) - 1;\nstruct RUQ {\n  int N, K;\n  vector<ll> data;\n  vector<ll> lazyUpdate; // -1ならupdateしない\n  RUQ(int N): N(N) {\n    K = sqrt(N) + 1;\n    data.resize(K * K + 1, INF);\n    lazyUpdate.resize(K + 1, -1);\n  }\n\n  // kは分割した配列のindex\n  void evil(int k) {\n    if(lazyUpdate[k] != -1) {\n      for(int i = k * K; i < (k + 1) * K; i++) {\n        data[i] = lazyUpdate[k];\n      }\n      lazyUpdate[k] = -1;\n    }\n  }\n\n  // [s, t)\n  void update(int s, int t, int x) {\n    for(int k = 0; k < K; k++) {\n      int l = k * K, r = (k + 1) * K;\n      // 区間でない\n      if(r <= s || t <= l) continue;\n      // 完全に含まれている\n      if(s <= l && r <= t) {\n        lazyUpdate[k] = x;\n      } else {\n        evil(k);\n        for(int i = max(s, l); i < min(t, r); i++) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n\n  int find(int i) {\n    int k = i / K;\n    evil(k);\n    return data[i];\n  }\n};\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  RUQ ruq(n);\n  FOR(i,0,q) {\n    ll a,s,t,x;\n    cin>>a;\n    if(a){\n      cin>>s;\n      cout<<ruq.find(s)<<endl;\n    } else {\n      cin>>s>>t>>x;\n      ruq.update(s,t+1,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n    s_min = 100000;\n    t_max = 0;\n    m = 0;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){ cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){ cout << x[j] << endl; break; }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \n#define INF 2147483647\n#define ASTART (1<<17)\nint a[1<<18][2];\nint ti=1;\n \nint find(int i){\n  int nv=INF,t=0;\n  i+=ASTART-1;\n  nv=a[i][0];\n  t=a[i][1];\n  while (i>0){\n    i=(i-1)/2;\n    if (t<a[i][1])nv=a[i][0],t=a[i][1];\n    //cout << i << \" = \" << a[i][0]<< \" = \" << a[i][1]<< endl;\n  }\n  return nv;\n}\nvoid update(int s,int t,int x,int k,int l,int r){\n  if (l>s&&r<=t){\n    a[k][0]=x;\n    a[k][1]=ti;\n    return;\n  }\n  if (r<=s||l>=t)return;\n  int m=(l+r)/2;\n  update(s,t,x,k*2+1,l,m);\n  update(s,t,x,k*2+2,m,r);\n}\nint main(){\n  int n,q,com,s,t,x;\n  for (int i=0;i<(1<<18);i++)a[i][0]=INF,a[i][1]=0;\n  cin >> n>>q;\n \n  for (int i=0;i<q;i++){\n    cin >> com;\n    if (com==0) {\n      cin >> s >> t >> x;\n      update(s,t+1,x,0,0,ASTART);\n      ti++;\n    }else {\n      cin >> s;\n      cout << find(s)<< endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct OwnNode\n{\n\tint num;\n\tint l, r;\n\tOwnNode* left;\n\tOwnNode* right;\n\n\tOwnNode(int l,int r):l(l),r(r),num(2147483647),left(nullptr),right(nullptr){}\n\t\n\tvoid Build()\n\t{\n\t\tif (l + 1 == r)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tleft = new OwnNode(l, m);\n\t\tright = new OwnNode(m, r);\n\t\tleft->Build();\n\t\tright->Build();\n\t}\n\n\tvoid update(int s, int t, int v)\n\t{\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\tnum = v;\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tif (right != nullptr)\n\t\t{\n\t\t\tif (num >= 0)\n\t\t\t{\n\t\t\t\tright->num = num;\n\t\t\t}\n\t\t\tif (m < t)\n\t\t\t{\n\t\t\t\tright->update(s, t, v);\n\t\t\t}\n\t\t}\n\t\tif (left != nullptr)\n\t\t{\n\t\t\tif (num >= 0)\n\t\t\t{\n\t\t\t\tleft->num = num;\n\t\t\t}\n\t\t\tif (s < m)\n\t\t\t{\n\t\t\t\tleft->update(s, t, v);\n\t\t\t}\n\t\t}\n\t\tnum = -1;\n\t}\n\n\tint find(int s, int t)\n\t{\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn 2147483647;\n\t\t}\n\t\tif (num >= 0)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t\tint mini = 2147483647;\n\t\tint m = (l + r) / 2;\n\t\tif (right != nullptr)\n\t\t{\n\t\t\tif (m < t)\n\t\t\t{\n\t\t\t\tmini = min(mini, right->find(s, t));\n\t\t\t}\n\t\t}\n\t\tif (left != nullptr)\n\t\t{\n\t\t\tif (s < m)\n\t\t\t{\n\t\t\t\tmini = min(mini, left->find(s, t));\n\t\t\t}\n\t\t}\n\t\treturn mini;\n\t}\n};\n\nusing namespace std;\n\nOwnNode* root;\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\troot = new OwnNode(0, n);\n\troot->Build();\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\troot->update(s, t + 1, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << root->find(s, s+1) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\nusing namespace std;\n#define MAX make_pair(-1,INT_MAX)\nvector<pair<int,int> > ary;\nint n;\nint right(int k){\n  return 2*k+2;\n}\nint left(int k){\n  return 2*k+1;\n}\nint parent(int k){\n  return (k-1)/2;\n}\nvoid update(int s,int t,int p,pair<int,int> x,int l,int r){\n  if(r<=s||t<=l)return;\n  if(s<=l&&r<=t)ary[p]=x;\n  else{\n    update(s,t,left(p),x,l,(l+r)/2);\n    update(s,t,right(p),x,(l+r)/2,r);\n  }\n}\nint query(int x){\n  x+=n-1;\n  pair<int,int> res=ary[x];\n  //cout<<\"x:\"<<x<<endl;\n  while(x>0){\n    //cout<<\"query: \"<<x<<\" xf:\"<<ary[x].first<<\" x s:\"<<ary[x].second<<endl;\n    x=parent(x);\n    res=(res<ary[x])?ary[x]:res;\n  }\n  //cout<<\"query: \"<<x<<\" xf:\"<<ary[x].first<<\" xs:\"<<ary[x].second<<endl;\n\n  return res.second;\n}\n\nvoid find(int x){\n  cout<<query(x)<<endl;\n}\n\nint main(){\n  int m,q,com,s,t,x,i=0;\n  cin>>n>>q;\n  while(n>pow(2,i))i++;\n  n = pow(2,i);\n  m = n*2-1;\n  ary.resize(m*2);\n  for(int i=0;i<m*2;i++)ary[i] = MAX;\n  for(int i=0;i<q;i++){\n    cin>>com;\n    if(!com){\n      //cout<<\"in-\"<<i<<endl;\n      cin>>s>>t>>x;\n      update(s,t+1,0,make_pair(i,x),0,n);\n    }\n    else{\n      cin>>x;\n      find(x);\n      //cout<<\"in-\"<<i<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\nconst int INF = (1LL << 31) - 1;\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<bool> lazyFlag;\n  vector<int> lazyUpdate;\n  SqrtDecomposition(int n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, INF);\n    lazyFlag.assign(K, false);\n    lazyUpdate.assign(K, 0);\n  }\n  void eval(int k) {\n    if (lazyFlag[k]) {\n      lazyFlag[k] = false;\n      for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n    }\n  }\n  // [s, t)\n  void update(int s, int t, int x) {\n    for (int k = 0; k < K; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        lazyFlag[k] = true;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n  int find(int i) {\n    int k = i / sqrtN;\n    eval(k);\n    return data[i];\n  }\n};\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  int N, Q;\n  cin >> N >> Q;\n  SqrtDecomposition decomp(N);\n  while (Q--) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      decomp.update(s, t + 1, x);\n    } else {\n      int i;\n      cin >> i;\n      cout << decomp.find(i) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_INT 2147483647\nusing namespace std;\nint main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int>a(n,MAX_INT);\n  for(int i=0;i<q;i++){\n    int com;cin>>com;\n    if(com){\n      int i;\n      cin>>i;\n      cout<<a[i]<<endl;\n    }else{\n      int s,t,l;\n      cin>>s>>t>>l;\n      fill(a.begin()+s,a.begin()+t+1,l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\ntemplate<typename Monoid> class RangeActionSegTree {\n  using T = typename Monoid::value_type;\n\n  Monoid m;\n  vector<T> tree; // 1-indexed\n  int size = 1;\n\n  void push(int x) {\n    if (x <= 1) return;\n    push(x /= 2);\n    tree[x * 2] = m(tree[x * 2], tree[x]);\n    tree[x * 2 + 1] = m(tree[x * 2 + 1], tree[x]);\n    tree[x] = m.id();\n  }\n\npublic:\n  RangeActionSegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n  }\n\n  RangeActionSegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n    fill(tree.begin() + size, tree.end(), x);\n  }\n\n  template<typename InputIterator> RangeActionSegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, m.id());\n    copy(first, last, tree.begin() + size);\n  }\n\n  void act(int l, int r, const T &x) { // [l, r) += x\n    for (push(l += size), push((r += size) - 1); l < r; l /= 2, r /= 2) {\n      if (l & 1) tree[l] = m(tree[l], x), l++;\n      if (r & 1) r--, tree[r] = m(tree[r], x);\n    }\n  }\n\n  T operator[](int i) {\n    T acc = tree[i += size];\n    while (i /= 2) acc = m(acc, tree[i]);\n    return acc;\n  }\n};\n\ntemplate<typename T> struct updateMonoid {\n  using value_type = pair<bool, T>;\n  value_type id() { return {false, T()}; }\n  value_type operator()(const value_type &a, const value_type &b) { return b.first ? b : a; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  RangeActionSegTree<updateMonoid<int>> rast(n, {false, 2147483647});\n  while (q--) {\n    if (in()) {\n      int i;\n      cin >> i;\n      cout << rast[i].second << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      rast.act(s, t + 1, {true, x});\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <tuple>\n#include <stdio.h>\n#include <bitset>\n#include <limits.h>\n#include <complex>\n#include <deque>\n#include <iomanip>\n#include <list>\n#include <cstring>\nusing namespace std;\n#define pi pair<int,int>\n#define pl pair<long long,long long>\n#define chmax(a,b) (a<b ? a=b:0)\n#define chmin(a,b) (a>b ? a=b:0)\n#define en cout << endl //セミコロンつけろ\n//#define MM 1000000000\n//#define MOD MM+7\ntypedef long long ll;\n//const int MM = 1e9;\nconst int MOD = 1e9+7;\nconst long double PI = acos(-1);\nconst long long INF = 1e15;\nint dx[8] = {-1,0,1,0,-1,-1,1,1};\nint dy[8] = {0,-1,0,1,-1,1,1,-1};\n// 'A' = 65, 'Z' = 90, 'a' = 97, 'z' = 122\n// priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > pq;\n\ntemplate<typename T> //最大公約数\nT GCD(T u,T v){\n    return v ? GCD(v,u%v) : u;\n}\ntemplate<typename T> //最小公倍数\nT LCM(T x,T y){\n    T gc = GCD(x,y);\n    return x*y/gc;\n}\n\nconst int COM_MAX = 500500;\nlong long fac[COM_MAX],finv[COM_MAX],inv[COM_MAX];\nvoid init(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < COM_MAX; i++){\n        fac[i] = fac[i-1]*i%MOD;\n        inv[i] = MOD - inv[MOD%i]*(MOD/i)%MOD;\n        finv[i] = finv[i-1]*inv[i]%MOD;\n    }\n}\n\nlong long COM(int n,int k){\n    if(n < k || n < 0 || k < 0) return 0;\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n\n// a^n mod を計算する\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// a^{-1} mod を計算する\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\ntemplate<typename T> \nstruct RUQ\n{\n    // pos は全体のノードを表す配列\n    // lazy は遅延評価を行うための配列\n    vector< T > pos, lazy; \n    int maxLimit;\n    const ll MAXRUQ = 2147483647; // 2^31-1\n\n    void Init(int _n){\n        int limit = 1;\n        while (limit < _n){\n            limit *= 2;\n        }\n        maxLimit = limit;\n        pos.assign(limit * 2 + 1, MAXRUQ);\n        lazy.assign(limit*2 + 1, MAXRUQ);\n    }\n\n    void Evaluate(int k){\n        if (lazy[k] == MAXRUQ) return;\n        if (k < maxLimit - 1){\n            lazy[k*2 + 1] = lazy[k];\n            lazy[k*2 + 2] = lazy[k];\n        }\n\n        pos[k] = lazy[k];\n        lazy[k] = MAXRUQ;\n    }\n\n    // Updateを用いれば十分\n    void sub_Update(int a, int b, int x, int k, int left, int right){\n        Evaluate(k);\n        if (a <= left && right <= b){\n            lazy[k] = x;\n            Evaluate(k);\n        } else if (a < right && left < b){\n            sub_Update(a, b, x, k*2+1, left, (left+right) / 2);\n            sub_Update(a, b, x, k*2+2, (left+right) / 2, right);\n            pos[k] = min(pos[k*2+1], pos[k*2+2]);\n        }\n    }\n\n    // 区間更新\n    // [a, b) の値を x に更新する\n    void Update(int a, int b, int x){\n        sub_Update(a, b, x, 0, 0, maxLimit);\n    }\n\n\n    T sub_Query(int a, int b, int k, int left, int right){\n        Evaluate(k);\n        if (right <= a || b <= left){\n            return MAXRUQ;\n        } else if (a <= left && right <= b){\n            return pos[k];\n        } else {\n            T vl = sub_Query(a, b, k*2+1, left, (right+left) / 2);\n            T vr = sub_Query(a, b, k*2+2, (left+right) / 2, right);\n            return min(vl, vr);\n        }\n    }\n\n    T Query(int a, int b){\n        return sub_Query(a, b, 0, 0, maxLimit);\n    }\n};\n\n\nint main(){\n    int N, Q; cin >> N >> Q;\n    RUQ<ll> ruq;\n    ruq.Init(N);\n    vector<int> ans(0);\n    for (int i = 0; i < Q; i++){\n        int num; cin >> num;\n        if (num == 0){\n            ll s, t, x; cin >> s >> t >> x;\n            ruq.Update(s, t+1, x);\n        } else {\n            int i; cin >> i;\n            ans.push_back(ruq.Query(i, i+1));\n        }\n    }\n    for (int i = 0; i < ans.size(); i++){\n        if (ans[i] == ruq.MAXRUQ) cout << 2147483647 << endl;\n        else cout << ans[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nstruct SD\n{\n\tint n;\n\tint lsize;\n\tint sn;\n\tvector<int> data;\n\tvector<int> lazyData;\n\n\tSD(int n) :n(n), lsize(sqrt(n)), sn(n / lsize + 1), data(n, 2147483647), lazyData(sn, -1){}\n\n\tvoid applyLazy(int k)\n\t{\n\t\tif (lazyData[k] == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = k*lsize; i < (min(n, (k + 1)*lsize)); i++)\n\t\t{\n\t\t\tdata[i] = lazyData[k];\n\t\t}\n\t}\n\n\tvoid update(int t, int s, int v)\n\t{\n\t\tfor (int i = 0; i < sn; i++)\n\t\t{\n\t\t\tint l = i*lsize;\n\t\t\tint r = (i + 1)*lsize - 1;\n\n\t\t\tif (s < l || r < t)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (t <= l&&r <= s)\n\t\t\t{\n\t\t\t\tlazyData[i] = v;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplyLazy(i);\n\t\t\t\tfor (int j = t; j <= s; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[j] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int index)\n\t{\n\t\tint k = index / lsize;\n\t\tapplyLazy(k);\n\t\treturn data[index];\n\t}\n};\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tSD sd(n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tsd.update(s, t, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << sd.find(s) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = (1ll << 31) - 1;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T>\nstruct RangeUpdateQuery {\n\tint n;\n\tvector<int>d;\n\tRangeUpdateQuery(int m) {\n\t\tfor (n = 1; n < m; n <<= 1);\n\t\td.assign(2 * n, INF);\n\t}\n\tint find(int i) {\n\t\tupdate(i, i + 1);\n\t\treturn d[n + i];\n\t}\n\tvoid update(int a, int b, int x = -1, int k = 1, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\n\t\tif (r <= a || b <= l)return;\n\t\telse if (a <= l&&r <= b) {\n\t\t\tif (x >= 0)d[k] = x;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (d[k] != INF)d[2 * k] = d[2 * k + 1] = d[k], d[k] = INF;\n\t\t\tupdate(a, b, x, 2 * k, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) / 2, r);\n\t\t}\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tRangeUpdateQuery<int> ruq(n);\n\trep(i, 0, q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint x; cin >> x;\n\t\t\tcout << ruq.find(x) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <vector>\n#include <functional>\ntemplate<class T, class Lazy> struct LazySegTree {\n  private:\n  public:\n    int size;\n    vector<T> v; vector<Lazy> lazy;\n    vector<int> seg_size;\n    using F = function<T(T,T)>;\n    using G = function<Lazy(Lazy,Lazy)>;\n    using H = function<T(T,Lazy,int)>;\n    F f; G g; H h;\n    T default_value; Lazy default_lazy;\n  public:\n    LazySegTree(int n, T default_value, Lazy default_lazy, F f, G g, H h)\n      : default_value(default_value), default_lazy(default_lazy), f(f), g(g), h(h) {\n      size = 1;\n      while (size < n) size *= 2;\n\n      v.resize(2 * size - 1, default_value);\n      lazy.resize(4 * size - 1, default_lazy);\n      seg_size.resize(2 * size - 1, 1);\n\n      for (int i = 0; i < size - 1; ++i) {\n        int j = size - 2 - i;\n        seg_size[j] = seg_size[2 * j + 1] + seg_size[2 * j + 2];\n      }\n    }\n    void update(int index, T val) {\n      update(index, index+1, default_lazy);\n      index = index + size - 1;\n      v[index] = val;\n      while (index > 0) {\n        index = (index - 1) / 2;\n        v[index] = f(v[2 * index + 1], v[2 * index + 2]);\n      }\n    }\n    void eval(int index) {\n      v[index] = h(v[index], lazy[index], seg_size[index]);\n\n      lazy[2 * index + 1] = g(lazy[index], lazy[2 * index + 1]);\n      lazy[2 * index + 2] = g(lazy[index], lazy[2 * index + 2]);\n\n      lazy[index] = default_lazy;\n    }\n    T query(int l, int r) { return query(l, r, 0, size, 0); }\n    T query(int l, int r, int cur_l, int cur_r, int index) {\n      // [l, r)に対するクエリ\n      eval(index);\n      if (cur_r <= l || r <= cur_l) return default_value;\n      if (l <= cur_l && cur_r <= r) return v[index];\n\n      // 左右を見ていく\n      int mid = (cur_l + cur_r) / 2;\n      return f(\n          query(l, r, cur_l, mid, 2 * index + 1),\n          query(l, r, mid, cur_r, 2 * index + 2));\n    }\n    void update(int l, int r, Lazy x) { update(l, r, x, 0, size, 0); }\n    void update(int l, int r, Lazy x, int cur_l, int cur_r, int index) {\n      // [l, r)に対して操作する\n\n      eval(index);\n      if (cur_r <= l || r <= cur_l) return;\n      if (l <= cur_l && cur_r <= r) {\n        lazy[index] = x;\n        eval(index);\n        return;\n      }\n      // 左右を見ていく\n      int mid = (cur_l + cur_r) / 2;\n      update(l, r, x, cur_l, mid, 2 * index + 1);\n      update(l, r, x, mid, cur_r, 2 * index + 2);\n      v[index] = f(v[2 * index + 1], v[2 * index + 2]);\n    }\n};\n\n// // 範囲和\n// LazySegTree<long long, int> T(N, 0, 0,\n//     [](long long a, long long b) {return a + b;},\n//     [](int a, int b) {return a + b;},\n//     [](long long a, int b, int size) {return a + b * size;});\n// // chmin\n// LazySegTree<ll, ll> T(N, INF, -1,\n//     [](ll a, ll b) {return min(a, b);},\n//     [](ll a, ll b) { return a == -1 ? b : a;},\n//     [](ll a, ll lz, int size) {return lz == -1 ? a : lz;});\n\n#define in(v) v; cin >> v;\nvoid ins() {}\ntemplate<class T,class... Rest>void ins(T& v,Rest&... rest){cin>>v;ins(rest...);}\n#define rep(i,n) for(int i=0,_i=(n);i<_i;++i)\n\nint main() {\n  int in(N); int in(Q);\n\n  // 範囲和\n  LazySegTree<int, int> T(N, 2147483647, -1,\n      [](int a, int b) {return min(a, b);},\n      [](int par_lz, int lz) {return par_lz == -1 ? lz : par_lz;},\n      [](int a, int lz, int size) {return lz == -1 ? a : lz;});\n\n  rep(i, Q) {\n    int com;\n    ins(com);\n\n    if (com == 0) {\n      int s, t, x;\n      ins(s, t, x);\n      ++t;\n      T.update(s, t, x);\n    } else {\n      int in(idx);\n      cout << T.query(idx, idx+1) << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <functional>\n#include <vector>\n\n// < 双対セグメント木クラス >\n// @ 概要 | 区間更新・点取得が高速に行える O(logN)\n// @ 要件 | monoid_type : 1, using value_type = oo; の形が記述されている等、用いる型にアクセス可能なこと\n//                       2, staticメンバ変数として単位元 identity_element が定義されていること\n//                       3, static関数 operation が定義されており, かつ以下の条件を満たすこと\n//                           (i) (元の値, 更新オペレータ) →　新しい値を返す\n//                           (ii) f(x, f(y, z)) = f(f(x, y), z)\ntemplate <class monoid_type> class dualSegmentTree{\nprivate:\n    using element_t = typename monoid_type::value_type;   // 要素の型 (渡した型に依存する)\n    const unsigned int original_length;                   // 元の配列の長さ : A.size()\n    const unsigned int height;                            // 配列の要素の数の指数部 : k\n    const unsigned int length;                            // 配列の要素の数 : 2^k (2のべき乗)\n    std::allocator<element_t> alloc;                      // データのアロケータ\n    element_t* data;                                      // 格納しているデータ(配列)本体(を指すポインタ)\n\n    static unsigned int set_log_len(const unsigned int n){ unsigned int res = 0; while((1U << res) < n) ++res; return res; }\n    inline void propagate(unsigned int idx){\n        for(unsigned int i = height, jp, jc; i ; --i){\n            jp = idx >> i; jc = jp << 1;\n            if(data[jp] == monoid_type::identity_element) continue;\n            data[jc | 0] = monoid_type::operation(data[jc | 0], data[jp]);\n            data[jc | 1] = monoid_type::operation(data[jc | 1], data[jp]);\n            data[jp    ] = monoid_type::identity_element;\n        }\n    }\npublic:\n    dualSegmentTree(const unsigned int n): original_length(n), height(set_log_len(n)), length(1U << height){\n        data = alloc.allocate(length << 1); std::fill(data, data + (length << 1), monoid_type::identity_element);\n    }\n    template <class InputIterator>\n    dualSegmentTree(InputIterator first, InputIterator last):original_length(last - first), height(set_log_len(original_length)), length(1U << height){\n        data = alloc.allocate(length << 1); std::fill(data, data + length, monoid_type::identity_element);\n        std::copy(first, last, data + length); std::fill(data + length + original_length, data + (1U << height), monoid_type::identity_element);\n    }\n    ~dualSegmentTree(void){ alloc.deallocate(data, (length << 1)); }\n\n    // 区間更新 : O(logN)\n    inline void update(unsigned int l, unsigned int r, const element_t& op){\n        propagate(l += length); propagate((r += length) - 1);\n        while(l < r){\n            if(l & 1){ data[l] = monoid_type::operation(data[l], op); l++; }\n            if(r & 1){ --r; data[r] = monoid_type::operation(data[r], op); }\n            l >>= 1; r >>= 1;\n        }\n    }\n\n    // 点更新\n    inline void update_at(unsigned int idx, const element_t& op){\n        propagate(idx += length); data[idx] = monoid_type::operation(data[idx], op);\n    }\n\n    // 点取得 : 計算量 O(logN)\n    inline element_t operator [](unsigned int idx) const {\n        element_t res = data[idx += length]; while(idx >>= 1) res = monoid_type::operation(res, data[idx]);\n        return res;\n    }\n    inline element_t at(unsigned int idx) const {\n        assert(idx < original_length);\n        element_t res = data[idx += length]; while(idx >>= 1) res = monoid_type::operation(res, data[idx]);\n        return res;\n    }\n};\n\nstruct RangeAdder{\n    using value_type = unsigned int;\n    static const value_type identity_element = 2147483647;\n    static constexpr value_type operation(const value_type& x, const value_type& y){\n        return (y == identity_element) ? x : y;\n    }\n};\n\n\nint main(void){\n    std::cin.tie(nullptr); std::cin.sync_with_stdio(false);\n    std::cout.tie(nullptr); std::cout.sync_with_stdio(false);\n    unsigned int n, q; std::cin >> n >> q;\n    dualSegmentTree<RangeAdder> R(n);\n    for(unsigned int i = 0; i < q; ++i){\n        char c; std::cin >> c;\n        if(c == '1'){ unsigned int idx; std::cin >> idx; std::cout << R[idx] << '\\n'; }\n        else { unsigned int l, r, x; std::cin >> l >> r >> x; R.update(l, r + 1, x); }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            //if(i < s_min || i > t_max){\n            //    A[i] = INT_MAX;\n            cout << A[i] << endl;\n            //}else{\n            //    for(j = m; j >= 0; j--){\n            //        if(s[j] <= i && t[j] >= i){\n            //            A[i] = x[j];\n            //            cout << A[i] << endl;\n            //            break;\n            //        }\n            //    }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RU {\n\tusing t1 = int;\n\tusing t2 = int;\n\tstatic t2 id2() { return -1; }\n\tstatic t1 op2(const t1& l, const t2& r) { return r == id2() ? l : r; }\n\tstatic t2 op3(const t2& l, const t2& r) { return r == id2() ? l : r; }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tconst vector<T1> data;\n\tvector<T2> lazy;\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tlazy[node << 1] = M::op3(lazy[node << 1], lazy[node]);\n\t\tlazy[(node << 1) | 1] = M::op3(lazy[(node << 1) | 1], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\npublic:\n\tlazy_segment_tree(int n_, T1 v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n_, v1), lazy(n << 1, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(data_), lazy(n << 1, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\tT1 find(int p) {\n\t\tT1 res = data[p]; p += n;\n\t\twhile (p) res = M::op2(res, lazy[p]), p >>= 1;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tlazy_segment_tree<RU> lst(n, INT_MAX);\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tlst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tprintf(\"%d\\n\", lst.find(p));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nstruct range_update_point_value{\n\tint N;\n\tvector<pair<T, int>> ST;\n\tint t;\n\trange_update_point_value(int n){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<pair<T, int>>(N * 2 - 1, make_pair(0, 0));\n\t\tt = 1;\n\t}\n\trange_update_point_value(int n, T x){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<pair<T, int>>(N * 2 - 1, make_pair(0, 0));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tST[N - 1 + i] = make_pair(x, 1);\n\t\t}\n\t\tt = 2;\n\t}\n\trange_update_point_value(vector<T> A){\n\t\tint n = A.size();\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<pair<T, int>>(N * 2 - 1, make_pair(0, 0));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tST[N - 1 + i] = make_pair(A[i], 1);\n\t\t}\n\t\tt = 2;\n\t}\n\tT operator [](int k){\n\t\tk += N - 1;\n\t\tT ans = ST[k].first;\n\t\tT time = ST[k].second;\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tif (ST[k].second > time){\n\t\t\t\tans = ST[k].first;\n\t\t\t\ttime = ST[k].second;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid update(int L, int R, T x, int i, int l, int r){\n\t\tif (R <= l || r <= L){\n\t\t\treturn;\n\t\t} else if (L <= l && r <= R){\n\t\t\tST[i] = make_pair(x, t);\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\tupdate(L, R, x, i * 2 + 1, l, m);\n\t\t\tupdate(L, R, x, i * 2 + 2, m, r);\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x){\n\t\tupdate(L, R, x, 0, 0, N);\n\t\tt++;\n\t}\n};\nint main(){\n  int n, q;\n  cin >> n >> q;\n  range_update_point_value<int> a(n, 2147483647);\n  for (int c = 0; c < q; c++){\n    int T;\n    cin >> T;\n    if (T == 0){\n      int s, t, x;\n      cin >> s >> t >> x;\n      a.range_update(s, t + 1, x);\n    }\n    if (T == 1){\n      int i;\n      cin >> i;\n      cout << a[i] << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\tDSL: domain-specific language\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/5/2017\n\tTLE: 17/22 10^10 must change the data structure--> binary tree\n\tupdate the data: set the priority\n\tWA 2/22\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 131072 //100000\n#define MAXVAL ((long int) ((unsigned long) (1 << 31) - 1))\ntypedef struct Node{\n\tint val;\n\tint priority;\n}node;\nvoid find(int i);\nvoid add(int s,int t, int x,int i);\nnode array[2*N+100];      //the size of array, for present the tree\n//BEGIN FROM 1;\nint main(){\n\tint n = 0, q = 0;\n\tint a,b,c;\n\t//FILE *fp;\n\t//fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\t\n\t//how to calculate the beginning index (the last layer of the tree)\n\tint count = 0;\n\tint temp = n;\n\twhile(n!=1){\n\t\tn = n/2;\n\t\tcount++;  \n\t}\n\tif(pow(2,count)!=temp) count++;\n\t//printf(\"count:%d\",count);\n\tint B = pow(2,count)-1;\n\tfor(int i = 0; i<=B;i++){ //special case forn==1, need i = 0;\n\t\tarray[i].val =  MAXVAL;\n\t\tarray[i].priority = 0;\n\t}\n\tfor(int i = 1; i<=n; i++){\n\t\tarray[i+B].val = MAXVAL;\t//e.g.begin from 8 (the last element of previous layer is 7)\n\t\tarray[i].priority = 0;\n\t}//printf(\"%d\\n\", array[B].val);\n\tfor(int i = 0; i < q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tadd(a+B,b+B,c,i);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfind(a+B);\n\t\t}\n\t}\n\treturn 0;\n}\n//add elements\n//s means: left pointer\n//t means : right pointer\nvoid add(int s,int t, int x,int i){\n\t//signle node\n\tif(s==t) {\n\t\tarray[s].val = x;\n\t\tarray[s].priority = i;\n\t\treturn;\n\t}\n\t//range update\n\t//check the left pointer\n\twhile(s<t){\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t\tif(s%2==0){ //left child, level up\n\t\t\ts = s/2;\n\t\t}else{ //right child: mark and level up + 1\n\t\t\tarray[s].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\ts = s/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tif(t%2==0){//left child: \n\t\t\tarray[t].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\tt = t/2;\n\t\t\tt--;\n\t\t} else { //right child\n\t\t\tt/= 2; \t\n\t\t}\n\t\tif(s==t) {\n\t\t\tarray[s].val =x;\n\t\t\tarray[s].priority = i;\n\t\t}// works for 1-4,1-3, 1-5\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t}\n\t\n\t//test for \n\t/*for(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", i);\n\t}printf(\"\\n\");\n\tfor(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", array[i]);\n\t}*/\n\t\n}\n\nvoid find(int i) {//the index of the tree\n\tint res = array[i].val;\n\tint max = 0; //the priority\n\t//printf(\"%d\\n\", array[i].val);\n\twhile(i>=1){\n\t\tif(array[i].priority>max){\n\t\t\tres=array[i].val;\n\t\t\t//printf(\"array:%d\",res);\n\t\t\tmax = array[i].priority;\t\n\t\t}\n\t\ti = i/2;\n\t}\n\t\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int INF=2147483647;\nstruct segment_tree{\n    int map[2000010];\n    void build(int now,int l,int r){\n        if(l==r){\n            map[now]=INF;\n            return;\n        }\n        map[now]=-1;\n        int mid=(l+r)/2;\n        build(now*2+1,l,mid);\n        build(now*2+2,mid+1,r);\n        return ;\n    }\n    void change(int n,int now,int L,int R,int l,int r){\n        if(R<l||L>r)return;\n        if(L>=l&&R<=r){\n            map[now]=n;\n            return;\n        }\n        if(map[now]!=-1){\n            map[now*2+1]=map[now*2+2]=map[now];\n            map[now]=-1;\n        }\n        int mid=(L+R)/2;\n        change(n,now*2+1,L,mid,l,r);\n        change(n,now*2+2,mid+1,R,l,r);\n        return ;\n    }\n    int find(int now,int L,int R,int n){\n        if(L==R)return map[now];\n        if(map[now]!=-1){map[now*2+1]=map[now*2+2]=map[now];\n            int temp=map[now];\n            map[now]=-1;\n            return temp;\n        }\n        int mid=(L+R)/2;\n        if(mid>=n)return find(now*2+1,L,mid,n);\n        else return find(now*2+2,mid+1,R,n);\n    }\n};\nint main(){\n    int n,m,k,l,r;\n    segment_tree arr;\n    scanf(\"%d%d\",&n,&m);\n    arr.build(0,0,n-1);\n    while(m--){\n        scanf(\"%d\",&k);\n        if(k==0){\n            scanf(\"%d%d%d\",&l,&r,&k);\n            arr.change(k,0,0,n-1,l,r);\n        }\n        else {\n            scanf(\"%d\",&k);\n            printf(\"%d\\n\",arr.find(0,0,n-1,k));\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<int> tp(Q), s(Q), t(Q), x(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tscanf(\"%d%d\", &tp[i], &s[i]);\n\t\tif (tp[i] == 0) scanf(\"%d%d\", &t[i], &x[i]), t[i]++;\n\t}\n\tvector<int> d(N, 2147483647);\n\tint B = sqrt(Q);\n\tfor (int i = 0; i < B; i++) {\n\t\tint l = 1LL * i * Q / B, r = 1LL * (i + 1) * Q / B;\n\t\tfor (int j = l; j < r; j++) {\n\t\t\tif (tp[j] == 1) {\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int k = j - 1; k >= l; k--) {\n\t\t\t\t\tif (tp[k] == 0 && s[k] <= s[j] && s[j] < t[k]) {\n\t\t\t\t\t\tprintf(\"%d\\n\", x[k]); flag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) printf(\"%d\\n\", d[s[j]]);\n\t\t\t}\n\t\t}\n\t\tvector<int> cp = { 0, N };\n\t\tfor (int j = l; j < r; j++) {\n\t\t\tif (tp[j] == 0) {\n\t\t\t\tcp.push_back(s[j]);\n\t\t\t\tcp.push_back(t[j]);\n\t\t\t}\n\t\t}\n\t\tsort(cp.begin(), cp.end());\n\t\tcp.erase(unique(cp.begin(), cp.end()), cp.end());\n\t\tvector<int> f(cp.size() - 1, -1);\n\t\tfor (int j = l; j < r; j++) {\n\t\t\tif (tp[j] == 0) {\n\t\t\t\tint pl = lower_bound(cp.begin(), cp.end(), s[j]) - cp.begin();\n\t\t\t\tint pr = lower_bound(cp.begin(), cp.end(), t[j]) - cp.begin();\n\t\t\t\tfor (int k = pl; k < pr; k++) f[k] = x[j];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < cp.size() - 1; j++) {\n\t\t\tif (f[j] != -1) {\n\t\t\t\tfor (int k = cp[j]; k < cp[j + 1]; k++) d[k] = f[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1LL << 31) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\ntemplate<typename T, typename E>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, size_t)>;\n    int n;\n    F f; //要素と要素のマージ\n    G g; //要素に作用素を作用\n    H h; //作用素と作用素をマージ\n    T ti; //要素の単位元?\n    E ei; //作用素の単位元?\n    P p; //b個の作用素aをマージした場合\n    vector<T> dat;\n    vector<E> laz;\n\n    SegmentTree(int n_, F f, G g, H h, T ti, E ei,\n                P p = [](E a, size_t b) {\n                    b++;\n                    return a;\n                }) :\n            f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n        dat.assign(2 * n - 1, ti);\n        laz.assign(2 * n - 1, ei);\n    }\n\n    void build(int n_, vector<T> v) {\n        for (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k) {\n        if (laz[k] == ei) return;\n        if (k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = ei;\n    }\n\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return dat[k];\n        if (a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    T update(int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return ti;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    void update(int k, T x) {\n        query(k, k + 1);//evaluate\n        k += n - 1;\n        dat[k] = x;\n        while (k) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    n++;\n    using T = pair<int, int>; //firstは値、secondはtime\n    using E = pair<int, int>;\n    auto f = [](T a, T b) {\n        if (a.second > b.second) {\n            return a;\n        } else {\n            return b;\n        }\n    }; // 要素と要素のマージ\n\n    auto g = [](T a, E b) {\n        if (a.second > b.second) {\n//            return a.first;\n            return a;\n        } else {\n//            return b.first;\n            return b;\n        }\n    }; // 要素に作用素を作用\n\n    auto h = [](E a, E b) {\n        if (a.second > b.second) {\n//            return a.first;\n            return a;\n        } else {\n//            return b.first;\n            return b;\n        }\n    }; // 作用素と作用素をマージ\n\n    auto p = [](E a, int b) {\n        return a;\n    }; // 作用素を区間加算する場合\n    T ti = T(INT_MAX, 0); //要素の単位元?\n    E ei = E(INT_MAX, 0); //作用素の単位元?\n    SegmentTree<T, E> treeone(n, f, g, h, ti, ei, p);\n\n//    cout << treeone.query(2,3).first << endl;\n    int time = 0;\n    while(q--){\n        int cmd;\n        cin >> cmd;\n        if(cmd){\n            int i;\n            cin >> i;\n            cout << treeone.query(i,i+1).first << endl;\n        }else{\n            time++;\n            int s,t,x;\n            cin >> s >> t >> x;\n            E val(x,time);\n            treeone.update(s,t+1,val);\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nstruct RUP{\n  static const int MAX_N = 1 << 18;\n  int n;\n  P dat[2*MAX_N-1];\n  RUP(){}\n  RUP(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=INT_MAX;\n  }\n  int query(int k){\n    k+=n-1;\n    P p=dat[k];\n    while(k>0){\n      k=(k-1)/2;\n      p=max(p,dat[k]);\n    }\n    return p.second;\n  }\n  \n  void update(int a,int b,P p,int k,int l,int r){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b) {\n      dat[k]=p;\n    }else{\n      update(a,b,p,k*2+1,l,(l+r)/2);\n      update(a,b,p,k*2+2,(l+r)/2,r);\n    }\n  }\n  \n  void update(int a,int b,P p){\n    update(a,b,p,0,0,n);\n  }\n};\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  RUP rup(n);\n  for(int i=0;i<q;i++){\n    int f;\n    cin>>f;\n    if(!f){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rup.update(s,t+1,P(i,x));\n    }else{\n      int u;\n      cin>>u;\n      cout<<rup.query(u)<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n\ntemplate<class T, class E>\nstruct SegTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  typedef function<E(E,E)> H;\n  typedef function<E(E,int)> P;\n  int n;\n  F f;\n  G g;\n  H h;\n  P p;\n  T d1;\n  E d0;\n  vector<T> dat;\n  vector<E> lazy;\n  SegTree(int n_, F f, G g, H h, T d1, E d0, P p=[](E a, int b){ return a; })\n    : f(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n    n = 1;\n    while (n < n_) n *= 2;\n    dat.resize(2 * n - 1, d1);\n    lazy.resize(2 * n - 1, d0);\n  }\n  void eval(int k, int l, int r) {\n    if (lazy[k] == d0) return;\n    dat[k] = g(dat[k], p(lazy[k], r - l));\n    if (k < n - 1) {\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = h(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = d0;\n  }\n  void update(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    eval(k, l, r);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      eval(k, l, r);\n    }\n    else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  // return op[a..b)\n  // k: node id, [l, r): node interval\n  E query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    // cerr << \"a = \" << a << \", b = \" << b << \", k = \" << k << \", l = \" << l << \", r = \" << r << endl;\n    if (r == -1) r = n;\n    eval(k, l, r);\n    if (r <= a || b <= l) return d1;\n    if (a <= l && r <= b) return dat[k];\n    E vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    E vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n  void print() {\n   int j = 2;\n   for (int i = 0; i < 2 * n - 1; i++) {\n     cerr << \"(\" << dat[i] << \", \" << lazy[i] << \")\";\n     if (i == j - 2) { cerr << endl; j *= 2;}\n     else { cerr << \" \"; }\n   }\n }\n};\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n, q;\n  cin >> n >> q;\n  SegTree<int, int> seg(\n    n,\n    [](int a, int b){ return std::min(a, b); },\n    [](int a, int b){ return b; },\n    [](int a, int b){ return b; },\n    INT_MAX,\n    -1);\n  rep(i, q) {\n    int t;\n    cin >> t;\n    if (t == 0) {\n      int a, b, x;\n      cin >> a >> b >> x;\n      seg.update(a, b + 1, x);\n    }\n    else {\n      int a;\n      cin >> a;\n      cout << seg.query(a, a + 1) << endl;\n    }\n    // cerr << \"i = \" << i << endl;\n    // seg.print();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int n;\n\tvector<T1> data;\n\tvector<T2> lazy;\n\tint size(int n) {\n\t\tint res = 1;\n\t\twhile (res < n) res <<= 1;\n\t\treturn res;\n\t}\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tif (node < n) {\n\t\t\tlazy[node * 2] = M::op3(lazy[node * 2], lazy[node]);\n\t\t\tlazy[node * 2 + 1] = M::op3(lazy[node * 2 + 1], lazy[node]);\n\t\t}\n\t\tdata[node] = M::op2(data[node], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\n\tvoid suc(int l, int r, int node, int lb, int ub, T2 val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) {\n\t\t\tlazy[node] = M::op3(lazy[node], val);\n\t\t\treturn;\n\t\t}\n\t\tpush(node);\n\t\tint c = (lb + ub) / 2;\n\t\tsuc(l, r, node * 2, lb, c, val);\n\t\tsuc(l, r, node * 2 + 1, c, ub, val);\n\t\tdata[node] = M::op1(M::op2(data[node * 2], lazy[node * 2]), M::op2(data[node * 2 + 1], lazy[node * 2 + 1]));\n\t}\n\tT1 sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return M::id1();\n\t\tif (l <= lb && ub <= r) return M::op2(data[node], lazy[node]);\n\t\tint c = (lb + ub) / 2;\n\t\treturn M::op2(M::op1(sub(l, r, node * 2, lb, c), sub(l, r, node * 2 + 1, c, ub)), lazy[node]);\n\t}\npublic:\n\tlazy_segment_tree(int n_) : n(size(n_)), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {}\n\tlazy_segment_tree(int n_, T1 v1) : n(size(n_)), data(n * 2, v1), lazy(n * 2, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_) : n(size(data_.size())), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {\n\t\tinit(data_);\n\t}\n\tvoid init() {\n\t\tfor (int i = n - 1; i >= 1; i--) data[i] = M::op1(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid init(const vector<T1>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++) data[i + n] = data_[i];\n\t\tinit();\n\t}\n\tvoid update(int l, int r, T2 val) {\n\t\tsuc(l, r + 1, 1, 0, n, val);\n\t}\n\tT1 find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nstruct RURM {\n\tusing t1 = int;\n\tusing t2 = int;\n\tstatic t1 id1() { return INT_MAX; }\n\tstatic t2 id2() { return -1; }\n\tstatic t1 op1(const t1& l, const t1& r) { return min(l, r); }\n\tstatic t1 op2(const t1& l, const t2& r) { return r != id2() ? r : l; }\n\tstatic t2 op3(const t2& l, const t2& r) { return r != id2() ? r : l; }\n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  LL N,Q;\n  cin >> N >> Q;\n\n\tlazy_segment_tree<RURM> seg(N);\n\tseg.init();\n\n\tREP(i,Q){\n\t\tLL y;\n\t\tcin >> y;\n\t\tif(y==0){\n\t\t\tLL s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.update(s, t, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLL s;\n\t\t\tcin >> s;\n\t\t\tcout << seg.find(s, s) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                cout << 2147483647 << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        cout << x[j] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t    }\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int MAX_N = 1e5;\nconst int SQRT_N = 317;\nconst int BUCKET_SIZE = 1 + (MAX_N - 1) / SQRT_N;\nint dat[MAX_N] = {};\nint lazy_bucket[SQRT_N] = {};\nbool lazy_flag[SQRT_N] = {};\n\nvoid init(int n) {\n\trep(i, 0, n) {\n\t\tdat[i] = INT_MAX;\n\t}\n}\n\nint get(int x) {\n\tint k = x / SQRT_N;\n\treturn lazy_flag[k] ? lazy_bucket[k] : dat[x];\n}\n\nvoid update(int l, int r, int val) {\n\tfor (int k = 0; k < BUCKET_SIZE; k++) {\n\t\tint bl = k * SQRT_N, br = (k + 1) * SQRT_N;\n\t\tif (r <= bl || br <= l)\n\t\t\tcontinue;\n\t\tif (l <= bl && br <= r) {\n\t\t\tlazy_bucket[k] = val;\n\t\t\tlazy_flag[k] = true;\n\t\t}\n\t\telse {\n\t\t\tif (lazy_flag[k]) {\n\t\t\t\tfor (int i = bl; i < br; i++) {\n\t\t\t\t\tdat[i] = lazy_bucket[k];\n\t\t\t\t}\n\t\t\t\tlazy_flag[k] = false;\n\t\t\t}\n\t\t\tfor (int i = max(l, bl); i < min(r, br); i++) {\n\t\t\t\tdat[i] = val;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tinit(n);\n\trep(i, 0, q) {\n\t\tint c; cin >> c;\n\t\tif (c == 0) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tupdate(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint i; cin >> i;\n\t\t\tcout << get(i) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tDSL: domain-specific language\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/5/2017\n\tTLE: 17/22 10^10 must change the data structure--> binary tree\n\tupdate the data: set the priority\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 131072 //100000\ntypedef struct Node{\n\tint val;\n\tint priority;\n}node;\nvoid find(int i);\nvoid add(int s,int t, int x,int i);\nnode array[2*N+100];      //the size of array, for present the tree\n//BEGIN FROM 1;\nint main(){\n\tint n = 0, q = 0;\n\tint a,b,c;\n\tscanf(\"%d %d\",&n,&q);\n\t\n\t//how to calculate the beginning index (the last layer of the tree)\n\tint count = 0;\n\tint temp = n;\n\twhile(n!=1){\n\t\tn = n/2;\n\t\tcount++;  \n\t}\n\tif(pow(2,count)!=temp) count++;\n\t//printf(\"count:%d\",count);\n\tint B = pow(2,count)-1;\n\tfor(int i = 0; i<=B;i++){ //special case forn==1, need i = 0;\n\t\tarray[i].val =  pow(2,31) - 1;\n\t\tarray[i].priority = 0;\n\t}\n\tfor(int i = 1; i<=n; i++){\n\t\tarray[i+B].val = pow(2,31) - 1;\t//e.g.begin from 8 (the last element of previous layer is 7)\n\t\tarray[i].priority = 0;\n\t}//printf(\"%d\\n\", array[B].val);\n\tfor(int i = 0; i < q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tadd(a+B,b+B,c,i);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfind(a+B);\n\t\t}\n\t}\n\treturn 0;\n}\n//add elements\n//s means: left pointer\n//t means : right pointer\nvoid add(int s,int t, int x,int i){\n\t//signle node\n\tif(s==t) {\n\t\tarray[s].val = x;\n\t\tarray[s].priority = i;\n\t\treturn;\n\t}\n\t//range update\n\t//check the left pointer\n\twhile(s<t){\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t\tif(s%2==0){ //left child, level up\n\t\t\ts = s/2;\n\t\t}else{ //right child: mark and level up + 1\n\t\t\tarray[s].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\ts = s/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tif(t%2==0){//left child: \n\t\t\tarray[t].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\tt = t/2;\n\t\t\tt--;\n\t\t} else { //right child\n\t\t\tt/= 2; \t\n\t\t}\n\t\tif(s==t) {\n\t\t\tarray[s].val =x;\n\t\t\tarray[s].priority = i;\n\t\t}// works for 1-4,1-3, 1-5\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t}\n\t\n\t//test for \n\t/*for(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", i);\n\t}printf(\"\\n\");\n\tfor(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", array[i]);\n\t}*/\n\t\n}\n\nvoid find(int i) {//the index of the tree\n\tint res = array[i].val;\n\tint max = 0; //the priority\n\t//printf(\"%d\\n\", array[i].val);\n\twhile(i>=1){\n\t\tif(array[i].priority>max){\n\t\t\tres=array[i].val;\n\t\t\t//printf(\"array:%d\",res);\n\t\t\tmax = array[i].priority;\t\n\t\t}\n\t\ti = i/2;\n\t}\n\t\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            //if(i < s_min || i > t_max){\n            //    A[i] = INT_MAX;\n                cout << A[i] << endl;\n            //}else{\n            //    for(j = m; j >= 0; j--){\n            //        if(s[j] <= i && t[j] >= i){\n            //            A[i] = x[j];\n            //            cout << A[i] << endl;\n            //            break;\n            //        }\n            //    }\n            //}\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 17;\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=INT_MAX;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  //cout<<k<<\"/\"<<dat[k].second<<endl;\n  while(k>0){\n    k=(k-1)/2;\n    //cout<<k<<\"/\"<<dat[k].second<<endl;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,int k,P p,int l,int r){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n    //cout<<a<<\":\"<<b<<\":\"<<k<<\":\"<<l<<\":\"<<r<<endl;\n     dat[k]=p;\n  }else{\n    update(a,b,k*2+1,p,l,(l+r)/2);\n    update(a,b,k*2+2,p,(l+r)/2,r);\n  }\n}\nint main(){\n  int n,q;\n  cin>>n>>q;\n  init(n+1);\n  for(int i=0;i<q;i++){\n    int f;\n    cin>>f;\n    if(!f){\n      int s,t,x;\n      cin>>s>>t>>x;\n      //cout<<i<<\":\"<<x<<endl;\n      update(s,t+1,0,P(i,x),0,n+1);\n    }else{\n      int u;\n      cin>>u;\n      cout<<query(u)<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<functional>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\n// Mq : Monoid(query) , Mo : Monoid(output), (time, num)\n\ntemplate <typename Mq=ll, typename Mo=std::pair<ll, ll>> class DelayedSegmentTree {\n    public:\n    using Mqq_func = function<Mq(Mq, Mq)>;\n    using Mqo_func = function<Mq(Mq, Mo)>;\n    using Moo_func = function<Mo(Mo, Mo)>;\n    using Mp_func = function<Mo(Mo, ll)>;\n    ll size;\n    std::vector<Mq> segment;  // 1-indexed 葉ノードは size ~ 2*size-1\n    std::vector<Mo> laz;\n    ll time;\n    Mq Mq_id; Mo Mo_id;\n    Mqq_func Mqq_calc; Mqo_func Mqo_calc; Moo_func Moo_calc; Mp_func Mp_calc;\n\n    DelayedSegmentTree(\n                ll N, \n                Mq Mq_id = 0,\n                Mo Mo_id = std::make_pair(0, 0),\n                Mqq_func Mqq_calc = [](ll a, ll b){return a+b;},\n                Mqo_func Mqo_calc = [](ll a, std::pair<ll, ll> b){return a+b.second;},\n                Moo_func Moo_calc = [](std::pair<ll, ll> a, std::pair<ll, ll> b){return a.second+b.second;},\n                Mp_func Mp_calc = [](std::pair<ll, ll> a, ll b){return a.second*b;}) \n            : size(1), time(1), Mq_id(Mq_id), Mo_id(Mo_id), Mqq_calc(Mqq_calc), Mqo_calc(Mqo_calc), Moo_calc(Moo_calc), Mp_calc(Mp_calc) {\n        while(size < N) size <<= 1;\n        segment.assign(size*2, Mq_id);\n        laz.assign(size*2, Mo_id);\n    }\n\n    void build(){  // 全てのノードを再計算\n        for(ll k=size-1; k>0; k--) segment[k] = Mqq_calc(segment[k*2], segment[k*2+1]);\n    }\n    void eval(ll len, ll node){\n        if(laz[node] == Mo_id) return;\n        if(node*2<size*2){\n            laz[node*2] = Moo_calc(laz[node*2], laz[node]);\n            laz[node*2+1] = Moo_calc(laz[node*2+1], laz[node]);\n        }\n        segment[node] = Mqo_calc(segment[node], Mp_calc(laz[node], len));\n        laz[node] = Mo_id;\n    }\n    Mq update(ll a, ll b, Mo x, ll node, ll l, ll r){\n        eval(r-l, node);\n        if(r <= a || b <= l) return segment[node]; // 範囲外\n        if(a <= l && r <= b){  // 包含\n            laz[node] = Moo_calc(laz[node], x);\n            return Mqo_calc(segment[node], Mp_calc(laz[node], r-l));\n        }\n        return segment[node] = Mqq_calc(update(a, b, x, node*2, l, (l+r)/2), update(a, b, x, node*2+1, (l+r)/2, r));\n    }\n    Mq update(ll a, ll b, Mo x){\n        time++;\n        return update(a,b,x,1,0,size);\n    }\n    Mq query(ll a, ll b, ll node, ll l, ll r){\n        eval(r-l, node);\n        if(r <= a || b <= l) return Mq_id;\n        if(a <= l && r <= b) return segment[node];\n        return Mqq_calc(query(a, b, node*2, l, (l+r)/2), query(a, b, node*2+1, (l+r)/2, r));\n    }\n    Mq query(ll a, ll b){ // [a, b)の演算結果\n        return query(a, b, 1, 0, size);\n    }\n\n    Mq operator[](const ll &k) const{\n        return segment[k+size];\n    }\n};\n\nint main(){\n    ll n,q, com, s, t, x;\n\n    cin >> n >> q;\n    DelayedSegmentTree<ll, std::pair<ll, ll>> dst(\n        n, 2147483647, std::make_pair(0, 0),\n        [](ll a, ll b){return a+b-2147483647;},\n        [](ll a, std::pair<ll, ll> b){return b.first>0 ? b.second : a;},\n        [](std::pair<ll, ll> a, std::pair<ll, ll> b){\n            return a.first>b.first ? std::make_pair(a.first, a.second) : std::make_pair(b.first, b.second);\n        },\n        [](std::pair<ll, ll> a, ll b){\n            return std::make_pair(a.first, a.second);\n        });\n    REP(i,q){\n        cin >> com;\n        if(com==0){\n            cin >> s >> t >> x;\n            dst.update(s, t+1, std::make_pair(dst.time, x));\n        }\n        else{\n            cin >> s;\n            cout << dst.query(s,s+1) << endl;\n        }\n        //for(auto j : dst.segment) cout << j;\n        //cout << \"###\" << endl;\n        //for(auto j : dst.laz) cout << j.first << \" \" << j.second << \"  \";\n        //cout << \"######\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define fi first\n#define se second\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\ntemplate <typename E>\nstruct dual_segment_tree {\n    using H = function<E(E, E)>;\n    int n, height;\n    H h;\n    E ei;\n    vector<E> lazy;\n    dual_segment_tree(H h, E ei) : h(h), ei(ei) {}\n    void init(int n_) {\n        n = 1; height = 0;\n        while (n < n_) n <<= 1, height++;\n        lazy.assign(2*n, ei);\n    }\n    inline void propagete(int i) {\n        if (lazy[i] == ei) return;\n        lazy[i<<1|0] = h(lazy[i<<1|0], lazy[i]);\n        lazy[i<<1|1] = h(lazy[i<<1|1], lazy[i]);\n        lazy[i] = ei;\n    }\n    inline void thrust(int i) {\n        for (int k = height; k >= 1; --k) propagete(i>>k);\n    }\n    void update(int a, int b, E x) {\n        a += n; b += n;\n        thrust(a);\n        thrust(b-1);\n        int l = a, r = b;\n        while (l < r) {\n            if (l & 1) lazy[l] = h(lazy[l], x), l++;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n            l >>= 1; r >>= 1;\n        }\n    }\n    E get_val(int i) {\n        i += n;\n        thrust(i);\n        return lazy[i];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int n, q;\n    cin >> n >> q;\n    const int inf = INT_MAX;\n    auto f = [](int a, int b) { return b == inf ? a : b;};\n    dual_segment_tree<int> seg(f, inf);\n    seg.init(n);\n    while (q--) {\n        int com, s, t, x, i;\n        cin >> com;\n        if (com == 0) {\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        } else {\n            cin >> i;\n            cout << seg.get_val(i) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<random>\nusing namespace std;\n\nusing Value = int;\nconst Value INI = INT_MAX;\nstruct Node {\n\tValue sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(0) {\n\t\tlazy = 0;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tdat[k].sum += dat[k].lazy * (b - a + 1);\n\t}\n\n\tValue connect(const Value l, const Value r) {\n\t\treturn l + r;\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy += dat[k].lazy;\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy += dat[k].lazy;\n\t\t}\n\t\tdat[k].lazy = 0;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy += v;\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\n\t// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn 0;\n\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tValue vl = get(l, r, 2 * k, a, m);\n\t\tValue vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\nnamespace perseg {\n\n\tstruct permanent_segtree {\n\t\tValue val;\n\t\tValue lazy;\n\t\tint l, r;\n\t\tvector<shared_ptr<permanent_segtree>>chs;\n\tpublic:\n\t\tpermanent_segtree(const int size_) :val(INI),lazy(INI), l(0), r(size_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const Value& val_, const int l_, const int r_) :val(val_), lazy(INI), l(l_), r(r_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const permanent_segtree&tree_) :val(tree_.val), lazy(tree_.lazy), l(tree_.l), r(tree_.r), chs(tree_.chs) {\n\n\t\t}\n\t\tvoid lazy_func() {\n\t\t\tif (lazy !=INI) {\n\t\t\t\tval = lazy;\n\t\t\t}\n\t\t}\n\t\tValue update_lazy(int lazy_from, int lazy_to) {\n\t\t\tif (lazy_to != INI) {\n\n\t\t\t\treturn lazy_to;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lazy_from;\n\t\t\t}\n\t\t}\n\t\tvoid lazy_evaluate_node() {\n\t\t\tlazy_func();\n\t\t\tif (l + 1 != r) {\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tgetch(i)->lazy = update_lazy(getch(i)->lazy, lazy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlazy = INI;\n\t\t}\n\t\tshared_ptr<permanent_segtree>getch(const int num_) {\n\t\t\tconst int amid = (l + r) / 2;\n\n\t\t\tif (chs[num_] == nullptr) {\n\t\t\t\tif (num_ == 0) {\n\t\t\t\t\tchs[0] = make_shared<permanent_segtree>(INI, l, amid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchs[1] = make_shared<permanent_segtree>(INI, amid, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chs[num_];\n\n\t\t}\n\t\tValue eval_value(const Value&value_l, const Value&value_r)const {\n\t\t\treturn min(value_l, value_r);\n\t\t}\n\t\t// min [a, b)\n\t\tValue  query(int a, int b, int k) {\n\t\t\tlazy_evaluate_node();\n\t\t\tif (r <= a or b <= l) return INI;\n\t\t\tif (a <= l and r <= b) return val;\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tconst Value al(getch(0)->query(a, b, k));\n\t\t\tconst Value ar(getch(1)->query(a, b, k));\n\t\t\treturn eval_value(al, ar);\n\t\t}\n\t};\n\n\tshared_ptr<permanent_segtree>immutable_update(const shared_ptr<permanent_segtree>&tree, const int l,const int r, const Value a) {\n\t\ttree->lazy_evaluate_node();\n\t\tif (tree->r <= l || r <= tree->l) {\n\t\t\treturn tree;\n\t\t}else if (l<= tree->l&&tree->r<=r) {\n\t\t\tshared_ptr<permanent_segtree>new_tree(make_shared<permanent_segtree>(INI, tree->l, tree->r));\n\t\t\tnew_tree->lazy = new_tree->update_lazy(new_tree->lazy, a);\n\t\t\tnew_tree->lazy_evaluate_node();\n\t\t\treturn new_tree;\n\t\t}\n\t\telse {\n\t\t\tshared_ptr<permanent_segtree>copy_tree = (make_shared<permanent_segtree>(*tree));\n\t\t\tassert(tree->l + 1 < tree->r);\n\t\t\tcopy_tree->chs[0] = immutable_update(tree->getch(0), l,r, a);\t\t\t\n\t\t\tcopy_tree->chs[1] = immutable_update(tree->getch(1),l,r, a);\t\n\t\t\tcopy_tree->val = copy_tree->eval_value(copy_tree->getch(0)->val, copy_tree->getch(1)->val);\n\n\t\t\treturn copy_tree;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tusing namespace perseg;\n\tvector < shared_ptr<permanent_segtree>>trees(1, nullptr);\n\ttrees[0] = make_shared<permanent_segtree>(1 << 17);\n\tint N, Q; cin >> N >> Q;\n\tint now = 0;\n\tvector<tuple<int, int>>qs;\n\tbool flag = false;\n\tfor (int i = 0; i < Q;++i){\n\t\t\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint t; cin >> t;\n\t\t\tqs.push_back(make_tuple(now, t));\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\t//if (flag) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\ttrees.push_back(immutable_update(trees[now], s,t+1,x));\n\t\t\tnow++;\n\t\t\tflag = false;\n\t\t\t/*}\n\t\t\telse {\n\t\t\t\ttrees.back() = immutable_update(trees[now], x, y);\n\t\t\t}*/\n\t\t}\n\t}\n\tfor (int i = 0; i < qs.size(); ++i) {\n\t\tint anow,x;\n\t\ttie(anow, x) = qs[i];\n\t\tint ans = trees[anow]->query(x, x + 1, 100);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nstruct segtree_lazy {\n\tint n;\n\tvector<T> tree, lazy;\n\tT def = numeric_limits<T>::max(), none = -1;\n\t\n\tsegtree_lazy(int n_) {\n\t\tfor (n = 1; n < n_; n *= 2) {\n\t\t\t\n\t\t}\n\t\ttree.assign(2 * n, def);\n\t\tlazy.assign(2 * n, none);\n\t}\n\t\n\tT merge(T a, T b) {\n\t\treturn max(a, b);\n\t}\n\t\n\tvoid set_lazy(int index, T x) {\n\t\ttree[index] = x;\n\t\tlazy[index] = x;\n\t}\n\t\n\tvoid push(int index) {\n\t\tif (lazy[index] == none) {\n\t\t\treturn;\n\t\t}\n\t\tset_lazy(2 * index, tree[index]);\n\t\tset_lazy(2 * index + 1, tree[index]);\n\t\tlazy[index] = none;\n\t}\n\t\n\tvoid fix(int index) {\n\t\ttree[index] = merge(tree[2 * index], tree[2 * index + 1]);\n\t}\n\t\n\tvoid update(int a, int b, int index, int l, int r, T x) {\n\t\tif (r <= a || b <= l) {\n\t\t\treturn;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\tset_lazy(index, x);\n\t\t\treturn;\n\t\t}\n\t\tpush(index);\n\t\tupdate(a, b, 2 * index, l, (l + r) / 2, x);\n\t\tupdate(a, b, 2 * index + 1, (l + r) / 2, r, x);\n\t\tfix(index);\n\t}\n\t\n\tvoid update(int l, int r, T x) {\n\t\tupdate(l, r, 1, 0, n, x);\n\t}\n\t\n\tT query(int a, int b, int index, int l, int r) {\n\t\tif (r <= a || b <= l) {\n\t\t\treturn none;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn tree[index];\n\t\t}\n\t\tpush(index);\n\t\tT puni = query(a, b, 2 * index, l, (l + r) / 2);\n\t\tT muni = query(a, b, 2 * index + 1, (l + r) / 2, r);\n\t\treturn merge(puni, muni);\n\t}\n\t\n\tT query(int l, int r) {\n\t\treturn query(l, r, 1, 0, n);\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tsegtree_lazy<int> seg(n);\n\tfor (int i = 0; i < q; i++) {\n\t\tbool b;\n\t\tcin >> b;\n\t\tif (b) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << seg.query(x, x + 1) << endl;\n\t\t} else {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define N 131072 //100000\n#define MAXVAL 2147483647 //((long int) ((unsigned long) (1 << 31) - 1))  //*2\nint min(int a, int b){return a>b?b:a;}\nint max(int a, int b){return a>b?a:b;}\nint data[2*131072+100];      //the size of array, for present the tree\n\n//range update and single query\n\n/*\nalways binary [node_left,node_right]\nfrom top to bottom\n*/ \nvoid update(int update_left, int update_right, int x, int current_node,int node_left,int node_right){\n\t//not in the range\n\tif(update_right<node_left||update_left>node_right){\n\t\treturn;\t\n\t}else if(update_left<=node_left&&update_right>=node_right){\n\t\tdata[current_node] = x;\n\t}else{\n\t\t//how to check if the\n\t\t//unfold the node, the amxValue->-1\n\t\tif(data[current_node]!=-1){ //-1: unfold\n\t\t\t//update(node_left, node_right,data[current_node],current_node*2+1,node_left,(node_left+node_right)/2);\n\t\t\t//update(node_left, node_right,data[current_node],current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t\t\tdata[2*current_node+1] = data[current_node];\n            data[2*current_node+2] = data[current_node];\n\t\t\tdata[current_node]=-1;\n\t\t}\n\t\t//update \n\t\tupdate(update_left, update_right, x, current_node*2+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left, update_right, x, current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t}\n}\n//segment of thr last layer\n//I did notdeal with 0\n//backtrack the tree from the bottom, \n//just update one time\nvoid update2(int x, int node_id,int node_left, int node_right){//x begin from data[0], node_id from 1\n\tif(x!=-1){\n\t\tdata[node_id] = x; \n\t}\n\t//printf(\"%d %d %d\\n\",node_left,node_right,node_id);\n\tif(node_left==node_right) {\n\t\treturn;\n\t}\n\tif(data[node_id]!=-1){\n\t\t//printf(\"%d\\n\",data[node_id]);\n\t\tupdate2(data[node_id], node_id*2+1,node_left, (node_left+node_right)/2);\n\t\tupdate2(data[node_id], node_id*2+2,(node_left+node_right)/2+1, node_right);\n\t\tdata[node_id]=-1;\n\t} \n\telse {\n\t\tupdate2(-1, node_id*2+1,node_left, (node_left+node_right)/2);\n\t\tupdate2(-1, node_id*2+2,(node_left+node_right)/2+1, node_right);\n\t}\n\t\n}\n//search from top to bottom\nint search(int search_left,int search_right, int current_node, int node_left, int node_right){\n\tif(search_right < node_left || search_left > node_right){\n        return -1;//not in the range\n\t}\n\telse if(search_left >= node_left && search_right <= node_right&&data[current_node]>=0){//??\n\t\treturn data[current_node];//for the folded node which parent present the minimal of their children \n\t}else {\n\t\tint left = search(search_left, search_right,current_node*2+1, node_left,(node_left+node_right)/2);\n\t\tint right = search(search_left, search_right,current_node*2+2, (node_left+node_right)/2+1, node_right);\n\t\treturn max(left,right);\n\t}\n\t\n}\nint main(){\n\tint n, q;\n\tFILE *fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\tint N = 1;\n\twhile(N<n) N = N<<1;\n\tif(n==1) N=2;\n\tfor(int i = 0; i<=2*N-2; i++){\n\t\tdata[i] = MAXVAL;\n\t}\n\t//printf(\"%d\",(-1/2));\n\tfor(int i = 0; i<q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tint a,b,c;\n\t\t\n\t\tif(temp == 0) {  //update\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tupdate(a,b,c,0,0,N-1);\n\t\t\t\n\t\t} else if(temp == 1){ //search\n\t\t\tscanf(\"%d\",&a);\n\t\t\tprintf(\"%d\\n\",search(a,a,0,0,N-1));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#include <functional>\nusing namespace std;\n\n// 動的遅延セグメント木 (必要なところだけノードを作る)\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegNode {\n    MonoidType value;\n    OperatorType lazy_value;\n    bool need_update;\n    LazySegNode *ch[2];\n    \n    LazySegNode() {}\n    LazySegNode(MonoidType value_, OperatorType lazy_value_) :\n        value(value_), lazy_value(lazy_value_) {\n        need_update = false;\n        ch[0] = ch[1] = nullptr;\n    }\n};\n\ntemplate <typename MonoidType, typename OperatorType, class SegFunc, typename IdxType = int>\nstruct DynamicLazySegmentTree {\n    // node, identity element\n    using LNode = LazySegNode<MonoidType, OperatorType>;\n    IdxType n;\n    LNode *root;\n    MonoidType E0;\n    OperatorType E1;\n\n    DynamicLazySegmentTree() {}\n    DynamicLazySegmentTree(IdxType n_, MonoidType E0_, OperatorType E1_) :\n        E0(E0_), E1(E1_) {\n        root = new LNode(E0_, E1_);\n        n = 1; while(n < n_) n *= 2;\n    }\n\n    void eval(LNode *node, IdxType l, IdxType r) {\n        if(!node->need_update) return;\n        node->value = SegFunc::update(node->value, SegFunc::accumulate(node->lazy_value, r - l));\n        if(r - l > 1) {\n            if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n            if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n            node->ch[0]->lazy_value = SegFunc::lazy_update(node->ch[0]->lazy_value, node->lazy_value);\n            node->ch[1]->lazy_value = SegFunc::lazy_update(node->ch[1]->lazy_value, node->lazy_value);\n            node->ch[0]->need_update = node->ch[1]->need_update = true;\n        }\n        node->lazy_value = E1;\n        node->need_update = false;\n    }\n\n    void update(LNode *node, IdxType a, IdxType b, OperatorType x,\n                IdxType l, IdxType r) {\n        eval(node, l, r);\n        if(b <= l or r <= a) return;\n        if(a <= l and r <= b) {\n            node->lazy_value = SegFunc::lazy_update(node->lazy_value, x);\n            node->need_update = true;\n            eval(node, l, r);\n        }\n        else {\n            IdxType mid = (l + r) / 2;\n\n            MonoidType vl = E0, vr = E0;\n            if(!(b <= l or mid <= a)) {\n                if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n                update(node->ch[0], a, b, x, l, mid);\n                vl = node->ch[0]->value;\n            }\n            if(!(b <= mid or r <= a)) {\n                if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n                update(node->ch[1], a, b, x, mid, r);\n                vr = node->ch[1]->value;\n            }\n            node->value = SegFunc::combine(vl, vr);\n        }\n    }\n\n    MonoidType query(LNode *node, IdxType a, IdxType b, IdxType l, IdxType r) {\n        if(b <= l or r <= a) return E0;\n        eval(node, l, r);\n        if(a <= l and r <= b) return node->value;\n        IdxType mid = (l + r) / 2;\n        MonoidType vl = (node->ch[0] ? query(node->ch[0], a, b, l, mid) : E0);\n        MonoidType vr = (node->ch[1] ? query(node->ch[1], a, b, mid, r) : E0);\n        return SegFunc::combine(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value: x)\n    void update(IdxType a, IdxType b, OperatorType x) {\n        update(root, a, b, x, 0, n);\n    }\n\n    // range query for [a, b)\n    MonoidType query(IdxType a, IdxType b) {\n        return query(root, a, b, 0, n);\n    }\n};\n\n\n// Verified on Apr 27, 2019\nvoid DSL_2_D() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int b) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, INT_MAX);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_E() {\n    struct SegFunc {\n        static int update(int a, int b) { return a + b; }\n        static int combine(int a, int b) { return a + b; }\n        static int lazy_update(int a, int b) { return a + b; }\n        static int accumulate(int a, int x) { return a * x; }\n    };\n\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int, SegFunc> seg(N, 0, 0);\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_F() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int x) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, 0);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_G() {\n    using ll = long long int;\n    struct SegFunc {\n        static ll update(ll a, ll b) { return a + b; }\n        static ll combine(ll a, ll b) { return a + b; }\n        static ll lazy_update(ll a, ll b) { return a + b; }\n        static ll accumulate(ll a, ll x) { return a * x; }\n    };\n\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<ll, ll, SegFunc> seg(N, 0, 0);\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n/*\n// Verified on May 28, 2019\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    using Pair = pair<ll, ll>;\n    DynamicLazySegmentTree<ll, Pair> seg(N, INT_MAX, make_pair(0, 0),\n                                       [](ll a, Pair b) {\n                                             if(b.second == 1) {\n                                                 return b.first;\n                                             }\n                                             else {\n                                                 return a + b.first;\n                                             }\n                                         },  // upd\n                                       [](ll a, ll  b) { return min(a, b); },  // cmb\n                                       [](Pair a, Pair b) {\n                                           if(a.second == 0 and b.second == 0) {\n                                               return make_pair(a.first + b.first, 0LL);\n                                           }\n                                           if(a.second == 0 and b.second == 1) {\n                                               return b;\n                                           }\n                                           if(a.second == 1 and b.second == 0) {\n                                               return make_pair(a.first + b.first, 1LL);\n                                           }\n                                           if(a.second == 1 and b.second == 1) {\n                                               return b;\n                                           }\n                                       },\n                                       [](Pair a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<N; i++) {\n        seg.update(i, i+1, make_pair(0, 1));\n    }\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, make_pair(x, 0));\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on May 28, 2019\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    DynamicLazySegmentTree<ll, ll> seg(N, 0, 0,\n                                       [](ll a, ll  b) { return b;     },  // upd\n                                       [](ll a, ll  b) { return a + b; },  // cmb\n                                       [](ll a, ll  b) { return b;     },  // lzy\n                                       [](ll a, int x) { return a * x; }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// TLE\nvoid ABC128_E() {\n    const int RANGE = 1 << 30;\n    int N, Q; cin >> N >> Q;\n\n    DynamicLazySegmentTree<int, int> seg(RANGE, INT_MAX, INT_MAX,\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return a; });\n\n    for(int i=0; i<N; i++) {\n        int s, t, x; cin >> s >> t >> x;\n        s = max(0, s-x), t = max(0, t-x);\n        seg.update(s, t, x);\n    }\n    for(int i=0; i<Q; i++) {\n        int x; cin >> x;\n        int res = seg.query(x, x+1);\n        if(res == INT_MAX) cout << -1 << endl;\n        else cout << res << endl;\n    }\n}\n*/\n\nint main() {\n    DSL_2_D();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    // DSL_2_I();\n    // ABC128_E();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Range Update Query\n//reference https://kujira16.hateblo.jp/entry/2016/12/15/000000\n//https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_D\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntemplate <typename T>\nstruct RUQ {\n  T n;\n  T k;//バケットの数\n  T sqrt_n;//バケットの大きさ\n  vector<T> data;\n  vector<T> lazy_update;\n  T INF;\n\n  RUQ() = delete;\n  RUQ(T n_,T sqrt_n_ = 1000,T INF_ = 1e9) {\n    initialize(n_,sqrt_n_,INF_);\n  }\n\n  void initialize(T n_,T sqrt_n_ = 1000,T INF_ = 1e9) {\n    n = n_;\n\n    sqrt_n = sqrt_n_;\n\n    k = (n + sqrt_n - 1) / sqrt_n;//切り上げ割り算\n\n    data.clear();lazy_update.clear();\n\n    data.resize(k * sqrt_n,INF_);\n    lazy_update.resize(k,INF_ + 1);\n\n    INF = INF_;\n  }\n\n  void delay_propagation(T bucket_id) {\n    if (lazy_update[bucket_id] <= INF) {\n      for (int i = bucket_id * sqrt_n;i < (bucket_id + 1) * sqrt_n;i++) {\n        data[i] = lazy_update[bucket_id];\n      }\n      lazy_update[bucket_id] = INF + 1;\n    }\n  }\n\n  void update(T a,T b,T x) {\n    if (a >= sqrt_n * k || b > sqrt_n * k) {\n      cerr << \"error index k\" << endl;\n      return;\n    }\n    if (a >= n || b > n) {\n      cerr << \"warning index k\" << endl;\n    }\n\n    rep (i,k) {\n      T l = i * sqrt_n,r = (i + 1) * sqrt_n;\n      if (b <= l|| r <= a) continue;\n      if (l < a || b < r) {\n        delay_propagation(i);\n        for (int i = max(l,a);i < min(b,r);i++) {\n          data[i] = x;\n        }\n      } else {\n        lazy_update[i] = x;\n      }\n    }\n  }\n\n  T get(T i) { // i番目(0-indexed)の値を取得する\n    T bucket_id = i / sqrt_n;\n\n    if (lazy_update[bucket_id] > INF)return data[i];\n    return lazy_update[bucket_id];\n  }\n};\n\nusing ll = long long;\n\nsigned main() {\n  ll n,q;\n  cin >> n >> q;\n\n  RUQ<ll> ruq(n,1000,(1ll << 31) - 1ll);\n\n  rep(i,q) {\n    ll c;\n    cin >> c;\n    if(c) {\n      ll i;\n      cin >> i;\n      cout << ruq.get(i) << endl;\n    } else {\n      ll s,t,x;\n      cin >> s >> t >> x;\n      ruq.update(s,t+1,x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n\ntemplate<class I, class BiOp = I (*) (I, I)>\nclass SegTree {\nprivate:\n  int n;\n  std::vector<I> dat, lazy;\n  BiOp op;\n  I e;\n\npublic:\n  SegTree(int n_) {\n    n = 1;\n    while (n < n_) n *= 2;\n    dat.resize(2 * n - 1, INT_MAX);\n    lazy.resize(2 * n - 1, -1);\n  }\n\n  void eval(int k, int l, int r) {\n    if (lazy[k] == -1) return;\n    // cerr << \"eval: k = \" << k << \", l = \" << l << \", r = \" << r << endl;\n\n    dat[k] = lazy[k];\n    if (k < n - 1) {\n      lazy[2 * k + 1] = lazy[k];\n      lazy[2 * k + 2] = lazy[k];\n    }\n    lazy[k] = -1;\n  }\n\n  void update(int a, int b, I x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    // cerr << \"update: a = \" << a << \", b = \" << b << \", x = \" << x << \", k = \" << k << \", l = \" << l << \", r = \" << r << endl;\n    eval(k, l, r);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      // cerr << \"hey!\" << endl;\n      lazy[k] = x;\n      eval(k, l, r);\n    }\n    else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      // dat[k] = dat[2 * k + 1] + dat[2 * k + 2];\n    }\n  }\n\n  I query(int a, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    // cerr << \"query: a = \" << a << \", k = \" << k << \", l = \" << l << \", r = \" << r << endl;\n    eval(k, l, r);\n    if (r - l == 1) return dat[k];\n    int m = (l + r) / 2;\n    if (a < m) {\n      return query(a, 2 * k + 1, l, m);\n    }\n    else {\n      return query(a, 2 * k + 2, m, r);\n    }\n  }\n\n  void print() {\n    int j = 2;\n    for (int i = 0; i < 2 * n - 1; i++) {\n      cerr << \"(\" << dat[i] << \", \" << lazy[i] << \")\";\n      if (i == j - 2) {\n        cerr << endl;\n        j *= 2;\n      }\n      else {\n        cerr << \" \";\n      }\n    }\n  }\n};\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n, q;\n  cin >> n >> q;\n  SegTree<ll> seg(n);\n\n  // seg.print();\n\n  rep(i, q) {\n    // cerr << \"i = \" << i << endl;\n\n    int t;\n    cin >> t;\n    if (t == 0) {\n      int a, b, x;\n      cin >> a >> b >> x;\n      seg.update(a, b + 1, x);\n    }\n    else {\n      int a;\n      cin >> a;\n      cout << seg.query(a) << endl;\n    }\n\n    // seg.print();\n    // cerr << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nstruct RUQ{\n\tusing T = int;\n\tT operator()(const T &a, const T &b) { return min(a,b); };\n\tstatic constexpr T identity() { return INT_MAX; }\n};\n\ntemplate<class Monoid>\nclass rangeUpdateQuery{\n\tprivate:\n\t\tusing T = typename Monoid::T;\n\t\tMonoid op;\n\t\tconst int n;\n\t\tvector<T> dat, lazy;\n\t\tint query(int a, int b, int k, int l, int r){\n\t\t\tevaluate(k);\n\n\t\t\tif(b <= l || r <= a) return INT_MAX;\n\t\t\telse if(a <= l && r <= b) return dat[k];\n\t\t\telse{\n\t\t\t\tint vl = query(a, b, k * 2, l, (l + r) / 2);\n\t\t\t\tint vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\t\t\treturn min(vl, vr);\n\t\t\t}\n\t\t}\n\t\tinline void evaluate(int k){\n\t\t\tif(lazy[k] == op.identity()) return;\n\t\t\tdat[k] = lazy[k];\n\t\t\tif(k < n){\n\t\t\t\tlazy[2 * k] = lazy[k];\n\t\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = op.identity();\n\t\t}\n\t\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\t\tevaluate(k);\n\t\t\tif(r <= a || b <= l) return;\n\t\t\tif(a <= l && r <= b){\n\t\t\t\tlazy[k] = x;\n\t\t\t}else if(l < b && a < r){\n\t\t\t\tevaluate(k);\n\t\t\t\tupdate(a, b, k * 2, l, (l + r) / 2, x);\n\t\t\t\tupdate(a, b, k * 2 + 1, (l + r) / 2, r, x);\n\t\t\t}\n\t\t}\n\t\tint power(int n){\n\t\t\tint res = 1;\n\t\t\twhile(n >= res) res*=2;\n\t\t\treturn res;\n\t\t}\n\tpublic:\n\t\trangeUpdateQuery(int n) : n(power(n)), dat(4 * n, op.identity()), lazy(4 * n, op.identity()) {}\n\t\trangeUpdateQuery(const vector<T> &v) : n(v.size()), dat(4 * n), lazy(4 * n, op.identity()){\n\t\t\tcopy(begin(v), end(v), begin(dat) + n);\n\t\t\tfor(int i = n - 1; i > 0; i--) dat[i] = op(dat[2 * i], dat[2 * i + 1]);\n\t\t}\n\t\tint query(int a, int b){ return query(a,b,1,0,n); }\n\t\tvoid update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n\t\tint get(int a){ return query(a, a + 1); };\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\n\trangeUpdateQuery<RUQ> seg(n);\n\trep(i,q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(not com){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\t//cout << s << ' ' << t << endl;\n\t\t\tseg.update(s + 1, t + 2, x);\n\t\t}else{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tcout << seg.get(p + 1) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    const function<T (T, T)> f;     // 要素に適用する演算\n    const function<T (T, T)> g;     // 作用素の適用\n    const function<T (T, T)> h;     // 作用素の合成\n    const function<T (T, int)> p;\n    const T unit;\n    const T lazy_unit;\n\npublic:\n    class Mode {\n    public:\n        function<T (T, T)> f;\n        function<T (T, T)> g;\n        function<T (T, T)> h;\n        function<T (T, int)> p;\n        T unit;\n        T lazy_unit;\n    };\n\n    enum Query {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum Operation {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, const Mode mode) : array_size(v.size()),  f(mode.f), g(mode.g), h(mode.h), p(mode.p), unit(mode.unit), lazy_unit(mode.lazy_unit){\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, lazy_unit);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    static Mode getMode(const Query query, const Operation operation) {\n        Mode mode;\n        if (query == RangeMinimumQuery) {\n            mode.unit = INT_MAX;\n\n            mode.f = [](T a, T b) { return std::min(a, b); };\n            if (operation == Update) {\n                mode.lazy_unit = -1;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b; };\n                mode.h = mode.g;\n                mode.p = [&](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeMaximumQuery) {\n            mode.unit = -INT_MAX;\n\n            mode.f = [](T a, T b) { return std::max(a, b); };\n            if (operation == Update) {\n                mode.lazy_unit = -1;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeSummationQuery) {\n            mode.unit = 0;\n\n            mode.f = [](T a, T b) { return a + b; };\n            if (operation == Update) {\n                mode.lazy_unit = INT_MAX;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b;};\n                mode.h = mode.g;\n                mode.p = [&](T a, int len) {return a == mode.lazy_unit ? a : a * len;};\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b;};\n                mode.h = [](T a, T b) { return a + b;};\n                mode.p = [](T a, int len) {return a * len;};\n            }\n        }\n        return mode;\n    }\n\n    // array[idx]\n    // log(N)\n    T access(const int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // operation(array[idx], x)\n    // log(N)\n    void operation(const int idx, const T x) {\n        operation(idx, idx + 1, x);\n    }\n\n    // operation(array[left, right), x)\n    // log(N)\n    void operation(const int left, const int right, const T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        operation(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(const int left, const int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T operation(const int a, const int b, const T x, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = operation(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = operation(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(const int a, const int b, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (lazy[k] == lazy_unit) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazy[k] = lazy_unit;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1 , 2147483647);\n\n    auto mode = LazySegmentTree<LL>::getMode(LazySegmentTree<LL>::Query::RangeMinimumQuery, LazySegmentTree<LL>::Operation::Update);\n    LazySegmentTree<LL> lst(v, mode);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.operation(s, t + 1, x);\n        }\n        else {\n            cin >> i;\n            print(lst.access(i));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntemplate <typename T, typename E>\nstruct LazeSegTree {\n    // 0-indexed\n    typedef function<T(T, T)> F;\n    typedef function<T(T, E)> G;\n    typedef function<E(E, E)> H;\n    int n, height;\n    F f;    // クエリ処理の関数\n    G g;    // 遅延伝搬を反映させる関数\n    H h;    // 遅延処理の更新を行う関数\n    T ti;   // クエリ処理の単位元\n    E ei;   // 遅延配列の単位元\n    vector<T> dat;\n    vector<E> laz;\n    LazeSegTree(){}\n    LazeSegTree(F f, G g, H h, T ti, E ei): \n        f(f), g(g), h(h), ti(ti), ei(ei) {}\n    \n    // 全体を初期化\n    void init(int n_) {\n        n = 1, height = 0;\n        while(n < n_) n <<= 1, ++height;\n        dat.assign(n<<1, ti);\n        laz.assign(n<<1, ei);\n    }\n\n    // 初期配列をセグ木の葉に\n    void build(const vector<T> &v) {\n        int n_ = v.size();\n        init(n_);\n        for(int i = 0; i < n_; ++i) dat[n+i] = v[i];\n        for(int i = n-1; i; --i) dat[i] = f(dat[(i<<1)|0], dat[(i<<1)|1]);\n    }\n\n    // 遅延伝搬の処理を行う\n    inline T reflect(int k) {\n        return laz[k] == ei ? dat[k] : g(dat[k], laz[k]);\n    }\n\n    // 遅延を子ノードに伝搬\n    inline void propagate(int k) {\n        if(laz[k] == ei) return;\n        laz[(k<<1)|0] = h(laz[(k<<1)|0], laz[k]);\n        laz[(k<<1)|1] = h(laz[(k<<1)|1], laz[k]);\n        dat[k] = reflect(k);\n        laz[k] = ei;\n    }\n\n    inline void thrust(int k) {\n        for(int i = height; i; --i) propagate(k>>i);\n        dat[k] = reflect(k);\n        laz[k] = ei;\n    }\n\n    // クエリ処理をマージ\n    inline void recalc(int k) {\n        while(k >>= 1) dat[k] = f(reflect((k<<1)|0), reflect((k<<1)|1));\n    }\n\n    void update(int a, int b, E x) {\n        if(a >= b) return;\n        thrust(a += n);\n        thrust(b += n-1);\n        for(int l = a, r = b+1; l < r; l >>= 1, r >>= 1) {\n            if(l&1) laz[l] = h(laz[l], x), l++;\n            if(r&1) --r, laz[r] = h(laz[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    // buildをバラバラに行う\n    void set_val(int a, T x) {\n        thrust(a += n);\n        dat[a] = x; laz[a] = ei;\n        recalc(a);\n    }\n\n    T query(int a, int b) {\n        if(a >= b) return ti;\n        thrust(a += n);\n        thrust(b += n-1);\n        T vl = ti, vr = ti;\n        for(int l = a, r = b+1; l < r; l >>= 1, r >>= 1) {\n            if(l&1) vl = f(vl, reflect(l++));\n            if(r&1) vr = f(reflect(--r), vr);\n        }\n        return f(vl, vr);\n    }\n\n    template <typename C>\n    int find(int st, C &check, T &acc, int k, int l, int r) {\n        if(l+1 == r) {\n            acc = f(acc, reflect(k));\n            return check(acc) ? k-n : -1;\n        }\n        propagate(k);\n        int m = (l+r)>>1;\n        if(m <= st) return find(st, check, acc, (k<<1)|1, m, r);\n        if(st <= 1 && !check(f(acc, dat[k]))) {\n            acc = f(acc, dat[k]);\n            return -1;\n        }\n        int vl = find(st, check, acc, (k<<1)|0, l, m);\n        if(~vl) return vl;\n        return find(st, check, acc, (k<<1)|1, m, r);\n    }\n\n    template <typename C>\n    int find(int st, C &check) {\n        T acc = ti;\n        return find(st, check, acc, 1, 0, n);\n    }\n};\n\nconst ll INF = (1LL<<31)-1;\n\nint main() {\n    int n, q; cin >> n >> q;\n    auto f = [](P l, P r) { return P(l.first+r.first, l.second+r.second); };\n    auto g = [](P l, ll r) { return P(r, l.second); };\n    auto h = [](ll l, ll r) { return r; };\n\n    LazeSegTree<P, ll> lseg(f, g, h, P(0, 0), -1);\n    lseg.build(vector<P>(n, P(INF, 1)));\n\n    for(int i = 0; i < q; ++i) {\n        int c; cin >> c;\n        ll s, t, x;\n        if(c) {\n            cin >> s;\n            cout << lseg.query(s, s+1).first << endl;\n        }else {\n            cin >> s >> t >> x;\n            lseg.update(s, t+1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\n\nstruct RUQ{\n  ll size;\n  ll *tree;\n  vi history;\n  RUQ(ll sz){\n    ll logsize; for(logsize=0;(1ll<<logsize)<=sz;logsize++);\n    size=(1ll<<logsize);\n    tree=new ll[size*2-1]; REP(i, size*2-1) tree[i]=0;\n  }\n  void update(ll s,ll t,ll x){\n    ll id=history.size();\n    updatesub(s,t,0,size,0,id);\n    history.push_back(x);\n  }\n  void updatesub(ll s,ll t,ll l,ll r,ll k,ll id){\n    if(r<=s||t<=l||l>=r) return;\n    if(l+1==r) {tree[k]=id; return;}\n    if(s<=l&&r<=t) {tree[k]=id; return;}\n    ll mid=(l+r+1)/2;\n    updatesub(s,t,l,mid,k*2+1,id);\n    updatesub(s,t,mid,r,k*2+2,id);\n  }\n  ll find(ll i){\n    ll k=size+i-1;\n    ll recent=tree[k];\n    while(k>0){\n      k=(k-1)/2;\n      recent=max(recent,tree[k]);\n    }\n    return history[recent];\n  }\n};\n\nint main(){\n  ll n,q; cin>>n>>q;\n  RUQ ruq(n);\n  ruq.update(0,n,(1ll<<31)-1);\n  REP(i,q){\n    ll com;cin>>com;\n    if(com==0) {ll s,t,x; cin>>s>>t>>x; ruq.update(s,t+1,x);}\n    else {ll i; cin>>i; cout<<ruq.find(i)<<endl;}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 2147483647;\n\nstruct SegmentTree {\n    int n;\n    vector<int> heap;\n    vector<bool> isLazy;\n    \n    SegmentTree(int n): n(n) {\n        heap.assign(4 * n, INF);\n        isLazy.assign(4 * n, true);\n    }\n    \n    void update(int nodeId, int l, int r, int ql, int qr, int v) {\n        if (qr < l || ql > r) {\n            return;\n        }\n        else if (ql <= l && r <= qr) {\n            heap[nodeId] = v;\n            isLazy[nodeId] = true;\n        }\n        else {\n            pushdown(nodeId);\n            int m = l + (r - l)/2;\n            update(nodeId * 2, l, m, ql, qr, v);\n            update(nodeId * 2 + 1, m + 1, r, ql, qr, v);\n        }\n    }\n    \n    int query(int nodeId, int l, int r, int q) {\n        if (q < l || q > r) {\n            return -INF;\n        }\n        else if (isLazy[nodeId]) {\n            return heap[nodeId];\n        }\n        else {\n            int m = l + (r - l)/2;\n            return max(query(nodeId * 2, l, m, q), query(nodeId * 2 + 1, m + 1, r, q));\n        }\n    }\n    \n    void pushdown(int nodeId) {\n        //cout << \"push: \" << nodeId << endl;\n        if (isLazy[nodeId]) {\n            heap[nodeId * 2] = heap[nodeId];\n            heap[nodeId * 2 + 1] = heap[nodeId];\n            heap[nodeId] = -INF;\n            isLazy[nodeId] = false;\n        }\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int ql, qr, v;\n            cin >> ql >> qr >> v;\n            st.update(1, 0, n -1, ql, qr, v);\n//            for (int i = 0; i < 4 * n; i++) {\n//                cout << i << \":\" << st.heap[i] << endl; \n//            }\n        }\n        else {\n            int pos;\n            cin >> pos;\n            cout << st.query(1, 0, n-1, pos) << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<stdio.h>\n#include<fstream>\n#include<stdlib.h>\n#include<math.h> \n#include<queue>\n#include<string.h>\n#include<stack>\n\n\nusing namespace std;\n\n#define INF 2147483647\n\n\nint n=1;\nint A[300000];\nbool flag[300000];\nint lazy[300000];\n\nvoid init(int size){\n\n\twhile(n<size){\n\t\tn*=2;\n\t}\n\tfor(int i=0;i<2*n-1;i++){\n\t\tA[i]=INF;\n\t\tflag[i]=false;\n\t}\n}\n\nvoid eval(int k,int l,int r){\n\tif(flag[k]){\n\t\tA[k]=lazy[k];\n\t\tif(l+1<r){\n\t\t\tlazy[2*k+1]=lazy[2*k+2]=lazy[k];\n\t\t\tflag[2*k+1]=flag[2*k+2]=true;\n\t\t}\n\t\tflag[k]=false;\n\t}\n}\n\n\nvoid update(int x,int y,int a,int k=0,int l=0,int r=n){\n\teval(k,l,r);\n\tif(r<=x||y<=l){\n\t\treturn;\n\t}\n\tif(x<=l&&r<=y){\n\t\tflag[k]=true;\n\t\tlazy[k]=a;\n\t\teval(k,l,r);\n\t}\n\telse{\n\t\tupdate(x,y,a,2*k+1,l,(l+r)/2);\n\t\tupdate(x,y,a,2*k+2,(l+r)/2,r);\n        A[k]=min(A[2*k+1],A[2*k+2]);\n\t}\n}\n\n\nint query2(int x,int y,int k=0,int l=0,int r=n){\n\teval(k,l,r);\n\tif(r<=x||y<=l){\n\t\treturn INF;\n\t}\n    if(x<=l&&r<=y){\n    \treturn A[k];\n    }\n    int vl=query2(x,y,2*k+1,l,(l+r)/2);\n    int vr=query2(x,y,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n}\n\nint main(){\n\tint k;\n\tint q;\n\tcin>>k>>q;\n\tinit(k);\n\tint qu;\n\tint x,s,t;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>qu;\n\t\tif(qu==0){\n\t\t\tcin>>s>>t>>x;\n\t\t\tupdate(s,t+1,x);\n\t\t}\n\t\telse if(qu==1){\n\t\t\tcin>>x;\n\t\t\tcout<<query2(x,x+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")  //浮動小数点\n#include \"bits/stdc++.h\"\n//#include <intrin.h>  //AtCoder (gcc) 上ではこれがあると動かない。__popcnt用のincludeファイル。\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define int long long\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define sqrt(d) pow((long double) (d), 0.50)\n#define PII pair<int, int>\n#define MP make_pair\n\nconst int INF = 2000000000; //2e9\nconst long long INF2 = 1000000000000000000; //1e18\nconst long double pi = acos(-1);\n\nconstexpr int MOD = 1000000007; //1e9 + 7\n//constexpr int MOD = 1000000009; //1e9 + 9\n//constexpr int MOD = 998244353;\n\n\n\n\n//繰り返し2乗法\n//N^aの、Mで割った余りを求める。\nll my_pow(ll N, ll a, ll M) {\n\tll tempo;\n\tif (a == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tif (a % 2 == 0) {\n\t\t\ttempo = my_pow(N, a / 2, M);\n\t\t\treturn (tempo * tempo) % M;\n\t\t}\n\t\telse {\n\t\t\ttempo = my_pow(N, a - 1, M);\n\t\t\treturn (tempo * N) % M;\n\t\t}\n\t}\n}\n\nll my_pow(ll N, ll a) {\n\tll tempo;\n\tif (a == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tif (a % 2 == 0) {\n\t\t\ttempo = my_pow(N, a / 2);\n\t\t\treturn (tempo * tempo);\n\t\t}\n\t\telse {\n\t\t\ttempo = my_pow(N, a - 1);\n\t\t\treturn (tempo * N);\n\t\t}\n\t}\n}\n\n\n\n\n//N_C_a を M で割った余り\nll my_combination(ll N, ll a, ll M) {\n\tif (N < a) return 0;\n\n\tll answer = 1;\n\n\trep(i, a) {\n\t\tanswer *= (N - i);\n\t\tanswer %= M;\n\t}\n\n\trep(i, a) {\n\t\tanswer *= my_pow(i + 1, M - 2, M);\n\t\tanswer %= M;\n\t}\n\n\treturn answer;\n}\n\n\n//N_C_i を M で割った余りを、v.at(i) に代入する。\nvoid my_combination_table(ll N, ll M, vector<ll>& v) {\n\tv.assign(N + 1, 1);\n\n\tfor (ll i = 1; i <= N; i++) {\n\t\tv.at(i) = v.at(i - 1) * (N - (i - 1LL));\n\t\tv.at(i) %= M;\n\n\t\tv.at(i) *= my_pow(i, M - 2, M);\n\t\tv.at(i) %= M;\n\t}\n}\n\n\n//(N + i)_C_N を M で割った余りを、v.at(i) に代入する。(v のサイズに依存)\nvoid my_combination_table2(ll N, ll M, vector<ll>& v) {\n\tv.at(0) = 1;\n\n\tfor (ll i = 1; i < (ll)v.size(); i++) {\n\t\tv.at(i) = v.at(i - 1) * (N + i);\n\t\tv.at(i) %= M;\n\n\t\tv.at(i) *= my_pow(i, M - 2, M);\n\t\tv.at(i) %= M;\n\t}\n}\n\n\n\n\n//階乗。x ! まで計算する。結果は dp に保存する。20 ! = 2.43e18 まで long long に入る。\nll factorial(ll x, vector<ll>& dp) {\n\tif ((ll)dp.size() <= x) {\n\t\tint n = dp.size();\n\t\trep(i, x + 1 - n) {\n\t\t\tdp.push_back(0);\n\t\t}\n\t}\n\n\tif (x == 0) return dp.at(x) = 1;\n\tif (dp.at(x) != -1 && dp.at(x) != 0) return dp.at(x);\n\treturn dp.at(x) = x * factorial(x - 1, dp);\n}\n\n\n\n\n//階乗の M で割った余り。x ! まで計算する。結果は dp に保存する。\nll factorial2(ll x, ll M, vector<ll>& dp) {\n\tif ((ll)dp.size() <= x) {\n\t\tint n = dp.size();\n\t\trep(i, x + 1 - n) {\n\t\t\tdp.push_back(0);\n\t\t}\n\t}\n\n\tif (x == 0) return dp.at(x) = 1;\n\tif (dp.at(x) != -1 && dp.at(x) != 0) return dp.at(x);\n\tll tempo = (x * factorial2(x - 1, M, dp));\n\ttempo %= M;\n\treturn dp.at(x) = tempo;\n}\n\n\n\n\n//階乗の mod M での逆元 (M: prime)。x ! まで計算する。結果は dp に保存する。\nll factorial_inverse(ll x, ll M, vector<ll>& dp) {\n\tif ((ll)dp.size() <= x) {\n\t\tint n = dp.size();\n\t\trep(i, x + 1 - n) {\n\t\t\tdp.push_back(0);\n\t\t}\n\t}\n\n\tif (x == 0) return dp.at(x) = 1;\n\tif (dp.at(x) != -1 && dp.at(x) != 0) return dp.at(x);\n\treturn dp.at(x) = (my_pow(x, M - 2, M) * factorial_inverse(x - 1, M, dp)) % M;\n}\n\n\n\n\n//N_C_a を M で割った余り。何度も呼ぶ用。\nll my_combination2(ll N, ll a, ll M, vector<ll>& dp_factorial, vector<ll>& dp_factorial_inverse) {\n\tif ((ll)dp_factorial.size() <= N) {\n\t\tfactorial2(N, M, dp_factorial);\n\t}\n\tif ((ll)dp_factorial_inverse.size() <= N) {\n\t\tfactorial_inverse(N, M, dp_factorial_inverse);\n\t}\n\n\tif (N < a) return 0;\n\n\tll answer = 1;\n\tanswer *= dp_factorial.at(N);\n\tanswer %= M;\n\tanswer *= dp_factorial_inverse.at(N - a);\n\tanswer %= M;\n\tanswer *= dp_factorial_inverse.at(a);\n\tanswer %= M;\n\n\treturn answer;\n}\n\n\n\n\nlong long my_gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn my_gcd(b, a % b);\n}\n\n\n\n\n// ax + by = gcd(a, b) を解く。返り値は、gcd(a, b)。\nlong long my_gcd_extended(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1; y = 0;\n\t\treturn a;\n\t}\n\n\tlong long tempo = my_gcd_extended(b, a % b, y, x);\n\n\t//bx' + ry' = gcd(a, b) → (qb + r)x + by = gcd(a, b) に戻さないといけない。// (r = a % b)\n\t//b(x' - qy') + (bq + r)y' = gcd(a, b) と同値変形できるから、\n\t// x = y', y = x' - qy'\n\ty -= (a / b) * x;\n\n\treturn tempo;\n}\n\n\n\n\n// base を底としたときの、n の i桁目を、v.at(i) に入れる。(桁数は n に応じて自動で設定する。)\nvoid ll_to_vector(signed base, long long n, vector<signed>& v) {\n\tlong long tempo = n;\n\tlong long tempo2 = n;\n\n\tsigned n_digit = 1;\n\twhile (tempo2 >= base) {\n\t\ttempo2 /= base;\n\t\tn_digit++;\n\t}\n\n\tv.assign(n_digit, 0);   // v のサイズを適切に調整する場合。\n\n\t// n_digit = v.size();  // v のサイズをそのままにする場合。\n\n\tfor (signed i = 0; i < n_digit; i++) {\n\t\tlong long denominator = my_pow(base, n_digit - 1 - i);\n\n\t\tv.at(i) = tempo / denominator;\n\t\ttempo -= v.at(i) * denominator;\n\t}\n}\n\n\n\n\nint char_to_int(char c) {\n\tswitch (c) {\n\tcase '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4;\n\tcase '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9;\n\tdefault: return 0;\n\t}\n}\n\n\n\n\n//エラトステネスの篩で、prime で ないところに false を入れる。O(n loglog n)\nvoid prime_judge(vector<bool>& prime_or_not) {\n\tprime_or_not.assign(prime_or_not.size(), true);\n\n\tprime_or_not.at(0) = false;\n\tprime_or_not.at(1) = false;\n\n\tlong long n = prime_or_not.size() - 1;\n\n\tfor (long long i = 2; 2 * i <= n; i++) {\n\t\tprime_or_not.at(2 * i) = false;\n\t}\n\n\n\tfor (long long i = 3; i * i <= n; i += 2) {\n\t\t//ここからは奇数のみ探索。i の倍数に false を入れる。\n\t\tif (prime_or_not.at(i)) {\n\t\t\tlong long j = i * i;  // i^2 未満の i の倍数には、すでに false が入っているはず。\n\t\t\twhile (j < n + 1) {\n\t\t\t\tprime_or_not.at(j) = false;\n\t\t\t\tj += 2 * i;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n\n// n + 1 の サイズの vector を返す。res.at(i) には、i の 1 以外で最小の約数を入れる。res.at(i) == i なら i は素数。\n// 2e8 なら、3.2 秒程度で終わる。たぶん、prime_judge より 3倍弱遅い。\nvector<long long> sieve(long long n) {\n\tn++; // n まで判定する。配列サイズは +1。\n\n\tvector<long long> res(n, 0);\n\tfor (long long i = 1; i < n; i++) {\n\t\tif (i % 2 == 0) res.at(i) = 2;  // 偶数をあらかじめ処理。\n\t\telse res.at(i) = i;\n\t}\n\n\tfor (long long i = 3; i * i < n; i += 2) {\n\t\t//ここからは奇数のみ探索。i の倍数に i を入れる。\n\t\tif (res.at(i) == i) {\n\t\t\tlong long j = i * i;  // i^2 未満の i の倍数には、すでに最小の約数が入っているはず。\n\t\t\twhile (j < n) {\n\t\t\t\tif (res.at(j) == j) res.at(j) = i;\n\t\t\t\tj += 2 * i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\n\n\n//O (sqrt(n)) で素数判定する用。\nbool is_prime(long long N) {\n\tif (N == 1 || N == 0) return false;\n\tif (N == 2 || N == 3) return true;\n\n\tif (N % 2 == 0) return false;\n\tif (N % 3 == 0) return false;\n\n\tfor (long long i = 1; (6 * i + 1) * (6 * i + 1) <= N; ++i) {\n\t\tif (N % (6 * i + 1) == 0) return false;\n\t}\n\tfor (long long i = 0; (6 * i + 5) * (6 * i + 5) <= N; ++i) {\n\t\tif (N % (6 * i + 5) == 0) return false;\n\t}\n\treturn true;\n}\n\n\n\n\n//素因数分解を O(sqrt(N)) で行うための関数。\nmap<ll, ll> divide_to_prime(int target) {\n\tmap<ll, ll> res;\n\n\t//sqrt(target) まで調べる。\n\tll upper_lim = ceil(sqrt(target));\n\tvector<bool> prime_or_not(upper_lim + 3, true);\n\tif (upper_lim < 20) prime_or_not.assign(25, true);\n\n\tprime_or_not.at(0) = false; prime_or_not.at(1) = false;\n\tprime_judge(prime_or_not);\n\n\tll tempo = target;\n\tfor (int i = 1; i * i <= target; i++) {\n\t\tif (prime_or_not.at(i)) {\n\t\t\twhile (tempo % i == 0) {\n\t\t\t\ttempo /= i;\n\t\t\t\tres[i]++;\n\t\t\t}\n\t\t}\n\n\t\tif (tempo == 1) break;  //別に必要はない。\n\t}\n\n\tif (tempo != 1) res[tempo]++; //sqrt(target) より大きな素因数は高々1つしかない。\n\treturn res;\n}\n\n\n\n\n//関数 sieve で得た、vector min_factor を持ってるときに、素因数分解を高速で行うための関数。\nmap<long long, long long> divide_to_prime2(long long target, vector<long long>& min_factor) {\n\tmap<long long, long long> res;\n\tif (min_factor.empty() || (long long)min_factor.size() - 1 < target) min_factor = sieve(target);\n\n\twhile (target > 1) {\n\t\tres[min_factor[target]]++;\n\t\ttarget /= min_factor[target];\n\t}\n\n\treturn res;\n}\n\n\n\n\n//約数全列挙を O(sqrt(N)) で行うための関数。\nvector<long long> count_dividers(long long target) {\n\n\tvector <long long> dividers, tempo;\n\tlong long i = 1;\n\twhile (i * i < target + 1) {\n\t\tif (target % i == 0) {\n\t\t\tdividers.push_back(i);\n\t\t\tif (i < target / i) tempo.push_back(target / i);  // if節がないと、平方数の時、sqrt(target) がダブルカウントされる。\n\t\t}\n\t\ti++;\n\t}\n\n\tfor (long long j = 0; j < (long long)tempo.size(); j++) {\n\t\tdividers.push_back(tempo.at(tempo.size() - 1 - j));\n\t}\n\n\treturn dividers;\n}\n\n\n\n\n//関数 sieve で得た、vector min_factor を持ってるときに、約数全列挙を高速で行うための関数。\nvector<long long> count_dividers2(long long target, vector<long long>& min_factor) {\n\n\tvector <long long> dividers = { 1 };\n\tmap<long long, long long> memo = divide_to_prime2(target, min_factor);\n\n\tfor (auto&& iter = memo.begin(); iter != memo.end(); iter++) {\n\t\tvector <long long> tempo = dividers;\n\t\tfor (long long k = 0; k < (long long)tempo.size(); k++) {\n\t\t\tlong long times = 1;\n\t\t\tfor (long long j = 1; j <= (iter->second); j++) {\n\t\t\t\ttimes *= iter->first;\n\t\t\t\tdividers.push_back(tempo[k] * times);\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(dividers.begin(), dividers.end());  //sortしないと小さい順に並ばないが、必要ないなら消しても良い。\n\treturn dividers;\n}\n\n\n\n\nvoid BFS_labyrinth(queue<pair<int, int>>& que, vector<vector<int>>& dist, int& area) {\n\tint n = dist.size();\n\tint m = dist.at(0).size();\n\n\twhile (!que.empty()) {\n\t\tint h, w;\n\t\tpair<int, int> tempo = que.front(); que.pop();\n\n\t\th = tempo.first;\n\t\tw = tempo.second;\n\t\t//cout << temp_i << \" \" << temp_j << endl;\n\n\t\tfor (int dh = -1; dh <= 1; dh++) {\n\t\t\tfor (int dw = -1; dw <= 1; dw++) {\n\t\t\t\tif (h + dh < 0 || n <= h + dh) continue;  //範囲外\n\t\t\t\tif (w + dw < 0 || m <= w + dw) continue;  //範囲外\n\t\t\t\tif (dh == 0 && dw == 0) continue; //動いていない\n\t\t\t\tif (dh * dw != 0) continue; //右上など。八近傍の場合は消す。\n\t\t\t\tif (dist.at(h + dh).at(w + dw) != -1) continue; //行けない領域に、既に INF などが代入されている場合はこの条件だけで ok\n\n\t\t\t\tdist.at(h + dh).at(w + dw) = dist.at(h).at(w) + 1;\n\t\t\t\tque.push(make_pair(h + dh, w + dw));\n\t\t\t}\n\t\t}\n\n\t\t//何か所も領域がある場合だけ必要\n\t\tif (que.empty()) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, m) {\n\t\t\t\t\tif (dist.at(i).at(j) == -1) {\n\t\t\t\t\t\tque.push(make_pair(i, j));\n\t\t\t\t\t\tdist.at(i).at(j) = 0;\n\t\t\t\t\t\tarea++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!que.empty()) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nvoid BFS01_labyrinth(deque<pair<int, int>>& que, vector<vector<int>>& dist, vector<vector<int>>& cost) {\n\tint n = dist.size();\n\tint m = dist.at(0).size();\n\n\twhile (!que.empty()) {\n\t\tint h, w;\n\t\tpair<int, int> tempo = que.front(); que.pop_front();\n\n\t\th = tempo.first;\n\t\tw = tempo.second;\n\t\t//cout << temp_i << \" \" << temp_j << endl;\n\n\t\tfor (int dh = -1; dh <= 1; dh++) {\n\t\t\tfor (int dw = -1; dw <= 1; dw++) {\n\t\t\t\tif (h + dh < 0 || n <= h + dh) continue;  //範囲外\n\t\t\t\tif (w + dw < 0 || m <= w + dw) continue;  //範囲外\n\t\t\t\tif (dh == 0 && dw == 0) continue; //動いていない\n\t\t\t\tif (dh * dw != 0) continue; //右上など。八近傍の場合は消す。\n\t\t\t\tif (dist.at(h + dh).at(w + dw) != -1) continue; //行けない領域に、既に INF などが代入されている場合はこの条件だけで ok\n\n\t\t\t\tdist.at(h + dh).at(w + dw) = dist.at(h).at(w) + cost.at(h + dh).at(w + dw);\n\n\t\t\t\tif (cost.at(h + dh).at(w + dw) == 0) {//コストが低い場合\n\t\t\t\t\tque.push_front(make_pair(h + dh, w + dw));\n\t\t\t\t}\n\t\t\t\telse {//コストが高い場合\n\t\t\t\t\tque.push_back(make_pair(h + dh, w + dw));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nvoid dfs(const vector<vector<int>>& G, vector<bool>& seen, int v) {\n\tseen.at(v) = true;\n\n\tfor (int next_v : G.at(v)) {\n\t\tif (seen.at(next_v)) continue;\n\t\tdfs(G, seen, next_v);\n\t}\n}\n\n\n\n\nclass edge {\npublic:\n\tint to;\n\tint cost;\n};\n\nvoid dijkstra(int s, const vector<vector<edge>> G, vector<int>& dist) {\n\tint V = dist.size(); //頂点数\n\tdist.assign(V, INF);\n\n\t//first が最短距離、second が頂点番号。\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n\tdist.at(s) = 0; que.push(make_pair(0, s));\n\n\twhile (!que.empty()) {\n\t\tpair<int, int> p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (dist.at(v) < p.first) continue;  //最短距離がすでに更新されているので無視。\n\n\t\tfor (int i = 0; i < (int)G.at(v).size(); i++) {\n\t\t\tedge e = G.at(v).at(i);\n\t\t\t//for (auto&& e : G.at(v)) {  // ← なぜか、やや遅いので。\n\t\t\tif (dist.at(e.to) > dist.at(v) + e.cost) {\n\t\t\t\tdist.at(e.to) = dist.at(v) + e.cost;\n\t\t\t\tque.push(make_pair(dist.at(e.to), e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int Vmax2 = 1;\nint dp_warshall[Vmax2][Vmax2];\n\n//G.at(i).at(j) は i から j への移動コスト。隣接行列。\nvoid warshall_floyd(int V, const vector<vector<int>> G) {\n\trep(i, V) {\n\t\trep(j, V) {\n\t\t\tdp_warshall[i][j] = G.at(i).at(j);  //初期化\n\t\t}\n\t}\n\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tdp_warshall[i][j] = min(dp_warshall[i][j], dp_warshall[i][k] + dp_warshall[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nclass UnionFind {\npublic:\n\tvector<int> parent;\n\tvector<int> rank;\n\tvector<int> v_size;\n\n\tUnionFind(int N) : parent(N), rank(N, 0), v_size(N, 1) {\n\t\trep(i, N) {\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\n\tint root(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = root(parent[x]); //経路圧縮\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\n\t\tif (rx == ry) return; //xの根とyの根が同じなので、何もしない。\n\t\tif (rank[rx] < rank[ry]) {\n\t\t\tparent[rx] = ry;\n\t\t\tv_size[ry] += v_size[rx];\n\t\t}\n\t\telse {\n\t\t\tparent[ry] = rx;\n\t\t\tv_size[rx] += v_size[ry];\n\t\t\tif (rank[rx] == rank[ry]) rank[rx]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn (root(x) == root(y));\n\t}\n\n\tint count_tree() {\n\t\tint N = parent.size();\n\t\tint res = 0;\n\n\t\trep(i, N) {\n\t\t\tif (root(i) == i) res++;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tint size(int x) {\n\t\treturn v_size[root(x)];\n\t}\n};\n\n\n\n\nclass wUnionFind {\npublic:\n\tvector<int> parent;\n\tvector<int> diff_weight; //親との差分。\n\tvector<int> rank;\n\n\twUnionFind(int N) : parent(N), diff_weight(N, 0), rank(N, 0) {\n\t\trep(i, N) {\n\t\t\tparent.at(i) = i;\n\t\t}\n\t}\n\n\tint root(int x) {\n\t\tif (parent.at(x) == x) return x;\n\n\t\tint r = root(parent.at(x));\n\t\tdiff_weight.at(x) += diff_weight.at(parent.at(x)); //累積和\n\t\treturn parent.at(x) = r;\n\t}\n\n\t//x の重みを出力する関数。\n\tint weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight.at(x);\n\t}\n\n\t//weight.at(y) - weight.at(x) == w となるようにする。\n\tbool unite(int x, int y, int w) {\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\tint diff_weight_to_ry_from_rx = w + weight(x) - weight(y);\n\n\t\tif (rx == ry) return false; //xの根とyの根が同じなので、何もしない。\n\t\tif (rank.at(rx) < rank.at(ry)) {\n\t\t\tparent.at(rx) = ry;\n\t\t\tdiff_weight.at(rx) = -diff_weight_to_ry_from_rx;\n\t\t}\n\t\telse {\n\t\t\tparent.at(ry) = rx;\n\t\t\tdiff_weight.at(ry) = diff_weight_to_ry_from_rx;\n\t\t\tif (rank.at(rx) == rank.at(ry)) rank.at(rx)++;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn (root(x) == root(y));\n\t}\n\n\tint count_tree() {\n\t\tint N = parent.size();\n\t\tint res = 0;\n\n\t\trep(i, N) {\n\t\t\tif (root(i) == i) res++;\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\n\n\n\nclass SegmentTree {\npublic:\n\tint ini = INF;\n\tint Size;  //対象の配列サイズ以上の2冪。\n\tvector<int> node;\n\n\tSegmentTree(int N) : Size(N), node(N) { initialize(N); }\n\tSegmentTree(int N, int ini) : ini(ini), Size(N), node(N) { initialize(N); }\n\tSegmentTree(vector<int> v) : Size(v.size()), node(v.size()) { initialize(v); }\n\tSegmentTree(vector<int> v, int ini) : ini(ini), Size(v.size()), node(v.size()) { initialize(v); }\n\n\n\t//初期化\n\tvoid initialize(int N) {\n\t\tint new_N = 1;\n\t\twhile (new_N < N) new_N *= 2;\n\n\t\tSize = new_N;\n\t\tnode.assign(2 * Size - 1, ini);\n\t}\n\n\t//初期化\n\tvoid initialize(vector<int> v) {\n\t\tint new_N = 1;\n\t\twhile (new_N < (int)v.size()) new_N *= 2;\n\n\t\tSize = new_N;\n\t\tnode.assign(2 * Size - 1, ini);\n\n\t\t//葉の初期化 (nodeの後ろに入れる, 二分木の一番下)\n\t\tfor (int i = 0; i < (int)v.size(); i++) node.at(Size - 1 + i) = v.at(i);\n\n\t\t//上りながら初期化 (0-indexedの場合、例えば、3 の子は、7, 8)\n\t\t//!!!!!!!!!!!!!問題に合わせて定義する!!!!!!!!!!!!!\n\t\tfor (int i = Size - 2; i >= 0; i--) {\n\t\t\tnode.at(i) = min(node.at(2 * i + 1), node.at(2 * i + 2));\n\t\t}\n\t}\n\n\t\n\t// k 番目の値 (0-indexed) を x に変更する。\n\tvoid update(int k, int x) {\n\t\t//葉のノードの番号 (等比数列の和の公式)\n\t\tk += Size - 1;\n\t\tnode.at(k) = x;\n\n\t\t//上りながら更新 (0-indexedの場合、例えば、3 の子は、7, 8)\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\n\t\t\t//子の最小値を親の最小値とする。\n\t\t\t//!!!!!!!!!!!!!問題に合わせて定義する!!!!!!!!!!!!!\n\t\t\tnode.at(k) = min(node.at(k * 2 + 1), node.at(k * 2 + 2));\n\t\t}\n\t}\n\n\n\t//[a, b) の、例えば最小値を計算する。[l, r) は、ノード k に対応する区間を与える。\n\t//query_sub(a, b, 0, 0, Size) で呼べばよい。\n\t//!!!!!!!!!!!!!問題に合わせて定義する!!!!!!!!!!!!!\n\tint query_sub(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return ini;  // 交差しない。\n\t\tif (a <= l && r <= b) return node.at(k); // 完全に含む。\n\t\telse {\n\t\t\tint vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\n\t}\n\n\t//[a, b) の、例えば最小値を計算する。\n\tint query(int a, int b) {return query_sub(a, b, 0, 0, Size);}\n};\n\n\n\n\n//転倒数を返す (comp = less_equal<int>() の場合)。\n//comp = greater<int>() の場合は、N_C_2 - 転倒数 を返すことになる。\nint my_merge(vector<int>& A, vector<int>& B, int left, int mid, int right, function <bool(int, int)> comp) {\n\tint i = left; //Aを分割したときの、左側の配列を差す添え字。\n\tint j = mid;  //Aを分割したときの、右側の配列を差す添え字。\n\tint k = 0;  //分割した後の配列 (一時的に) B に保存。\n\n\tint res = 0;\n\n\twhile (i < mid && j < right) {\n\t\tif (comp(A.at(i), A.at(j))) B.at(k++) = A.at(i++);\n\t\telse {\n\t\t\tB.at(k++) = A.at(j++);\n\t\t\tres += mid - i;\n\t\t}\n\t}\n\n\t//左側をBに移動し尽くしたので、右側を順に入れていく。\n\tif (i == mid) {\n\t\twhile (j < right) {\n\t\t\tB.at(k++) = A.at(j++);\n\t\t}\n\t}\n\telse { //右側をBに移動し尽くしたので、左側を順に入れていく。\n\t\twhile (i < mid) {\n\t\t\tB.at(k++) = A.at(i++);\n\t\t}\n\t}\n\n\t//Aに値を戻す。\n\trep(l, k) {\n\t\tA.at(left + l) = B.at(l);\n\t}\n\n\treturn res;\n}\n\n\nint my_merge_sort(vector<int>& target, vector<int>& tempo, int left, int right, function <bool(int, int)> comp) {\n\n\tint mid, res = 0;\n\tif (left == right || left == right - 1) return res;\n\n\tmid = (left + right) / 2;\n\tres += my_merge_sort(target, tempo, left, mid, comp);\n\tres += my_merge_sort(target, tempo, mid, right, comp);\n\tres += my_merge(target, tempo, left, mid, right, comp);\n\treturn res;\n}\n\n\nint my_merge_sort(vector<int>& target, vector<int>& tempo, int left, int right) {\n\treturn my_merge_sort(target, tempo, left, right, less_equal<int>());\n}\n\n\n\n\n\nld calc_dist(int x1, int x2, int y1, int y2) {\n\tint tempo = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\tld res = sqrt((ld)tempo);\n\treturn res;\n}\n\n\n\n\n//next[i][v] → 頂点 v の 2^i 先。\n//next.at(i).at(j) = next.at(i - 1).at(next.at(i - 1).at(j));\nint doubling(vector<vector<int>> next, int v, int N) {\n\tvector<signed> memo;\n\tll_to_vector(2, N, memo);\n\n\tint M = 0;\n\tM = memo.size();  //上と下のどちらか。上の方が計算量的には有利。\n\t//M = next.size();\n\n\tint now = v;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (N & (int)(1LL << i)) {\n\t\t\tnow = next.at(i).at(now);\n\t\t\t//cout << (int)(1LL << i) << endl;\n\t\t}\n\t}\n\n\treturn now;\n}\n\n\n\n\n//ラングレス圧縮\nvector<pair<int, char>> compress(string S) {\n\tint N = S.size();\n\tvector<pair<int, char>> memo;\n\n\tint tempo = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (i != N - 1) {\n\t\t\tif (S.at(i) == S.at(i - 1)) tempo++;\n\t\t\telse {\n\t\t\t\tmemo.push_back(MP(tempo, S.at(i - 1)));\n\t\t\t\ttempo = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (S.at(i) == S.at(i - 1)) {\n\t\t\t\ttempo++;\n\t\t\t\tmemo.push_back(MP(tempo, S.at(i - 1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmemo.push_back(MP(tempo, S.at(i - 1)));\n\t\t\t\tmemo.push_back(MP(1, S.at(i)));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo;\n}\n\n\n\n\n//平方分割\nclass SqrtDecomposition {\npublic:\n\tint ini = my_pow(2, 31) - 1;  //初期値\n\n\tint N = 1;  //元の配列のサイズ (data)\n\tint width = 1; // ~ sqrt(N)\n\tint size = 1;  // 平方分割した後の、bucket vector のサイズ。\n\n\tvector<int> data;  //対象の配列\n\tvector<int> bucket;  //平方分割した後のバケット\n\n\t//コンストラクタ\n\tSqrtDecomposition(int N) : N(N), width(sqrt(N)), data(N) {\n\t\tsize = N / width + 1;\n\t\tif (N % width == 0) size--;\n\t\tdata.assign(N, ini);\n\t\tbucket.assign(size, ini);\n\t}\n\n\tSqrtDecomposition(vector<int> data) : N((int)data.size()), width(sqrt((int)data.size())), data(data) {\n\t\tsize = N / width + 1;\n\t\tif (N % width == 0) size--;\n\t\tbucket.assign(size, ini);\n\t\tinitialize();\n\t}\n\n\t//ベクトルと、問題に合わせた初期値でコンストラクト。\n\tSqrtDecomposition(vector<int> data, int ini) : ini(ini), N((int)data.size()), width(sqrt((int)data.size())), data(data) {\n\t\tsize = N / width + 1;\n\t\tif (N % width == 0) size--;\n\t\tbucket.assign(size, ini);\n\t\tinitialize();\n\t}\n\n\n\t//バケットの初期化\n\tvoid initialize() {\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tCalcBucket(i);\n\t\t}\n\t}\n\n\n\t//data[n] を x に変更\n\tvoid update(int n, int x) {\n\t\tdata[n] = x;\n\t\tint tempo = n / width;\n\t\tCalcBucket(tempo);\n\t}\n\n\n\t//区間に対する更新クエリ (足す場合)\n\t//問題に応じて定義する。\n\tvoid add(int l, int r, int x) {\n\t\tint lb = l / width + 1;\n\t\tif (l % width == 0) lb--;\n\t\tint rb = r / width;\n\n\t\tif (lb < rb) {\n\t\t\tfor (int i = lb; i < rb; i++) {\n\t\t\t\tbucket[i] += x;\n\t\t\t}\n\t\t\tfor (int i = l; i < lb * width && i < r; i++) {\n\t\t\t\tdata[i] += x;\n\t\t\t}\n\t\t\tfor (int i = max(rb * width, l); i < r; i++) {\n\t\t\t\tdata[i] += x;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = l; i < r; i++) {\n\t\t\t\tdata[i] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//findクエリ (最小値の場合)。[l, r)\n\t//問題に応じて定義する。\n\tint find(int l, int r) {\n\t\tint lb = l / width + 1;\n\t\tif (l % width == 0) lb--;\n\t\tint rb = r / width;\n\n\t\tint res = ini;\n\t\tif (lb < rb) {\n\t\t\tfor (int i = lb; i < rb; i++) {\n\t\t\t\tres = min(res, bucket[i]);\n\t\t\t}\n\t\t\tfor (int i = l; i < lb * width && i < r; i++) {\n\t\t\t\tres = min(res, data[i]);\n\t\t\t}\n\t\t\tfor (int i = max(rb * width, l); i < r; i++) {\n\t\t\t\tres = min(res, data[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = l; i < r; i++) {\n\t\t\t\tres = min(res, data[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\n\t//n番目のバケットを計算 (最小値の場合)\n\t//問題に応じて定義する。\n\tvoid CalcBucket(int n) {\n\t\tbucket[n] = ini;\n\t\tfor (int i = n * width; i < (n + 1) * width && i < N; i++) {\n\t\t\tbucket[n] = min(bucket[n], data[i]);\n\t\t}\n\t}\n\n\n\t//デバッグ用。表示。\n\tvoid DataShow() {\n\t\trep(i, N) cout << data[i] << endl;\n\t}\n\n\tvoid BucketShow() {\n\t\trep(i, size) cout << bucket[i] << endl;\n\t}\n\n};\n\n\n\n\nclass SegmentTree_RUQ_and_RMQ {\npublic:\n\tint ini = INF;\n\tint Size;  //対象の配列サイズ以上の2冪。\n\tvector<int> node;\n\tvector<int> lazy;\n\n\tSegmentTree_RUQ_and_RMQ(int N) : Size(N), node(N) { initialize(N); }\n\tSegmentTree_RUQ_and_RMQ(int N, int ini) : ini(ini), Size(N), node(N) { initialize(N); }\n\tSegmentTree_RUQ_and_RMQ(vector<int> v) : Size(v.size()), node(v.size()) { initialize(v); }\n\tSegmentTree_RUQ_and_RMQ(vector<int> v, int ini) : ini(ini), Size(v.size()), node(v.size()) { initialize(v); }\n\n\n\t//初期化\n\tvoid initialize(int N) {\n\t\tint new_N = 1;\n\t\twhile (new_N < N) new_N *= 2;\n\n\t\tSize = new_N;\n\t\tnode.assign(2 * Size - 1, ini);\n\t\tlazy.assign(2 * Size - 1, ini);\n\t}\n\n\t//初期化\n\tvoid initialize(vector<int> v) {\n\t\tint new_N = 1;\n\t\twhile (new_N < (int)v.size()) new_N *= 2;\n\n\t\tSize = new_N;\n\t\tnode.assign(2 * Size - 1, ini);\n\t\tlazy.assign(2 * Size - 1, ini);\n\n\t\t//葉の初期化 (nodeの後ろに入れる, 二分木の一番下)\n\t\tfor (int i = 0; i < (int)v.size(); i++) node.at(Size - 1 + i) = v.at(i);\n\n\t\t//上りながら初期化 (0-indexedの場合、例えば、3 の子は、7, 8)\n\t\t//!!!!!!!!!!!!!問題に合わせて定義する!!!!!!!!!!!!!\n\t\tfor (int i = Size - 2; i >= 0; i--) {\n\t\t\tnode.at(i) += min(node.at(2 * i + 1), node.at(2 * i + 2));\n\t\t}\n\t}\n\n\n\t//evaluate。配列の k番目 (0-indexed) を更新\n\tvoid eval(int k) {\n\t\tif (lazy.at(k) == ini) return;  //更新するものがないので終了。\n\n\t\t//葉でなければ子に伝搬。\n\t\tif (k < Size - 1) {\n\t\t\tlazy.at(k * 2 + 1) = lazy.at(k);\n\t\t\tlazy.at(k * 2 + 2) = lazy.at(k);\n\t\t}\n\n\t\t//自身を更新\n\t\tnode.at(k) = lazy.at(k);\n\t\tlazy.at(k) = ini;\n\t}\n\n\n\t//[a, b) を x に更新する。[l, r) は、ノード k に対応する区間を与える。\n\tvoid update_sub(int a, int b, int x, int k, int l, int r) {\n\t\teval(k); // 前回更新の処理。\n\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\t// 完全に含む。\n\t\t\tlazy.at(k) = x; \n\t\t\teval(k);\n\t\t}\n\t\telse {\n\t\t\tupdate_sub(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate_sub(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\t\t//!!!!!!!!!!!!!問題に合わせて定義する!!!!!!!!!!!!!\n\t\t\tnode.at(k) = min(node.at(k * 2 + 1), node.at(k * 2 + 2));\n\t\t}\n\n\t}\n\n\tvoid update(int a, int b, int x) { update_sub(a, b, x, 0, 0, Size); }\n\n\n\t//[a, b) の、例えば最小値を計算する。[l, r) は、ノード k に対応する区間を与える。\n\t//query_sub(a, b, 0, 0, Size) で呼べばよい。\n\t//!!!!!!!!!!!!!問題に合わせて定義する!!!!!!!!!!!!!\n\tint query_sub(int a, int b, int k, int l, int r) {\n\t\teval(k);\n\t\tif (r <= a || b <= l) return ini;  // 交差しない。\n\t\tif (a <= l && r <= b) return node.at(k); // 完全に含む。\n\t\telse {\n\t\t\tint vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\n\t}\n\n\t//[a, b) の、例えば最小値を計算する。\n\tint query(int a, int b) { return query_sub(a, b, 0, 0, Size); }\n\n\n\n\tvoid node_show() {\n\t\tcout << endl;\n\t\tfor (int i = 0; i < Size - 1; i++) cout << node[i] << endl;\n\t\tcout << endl;\n\t\tfor(int i = Size - 1; i < 2 * Size - 1; i++) cout << node[i] << endl;\n\t}\n};\n\n\n\n\nsigned main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\n\tint M = (1LL << 31) - 1;\n\tSegmentTree_RUQ_and_RMQ tree(N, M);\n\n\trep(q, Q) {\n\t\tint com;\n\t\tcin >> com;\n\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\ttree.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint i; cin >> i;\n\t\t\tint res = tree.query(i, i + 1);\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\t//tree.node_show();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: barish21\nLANG: C++14\nTASK: test\n*/\n\n/****Author: Barish Namazov****/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/***TEMPLATE***/\n#define intt long long\n\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n\n#define F first\n#define S second\n#define pb push_back\n\n#define IO ios_base::sync_with_stdio(false);cin.tie();\n\nconst intt max4 = 10004;\nconst intt maxx = 100005;\nconst intt max6 = 1000006;\nconst intt max7 = 10000007;\n\nconst intt lg4 = 13;\nconst intt lg5 = 17;\nconst intt lg6 = 20;\n\nconst intt INF = 2LL * 1000000000;\n/***************/\n\n/***Additional Functions***/\n\nintt powmod (intt a, intt b, intt mod) {\n    intt res = 1;\n    a %= mod;\n    for (; b; b >>= 1) {\n        if (b & 1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n    }\n    return res;\n}\n\nintt gcd (intt a, intt b) {\n    while (b > 0) {\n        intt t = a % b;\n        a = b, b = t;\n    }\n    return a;\n}\n\nintt lcm (intt a, intt b) {\n    return (a / gcd (a, b)) * b;\n}\n\nintt is_prime (intt n) {\n    if (n <= 1 || n > 3 && (n % 2 == 0 || n % 3 == 0))\n        return 0;\n    for (intt i = 5, t = 2; i * i <= n; i += t, t = 6 - t)\n        if (n % i == 0)\n            return 0;\n    return 1;\n}\n\n/**************************/\n\nconst intt initt = (1 << 31) - 1;\n\nintt n, q;\nintt t[maxx << 2], lazy[maxx << 2];\n\nvoid init () {\n    memset (lazy, -1, sizeof (lazy));\n}\n\nvoid relax (intt v, intt l, intt r) {\n    t[v] = (r - l + 1) * lazy[v];\n    if (l != r)\n        lazy[v << 1] = lazy[v << 1 | 1] = lazy[v];\n    lazy[v] = -1;\n}\n\nvoid build (intt v, intt l, intt r) {\n    if (l == r) {\n        t[v] = initt;\n        return;\n    }\n    intt mid = (l + r) >> 1;\n    build (v << 1, l, mid);\n    build (v << 1 | 1, mid + 1, r);\n    t[v] = t[v << 1] + t[v << 1 | 1];\n}\n\nvoid update (intt v, intt l, intt r, intt i, intt j, intt val) {\n    if (lazy[v] != -1)\n        relax (v, l, r);\n    if (j < l || i > r)\n        return;\n    if (i <= l && r <= j) {\n        lazy[v] = val;\n        relax (v, l, r);\n        return;\n    }\n    intt mid = (l + r) >> 1;\n    update (v << 1, l, mid, i, j, val);\n    update (v << 1 | 1, mid + 1, r, i, j, val);\n    t[v] = t[v << 1] + t[v << 1 | 1];\n}\n\nintt query (intt v, intt l, intt r, intt i, intt j) {\n    if (j < l || i > r)\n        return 0;\n    if (lazy[v] != -1)\n        relax (v, l, r);\n    if (i <= l && r <= j)\n        return t[v];\n    intt mid = (l + r) >> 1;\n    return query (v << 1, l, mid, i, j) +\n           query (v << 1 | 1, mid + 1, r, i, j);\n}\n\nint main() {\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    //ofstream fout (\"test.out\");\n    //ifstream fin (\"test.in\");\n    IO;\n    cin >> n >> q;\n    while (q --) {\n        intt type, i, j, val;\n        cin >> type;\n        if (type == 0)\n            cin >> i >> j >> val, i ++, j ++, update (1, 1, n, i, j, val);\n        else\n            cin >> i, i ++, cout << query (1, 1, n, i, i) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[105000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\tint k = node;\n\t\tint ope;\n\t\tif (node % 2 == 0)ope = 0;\n\t\telse ope = 1;\n\n\t\tnode /= 2;\n\t\twhile (node > 0) {\n\t\t\tif (m[node] != -INF) {\n\t\t\t\tif (ope == 0)m[2 * node + 1] = m[node];\n\t\t\t\telse m[2 * node] = m[node];\n\t\t\t}\n\t\t\tm[node] = -INF;\n\t\t\tif (node % 2 == 0)ope = 0;\n\t\t\telse ope = 1;\n\t\t\tnode /= 2;\n\t\t}\n\t\treturn;\n\t}\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{\n\tcin >> n >> q;\n\n\tn=init(n);\n\n\tint a, s, t, x, k;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> k;\n\t\t\tcout << find(k) << endl;\n\t\t}\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int,int>;\n\nstruct RUQ{\n\tint n,seg,init,now;\n\tvector<P> dat;\n\tRUQ(int n,int init) : n(n),init(init),seg(1),now(0){\n\t\twhile(seg < n) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = P(-1,init);\n\t}\n\tvoid update(int a,int b,int x,int tim,int k = 0,int l = 0,int r = -1){\n\t\tif(r == -1) r = seg;\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdat[k] = P(tim,x);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,x,tim,k * 2 + 1,l,(l + r) / 2);\n\t\tupdate(a,b,x,tim,k * 2 + 2,(l + r) / 2,r);\n\t}\n\tvoid update(int a,int b,int x){\n\t\tupdate(a,b,x,now++);\n\t}\n\tP get(int i){\n\t\ti += seg - 1;\n\t\tP ret = dat[i];\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tret = max(ret,dat[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main(){\n\tint n,q;\n\tcin >> n >> q;\n\tRUQ ruq(n,(1ll << 31) - 1);\n\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(!t){\n\t\t\tint a,b,x;\n\t\t\tcin >> a >> b >> x;\n\t\t\truq.update(a,b + 1,x);\n\t\t}\n\t\telse{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << ruq.get(x).second << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\ntemplate< typename Monoid, typename OperatorMonoid, typename F, typename G, typename H >\nstruct LazySegmentTree {\n  // std::function は遅いので使わないことを推奨\n  //using F = function< Monoid(Monoid, Monoid) >;\n  //using G = function< Monoid(Monoid, OperatorMonoid) >;\n  //using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  int sz, height;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n\n  // n: サイズ\n  // f: 二つの区間をマージする二項演算\n  // g: 要素と作用素をマージする二項演算\n  // h: 作用素同士をマージする二項演算\n  // M1: モノイドの単位元\n  // OM0: 作用素の単位元\n\n  // 初期化を忘れない！x を初期値とすると\n  // REP(i, n) seg[i].set(x);\n  // seg.build();\n\n  // 初期化なしだとM1で初期化される\n  // range sum をするときは，M1は(0, 0)だが初期化は(0, 1)であることに注意！\n\n  LazySegmentTree(int n, const F f, const G g, const H h,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while(sz < n) sz <<= 1, height++;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(int k, const Monoid &x) {\n    data[k + sz] = x;\n  }\n\n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n\n  inline void propagate(int k) {\n    if(lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline Monoid reflect(int k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(int k) {\n    while(k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  Monoid query(int a, int b) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    Monoid L = M1, R = M1;\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) L = f(L, reflect(l++));\n      if(r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k + 1);\n  }\n\n  template< typename C >\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while(a < sz) {\n      propagate(a);\n      Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n      if(check(nxt)) a = 2 * a + type;\n      else M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n  template< typename C >\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if(a <= 0) {\n      if(check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    thrust(a + sz);\n    int b = sz;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) {\n        Monoid nxt = f(L, reflect(a));\n        if(check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n\n  template< typename C >\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if(b >= sz) {\n      if(check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    thrust(b + sz - 1);\n    int a = sz;\n    for(b += sz; a < b; a >>= 1, b >>= 1) {\n      if(b & 1) {\n        Monoid nxt = f(reflect(--b), R);\n        if(check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, q;\n    cin >> n >> q;\n\n    //ll M1 = (1ll<<60); // min の単位元\n    ll M1 = (1ll<<31)-1; // verify用\n    ll OM0 = -1; // update query に出てこない数字なら何でもOK，\n    auto f = [](ll x, ll y){return min(x, y);};\n    // 使わないので何でもいいように見えるが，実は x+y とかだとダメ (seg[idx] で失敗する)．\n    // range sum 素直には遅延セグ木に乗らないことが原因だと思われる．min とかにしとくのが無難．\n    auto g = [](ll x, ll a){return (a==-1 ? x : a);};\n    auto h = [](ll a, ll b){return (b==-1 ? a : b);};\n    LazySegmentTree<ll, ll, decltype(f), decltype(g), decltype(h)> seg(n, f, g, h, M1, OM0);\n\n    while(q--){\n    \tll Q;\n    \tcin >> Q;\n    \tif(Q){\n    \t\tll idx;\n    \t\tcin >> idx;\n    \t\tcout << seg[idx] << endl;\n    \t}else{\n    \t\tll s, t, x;\n    \t\tcin >> s >> t >> x;\n    \t\tseg.update(s, t+1, x);\n    \t}\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int sqrtN = 512;\n\nstruct SqrtDecomposition {\n    int N, K;\n    vector<int> data;\n    vector<bool> lazyFlag;\n    vector<int> lazyUpdate;\n\n    explicit SqrtDecomposition(const vector<int> &v) : N(v.size()) {\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(K * sqrtN, 0);\n        for (int i = 0; i < v.size(); ++i) {\n            data[i] = v[i];\n        }\n        lazyFlag.assign(K, false);\n        lazyUpdate.assign(K, 0);\n    }\n\n    // [s, t) = x\n    void update(int s, int t, int x) {\n        for (int k = 0; k < K; ++k) {\n            int l = k * sqrtN, r = (k + 1) * sqrtN;\n            if (r <= s || t <= l) {\n                continue;\n            }\n            if (s <= l && r <= t) {\n                lazyFlag[k] = true;\n                lazyUpdate[k] = x;\n            } else {\n                eval(k);\n                for (int i = max(s, l); i < min(t, r); ++i) {\n                    data[i] = x;\n                }\n            }\n        }\n    }\n\n    int find(int i) {\n        int k = i / sqrtN;\n        eval(k);\n        return data[i];\n    }\n\nprivate:\n    void eval(int k) {\n        if (lazyFlag[k]) {\n            lazyFlag[k] = false;\n            for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n                data[i] = lazyUpdate[k];\n            }\n        }\n    }\n\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> v(N, (1LL << 31) - 1);\n    SqrtDecomposition sd(v);\n    while (Q--) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            sd.update(s, t + 1, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << sd.find(i) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long INF = (1ll<<31)-1;\n\ntemplate<typename T>\nclass lazy_segment_tree{\n\tint n;\n\tT fval;\n\tvector<T> dat, lazy;\n\tvector<bool> lazyFlag;\n\t\npublic:\n\t\n\tlazy_segment_tree(){\n\t\t\n\t}\n\t\n\tlazy_segment_tree(int n_, T val){\n\t\tinit(n_, val);\n\t}\n\t\n\t~lazy_segment_tree(){\n\t\t\n\t}\n\t\n\tvoid init(int n_, T val){\n\t\tfval = val;\n\t\t\n\t\tn = 1;\n\t\t\n\t\twhile(n < n_) n *= 2;\n\t\t\n\t\tdat.resize(2 * n - 1);\n\t\tlazy.resize(2 * n - 1, fval);\n\t\tlazyFlag.resize(2 * n - 1, false);\n\t\n\t\tfor(int i = 0; i < 2 * n - 1; i++) dat[i] = fval;\n\t}\n\t\n\tvoid eval(int k, int l, int r){\n\t\t\n\t\tif(lazyFlag[k]){\n\t\t\tdat[k] = lazy[k];\n\t\t\t\n\t\t\tif(r - l > 1) {\n\t\t\t\tlazy[2*k+1] = lazy[2*k+2] = lazy[k];\n\t\t\t\tlazyFlag[2*k+1] = lazyFlag[2*k+2] = lazyFlag[k];\n\t\t\t}\n\t\t\t\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\t\n\tvoid update(int a, int b, T x, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) {return ;}\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = x;\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\t\t} else {\n\t\t\tupdate(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tdat[k] = min(dat[2*k+1], dat[2*k+2]);\n\t\t}\n\t}\n\t\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(r <= a || b <= l){\n\t\t\treturn INF;\n\t\t}\n\t\tif(a <= l && r <= b){\n\t\t\treturn dat[k];\n\t\t}else {\n\t\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2 );\n\t\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\t}\n};\n\nsigned main(){\n\t\n\tlazy_segment_tree<long long> lseg;\n\t\n\tint n, q;\n\t\n\tcin>>n>>q;\n\t\n\tlseg.init(n+10, INF);\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tint com, s, t, x;\n\t\tcin>>com;\n\t\ts++, t++;\n\t\tif(com){\n\t\t\tcin>>s;\n\t\t\tcout<<lseg.query(s,s+1)<<endl;\n\t\t} else {\n\t\t\tcin>>s>>t>>x;\n\t\t\tlseg.update(s, t+1, x);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>\nusing namespace std;\n// 完成版。\n\nint tree[(1 << 18)];\n\nvoid Update(int s, int t, int m, int left = 0, int right = (1 << 17), int key = 0){\n    if(t < left || right <= s) return;\n    if(s <= left && right - 1 <= t){ tree[key] = max(tree[key], m); return; }\n    Update(s, t, m, left, (left + right) / 2, 2 * key + 1);\n    Update(s, t, m, (left + right) / 2, right, 2 * key + 2);\n}\n\nint Find(int i){\n    i += (1 << 17) - 1;\n    int m = tree[i];\n    while(i){\n        i = (i - 1) / 2;\n        m = max(tree[i], m);\n    };\n    return m;\n}\n\nint main(){\n    int i;\n    for(i = 0; i < (1 << 18); i++) tree[i] = 0;\n    int n, q;\n    int x[100000];\n    for(i = 0; i < 100000; i++) x[i] = INT_MAX;\n    int s, t, value, m;\n    m = 1;\n    \n    cin >> n >> q;\n    int query;\n    while(q){\n        q--;\n        cin >> query;\n        if(query){\n            cin >> i;\n            //cout << x[Find(i)] << endl;\n            printf(\"%d\\n\", x[Find(i)]);\n        }else{\n            cin >> s >> t >> value;\n            x[m] = value;\n            Update(s, t, m);\n            m++;\n        }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<climits>\n\n#define MAX_N 1000001\n\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\nint sqrtN;\nint N,K;\nvector<int> data;\nvector<bool> lazyflag;\nvector<int> lazyupdate;\n\nvoid init(){\n\tK=(N+sqrtN-1)/sqrtN;\n\tdata.assign(K*sqrtN,INF);\n\tlazyflag.assign(K,false);\n\tlazyupdate.assign(K,0);\n}\n\nvoid eval(int k){\n\tif(lazyflag[k]){\n\t\tlazyflag[k]=false;\n\t\tfor(int i=k*sqrtN;i<(k+1)*sqrtN;i++){\n\t\t\tdata[i]=lazyupdate[k];\n\t\t}\n\t}\n}\n\nvoid update(int s, int t, int x){\n\tfor(int k=0;k<K;k++){\n\t\tint l=k*sqrtN;\n\t\tint r=(k+1)*sqrtN;\n\t\tif(r<=s || t<=l) continue;\n\t\tif(s<=l && r<=t){\n\t\t\tlazyflag[k]=true;\n\t\t\tlazyupdate[k]=x;\n\t\t}\n\t\telse{\n\t\t\teval(k);\n\t\t\tfor(int i=max(s,l);i<min(t,r);i++){\n\t\t\t\tdata[i]=x;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid find_i(int i){\n\tint k=i/sqrtN;\n\teval(k);\n\tprintf(\"%d\\n\",data[i]);\n}\n\nint main(){\n\tint q,com;\n\tint s,t,x;\n\tscanf(\"%d %d\",&N,&q);\n\tsqrtN=(int)sqrt(N);\n\tinit();\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d\",&com);\n\t\tif(com==0){\n\t\t\tscanf(\"%d %d %d\",&s,&t,&x);\n\t\t\tupdate(s,t+1,x);//[s,t)\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfind_i(x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\nconst int NIL = -1;\nconst int MAX = 2147483647;\nclock_t START, END;\n\nstruct Node {\n\tint l, r, key, lazy;\n};\n\nbool debug = false;\nNode Tree[500010];\nint mark[500010];\nint n = 0, N = 1;\n\n\nvoid update(int x, int y, int z, int k, int height)\n{\n\tif (!mark[k]) {\n\t\tTree[k].l = k * (1 << height) - N;\n\t\tTree[k].r = min(Tree[k].l + (1 << height) - 1, n - 1);\n\t\tmark[k] = 1;\n\t}\n\tif (x > y)\n\t\treturn;\n\tif (x <= Tree[k].l && Tree[k].r <= y) {\n\t\tTree[k].key = z;\n\t\tTree[k].lazy = 1;\n\t\treturn;\n\t}\n\telse if (Tree[k].r < x || Tree[k].l > y) {\n\t\treturn;\n\t}\n\telse {\n\t\tif (Tree[k].lazy) {\n\t\t\tTree[k].lazy = 0;\n\t\t\tTree[2 * k].key = Tree[2 * k + 1].key = Tree[k].key;\n\t\t\tTree[2 * k].lazy = Tree[2 * k + 1].lazy = 1;\n\t\t}\n\t\tupdate(x, min(Tree[k].l + (1 << (height - 1)) - 1, y), z, 2 * k, height - 1);\n\t\tupdate(max(Tree[k].l + (1 << (height - 1)), x), y, z, 2 * k + 1, height - 1);\n\t}\n}\n\nint find(int k, int height, int z)\n{\n\tif (!mark[k]) {\n\t\tTree[k].l = k * (1 << height) - N;\n\t\tTree[k].r = min(Tree[k].l + (1 << height) - 1, n - 1);\n\t\tmark[k] = 1;\n\t}\n\tif (Tree[k].lazy) {\n\t\tTree[2 * k].key = Tree[2 * k + 1].key = Tree[k].key;\n\t\tTree[2 * k].lazy = Tree[2 * k + 1].lazy = 1;\n\t\treturn Tree[k].key;\n\t}\n\telse {\n\t\tif (z <= Tree[k].l + (1 << (height - 1)) - 1)\n\t\t\treturn find(2 * k, height - 1, z);\n\t\telse\n\t\t\treturn find(2 * k + 1, height - 1, z);\n\t}\n}\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in15.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint q, com, x, s, t, k, height = 0;\n\tscanf(\"%d%d\", &n, &q);\n\twhile (N < n) {\n\t\tN *= 2;\n\t\theight++;\n\t}\n\tfor (int i = 1; i <= n + N - 1; i++) {\n\t\tTree[i].key = MAX;\n\t\tTree[i].lazy = 1;\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &com);\t \n\t\tif (com) {\n\t\t\tscanf(\"%d\", &k);\n\t\t\tprintf(\"%d\\n\", find(1, height, k));\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x, 1, height);\n\t\t}\n\t}\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF INT_MAX\n#define rep(i,n) for(int i=0;i<n;i++)\n#define P pair<int,int>\nint n,N;\nP dat[444444];\nvoid init(){\n\tint x=1;\n\twhile(x<n)x*=2;\n\tN=x*2-1;\n\trep(i,N)dat[i]={INF,INF};\n}\nvoid eval(int k,int l,int r){\n\tif(dat[k].second!=INF){\n\t\tdat[k].first=dat[k].second;\n\t\tif(r-l>1){\n\t\t\tdat[2*k+1].second=dat[k].second;\n\t\t\tdat[2*k+2].second=dat[k].second;\n\t\t}\n\t\tdat[k].second=INF;\n\t}\n}\nvoid update(int a,int b,int x,int k,int l,int r){\n\teval(k,l,r);\n\tif(b<=l||r<=a)return;\n\tif(a<=l&&r<=b){\n\t\tdat[k].second=x;\n\t\teval(k,l,r);\n\t}\n\telse{\n\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t}\n}\nint query(int a,int k,int l,int r){\n\teval(k,l,r);\n\tif(r-l==1)return dat[k].first;\n\tif(a<(l+r)/2)return query(a,k*2+1,l,(l+r)/2);\n\telse return query(a,k*2+2,(l+r)/2,r);\n}\nint main(){\n\tint q;\n\tcin>>n>>q;\n\tinit();\n\trep(i,q){\n\t\tint Q;\n\t\tcin>>Q;\n\t\tif(Q==0){\n\t\t\tint s,t,x;\n\t\t\tcin>>s>>t>>x;\n\t\t\tupdate(s,t+1,x,0,0,N);\n\t\t}\n\t\telse{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tcout<<query(x,0,0,N)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; ++i)\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing P = pair<ll, ll>;\n\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Lazy Segment Tree\n */\ntemplate <typename X, typename M>\nclass SegmentTree {\n  using Fx = function<X(X, X)>;\n  using Fa = function<X(X, M)>;\n  using Fm = function<M(M, M)>;\n  Fx fx_;\n  Fa fa_;\n  Fm fm_;\n  const X ex_;\n  const M em_;\n  vector<X> node_;\n  vector<M> lazy_;\n  int n_;             // 最下段のノード数\n\n public:\n  SegmentTree(const vector<X>& v, Fx fx, Fa fa, Fm fm, X ex, M em)\n   : fx_(fx), fa_(fa), fm_(fm), ex_(ex), em_(em) {\n    n_ = 1;\n    while (n_ < v.size()) n_ <<= 1;  // n: 最下段の横幅\n    node_.resize(2 * n_ - 1, ex_);   // ex で初期化\n    lazy_.resize(2 * n_ - 1, em_);   // em で初期化\n\n    // 最下段に値を挿入\n    rep(i, v.size()) set(i, v[i]);\n    // 最下段以外を更新していく\n    build();\n  }\n\n  void set(int i, X x) { node_[(n_ - 1) + i] = x; }\n\n  void build() {\n    for (int i = n_ - 2; i >= 0; i--) {\n      node_[i] = fx_(node_[i * 2 + 1], node_[i * 2 + 2]);\n    }\n  }\n\n  // lazy eval\n  void eval(int k) {\n    if (lazy_[k] == em_) return;  // 更新するものが無ければ終了\n    if (k < n_ - 1) {              // 葉でなければ子に伝搬\n      lazy_[k * 2 + 1] = fm_(lazy_[k * 2 + 1], lazy_[k]);\n      lazy_[k * 2 + 2] = fm_(lazy_[k * 2 + 2], lazy_[k]);\n    }\n    // 自身を更新\n    node_[k] = fa_(node_[k], lazy_[k]);\n    lazy_[k] = em_;\n  }\n\n  // [a, b) の区間の要素を x に更新 O(log(n))\n  void update(int a, int b, M x, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n_;\n    eval(k);\n    if (a <= l && r <= b) {  // 完全に内側のとき\n      lazy_[k] = fm_(lazy_[k], x);\n      eval(k);\n    } else if (a < r && l < b) {   // 一部区間が被るとき\n      update(a, b, x, k * 2 + 1, l, (l + r) / 2);   // 左の子\n      update(a, b, x, k * 2 + 2, (l + r) / 2, r);   // 右の子\n      node_[k] = fx_(node_[k * 2 + 1], node_[k * 2 + 2]);\n    }\n  }\n\n  // [a, b) の区間に対するクエリについてノード k (区間 [l, r) 相当) が答える O(log(n))\n  // 注意 [a, b) は半区間なので 区間 [m, n] の最小値を求めたい場合は find(m, n+1) とする\n  X find(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n_;\n    eval(k);\n    if (r <= a || b <= l) return ex_;  // 区間がかぶらない場合は init を返す\n\n    if (a <= l && r <= b) {  // ノード k の担当範囲がクエリ区間 [a, b) に完全に含まれる\n      return node_[k];\n    } else {                        // 一部区間が被るとき\n      X c1 = find(a, b, k * 2 + 1, l, (l + r) / 2);  // 左の子に値を聞く\n      X c2 = find(a, b, k * 2 + 2, (l + r) / 2, r);  // 右の子に値を聞く\n      return fx_(c1, c2);\n    }\n  }\n\n  X operator[](int i) { return find(i, i+1); }\n};\n///////////////////////////////////////////////////////////////////////////////\n\n\n// 区間更新 Range Update Query https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_D\nvoid aoj_dsl_2_d() {\n  int n, q; cin >> n >> q;\n  ll init = (1LL<<31) - 1;\n  vector<ll> a(n, init);\n  auto fx = [&](ll a, ll b) { return a == init ? b : a; };\n  auto fa = [](ll a, ll b) { return b; };\n  auto fm = [](ll a, ll b) { return b; };\n  SegmentTree<ll, ll> seg(a, fx, fa, fm, init, init);\n  rep(i, q) {\n    int t; cin >> t;\n    if (t == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t+1, x);\n    } else {\n      int s; cin >> s;\n      cout << seg.find(s, s+1) << endl;\n    }\n  }\n}\n/*\n// 区間加算 Range Add Query https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_E\nvoid aoj_dsl_2_e() {\n  int n, q; cin >> n >> q;\n  ll init = 1LL<<31;\n  vector<ll> a(n, init);\n  auto f = [](ll a, ll b) { return a + b; };\n  SegmentTree<ll> seg(a, f, init);\n  rep(i, q) {\n    int t; cin >> t;\n    if (t == 0) {\n      int s, t, x; cin >> s >> t >> x; s--; t--;\n      printf(\"%d %d %d\\n\", s, t+1, x);\n      seg.update(s, t+1, x);\n    } else {\n      int s; cin >> s; s--;\n      cout << seg.find(s, s+1) << endl;\n    }\n  }\n}\n\n\n// 区間更新・区間取得  https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_F\nvoid aoj_dsl_2_f() {\n  int n, q;\n  cin >> n >> q;\n  ll init = (1LL<<31)-1;\n  vector<ll> a(n, init);\n  auto f = [](ll a, ll b) { return min(a, b); };\n  SegmentTree<ll> seg(a, f, init);\n  rep(i, q) {\n    int t; cin >> t;\n    if (t == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    } else {\n      int s, t;\n      cin >> s >> t;\n      cout << seg.find(s, t + 1) << endl;\n    }\n  }\n}\n*/\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  aoj_dsl_2_d();\n  // aoj_dsl_2_e();\n  // aoj_dsl_2_f();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e9;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\n\nint inf=2147483647;\nint size=1;\nvector<int> tree;\nvoid init(int n){\n  while(size<n)size*=2;\n  tree.assign(size*2,inf);\n}\n\n//Range add Query [ )\nvoid update(int l,int r,int x){\n  l+=size,r+=size;\n  int nl=l,nr=r;\n  stack<int> s;\n\n  for(l/=2;1<=l;l/=2)s.emplace(l);\n  while(!s.empty()){\n    int tmp=s.top();s.pop();\n    if(tree[tmp]==-1)continue;\n    tree[2*tmp]=tree[2*tmp+1]=tree[tmp];\n    tree[tmp]=-1;\n  }\n  for(r/=2;1<=r;r/=2)s.emplace(r);\n  while(!s.empty()){\n    int tmp=s.top();s.pop();\n    if(tree[tmp]==-1)continue;\n    tree[2*tmp]=tree[2*tmp+1]=tree[tmp];\n    tree[tmp]=-1;\n  }\n\n  for(;nl<nr;nl/=2,nr/=2){\n    if(nl%2==1)tree[nl++]=x;\n    if(nr%2==1)tree[--nr]=x;\n  }\n\n  return ;\n}\n\nint getvalue(int i){\n  i+=size;\n  int res=tree[i];\n  while(i/=2){\n    if(tree[i]!=-1){\n      res=tree[i];\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  init(n);\n  rep(i,q){\n    int a;\n    cin>>a;\n    if(a){\n      int x;\n      cin>>x;\n      cout<<getvalue(x)<<endl;\n    }else{\n      int s,t,x;\n      cin>>s>>t>>x;\n      t++;\n      update(s,t,x);\n    }\n  }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = (1 << 31) - 1;\n\n//?????¶???????????°???????????¨(RMQ & RUQ)??????????????¨??????????°????\nstruct SegTree {\n    int N;\n    vector<int> dat, lazy;\n    SegTree() {}\n    SegTree(int n) {\n        N = 1;\n        while(N < n) N *= 2;\n        dat.resize(2 * N, INF);//change!!\n        lazy.resize(2 * N, -1);//change!!\n    }\n    //?????¶??????\n    void lazy_evaluate(int k, int l, int r){\n        if(lazy[k] != -1){//?????¶????????????\n            dat[k] = lazy[k];\n            if(k < N - 1){//k????????§???????????????????????¬\n                lazy[k * 2 + 1] = lazy[k];\n                lazy[k * 2 + 2] = lazy[k];\n            }\n            lazy[k] = -1;\n        }\n    }\n    int marge(int x, int y){\n        return min(x, y);//change!!\n    }\n    //replace x [a, b)\n    void update(int a, int b, int x){ update(a, b, 0, 0, N, x); }\n    void update(int a, int b, int k, int l, int r, int x){\n        lazy_evaluate(k, l, r);        \n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b){\n            lazy[k] = x;\n            lazy_evaluate(k, l, r);\n        }else{\n            int m = (l + r) / 2;\n            update(a, b, k * 2 + 1, l, m, x);\n            update(a, b, k * 2 + 2, m, r, x);\n            dat[k] = marge(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    // min [a, b)\n    int query(int a, int b){ return query(a, b, 0, 0, N); }\n    int query(int a, int b, int k, int l, int r) {\n        lazy_evaluate(k, l, r);\n        if(r <= a or b <= l) return INF;//change!!\n        if(a <= l and r <= b) return dat[k];\n        int m = (l + r) / 2;\n        int x = query(a, b, k * 2 + 1, l, m);\n        int y = query(a, b, k * 2 + 2, m, r);\n        return marge(x, y);\n    }\n};\n\n\nsigned main(){\n    int n, q;\n    cin >> n >> q;\n    SegTree sg(n);\n    rep(i, 0, q){\n        int k, s, t, x;\n        cin >> k;\n        if(k == 0){\n            cin >> s >> t >> x;\n            sg.update(s, t + 1, x);\n        }else{\n            cin >> s;\n            cout << sg.query(s, s + 1) << endl;\n            //  rep(j, 0, n){\n            //     cout << sg.dat[sg.N - 1 +  j] << \" \";\n            // }\n            // rep(j, 0, sg.N * 2){\n            //     cout << sg.dat[j] << \" \";\n            // }\n            // cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[n/sq+1];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tfill_n(a+s,t-s+1,x);\n\t//cout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s) < 2*sq){\n\tfill_n(a+s,t-s+1,x);\n\t\n\tlazy[t/sq] = -1;\n\t\n\tlazy[s/sq] = -1;\n      \n\t//cout << \"debug2\" << endl;\n      }\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tcout << a[x] << endl;\n\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RU {\n\tusing type1 = int;\n\tusing type2 = int;\n\tstatic type1 id1() { return INT_MAX; }\n\tstatic type2 id2() { return -1; }\n\tstatic type1 op1(const type1& l, const type1& r) { return min(l, r); }\n\tstatic type1 op2(const type1& l, const type2& r) { return r == -1 ? l : r; }\n\tstatic type2 op3(const type2& l, const type2& r) { return r == -1 ? l : r; }\n};\n\ntemplate <typename M>\nclass LazySegmentTree {\n\tusing T1 = typename M::type1;\n\tusing T2 = typename M::type2;\n\tconst int n;\n\tvector<T1> data;\n\tvector<T2> lazy;\n\tint size(int n) {\n\t\tint res = 1;\n\t\twhile (res < n) res <<= 1;\n\t\treturn res;\n\t}\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tif (node < n) {\n\t\t\tlazy[node * 2] = M::op3(lazy[node * 2], lazy[node]);\n\t\t\tlazy[node * 2 + 1] = M::op3(lazy[node * 2 + 1], lazy[node]);\n\t\t}\n\t\tdata[node] = M::op2(data[node], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\n\tvoid suc(int l, int r, int node, int lb, int ub, T2 val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) {\n\t\t\tlazy[node] = M::op3(lazy[node], val);\n\t\t\treturn;\n\t\t}\n\t\tpush(node);\n\t\tint c = (lb + ub) / 2;\n\t\tsuc(l, r, node * 2, lb, c, val);\n\t\tsuc(l, r, node * 2 + 1, c, ub, val);\n\t\tdata[node] = M::op1(M::op2(data[node * 2], lazy[node * 2]), M::op2(data[node * 2 + 1], lazy[node * 2 + 1]));\n\t}\n\tT1 sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return M::id1();\n\t\tif (l <= lb && ub <= r) return M::op2(data[node], lazy[node]);\n\t\tpush(node);\n\t\tint c = (lb + ub) / 2;\n\t\treturn M::op1(sub(l, r, node * 2, lb, c), sub(l, r, node * 2 + 1, c, ub));\n\t}\npublic:\n\tLazySegmentTree(int n_) : n(size(n_)), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tsuc(l, r + 1, 1, 0, n, val);\n\t}\n\tT1 find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q, type, s, t, x;\n\tcin >> n >> q;\n\tLazySegmentTree<RU> lst(n);\n\twhile (q--) {\n\t\tcin >> type;\n\t\tif (type) {\n\t\t\tcin >> x;\n\t\t\tprintf(\"%d\\n\", lst.find(x, x));\n\t\t}\n\t\telse {\n\t\t\tcin >> s >> t >> x;\n\t\t\tlst.update(s, t, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\n\nconst long long inf = (1ll << 31) - 1;\nconst int max_n = (1 << 17);\n\nlong long seg[max_n * 2 - 1];\nlong long lazy[max_n * 2 - 1];\n\nvoid init()\n{\n  int _n = n;\n\n  n = 1;\n  while (n < _n) n *= 2;\n\n  fill(seg, seg + 2 * n - 1, inf);\n  fill(lazy, lazy + 2 * n - 1, inf + 1);\n}\n\nvoid update(int a, int b, int x, int k = 0, int l = 0, int r = n)\n{\n  if (a <= l && r <= b){\n    lazy[k] = x;\n    return;\n  }\n  if (r <= a || b <= l){\n    return;\n  }\n\n  if (lazy[k] != inf + 1) {\n    lazy[k * 2 + 1] = lazy[k * 2 + 2] = lazy[k];\n  }\n  lazy[k] = inf + 1;\n  update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n  update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n}\n\nvoid find(int a, int b, int k = 0, int l = 0, int r = n)\n{\n  if (a <= l && r <= b){\n    if (lazy[k] != inf + 1){\n      seg[k] = lazy[k];\n    }\n    lazy[k] = inf + 1;\n    return;\n  }\n  else if (r <= a || b <= l){\n    return;\n  }\n  else {\n    if (lazy[k] != inf + 1){\n      lazy[k * 2 + 1] = lazy[k * 2 + 2] = lazy[k];\n      lazy[k] = inf + 1;\n    }\n    find(a, b, k * 2 + 1, l, (l + r) / 2);\n    find(a, b, k * 2 + 2, (l + r) / 2, r);\n  }\n}\n\nint main()\n{\n  cin >> n >> q;\n  init();\n  for (int i = 0; i < q; i++){\n    int f;\n    cin >> f;\n\n    if (f == 0){\n      int s, t, x;\n\n      cin >> s >> t >> x;\n      update(s, t + 1, x);\n      /*\n      for (int i = 0; i < n * 2 - 1; i++){\n        cout << lazy[i] << \" \";\n      }\n      puts(\"\");\n      */\n    } else {\n      int i;\n\n      cin >> i;\n      find(i, i + 1);\n\n      /*\n      for (int i = 0; i < n * 2 - 1; i++){\n        cout << seg[i] << \" \";\n      }\n      puts(\"\");\n      */\n      cout << seg[i + n - 1] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  ll lazy[sq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(t >= sq*sq && s < sq*sq){\n\t//cout << \"deug\" << endl;\n\tfill_n(a+sq*sq,t%sq+1,x);\n\tt = sq*sq-1;\n      }\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tfill_n(a+s,t-s+1,x);\n\t//cout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s) <= 2*sq){\n\tfill_n(a+s,t-s+1,x);\n\tif(t/sq <= sq - 1){\n\t  lazy[t/sq] = -1;\n\t}\n\tif(s/sq <= sq - 1){\n\t  lazy[s/sq] = -1;\n\t}\n\t//cout << \"debug2\" << endl;\n      }\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tfill_n(a+s,f-s,x);\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n      cout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      if(te > sq-1){\n\tcout << a[x] << endl;\n      }\n      else if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq+1,lazy[te]);\n\tcout << a[x] << endl;\n\t//cout << \"debug7\" << endl;\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long int ll;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n\nconst int MAX_N = 1 << 19;\n#define NUM 2147483647\n\nint nn = 1;\nint data[MAX_N];\n\nvoid init(int first_N){\n    nn = 1;\n    if(first_N < 10) nn = 100;\n\twhile(nn < first_N)nn *= 2;\n}\n\n// [left,right]の区間の値をvalueに更新する\n// update_(left,right,value,0,0,nn-1)のように呼ぶ\nvoid update_(int update_left,int update_right,int new_value,int node_id,int node_left,int node_right){\n\tif(update_right < node_left || update_left > node_right)return;\n\telse if(update_left <= node_left && update_right >= node_right){\n\t\tdata[node_id] = new_value;\n\t}else{\n\t\tif(data[node_id] >= 0){\n\t\t\tdata[2*node_id+1] = data[node_id];\n\t\t\tdata[2*node_id+2] = data[node_id];\n\t\t\tdata[node_id] = -1;\n\t\t}\n\t\tupdate_(update_left,update_right,new_value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tupdate_(update_left,update_right,new_value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\n// query_(ite,ite,0,0,nn-1)のように呼ぶ\nint query_(int search_left,int search_right,int node_id,int node_left,int node_right){\n\tif(search_right < node_left || search_left > node_right){\n\t\treturn -1;\n\t}else if(node_left <= search_left && node_right >= search_right && data[node_id] >= 0){\n\t\treturn data[node_id];\n\t}else{\n\t\tint left = query_(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tint right = query_(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn max(left,right);\n\t}\n}\n\nint main(){\n\tint n,Q;\n\tcin >> n >> Q;\n\n\tinit(n);\n\n\tfor(int i = 0; i <= 2*nn-2; i++)data[i] = NUM;\n\n\trep(i,Q){\n\t\tint command;\n        cin >> command;\n\n\t\tif(command == 0){\n            int left,right,value;\n\t\t\tcin >> left >> right >> value;\n\t\t\tupdate_(left,right,value,0,0,nn-1);\n\t\t}else{\n            int loc;\n\t\t\tcin >> loc;\n\t\t\tcout << query_(loc,loc,0,0,nn-1) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define siz 10000000\n\nchar buf[siz], *bit = buf;\n\ninline int nextInt(void) {\n\tregister int ret = 0;\n\tregister int neg = false;\n\n\tfor (; *bit < '0'; ++bit)\n\t\tif (*bit == '-')neg ^= true;\n\n\tfor (; *bit >= '0'; ++bit)\n\t\tret = ret * 10 + *bit - '0';\n\n\treturn neg ? -ret : ret;\n}\n\n#define inf 2147483647\n\nint n, m;\n\nint tag[400005];\n\nint find(int t, int l, int r, int p) {\n\tif (~tag[t])\n\t\treturn tag[t];\n\tint mid = (l + r) >> 1;\n\tif (p <= mid)\n\t\treturn find(t << 1, l, mid, p);\n\telse\n\t\treturn find(t << 1 | 1, mid + 1, r, p);\n}\n\nvoid update(int t, int l, int r, int x, int y, int k) {\n\tif (l == x && r == y)\n\t\ttag[t] = k;\n\telse {\n\t\tint mid = (l + r) >> 1;\n\t\tif (~tag[t])\n\t\t\ttag[t << 1] = tag[t << 1 | 1] = tag[t], tag[t] = -1;\n\t\tif (y <= mid)\n\t\t\tupdate(t << 1, l, mid, x, y, k);\n\t\telse if (x > mid)\n\t\t\tupdate(t << 1 | 1, mid + 1, r, x, y, k);\n\t\telse {\n\t\t\tupdate(t << 1, l, mid, x, mid, k);\n\t\t\tupdate(t << 1 | 1, mid + 1, r, mid + 1, y, k);\n\t\t}\n\t}\n}\n\nsigned main(void) {\n\tfread(buf, 1, siz, stdin);\n\n\tn = nextInt();\n\tm = nextInt();\n\n\tfor (int i = 0; i < (n << 2); ++i)\n\t\ttag[i] = inf;\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint c = nextInt();\n\t\tif (c)\t// find(x)\n\t\t\tprintf(\"%d\\n\", find(1, 1, n, nextInt() + 1));\n\t\telse {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tupdate(1, 1, n, x + 1, y + 1, k);\n\t\t}\n\t}\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing ll = long long;\n\ntemplate <typename T>\nT min(T a, T b){\n  return (a < b) ? a : b;\n}\n\ntemplate <typename T>\nclass SegTree{\n  static const int MAXN = 100010;\n  T INF;\n  int n;\n  T A[MAXN*4];\n  T time[MAXN*4];\n  public:\n  SegTree(int size, T INF): INF(INF){\n    n = 1;\n    while(n < size){\n      n *= 2;\n    }\n    n *= 2;\n    for(int i = 0; i < MAXN*4; i++) A[i] = INF;\n    for(int i = 0; i < MAXN*4; i++) time[i] = 0;\n  }\n\n  void update(int a, int b, T v, T t){\n    return _update(a, b, 0, 0, n, v, t);\n  }\n\n  void _update(int a, int b, int k, int l, int r, T v, T t){\n    if(a >= r || b <= l){\n      return;\n    }\n    if(l >= a && r <= b){\n      A[k] = v;\n      time[k] = t;\n      return;\n    }\n    _update(a, b, 2*k + 1, l, (l+r)/2, v, t);\n    _update(a, b, 2*k + 2, (l+r)/2, r, v, t);\n  }\n\n  T query(int _idx){\n    int offset = n - 1;\n    int idx = _idx + offset;\n    T t = 0;\n    T ans = INF;\n    while(idx > 0){\n      if(time[idx] >= t){\n        ans = A[idx];\n        t = time[idx];\n      }\n      idx = (idx-1)/2;\n    }\n    return ans;\n  }\n};\n\nint main(void){\n  int n, q; cin >> n >> q;\n  SegTree<int> rmq(n, 0x7FFFFFFF);\n  for(int loop = 0; loop < q; loop++){\n    int com;\n    cin >> com;\n    if(com == 0){\n      int x, y, v; cin >> x >> y >> v;\n      rmq.update(x, y+1, v, loop+1);\n    }else{\n      int i; cin >> i;\n      cout << rmq.query(i) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_INT 2147483647\nusing namespace std;\nint main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int>a(n,MAX_INT);\n  for(int i=0;i<q;i++){\n    int com;cin>>com;\n    if(com){\n      int i;\n      scanf(\"%d\",&i);\n      printf(\"%d\\n\",a[i]);\n    }else{\n      int s,t,l;\n      scanf(\"%d %d %d\",&s,&t,&l);\n      fill(a.begin()+s,a.begin()+t+1,l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \n#define INF 2147483647\n#define ASTART (1<<17)\nint a[1<<18][2];\nint ti=1;\n \nint find(int i){\n  int nv=INF,t=0;\n  i+=ASTART-1;\n  nv=a[i][0];\n  t=a[i][1];\n  while (i>0){\n    i=(i-1)/2;\n    if (t<a[i][1])nv=a[i][0],t=a[i][1];\n  }\n  return nv;\n}\nvoid update(int s,int t,int x,int k,int l,int r){\n  if (l>=s&&r<=t){\n    a[k][0]=x;\n    a[k][1]=ti;\n    return;\n  }\n  if (r<=s||l>=t)return;\n  int m=(l+r)/2;\n  update(s,t,x,k*2+1,l,m);\n  update(s,t,x,k*2+2,m,r);\n}\nint main(){\n  int n,q,com,s,t,x;\n  for (int i=0;i<(1<<18);i++)a[i][0]=INF,a[i][1]=0;\n  cin >> n>>q;\n \n  for (int i=0;i<q;i++){\n    cin >> com;\n    if (com==0) {\n      cin >> s >> t >> x;\n      update(s,t+1,x,0,0,ASTART);\n      ti++;\n    }else {\n      cin >> s;\n      cout << find(s)<< endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (????±?????±?????????¶?????°???????????¨)\nconst int SIZE = 1 << 17; // 2^17 = 131072\ntemplate<typename T>\nstruct lazysegtree {\n    // ?????????????????????\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // ????????¬????????§??? (update, query ??? 2 ???????????????)\n    // update function ??????????????????????????¢????????????\n    // upd_f(X, Y, l, r) -> ????????? [l, r) ??§???????????????????????? X ??? Y ????????????\n    // lazy ???????????? update ??¨??????????????? 1 ??????????????¨?????°?????????\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // ???????????¨?????????????????????????????¨?????? node ??¨ lazy ??????????????§?????????\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // ???????????? [a, b) ??????????????? val ??????????????????\n    // (upd_f ?????¨????????????)\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // ???????????? [a, b) ?????????????????¨???????????????\n    // (qry_f ?????¨????????????)\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return I;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\n// [[???????????????]]\n// update ??¨??¨ query ??¨?????¢??°??¨????????? (??¢??°????????????????????????????????????????????????) ?????¨???????????£?¨???????\n// ??????????????¨???update ??¨?????¢??°??? upd ??§???query ??¨?????¢??°??? fnd ??§??????????????? INT_MAX\n\nint upd(int a, int b, int l, int r) {return b;}\nint fnd(int a, int b) {return min(a, b);}\nlazysegtree<int> seg(upd, fnd, INT_MAX);\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    while(Q--) {\n        int q; scanf(\"%d\", &q);\n        if(q == 0) {\n            int s, t, x; scanf(\"%d%d%d\", &s, &t, &x); t++;\n            seg.update(s, t, x);\n        }\n        else {\n            int i; scanf(\"%d\", &i);\n            printf(\"%d\\n\", seg.query(i, i+1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ DSL_2_D Range Update Query\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nstruct Seg {\n  int vv(int value1, int value2) { return min(value1, value2); } // min\n  int pp(int oldpending, int newpending) { return newpending; }  // set\n  int vp(int oldvalue, int newpending) { return newpending; }    // set\n\n  vector<int> A;\n  vector<bool> flag;\n  vector<int> pending;\n  int n;\n\n  // Endpoints returns the (closed) endpoints of the interval owned by the\n  // node with array index `i`\n  pair<int, int> Endpoints(int i) {\n    int depth = static_cast<int>(floor(log2(i)));\n    // 2^d nodes with depth d\n    int per_node_in_row = n >> depth;\n    int l = 1 + (i - (1 << depth)) * per_node_in_row;\n    int r = l + per_node_in_row;\n    return {l, r};\n  }\n\n  // ContainedIn returns whether the node with array index `i`'s interval\n  // is contained in the interval [s, t)\n  bool ContainedIn(int i, int s, int t) {\n    int l, r;\n    tie(l, r) = Endpoints(i);\n    return (s <= l and t >= r);\n  }\n\n  // Intersects returns whether the node with array index `i`'s interval\n  // intersects with the interval [s, t)\n  bool Intersects(int i, int s, int t) {\n    if (s == t) // empty\n      return false;\n    int l, r;\n    tie(l, r) = Endpoints(i);\n    return (l >= s and l < t) or (s >= l and s < r);\n  }\n\n  void Propagate(int i) {\n    if (!flag[i])\n      return;\n    flag[i] = false;\n    A[i] = vp(A[i], pending[i]);\n    if (i < n) { // internal node\n      if (flag[2 * i]) {\n        pending[2 * i] = pp(pending[2 * i], pending[i]);\n      } else {\n        pending[2 * i] = pending[i];\n        flag[2 * i] = true;\n      }\n      if (flag[2 * i + 1]) {\n        pending[2 * i + 1] = pp(pending[2 * i + 1], pending[i]);\n      } else {\n        pending[2 * i + 1] = pending[i];\n        flag[2 * i + 1] = true;\n      }\n    }\n  }\n\n  int Get(int i, int s, int t) { // open interval [s, t)\n    Propagate(i);\n    if (ContainedIn(i, s, t))\n      return A[i];\n    assert(i < n);\n    if (Intersects(2 * i, s, t) and Intersects(2 * i + 1, s, t))\n      return vv(Get(2 * i, s, t), Get(2 * i + 1, s, t));\n    if (Intersects(2 * i, s, t))\n      return Get(2 * i, s, t);\n    if (Intersects(2 * i + 1, s, t))\n      return Get(2 * i + 1, s, t);\n  }\n\n  void Modify(int i, int s, int t, int x) {\n    Propagate(i);\n    if (ContainedIn(i, s, t)) {\n      if (flag[i]) {\n        pending[i] = pp(pending[i], x);\n      } else {\n        pending[i] = x;\n        flag[i] = true;\n      }\n    } else if (i < n) { // internal node\n      if (Intersects(2 * i, s, t))\n        Modify(2 * i, s, t, x);\n      if (Intersects(2 * i + 1, s, t))\n        Modify(2 * i + 1, s, t, x);\n      Propagate(2 * i);\n      Propagate(2 * i + 1);\n      A[i] = vv(A[2 * i], A[2 * i + 1]);\n    }\n  }\n\n  Seg(int n, int default_value)\n      : n(n), pending(2 * n), A(2 * n, default_value), flag(2 * n) {\n    for (int i = n - 1; i > 0; --i)\n      A[i] = vv(A[2 * i], A[2 * i + 1]);\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  Seg seg(1 << static_cast<int>(ceil(log2(n))), numeric_limits<int>::max());\n  for (int c, s, t, x, i; cin >> c;) {\n    if (c == 0) { // update(s,t,x): each i=s,..,t set a[i]:=x\n      cin >> s >> t >> x;\n      seg.Modify(1, s + 1, t + 2, x);\n    }\n    if (c == 1) { // find(i): output a[i]\n      cin >> i;\n      cout << seg.Get(1, i + 1, i + 2) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INIVAL = (1<<31) -1;\n\nclass SegmentTree{\npublic:\n    int n; //array size\n    vector<int> tree; // store the segment tree\n    vector<int> lazy; // store pending updates\n    //\n    void initRMQ(int arrSize);\n    void update(int idx, int val);\n    void lazy_evaluate(int iNode, int sStart, int sEnd);\n    int readUtil(int iNode, int sStart, int sEnd, int idx);\n    int read(int idx);\n    void updateRangeUtil(int iNode, int sStart, int sEnd, int uStart, int uEnd, int val);\n    void updateRange(int uStart, int uEnd, int val);\n    int findMinUtil(int iNode, int nStart, int nEnd, int qLeft, int qRight);\n    int findMin(int fLeft, int fRight);\n    //\n    void printTree();\n};\n\nint main()\n{\n    // get input from cmd window\n    SegmentTree ist;\n    int n, q, x, y, z, t;\n    cin >> n >> q;\n    ist.initRMQ(n);\n    vector<int> out;\n    for (int i = 0; i < q; i++) {\n        cin >> x;\n        if (x==0) {\n            cin >> y >> z >> t;\n            ist.updateRange(y, z, t);\n        }\n        else if (x==1) {\n            cin >> y;\n            out.push_back(ist.read(y));\n        }\n    }\n\n    // output\n    for (int i = 0; i < out.size(); i++) {cout << fixed << out[i] << \"\\n\";}\n    return 0;\n}\n\nvoid SegmentTree::initRMQ(int arrSize) {\n    n = 1;\n    while (n<arrSize) {n *= 2;}\n    tree = vector<int>(2*n-1, INIVAL);\n    lazy = vector<int>(2*n-1, -1);\n}\n\nvoid SegmentTree::printTree() {\n    cout << \"tree[]: \" << \"\\t\";\n    for (int i = 0; i < tree.size(); i++) {cout << fixed << this->tree[i] << \"\\t\";}\n    cout << \"\\n\" << \"lazy[]: \" << \"\\t\";\n    for (int i = 0; i < lazy.size(); i++) {cout << fixed << this->lazy[i] << \"\\t\";}\n    cout << endl;\n}\n\nvoid SegmentTree::update(int idx, int val) {\n    idx += n - 1;\n    tree[idx] = val;\n    while (idx > 0) {\n        idx = (idx-1)/2;\n        tree[idx] = min(tree[idx*2+1], tree[idx*2+2]);\n    }\n}\n\nvoid SegmentTree::lazy_evaluate(int iNode, int sStart, int sEnd) {\n    if (lazy[iNode] != -1) {\n        // apply the pending update stored in the corresponding lazy node\n        tree[iNode] = lazy[iNode]; // since all elements in the range presented by this node are the same = lazy[iNode]\n        // not a leaf node\n        if (sStart!=sEnd) {\n            lazy[iNode*2+1] = lazy[iNode];\n            lazy[iNode*2+2] = lazy[iNode];\n        }\n        // erase the mark for the pending update of this node\n        lazy[iNode] = -1;\n    }\n}\n\nint SegmentTree::readUtil(int iNode, int sStart, int sEnd, int idx) {\n    // check pending update\n    lazy_evaluate(iNode, sStart, sEnd);\n\n    // leaf node\n    if (sStart==sEnd){return tree[iNode];}\n\n    // not a leaf node\n    int mid = (sStart+sEnd)/2;\n    if (sStart <= idx && idx <= mid) {return readUtil(iNode*2+1, sStart, mid, idx);}\n    else {return readUtil(iNode*2+2, mid+1, sEnd, idx);}\n}\n\nint SegmentTree::read(int idx) {\n    return readUtil(0, 0, n-1, idx);\n}\n\nvoid SegmentTree::updateRangeUtil(int iNode, int sStart, int sEnd, int uStart, int uEnd, int val) {\n    // apply pending updates (if any)\n    lazy_evaluate(iNode, sStart, sEnd);\n\n    // out of range\n    if (sStart > uEnd || sEnd < uStart || sStart > sEnd) {return;}\n\n    // current segment is fully in range\n    if (sStart >= uStart && sEnd <= uEnd) {\n        // update the current node\n        tree[iNode] = val;\n        // in case not a leaf node -> postpone the update for children nodes\n        if (sStart != sEnd) {\n            lazy[iNode*2+1] = val;\n            lazy[iNode*2+2] = val;\n        }\n        return;\n    }\n\n    // not completely in range, but overlapped -> recur throughout children nodes\n    int mid = (sStart + sEnd)/2;\n    updateRangeUtil(iNode*2+1, sStart, mid, uStart, uEnd, val);\n    updateRangeUtil(iNode*2+2, mid+1, sEnd, uStart, uEnd, val);\n    // then, use the result of children calls to update the current node\n    tree[iNode] = min(tree[iNode*2+1], tree[iNode*2+2]);\n}\n\nvoid SegmentTree::updateRange(int uStart, int uEnd, int val) {\n    updateRangeUtil(0, 0, n-1, uStart, uEnd, val);\n}\n\nint SegmentTree::findMin(int fLeft, int fRight) {\n    return findMinUtil(0, 0, n-1, fLeft, fRight);\n}\n\n// given searching range a[l], ... a[r]\nint SegmentTree::findMinUtil(int iNode, int nStart, int nEnd, int qLeft, int qRight) {\n    if ((qRight < nStart) || (nEnd < qLeft)) {\n        // the range presented by the current node is completely outside the given (searching) range\n        return INIVAL;\n    }\n    else if ((qLeft <= nStart) && (nEnd <= qRight)) {\n        // the range presented by the current node is completely inside the given range\n        return tree[iNode];\n    }\n    else {\n        // the range presented by the current node is  partly inside and partly outside the given range\n        int mid = (nStart+nEnd)/2;\n        int vl = findMinUtil(2*iNode+1, nStart, mid, qLeft, qRight);\n        int vr = findMinUtil(2*iNode+2, mid+1, nEnd, qLeft, qRight);\n        return min(vl, vr);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vi a(n, INT_MAX);\n    int m = sqrt(n);\n    vi b((n+m-1)/m, -1);\n    auto call = [&](int i) {\n        for(int x = i/m*m; x != (i/m+1)*m and x != n; x++) {\n            a[x] = b[i/m];\n        }\n        b[i/m] = -1;\n    };\n    auto get = [&](int i) {\n        if(b[i/m] != -1) {\n            call(i);\n        }\n        return a[i];\n    };\n    auto update = [&](int l, int r, int x) {\n        if(l/m == r/m) {\n            if(b[l/m] != -1) call(l);\n            for(; l != r; l++) {\n                a[l] = x;\n            }\n        }\n        else {\n            if(b[l/m] != -1) call(l);\n            if(b[r/m] != -1) call(r);\n            for(; l%m; a[l++] = x);\n            for(; r%m; a[--r] = x);\n            for(l /= m, r /= m; l != r; b[l++] = x);\n        }\n    };\n\n    while(q--) {\n        int t;\n        cin >> t;\n        if(t) {\n            int i;\n            cin >> i;\n            cout << get(i) << '\\n';\n        } else {\n            int l, r, x;\n            cin >> l >> r >> x;\n            update(l, r+1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nconst ll INF=(1ll<<31)-1;\nint a[100001];\nint b[1005];\nint main(){\n    int n,q;\n    cin>>n>>q;\n    int sqn=sqrt(n);\n    int bn=(n+sqn-1)/sqn;\n    rep(i,n) a[i]=INF;\n    rep(i,bn) b[i]=INF;\n    int com;\n    rep(i,q){\n        cin>>com;\n        if(com==0){\n            int s,t,x;\n            //[s,t)\n            cin>>s>>t>>x;\n            ++t;\n            rep(j,bn){\n                int l=j*sqn,r=(j+1)*sqn;\n                if(r<=s||t<=l) continue;\n                if(s<=l&&r<=t) b[j]=x;\n                else{\n                    FOR(k,l,r){\n                        if(k>=max(s,l)&&k<min(t,r)) a[k]=x;\n                        else if(b[j]!=INF) a[k]=b[j];\n                    }\n                    b[j]=INF;\n                }\n            }\n        }\n        if(com==1){\n            int k;\n            cin>>k;\n            int cur=k/sqn;\n            if(b[cur]!=INF){\n                FOR(j,cur*sqn,(cur+1)*sqn){\n                    a[j]=b[cur];\n                }\n                b[cur]=INF;\n            }\n            cout<<a[k]<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  ll lazy[sq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(t >= sq*sq && s < sq*sq){\n\tcout << \"deug\" << endl;\n\tfill_n(a+sq*sq,t%sq+1,x);\n\tt = sq*sq-1;\n      }\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tfill_n(a+s,t-s+1,x);\n\tcout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s) <= 2*sq){\n\tfill_n(a+s,t-s+1,x);\n\tif(t/sq <= sq - 1){\n\t  lazy[t/sq] = -1;\n\t}\n\tif(s/sq <= sq - 1){\n\t  lazy[s/sq] = -1;\n\t}\n\tcout << \"debug2\" << endl;\n      }\n      else{\n\tcout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tfill_n(a+s,f-s,x);\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n      REP(i,n)\n\tcout << a[i] << \"  \";\n      cout << endl;\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      if(te > sq-1){\n\tcout << a[x] << endl;\n      }\n      else if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq+1,lazy[te]);\n\tcout << a[x] << endl;\n\tcout << \"debug7\" << endl;\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n/*\nstruct M_act {\n   using T = _operand_set_; // ?????¨???????????´???????????????\n   using Monoid = _operator_monoid_; // ?????¨?´???¢?????????\n   T operator()(const Monoid::T& m, const T& a) { return _m_act_a_; } // ?????¨??????\n};\nstruct Monoid {\n   using T = _underlying_set_; // ??¢??????????????°????????????\n   T operator()(const T& a, const T& b) { return _a_op_b_; } // ????????????\n   static constexpr T identity() { return _identity_element_; } // ?????????\n};\n*/\n\nstruct Update {\n   using T = int; // ??¢??????????????°????????????\n   T operator()(const T& a, const T& b) { return a == INT_MAX ? b : a; } // ????????????\n   static constexpr T identity() { return INT_MAX; } // ?????????\n};\nstruct M_act {\n    using T = int; // ?????¨???????????´???????????????\n    using Monoid = Update; // ?????¨?´???¢?????????\n    T operator()(const Monoid::T& m, const T& a) { return m == INT_MAX ? a : m; } // ?????¨??????\n};\n\n\ntemplate <class M_act>\nclass SegTree {\n    private:\n        using T = typename M_act::T; // ?????¨???????????´????????????????????¨????????¢???\n        using M = typename M_act::Monoid::T; // ?????¨?´???¢??????????????°???????????¨????????¢???\n        M_act action; // ?????¨?????????\n        typename M_act::Monoid op; // ?????¨?´???¢?????????????????????\n        const int n, h; // ?????????????????¨?????????\n        vector<T> dat; // ?????????\n        vector<M> lazy; // ????????§?????????????????????????§?????????¨????????????????????????????????¨?????????????????°???????????§????????§?????????n??§??????\n        bool has_lazy; // ??????????????§??????????????????????????¨????????????????????????????????°\n\n        void act(int i, const M& m) { // ?????????i????????¨\n            if (i < n) lazy[i] = op(m, lazy[i]); // ?????¨????????????????????¨??¨?????¨????????¨?´???¢????????????????????§?????¨??????\n            else {\n                i -= n;\n                dat[i] = action(m, dat[i]); // ??????????????¨????????¨???????????????\n            }\n        }\n\n        void prop_from(int i) { // ?????????i????????¨??????????????????\n            act(i << 1, lazy[i]);\n            act(i << 1 | 1, lazy[i]);\n            lazy[i] = op.identity();\n        }\n\n        void prop_to(int i) { // i???????????????????????¨?????¨???????????§??????????????????\n            i += n;\n            for (int s = (i >> h ? h : h-1); s > 0; --s) prop_from(i >> s);\n        }\n\n    public:\n        SegTree(int n) : n(n), h(log(n)), dat(n, op.identity()), lazy(n, op.identity()), has_lazy() {} // ????§????x??§??????????????????????????????\n        SegTree(const vector<T>& v) : n(v.size()), h(__lg(n)), dat(v), lazy(n, op.identity()), has_lazy() {} // ????????????vector??§???????????????????????????\n\n        void act(int l, int r, const M& m) { // [l, r)???m????????¨?????????\n            prop_to(l);\n            prop_to(r-1);\n            l += n, r += n;\n            for (; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) act(l++, m);\n                if (r & 1) act(r-1, m);\n            }\n            has_lazy = true;\n        }\n\n        void prop() { // ?????????????????¨???????????¨???????????§?????????\n            for (int i = 1; i < n; ++i) prop_from(i);\n            has_lazy = false;\n        }\n\n        void set(int i, const T& x) { // i????????????????????´??°\n            prop_to(i);\n            dat[i] = x;\n        }\n        void add(int i, const T &x){\n            set(i, get(i) * x);\n        }\n\n        T get(int i) { // i?????????????????????\n            if (!has_lazy) return dat[i]; // ????????????????????¨?????????????????????????????????\n            T ret = dat[i];\n            i += n;\n            while (i >>= 1) ret = action(lazy[i], ret); // ????????§????????????????????§?????£???????????????????????????????????§????????¨????¢???£?????????\n            return ret;\n        }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n\n    SegTree<M_act> seg(n);\n    rep(i,q){\n        int com;\n        cin >> com;\n        if(com){\n            int x;\n            cin >> x;\n            cout << seg.get(x) << endl;\n        }else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.act(s, t + 1, x);\n        }\n        //seg.print();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define moder (int)(1e9+7)\n#define inf (int)(3e18+7)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define P pair<int,int>\n#define all(v) v.begin(),v.end()\n#define mkp make_pair\n#define mkt make_tuple\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define vecunique(vec) sort(vec.begin(), vec.end());decltype(vec)::iterator result = std::unique(vec.begin(), vec.end());vec.erase(result, vec.end())\nusing namespace std;\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)return false;\n\t}\n\treturn x > 1;\n}\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x * y / gcd(x, y);\n}\nint kai(int x) {\n\tif (x == 0)return 1;\n\treturn kai(x - 1) * x % moder;\n}\nint mod_pow(int x, int y, int mod) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % mod;\n\t\t}\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint comb(int x, int y) {\n\treturn kai(x)* mod_pow(kai(x - y), moder - 2, moder) % moder * mod_pow(kai(y), moder - 2, moder) % moder;\n}\n/*--------Library Zone!--------*/\n\nstruct LazySegtree {\nprivate:\n\tint size_;\n\tstring type;\n\tP dat[1000000];\n\tvoid init_RUQ() {\n\t\tint x = size_; size_ = 1;\n\t\twhile (x > size_)size_ *= 2;\n\t\trep(i, size_ * 2 - 1) {\n\t\t\tdat[i] = { ((int)1 << 31) - 1,inf };\n\t\t}\n\t}\n\tvoid eval_RUQ(int k, int l, int r) {\n\t\tif (dat[k].second != inf) {\n\t\t\tdat[k].first = dat[k].second;\n\t\t\tif (r - l > 1) {\n\t\t\t\tdat[2 * k + 1].second = dat[k].second;\n\t\t\t\tdat[2 * k + 2].second = dat[k].second;\n\t\t\t}\n\t\t\tdat[k].second = inf;\n\t\t}\n\t}\n\tvoid update_RUQ(int a, int b, int x, int k, int l, int r) {\n\t\teval_RUQ(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat[k].second = x;\n\t\t\teval_RUQ(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate_RUQ(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate_RUQ(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t}\n\t}\npublic:\n\tLazySegtree(int x, string s) {\n\t\tsize_ = x; type = s;\n\t\tif (type == \"RUQ\")init_RUQ();\n\t}\n\tvoid update(int l, int r, int x) {\n\t\tif (type == \"RUQ\")update_RUQ(l, r, x, 0, 0, size_);\n\t}\n\tint query_RUQ(int a, int k, int l, int r) {\n\t\teval_RUQ(k, l, r);\n\t\tif (r - l == 1) {\n\t\t\treturn dat[k].first;\n\t\t}\n\t\tif (a < (l + r) / 2)return query_RUQ(a, k * 2 + 1, l, (l + r) / 2);\n\t\telse return query_RUQ(a, k * 2 + 2, (l + r) / 2, r);\n\t}\n\tint query(int x) {\n\t\treturn query_RUQ(x, 0, 0, size_);\n\t}\n};\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tLazySegtree segtree(n, \"RUQ\");\n\trep(i, q) {\n\t\tint a; cin >> a;\n\t\tif (!a) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tsegtree.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint x; cin >> x;\n\t\t\tcout << segtree.query(x) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q;\nint const INF = INT_MAX;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<int> node, lazy;\n\npublic:\n    LazySegmentTree(vector<int> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n\n    // k ?????????????????? ( ??????????????? [l, r) ) ?????????????????¶??????\n    void lazy_evaluate(int k, int l, int r) {\n        // ?????? lazy ???????????\\??£??????????????????\n        // ??????????????¨????????? (??? lazy) ???????????????????????????\n        if(lazy[k] != 0) {\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] = lazy[k];\n                lazy[2*k+2] = lazy[k];\n            }\n            lazy[k] = 0;\n        }\n    }\n\n    // [a, b) ??????????´??????¨??? x ?????´??°??????\n    // ????????????????????? k ??¨??????????????????????????????????????? [l, r) ??§??????\n    void update(int a, int b, int x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        lazy_evaluate(k, l, r);\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazy_evaluate(k, l, r);\n        }\n        else {\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = node[k*2+1] + node[k*2+2];\n        }\n    }\n\n    int find(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        lazy_evaluate(k, l, r);\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n        int vl = find(a, b, 2*k+1, l, (l+r)/2);\n        int vr = find(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n};\n\nint main() {\n    cin >> N >> Q;\n    LazySegmentTree seg( vector<int>(N, INF) );\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }\n        else {\n            int i; cin >> i;\n            cout << seg.find(i, i+1) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,E)> G;\n  typedef function<T(E,E)> H;\n  int n;\n  G g;\n  H h;\n  T d1;\n  E d0;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(){};\n  SegmentTree(int n_,G g,H h,T d1,E d0,\n\t      vector<T> v=vector<T>()):\n    g(g),h(h),d1(d1),d0(d0){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(n,d1);\n    laz.clear();\n    laz.resize(2*n-1,d0);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i]=v[i];\n  }\n  void eval(int k){\n    if(k*2+1<2*n-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n      laz[k]=d0;\n    }\n  }\n  \n  void update(int a,int b,E x,int k,int l,int r){\n    eval(k);\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return;\n    }\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n  void update(int a,int b,E x){\n    update(a,b,x,0,0,n);\n  }\n  void eval2(int k){\n    if(k) eval2((k-1)/2);\n    eval(k);\n  }\n  \n  T query(int k){\n    T c=dat[k];\n    k+=n-1;\n    eval2(k);\n    return g(c,laz[k]);\n  }\n};\n//END CUT HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> beet(n,\n\t\t\t    [&](int a,int b){ return b<0?a:b;},\n\t\t\t    [&](int a,int b){ return b<0?a:b;},\n\t\t\t    INT_MAX,-1);\n  for(int i=0;i<q;i++){\n    int c;\n    cin>>c;\n    if(c){\n      int x;\n      cin>>x;\n      cout<<beet.query(x)<<endl;\n    }else{\n      int s,t,x;\n      cin>>s>>t>>x;\n      t++;\n      beet.update(s,t,x);\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/05\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[n/sq+1];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s+1) < 2*sq && t%sq != sq - 1 && s%sq != 0){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+s,t-s+1,x);\n\t\n\tlazy[t/sq] = -1;\n\t\n\tlazy[s/sq] = -1;\n      \n\t//cout << \"debug2\" << endl;\n      }\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  REP(i,res.size()){\n    cout << res[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\n\n\ntemplate<typename T>\nclass segtree {\n    int size;\n    vector<T> valtree;\n    vector<int> ismixedtree;\n\npublic:\n    segtree(int n) {\n        size = 8;\n        while (size < n) size <<= 1;\n        valtree.resize(size*2);\n        ismixedtree.resize(size*2);\n    }\n    \n    void fill(T val){\n        std::fill(ALL(valtree), val);\n        std::fill(ALL(ismixedtree), 0);\n    }\n\n    \n    void _setvalrange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return;\n        \n        if (begin <= rangebegin && rangeend <= end) {\n            ismixedtree[ptr] = false;\n            valtree[ptr] = val;\n            return;\n        }\n        \n        int rangemid = (rangebegin + rangeend) / 2;\n        if (ismixedtree[ptr] == false){\n            // lazy\n            valtree[ptr * 2 + 1] = valtree[ptr];\n            valtree[ptr * 2 + 2] = valtree[ptr];\n            ismixedtree[ptr * 2 + 1] = false;\n            ismixedtree[ptr * 2 + 2] = false;\n        }\n        ismixedtree[ptr] = true;\n\n        _setvalrange(begin, end, val, ptr * 2 + 1, rangebegin, rangemid);\n        _setvalrange(begin, end, val, ptr * 2 + 2, rangemid, rangeend);\n    }\n    inline void setvalrange(int begin, int end, T val) {\n        _setvalrange(begin, end, val, 0, 0, size);\n    }\n\n    T _getval(int index, int ptr, int rangebegin, int rangeend) {\n        if (ismixedtree[ptr] == false) {\n            return valtree[ptr];\n        }\n\n        int rangemid = (rangebegin + rangeend) / 2;\n        if (index < rangemid)\n            return _getval(index, ptr * 2 + 1, rangebegin, rangemid);\n        else\n            return _getval(index, ptr * 2 + 2, rangemid, rangeend);\n    }\n    inline T getval(int index){\n        return _getval(index, 0, 0, size);\n    }\n};\n\n\nll m, n, kei;\n\n\nint main() {\n    int q;\n    scanner >> n >> q;\n\n    segtree<int> seg(n);\n    seg.fill(0x7FFFFFFF);\n\n    repeat(_, q) {\n        int t;\n        scanner >> t;\n        if (t == 0) {\n            int s, t, x;\n            scanner >> s >> t >> x;\n            //--s; --t;\n            seg.setvalrange(s, t + 1, x);\n        }\n        else {\n            int s, t;\n            scanner >> s;\n            //--s; --t;\n            printer << (seg.getval(s)) << '\\n';\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF=pow(2,31)-1;\nstd::vector<P> v(1e6,P(INF,-1));\nint N=1;\nvoid update(int a,int b,int c,int d,int k,int l,int r){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b)v[k]=P(c,d);\n  else{\n    update(a,b,c,d,k*2+1,l,(l+r)/2);\n    update(a,b,c,d,k*2+2,(l+r)/2,r);\n  }\n}\nint ma(int a){\n  int k=a+N-1;\n  P res=v[k];\n  while(k){\n    k=(k-1)/2;\n    if(res.second<v[k].second)res=v[k];\n  }\n  return res.first;\n}\n\nsigned main(){\n  int n,M;\n  cin>>n>>M;\n  while(n>N)N*=2;\n  std::vector<int> ans;\n\n  for(int i=0;i<M;i++){\n    int q;cin>>q;\n    if(q){\n      int a;cin>>a;\n      ans.push_back(ma(a));\n    }\n    else{\n      int s,t,x;cin>>s>>t>>x;\n      update(s,t+1,x,i,0,0,N);\n    }\n  }\n  for(int p:ans)cout<<p<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define INF      2147483647LL\n// #define NUL      2147483647LL\n#define NUL     -1LL\ntypedef long long int llong;\n\nllong n_array;\nllong queries;\nvector<llong> D, Lazy;\n\nvoid printDL();\n\nvoid lazyEv(llong k, llong l, llong r){\n  if( Lazy[k] == NUL ){\n    return;\n  }\n  D[k] = Lazy[k];\n  // if it is not leaf\n  if( r - l > 1 ){\n    Lazy[2*k+1] = Lazy[k];\n    Lazy[2*k+2] = Lazy[k];\n  }\n  Lazy[k] = NUL;\n}\n\nvoid init(llong reqsz){\n  n_array = 1;\n  while( n_array < reqsz ){\n    n_array *= 2;\n  }\n  D.resize(2*n_array-1, 0);\n  Lazy.resize(2*n_array-1, NUL);\n\n  for( llong i = 0 ; i < reqsz ; i++ ){\n    D[i+n_array-1] = INF; // initialize the leaves\n  }\n  for( llong i = n_array - 2 ; i >= 0 ; i--){\n    D[i] = min(D[i*2+1] ,D[i*2+2]); // first update segment tree\n  }\n}\n\nvoid updateRange(llong a, llong b, llong x, llong k=0, llong l=0, llong r=-1){\n  if( r < 0 ){\n    r = n_array;\n  }\n\n  lazyEv(k, l, r);\n  if( b <= l || r <= a){  // case 1\n    return;\n  }else if( a <= l && r <= b ){ // case 2\n    Lazy[k] = x;\n    lazyEv(k, l, r);\n  }else{ // case 3\n    updateRange(a, b, x, 2*k+1, l, (l+r)/2);\n    updateRange(a, b, x, 2*k+2, (l+r)/2, r);\n    D[k] = min(D[2*k+1], D[2*k+2]);\n  }\n\n}\n\nllong find(llong a, llong b, llong k=0, llong l=0 , llong r=-1){\n  if( r < 0 ){\n    r = n_array;\n  }\n  lazyEv(k, l, r);\n  if( b <= l || r <= a){  // case 1\n    return INF;\n  }else if( a <= l && r <= b ){ // case 2\n    return D[k];\n  }else{ // case 3\n    llong vl = find(a, b, 2*k+1, l, (l+r)/2);\n    llong vr = find(a, b, 2*k+2, (l+r)/2, r);\n    return min(vl,vr);\n  }\n}\n\nvoid printDL(){ // For debug\n  llong i = 0;\n  llong j = 0;\n  for (const auto& e : D) {\n     printf(\"D[%lld]=\" ,i); i++;\n     std::cout << e << std::endl;\n  }\n  for (const auto& e : Lazy) {\n     printf(\"Lazy[%lld]=\" ,j); j++;\n     std::cout << e << std::endl;\n  }\n}\n\nint main(){\n  llong reqsz;\n  scanf(\"%lld %lld\" ,&reqsz ,&queries);\n  init(reqsz);\n  for(llong i = 0 ; i < queries ; i++){\n    llong com;\n    scanf(\"%lld\" ,&com ); \n    if( com== 0){\n      llong s, t, x;\n      scanf(\"%lld %lld %lld\" ,&s ,&t ,&x );\n      updateRange(s, t+1, x);\n    }else{\n      llong idx;\n      scanf(\"%lld\" ,&idx );\n      llong result = find(idx, idx+1);\n      printf(\"%lld\\n\" ,result);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define N 131072 //100000\n#define MAXVAL 2147483647 //((long int) ((unsigned long) (1 << 31) - 1))  //*2\nint min(int a, int b){return a>b?b:a;}\nint data[2*131072+100];      //the size of array, for present the tree\n\n//range update and single query\n\n/*\nalways binary [node_left,node_right]\n*/ \nvoid update(int update_left, int update_right, int x, int current_node,int node_left,int node_right){\n\t//not in the range\n\tif(update_right<node_left||update_left>node_right){\n\t\treturn;\t\n\t}else if(update_left<=node_left&&update_right>=node_right){\n\t\tdata[current_node] = x;\n\t}else{\n\t\t//how to check if the\n\t\t//unfold the node, the amxValue->-1\n\t\tif(data[current_node]!=-1){ //-1: unfold\n\t\t\tupdate(node_left, node_right,data[current_node],current_node*2+1,node_left,(node_left+node_right)/2);\n\t\t\tupdate(node_left, node_right,data[current_node],current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t\t\tdata[current_node]=-1;\n\t\t}\n\t\t//update \n\t\tupdate(update_left, update_right, x, current_node*2+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left, update_right, x, current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t}\n}\n//segment of thr last layer\n//I did notdeal with 0\n//backtrack the tree from the bottom, \n\nvoid update2(int x, int node_id,int node_left, int node_right){//x begin from data[0], node_id from 1\n\tif(x!=-1){\n\t\tdata[node_id] = x; \n\t}\n\t//printf(\"%d %d %d\\n\",node_left,node_right,node_id);\n\tif(node_left==node_right) {\n\t\treturn;\n\t}\n\tif(data[node_id]!=-1){\n\t\t//printf(\"%d\\n\",data[node_id]);\n\t\tupdate2(data[node_id], node_id*2+1,node_left, (node_left+node_right)/2);\n\t\tupdate2(data[node_id], node_id*2+2,(node_left+node_right)/2+1, node_right);\n\t\tdata[node_id]=-1;\n\t} \n\telse {\n\t\tupdate2(-1, node_id*2+1,node_left, (node_left+node_right)/2);\n\t\tupdate2(-1, node_id*2+2,(node_left+node_right)/2+1, node_right);\n\t}\n\t\n}\n//search from top to bottom\nint search(int index,int origin_index){\n\t\n\t//if(index<0) return MAXVAL;\n\tif(data[index]!=-1) return data[index];\n\t\n\t\n\treturn search((index-1)/2,origin_index);\n}\nint main(){\n\tint n, q;\n\t//FILE *fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\tint N = 1;\n\twhile(N<n) N = N<<1;\n\tif(n==1) N=2;\n\tfor(int i = 0; i<=2*N-2; i++){\n\t\tdata[i] = MAXVAL;\n\t}\n\t//printf(\"%d\",(-1/2));\n\tfor(int i = 0; i<q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tint a,b,c;\n\t\t\n\t\tif(temp == 0) {  //update\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tupdate(a,b,c,0,0,N-1);\n\t\t\t//test print\n\t\t\t/*for(int i = 0; i<=2*N-2; i++){\n\t\t\t\tprintf(\"%d \",data[i]);\n\t\t\t}printf(\"\\n\");*/\n\t\t\t\n\t\t} else if(temp == 1){ //search\n\t\t\t//printf(\"N:%d\\n\",N);\n\t\t\tupdate2(data[0],1,0,(N-1)/2);\n\t\t\t//printf(\"N:%d\\n\",N);\n\t\t\tupdate2(data[0],2,(N-1)/2+1,N-1);\n\t\t//test print\n\t\t\t/*for(int i = 0; i<=2*N-2; i++){\n\t\t\t\tprintf(\"%d \",data[i]);\n\t\t\t}printf(\"\\n\");*/\n\t\t\t\n\t\t\tscanf(\"%d\",&a);\n\t\t\tprintf(\"%d\\n\",search(a+N-1,a+N-1));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[nsq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t  lazy[t/sq] = -1;\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n// T: The type of values.\n// U: The type of operators.\n// Verified: AOJ-DSL2F\ntemplate<typename T, typename U>\nclass LazyPropagationSegmentTreeNoGetRange {\n private:\n  function<U(U, U)> op_merge;\n  U empty_op;\n  function<T(T, U)> apply_op;\n  int num_nodes;\n  vector<T> values;\n  vector<U> op_nodes;\n\n  void DoLazyPropagation(int node_index) {\n   if (op_nodes[node_index] != empty_op) {\n      if (node_index < num_nodes / 2) {\n        op_nodes[2 * node_index] =\n            op_merge(op_nodes[2 * node_index], op_nodes[node_index]);\n        op_nodes[2 * node_index + 1] =\n            op_merge(op_nodes[2 * node_index + 1], op_nodes[node_index]);\n      } else {\n        int value_index = node_index - num_nodes / 2;\n        values[value_index] =\n            apply_op(values[value_index], op_nodes[node_index]);\n      }\n      op_nodes[node_index] = empty_op;\n    }\n  }\n\n  void ApplyOpRangeInternal(\n      int node_index, int node_l, int node_r, int l, int r, U op) {\n    DoLazyPropagation(node_index);\n\n    if (node_r <= l || r <= node_l) return;\n\n    if (l <= node_l && node_r <= r) {\n      op_nodes[node_index] = op;\n      DoLazyPropagation(node_index);\n      return;\n    }\n    int node_m = (node_l + node_r) / 2;\n    ApplyOpRangeInternal(2 * node_index, node_l, node_m, l, r, op);\n    ApplyOpRangeInternal(2 * node_index + 1, node_m, node_r, l, r, op);\n  }\n\n  T GetInternal(int node_index, int node_l, int node_r, int i) {\n    DoLazyPropagation(node_index);\n\n    if (node_index >= num_nodes / 2) {\n      return values[i];\n    }\n\n    int node_m = (node_l + node_r) / 2;\n    if (i < node_m) {\n      return GetInternal(2 * node_index, node_l, node_m, i);\n    } else {\n      return GetInternal(2 * node_index + 1, node_m, node_r, i);\n    }\n  }\n\n public:\n  LazyPropagationSegmentTreeNoGetRange(\n      function<U(U, U)> in_op_merge, U in_empty_op,\n      function<T(T, U)> in_apply_op, vector<T> in_values) :\n          op_merge(in_op_merge), empty_op(in_empty_op), apply_op(in_apply_op),\n          values(in_values) {\n    int n = values.size();\n    num_nodes = 1;\n    while (num_nodes < n) num_nodes *= 2;\n    num_nodes *= 2;\n    op_nodes = vector<U>(num_nodes, empty_op);\n  }\n\n  // Applies the operator to the range [l, r).\n  void ApplyOpRange(int l, int r, U op) {\n    return ApplyOpRangeInternal(1, 0, num_nodes / 2, l, r, op);\n  }\n\n  T Get(int i) { return GetInternal(1, 0, num_nodes / 2, i); }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, q;\n  cin >> n >> q;\n  vector<int> xs(n, INT_MAX);\n\n  auto op_merge =\n      function<int(int, int)>([] (int x, int y) { return y; });\n  constexpr int EMPTY_OP = -1;\n  auto apply_op =\n      function<int(int, int)>([] (int x, int op) { return op; });\n  auto tree = LazyPropagationSegmentTreeNoGetRange<int, int>(\n      op_merge, EMPTY_OP, apply_op, xs);\n\n  for (int i = 0; i < q; i++) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int s, t, v;\n      cin >> s >> t >> v;\n      tree.ApplyOpRange(s, t + 1, v);\n      // tree.Dump();\n    } else {\n      int i;\n      cin >> i;\n      cout << tree.Get(i) << endl;\n      // tree.Dump();\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate <class Z> Z getint() {\n  char c = getchar();\n  bool neg = c == '-';\n  Z res = neg ? 0 : c - '0';\n  while (isdigit(c = getchar())) res = res * 10 + (c - '0');\n  return neg ? -res : res;\n}\ntemplate <class Z> void putint(Z a, char c = '\\n') {\n  if (a < 0) putchar('-'), a = -a;\n  int d[40], i = 0;\n  do d[i++] = a % 10; while (a /= 10);\n  while (i--) putchar('0' + d[i]);\n  putchar(c);\n}\n\ntemplate <class T> struct assign_segtree {\n  const int n;\n  vector<pair<int, T>> t;\n  assign_segtree(int _n, T a) : n(_n), t(2 * n, {0, a}) {}\n  void assign(int l, int r, T a) {\n    static int time = 0;\n    ++time;\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) t[l++] = {time, a};\n      if (r & 1) t[--r] = {time, a};\n    }\n  }\n  T get(int i) const {\n    auto res = t[i += n];\n    while (i >>= 1) if (t[i].first > res.first) res = t[i];\n    return res.second;\n  }\n};\n\nint main() {\n  int n = getint<int>();\n  int q = getint<int>();\n  assign_segtree<int> st(n, 0x7fffffff);\n  while (q--) {\n    if (getint<int>() == 0) {\n      int l = getint<int>();\n      int r = getint<int>() + 1;\n      int a = getint<int>();\n      st.assign(l, r, a);\n    } else {\n      putint(st.get(getint<int>()));\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass lazy_segtree {\n    private:\n        int size;\n        vector<int> node,lazy;\n    public:\n        lazy_segtree(int n_) {\n            size=1;\n            while (size<n_) size*=2;\n            node.resize(2*size, 0);\n            lazy.resize(2*size, 0);\n        }\n\n        void setlazy(int k, int v) {\n            if (2*size-1<=k) return ;\n            lazy[k] += v;\n            node[k] += v;\n        }\n\n        void push(int k) {\n            if (lazy[k] == 0) return ;\n            setlazy(k * 2 + 1, lazy[k]);\n            setlazy(k * 2 + 2, lazy[k]);\n            lazy[k] = 0;\n        }\n\n        void range_add(int queryL,int queryR,int val,int k=0,int nodeL=0,int nodeR=-1) {\n            if (nodeR==-1) nodeR=size;\n            if (nodeR<=queryL || queryR<=nodeL) return ;\n            if (queryL<=nodeL && nodeR<=queryR) {\n                setlazy(k,val);\n                return ;\n            }\n            else {\n                push(k);\n                int nodeM=(nodeL+nodeR)/2;\n                range_add(queryL,queryR,val,k*2+1,nodeL,nodeM);\n                range_add(queryL,queryR,val,k*2+2,nodeM,nodeR);\n                return ;\n            }\n        }\n\n        int get_node(int queryL,int queryR,int k=0,int nodeL=0,int nodeR=-1) {\n            if (nodeR==-1) nodeR=size;\n            if (nodeR<=queryL || queryR<=nodeL) return 0;\n            if (queryL<=nodeL && nodeR<=queryR) return node[k];\n            else {\n                push(k);\n                int nodeM=(nodeL+nodeR)/2;\n                int vl=get_node(queryL,queryR,k*2+1,nodeL,nodeM);\n                int vr=get_node(queryL,queryR,k*2+2,nodeM,nodeR);\n                return vl+vr;\n            }\n        }\n};\n\nint n,q;\n\nint main(){\n    cin >> n >> q;\n    lazy_segtree ls(n);\n    for (int i=0; i<q; i++) {\n        int que,s,t,x,idx;\n        cin >> que;\n        if (que==0) {\n            cin >> s >> t >> x;\n            ls.range_add(s-1,t,x);\n        }\n        else {\n            cin >> idx;\n            cout << ls.get_node(idx-1,idx) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include <vector>\n#include <functional>\n#include <limits.h>\n\ntemplate<typename T, typename S>\nstruct LazySegTree{\n    int size;\n    std::vector<T> nod;\n    std::vector<S> monoid;\n    std::vector<bool> flag;\n    T t0;\n    S s0;\n    std::function<T(T,T)> operation;\n    std::function<S(S,S)> merge;\n    std::function<T(T,S,int)> calc;\n    LazySegTree(int n, T _t0, S _s0, std::function<T(T,T)> _operation, std::function<S(S,S)> _merge, std::function<T(T,S,int)> _calc){\n        t0 = _t0;\n        s0 = _s0;\n        operation = _operation;\n        merge = _merge;\n        calc = _calc;\n        size = 1;\n        while(n > size) size *= 2;\n        nod = std::vector<T> (size*2-1, t0);\n        monoid = std::vector<S> (size*2-1, s0);\n        flag = std::vector<bool> (size*2-1);\n    }\n    void disassembly(int k, int l, int r){\n        if(r-l>1){\n            monoid[k*2+1] = merge(monoid[k*2+1], monoid[k]);\n            monoid[k*2+2] = merge(monoid[k*2+2], monoid[k]);\n            flag[k*2+1] = true;\n            flag[k*2+2] = true;\n        }\n        nod[k] = calc(nod[k],monoid[k],r-l);\n        monoid[k] = s0;\n        flag[k] = false;\n    }\n    S update_query(int a,int b,int k,int l,int r,S x){\n        //[a,b)について\n        //kは節点の番号,[l,r)はその節点がカバーする範囲\n        if(r<=a||b<=l){ //[a,b)と[l,r)が重なって無いとき\n            if(flag[k]) return calc(nod[k], monoid[k], r-l);\n            return nod[k];\n        }\n        if(a<=l && r<=b){ //[a,b)が[l,r)を完全に含んでいるとき\n            monoid[k] = merge(monoid[k], x);\n            flag[k] = true;\n            return calc(nod[k], monoid[k],r-l);\n        }\n        else{\n            if(flag[k]) disassembly(k,l,r);\n            nod[k] = operation(update_query(a,b,k*2+1,l,(l+r)/2,x), update_query(a,b,k*2+2,(l+r)/2,r,x));\n            return nod[k];\n        }\n    }\n    void update(int a, int b, S x){\n        // [a,b)をxに更新\n        update_query(a,b,0,0,size,x);\n    }\n    T sum_query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l){\n            return t0;\n        }\n        if(a<=l && r<=b){\n            if(flag[k]) return calc(nod[k],monoid[k],r-l);\n            else return nod[k];\n        }\n        if(flag[k]) disassembly(k, l, r);\n        return operation(sum_query(a,b,k*2+1,l,(l+r)/2),sum_query(a,b,k*2+2,(l+r)/2,r));\n    }\n    T sum(int a, int b){\n        return sum_query(a,b,0,0,size);\n    }\n   void deb(){ //全ノードの出力\n\t\tfor(int i=0;i<size*2-1;i++){\n\t\t\tif(i==size*2-2){\n\t\t\t\tstd::cout << nod[i] <<std:: endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << nod[i] << ' ';\n\t\t\t}\n\t\t}\n        for(int i=0;i<size*2-1;i++){\n\t\t\tif(i==size*2-2){\n\t\t\t\tstd::cout << monoid[i] <<std:: endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << monoid[i] << ' ';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n};\n\nint main(){\n    int n,q; std::cin >> n >> q;\n    std::vector<int> ans(0);\n    LazySegTree<long long, long long> lst(n,INT_MAX,0,[](long long a, long long b){return std::min(a,b);}, [](long long a, long long b){return b;},[](long long a, long long b, long long c){return b;});\n    for(int i= 0;i<q;i++){\n        int w; std::cin >> w;\n        if(w == 0){\n            int s,t,x; std::cin >> s >> t >> x;\n            lst.update(s, t+1, x);\n        }\n        else{\n            int s,t; std::cin >> s;\n            ans.push_back(lst.sum(s,s+1));\n        }\n        //lst.deb();\n    }\n    for(int i = 0;i<ans.size();i++) std::printf(\"%d\\n\", ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 18;\n#define int long long\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=INT_MAX;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  //cout<<k<<\"/\"<<dat[k].second<<endl;\n  while(k>0){\n    k=(k-1)/2;\n    //cout<<k<<\"/\"<<dat[k].second<<endl;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,int k,P p,int l,int r){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n    //cout<<a<<\":\"<<b<<\":\"<<k<<\":\"<<l<<\":\"<<r<<endl;\n     dat[k]=p;\n  }else{\n    update(a,b,k*2+1,p,l,(l+r)/2);\n    update(a,b,k*2+2,p,(l+r)/2,r);\n  }\n}\nsigned main(){\n  int _n,q;\n  cin>>_n>>q;\n  init(_n+1);\n  for(int i=0;i<q;i++){\n    int f;\n    cin>>f;\n    if(!f){\n      int s,t,x;\n      cin>>s>>t>>x;\n      //cout<<i<<\":\"<<x<<endl;\n      update(s,t+1,0,P(i,x),0,n);\n    }else{\n      int u;\n      cin>>u;\n      cout<<query(u)<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, v, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u, long long v) {\n\tif (s <= p || q <= r) { seg[u] = v; return; }\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tlong long w = seg[u]; seg[u] = INF;\n\tupdate(p, q, r, (r + s) / 2, t, u * 2, w);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1, w);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((p <= r && s <= q) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> v; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_ * 2; i++)seg[i] = INF;\n\tfor (int i = 1; i <= v; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1, INF); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1LL << 31) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\ntemplate<typename T, typename E>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, size_t)>;\n    int n;\n    F f; //要素と要素のマージ\n    G g; //要素に作用素を作用\n    H h; //作用素と作用素をマージ\n    T ti; //要素の単位元?\n    E ei; //作用素の単位元?\n    P p; //b個の作用素aをマージした場合\n    vector<T> dat;\n    vector<E> laz;\n\n    SegmentTree(int n_, F f, G g, H h, T ti, E ei,\n                P p = [](E a, size_t b) {\n                    b++;\n                    return a;\n                }) :\n            f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n        dat.assign(2 * n - 1, ti);\n        laz.assign(2 * n - 1, ei);\n    }\n\n    void build(int n_, vector<T> v) {\n        for (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k) {\n        if (laz[k] == ei) return;\n        if (k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = ei;\n    }\n\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return dat[k];\n        if (a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    T update(int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return ti;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    void update(int k, T x) {\n        query(k, k + 1);//evaluate\n        k += n - 1;\n        dat[k] = x;\n        while (k) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    n++;\n    function<ll(ll, ll)> f = [](ll a, ll b) { return a + b; }; // 要素と要素のマージ\n    auto g = [](ll a, ll b) {\n        if (b == 0)return a;\n        else return b;\n    }; // 要素に作用素を作用\n    auto h = [](ll a, ll b) {\n        if (b == 0)return a;\n        else return b;\n    }; // 作用素と作用素をマージ\n    auto p = [](ll a, int b) { return a; }; // 作用素を区間加算する場合\n    ll ti = 0;\n    ll ei = 0;\n    SegmentTree<ll, ll> treeone(n, f, g, h, ti, ei, p);\n    vector<ll> v(n,INF);\n    treeone.build(n,v);\n\n    while (q--) {\n        int com;\n        cin >> com;\n        if (com) {\n            int x;\n            cin >> x;\n            cout << treeone.query(x, x + 1) << endl;\n        } else {\n            int s, t;\n            ll x;\n            cin >> s >> t >> x;\n            treeone.update(s, t + 1, x);\n\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int N = 1 << 17;\n\n//?????????????????????0?§???????\n//????°????????±???????????????°??????(RMQ)\n\n//?????°???????????¨???????????°??????????????????\n\nint n,n_,q,ud[2*N-1],t[2*N-1];\n\n//?????????\n//n_???x??\\??????????°????2????????????\nvoid init(int x)\n{\n\t//?°????????????????????´???°???2???????????????\n\tn_=1;\n\twhile(n_<x){\n\t\tn_*=2;\n\t}\n\trep(i,2*n_-1){\n\t\tud[i] = (int)((1LL<<31) -1LL);\n\t\tt[i] = -1;\n\t}\n}\n\n//k????????????????????§??????\nint find(int k)\n{\n\tP res;\n\t//????????????\n\tk += n_-1;\n\tres.first = ud[k];\n\tres.second = t[k];\n\t//?????????????????´??°\n\twhile(k>0){\n\t\tk = (k-1)/2;\n\t\tif(t[k] > res.second){\n\t\t\tres.first = ud[k];\n\t\t\tres.second = t[k];\n\t\t}\t\n\t}\n\treturn res.first;\n}\n\n//[a,b)???????°????????±??????????\n//k??????????????????\n//????????????query(a,b,0,0,n_)??¨???????????¶???(n_??¨???????????¨?????¨???)\nvoid update(int a,int b,int k,int l,int r,int val,int id)\n{\n\tif(r <= a || b <= l){\n\t\treturn;\n\t}\n\tif(a <= l && r <= b){\n\t\tud[k] = val;\n\t\tt[k] = id;\n\t}else{\n\t\tupdate(a,b,2*k+1,l,(l+r)/2,val,id);\n\t\tupdate(a,b,2*k+2,(l+r)/2,r,val,id);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tinit(n);\n\trep(i,q){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x==0){\n\t\t\tint s,t,u;\n\t\t\tscanf(\"%d%d%d\",&s,&t,&u);\n\t\t\tupdate(s,t+1,0,0,n_,u,i);\n\t\t}else{\n\t\t\tint s;\n\t\t\tscanf(\"%d\",&s);\n\t\t\tprintf(\"%d\\n\",find(s));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\nusing namespace std;\n/*\nstruct Monoid {\n    using T = _underlying_set_;\n    static  T op(const T& a, const T& b) { return _a_op_b_; }\n    static constexpr T identity() { return _identity_element_; }\n};\n*/\ntemplate <class Monoid,class MonoidAct>\nclass LazySegmentTree {\nprivate:\n    using T1 = typename Monoid::T;\n    using T2 = typename MonoidAct::T;\n    vector<T1> data;\n    vector<T2> lazy;\n    const size_t h, n;\n\n    //オペレータ2 MonoidAct -> Monoid\n    static T1 op2(const T1& l,const T2& r) { return r != MonoidAct::id() ? r : l; }\n\nprivate:\n    void eval(size_t node) {\n        if (lazy[node] == MonoidAct::id()) return;\n        if (node < n) {\n            lazy[node * 2] = MonoidAct::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = MonoidAct::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = op2(data[node], lazy[node]);\n        lazy[node] = MonoidAct::id();\n    }\n    void update(size_t node) {\n        data[node] = Monoid::op1(op2(data[node * 2], lazy[node * 2])\n                        ,op2(data[node * 2 + 1], lazy[node * 2 + 1]));\n    }\n\npublic:\n    LazySegmentTree(int n_)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, Monoid::id());lazy.resize(n * 2, MonoidAct::id());}\n    LazySegmentTree(int n_, T1 v1)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, v1);lazy.resize(n * 2, MonoidAct::id());}\n    LazySegmentTree(const vector<T1>& data_)\n        : h(ceil(log2(data_.size()))), n(1 << h) {\n            data.resize(n * 2,Monoid::id());\n            lazy.resize(n * 2, MonoidAct::id());\n            init(data_);    \n    }\n    void init() {\n        for (int i = n - 1; i >= 1; i--) data[i] = Monoid::op1(data[i * 2], data[i * 2 + 1]);\n    }\n    void init(const vector<T1>& data_) {\n        for (int i = 0; i < (int)data_.size(); i++) data[i + n] = data_[i];\n        init();\n    }\n\n    void update(size_t l, size_t r, T2 val) {\n        l += n, r += n - 1;\n        for (int i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        size_t tl = l, tr = r;\n        r++;\n        while (l < r) {\n            if (l & 1) lazy[l] = MonoidAct::op3(lazy[l], val), l++;\n            if (r & 1) r--, lazy[r] = MonoidAct::op3(lazy[r], val);\n            l >>= 1; r >>= 1;\n        }\n        while (tl >>= 1, tr >>= 1, tl) {\n            if (lazy[tl] == MonoidAct::id()) update(tl);\n            if (lazy[tr] == MonoidAct::id()) update(tr);\n        }\n    }\n    T1 find(size_t l, size_t r) {\n        l += n, r += n - 1;\n        for (int i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        r++;\n        T1 res1 = Monoid::id(), res2 = Monoid::id();\n        while (l < r) {\n            if (l & 1) res1 = Monoid::op1(res1, op2(data[l], lazy[l])), l++;\n            if (r & 1) r--, res2 = Monoid::op1(op2(data[r], lazy[r]), res2);\n            l >>= 1; r >>= 1;\n        }\n        return Monoid::op1(res1, res2);\n    }\n};\n\n// findモノイド\nstruct RMQ { // 区間の最小\n    using T = int;\n    static T op1(const T& a, const T& b) { return min(a, b); }\n    static constexpr T id() {return numeric_limits<T>::max(); }\n};\n\n// updateモノイド\nstruct RUQ { // 区間に代入更新\n    using T = int;\n    static T op3(const T& l,const T& r) { return r != id() ? r : l;}\n    static constexpr T id() { return (-1); }\n};\n\nint main(void) {\n    int n,q,com,s,t,x;\n    cin >> n >> q;\n    vector<int> a(n,numeric_limits<int>::max());\n    LazySegmentTree<RMQ,RUQ> sg(a);\n    REP(i,q) {\n        cin >> com;\n        if (!com) {\n            cin >> s >> t >> x;\n            sg.update(s,t+1,x);\n        }\n        else {\n            cin >> s;\n            cout << sg.find(s,s+1) << endl;\n        }\n    }\n}\n//00:13 sec    5408 KB     4706 bytes     \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////\n// Range Update Query //\n////////////////////////\n\nclass RUQ {\nprivate:\n\tstd::vector<int64_t> container_, time_container_;\n\tconst int64_t optional_{(1ll << 31) - 1};\n\tint update_num_{};\n\n\tvoid build(const unsigned int array_size)\n\t{\n\t\tunsigned int length{1};\n\t\twhile (length < array_size)\n\t\t\tlength <<= 1;\n\t\tcontainer_.resize(2 * length, optional_);\n\t\ttime_container_.resize(2 * length, -1);\n\t}\n\npublic:\n\tRUQ(const unsigned int array_size) { build(array_size); }\n\tRUQ(const std::vector<int64_t> &array)\n\t{\n\t\tbuild(array.size());\n\t\tstd::copy(array.begin(), array.end(), container_.begin() + (container_.size() >> 1));\n\t\tfor (int i{((int)container_.size() >> 1) - 1}; i > 0; i--)\n\t\t\tcontainer_[i] = container_[2 * i] + container_[2 * i + 1];\n\t}\n\t// left,rightは0-indexed、[left, right)の半開区間\n\tvoid update(const int left, const int right, const int64_t assigned)\n\t{\n\t\tfor (int left_i{std::max(0, left) + ((int)container_.size() >> 1)}, right_i{std::min((int)container_.size() >> 1, right) + ((int)container_.size() >> 1)};\n\t\t\tleft_i < right_i; left_i >>= 1, right_i >>= 1\n\t\t\t)\n\t\t{\n\t\t\tif (left_i & 1)\n\t\t\t{\n\t\t\t\tcontainer_[left_i] = assigned;\n\t\t\t\ttime_container_[left_i] = update_num_;\n\t\t\t\tleft_i++;\n\t\t\t}\n\t\t\tif (right_i & 1)\n\t\t\t{\n\t\t\t\tright_i--;\n\t\t\t\tcontainer_[right_i] = assigned;\n\t\t\t\ttime_container_[right_i] = update_num_;\n\t\t\t}\n\t\t}\n\t\tupdate_num_++;\n\t}\n\t// indexは0-indexed\n\tint64_t get(const int index) const\n\t{\n\t\tint64_t last{optional_};\n\t\tint last_time{-1};\n\t\tfor (int assign_place{index + ((int)container_.size() >> 1)}; assign_place > 0; assign_place >>= 1)\n\t\t\tif (time_container_[assign_place] > last_time)\n\t\t\t{\n\t\t\t\tlast = container_[assign_place];\n\t\t\t\tlast_time = time_container_[assign_place];\n\t\t\t}\n\t\treturn last;\n\t}\n};\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_E\nint main()\n{\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\n\tRUQ raq(n);\n\tfor (int q_i{}; q_i < q; q_i++)\n\t{\n\t\tint com;\n\t\tscanf(\"%d\", &com);\n\t\tif (com)\n\t\t{\n\t\t\tint i;\n\t\t\tscanf(\"%d\", &i);\n\t\t\tprintf(\"%lld\\n\", raq.get(i));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s, t, x;\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\traq.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 1-indexed\ntemplate <class T, class E>\nstruct SegmentTreeLaze {\n  // a,b:T c,d:E e:E(unit)\n  // g(f(a,b),c) = f(g(a,c),g(b,c))\n  // g(g(a,c),d) = g(a,h(c,d))\n  // g(a,e) = a\n  typedef function<T(T, T)> F;\n  typedef function<T(T, E)> G;\n  typedef function<E(E, E)> H;\n  int n, height;\n  F f;\n  G g;\n  H h;\n  T tunit;\n  E eunit;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTreeLaze(){};\n  SegmentTreeLaze(int newn, F f, G g, H h, T nt, E ne)\n      : f(f), g(g), h(h), tunit(nt), eunit(ne) {\n    init(newn);\n  }\n  void init(int newn) {\n    n = 1, height = 0;\n    while(n < newn) n <<= 1, ++height;\n    dat.assign(n << 1, tunit);\n    laz.assign(n << 1, eunit);\n  }\n\n  inline T reflect(int k) {\n    return laz[k] == eunit ? dat[k] : g(dat[k], laz[k]);\n  }\n\n  inline void eval(int k) {\n    if(laz[k] == eunit) return;\n    laz[k << 1] = h(laz[k << 1], laz[k]);\n    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);\n    dat[k] = reflect(k);\n    laz[k] = eunit;\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i; --i) eval(k >> i);\n  }\n\n  void recalc(int k) {\n    while(k >>= 1)\n      dat[k] = f(reflect(k << 1), reflect((k << 1) | 1));\n  }\n  // [a,b)\n  void update(int a, int b, E newdata) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) laz[l] = h(laz[l], newdata), l++;\n      if(r & 1) --r, laz[r] = h(laz[r], newdata);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  void set_val(int k, T newdata) {\n    thrust(k += n);\n    dat[k] = newdata;\n    laz[k] = eunit;\n    recalc(k);\n  }\n\n  // [a,b)\n  T query(int a, int b) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    T vl = tunit, vr = tunit;\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) vl = f(vl, reflect(l++));\n      if(r & 1) vr = f(reflect(--r), vr);\n    }\n    return f(vl, vr);\n  }\n};\n\nlong long n, q;\n\nint main() {\n  cin >> n >> q;\n  using P = pair<long long, long long>;\n  auto f = [](P l, P r) {\n    return P(l.first + r.first, l.second + r.second);\n  };\n  auto g = [](P l, long long r) {\n    return P(r * l.second, l.second);\n  };\n  auto h = [](long long l, long long r) { return r; };\n  SegmentTreeLaze<P, long long> seg(n, f, g, h, P(0, 0),\n                                    -100000);\n  for(int i = 0; i < n; ++i)\n    seg.set_val(i, P(2147483647, 1));\n  for(int i = 0; i < q; ++i) {\n    long long c, s, t, x;\n    cin >> c >> s;\n    if(c) { cout << seg.query(s, s + 1).first << endl; }\n    else {\n      cin >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n    s_min = 100000;\n    t_max = 0;\n    m = 0;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){ cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[m] <= i && t[m] >= i){ cout << x[m] << endl; break; }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstdint>\n\nusing namespace std;\n\ntemplate <class T, class Updater, class Aggregator>\nclass LazySegmentTree {\n    size_t n, m;\n    vector<T> tree, buf;\n    vector<bool> buffering;\n    Updater update;\n    Aggregator aggregate;\n    const T e;\n    void buffer(size_t i, T x) {\n        buffering[i] = true;\n        buf[i] = update(buf[i], x);\n        tree[i] = update(buf[i], x);\n    }\n    inline void propagate(size_t i) {\n        if (!buffering[i]) return;\n\n        buffer(i<<1|0, buf[i]);\n        buffer(i<<1|1, buf[i]);\n        buf[i] = e;\n        buffering[i] = false;\n    }\n    inline void modify(size_t l, size_t r, const T &x, size_t i, size_t a, size_t b) {\n        if (r <= a || b <= l) return;\n        if (l <= a && b <= r) {\n            buffer(i, x);\n            return;\n        }\n        propagate(i);\n\n        size_t c=(a+b)>>1;\n        modify(l, r, x, i<<1|0, a, c);\n        modify(l, r, x, i<<1|1, c, b);\n        tree[i] = aggregate(tree[i<<1|0], tree[i<<1|1]);\n    }\n    T query(size_t l, size_t r, size_t i, size_t a, size_t b) {\n        if (r <= a || b <= l) return e;\n        if (l <= a && b <= r) return tree[i];\n\n        propagate(i);\n        size_t c=(a+b)>>1;\n        T vl=query(l, r, i<<1|0, a, c);\n        T vr=query(l, r, i<<1|1, c, b);\n\n        return aggregate(vl, vr);\n    }\npublic:\n    LazySegmentTree(size_t m, T e=T()): n(1), m(m), e(e) {\n        while (n < m) n <<= 1;\n\n        tree.assign(n<<1, e);\n        buf.assign(n<<1, e);\n        buffering.assign(n<<1, false);\n    }\n    void modify(size_t l, size_t r, const T &x) {\n        modify(l, r, x, 1, 0, n);\n    }\n    T query(size_t l, size_t r) {\n        return query(l, r, 1, 0, n);\n    }\n};\n\ntemplate <class T>\nstruct Updater {\n    T operator ()(const T &lhs, const T &rhs) {\n        return rhs;\n    }\n};\n\ntemplate <class T>\nstruct Min {\n    T operator ()(const T &lhs, const T &rhs) {\n        return min(lhs, rhs);\n    }\n};\n\nint main() {\n    size_t n;\n    int q;\n    scanf(\"%zu %d\\n\", &n, &q);\n\n    int64_t e=(1LL<<31)-1;\n    LazySegmentTree<int64_t, Updater<int64_t>, Min<int64_t>> tree(n, e);\n    for (int i=0; i<q; ++i) {\n        int query;\n        scanf(\"%d\", &query);\n\n        if (query == 0) {\n                size_t s, t;\n                int64_t x;\n                scanf(\"%zu %zu %lld\", &s, &t, &x);\n                tree.modify(s, t+1, x);\n        } else if (query == 1) {\n                size_t s;\n                scanf(\"%zu\", &s);\n                printf(\"%lld\\n\", tree.query(s, s+1));\n        } else {\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=(1LL<<31)-1;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nclass SquareDivision{\n    private:\n        const int BUCKET_SIZE=256;\n        ll N, B;\n        vector<ll> data;\n        vector<bool> lazy_flag;\n        vector<ll> lazy_update;\n\n    public:\n        void prepare(int n){\n            B=(n+BUCKET_SIZE-1)/BUCKET_SIZE;\n            N=B*BUCKET_SIZE;\n            data.assign(N, INF);\n            lazy_flag.assign(B, false);\n            lazy_update.assign(B, 0);\n        }\n\n        void eval(int k){\n            if(lazy_flag[k]){\n                lazy_flag[k]=false;\n                for(int i=k*BUCKET_SIZE; i<(k+1)*BUCKET_SIZE; i++){\n                    data[i]=lazy_update[k];\n                }\n            }\n        }\n\n        // [s, t)\n        void update(int s, int t, ll x){\n            for(int k=0; k<B; k++){\n                int l=k*BUCKET_SIZE, r=(k+1)*BUCKET_SIZE;\n\n                if(r<=s || t<=l) continue;\n\n                if(s<=l && r<=t){\n                    lazy_flag[k]=true;\n                    lazy_update[k]=x;\n                }\n                else{\n                    eval(k);\n                    for(int i=max(s, l); i<min(t, r); i++){\n                        data[i]=x;\n                    }\n                }\n            }\n        }\n\n        int find(int i){\n            int k=i/BUCKET_SIZE;\n            eval(k);\n            return data[i];\n        }\n};\n\nsigned main(){\n    int n, q; cin>>n>>q;\n    SquareDivision ans;\n    ans.prepare(n);\n\n    while(q--){\n        int c; cin>>c;\n        if(c==0){\n            ll s, t, x; cin>>s>>t>>x;\n            ans.update(s, t+1, x);\n        }\n        else{\n            ll x; cin>>x;\n            cout << ans.find(x) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid update(int a, int b,int x, int k, int l, int r, vector<int>& node) {\n\tif (r <= a || b <= l)return;\n\tif (a <= l && r <= b) {\n\t\tnode[k] = x; return;\n\t}\n\telse {\n\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2, node);\n\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r, node);\n\t}\n}\n\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_, q;  cin >> n_ >> q;\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<int> node(2 * n - 1, INT_MAX);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) { \n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tupdate(s, t+1, x, 0, 0, n, node);\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\tfor (auto x : node) {\n\t\t\t\tcout << x << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t\tint j; cin >> j;\n\t\t\tcout << node[n - 1 + j] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  int n,height;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){}\n\n  void init(int n_){\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    dat.assign(2*n,ti);\n    laz.assign(2*n,ei);\n  }\n\n  void build(const vector<T> &v){\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n\n  inline T reflect(int k){\n    return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n  }\n\n  inline void propagate(int k){\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n    dat[k]=reflect(k);\n    laz[k]=ei;\n  }\n\n  inline void thrust(int k){\n    for(int i=height;i;i--) propagate(k>>i);\n  }\n\n  inline void recalc(int k){\n    while(k>>=1)\n      dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n  }\n\n  void update(int a,int b,E x){\n    if(a>=b) return;\n    thrust(a+=n);\n    thrust(b+=n-1);\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  void set_val(int a,T x){\n    thrust(a+=n);\n    dat[a]=x;laz[a]=ei;\n    recalc(a);\n  }\n\n  T query(int a,int b){\n    if(a>=b) return ti;\n    thrust(a+=n);\n    thrust(b+=n-1);\n    T vl=ti,vr=ti;\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,reflect(l++));\n      if(r&1) vr=f(reflect(--r),vr);\n    }\n    return f(vl,vr);\n  }\n\n  template<typename C>\n  int find(int st,C &check,T &acc,int k,int l,int r){\n    if(l+1==r){\n      acc=f(acc,reflect(k));\n      return check(acc)?k-n:-1;\n    }\n    propagate(k);\n    int m=(l+r)>>1;\n    if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n    if(st<=l&&!check(f(acc,dat[k]))){\n      acc=f(acc,dat[k]);\n      return -1;\n    }\n    int vl=find(st,check,acc,(k<<1)|0,l,m);\n    if(~vl) return vl;\n    return find(st,check,acc,(k<<1)|1,m,r);\n  }\n\n  template<typename C>\n  int find(int st,C &check){\n    T acc=ti;\n    return find(st,check,acc,1,0,n);\n  }\n};\n\nsigned main(){\n\tint N,Q;\n\tcin >> N >> Q;\n\tauto f = [](int a,int b){return a + b;};\n\tauto g = [](int a,int b){return b;};\n\tauto h = [](int a,int b){return b;};\n\tSegmentTree<int,int>seg(f,g,h,0ll,(1ll << 31) - 1);\n\tseg.build(vector<int>(N,(1ll << 31) - 1));\n\twhile(Q--){\n\t\tint q;\n\t\tcin >> q;\n\t\tif(q){\n\t\t\tint idx;\n\t\t\tcin >> idx;\n\t\t\tcout << seg.query(idx,idx + 1) << endl;\n\t\t}else{\n\t\t\tint s,t,x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.update(s,t + 1,x);\n\t\t}\n\t\t/*REP(i,N){\n\t\t\tif(i)cout << \" \";\n\t\t\tcout << seg.query(i,i + 1);\n\t\t}\n\t\tcout << endl;*/\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        if(Tree[level].size() == 1)\n            return;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][iter]);\n            iter++;\n        }\n        \n        PrintTree();\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        \n        if(n == UNDEF){\n            if(level == Tree.size() - 1){\n                DownValue(level, key);\n                return UNDEF;\n            }\n            else if(Tree[level][key].value == UNDEF)\n                return UNDEF;\n            else{\n                \n                UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n                DownValue(level, key);\n                return UNDEF;\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        \n        if(level < Tree.size() - 1){\n            UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n            DownValue(level, key, before);\n        }\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    void DownValue(int level, int key){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        Tree[level - 1][2 * key].value = tmp;\n        if(2 * key + 1 < Tree[level - 1].size())\n            Tree[level - 1][2 * key + 1].value = tmp;\n        \n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        \n        if((Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF) || level == 0)\n            return Tree[level][0].value;\n        \n        if(target <= Tree[level - 1][0].high)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= Tree[level - 1][2 * key].high || 2 * key + 1 > Tree[level - 1].size() - 1)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \n    void PrintTree(){\n        static ofstream fout(\"tree.txt\");\n        for(int i = (int)Tree.size() - 1; i >= 0; i--){\n            for(vector<Node>::size_type j = 0; j < Tree[i].size(); j++){\n                fout << \"(\";\n                if(Tree[i][j].value == MAX_VALUE)\n                    fout << \"∞\";\n                else\n                    fout << Tree[i][j].value;\n                fout << \", [\" << Tree[i][j].low << \", \" << Tree[i][j].high << \"])\";\n            }\n            fout << endl;\n        }\n        fout << endl;\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\ntemplate<typename T>\nclass Deque{\npublic:\n  T *val;\n  int sz;\n  int length;\n  int head, tail;\n  \n  Deque(){sz = 0, length = 0, val = new T[0];}\n  Deque(int size, T init = T()){\n    length = 1;\n    while(length < size) length *= 2;\n    val = new T[length];\n    sz = size;\n    head = 0;\n    tail = 0;\n    for(int i=0;i<size;i++) val[tail++] = init;\n  }\n  \n  Deque(const Deque &t){\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n  }\n\n  ~Deque(){\n    delete [] val;\n  }\n  \n  T& operator [] (int i){assert(0 <= i && i < sz);return val[(head + i)%length];}\n  T& operator [] (int i)const{assert(0 <= i && i < sz);return val[(head + i)%length];}\n  int size()const{return sz;}\n  int empty()const{return sz == 0;}\n  void resize(int n, T v=T()){\n    while(n < size()) pop_back();\n    while(n > size()) push_back(v);\n  }\n  \n  void increaseMemory(){\n    int length_ = length;\n    \n    length = length * 2;\n    if(length == 0) length = 1;\n    T *val2 = new T[length];\n    for(int i=0;i<sz;i++) val2[i] = val[(head + i)%length_];\n    head = 0;\n    tail = sz;\n    delete [] val;\n    val = val2;\n  };\n  \n  void push_back(T v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n  \n  void push_front(int v){\n    if(sz == length) increaseMemory();\n    sz++;\n    head--;\n    if(head == -1) head = length - 1;\n    val[head] = v;\n  }\n\n  void pop_back(){\n    assert(sz > 0);\n    sz--;\n    tail--;\n    if(tail == -1) tail = length - 1;\n  }\n  \n  void pop_front(){\n    assert(sz > 0);\n    sz--;\n    head++;\n    if(head == length) head = 0;\n  }\n};\ntemplate <typename T>\nusing vector = Deque<T>;\n\n\ntemplate<class T>T max(T a, T b){return a >= b? a:b;}\ntemplate<class T>T min(T a, T b){return a <= b? a:b;}\n\ntemplate<typename dtype, dtype initValue/*範囲外のときに返す値*/>\nclass RUQ{\npublic:\n  int n,n_;\n  vector<dtype> dat;\n  vector<int> his;\n  int time;\n\n  //初期化\n  RUQ(){n=-1,time = 0;}\n  RUQ(int n_):n_(n_){\n    time = 0;\n    n=1;\n    while(n<n_)n*=2;\n    dat.resize(2*n-1,initValue);\n    his.resize(2*n-1,-1);\n  }\n\n  //k番目の値をaに変更\n  dtype get(int k){\n    k+=n-1;\n    int i = k;\n    while(k>0){\n      k=(k-1)/2;\n      if(his[i] < his[k]) i = k;\n    }\n    return dat[i];\n  }\n  \n  void dfs(int a,int b, dtype x, int k,int l,int r){\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n      dat[k] = x;\n      his[k] = time;\n      return;\n    }\n    dfs(a,b,x,k*2+1,l,(l+r)/2);\n    dfs(a,b,x,k*2+2,(l+r)/2,r);\n  }\n  \n  //[a,b)の最小値を求める\n  void update(int a,int b, dtype x){\n    assert(a <= b), assert(a <= n_ && b <= n_), assert(a >= 0 && a >= 0);\n    dfs(a,b,x,0,0,n);\n    time++;\n  }\n};\n\n\nsigned main(){\n\n  int n,q;\n  std::cin>>n>>q;\n  typedef long long ll;\n  RUQ <ll, (1LL<<31)-1> A(n);\n  \n  while(q--){\n    int com;\n    std::cin>>com;\n    if(com == 0) {\n      int s,t,x;\n      std::cin>>s>>t>>x;\n      A.update(s, t+1, x);\n    }\n    if(com == 1) {\n      int k;\n      std::cin>>k;\n      std::cout<<A.get(k)<<std::endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\n#include <functional>\ntemplate<typename T>\nclass SegmentTreeAllOne {\n    using Func = function<T(T, T)>;\n\npublic:\n    vector<T> data;\n    int n;\n    T init;\n    Func update_func;\n    SegmentTreeAllOne(int _n, T _init, Func up) {\n        init = _init;\n        update_func = up;\n        for (n = 1; n < _n; n *= 2)\n            ;\n        data.resize(2 * n - 1, init);\n    }\n    void update(int l, int r, T val) {\n        for (l += n - 1, r += n - 1; l < r; l = l / 2, r = (r - 1) / 2) {\n            if (!(l & 1)) {\n                data[l] = update_func(data[l], val);\n            }\n            if (!(r & 1)) {\n                data[r - 1] = update_func(data[r - 1], val);\n            }\n        }\n    }\n    T query(int pos) {\n        pos += n - 1;\n        T res = data[pos];\n        while (pos > 0) {\n            pos = (pos - 1) / 2;\n            res = update_func(res, data[pos]);\n        }\n        return res;\n    }\n};\n\n#include <utility>\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    using P = pair<int, ll>;\n    auto MAX = [](P a, P b) { return max(a, b); };\n    int n, q;\n    cin >> n >> q;\n    SegmentTreeAllOne<P> segtree(n, P(-1, (1LL << 31) - 1), MAX);\n    REP(i, 0, q) {\n        int com;\n        cin >> com;\n        if (com) {\n            int x;\n            cin >> x;\n            cout << segtree.query(x).second << endl;\n\n        } else {\n            int s, t, x;\n            cin >> s >> t >> x;\n            segtree.update(s, t + 1, P(i, x));\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\n// LazyUpdateSegmentTree\ntemplate<typename T>\nclass LazyUpdateSegTree{\npublic:\n    int n;\n    T defaultValue;\n    vector<T> dat;\n    vector<T> lazy;\n    vector<bool> isSetLazy;\n\n    LazyUpdateSegTree(vector<T>& v, T defaultValue){\n        n = 1;\n        int vSize = (int)v.size();\n        while(n < vSize){\n            n *= 2;\n        }\n        dat.assign(2 * n - 1, defaultValue);\n        lazy.assign(2 * n - 1, 0);\n        isSetLazy.assign(2 * n - 1, false);\n        this->defaultValue = defaultValue;\n\n        for(int i = 0; i < vSize; i++){\n            dat[i + n - 1] = v[i];\n        }\n        for(int i = n - 2; i >= 0; i--){\n            dat[i] = ope(dat[2 * i + 1], dat[2 * i + 2]);\n        }\n    }\n\n    T update(int a, int b, T value, int k = 0, int l = 0, int r = -1){\n        if(r < 0){\n            r = n;\n        }\n        propagate(k);\n\n        if(r <= a || b <= l){\n            return dat[k];\n        }\n\n        if(a <= l && r <= b){\n            lazy[k] = lazyUpdate(value, l, r);\n            isSetLazy[k] = true;\n            propagate(k);\n            return dat[k];\n        }\n        else{\n            T vl = update(a, b, value, 2 * k + 1, l, (l + r) / 2);\n            T vr = update(a, b, value, 2 * k + 2, (l + r) / 2, r);\n            dat[k] = ope(vl, vr);\n            return dat[k];\n        }\n    }\n\n    T query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0){\n            r = n;\n        }\n\n        if(r <= a || b <= l){\n            return defaultValue;\n        }\n        propagate(k);\n\n        if(a <= l && r <= b){\n            return dat[k];\n        }\n        else{\n            T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return ope(vl, vr);\n        }\n    }\n\nprivate:\n\n    void propagate(int k){\n        if(isSetLazy[k]){\n            dat[k] = lazy[k];\n            if(k <= n - 2){\n                T value = lazyPropUpdate(lazy[k]);\n                lazy[2 * k + 1] = value;\n                lazy[2 * k + 2] = value;\n                isSetLazy[2 * k + 1] = true;\n                isSetLazy[2 * k + 2] = true;\n            }\n\n            isSetLazy[k] = false;\n        }\n    }\n\n    T ope(T a, T b){\n        return a + b;\n    }\n\n    T lazyUpdate(T value, int l, int r){\n        return (r - l) * value;\n    }\n\n    T lazyPropUpdate(T value){\n        return value / 2;\n    }\n};\n\nint main(){\n\n    int n, q;\n    cin >> n >> q;\n    vector<long long> v(n, (1LL << 31) - 1);\n    LazyUpdateSegTree<long long> segTree(v, 0);\n    for(int i = 0; i < q; i++){\n        int type;\n        cin >> type;\n        if(type == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            segTree.update(s, t + 1, x);\n        }\n        else{\n            int j;\n            cin >> j;\n            cout << segTree.query(j, j + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <typename T> struct Segtree {\n    inline T merge(T a, T b) { return a.first > b.first ? a : b; }\n    inline void act(T &a, T b) { a = b; }\n    vector<T> dat;\n    int n;\n    T e;\n    Segtree(int n_, T e) : e(e) {\n        n = 1;\n        while (n < n_) {\n            n <<= 1;\n        }\n        dat.resize(2 * n, e);\n    }\n    void set(const int &a, const int &b, const T &x, int k, int l, int r) {\n        if (b <= l || r <= a) {\n            return;\n        }\n        if (a <= l && r <= b) {\n            act(dat[k], x);\n            return;\n        }\n        set(a, b, x, k << 1, l, (l + r) >> 1);\n        set(a, b, x, k << 1 | 1, (l + r) >> 1, r);\n    }\n    inline void set(const int &a, const int &b, const T &x) {\n        if (a >= b) {\n            return;\n        }\n        set(a, b, x, 1, 0, n);\n    }\n    T get(int k) {\n        k += n;\n        T res = dat[k];\n        k >>= 1;\n        while (k > 0) {\n            res = merge(res, dat[k]);\n            k >>= 1;\n        }\n        return res;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    Segtree<P> seg(n, P(-1, (1LL << 31) - 1LL));\n    for (int k = 0; k < q; k++) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int l, r, x;\n            cin >> l >> r >> x;\n            ++r;\n            seg.set(l, r, P(k, x));\n        } else {\n            int i;\n            cin >> i;\n            cout << seg.get(i).second << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint find(int x,int n,vector<int>& node) {\n\tx += n - 1;\n\tint ret = node[x];\n\twhile (x > 0) {\n\t\tx = (x - 1) / 2;\n\t\tret = max(ret, node[x]);\n\t}\n\treturn ret;\n}\n\nvoid update(int a, int b,int i, int k, int l, int r, vector<int>& node) {\n\tif (r <= a || b <= l)return;\n\tif (a <= l && r <= b) {\n\t\tnode[k] = i; return;\n\t}\n\telse {\n\t\tupdate(a, b, i, 2 * k + 1, l, (l + r) / 2, node);\n\t\tupdate(a, b, i, 2 * k + 2, (l + r) / 2, r, node);\n\t}\n}\n\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_, q;  cin >> n_ >> q;\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<int> node(2 * n - 1, 0);\n\tvector<int> ans(q + 1, INT_MAX);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) { \n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tans[i + 1] = x;\n\t\t\tupdate(s, t + 1, i + 1, 0, 0, n, node);\n\t\t}\n\t\telse{\n\t\t\tint x; cin >> x;\n\t\t\tcout << ans[find(x,n,node)] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int DEPTH = 17;\nconst int INTMAX = (1LL << 31) - 1;\n\nstruct RUQ {\n\tint d[1 << (DEPTH + 1)];\n\tint t[1 << (DEPTH + 1)];\n\t\n\tRUQ() {\n\t\tint i;\n\t\tfor (i = 0; i < (1 << (DEPTH + 1)); i++) {\n\t\t\td[i] = INTMAX;\n\t\t\tt[i] = -1;\n\t\t}\n\t}\n\t\n\t//[l, r)\n\tvoid update(int l, int r, int x, int Time, int a = 0, int b = (1 << DEPTH), int id = 0) {\n\t\tif (a >= r || b <= l) return;\n\t\tif (l <= a && b <= r) {\n\t\t\td[id] = x;\n\t\t\tt[id] = Time;\n\t\t\treturn;\n\t\t}\n\t\tupdate(l, r, x, Time, a, (a + b) / 2, id * 2 + 1);\n\t\tupdate(l, r, x, Time, (a + b) / 2, b, id * 2 + 2);\n\t}\n\t\n\tint getValue(int pos) {\n\t\tpos += (1 << DEPTH) - 1;\n\t\tint retD = d[pos];\n\t\tint retT = t[pos];\n\t\t\n\t\twhile (pos > 0) {\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tif (retT < t[pos]) {\n\t\t\t\tretT = t[pos];\n\t\t\t\tretD = d[pos];\n\t\t\t}\n\t\t}\n\t\treturn retD;\n\t}\n};\n\nRUQ ruq;\n\nint main() {\n\tint n, q;\n\t\n\tcin >> n >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint type;\n\t\tcin >> type;\n\t\tif (type == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x, i);\n\t\t}\n\t\telse {\n\t\t\tint pos;\n\t\t\tcin >> pos;\n\t\t\tcout << ruq.getValue(pos) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\n#ifndef SEGMENT_TREE\n#define SEGMENT_TREE\n\ntemplate<typename Data,typename Mono>\nclass SegTree{\nprivate:\n  typedef function<void(Data&,Data&)> MergeData;\n  typedef function<void(Mono&,Mono&)> MergeMono;\n  typedef function<void(Data&,Mono&)> Culc;\n  typedef function<bool(Data&,Mono&,int&,int&)> UpdateQuery; //data,mono,left,right true::Data,Monoに作用する false::子に降りる\n\n\n  int size,high;\n  vector<int> left,right;\n  vector<Data> dv;\n  vector<Mono> mv;\n  \n  Data de;\n  Mono me;\n  MergeData df;\n  MergeMono mf;\n  Culc cf;\n  \n\n  inline bool nx(int &idx){\n    while(idx&1){idx>>=1; if(idx){reculc(idx);}}\n    return idx?idx|=1:idx;\n  }\n\n  inline void reculc(int idx){\n    dv[idx]=dv[idx<<1];\n    df(dv[idx],dv[(idx<<1)|1]);\n    cf(dv[idx],mv[idx]);\n  }\n\n  inline void down(int idx){\n    cf(dv[idx<<1],mv[idx]);\n    mf(mv[idx<<1],mv[idx]);\n    cf(dv[(idx<<1)|1],mv[idx]);\n    mf(mv[(idx<<1)|1],mv[idx]);\n    mv[idx]=me;\n  }\n\npublic:\n  SegTree(Data de,Mono me,MergeData df,MergeMono mf,Culc cf,int n=0):de(de),me(me),df(df),mf(mf),cf(cf){init(n);}\n\n  void init(int n){\n    size=1;\n    high=0;\n    while(size<n){size<<=1; high++;}\n    dv.assign(size<<1,de);\n    mv.assign(size<<1,me);\n    left.resize(size<<1);\n    right.resize(size<<1);\n    for(int i=0;i<size;i++){left[size|i]=i; right[size|i]=i+1;}\n    for(int i=size-1;i>0;i--){left[i]=left[i<<1]; right[i]=right[(i<<1)|1];}\n  }\n\n  void build(const vector<Data> &ary){\n    int n=ary.size();\n    init(n);\n    for(int i=0;i<n;i++){dv[size|i]=ary[i];}\n    for(int i=size-1;i>0;i--){dv[i]=dv[i<<1]; df(dv[i],dv[(i<<1)|1]);}\n  }\n\n  //[lf,rg)\n  Data query(int lf,int rg){\n    Data ret=de;\n    int idx=1;\n    bool j=true;\n    while(j){\n      if(right[idx]<=lf || rg<=left[idx]){j&=nx(idx);}\n      else if(lf<=left[idx] && right[idx]<=rg){df(ret,dv[idx]); j&=nx(idx);}\n      else{down(idx); idx<<=1;}\n    }\n    return ret;\n  }\n\n  void update(int lf,int rg,Mono m){\n    int idx=1;\n    bool j=true;\n    while(j){\n      if(right[idx]<=lf || rg<=left[idx]){j&=nx(idx);}\n      else if(lf<=left[idx] && right[idx]<=rg){\n        cf(dv[idx],m); mf(mv[idx],m); j&=nx(idx);\n      }\n      else{down(idx); idx<<=1;}\n    }\n  }\n\n  void update(int lf,int rg,UpdateQuery br){\n    int idx=1;\n    bool j=true;\n    while(j){\n      if(right[idx]<=lf || rg<=left[idx]){j&=nx(idx);}\n      else if(lf<=left[idx] && right[idx]<=rg){\n        if(br(dv[idx],mv[idx],left[idx],right[idx])){j&=nx(idx);}\n        else{down(idx); idx<<=1;}\n      }\n      else{down(idx); idx<<=1;}\n    }\n  }\n\n  void DEBUG(){cout<<dv<<endl;}\n};\n\n#endif /*SEGMENT_TREE*/\n\n\nvoid DSL_2_A(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](ll &a,pll &b)->void{if(b.F!=0){a=b.S;}};\n  ll de=1e18;\n  pll me={0,0};\n  SegTree<ll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,(1LL<<31)-1));\n  for(int i=0;i<q;i++){\n    int c,x,y;\n    cin>>c>>x>>y;\n    if(c){\n      cout<<Tr.query(x,y+1)<<endl;\n    }\n    else{\n      Tr.update(x,x+1,{1,y});\n    }\n  }\n}\n\nvoid DSL_2_B(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a+=b;};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](ll &a,ll &b)->void{a+=b;};\n  ll de=0;\n  ll me=0;\n  SegTree<ll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,0));\n  for(int i=0;i<q;i++){\n    int c,x,y;\n    cin>>c>>x>>y;\n    if(c){\n      x--;\n      cout<<Tr.query(x,y)<<endl;\n    }\n    else{\n      x--;\n      Tr.update(x,x+1,y);\n    }\n  }\n}\n\nvoid DSL_2_D(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](ll &a,pll &b)->void{if(b.F!=0){a=b.S;}};\n  ll de=1e18;\n  pll me={0,0};\n  SegTree<ll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,(1LL<<31)-1));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c;\n    if(c){\n      cin>>x;\n      cout<<Tr.query(x,x+1)<<endl;\n    }\n    else{\n      cin>>x>>y>>z;\n      Tr.update(x,y+1,{1,z});\n    }\n  }\n}\n\nvoid DSL_2_E(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](pll &a,pll &b)->void{a.F+=b.F; a.S+=b.S;};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](pll &a,ll &b)->void{a.F+=b*a.S;};\n  pll de={0,0};\n  ll me=0;\n  SegTree<pll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<pll>(n,{0,1}));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    x--;\n    if(c){\n      cout<<Tr.query(x,x+1).F<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y,z);\n    }\n  }\n}\n\nvoid DSL_2_F(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](ll &a,pll &b)->void{if(b.F!=0){a=b.S;}};\n  ll de=1e18;\n  pll me={0,0};\n  SegTree<ll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,(1LL<<31)-1));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c;\n    if(c){\n      cin>>x>>y;\n      cout<<Tr.query(x,y+1)<<endl;\n    }\n    else{\n      cin>>x>>y>>z;\n      Tr.update(x,y+1,{1,z});\n    }\n  }\n}\n\nvoid DSL_2_G(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](pll &a,pll &b)->void{a.F+=b.F; a.S+=b.S;};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](pll &a,ll &b)->void{a.F+=b*a.S;};\n  pll de={0,0};\n  ll me=0;\n  SegTree<pll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<pll>(n,{0,1}));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    x--;\n    if(c){\n      cin>>y;\n      cout<<Tr.query(x,y).F<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y,z);\n    }\n  }\n}\n\nvoid DSL_2_H(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](ll &a,ll &b)->void{a+=b;};\n  ll de=1e18;\n  ll me=0;\n  SegTree<ll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,0));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    if(c){\n      cin>>y;\n      cout<<Tr.query(x,y+1)<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y+1,z);\n    }\n  }\n}\n\nvoid DSL_2_I(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](pll &a,pll &b)->void{a.F+=b.F; a.S+=b.S;};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](pll &a,pll &b)->void{if(b.F){a.F=b.S*a.S;}};\n  pll de={0,0};\n  pll me={0,0};\n  SegTree<pll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<pll>(n,{0,1}));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    if(c){\n      cin>>y;\n      cout<<Tr.query(x,y+1).F<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y+1,{1,z});\n    }\n  }\n}\n\nint main(){\n  DSL_2_D();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/2/2017\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nvoid find(int i);\nvoid update(int s,int t, int x);\n#define MaxN 100005\nint a[MaxN];\nint main(){\n\tint n = 0, q = 0;\n\tint array[10];\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tfor(int i = 0; i<n; i++){\n\t\ta[i] = pow(2,31) - 1;\t\n\t}\n\tfor(int i = 0; i < q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tscanf(\"%d %d %d\",&array[0],&array[1],&array[2]);\n\t\t\tupdate(array[0],array[1],array[2]);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tscanf(\"%d\",&array[0]);\n\t\t\tfind(array[0]);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nvoid update(int s,int t, int x){\n\tfor(int i = s; i<=t; i++){\n\t\ta[i] = x;\n\t}\n}\n\nvoid find(int i) {\n\tprintf(\"%d\\n\",a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\ntemplate<class Monoid, class Lazy>\nclass LazySegmentTree {\n\npublic:\n\n    /**\n     * @param N size\n     * @param initial_val initial value in `data`\n     * @param def identity element\n     * @param def_lazy identity element for `lazy`\n     * @param operation operation to merge `data`\n     * @param lazy_operation operation to update `data` using `lazy`\n     * @param lazy_updater operation to update `lazy`\n     * @param lazy_calc operation to calculate `lazy` value from length\n     */\n    LazySegmentTree(int N, Monoid initial_val, Monoid def, Lazy def_lazy,\n                    function<Monoid(Monoid, Monoid)> operation,\n                    function<Monoid(Monoid, Lazy)> lazy_operation,\n                    function<Lazy(Lazy, Lazy)> lazy_updater,\n                    function<Lazy(Lazy, ll)> lazy_calc)\n            : initial_val(initial_val), def(def), def_lazy(def_lazy), operation(operation),\n              lazy_operation(std::move(lazy_operation)), lazy_updater(std::move(lazy_updater)),\n              lazy_calc(std::move(lazy_calc)) {\n        n = 1;\n        while (n < N) {\n            n *= 2;\n        }\n        data = vector<Monoid>(2 * n - 1, initial_val);\n        lazy = vector<Monoid>(2 * n - 1, def_lazy);\n\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = operation(data[2 * i + 1], data[2 * i + 2]);\n        }\n    }\n\n    /**\n     * 区間更新 [a, b)\n     * O(logN)\n     */\n    void update(int a, int b, Lazy x) {\n        update(a, b, x, 0, 0, n);\n    }\n\n    /**\n     * 区間取得 [a, b)\n     * O(logN)\n     */\n    Monoid query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    /**\n     * 添字でアクセス( 0-indexed )\n     */\n    Monoid operator[](int i) {\n        return data[i + n - 1];\n    }\n\nprivate:\n    int n;\n    vector<Monoid> data;\n    vector<Lazy> lazy;\n    Monoid initial_val;\n    Monoid def;\n    Lazy def_lazy;\n\n    // To merge data\n    function<Monoid(Monoid, Monoid)> operation;\n\n    // To update data using lazy\n    function<Monoid(Monoid, Lazy)> lazy_operation;\n\n    // To update lazy\n    function<Lazy(Lazy, Lazy)> lazy_updater;\n\n    // To calculate lazy value using length\n    function<Lazy(Lazy, ll)> lazy_calc;\n\n    void eval(int l, int r, int k) {\n        // 遅延伝播用の配列の値が初期値と同じかどうかを比較\n        if (lazy[k] == def_lazy) return;\n\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lazy_updater(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = lazy_updater(lazy[2 * k + 2], lazy[k]);\n        }\n\n        // k 番目ノードの値に対して遅延評価を行う\n        data[k] = lazy_operation(data[k], lazy_calc(lazy[k], r - l));\n\n        // 遅延伝播用の配列の値を初期値に戻す\n        lazy[k] = def_lazy;\n    }\n\n    Monoid update(int a, int b, Monoid x, int k, int l, int r) {\n        eval(l, r, k);\n        if (r <= a || b <= l) return data[k];\n        if (a <= l && r <= b) {\n            lazy[k] = lazy_updater(lazy[k], x);\n            return lazy_operation(data[k], lazy_calc(lazy[k], r - l));\n        }\n\n        return data[k] = operation(update(a, b, x, 2 * k + 1, l, (l + r) / 2),\n                                   update(a, b, x, 2 * k + 2, (l + r) / 2, r));\n    }\n\n    Monoid query(int a, int b, int k, int l, int r) {\n\n        // 交差しない\n        if (b <= l || r <= a) {\n            return def;\n        }\n        // 取得時に評価\n        eval(l, r, k);\n\n        // 区間 [a, b) に l, r が含まれる\n        if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 左の子\n        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        // 右の子\n        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return operation(vl, vr);\n    }\n};\n\nvoid Main() {\n    ll N, Q;\n    cin >> N >> Q;\n    LazySegmentTree<ll, ll> lazySegmentTree(N, (1L << 31) - 1, INF, -1, [](ll a, ll b) { return min(a, b); },\n                                            [](ll a, ll b) { return b; },\n                                            [](ll a, ll b) { return b; }, [](ll a, ll b) { return a; });\n    rep(q, Q) {\n        int query;\n        cin >> query;\n        if (query) {\n            ll i;\n            cin >> i;\n            ll ans = lazySegmentTree.query(i, i + 1);\n            cout << ans << '\\n';\n        } else {\n            ll s, t, x;\n            cin >> s >> t >> x;\n            lazySegmentTree.update(s, t + 1, x);\n        }\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nlong long seg[262149], n, v, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u, long long v) {\n\tif (s <= p || q <= r) { if (v != INF)seg[u] = v; return; }\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tlong long w = v; if (w == INF)w = seg[u]; seg[u] = INF;\n\tupdate(p, q, r, (r + s) / 2, t, u * 2, w);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1, w);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((r <= p && q <= s) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> v; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_ * 2; i++)seg[i] = INF;\n\tfor (int i = 1; i <= v; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1, INF); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <fstream>\n#include <random>\n#include <cmath>\n#include <iomanip>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <deque>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <unordered_map>\n#include <bitset>\n#include <sstream>\n#include <new>\n#include <typeinfo>\n#include <iterator>\n\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nconstexpr ll mop = 1000000007;\nconstexpr ll mop2 = 998244353;\n\nusing namespace std;\n\nconstexpr ll DEF_VAL = (1LL << 31) - 1;\nconstexpr ll SEG_LEN = (1LL << 18);\npair<ll,ll> segTree[SEG_LEN * 2]; // segTree[i] = {times, val}\n\nvoid initialize() {\n\tfor (ll i = 0; i < SEG_LEN * 2; i++) {\n\t\tsegTree[i] = make_pair(0, DEF_VAL);\n\t}\n}\n\nvoid add(ll l, ll r, ll val, ll times) {\n\tl += SEG_LEN;\n\tr += SEG_LEN;\n\twhile (l < r) {\n\t\tif (l % 2 == 1) {\n\t\t\tsegTree[l++] = make_pair(times, val);\n\t\t}\n\t\tl /= 2;\n\t\tif (r % 2 == 1) {\n\t\t\tsegTree[--r] = make_pair(times, val);\n\t\t}\n\t\tr /= 2;\n\t}\n}\n\nll get(ll idx) {\n\tidx += SEG_LEN;\n\tpair<ll,ll> ans = make_pair(0, DEF_VAL);\n\twhile (idx > 0) {\n\t\tif (ans.first < segTree[idx].first) {\n\t\t\tans = segTree[idx];\n\t\t}\n\t\tidx /= 2;\n\t}\n\treturn ans.second;\n}\n\nint main() {\n\tll aLen, Q;\n\tcin >> aLen >> Q;\n\tll times = 0;\n\tfor (ll i = 0; i < Q; i++) {\n\t\tll com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tll l, r, val;\n\t\t\tcin >> l >> r >> val;\n\t\t\tadd(l, r+1, val, ++times);\n\t\t}\n\t\telse {\n\t\t\tll idx;\n\t\t\tcin >> idx;\n\t\t\tcout << get(idx) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define N (1<<18)\n\nll ai[N*2];\nll value[N*2];\nll max_num = 1;\n\nint find(int k){\n    k += N-1;\n    int ans = ai[k];\n    int v = value[k];\n    while(k > 0){\n        k = (k-1)/2;\n        if(value[k] > v){\n            ans = ai[k];\n            v = value[k];\n        }\n    }\n    return ans;\n}\n\nvoid update(int s, int t, int x, int i, int k = 0, int l = 0, int r = N){\n    if(r <= s || t <= l) return;\n    if(s <= l && r <= t){\n        value[k] = i;\n        ai[k] = x;\n    }else{\n        update(s, t, x, i, k*2+1, l, (l+r)/2);\n        update(s, t, x, i, k*2+2, (l+r)/2, r);\n    }\n}\n\nint main(){\n    for(int i = 0; i < 31; i++) max_num *= 2;\n    max_num -= 1;\n\n    for(int i = 0; i < N*2; i++){\n        ai[i] = max_num;\n        value[i] = -1;\n    }\n\n    int n, q;\n    cin >> n >> q;\n\n    for(int i = 0; i < q; i++){\n        int com, s, t, x;\n        cin >> com;\n        if(com == 1){\n            cin >> s;\n            cout << find(s) << endl;\n        }else{\n            cin >> s >> t >> x;\n            update(s, t+1, x, i);\n        }\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////\n// 双対セグメント木 //\n//////////////////////\n\n// 要件は以下\n// Transformation_tはElement_t上の変換全体の集合、(Monoid_t, operate_, identity_)はモノイド\n// 準同型写像homoMorphism:Monoid_t->Transformation_tによりMonid_tとTransformation_tは準同型\ntemplate <typename Element_t, typename Monoid_t>\nclass DualSegmentTree {\nprivate:\n\tusing Transformation_t = std::function<Element_t(Element_t)>;\n\tusing HomoMorphism_t = std::function<Transformation_t(Element_t)>;\n\tusing Operation_t = std::function<Monoid_t(Monoid_t, Monoid_t)>;\n\t\n\tconst Operation_t operate_;\n\tconst Monoid_t identity_;\n\tconst HomoMorphism_t homoMorphism_;\n\tstd::vector<Element_t> element_container_;\n\tstd::vector<Monoid_t> monoid_container_;\n\n\tvoid build(const unsigned int array_size)\n\t{\n\t\tunsigned int length{1};\n\t\twhile (length < array_size)\n\t\t\tlength <<= 1;\n\t\telement_container_.resize(length);\n\t\tmonoid_container_.resize(2 * length, identity_);\n\t}\n\n\t// 新しい演算ほど左にくるようにする(写像の合成と同じ順番)\n\tvoid updateHelper(const int query_l, const int query_r, const Monoid_t& added, const int node_i, const int node_l, const int node_r)\n\t{\n\t\tif (query_r <= node_l || node_r <= query_l) return;\n\n\t\tMonoid_t& monoid{monoid_container_[node_i]};\n\t\tif (query_l <= node_l && node_r <= query_r)\n\t\t{\n\t\t\tmonoid = operate_(added, monoid);\n\t\t\treturn;\n\t\t}\n\n\t\tmonoid_container_[2 * node_i] = operate_(monoid, monoid_container_[2 * node_i]);\n\t\tmonoid_container_[2 * node_i + 1] = operate_(monoid, monoid_container_[2 * node_i + 1]);\n\t\tmonoid = identity_;\n\t\n\t\tconst int node_m{(node_l + node_r) >> 1};\n\t\tupdateHelper(query_l, query_r, added, 2 * node_i, node_l, node_m);\n\t\tupdateHelper(query_l, query_r, added, 2 * node_i + 1, node_m, node_r);\n\t}\n\n\t// デバッグ用出力関数(中身は適宜編集)\n\tvoid debugOutput()\n\t{\n\t\tint line_break{2};\n\t\tfor (int i{1}; i < (int)monoid_container_.size(); i++)\n\t\t{\n\t\t\tstd::cout << monoid_container_[i] << ' ';\n\t\t\tif (i + 1 == line_break)\n\t\t\t{\n\t\t\t\tputchar('\\n');\n\t\t\t\tline_break *= 2;\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\t// initial_elementで要素配列を初期化\n\tDualSegmentTree(const unsigned int array_size, const Element_t initial_element,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n\t\t: operate_(operate), identity_(identity), homoMorphism_(homoMorphism)\n\t{\n\t\tbuild(array_size);\n\t\tstd::fill(element_container_.begin(), element_container_.end(), initial_element);\n\t}\n\t// initial_arraydで要素配列を初期化\n\tDualSegmentTree(const std::vector<Element_t> initial_array,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n\t{\n\t\tbuild(initial_array.size());\n\t\tstd::copy(initial_array.begin(), initial_array.end(), element_container_.begin());\n\t}\n\n\t// left,rightは0-indexed、半開区間[left,right)にhomoMorphism(operate)を施す\n\tvoid update(const int left, const int right, const Monoid_t added)\n\t{\n\t\tupdateHelper(left, right, added, 1, 0, element_container_.size());\n\t}\n\n\t// indexは0-indexed、indexの要素を返す\n\tElement_t get(const int index)\n\t{\n\t\tElement_t element{element_container_[index]};\n\t\tfor (int monoid_i{((int)monoid_container_.size() >> 1) + index}; monoid_i > 0; monoid_i >>= 1)\n\t\t{\n\t\t\tauto trans{homoMorphism_(monoid_container_[monoid_i])};\n\t\t\telement = trans(element);\n\t\t}\n\n\t\treturn element;\n\t}\n};\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tDualSegmentTree<int64_t, int64_t> dst(n, (1ll << 31) - 1,\n\t\t[](const int64_t left, const int64_t right)\n\t\t{\n\t\t\treturn left >= 0?left:right;\n\t\t},\n\t\t-1,\n\t\t[](const int64_t monoid)\n\t\t{\n\t\t\treturn [=](const int64_t argument)\n\t\t\t{\n\t\t\t\treturn monoid >= 0? monoid: argument;\n\t\t\t};\n\t\t}\n\t);\n\n\tfor (int q_i{}; q_i < q; q_i++)\n\t{\n\t\tint com;\n\t\tscanf(\"%d\", &com);\n\t\tif (com)\n\t\t{\n\t\t\tint i;\n\t\t\tscanf(\"%d\", &i);\n\t\t\tprintf(\"%lld\\n\", dst.get(i));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s, t, x;\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tt++;\n\t\t\tdst.update(s, t, x);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                A[i] = INT_MAX;\n                cout << A[i] << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        A[i] = x[j];\n                        cout << A[i] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            //for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\ntemplate<typename T>\nclass SegmentTree{\n\tT def_value;\n\tint last_num;\n\tvector<T> element,lazy;\n\tvector<bool> lazy_flag;\npublic:\n\tSegmentTree(vector<T>& vec,T def):def_value(def){\n\t\tint N=vec.size();\n\t\tlast_num=1;\n\t\twhile(last_num<N) last_num <<= 1;\n\t\telement.resize(2*last_num-1,def);\n\t\tlazy.resize(2*last_num-1,0);\n\t\tlazy_flag.resize(2*last_num-1,false);\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\telement[i+last_num-1] = vec[i];\n\t\t}\n\t\tfor(int i=last_num-2;i>=0;i--){\n\t\t\telement[i] = min(element[2*i+1],element[2*i+2]);\n\t\t}\n\t}\n\tvoid Evaluate(int index,int left,int right){\n\t\tif(!lazy_flag[index]) return;\n\t\telement[index] = lazy[index];\n\t\tif(right-left>1){\n\t\t\tlazy[2*index+1] = lazy[index];\n\t\t\tlazy[2*index+2] = lazy[index];\n\t\t\tlazy_flag[2*index+1] = lazy_flag[2*index+2] = true;\n\t\t}\n\t\tlazy[index] = 0;\n\t\tlazy_flag[index] = false;\n\t}\n\tvoid UpdateRange(int left,int right,T x,int index=0,int vleft=0,int vright=-1){\n\t\tif(vright<0) vright = last_num;\n\t\tEvaluate(index,vleft,vright);\n\n\t\tif(vright<=left || right<=vleft) return;\n\t\tif(left<=vleft && vright<=right){\n\t\t\tlazy[index] = x;\n\t\t\tlazy_flag[index] = true;\n\t\t\tEvaluate(index,vleft,vright);\n\t\t}\n\t\telse{\n\t\t\tUpdateRange(left,right,x,2*index+1,vleft,(vleft+vright)/2);\n\t\t\tUpdateRange(left,right,x,2*index+2,(vleft+vright)/2,vright);\n\t\t\telement[index] = min(element[2*index+1],element[2*index+2]);\n\t\t}\n\t}\n\tvoid Update(int index,T x){\n\t\tint i=last_num+index-1;\n\t\telement[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\telement[i] = element[2*i+1]+element[2*i+2];\n\t\t}\n\t}\n\t// left<right\n\tT Find(int left,int right,int index=0,int vleft=0,int vright=-1){\n\t\tif(vright<0) vright = last_num;\n\t\tif(vright<=left || right<=vleft) return def_value;\n\n\t\tEvaluate(index,vleft,vright);\n\t\tif(left<=vleft && vright<=right) return element[index];\n\n\t\tT res_left = Find(left,right,2*index+1,vleft,(vleft+vright)/2);\n\t\tT res_right = Find(left,right,2*index+2,(vleft+vright)/2,vright);\n\t\treturn min(res_left,res_right);\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tauto N=in(),Q=in();\n\tvector<ll> A(N,(1LL<<31)-1);\n\tSegmentTree<ll> tree(A,(1LL<<31)-1);\n\n\tREP(i,Q){\n\t\tint q=in();\n\t\tif(q==1){\n\t\t\tint x=in();\n\t\t\tout(tree.Find(x,x+1));\n\t\t}\n\t\telse{\n\t\t\tint s=in(),t=in(),x=in();\n\t\t\ttree.UpdateRange(s,t+1,x);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = -1 * (((1<<30)-1)*2+1) ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nclass Bucket{\n  public:\n  vector<ll> buc,v;\n  ll N,sqn,K;\n  Bucket(){};\n  Bucket(ll n){\n    N = n;\n    sqn = sqrt(N);\n    K = (n + sqn - 1) /sqn;\n    buc.assign(K,-inf);\n    v.assign(K * sqn,-inf);\n  }\n  ll find(int x){\n    lazyupdate(x/sqn);\n    return v[x];\n  }\n  void lazyupdate(int k){\n    if(k >= K) return ;\n    if(buc[k] != -inf){\n      for(int i = k * sqn; i < (k+1) * sqn;++i){\n        v[i] = buc[k];\n      }\n    }\n    buc[k] = -inf;\n  }\n  void update(int x,int y,int n){\n    for (int k = 0; k < K; ++k) {\n      int l = k * sqn, r = (k + 1) * sqn;\n      if (r <= x || y <= l)\n        continue;\n      if (x <= l && r <= y) {\n        buc[k] = n;\n      } else {\n        if(l <= x){\n          lazyupdate(k);\n        }\n        if(r > y){\n          lazyupdate(k+1);\n        }\n        for (int i = max(x, l); i < min(y, r); ++i) {\n          v[i] = n;\n        }\n      }\n    }\n  }\n  void Debug(){\n    for(int i = 0; i < N;++i){\n      cout << buc[i/sqn] << ' ';\n    }\n    cout << endl;\n    for(int i = 0; i < N;++i){\n      cout << v[i] << ' ';\n    }\n    cout << endl;\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n, q,s,t,x,a;\n  cin >> n >> q;\n  Bucket buc(n);\n  rep(i,q){\n    cin >> a;\n    if(a){\n      cin >> s;\n      cout << buc.find(s) << endl;\n    }\n    else{\n      cin >> s >> t >> x;\n      buc.update(s,t+1,x);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N=1<<18;\ntypedef pair<int,int> P;\nint n_;\nP dat[2*MAX_N-1];\n\nvoid init(int n) {\n  n_=1;\n  while (n>n_) {\n    n_*=2;\n  }\n  for (int i=0; i<2*n_-1; i++) {\n    dat[i].first=-1;\n    dat[i].second=INT_MAX;\n  }\n}\nint find(int i) {\n  i+=n_-1;\n  P p=dat[i];\n  while (i>0) {\n    i=(i-1)/2;\n    p=max(p,dat[i]);\n  }\n  return p.second;\n}\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n_) {\n  if (r<=a || b<=l) {\n    return;\n  }\n  if (a<=l && r<=b) {\n    dat[k]=p;\n  } else {\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  } \n}\nint main() {\n  int n, q;\n  cin >> n >> q;\n  init(n);\n  for (int k=0; k<q; k++) {\n    int f;\n    cin >> f;\n    if (!f) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      update(s,t+1,P(k,x));\n    } else {\n      int i;\n      cin >> i;\n      printf(\"%d\\n\",find(i));\n    }    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(vector<T>v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nmain()\n{\n\tint n,q;cin>>n>>q;\n\tlazysegtree<int>S(n,(1<<31)-1,[](int a,int b){return a;},[](int a,int b){return b;},[](int a,int b,unsigned int c){return b;});\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint c;cin>>c;\n\t\tif(c)\n\t\t{\n\t\t\tint s;cin>>s;\n\t\t\tS.eval(s+S.n-1,s,s+1);\n\t\t\tcout<<S.dat[s+S.n-1]<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s,t,x;cin>>s>>t>>x;\n\t\t\tS.update(s,t+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <cstdint>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\nusing ll =  long long;\nusing Pll = pair<ll, ll>;\nusing Pii = pair<int, int>;\n\nconstexpr ll MOD = 1000000007;\nconstexpr long double EPS = 1e-10;\nconstexpr int dyx[4][2] = {\n    { 0, 1}, {-1, 0}, {0,-1}, {1, 0}\n};\n\ntemplate<class T> class LazySegmentTree {\n    public:\n    size_t n;       // 葉の数\n    vector<T> data; // データ\n    vector<T> lazy; // 遅延評価用\n    T unit;         // 単位元\n    T def;          // 初期値\n    function<T(T, T)> update_func;      // 更新で使う処理\n    function<T(T, T)> find_func;        // クエリで使う処理\n    function<T(T, T)> lazy_prop_func;   // 遅延評価用の値を子ノードに伝播させる処理\n\n    LazySegmentTree(\n        size_t _n, T _unit, T _def,  \n        function<T(T, T)> _update_func, \n        function<T(T, T)> _find_func, \n        function<T(T, T)> _lazy_prop_func\n        ) : unit(_unit), def(_def), update_func(_update_func), find_func(_find_func), lazy_prop_func(_lazy_prop_func) {\n        // 2のべき乗にする\n        n = 1;\n        while(n < _n) n <<= 1;\n        data = vector<T>(2*n-1, _def);\n        lazy = vector<T>(2*n-1, _def);\n    }\n\n    void eval(size_t k, size_t kl, size_t kr) {\n        if(lazy[k] == def) return;\n        // if(data[k] != def) data[k] = unit;\n        data[k] = update_func(data[k], lazy[k]);\n        if(kr - kl > 1){\n            lazy[2*k+1] = lazy_prop_func(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lazy_prop_func(lazy[2*k+1], lazy[k]);\n        }\n        lazy[k] = def;\n    }\n\n    void _update(size_t s, size_t t, size_t k, size_t kl, size_t kr, T x){\n        eval(k, kl, kr);\n\n        if(t <= kl || kr <= s) return;\n        if(s <= kl && kr <= t) {\n            lazy[k] = lazy_prop_func(lazy[k], x);\n            eval(k, kl, kr);\n        } else {\n            size_t kc = (kl+kr)/2;\n            _update(s, t, 2*k+1, kl, kc, x);\n            _update(s, t, 2*k+2, kc, kr, x);\n            data[k] = find_func(data[2*k+1], data[2*k+2]);\n        }\n    }\n\n    void update(size_t s, size_t t, T x) {\n        return _update(s, t, 0, 0, n, x);\n    }\n\n    T _find(size_t s, size_t t, size_t k, size_t kl, size_t kr){\n        if(kr <= s || t <= kl) return unit;\n\n        eval(k, kl, kr);\n        if(s <= kl && kr <= t) return data[k];\n\n        size_t kc = (kl+kr)/2;\n        T vl = _find(s, t, 2*k+1, kl, kc);\n        T vr = _find(s, t, 2*k+2, kc, kr);\n        return find_func(vl, vr);\n    }\n    \n    T find(size_t s, size_t t) {\n        return _find(s, t, 0, 0, n);\n    }\n};\n\nint main() {\n    unsigned int n, q, com, s, t, x;\n    cin >> n >> q;\n    LazySegmentTree<ll> tree(\n        n, 0LL, (1LL << 31) - 1, \n        [](ll a, ll b) { return b; }, \n        [](ll a, ll b) { return a+b; }, \n        [](ll a, ll b) { return b; }\n    );\n\n    while(q--) {\n        cin >> com;\n        if(com) {\n            cin >> s;\n            cout << tree.find(s, s+1) << endl;\n        } else {\n            cin >> s >> t >> x;\n            tree.update(s, t+1, x);\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate<class T, class TUpdater>\nstruct RangeSegTreeT\n{\n\tint size;\n\tvector<T> tree;\n\tvector<pair<bool, T>> lazy;\n\tTUpdater updator;\n\tT initialValue;\n\n\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\t\n\tRangeSegTreeT(int count, TUpdater updator, T initialValue)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, lazy(size * 2)\n\t\t, updator(updator)\n\t\t, initialValue(initialValue)\n\t{\n\t\tlazy[1] = { true, initialValue };\n\t}\n\n\tvoid propagate(int l, int r, int i)\n\t{\n\t\tif (lazy[i].first)\n\t\t{\n\t\t\ttree[i] = invoke_update(tree[i], lazy[i].second, r - l);\n\t\t\tif (r - l > 1)\n\t\t\t{\n\t\t\t\tlazy[i * 2] = { true, invoke_update(lazy[i * 2].second, lazy[i].second) };\n\t\t\t\tlazy[i * 2 + 1] = { true, invoke_update(lazy[i * 2 + 1].second, lazy[i].second) };\n\t\t\t}\n\t\t\tlazy[i] = { false, 0 };\n\t\t}\n\t}\n\n\tvoid update_range(int begin, int end, T value) { update_range(begin, end, 1, 0, size, value); }\n\tT query(int begin, int end) { return query(begin, end, initialValue); }\n\tT query(int begin, int end, T initialValue) { return query(begin, end, 1, 0, size, initialValue); }\n\nprivate:\n\n\tT invoke_update(T a, T b, T c = 1) { return updator(a, b, c); }\n\n\n\tvoid update_range(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpropagate(l, r, i);\n\n\t\tif (r <= s || e <= l) { return; }\n\t\tif (s <= l && r <= e) { lazy[i] = { true, invoke_update(lazy[i].second, value) }; return; }\n\t\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { update_range(s, e, i * 2, l, m, value); }\n\t\tif (e > m) { update_range(s, e, i * 2 + 1, m, r, value); }\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpropagate(l, r, i);\n\t\tif (r <= s || e <= l) { return value; }\n\t\tif (s <= l && r <= e) { return tree[i]; }\n\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { value = invoke_update(value, query(s, e, i * 2, l, m, value)); }\n\t\tif (e > m) { value = invoke_update(value, query(s, e, i * 2 + 1, m, r, value)); }\n\t\treturn value;\n\t}\n};\n\ntemplate <class T, class TUpdator>\nRangeSegTreeT<T, TUpdator> RangeSegTree(int n, TUpdator updator, int initialValue)\n{\n\treturn RangeSegTreeT<T, TUpdator>(n, updator, initialValue);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTree<int>(n, CONV3(a, b, c, b), (1LL << 31) - 1);\n\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s, t + 1, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, i);\n\t\t\tint v = tree.query(i, i + 1, 0);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\n\n\nconst long long INF2 = (((ll)1<<31)-1);\n\nint main(int argc, char* argv[])\n{\n    int n,q;\n    scanf(\"%d%d\", &n, &q);\n    \n    vector<pair<int, pair<int, pair<int,int> > > > z(q);     // type, s, t, x;\n    int i;\n    int cnt=0;\n    for(i=0; i<q; i++) {\n        int type, s, t, x;\n        scanf(\"%d\", &type);\n        if(type==0) {\n            scanf(\"%d%d%d\", &s, &t, &x);\n            z[i]=make_pair(type, make_pair(s, make_pair(t,x)));\n        }\n        else {\n            scanf(\"%d\", &s);\n            z[i]=make_pair(type, make_pair(s, make_pair(0,0)));\n            cnt++;\n        }\n    }\n    int ansnum=cnt;\n\n    set<pair<int,int> > zz;    // val, ansid\n    vector<int> ans(ansnum, INF2);\n    cnt=ansnum-1;\n    for(i=q-1; i>=0; i--) {\n        if(z[i].first==0) {\n            int s=z[i].second.first;\n            int t=z[i].second.second.first;\n            int x=z[i].second.second.second;\n            auto it=zz.lower_bound(make_pair(s,-INF));\n            auto itend=zz.lower_bound(make_pair(t+1,-INF));\n            while(it!=itend) {\n                ans[it->second]=x;\n                auto itnext=it; itnext++;\n                zz.erase(*it);\n                it=itnext;\n            }\n        }\n        else {\n            zz.insert(make_pair(z[i].second.first, cnt));\n            cnt--;\n        }\n    }\n    for(i=0; i<ansnum; i++) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n    s_min = 100000;\n    t_max = 0;\n    m = 0;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){ cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){ cout << x[j] << endl; break; }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\n\n\ntemplate<class T, class OP, class PROP>\nclass Lazy_Segment_Tree {//0-indexed ??????\npublic:\n\tvector<T> data, lazy;\n\tvector<bool> isupd;\n\tint n;\n\tLazy_Segment_Tree(int a) :n(1) {\n\t\twhile (n < a) n *= 2;\n\t\tdata.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tisupd.resize(n * 2 - 1);\n\t}\n\n\tvoid prop(int num, int s) {\n\t\tif (isupd[num]) {\n\t\t\tdata[num] = PROP()(data[num], lazy[num], 1, s);\n\t\t\tif (num < n - 1) {\n\t\t\t\tlazy[num * 2 + 1] = PROP()(lazy[num * 2 + 1], lazy[num]);\n\t\t\t\tlazy[num * 2 + 2] = PROP()(lazy[num * 2 + 2], lazy[num]);\n\t\t\t\tisupd[num * 2 + 1] = 1;\n\t\t\t\tisupd[num * 2 + 2] = 1;\n\t\t\t}\n\t\t\tlazy[num] = T();\n\t\t\tisupd[num] = 0;\n\t\t}\n\t}\n\tvoid op(int a, int b, T v, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\tprop(num,r-l);\n\t\tif (a == l && b == r) {\n\t\t\tisupd[num] = 1;\n\t\t\tlazy[num] = PROP()(lazy[num], v);\n\t\t\tprop(num, r-l);\n\t\t}\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tif (nr > a) op(a, min(b, nr), v, num * 2 + 1, base * 2);\n\t\t\tif (nr < b) op(max(a, nr), b, v, num * 2 + 2, base * 2);\n\t\t\tprop(num * 2 + 1, (r - l) / 2), prop(num * 2 + 2, (r - l) / 2);\n\t\t\tdata[num] = OP()(data[num * 2 + 1], data[num * 2 + 2]);\n\t\t}\n\t}\n\n\tT query(int a, int b, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\t\n\t\tprop(num,r-l);\n\n\t\tif (a == l && b == r)\n\t\t\treturn data[num];\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tT ret = T();\n\t\t\tif (nr > a) ret = OP()(ret,query(a, min(b, nr), num * 2 + 1, base * 2));\n\t\t\tif (nr < b) ret = OP()(ret,query(max(a, nr), b, num * 2 + 2, base * 2));\n\t\t\treturn ret;\n\t\t}\n\t}\n};\n\n\ntemplate<class T>\nclass ADD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn a + b;\n\t}\n};\n\ntemplate<class T>\nclass UPD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn b;\n\t}\n};\n\ntemplate<class T>\nclass RMQ {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn min(a, b);\n\t}\n};\ntemplate<class T>\nclass SUM {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn a+b;\n\t}\n};\n\nstruct N {\npublic:\n\tll num;\n\tN(int num) : num(num) {}\n\tN():num(pow(2,31)-1) {}\n\tN operator + (const N obj) const{\n\t\treturn N(obj.num + num);\n\t}\n\tbool operator < (const N obj)const {\n\t\treturn obj.num > num;\n\t}\n};\nsigned main() {\n\tint n, q;\n\n\tscanf(\"%d %d\", &n, &q);\n\tLazy_Segment_Tree<N, SUM<N>, UPD<N>> seg(n);\n\tREP(i, q) {\n\t\tint t;\n\t\tscnaf(\"%d\", &t);\n\t\tif (!t) {\n\t\t\tint a, b, c;\n\t\t\tscnaf(\"%d %d %d\", &a, &b, &c);\n\t\t\tseg.op(a, b+1, c);\n\t\t}\n\t\telse {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tprintf(\"%d\\n\", seg.query(a,a+1));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<random>\nusing namespace std;\n\nusing Value = int;\nconst Value INI = INT_MAX;\nstruct Node {\n\tValue sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(0) {\n\t\tlazy = 0;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tdat[k].sum += dat[k].lazy * (b - a + 1);\n\t}\n\n\tValue connect(const Value l, const Value r) {\n\t\treturn l + r;\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy += dat[k].lazy;\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy += dat[k].lazy;\n\t\t}\n\t\tdat[k].lazy = 0;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy += v;\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\n\t// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn 0;\n\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tValue vl = get(l, r, 2 * k, a, m);\n\t\tValue vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\nnamespace perseg {\n\n\tstruct permanent_segtree {\n\t\tValue val;\n\t\tValue lazy;\n\t\tint l, r;\n\t\tvector<shared_ptr<permanent_segtree>>chs;\n\tpublic:\n\t\tpermanent_segtree(const int size_) :val(INI),lazy(INI), l(0), r(size_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const Value& val_, const int l_, const int r_) :val(val_), lazy(INI), l(l_), r(r_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const permanent_segtree&tree_) :val(tree_.val), lazy(tree_.lazy), l(tree_.l), r(tree_.r), chs(tree_.chs) {\n\n\t\t}\n\t\tvoid lazy_func() {\n\t\t\tif (lazy !=INI) {\n\t\t\t\tval = lazy;\n\t\t\t}\n\t\t}\n\t\tValue update_lazy(int lazy_from, int lazy_to) {\n\t\t\tif (lazy_to != INI) {\n\n\t\t\t\treturn lazy_to;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lazy_from;\n\t\t\t}\n\t\t}\n\t\tvoid lazy_evaluate_node() {\n\t\t\tlazy_func();\n\t\t\tif (l + 1 != r) {\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tgetch(i)->lazy = update_lazy(getch(i)->lazy, lazy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlazy = INI;\n\t\t}\n\t\tshared_ptr<permanent_segtree>getch(const int num_) {\n\t\t\tconst int amid = (l + r) / 2;\n\n\t\t\tif (chs[num_] == nullptr) {\n\t\t\t\tif (num_ == 0) {\n\t\t\t\t\tchs[0] = make_shared<permanent_segtree>(INI, l, amid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchs[1] = make_shared<permanent_segtree>(INI, amid, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chs[num_];\n\n\t\t}\n\t\tValue eval_value(const Value&value_l, const Value&value_r)const {\n\t\t\treturn min(value_l, value_r);\n\t\t}\n\t\t// min [a, b)\n\t\tValue  query(int a, int b, int k) {\n\t\t\tlazy_evaluate_node();\n\t\t\tif (r <= a or b <= l) return INI;\n\t\t\tif (a <= l and r <= b) return val;\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tconst Value al(getch(0)->query(a, b, k));\n\t\t\tconst Value ar(getch(1)->query(a, b, k));\n\t\t\treturn eval_value(al, ar);\n\t\t}\n\t};\n\n\tshared_ptr<permanent_segtree>immutable_update(const shared_ptr<permanent_segtree>&tree, const int l,const int r, const Value a) {\n\t\ttree->lazy_evaluate_node();\n\t\tif (tree->r <= l || r <= tree->l) {\n\t\t\treturn tree;\n\t\t}else if (l<= tree->l&&tree->r<=r) {\n\t\t\tshared_ptr<permanent_segtree>new_tree(make_shared<permanent_segtree>(INI, tree->l, tree->r));\n\t\t\tnew_tree->lazy = new_tree->update_lazy(new_tree->lazy, a);\n\t\t\tnew_tree->lazy_evaluate_node();\n\t\t\treturn new_tree;\n\t\t}\n\t\telse {\n\t\t\tshared_ptr<permanent_segtree>copy_tree = (make_shared<permanent_segtree>(*tree));\n\t\t\tassert(tree->l + 1 < tree->r);\n\t\t\tcopy_tree->chs[0] = immutable_update(tree->getch(0), l,r, a);\t\t\t\n\t\t\tcopy_tree->chs[1] = immutable_update(tree->getch(1),l,r, a);\t\n\t\t\tcopy_tree->val = copy_tree->eval_value(copy_tree->getch(0)->val, copy_tree->getch(1)->val);\n\n\t\t\treturn copy_tree;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tusing namespace perseg;\n\tvector < shared_ptr<permanent_segtree>>trees(1, nullptr);\n\ttrees[0] = make_shared<permanent_segtree>(1 << 17);\n\tint N, Q; cin >> N >> Q;\n\tint now = 0;\n\tvector<tuple<int, int>>qs;\n\tbool flag = false;\n\tfor (int i = 0; i < Q;++i){\n\t\t\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint t; cin >> t;\n\t\t\tqs.push_back(make_tuple(now, t));\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tif (flag) {\n\t\t\t\ttrees.push_back(immutable_update(trees[now], s,t+1,x));\n\t\t\t\tnow++;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttrees.back() = immutable_update(trees[now],s,t+1,x);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < qs.size(); ++i) {\n\t\tint anow,x;\n\t\ttie(anow, x) = qs[i];\n\t\tint ans = trees[anow]->query(x, x + 1, 100);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// RUQはある区間のすべての値を更新するクエリ\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint n;\nstruct RUQ{\n  static const int MAX_N = 1 << 18;\n  P dat[2*MAX_N-1];\n  RUQ(){}\n  RUQ(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=INT_MAX;\n  }\n  int query(int k){\n    k+=n-1;\n    P p=dat[k];\n    //cout<<k<<\"/\"<<dat[k].second<<endl;\n    while(k>0){\n      k=(k-1)/2;\n      //cout<<k<<\"/\"<<dat[k].second<<endl;\n      p=max(p,dat[k]);\n    }\n    return p.second;\n  }\n\n  void update(int a,int b,int k,P p,int l,int r){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b) {\n      //cout<<a<<\":\"<<b<<\":\"<<k<<\":\"<<l<<\":\"<<r<<endl;\n       dat[k]=p;\n    }else{\n      update(a,b,k*2+1,p,l,(l+r)/2);\n      update(a,b,k*2+2,p,(l+r)/2,r);\n    }\n  }\n};\nsigned main(){\n  int _n,q;\n  cin>>_n>>q;\n  RUQ ruq(_n+1);\n  for(int i=0;i<q;i++){\n    int f;\n    cin>>f;\n    if(!f){\n      int s,t,x;\n      cin>>s>>t>>x;\n      //cout<<i<<\":\"<<x<<endl;\n      ruq.update(s,t+1,0,P(i,x),0,n);\n    }else{\n      int u;\n      cin>>u;\n      cout<<ruq.query(u)<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class M>\nstruct LazySegmentTree{\n    using T = typename M::T;\n    using L = typename M::L;\n    int sz, height{};\n    vector<T> seg; vector<L> lazy;\n    explicit LazySegmentTree(int n) {\n        sz = 1;\n        while(sz < n) sz <<= 1, height++;\n        seg.assign(2*sz, M::e());\n        lazy.assign(2*sz, M::l());\n    }\n\n    void set(int k, const T &x){\n        seg[k + sz] = x;\n    }\n\n    void build(){\n        for (int i = sz-1; i > 0; --i) seg[i] = M::f(seg[2*i], seg[2*i+1]);\n    }\n\n    T reflect(int k){ return lazy[k] == M::l() ? seg[k] : M::g(seg[k], lazy[k]); }\n\n    void eval(int k){\n        if(lazy[k] == M::l()) return;\n        lazy[(k<<1)|0] = M::h(lazy[(k<<1)|0], lazy[k]);\n        lazy[(k<<1)|1] = M::h(lazy[(k<<1)|1], lazy[k]);\n        seg[k] = reflect(k);\n        lazy[k] = M::l();\n    }\n    void thrust(int k){ for (int i = height; i; --i) eval(k>>i); }\n    void recalc(int k) { while(k >>= 1) seg[k] = M::f(reflect((k<<1)|0), reflect((k<<1)|1));}\n    void update(int a, int b, const L &x){\n        thrust(a += sz); thrust(b += sz-1);\n        for (int l = a, r = b+1;l < r; l >>=1, r >>= 1) {\n            if(l&1) lazy[l] = M::h(lazy[l], x), l++;\n            if(r&1) --r, lazy[r] = M::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    T query(int a, int b){ // [l, r)\n        thrust(a += sz);\n        thrust(b += sz-1);\n        T ll = M::e(), rr = M::e();\n        for(int l = a, r = b+1; l < r; l >>=1, r>>=1) {\n            if (l & 1) ll = M::f(ll, reflect(l++));\n            if (r & 1) rr = M::f(reflect(--r), rr);\n        }\n        return M::f(ll, rr);\n    }\n\n    T operator[](const int &k) const { // 0-indexed\n        return seg[k + sz];\n    }\n};\n\nstruct Monoid{\n    using T = int;\n    using L = int;\n    static T f(T a, T b) { return min(a, b); }\n    static T g(T a, L b) {\n        if(b == e()) return a; else return b;\n    }\n    static L h(L a, L b) {\n        if(b == e()) return a; else return b;\n    }\n    static T e() { return INT32_MAX; }\n    static L l() { return INT32_MAX; }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree<Monoid> seg(n);\n    for (int i = 0; i < q; ++i) {\n        int c;\n        scanf(\"%d\", &c);\n        if(c == 0){\n            int s, t, x;\n            scanf(\"%d %d %d\", &s, &t, &x);\n            seg.update(s, t+1, x);\n        }else {\n            int x;\n            scanf(\"%d\", &x);\n            printf(\"%d\\n\", seg.query(x, x+1));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nconst int BUCKET = 400,SIZE = 300;\nint N,Q;\nbool updateFlag [BUCKET];\nll lazyUpdate [BUCKET];\nll A [100000];\nconst ll INF = (1ll << 31) - 1;\n\nvoid update(int l,int r,ll val)\n{\n\tFOR(i,0,BUCKET){\n\t\tint bucketL = i * SIZE,bucketR = (i + 1) * SIZE;\n\t\tif(r <= bucketL || bucketR <= l) continue;\n\t\tif(l <= bucketL && bucketR <= r){\n\t\t\tlazyUpdate [i] = val;\n\t\t\tupdateFlag [i] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(updateFlag [i]){\n\t\t\tFOR(j,bucketL,bucketR){\n\t\t\t\tA [j] = lazyUpdate [i];\n\t\t\t}\n\t\t\tupdateFlag [i] = false;\n\t\t}\n\t\tFOR(j,bucketL,bucketR){\n\t\t\tif(l <= j && j < r){\n\t\t\t\tA [j] = val;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll get(int idx)\n{\n\tif(updateFlag [idx / SIZE]){\n\t\tint bucketL = (idx / SIZE) * SIZE,bucketR = (idx / SIZE + 1) * SIZE;\n\t\tFOR(i,bucketL,bucketR){\n\t\t\tA [i] = lazyUpdate [idx / SIZE];\n\t\t}\n\t\tupdateFlag [idx / SIZE] = false;\n\t}\n\treturn A [idx];\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfill(A,A + N,INF);\n\tvector<ll> ans;\n\tFOR(i,0,Q){\n\t\tint com;\n\t\tscanf(\"%d\",&com);\n\t\tif(com == 0){\n\t\t\tint s,t,x;\n\t\t\tscanf(\"%d%d%d\",&s,&t,&x);\n\t\t\tupdate(s,t + 1,x);\n\t\t}\n\t\telse{\n\t\t\tint idx;\n\t\t\tscanf(\"%d\",&idx);\n\t\t\tans.push_back(get(idx));\n\t\t}\n\t}\n\n\tFOR(i,0,ans.size()){\n\t\tprintf(\"%lld\\n\",ans [i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n\tlong long Size;\n\tpair<long long, long long> Unit;\n\tvector<pair<long long, long long> > Node;\npublic:\n\tSegmentTree(long long N, pair<long long, long long> X) : Unit(X) {\n\t\tSize = 1;\n\t\twhile (Size < N) Size *= 2;\n\t\tNode.assign(Size * 2, Unit);\n\t}\n\tvoid update(long long L, long long R, long long T, long long X) {\n\t\tlong long NOWS = Size;\n\t\twhile (L < R) {\n\t\t\tif (L & 1) {\n\t\t\t\tNode[L + NOWS] = { T, X };\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (R & 1) {\n\t\t\t\tNode[R + NOWS - 1] = { T, X };\n\t\t\t\tR--;\n\t\t\t}\n\t\t\tL >>= 1, R >>= 1, NOWS >>= 1;\n\t\t}\n\t}\n\tlong long query(long long X) {\n\t\tlong long MAXT = Unit.first, ANS = Unit.second;\n\t\tlong long NOWS = Size;\n\t\twhile (NOWS > 0) {\n\t\t\tif (MAXT < Node[X + NOWS].first) {\n\t\t\t\tMAXT = Node[X + NOWS].first;\n\t\t\t\tANS = Node[X + NOWS].second;\n\t\t\t}\n\t\t\tif (X & 1) X--;\n\t\t\tX >>= 1, NOWS >>= 1;\n\t\t}\n\t\treturn ANS;\n\t}\n};\n\nint main() {\n\tlong long N, Q;\n\tcin >> N >> Q;\n\tSegmentTree Seg(N, { -1, (1LL << 31) - 1 });\n\tfor (int i = 0; i < Q; i++) {\n\t\tlong long COM;\n\t\tcin >> COM;\n\t\tif (COM == 0) {\n\t\t\tlong long S, T, X;\n\t\t\tcin >> S >> T >> X;\n\t\t\tSeg.update(S, T + 1, i, X);\n\t\t}\n\t\telse {\n\t\t\tlong long X;\n\t\t\tcin >> X;\n\t\t\tcout << Seg.query(X) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct LazySegmentTree {\n    int size;\n    vector<int> node, lazy;\n\n    LazySegmentTree(int n) {\n        size = 1;\n        while (size < n) size <<= 1;\n        node.resize(2 * size, (unsigned int) (1 << 31) - 1);\n        lazy.resize(2 * size, -1);\n    }\n\n    void eval(int k) {\n        if (lazy[k] == -1) return;\n        if (k >= size) {\n            node[k] = lazy[k];\n        } else {\n            lazy[2 * k] = lazy[2 * k + 1] = lazy[k];\n        }\n        lazy[k] = -1;\n    }\n\n    void update(int a, int b, int x, int k = 1, int l = 0, int r = -1) {\n        if (r == -1) r = size;\n        eval(k);\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            eval(k);\n        } else {\n            int m = (l + r) / 2;\n            update(a, b, x, 2 * k, l, m);\n            update(a, b, x, 2 * k + 1, m, r);\n        }\n    }\n\n    int query(int i, int k = 1, int l = 0, int r = -1) {\n        if (r == -1) r = size;\n\n        eval(k);\n        int m = (l + r) / 2;\n        if (k >= size && l == i) return node[k];\n        if (l <= i && i < m) return query(i, 2 * k, l, m);\n        else return query(i, 2 * k + 1, m, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree st(n);\n    for (int j = 0; j < q; j++) {\n        int type;\n        cin >> type;\n        if (type == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(s, t + 1, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.query(i) << '\\n';\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#include <cassert>\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_D\"\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\ntemplate<typename Element>\nstruct assign\n{\n    using element_type  = Element;\n    using operator_type = element_type;\n    static operator_type compose(const operator_type& f1, const operator_type& f2) { return f1 != id() ? f1 : f2; }\n    assign() = delete;\n    static constexpr operator_type id() { return inf_v<operator_type>; }\n};\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\ntemplate<typename T>\nvoid out(const T& v) { std::cout << v; }\ntemplate<typename T>\nvoid out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    std::cout << \"\\n\";\n}\ntemplate<typename T1, typename T2>\nvoid out(const std::pair<T1, T2>& v) { out(v.first), std::cout << ' ', out(v.second); }\ntemplate<typename T, typename... Args>\nvoid out(const T& v, const Args... args) { out(v), std::cout << ' ', out(args...); }\ntemplate<typename... Args>\nvoid outln(const Args... args) { out(args...), std::cout << '\\n'; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { out(args...), std::cout << std::endl; }\n\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename OpMonoid>\nclass dualseg\n{\npublic:\n    using operator_monoid_type = OpMonoid;\n    using operator_type        = typename operator_monoid_type::operator_type;\n    dualseg(const usize sz, const operator_type& initial = operator_monoid_type::id()) : sz{sz}, depth{clog(sz)}, half{static_cast<usize>(1) << depth}, op(half << 1, operator_monoid_type::id())\n    {\n        if (initial != operator_monoid_type::id()) { std::fill(op.begin() + half, op.end(), initial); }\n    }\n    template<typename InIt>\n    dualseg(const InIt first, const InIt last) : sz{static_cast<usize>(std::distance(first, last))}, depth{clog(sz)}, half{static_cast<usize>(1) << depth}, op(half << 1, operator_monoid_type::id()) { std::copy(first, last, op.begin() + half); }\n    operator_type get(const usize a) const\n    {\n        assert(a < sz);\n        operator_type ans = operator_monoid_type::id();\n        for (usize i = 0; i <= depth; i++) { ans = operator_monoid_type::compose(ans, op[(a + half) >> (depth - i)]); }\n        return ans;\n    }\n    void set(usize a, const operator_type& f)\n    {\n        assert(a < sz);\n        clean(a += half), clean(a + 1), op[a] = f;\n    }\n    void act(usize L, usize R, const operator_type& f)\n    {\n        assert(L < R), assert(R <= sz);\n        clean(L += half), clean(R += half);\n        for (; L < R; L >>= 1, R >>= 1) {\n            if (L & 1) { update(L++, f); }\n            if (R & 1) { update(--R, f); }\n        }\n    }\n    usize size() const { return sz; }\n    friend std::ostream& operator<<(std::ostream& os, const dualseg& seg)\n    {\n        os << \"[\";\n        for (usize i = 0; i < seg.sz; i++) { os << seg.get(i) << (i + 1 == seg.sz ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void down(const usize a) { update(a << 1, op[a]), update(a << 1 | 1, op[a]), op[a] = operator_monoid_type::id(); }\n    void clean(const usize a)\n    {\n        const usize b = (a / (a & -a)) >> 1;\n        for (usize i = 0; i < depth; i++) {\n            const usize v = a >> (depth - i);\n            if (v > b) { break; }\n            down(v);\n        }\n    }\n    void update(const usize a, const operator_type& f) { op[a] = operator_monoid_type::compose(f, op[a]); }\n    const usize sz, depth, half;\n    std::vector<operator_type> op;\n};\nint main()\n{\n    const auto n = in<usize>();\n    const auto q = in<usize>();\n    dualseg<assign<ll>> seg(n, (1LL << 31) - 1);\n    for (usize i = 0; i < q; i++) {\n        const auto c = in<usize>();\n        if (c == 0) {\n            const auto l = in<usize>();\n            const auto r = in<usize>() + 1;\n            const auto x = in<ll>();\n            seg.act(l, r, x);\n        } else {\n            const auto x = in<usize>();\n            outln(seg.get(x));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n#define INF (1LL<<31)-1\ntypedef struct RUQ{\nll n;\n\tvector<ll> a;\n\t//vector<bool> f;\n\tvoid init(int size){\n\t\tn = 1;\n\t\twhile(n<size) n*=2;\n\t\ta = vector<ll> (2*n-1,INF);\n\t\t//f = vector<bool> (2*n-1,true);\n\t}\n\t\n\tvoid init(vector<ll> &b){\n\t\tint size = b.size();\n\t\tn = 1;\n\t\twhile(n<size)n*=2;\n\t\ta = vector<ll> (2*n-1,INF);\n\t\t//f = vector<bool> (n,true);\n\t\tfor(int i=0;i<size;i++) a[i+n-1] = b[i];\n\t}\n\t//\n\tvoid update(ll aa,ll b ,ll k,ll l,ll r ,ll x){\n\t\tif(r<= aa|| b<= l)return ;\n\t\tif(aa<=l && r<=b ) a[k] = x;\n\t\telse{\n\t\t\tif(a[k] != INF){\n\t\t\t\ta[k*2+1] = a[k];\n\t\t\t\ta[k*2+2] = a[k];\n\t\t\t\ta[k] = INF;\n\t\t\t}\n\t\t\tupdate(aa,b,k*2+1,l,(l+r)/2,x);\n\t\t\tupdate(aa,b,k*2+2,(l+r)/2,r,x);\n\t\t}\n\t\treturn ;\n\t}\n\tll find(ll aa,ll b,ll k,ll l,ll r){\n\t\tif(r<=aa|| b<=l) return INF;\n\t\tif(aa<=l && r<= b) return a[k];\n\t\tif(a[k]!=INF){\n\t\t\ta[k*2+1] = a[k];\n\t\t\ta[k*2+2] = a[k];\n\t\t\ta[k] = INF;\n\t\t}\n\t\treturn min(find(aa,b,k*2+1,l,(l+r)/2),find(aa,b,k*2+2,(l+r)/2,r) );\n\t}\n\t//[s,t]\n\tvoid update(ll s,ll t,ll x){\n\t\tupdate(s,t+1,0,0,n,x);\n\t}\n\tll find(ll s){\n\t\treturn find(s,s+1,0,0,n);\n\t}\n\t\n}RUQ;\n\n\n\nint main(){\n\tll n,q;\n\tcin>>n>>q;\n\tRUQ seg;\n\tseg.init(n);\n\t//cout<<seg.a.size()<<endl;\n\tfor(ll i=0;i<q;i++){\n\t\tll d,s,t,x;\n\t\tcin>>d;\t\t\n\t\tif(d==0){\n\t\t\tcin>>s>>t>>x;\n\t\t\tseg.update(s,t,x);\n\t\t}else{\n\t\t\tcin>>s;\n\t\t\tcout<<seg.find(s)<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int A[100000];\n    int i, s, t, x, n, q, ask;\n\n    for(i = 0; i < 100000; i++) A[i] = INT_MAX;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n\t\tif(ask){\n            cin >> i;\n            printf(\"%d\\n\", A[i]);\n\t\t}else{\n            cin >> s >> t >> x;\n\t\t\tfor(i = s; i <= t; i++) A[i] = x;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define rep(i, N) for(ll i=0; i<(N); ++i)\n\n//sqrtN -> 最大値のみに対応できればいいので，それを使う\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<int> bucketData;\n  const int INIT_VALUE = 0;\n  \n  SqrtDecomposition(int n) : N(n) {\n    //分割数\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, 2147483647);\n    bucketData.assign(K, -1);\n  }\n  \n  //ここまで共通\n  \n  void update(int x, int y, int v) {\n    for(int k = 0; k < K; ++k) {\n      int l = k * sqrtN;\n      int r = (k + 1) * sqrtN;\n      if(y <= l || x >= r) continue;  //完全に区間外\n      if(l >= x && y >= r) {  //完全に区間内をUPDATE（遅延bucketのみ）\n        bucketData[k] = v;\n      } else {\n        //一部区間内\n        if(bucketData[k] != -1) {\n          //まず，bucketを伝搬\n          for(int i = l; i < r; ++i) {\n            data[i] = bucketData[k];\n          }\n          bucketData[k] = -1;\n        }\n        \n        for(int i = max(x, l); i < min(y, r); ++i) {\n          data[i] = v;\n        }\n      }\n    }\n  }\n  \n  // [x, y)\n  int find(int x) {\n    int k = x / sqrtN;\n    \n    //伝搬\n    if(bucketData[k] != -1) {\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = bucketData[k];\n      }\n      bucketData[k] = -1;\n    }\n    \n    return data[x];\n  }\n};\n\nint main() {\n  //range sum query\n  int n, q;\n  cin >> n >> q;\n  \n  SqrtDecomposition dec(n);\n  vector<string> res;\n  rep(_, q) {\n    int c;\n    cin >> c;\n    if(c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      ++t;\n      dec.update(s, t, x);\n    } else {\n      int i;\n      cin >> i;\n      cout << dec.find(i) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n#ifndef MAX\n#define MAX 400000\n#endif\n\n//Range Update Query+Range Sum Query\ntemplate<class T>\nclass RUQ_RSQ {\npublic:\n\tint n;\n\tT dat[MAX], lazy[MAX], ZERO, DEFAULT;\n\tvoid init(int n_, T d = INT_MAX, T t = 0) {\n\t\tDEFAULT = d;\n\t\tZERO = T();\n\t\tn = 1; while (n < n_)n <<= 1;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tdat[i] = t; lazy[i] = DEFAULT;\n\t\t}\n\t}\n\tinline void push(int k, int s) {\n\t\tif (lazy[k] == DEFAULT)return;\n\t\tdat[k] = lazy[k] * s;\n\t\tif (k < n - 1) {\n\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = DEFAULT;\n\t}\n\tinline void update_node(int k) {\n\t\tdat[k] = dat[k * 2 + 1] + dat[k * 2 + 2];\n\t}\n\tinline void update(int a, int b, T x, int k, int l, int r) {\n\t\tpush(k, r - l);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = x; push(k, r - l); return;\n\t\t}\n\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t}\n\tinline T query(int a, int b, int k, int l, int r) {\n\t\tpush(k, r - l);\n\t\tif (r <= a || b <= l)return ZERO;\n\t\tif (a <= l&&r <= b)return dat[k];\n\t\tT lb = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT rb = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t\treturn lb + rb;\n\t}\n\tinline void update(int a, int b, T x) {\n\t\tupdate(a, b, x, 0, 0, n);\n\t}\n\tinline void update(int a, T x) {\n\t\tupdate(a, a + 1, x);\n\t}\n\tinline T query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\tinline T query(int a) {\n\t\treturn query(a, a + 1);\n\t}\n};\nRUQ_RSQ<int>seg;\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tseg.init(n, INT_MAX, INT_MAX);\n\trep(i, q) {\n\t\tint a; scanf(\"%d\", &a);\n\t\tif (a == 0) {\n\t\t\tint s, t, x; scanf(\"%d%d%d\", &s, &t, &x); t++;\n\t\t\tseg.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint t; scanf(\"%d\", &t);\n\t\t\tprintf(\"%d\\n\", seg.query(t));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\n\nconst long long inf = (1ll << 31);\nconst int max_n = (1 << 17);\n\nlong long seg[max_n * 2 - 1];\nlong long lazy[max_n * 2 - 1];\n\nvoid init()\n{\n  int _n = n;\n\n  n = 1;\n  while (n < _n) n *= 2;\n\n  fill(seg, seg + 2 * n - 1, inf);\n  fill(lazy, lazy + 2 * n - 1, inf + 1);\n}\n\nvoid update(int a, int b, int x, int k = 0, int l = 0, int r = n)\n{\n  if (a <= l && r <= b){\n    lazy[k] = x;\n    return;\n  }\n  if (r <= a || b <= l){\n    return;\n  }\n\n  if (lazy[k] != inf + 1) {\n    lazy[k * 2 + 1] = lazy[k * 2 + 2] = lazy[k];\n  }\n  lazy[k] = inf + 1;\n  update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n  update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n}\n\nvoid find(int a, int b, int k = 0, int l = 0, int r = n)\n{\n  if (a <= l && r <= b){\n    if (lazy[k] != inf + 1){\n      seg[k] = lazy[k];\n    }\n    lazy[k] = inf + 1;\n    return;\n  }\n  else if (r <= a || b <= l){\n    return;\n  }\n  else {\n    if (lazy[k] != inf + 1){\n      lazy[k * 2 + 1] = lazy[k * 2 + 2] = lazy[k];\n      lazy[k] = inf + 1;\n    }\n    find(a, b, k * 2 + 1, l, (l + r) / 2);\n    find(a, b, k * 2 + 2, (l + r) / 2, r);\n  }\n}\n\nint main()\n{\n  cin >> n >> q;\n  init();\n  for (int i = 0; i < q; i++){\n    int f;\n    cin >> f;\n\n    if (f == 0){\n      int s, t, x;\n\n      cin >> s >> t >> x;\n      update(s, t + 1, x);\n      /*\n      for (int i = 0; i < n * 2 - 1; i++){\n        cout << lazy[i] << \" \";\n      }\n      puts(\"\");\n      */\n    } else {\n      int i;\n\n      cin >> i;\n      find(i, i + 1);\n\n      /*\n      for (int i = 0; i < n * 2 - 1; i++){\n        cout << seg[i] << \" \";\n      }\n      puts(\"\");\n      */\n      cout << seg[i + n - 1] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct RUP{\n  int n;\n  vector<int> dat,laz;\n  const int def=INT_MAX;\n  RUP(){}\n  RUP(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n    laz.clear();\n    laz.resize(2*n-1,-1);\n  }\n  inline void eval(int len,int k){\n    if(laz[k]<0) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=laz[k];\n      laz[k*2+2]=laz[k];\n    }\n    dat[k]=laz[k];\n    laz[k]=-1;\n  }\n  void update(int a,int b,int x,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      laz[k]=x;\n      return;\n    }\n    eval(r-l,k);\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n  int query(int a,int b,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  void update(int a,int b,int x){\n    update(a,b,x,0,0,n);\n  }\n  int query(int a){\n    return query(a,a+1,0,0,n);\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  RUP rup(n);\n  for(int i=0;i<q;i++){\n    int f;\n    cin>>f;\n    if(!f){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rup.update(s,t+1,x);\n    }else{\n      int u;\n      cin>>u;\n      cout<<rup.query(u)<<endl;\n    }\n  }\n  return 0;\n}\n\n/*\nverified on 2017/07/12\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\n\n\ntemplate<class T, class OP, class PROP>\nclass Lazy_Segment_Tree {//0-indexed ??????\npublic:\n\tvector<T> data, lazy;\n\tvector<bool> isupd;\n\tint n;\n\tLazy_Segment_Tree(int a) :n(1) {\n\t\twhile (n < a) n *= 2;\n\t\tdata.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tisupd.resize(n * 2 - 1);\n\t}\n\n\tvoid prop(int num, int s) {\n\t\tif (isupd[num]) {\n\t\t\tdata[num] = PROP()(data[num], lazy[num], 1, s);\n\t\t\tif (num < n - 1) {\n\t\t\t\tlazy[num * 2 + 1] = PROP()(lazy[num * 2 + 1], lazy[num]);\n\t\t\t\tlazy[num * 2 + 2] = PROP()(lazy[num * 2 + 2], lazy[num]);\n\t\t\t\tisupd[num * 2 + 1] = 1;\n\t\t\t\tisupd[num * 2 + 2] = 1;\n\t\t\t}\n\t\t\tlazy[num] = T();\n\t\t\tisupd[num] = 0;\n\t\t}\n\t}\n\tvoid op(int a, int b, T v, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\tprop(num,r-l);\n\t\tif (a == l && b == r) {\n\t\t\tisupd[num] = 1;\n\t\t\tlazy[num] = PROP()(lazy[num], v);\n\t\t\tprop(num, r-l);\n\t\t}\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tif (nr > a) op(a, min(b, nr), v, num * 2 + 1, base * 2);\n\t\t\tif (nr < b) op(max(a, nr), b, v, num * 2 + 2, base * 2);\n\t\t\tprop(num * 2 + 1, (r - l) / 2), prop(num * 2 + 2, (r - l) / 2);\n\t\t\tdata[num] = OP()(data[num * 2 + 1], data[num * 2 + 2]);\n\t\t}\n\t}\n\n\tT query(int a, int b, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\t\n\t\tprop(num,r-l);\n\n\t\tif (a == l && b == r)\n\t\t\treturn data[num];\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tT ret = T();\n\t\t\tif (nr > a) ret = OP()(ret,query(a, min(b, nr), num * 2 + 1, base * 2));\n\t\t\tif (nr < b) ret = OP()(ret,query(max(a, nr), b, num * 2 + 2, base * 2));\n\t\t\treturn ret;\n\t\t}\n\t}\n};\n\n\ntemplate<class T>\nclass ADD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn a + b;\n\t}\n};\n\ntemplate<class T>\nclass UPD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn b;\n\t}\n};\n\ntemplate<class T>\nclass RMQ {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn min(a, b);\n\t}\n};\ntemplate<class T>\nclass SUM {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn a+b;\n\t}\n};\n\nstruct N {\npublic:\n\tll num;\n\tN(ll num) : num(num) {}\n\tN():num(0) {}\n\tN operator + (const N obj) const{\n\t\treturn N(obj.num + num);\n\t}\n\tbool operator < (const N obj)const {\n\t\treturn obj.num > num;\n\t}\n};\nsigned main() {\n\tint n, q;\n\n\tscanf(\"%d %d\", &n, &q);\n\tLazy_Segment_Tree<N, SUM<N>, UPD<N>> seg(n);\n\tseg.op(0, n, pow(2,31)-1);\n\tREP(i, q) {\n\t\tint t;\n\t\tscnaf(\"%d\", &t);\n\t\tif (!t) {\n\t\t\tint a, b, c;\n\t\t\tscnaf(\"%d %d %d\", &a, &b, &c);\n\t\t\tseg.op(a, b+1, c);\n\t\t}\n\t\telse {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tprintf(\"%d\\n\", seg.query(a,a+1));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\ntemplate <typename T, typename E>\nstruct LazySegmentTree\n{\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, int)>;\n    F f;\n    G g;\n    H h;\n    P p;\n    T d1;\n    E d0;\n    int n;\n    vector<T> node;\n    vector<E> lazy;\n\n    LazySegmentTree(int sz, F f, G g, H h, T d1, E d0, vector<T> v = vector<T>(), P p = [](E a, int b) { return a; }) : f(f), g(g), h(h), d1(d1), d0(d0), p(p)\n    {\n        init(sz);\n        if (sz == (int)v.size())\n        {\n            build(sz, v);\n        }\n    }\n\n    void init(int sz)\n    {\n        n = 1;\n        while (n < sz)\n        {\n            n *= 2;\n        }\n        node.clear();\n        node.resize(2 * n - 1, d1);\n        lazy.clear();\n        lazy.resize(2 * n - 1, d0);\n    }\n\n    void build(int sz, vector<T> v)\n    {\n        for (int i = 0; i < sz; i++)\n        {\n            node[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--)\n        {\n            node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    inline void eval(int len, int now)\n    {\n        if (lazy[now] == d0)\n        {\n            return;\n        }\n        if (2 * now + 1 < 2 * n - 1)\n        {\n            lazy[2 * now + 1] = h(lazy[2 * now + 1], lazy[now]);\n            lazy[2 * now + 2] = h(lazy[2 * now + 2], lazy[now]);\n        }\n        node[now] = g(node[now], p(lazy[now], len));\n        lazy[now] = d0;\n    }\n\n    T update(int a, int b, E x, int now = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = n;\n        }\n        eval(r - l, now);\n        if (r <= a || b <= l)\n        {\n            return node[now];\n        }\n        if (a <= l && r <= b)\n        {\n            lazy[now] = h(lazy[now], x);\n            return g(node[now], p(lazy[now], r - l));\n        }\n        T vl = update(a, b, x, 2 * now + 1, l, (l + r) / 2);\n        T vr = update(a, b, x, 2 * now + 2, (l + r) / 2, r);\n        return node[now] = f(vl, vr);\n    }\n\n    T query(int a, int b, int now = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = n;\n        }\n        eval(r - l, now);\n        if (r <= a || b <= l)\n        {\n            return d1;\n        }\n        if (a <= l && r <= b)\n        {\n            return node[now];\n        }\n        T vl = query(a, b, 2 * now + 1, l, (l + r) / 2);\n        T vr = query(a, b, 2 * now + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    vector<int> data(n, INT_MAX);\n    auto f = [](int a, int b) { return min(a, b); };\n    auto g = [](int a, int b) { return (b == INT_MAX ? a : b); };\n    auto h = [](int a, int b) { return (b == INT_MAX ? a : b); };\n    LazySegmentTree<int, int> seg(n, f, g, h, INT_MAX, INT_MAX, data);\n    while (q--)\n    {\n        int hoge, s, t, x;\n        cin >> hoge;\n        if (hoge)\n        {\n            cin >> x;\n            cout << seg.query(x, x + 1) << endl;\n        }\n        else\n        {\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass lazy_segtree {\n    public:\n        int size;\n        vector<int> node,lazy;\n\n        lazy_segtree(int n_) {\n            size=1;\n            while (size<n_) size*=2;\n            node.resize(2 * size, INT_MAX);\n            lazy.resize(2 * size, -1);\n        }\n\n        void setlazy(int k, int v) {\n            if (k>=2*size-1) return ;\n            lazy[k] = v;\n            node[k] = v;\n        }\n\n        void push(int k) {\n            if (k>=2*size-1) return ;\n            if (lazy[k] == -1) return ;\n            setlazy(k * 2 + 1, lazy[k]);\n            setlazy(k * 2 + 2, lazy[k]);\n            lazy[k] = -1;\n        }\n\n        void range_update(int queryL,int queryR,int val,int k=0,int nodeL=0,int nodeR=-1) {\n            if (nodeR==-1) nodeR=size;\n            if (nodeR<=queryL || queryR<=nodeL) return ;\n            if (queryL<=nodeL && nodeR<=queryR) {\n                setlazy(k,val);\n                return ;\n            }\n            else {\n                push(k);\n                int nodeM=(nodeL+nodeR)/2;\n                range_update(queryL,queryR,val,k*2+1,nodeL,nodeM);\n                range_update(queryL,queryR,val,k*2+2,nodeM,nodeR);\n                return ;\n            }\n        }\n\n        int get_node(int queryL,int queryR,int k=0,int nodeL=0,int nodeR=-1) {\n            if (nodeR==-1) nodeR=size;\n            if (nodeR<=queryL || queryR<=nodeL) return 0;\n            if (queryL<=nodeL && nodeR<=queryR) return node[k];\n            else {\n                push(k);\n                int nodeM=(nodeL+nodeR)/2;\n                int tmp1=get_node(queryL,queryR,k*2+1,nodeL,nodeM);\n                int tmp2=get_node(queryL,queryR,k*2+2,nodeM,nodeR);\n                if (tmp1!=0) return tmp1;\n                else if(tmp2!=0) return tmp2;\n            }\n        }\n};\n\nint n,q;\n\nint main(){\n    cin >> n >> q;\n    lazy_segtree ls(n);\n    for (int i=0; i<q; i++) {\n        int que,s,t,x,idx;\n        cin >> que;\n        if (que==0) {\n            cin >> s >> t >> x;\n            ls.range_update(s,t+1,x);\n        }\n        else {\n            cin >> idx;\n            cout << ls.get_node(idx,idx+1) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass RUQ{\npublic:\n    int N;\n    vector<int> data;\n    vector<int> times;\n    \n    void update(int time, int a, int b, int x, int k, int l, int r){\n        if(a <= l && r <= b){\n            if(times[k] < time){\n                data[k] = x;\n                times[k] = time;\n            }\n            return;\n        }\n        if(b <= l || r <= a)\n            return;\n        update(time, a, b, x, 2*k+1, l, (l+r)/2);\n        update(time, a, b, x, 2*k+2, (l+r)/2, r);\n    }\n    \npublic:\n    RUQ(int N_){\n        N = 1;\n        while(N < N_)\n            N <<= 1;\n        data.assign(2*N-1, INF);\n        times.assign(2*N-1, -1);\n    }\n    void update(int time, int s, int t, int x){\n        update(time, s, t, x, 0, 0, N);\n    }\n    int find(int x){\n        x += N-1;\n        int res = INF;\n        int time = -1;\n        while(true){\n            if(time < times[x]){\n                time = times[x];\n                res = data[x];\n            }\n            if(x == 0)\n                break;\n            x = (x-1)/2;\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N, Q;\n    cin >> N >> Q;\n    \n    RUQ ruq(N);\n    \n    for(int i=0; i<Q; i++){\n        int com; cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            ruq.update(i, s, t+1, x);\n        }\n        if(com == 1){\n            int i; cin >> i;\n            cout << ruq.find(i) << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[n/sq+1];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*(t/sq),sq,lazy[t/sq]);\n\t}\n\tfill_n(a+s,t-s+1,x);\n\t\n\t//cout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s) < 2*sq && t%sq != sq - 1){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*(t/sq),sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*(s/sq),sq,lazy[s/sq]);\n\t}\n\tfill_n(a+s,t-s+1,x);\n\t\n\tlazy[t/sq] = -1;\n\t\n\tlazy[s/sq] = -1;\n      \n\t//cout << \"debug2\" << endl;\n      }\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*(t/sq),sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*(s/sq),sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  REP(i,res.size()){\n    cout << res[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e5+5;\nconst int inf=(1ll<<31)-1;\n#define lson (rt<<1)\n#define rson (rt<<1|1)\n\nint tag[maxn*4];//标记打成-1，用~-1==0简化代码\nvoid upd(int rt,int l,int r,int x,int y,int v){\n    if(x<=l&&r<=y)tag[rt]=v;\n    else{\n        if(~tag[rt])tag[lson]=tag[rson]=tag[rt],tag[rt]=-1;\n        int mid=(l+r)/2;\n        if(y<=mid)upd(lson,l,mid,x,y,v);\n        else if(x>mid) upd(rson,mid+1,r,x,y,v);\n        else upd(lson,l,mid,x,mid,v),upd(rson,mid+1,r,mid+1,y,v);\n    }\n}\nint find(int rt,int l,int r,int x){\n    if(~tag[rt])return tag[rt];\n    int mid=(l+r)>>1;\n    if(x<=mid)return find(lson,l,mid,x);\n    else return find(rson,mid+1,r,x);\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,q;\n    cin>>n>>q;\n    rep(i,1,(n<<2))tag[i]=inf;\n    rep(i,1,q){\n        int op,x,y,v;\n        cin>>op;\n        if(op){\n            cin>>x;\n            cout<<find(1,1,n,x+1)<<endl;\n        }else{\n            int v;\n            cin>>x>>y>>v;\n            upd(1,1,n,x+1,y+1,v);\n        }\n    }\n\n}\n\n\n/* \n3 5\n0 0 1 1\n0 1 2 3\n0 2 2 2\n1 0\n1 1 \n\n1≤n≤100000\n1≤q≤100000\n0≤s≤t<n\n0≤i<n\n0≤x<2^31−1\n */\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n// write [ StarrySkyTree<> sst(n) ] when using this snippet.\ntemplate<typename T = ll, bool QUERY_IS_GETMAX = true>\nstruct StarrySkyTree {\n\tstd::vector<T> seg, laz;\n\tint size;\n\tT inf;\n\tstd::function<T(T&, T&)> func;\n\tStarrySkyTree() {}\n\tStarrySkyTree(int n) : inf((QUERY_IS_GETMAX ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max())), func([](T& a, T& b) {return (QUERY_IS_GETMAX ? std::max(a, b) : std::min(a, b)); }) {\n\t\tinit(n);\n\t}\n\tvoid init(int n) {\n\t\tsize = 1;\n\t\twhile (size < n) size *= 2;\n\t\tseg.resize(size * 2);\n\t\tlaz.resize(size * 2);\n\t}\n\tvoid push(int k, int l, int r) {\n\t\tseg[k] += laz[k];\n\t\tif (r - l > 1) {\n\t\t\tlaz[k * 2 + 1] += laz[k];\n\t\t\tlaz[k * 2 + 2] += laz[k];\n\t\t}\n\t\tlaz[k] = 0;\n\t}\n\tvoid update(int a, int b, T v, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlaz[k] += v;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, v, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, v, k * 2 + 2, (l + r) / 2, r);\n\t\t\tseg[k] = func(seg[k * 2 + 1], seg[k * 2 + 2]);\n\n\t\t}\n\t}\n\t// add v to [a,b)\n\tvoid update(int a, int b, T v) {\n\t\tupdate(a, b, v, 0, 0, size);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return inf;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn func(vl, vr);\n\t}\n\t// return min(or max) in [a,b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size);\n\t}\n};\n\n// ------------>8---------- LazySegmentTree ---------->8------------\n\n// write [ LazySegmentTree st(n, SUM/MAX/MIN, ADD/UPD) ] when using this snippet.\nenum QUERY_SEG_LazySegmentTree { SUM, MAX, MIN };\nenum QUERY_LAZ_LazySegmentTree { ADD, UPD };\ntemplate<class SEG, class LAZ>\nclass LazySegmentTree {\nprivate:\n\tstd::vector<SEG> seg;\n\tstd::vector<LAZ> laz;\n\tstd::vector<bool> isUpdated;\n\tint ARY_SIZE;\n\tSEG eSeg;\n\tLAZ eLaz;\n\tstd::function<SEG(SEG&, SEG&)> mergeSeg;\n\tstd::function<LAZ(LAZ&, LAZ&)> mergeLaz;\n\tstd::function<SEG(SEG&, LAZ&, int)> applyLaz;\n\n\tvoid push(int k, int l, int r) {\n\t\tif (!isUpdated[k]) {\n\t\t\tseg[k] = applyLaz(seg[k], laz[k], r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tmergeLaz(laz[k * 2 + 1], laz[k]); isUpdated[k * 2 + 1] = false;\n\t\t\t\tmergeLaz(laz[k * 2 + 2], laz[k]); isUpdated[k * 2 + 2] = false;\n\t\t\t}\n\t\t\tisUpdated[k] = true;\n\t\t\tlaz[k] = eLaz;\n\t\t}\n\t}\npublic:\n\tLazySegmentTree(int n, QUERY_SEG_LazySegmentTree qSeg, QUERY_LAZ_LazySegmentTree qLaz) : ARY_SIZE(1) {\n\t\tARY_SIZE = 1;\n\t\twhile (ARY_SIZE < n) ARY_SIZE *= 2;\n\t\tseg.resize(ARY_SIZE * 2 - 1);\n\t\tlaz.resize(ARY_SIZE * 2 - 1);\n\t\tisUpdated.resize(ARY_SIZE * 2 - 1, true);\n\n\t\tswitch (qSeg) {\n\t\t\tcase SUM:\n\t\t\t\teSeg = 0;\n\t\t\t\tmergeSeg = [](SEG& l, SEG& r) { return l + r; };\n\t\t\t\tbreak;\n\t\t\tcase MAX:\n\t\t\t\teSeg = std::numeric_limits<SEG>::lowest();\n\t\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::max(l, r); };\n\t\t\t\tbreak;\n\t\t\tcase MIN:\n\t\t\t\teSeg = std::numeric_limits<SEG>::max();\n\t\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::min(l, r); };\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (qLaz)\n\t\t{\n\t\t\tcase ADD:\n\t\t\t\teLaz = 0;\n\t\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l += r; };\n\t\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s += l * w; };\n\t\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s += l; };\n\t\t\t\tbreak;\n\t\t\tcase UPD:\n\t\t\t\teLaz = 0;\n\t\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l = r; };\n\t\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s = l * w; };\n\t\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s = l; };\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvoid update(int a, int b, SEG v, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tLAZ la(v);\n\t\t\tmergeLaz(laz[k], la);\n\t\t\tisUpdated[k] = false;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, v, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, v, k * 2 + 2, (l + r) / 2, r);\n\t\t\tseg[k] = mergeSeg(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\t// add v to [a,b)\n\tvoid update(int a, int b, SEG v) {\n\t\tupdate(a, b, v, 0, 0, ARY_SIZE);\n\t}\n\tSEG query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return eSeg;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tSEG vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tSEG vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn mergeSeg(vl, vr);\n\t}\n\t// return min(or max) in [a,b)\n\tSEG query(int a, int b) {\n\t\treturn query(a, b, 0, 0, ARY_SIZE);\n\t}\n};\n\nusing LST = LazySegmentTree<ll, ll>;\n// ------------>8---------- LazySegmentTree ---------->8------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, Q);\n\n\tLST lst(n, MAX, UPD);\n\tREP(i, n) lst.update(0, n, (1 << 30) - 1 + (1 << 30));\n\tREP(_, Q) {\n\t\tVAR(int, c, s);\n\t\tif (c == 0) {\n\t\t\tVAR(int, t, x);\n\t\t\tlst.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tOUT(lst.query(s, s + 1))BR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass lazy_segtree {\n    public:\n        int size;\n        vector<int> node,lazy;\n        lazy_segtree(int n_) {\n            size=1;\n            while (size<n_) size*=2;\n            node.resize(2 * size, INT_MAX);\n            lazy.resize(2 * size, -1);\n        }\n\n        void setlazy(int k, int v) {\n            if (k>=2*size-1) return ;\n            lazy[k] = v;\n            node[k] = v;\n        }\n\n        void push(int k) {\n            if (k>=2*size-1) return ;\n            if (lazy[k] == -1) return ;\n            setlazy(k * 2 + 1, lazy[k]);\n            setlazy(k * 2 + 2, lazy[k]);\n            lazy[k] = -1;\n        }\n\n        void range_update(int queryL,int queryR,int val,int k=0,int nodeL=0,int nodeR=-1) {\n            if (nodeR==-1) nodeR=size;\n            if (nodeR<=queryL || queryR<=nodeL) return ;\n            if (queryL<=nodeL && nodeR<=queryR) {\n                setlazy(k,val);\n                return ;\n            }\n            else {\n                push(k);\n                int nodeM=(nodeL+nodeR)/2;\n                range_update(queryL,queryR,val,k*2+1,nodeL,nodeM);\n                range_update(queryL,queryR,val,k*2+2,nodeM,nodeR);\n                return ;\n            }\n        }\n\n        int get_node(int queryL,int queryR,int k=0,int nodeL=0,int nodeR=-1) {\n            if (nodeR==-1) nodeR=size;\n            if (nodeR<=queryL || queryR<=nodeL) return -1;\n            if (queryL<=nodeL && nodeR<=queryR) return node[k];\n            else {\n                push(k);\n                int nodeM=(nodeL+nodeR)/2;\n                int tmp1=get_node(queryL,queryR,k*2+1,nodeL,nodeM);\n                int tmp2=get_node(queryL,queryR,k*2+2,nodeM,nodeR);\n                if (tmp1!=-1) return tmp1;\n                else if(tmp2!=-1) return tmp2;\n            }\n        }\n};\n\nint n,q;\n\nint main(){\n    cin >> n >> q;\n    lazy_segtree ls(n);\n    for (int i=0; i<q; i++) {\n        int que,s,t,x,idx;\n        cin >> que;\n        if (que==0) {\n            cin >> s >> t >> x;\n            ls.range_update(s,t+1,x);\n        }\n        else {\n            cin >> idx;\n            cout << ls.get_node(idx,idx+1) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool upd[(1<<18)];\nint val[(1<<18)];\n\nvoid Set(int a,int b,int x,int k=0,int l=0,int r=(1<<17)){\n\tif(b<=l || r<=a)return;\n\n\tif( r-l>1 && upd[k] ){\n\t\tupd[k*2+1] = upd[k*2+2] = 1;  \n\t\tval[k*2+1] = val[k*2+2] = val[k];\n\t}\n\tupd[k]=0;\n\n\tif(a<=l && r<=b){\n\t\tupd[k]=1;\n\t\tval[k]=x;\n\t}\n\telse{\n\t\tSet(a,b,x,k*2+1,l,(l+r)/2);\n\t\tSet(a,b,x,k*2+2,(l+r)/2,r);\n\t\tval[k]=min(val[k*2+1],val[k*2+2]);\n\t}\n}\nint Find(int a,int b,int k=0,int l=0,int r=(1<<17)){\n\tif(b<=l || r<=a)return INT_MAX;\n\n\tif( r-l>1 && upd[k] ){\n\t\tupd[k*2+1] = upd[k*2+2] = 1;  \n\t\tval[k*2+1] = val[k*2+2] = val[k];\n\t}\n\tupd[k]=0;\n\n\tif(a<=l && r<=b) return val[k];\n\telse{\n\t\tint L = Find(a,b,k*2+1,l,(l+r)/2);\n\t\tint R = Find(a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(L,R);\n\t}\n}\n\nint n,m,a,b,c,d;\n\nint main(){\n\tmemset(upd,0,sizeof(upd));\n\tfill(val,val+(1<<18),INT_MAX);\n\tcin>>n>>m;\n\twhile(m--){\n\t\tcin>>a>>b;\n\t\tif(a){\n\t\t\tcout<<Find(b,b+1)<<endl;\n\t\t}\n\t\telse{\n\t\t\tcin>>c>>d;\n\t\t\tSet(b,c+1,d);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, q);\n\n\tstd::vector<int> a(n, INFINT_LIM);\n\n\tint DIV = std::sqrt(n) + 1;\n\tstd::vector<int> seg(n / DIV + 1, -1);\n\n\tREP(_, q) {\n\t\tVAR(int, c);\n\t\tif (c == 0) {\n\t\t\tVAR(int, l, r, x);\n\t\t\twhile (l <= r && l%DIV != 0) {\n\t\t\t\tint p = l / DIV;\n\t\t\t\tif (seg[p] != -1) {\n\t\t\t\t\tFOR(i, p*DIV, (p + 1)*DIV) {\n\t\t\t\t\t\ta[i] = seg[p];\n\t\t\t\t\t}\n\t\t\t\t\tseg[p] = -1;\n\t\t\t\t}\n\t\t\t\ta[l] = x;\n\t\t\t\t++l;\n\t\t\t}\n\t\t\twhile (l <= r && r%DIV != DIV - 1) {\n\t\t\t\tint p = r / DIV;\n\t\t\t\tif (seg[p] != -1) {\n\t\t\t\t\tFOR(i, p*DIV, (p + 1)*DIV) {\n\t\t\t\t\t\ta[i] = seg[p];\n\t\t\t\t\t}\n\t\t\t\t\tseg[p] = -1;\n\t\t\t\t}\n\t\t\t\ta[r] = x;\n\t\t\t\t--r;\n\t\t\t}\n\t\t\twhile (l < r) {\n\t\t\t\tseg[l / DIV] = x;\n\t\t\t\tl += DIV;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tVAR(int, i);\n\t\t\tint p = i / DIV;\n\t\t\tif (seg[p] != -1) {\n\t\t\t\tFOR(i, p*DIV, (p + 1)*DIV) {\n\t\t\t\t\ta[i] = seg[p];\n\t\t\t\t}\n\t\t\t\tseg[p] = -1;\n\t\t\t}\n\t\t\tOUT(a[i])BR;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\n\n\ntemplate<class T, class OP, class PROP>\nclass Lazy_Segment_Tree {//0-indexed ??????\npublic:\n\tvector<T> data, lazy;\n\tvector<bool> isupd;\n\tint n;\n\tLazy_Segment_Tree(int a) :n(1) {\n\t\twhile (n < a) n *= 2;\n\t\tdata.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tisupd.resize(n * 2 - 1);\n\t}\n\n\tvoid prop(int num, int s) {\n\t\tif (isupd[num]) {\n\t\t\tdata[num] = PROP()(data[num], lazy[num], 1, s);\n\t\t\tif (num < n - 1) {\n\t\t\t\tlazy[num * 2 + 1] = PROP()(lazy[num * 2 + 1], lazy[num]);\n\t\t\t\tlazy[num * 2 + 2] = PROP()(lazy[num * 2 + 2], lazy[num]);\n\t\t\t\tisupd[num * 2 + 1] = 1;\n\t\t\t\tisupd[num * 2 + 2] = 1;\n\t\t\t}\n\t\t\tlazy[num] = T();\n\t\t\tisupd[num] = 0;\n\t\t}\n\t}\n\tvoid op(int a, int b, T v, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\tprop(num,r-l);\n\t\tif (a == l && b == r) {\n\t\t\tisupd[num] = 1;\n\t\t\tlazy[num] = PROP()(lazy[num], v);\n\t\t\tprop(num, r-l);\n\t\t}\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tif (nr > a) op(a, min(b, nr), v, num * 2 + 1, base * 2);\n\t\t\tif (nr < b) op(max(a, nr), b, v, num * 2 + 2, base * 2);\n\t\t\tprop(num * 2 + 1, (r - l) / 2), prop(num * 2 + 2, (r - l) / 2);\n\t\t\tdata[num] = OP()(data[num * 2 + 1], data[num * 2 + 2]);\n\t\t}\n\t}\n\n\tT query(int a, int b, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\t\n\t\tprop(num,r-l);\n\n\t\tif (a == l && b == r)\n\t\t\treturn data[num];\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tT ret = T();\n\t\t\tif (nr > a) ret = OP()(ret,query(a, min(b, nr), num * 2 + 1, base * 2));\n\t\t\tif (nr < b) ret = OP()(ret,query(max(a, nr), b, num * 2 + 2, base * 2));\n\t\t\treturn ret;\n\t\t}\n\t}\n};\n\n\ntemplate<class T>\nclass ADD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn a + b;\n\t}\n};\n\ntemplate<class T>\nclass UPD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn b;\n\t}\n};\n\ntemplate<class T>\nclass RMQ {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn min(a, b);\n\t}\n};\ntemplate<class T>\nclass SUM {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn a+b;\n\t}\n};\n\nstruct N {\npublic:\n\tint num;\n\tN(int num) : num(num) {}\n\tN():num(0) {}\n\tN operator + (const N obj) const{\n\t\treturn N(obj.num + num);\n\t}\n\tbool operator < (const N obj)const {\n\t\treturn obj.num > num;\n\t}\n};\nsigned main() {\n\tint n, q;\n\n\tscanf(\"%d %d\", &n, &q);\n\tLazy_Segment_Tree<N, SUM<N>, UPD<N>> seg(n);\n\tREP(i, q) {\n\t\tint t;\n\t\tscnaf(\"%d\", &t);\n\t\tif (!t) {\n\t\t\tint a, b, c;\n\t\t\tscnaf(\"%d %d %d\", &a, &b, &c);\n\t\t\tseg.op(a, b+1, c);\n\t\t}\n\t\telse {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tprintf(\"%d\\n\", seg.query(a,a+1));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[105000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\tint k = node;\n\t\tint ope;\n\t\tif (node % 2 == 0)ope = 0;\n\t\telse ope = 1;\n\n\t\tnode /= 2;\n\t\twhile (node > 0) {\n\t\t\tif (ope == 0)m[2 * node + 1] = m[node];\n\t\t\telse m[2 * node] = m[node];\n\t\t\tm[node] = -INF;\n\t\t\tif (node % 2 == 0)ope = 0;\n\t\t\telse ope = 1;\n\t\t\tnode /= 2;\n\t\t}\n\t\treturn;\n\t}\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{\n\tcin >> n >> q;\n\n\tn=init(n);\n\n\tint a, s, t, x, k;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> k;\n\t\t\tcout << find(k) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // include all standard C++ libraries\n\nusing namespace std;\n\n// Loops\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define _rrep(i,n) rrepi(i,n,0)\n#define rrepi(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)\n#define each(xi, x) for (auto&& xi : x)\n// Note: we can use rep(i,N) or rep(i,from,to)\n\n\n// typedef\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\nusing vi   = vector<int>;\nusing vvi  = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii  = pair<int, int>;\n\n\n// Constants\n\n// Shorter repr for frequently used terms\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\n// Algorithms\n#define all(x) (x).begin(), (x).end()\ntemplate<class T> pair<T, size_t> max(vector<T> &x){ auto it = max_element(all(x)); return mp(*it, it-x.begin()); }\ntemplate<class T> pair<T, size_t> min(vector<T> &x){ auto it = min_element(all(x)); return mp(*it, it-x.begin()); }\ntemplate<class T> inline bool chmax(T &maxval, const T &newval) { if (maxval<newval) { maxval=newval; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &minval, const T &newval) { if (minval>newval) { minval=newval; return 1; } return 0; }\n\n// Utilities\n// Grid world utilities\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n#define inside(H,W,y,x) 0<=(x) && (x)<(W) && 0<=(y) && (y)<(H)\n\ninline int in() {int x; cin >> x; return x;} // read int from cin\ninline  ll IN() {ll x; cin >> x; return x;}  // read ll from cin\n\n// Debug\n#ifdef LOCAL\n  #include \"dump.hpp\"\n  #define debug(x) cerr << #x << \": \" << x << '\\n'\n#else\n  #define dump(...)\n  #define debug(x)\n#endif\n\nstruct SegTree {\n  using T = pair<int,int>;  // 配列のデータ型\n  vector<T> dat;\n  int n;\n  T default_value;\n\n  struct Interval {\n    // セグ木の範囲のためのクラス\n    int node_id, left, right;  // id はノードID, [left, right)\n    inline bool intersects(Interval &other) const { return ! ((right<=other.left) || (other.right<=left)); }\n    inline bool includes(Interval &other) const { return (left<=other.left) && (other.right<=right); }\n    inline Interval left_child() const { return {2*node_id+1, left, (left+right)/2 }; };\n    inline Interval right_child() const { return {2*node_id+2, (left+right)/2, right }; };\n    inline Interval parent() const {\n      assert(!is_root());\n      bool is_left = (node_id%2==1);\n      if(is_left) return { (node_id-1)/2, left, 2*right-left };\n      else return { (node_id-1)/2, 2*left-right, right };\n    }\n    inline bool is_root() const { return node_id<=0; }\n  };\n\n\n  // 実装すべきもの\n  void update(int l, int r, T val){\n    Interval q = {-1, l, r};\n    update(q,root(),val);\n  }\n  void update(Interval q, Interval i, T val){\n    if(!q.intersects(i)) return;\n    else if(q.includes(i)){\n      (*this)[i] = val;\n    } else {\n      update(q,i.left_child(),val);\n      update(q,i.right_child(),val);\n    }\n  }\n  int query(int i){\n    Interval node = get_node(i);\n    T ret = (*this)[node];\n    while(!node.is_root()){\n      node = node.parent();\n      T tmp = (*this)[node];\n      if(tmp.first>ret.first) ret = tmp;\n    }\n    return ret.second;\n  }\n\n  SegTree(int n_, T default_value) : default_value(default_value) {\n    // n_: 配列サイズ\n    // default_value: 配列の初期値\n    init(n_, default_value);\n  }\nprotected:\n  // 根を取得\n  Interval root() const { return {0, 0, n}; }\n  // 配列の i 番目の要素に対応する葉ノードを得る (範囲の大きさは1)\n  Interval get_node(int i) const { return {i+n-1, i, i+1}; }\n  // 範囲に対応する値への参照を返す\n  T& operator[](const Interval &lr) { return dat[lr.node_id]; }\n  // 木ノードの移動関連 (通常は Interval クラスを使えば十分なので使わない)\n  inline int parent(int node) const { return (node-1)/2; }\n  inline int left_child(int node) const { return 2*node+1; }  // おアノード\n  inline int right_child(int node) const { return 2*node+2; }\n  inline int is_root(int node) const { return node<=0; }\n\n  // 木の初期化\n  void init(int n_, T default_value){\n    int n=1; while(n<n_) n*=2; dat.resize(2*n-1, default_value); this->n = n;\n  }\n};\n// \n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(false);    // Magic for faster cin\n  int n, q; cin>>n>>q;\n  int c, x, y, z;\n  int t = 0;\n  SegTree rsq(n, {-1,numeric_limits<int>::max()});\n  rep(i,q){\n    cin >> c;\n    if(c==0){\n      cin >> x >> y >> z;      \n      pair<int,int> Z = {t++, z};\n      rsq.update(x,y+1,Z);\n    } else {\n      cin >> x;\n      cout << rsq.query(x) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, double> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nclass LazySegTree {\npublic:\n\tint n;\n\tvector<ll> dat;\n\tvector<ll> lazy;\n\tvector<int> depth;\n\tvector<int> width;\n\tconst int NIL = -INF;\n\n\tll def = INT32_MAX;\n\tll operation(int a, int b) {\n\t\treturn min(a, b);\n\t}\n\n\t// ????????????_n????????????????´???°???\n\tLazySegTree(int _n) {\n\t\tn = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, def);\n\t\tlazy = vector<ll>(2 * n - 1, NIL);\n\t\tdepth = vector<int>(2 * n - 1);\n\t\twidth = vector<int>(2 * n - 1);\n\t\tdepth[0] = 0;\n\t\twidth[0] = n;\n\t\trepl(i, 1, 2 * n - 1) {\n\t\t\tdepth[i] = depth[(i - 1) / 2] + 1;\n\t\t\twidth[i] = width[(i - 1) / 2] / 2;\n\t\t}\n\t}\n\n\t// ????????????????????????k???Lazy???v????????????\n\tvoid setLazy(int k, int v) {\n\t\t//cout << k << \", \" << v << endl;\n\t\t// ???????????¶???\n\t\tlazy[k] = v;\n\t\t// ??????\n\t\t//lazy[k] += v;\n\n\t\t// min,max?????´???\n\t\tdat[k] = v;\n\n\t\t// sum?????´???\n\t\t//dat[k] = lazy[k] * width[k];\n\t}\n\n\tvoid push(int k) {\n\t\t//cout << \"push: \" << k << endl;\n\t\tif (lazy[k] == NIL)return;\n\t\tsetLazy(k * 2 + 1, lazy[k]);\n\t\tsetLazy(k * 2 + 2, lazy[k]);\n\t\tlazy[k] = NIL;\n\t}\n\n\t// ??????[a,b)???v??§???????????¶???\n\tvoid fill(int a, int b, int v, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\t//cout << k << \", \" << a << \", \" << b << \", \" << l << \", \" << r << endl;\n\t\tif (r <= a || b <= l)return;  // ???????????????\n\t\tif (a <= l && r <= b) {   // a,l,r,b????????§?????¨???????????????\n\t\t\tsetLazy(k, v);\n\t\t\treturn;\n\t\t}\n\n\t\tpush(k);\n\n\t\tfill(a, b, v, 2 * k + 1, l, (l + r) / 2);    // ?????????\n\t\tfill(a, b, v, 2 * k + 2, (l + r) / 2, r);    // ?????????\n\t}\n\n\t// ??´???i(0-indexed)???x????¶????\n\tvoid add(int i, ll x) {\n\t\ti += n - 1;\n\t\tdat[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// ??´???i(0-indexed)?????????x?????´??°\n\tvoid change(int i, ll x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = operation(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// ??????[a,b)?????????????????????k=[l,r)????????????????????????\n\tll _query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return def;  // ???????????????\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,b????????§?????¨???????????????\n\n\t\tpush(k);\n\n\t\tll c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2);    // ?????????\n\t\tll c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r);    // ?????????\n\t\treturn operation(c1, c2);\n\t}\n\n\t// ?????¨?????¨???_query()???????????????\n\tll query(int a, int b) {\n\t\treturn _query(a, b, 0, 0, n);\n\t}\n\n\tll operator[](int i) {\n\t\t//return dat[i + n - 1];\n\t\treturn query(i, i + 1);\n\t}\n};\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\tLazySegTree seg(N+1);\n\trep(q, Q) {\n\t\tint c;\n\t\tcin >> c;\n\t\tif (c == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.fill(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << seg.query(i, i + 1) << endl;\n\t\t}\n\t\t/*\n\t\trep(i, N) {\n\t\t\tcout << seg[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n/*\n??????URL???https://pekempey.github.io/lazy_propagation_segment_tree/lazy_propagation_segment_tree.html\n*/\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <climits>\n#include <set>\n\n//#define int long long\ntypedef long long ll;\n//using ll = long long;\n//using R = double;\n\n//#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,bg,ed) for(ll i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\n#define MOD 1000000007\n\nconst int INF = int(1e9);\n\nusing namespace std;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\n\n\n// ???????????????1??¨?????????????????§???\n// ????????????k*2\n// ????????????k*2+1\n// ??????floor(k/2)\n// ??¨?????????\n// ???????????????1??¨????????¨????????°?????????????????????????????°?????§??????????????????????????????????????????\n// ?????°?????????????????§????????°???????????§??????????????????\n\nconst int N = 1 << 17;  // ???????????°\n//const int NIL = INT_MAX;\nconst ll NIL = 1e18;\n\nll maxi[N * 2]; // ?????????k?????????????????????????????§???\nll lazy[N * 2]; // lazy[k]????????????k???????????¨??????lazy[k]??§???????????¶?????¨?????????????????¨??????lazy[k]=NIL?????¨???????????????????????¨?´??????????\n\nvoid setLazy(int k, int v) {\n    lazy[k] = v;\n\n    // ??????????????????????????¨?????? v ??§???????????¶????????????????????????????????¶????????????k????????§??????v??§??????\n    maxi[k] = v;\n\n    // *** ?????? ***\n    // ????????????????????¶?????°???????????¨??§????????£??¨????????????\n    // ?????????O(1)????????¢?????§??¨?????§??????????????????????????????????????§???????????§????????°?????¶?????°???????????¨??§????????§?????????\n    // ?????¨?????°?????????????????¨?????????????????¶???????????????????????????????????°???????????¨??????????????§????????°???\n    //\n    // fill v := v ??§???????????¶???\n    // add v := v ???????????????\n    //\n    // ??¨??????????¨???????????????????????????????????????????\n    // add u ??????????????? fill v ??????????????¨??? (fill v) . (add u) ??¨???????????¨???????????????\n    // ????????¨?????\\????????¢????????????????????????\n    //\n    // (add v) . (add u) = (add v+u)\n    // (add v) . (fill u) = (fill v+u)\n    // (fill v) . (add u) = (fill v)\n    // (fill v) . (fill u) = (fill v)\n    //\n    // ????????????add u ??¨ fill u ????£????????????? (add or fill, Int) ??§??????????????????\n    // ?????£??????????????? add ??§????????? fill ??§???????????¨????????????????????±??¨?????????/???????????¶????????? 2 ???????????±????????£?????¨?????§?????????\n    // ?????°??????????????????????????????????????????????????????????????????????????¨???????????¨???????????????????????????????????????\n    //\n    // ?????¶?????°???????????¨??????????????????????????????????????????????????¨????????????\n    // ??????????????¶?????¬?????°???????????¨????????§???????????¨????????????\n    // ??????????????????????????????????????±???????????????????????????\n    //\n    // ????§£??????????????????????????????????????????????????????????????¶???????????¶?????¬????????????????????¨??????????????§????????????\n    // ???????????¶???????????????????????????????????°???\n    //  (timeS, valueS) . (timeT, valueT) = max((timeS, valueS), (timeT, valueT))\n    // ??¨??????????????????????????¢??§?????????\n}\n\nvoid push(int k) {\n    // ?????¶?????????????????????????????°???????????????\n    if (lazy[k] == NIL) {\n        return;\n    }\n    setLazy(k * 2 + 0, lazy[k]);\n    setLazy(k * 2 + 1, lazy[k]);\n\n    // ????????????????????¬??????????????§????????????????????????\n    lazy[k] = NIL;\n}\n\nvoid fix(int k) {\n    // ?????????k?????????????????????????????§?????????????????????????????§????????¨????????????????????§??????????????§???\n    maxi[k] = max(maxi[k * 2], maxi[k * 2 + 1]);\n}\n\n// ??????[queryL,queryR)???val??§???????????¶???\nvoid fill(int queryL, int queryR, int val, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨????????????????????????????????????????????????????????\\?????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return;\n    }\n    // ???????????????????????¨?????????????????¨??????????????????????????¶????????????????????????????????£?????¨??°???\n    if (queryL <= nodeL && nodeR <= queryR) {\n        setLazy(k, val);\n        return;\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    fill(queryL, queryR, val, k * 2 + 0, nodeL, nodeM);\n    fill(queryL, queryR, val, k * 2 + 1, nodeM, nodeR);\n\n    // ???????????????????????¨??????????????±???fix??????\n    fix(k);\n}\n\n// ??????[queryL, queryR)????????§???????±???????\nll maximum(int queryL, int queryR, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨???????????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return -(1e18);\n    }\n    // ???????????????????????¨?????????????????¨???????????????\n    if (queryL <= nodeL && nodeR <= queryR) {\n        return maxi[k];\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    ll vl = maximum(queryL, queryR, k * 2 + 0, nodeL, nodeM);\n    ll vr = maximum(queryL, queryR, k * 2 + 1, nodeM, nodeR);\n    return max(vl, vr);\n}\n\n\nint n, q;\nint com, s, t, x;\n\n\nsigned main()\n{\n    cin >> n >> q;\n\n    for (int i=0; i<N*2; i++) {\n        lazy[i] = NIL;\n    }\n\n    fill(0, n, INT_MAX);\n\n    REP(i,q) {\n        cin >> com;\n        if (com == 0) {\n            cin >> s >> t >> x;\n            fill(s, t + 1, x);\n        } else {\n            cin >> s;\n            cout << maximum(s, s + 1) << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e5+10;\n\ntypedef vector<int> vec;\n\nclass RUQ\n{\npublic:\n    vec data;\n    vec lazy;\n    int n;\n\n    RUQ(int _n)\n    {\n        data.resize(4*_n);\n        lazy.resize(4*_n);\n        for(n=1;n<_n;n<<=1);\n        fill(data.begin(),data.end(),(1LL<<31)-1);\n        fill(lazy.begin(),lazy.end(),-1);\n    }\n\n    void Down(int p,int l,int r)\n    {\n        if(lazy[p]==-1) return;\n        if(l+1>=r)\n        {\n            data[p]=lazy[p];\n        }else\n        {\n            lazy[p*2+1]=lazy[p*2+2]=lazy[p];\n        }\n        lazy[p]=-1;\n    }\n\n    void update(int p,int l,int r,int x,int a,int b)\n    {\n        if(a>=r||b<=l) return;\n        if(a<=l&&r<=b)\n        {\n            lazy[p]=x;\n            return;\n        }\n        Down(p,l,r);\n        int mid=(l+r)/2;\n        update(p*2+1,l,mid,x,a,b);\n        update(p*2+2,mid,r,x,a,b);\n    }\n\n    int query(int p,int l,int r,int a,int b)\n    {\n        if(a>=r||b<=l) return -1;\n        Down(p,l,r);\n        if(a<=l&&r<=b) return data[p];\n        int mid=(l+r)/2;\n        if(a<mid)\n        {\n            return query(p*2+1,l,mid,a,b);\n        }else\n        {\n            return query(p*2+2,mid,r,a,b);\n        }\n    }\n};\n\nint main()\n{\n    int n,q;\n\n    while(scanf(\"%d %d\",&n,&q)!=EOF)\n    {\n\n        RUQ ruq(n);\n        while(q--)\n        {\n            int op,a,b,c;\n            scanf(\"%d\",&op);\n            if(op)\n            {\n                scanf(\"%d\",&a);\n                printf(\"%d\\n\",ruq.query(0,0,ruq.n,a,a+1));\n            }else\n            {\n                scanf(\"%d %d %d\",&a,&b,&c);\n                ruq.update(0,0,ruq.n,c,a,b+1);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nstruct LazySegmentTree {\nprivate:\n\tint n;\n\tvector<LL> node, lazy;\npublic:\n\tLazySegmentTree(int sz) {\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnode.resize(2 * n - 1,INF<int>());\n\t\tlazy.resize(2 * n - 1, -1);\n\t}\n\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazy[k] != -1) {\n\t\t\tnode[k] = lazy[k];;\n\t\t\tif (k < n - 1) {\n\t\t\t\tlazy[k * 2 + 1] = lazy[k * 2 + 2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\n\tvoid add(int a, int b, LL x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tadd(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tadd(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = min( node[2 * k + 1] , node[2 * k + 2]);\n\t\t}\n\t}\n\n\tLL getmin(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a) return INF<int>();\n\t\tif (a <= l && r <= b) return node[k];\n\t\tLL vl = getmin(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tLL vr = getmin(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn min(vl ,vr);\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tLazySegmentTree seg(n);\n\tREP(i, q) {\n\t\tint k, s, t, x;\n\t\tcin >> k;\n\t\tif (k == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.add(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tcin >> s;\n\t\t\tcout << seg.getmin(s, s + 1) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\ntemplate<typename OperatorMonoid>\nstruct SegmentTree {\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    const H h;\n    const OperatorMonoid OM0;\n    int sz, height;\n    vector<OperatorMonoid> lazy;\n    SegmentTree(int n, const H h, const OperatorMonoid &OM0)\n        : h(h), OM0(OM0), sz(1), height(0)\n    {\n        while (sz < n) sz <<= 1, height++;\n        lazy.assign(sz * 2, OM0);\n    }\n    inline void propagate(int k) {\n        if (lazy[k] == OM0) return ;\n        lazy[k << 1 | 0] = h(lazy[k << 1 | 0], lazy[k]);\n        lazy[k << 1 | 1] = h(lazy[k << 1 | 1], lazy[k]);\n        lazy[k] = OM0;\n    }\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n    void update(int a, int b, const OperatorMonoid &x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n    }\n    void set(int k, const OperatorMonoid &x) { thrust(k += sz); lazy[k] = x; }\n    OperatorMonoid get(int k) { thrust(k += sz); return lazy[k]; }\n    OperatorMonoid operator[](const int &k) { return get(k); }\n};\n\nconst int INF = numeric_limits<int>::max();\nint main() {\n    int n, q; cin >> n >> q;\n    SegmentTree<int> seg(n, [](int a, int b) { return b; }, INF);\n    while (q--) {\n        int com; cin >> com;\n        if (com == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            seg.update(s, t, x);\n        } else {\n            int i; cin >> i;\n            cout << seg[i] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nstruct RU\n{\n    using t1 = int;\n    using t2 = int;\n    static t2 id2() { return -1; }\n    static t1 op2(const t1 &l, const t2 &r) { return r == id2() ? l : r; }\n    static t2 op3(const t2 &l, const t2 &r) { return r == id2() ? l : r; }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree\n{\n    using T1 = typename M::t1;\n    using T2 = typename M::t2;\n    const int h, n;\n    vector<T1> data;\n    vector<T2> lazy;\n    void push(int node)\n    {\n        if (lazy[node] == M::id2())\n            return;\n        lazy[node << 1] = M::op3(lazy[node << 1], lazy[node]);\n        lazy[(node << 1) | 1] = M::op3(lazy[(node << 1) | 1], lazy[node]);\n        lazy[node] = M::id2();\n    }\n\n  public:\n    lazy_segment_tree(int n_, T1 v1)\n        : h(ceil(log2(n_))), n(1 << h), data(n_, v1), lazy(n << 1, M::id2()) {}\n    lazy_segment_tree(const vector<T1> &data_)\n        : h(ceil(log2(data_.size()))), n(1 << h), data(data_), lazy(n << 1, M::id2()) {}\n    void update(int l, int r, T2 val)\n    {\n        l += n, r += n;\n        for (int i = h; i > 0; i--)\n            push(l >> i), push(r >> i);\n        r++;\n        while (l < r)\n        {\n            if (l & 1)\n                lazy[l] = M::op3(lazy[l], val), l++;\n            if (r & 1)\n                r--, lazy[r] = M::op3(lazy[r], val);\n            l >>= 1;\n            r >>= 1;\n        }\n    }\n    T1 find(int p)\n    {\n        T1 res = data[p];\n        p += n;\n        while (p)\n            res = M::op2(res, lazy[p]), p >>= 1;\n        return res;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    lazy_segment_tree<RU> st(111111, (1LL << 31) - 1);\n    for (int i = 0; i < q; i++)\n    {\n        ll com;\n        cin >> com;\n        if (com)\n        {\n            int idx;\n            cin >> idx;\n            cout << st.find(idx) << endl;\n        }\n        else\n        {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(s, t, x);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename Monoid> constexpr typename Monoid::value_type powm(typename Monoid::value_type a, int b) {\n  Monoid m;\n  typename Monoid::value_type c = m.id();\n  while (b) {\n    if (b & 1) c = m(c, a);\n    b >>= 1;\n    a = m(a, a);\n  }\n  return c;\n}\n\ntemplate<typename LSTTrait> class LazySegTree {\n  using FoldMonoid = typename LSTTrait::FoldMonoid;\n  using ActionMonoid = typename LSTTrait::ActionMonoid;\n  using T = typename FoldMonoid::value_type;\n  using Q = typename ActionMonoid::value_type;\n\n  LSTTrait lstTrait; // apply :: (T, Q) -> T\n  FoldMonoid foldM;\n  ActionMonoid actionM;\n  int size = 1;\n  std::vector<T> tree; // 1-indexed\n  std::vector<Q> lazy; // 1-indexed\n\n  void flush(int i, int l, int r) {\n    tree[i] = lstTrait.apply(tree[i], powm<ActionMonoid>(lazy[i], r - l));\n    if (i < size) {\n      lazy[i * 2] = actionM(lazy[i * 2], lazy[i]);\n      lazy[i * 2 + 1] = actionM(lazy[i * 2 + 1], lazy[i]);\n    }\n    lazy[i] = actionM.id();\n  }\n\npublic:\n  LazySegTree(const int n) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, foldM.id());\n    lazy.assign(size * 2, actionM.id());\n  }\n\n  // [l, r)\n  void act(int l, int r, const Q x) { act(l, r, x, 1, 0, size); }\n  void act(const int l, const int r, const Q x, int i, int a, int b) {\n    flush(i, a, b);\n    if (b <= l || r <= a) return;\n    if (l <= a && b <= r) {\n      lazy[i] = actionM(lazy[i], x);\n      flush(i, a, b);\n      return;\n    }\n    act(l, r, x, i * 2, a, (a + b) / 2);\n    act(l, r, x, i * 2 + 1, (a + b) / 2, b);\n    tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  // [l, r)\n  T fold(int l, int r) { return fold(l, r, 1, 0, size); }\n  T fold(int l, int r, int i, int a, int b) {\n    flush(i, a, b);\n    if (b <= l || r <= a) return foldM.id();\n    if (l <= a && b <= r) return tree[i];\n    T lhs = fold(l, r, i * 2, a, (a + b) / 2);\n    T rhs = fold(l, r, i * 2 + 1, (a + b) / 2, b);\n    tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n    return foldM(lhs, rhs);\n  }\n};\n\ntemplate<typename T, T upperInf = std::numeric_limits<T>::max()> struct minMonoid {\n  using value_type = T;\n  constexpr value_type id() { return upperInf; }\n  constexpr value_type operator()(const value_type &a, const value_type &b) { return a < b ? a : b; }\n};\n\ntemplate<typename T> struct updateMonoid {\n  using value_type = pair<bool, T>;\n  constexpr value_type id() { return {false, T()}; }\n  constexpr value_type operator()(const value_type &a, const value_type &b) { return b.first ? b : a; }\n};\n\ntemplate<typename T, T upperInf = std::numeric_limits<T>::max()> struct RMQ_RUQ_Trait {\n  using FoldMonoid = minMonoid<T, upperInf>;\n  using ActionMonoid = updateMonoid<T>;\n  typename FoldMonoid::value_type apply(typename FoldMonoid::value_type t, typename ActionMonoid::value_type q) { return q.first ? q.second : t; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  LazySegTree<RMQ_RUQ_Trait<int, 2147483647>> lst(n);\n  while (q--) {\n    int a;\n    cin >> a;\n    if (a) {\n      int i;\n      cin >> i;\n      cout << lst.fold(i, i + 1) << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      lst.act(s, t + 1, {true, x});\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        if(Tree[level].size() == 1)\n            return;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][iter]);\n            iter++;\n        }\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        if(n == UNDEF){\n            if(level == Tree.size() - 1){\n                DownValue(level, key);\n                return UNDEF;\n            }\n            else{\n                UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n                DownValue(level, key);\n                return UNDEF;\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        \n        if(level < Tree.size() - 1)\n            UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n        DownValue(level, key, before);\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    void DownValue(int level, int key){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            Tree[level - 1][2 * key].value = tmp;\n            if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        \n        if((Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF) || level == 0)\n            return Tree[level][0].value;\n        \n        if(target <= Tree[level - 1][0].high)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= Tree[level - 1][2 * key].high || 2 * key + 1 > Tree[level - 1].size() - 1)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define PACK 300\nint x[400], y[100000], n, q;\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < 400; i++)x[i] = 2147483647;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a, b, c, d; cin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> b >> c >> d; c++;\n\t\t\tint L1 = ((b + PACK - 1) / PACK), R1 = L1*PACK;\n\t\t\tint L2 = c / PACK, R2 = L2*PACK;\n\t\t\tint W1 = 0, W2 = 0;\n\t\t\tfor (int j = L1; j < L2; j++)x[i] = d;\n\t\t\tif (L1 - 1 == L2) {\n\t\t\t\tx[L1] = -1;\n\t\t\t\tfor (int j = b; j <= c; j++)y[j] = d;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b%PACK != 0) {\n\t\t\t\t\tW1 = x[L1 - 1]; x[L1 - 1] = -1;\n\t\t\t\t\tfor (int j = b; j < R1; j++) { y[j] = d; }\n\t\t\t\t\tfor (int j = R1 - PACK; j < b; j++) { y[j] = W1; }\n\t\t\t\t}\n\t\t\t\tif (c%PACK != (PACK - 1)) {\n\t\t\t\t\tW2 = x[L2]; x[L2] = -1;\n\t\t\t\t\tfor (int j = R2; j < c; j++) { y[j] = d; }\n\t\t\t\t\tfor (int j = c; j < R2 + PACK; j++) { y[j] = W2; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> b;\n\t\t\tif (x[b / PACK] != -1)cout << x[b / PACK] << endl;\n\t\t\telse { cout << y[b] << endl; }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n#define SEG_NUM (1<<20)\n\npair<long, long> seg[SEG_NUM*2];\n\nlong find(int i){\n    i += SEG_NUM;\n    long ans = 2147483647;\n    int time = 0;\n    while(i > 0){\n        if(time < seg[i].first) {\n            ans = seg[i].second;\n            time = seg[i].first;\n        }\n        i /= 2;\n    }\n    return ans;\n}\n\nvoid update(int s, int t, long x, long time){\n    s += SEG_NUM;\n    t += SEG_NUM;\n    while(s < t){\n        if(s % 2 == 1){\n            seg[s].first = time;\n            seg[s].second = x;\n            s++;\n        }\n        s /= 2;\n        if(t % 2 == 1){\n            seg[t-1].first = time;\n            seg[t-1].second = x;\n            t--;\n        }\n        t /= 2;\n    }\n}\n\nint main() {\n    for(long i=0;i<2*SEG_NUM;++i){\n        seg[i] = make_pair(0, 2147483647);\n    }\n    int n, q;\n    cin>>n>>q;\n    long query, s, t, x, i;\n    for(int time=0;time<q;++time){\n        cin>>query;\n        if(query){\n            cin>>i;\n            cout<<find(i)<<endl;\n        }\n        else {\n            cin>>s>>t>>x;\n            update(s, t+1, x, time+1);\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int maxn = 0x7fffffff;\nconst int maxnode = 1 << 19;\nconst int INF = 1000000000;\n\nint y1, y2, x, v;\n\nstruct IntervalTree\n{\n    int sumv[maxnode], setv[maxnode];\n\n    // 维护信息\n    void maintain(int o, int L, int R)\n    {\n        int lc = o * 2, rc = o * 2 + 1;\n        if(R > L)\n        {\n            sumv[o] = sumv[lc] + sumv[rc];\n        }\n        if(setv[o] >= 0)\n        {\n            sumv[o] = setv[o] * (R - L + 1);\n        }\n    }\n\n    // 标记传递\n    void pushdown(int o)\n    {\n        int lc = o * 2, rc = o * 2 + 1;\n        if(setv[o] >= 0)\n        {\n            setv[lc] = setv[rc] = setv[o];\n            setv[o] = -1; // 清除本结点标记\n        }\n    }\n\n    void update(int o, int L, int R)\n    {\n        int lc = o * 2, rc = o * 2 + 1;\n        if(y1 <= L && y2 >= R)   // 标记修改\n        {\n            setv[o] = v;\n        }\n        else\n        {\n            pushdown(o);\n            int M = L + (R - L) / 2;\n            if(y1 <= M) update(lc, L, M);\n            else maintain(lc, L, M);\n            if(y2 > M) update(rc, M + 1, R);\n            else maintain(rc, M + 1, R);\n        }\n        maintain(o, L, R);\n    }\n\n    void query(int o, int L, int R, int &ssum)\n    {\n        int lc = o * 2, rc = o * 2 + 1;\n        maintain(o, L, R); // 处理被pushdown下来的标记\n        if(y1 <= L && y2 >= R)\n        {\n            ssum = sumv[o];\n        }\n        else\n        {\n            pushdown(o);\n            int M = L + (R - L) / 2;\n            int lsum = 0;\n            int rsum = 0;\n            if(y1 <= M) query(lc, L, M, lsum);\n            else maintain(lc, L, M);\n            if(y2 > M) query(rc, M + 1, R, rsum);\n            else maintain(rc, M + 1, R);\n            ssum = lsum + rsum;\n        }\n    }\n};\n/*\n3 5\n0 0 1 1\n0 1 2 3\n0 2 2 2\n1 0\n1 1\n*/\nint n, q;\nIntervalTree tree;\n\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\ttree.setv[1] = maxn;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tif (!op)\n\t\t{\n\t\t\tscanf(\"%d %d %d\", &y1, &y2, &v);\n\t\t\t++y1;\n\t\t\t++y2;\n\t\t\ttree.update(1, 1, n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint loc;\n\t\t\tscanf(\"%d\", &loc);\n\t\t\t++loc;\n\t\t\ty1 = y2 = loc;\n\t\t\tint gsum = 0;\n            int ssum;\n            tree.query(1, 1, n, ssum);\n            gsum += ssum;\n            printf(\"%d\\n\", gsum);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma region macros_and_aliases\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define foa(s, v) for(auto &s : v)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vb = vector<bool>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing qll = queue<long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n#define debug(var)              \\\n\tstd::cout << #var << \" : \"; \\\n\tview(var)\ntemplate <typename T>\nvoid view(T e) {\n\tstd::cout << e << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<T> &v) {\n\tfor(const auto &e : v) {\n\t\tstd::cout << e << \" \";\n\t}\n\tstd::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv) {\n\tfor(const auto &v : vv) {\n\t\tview(v);\n\t}\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\n#pragma endregion\n\ntemplate <class T = long long, class U = long long>\nclass LazyST {\n   private:\n\tint n;\n\tint height = -1;\t   //木の高さ\n\tvector<T> data;\t\t   // monoid\n\tvector<U> lazy;\t\t   // operator\n\tT unit_data;\t\t   // monoid単位元\n\tU unit_lazy;\t\t   // operator単位元\n\tfunction<T(T, T)> f1;  // monoid同士の演算\n\tfunction<T(T, U)> f2;  // monoidとoperatorとの演算\n\tfunction<U(U, U)> f3;  // operator同士の演算\n\tvoid propagate(int lef, int rig) {\n\t\t// 遅延させていた作用素を上から伝播させる [lef,rig)に有効な範囲で\n\t\tlef += n;\n\t\trig += n - 1;  //閉区間にする\n\t\tfor(int i = height; i > 0; i--) {\n\t\t\tint l = lef >> i;\n\t\t\tint r = rig >> i;\n\t\t\tlazy[l << 1] = f3(lazy[l << 1], lazy[l]);\n\t\t\tlazy[l << 1 | 1] = f3(lazy[l << 1 | 1], lazy[l]);\n\t\t\tdata[l] = f2(data[l], lazy[l]);\n\t\t\tlazy[l] = unit_lazy;\n\t\t\tlazy[r << 1] = f3(lazy[r << 1], lazy[r]);\n\t\t\tlazy[r << 1 | 1] = f3(lazy[r << 1 | 1], lazy[r]);\n\t\t\tdata[r] = f2(data[r], lazy[r]);\n\t\t\tlazy[r] = unit_lazy;\n\t\t}\n\t}\n\n   public:\n\tLazyST(int _n, function<T(T, T)> ope_data_data, function<T(T, U)> ope_data_lazy, function<U(U, U)> ope_lazy_lazy, T _unit_data,\n\t\t   U _unit_lazy)\n\t\t: n(_n), f1(ope_data_data), f2(ope_data_lazy), f3(ope_lazy_lazy), unit_data(_unit_data), unit_lazy(_unit_lazy) {\n\t\tdata.assign(n * 2, unit_data);\n\t\tlazy.assign(n * 2, unit_lazy);\n\t\tfor(int i = 1; i <= n; i *= 2) height++;\n\t}\n\n\tvoid update(int lef, int rig, U _operator) {  //[lef,rig)にopeを作用させる\n\t\tpropagate(lef, rig);\n\t\tlef += n;\n\t\trig += n;  //半開区間にする 下から上にdataを更新\n\t\tint L0 = lef / (lef & -lef);\n\t\tint R0 = rig / (rig & -rig);\n\t\twhile(lef < rig) {\n\t\t\tif(lef & 1) {\n\t\t\t\tlazy[lef] = f3(lazy[lef], _operator);\n\t\t\t\tdata[lef >> 1] = f1(f2(data[lef], lazy[lef]), f2(data[lef - 1], lazy[lef - 1]));\n\t\t\t\tlazy[lef >> 1] = unit_lazy;\n\t\t\t\tlef++;\n\t\t\t}\n\t\t\tif(rig & 1) {\n\t\t\t\tlazy[rig - 1] = f3(lazy[rig - 1], _operator);\n\t\t\t\tdata[(rig - 1) >> 1] = f1(f2(data[rig - 1], lazy[rig - 1]), f2(data[rig], lazy[rig]));\n\t\t\t\tlazy[(rig - 1) >> 1] = unit_lazy;\n\t\t\t\trig--;\n\t\t\t}\n\t\t\tlef >>= 1;\n\t\t\trig >>= 1;\n\t\t}\n\t\tlef = L0;\n\t\trig = R0;\n\t\twhile(lef > 1) {\n\t\t\tlef >>= 1;\n\t\t\tdata[lef] = f1(f2(data[lef << 1], lazy[lef << 1]), f2(data[lef << 1 | 1], lazy[lef << 1 | 1]));\n\t\t\tlazy[lef] = unit_lazy;\n\t\t}\n\t\twhile(rig > 1) {\n\t\t\trig >>= 1;\n\t\t\tdata[rig] = f1(f2(data[rig << 1], lazy[rig << 1]), f2(data[rig << 1 | 1], lazy[rig << 1 | 1]));\n\t\t\tlazy[rig] = unit_lazy;\n\t\t}\n\t}\n\n\tvoid update(int idx, T x) {\t //点更新\n\t\tidx += n;\n\t\tdata[idx] = x;\n\t\tidx >>= 1;\n\t\twhile(idx > 0) {\n\t\t\tdata[idx] = f1(data[(idx << 1)], data[(idx << 1) | 1]);\n\t\t\tidx >>= 1;\n\t\t}\n\t}\n\n\tT get(int lef, int rig) {  //区間の値取得\n\t\tpropagate(lef, rig);\n\t\tT a = unit_data, b = unit_data;\n\t\tlef += n;\n\t\trig += n;\n\t\twhile(lef < rig) {\n\t\t\tif(lef & 1) a = f1(a, f3(data[lef], lazy[lef]));\n\t\t\tif(rig & 1) b = f1(f3(data[rig - 1], lazy[rig - 1]), b);\n\t\t\t(lef += 1) >>= 1;\n\t\t\trig >>= 1;\n\t\t}\n\t\treturn f1(a, b);\n\t}\n};\n\nint main() {\n\tll rep_unit = -1;\n\tauto replace = [](ll a, ll b) { return b == -1 ? a : b; };\n\tauto mini = [](ll a, ll b) { return min(a, b); };\n\tauto maxi = [](ll a, ll b) { return max(a, b); };\n\tauto pairadd = [](pll a, pll b) { return (pll){a.first + b.first, a.second + b.second}; };\n\n\tll n, q;\n\tcin >> n >> q;\n\tLazyST<> st(n, mini, replace, replace, (1LL << 31) - 1, rep_unit);\n\tvll ans;\n\trep(i, q) {\n\t\tint sort;\n\t\tcin >> sort;\n\t\tif(sort) {\n\t\t\tll s;\n\t\t\tcin >> s;\n\t\t\tll k = st.get(s, s + 1);\n\t\t\tans.push_back(k);\n\t\t} else {\n\t\t\tll s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tt++;\n\t\t\tst.update(s, t, x);\n\t\t}\n\t}\n\tfoa(t, ans) cout << t << enld;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nstruct segtree {\n    vector<int> lazy, dat;\n    int n;\n\n    segtree(int n_, int init){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.assign(n*2, init);\n        lazy.assign(n*2, -1);\n    }\n\n    void set(int l, int r, int x){\n        set(l, r, x, 0, n, 1);\n    }\n\n    void set(int l, int r, int x, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segr <= l || r <= segl);\n        else if(l <= segl && segr <= r) lazy[n] = x;\n        else {\n            int segm = (segl + segr) / 2;\n            set(l, r, x, segl, segm, n*2);\n            set(l, r, x, segm, segr, n*2+1);\n        }\n    }\n\n    int get(int k){\n        return get(k, 0, n, 1);\n    }\n\n    int get(int k, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segl + 1 == segr) return dat[n];\n        int segm = (segl + segr) / 2;\n        if(k < segm) return get(k, segl, segm, n*2);\n        else return get(k, segm, segr, n*2+1);\n    }\n\n    void push(int segl, int segr, int node){\n        if(lazy[node] != -1){\n            dat[node] = lazy[node];\n            if(segl + 1 != segr){\n                lazy[node*2] = lazy[node];\n                lazy[node*2+1] = lazy[node];\n            }\n            lazy[node] = -1;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, q;\n    cin >> n >> q;\n    segtree st(n, 2147483647);\n    for(int iq = 0; iq < q; ++iq){\n        int t;\n        cin >> t;\n        // dump(t);\n        if(t == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            st.set(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.get(i) << '\\n';\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nclass SegmentTree\n{\n private:\n    int n;\n    vector<int> node;\n public:\n    SegmentTree(int sz){\n        n=1;\n        while(n<sz) n*=2;\n        node.resize(2*n);\n        for(int i=1;i<n;i++) node[i]=-1;\n        for(int i=n;i<2*n;i++) node[i]=INT_MAX;\n    }\n    void update(int a,int b,int val,int k=1,int l=0,int r=-1){\n        if(r<0) r=n;\n        if(r<=a or b<=l) return;\n        if(a<=l and r<=b){\n            node[k]=val;\n            return;\n        }\n        if(node[k]!=-1){\n            node[2*k]=node[2*k+1]=node[k];\n            node[k]=-1;\n        }\n        update(a,b,val,2*k,l,(l+r)/2);\n        update(a,b,val,2*k+1,(l+r)/2,r);\n    }\n    int get(int idx){\n        idx+=n;\n        int res=node[idx];\n        while(idx>>=1){\n            if(node[idx]!=-1) res=node[idx];\n        }\n        return res;\n    }\n};\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N,Q; cin>>N>>Q;\n    SegmentTree seg(N);\n    while(Q--){\n        int q; cin>>q;\n        if(q==0){\n            int s,t,x; cin>>s>>t>>x;\n            seg.update(s,t+1,x);\n        }else{\n            int i; cin>>i;\n            cout<<seg.get(i)<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntypedef long long ll;\ntemplate <typename F,typename T>\nstruct DST{\n  T identity;\n  F merge;\n  int size;\n  vector<T> dat,delay;\n  \n  DST(F f,T id):merge(f),identity(id){}\n\n  void eval(int k,int l,int r){\n    if(delay[k] != -1){\n      dat[k] = delay[k];\n      if(k<size-1){\n\tdelay[2*k+1] = delay[2*k+2] = delay[k];\n      }\n      delay[k]=-1;\n    }\n  }\n\n  void init(int n){\n    size = 1;\n    while(size<=n) size *= 2;\n    dat.resize(size*2-1,identity);\n    delay.resize(size*2-1,-1);    \n  }\n\n  void build(vector<T> vec){\n    rep(i,vec.size()) dat[size-1+i] = vec[i];\n    dfs(0);\n  }\n\n  T dfs(int k){\n    if(k>=size-1) return dat[k];\n    else return dat[k] = merge(dfs(2*k+1),dfs(2*k+2));\n  }\n\n  void update(int a,int b,T x,int k,int l,int r){\n    eval(k,l,r);\n\n    if(r<=a||b<=l) return ;\n    if(a<=l&&r<=b){\n      delay[k] = x;\n      eval(k,l,r);\n    }\n    else{\n      update(a,b,x,2*k+1,l,(l+r)/2);\n      update(a,b,x,2*k+2,(l+r)/2,r);\n      dat[k] = merge(dat[2*k+1],dat[2*k+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    eval(k,l,r);\n    if(r<=a||b<=l) return identity;\n\n    if(a<=l&&r<=b) return dat[k];\n    else return merge(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r));\n  }\n\n  void all_eval(){\n    rep(i,2*size-1){\n      eval(i,0,0);\n    }\n  }\n\n  T get(int k){ return dat[size-1+k];}\n  \n  void show(){\n    int index = 0;\n    int num = 1;\n    while(index<size){\n      rep(i,num){\n\tif(dat[i+index]==identity) cout << \"e \";\n\telse cout << dat[i+index] << \" \";\n      }\n      cout << \"\\n\";\n      num *= 2;\n      index = index*2+1;\n    }\n    index = 0;\n    num = 1;\n    while(index<size){\n      rep(i,num){\n\tcout << delay[i+index] << \" \";\n      }\n      cout << \"\\n\";\n      num *= 2;\n      index = index*2+1;\n    }\n  }\n  \n\n  \n};\nint main()\n{\n  int n,q;cin >> n >> q;\n  vector<ll> c(q),s(q),t(q),x(q);\n  rep(i,q){\n    cin >> c[i];\n    if(c[i]==0) cin >> s[i] >> t[i] >> x[i];\n    else cin >> x[i];\n  }\n\n  auto f = [&](ll a,ll b){ return min(a,b);};\n  ll id = (1LL<<31)-1;\n  DST<decltype(f),ll> dst(f,id);\n  dst.init(n);\n  rep(i,q){\n    if(c[i]==0) dst.update(s[i],t[i]+1,x[i],0,0,dst.size);\n    else cout << dst.query(x[i],x[i]+1,0,0,dst.size) << \"\\n\";\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    const function<T (T, T)> f;     // 要素に適用する演算\n    const function<T (T, T)> g;     // 作用素の適用\n    const function<T (T, T)> h;     // 作用素の合成\n    const function<T (T, int)> p;\n    const T unit;\n    const T lazy_unit;\n\npublic:\n    class Mode {\n    public:\n        function<T (T, T)> f;\n        function<T (T, T)> g;\n        function<T (T, T)> h;\n        function<T (T, int)> p;\n        T unit;\n        T lazy_unit;\n    };\n\n    enum Query {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum Operation {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, const Mode mode) : array_size(v.size()),  f(mode.f), g(mode.g), h(mode.h), p(mode.p), unit(mode.unit), lazy_unit(mode.lazy_unit){\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, lazy_unit);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    static Mode getMode(const Query query, const Operation operation) {\n        Mode mode;\n        if (query == RangeMinimumQuery) {\n            mode.unit = INT_MAX;\n\n            mode.f = [](T a, T b) { return std::min(a, b); };\n            if (operation == Update) {\n                mode.lazy_unit = -1;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeMaximumQuery) {\n            mode.unit = -INT_MAX;\n\n            mode.f = [](T a, T b) { return std::max(a, b); };\n            if (operation == Update) {\n                mode.lazy_unit = -1;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeSummationQuery) {\n            mode.unit = 0;\n\n            mode.f = [](T a, T b) { return a + b; };\n            if (operation == Update) {\n                mode.lazy_unit = INT_MAX;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b;};\n                mode.h = mode.g;\n                mode.p = [&](T a, int len) {return a == mode.lazy_unit ? a : a * len;};\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b;};\n                mode.h = [](T a, T b) { return a + b;};\n                mode.p = [](T a, int len) {return a * len;};\n            }\n        }\n        return mode;\n    }\n\n    // array[idx]\n    // log(N)\n    T access(const int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] += x\n    // log(N)\n    void update(const int idx, const T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) += x\n    // log(N)\n    void update(const int left, const int right, const T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(const int left, const int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(const int a, const int b, const T x, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(const int a, const int b, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (lazy[k] == lazy_unit) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazy[k] = lazy_unit;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1 , 2147483647);\n\n    auto mode = LazySegmentTree<LL>::getMode(LazySegmentTree<LL>::Query::RangeMinimumQuery, LazySegmentTree<LL>::Operation::Update);\n    LazySegmentTree<LL> lst(v, mode);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> i;\n            print(lst.access(i));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<climits>\n#include<math.h>\nusing namespace std;\n\nint min(const int& a, const int& b){\n    return a < b? a : b;\n}\nint updateUtil(vector<int>& tree, vector<int>& lazy, const int& L, const int& R, const int& v, const int& k, const int& l, const int& r){\n    if(k > tree.size() || l > r) return INT_MAX;\n    if(lazy[k] >= 0){\n        tree[k] = lazy[k];\n        if(l < r){\n            lazy[2*k+1] = lazy[k];\n            lazy[2*k+2] = lazy[k];\n        }\n        lazy[k] = -1;\n    }\n    if(l > R || r < L) return tree[k];\n    if(l >= L && r <= R){\n        tree[k] = v;\n        if(l < r){\n            lazy[2*k+1] = v;\n            lazy[2*k+2] = v;\n        }\n    }\n    else{\n        int mid = l+(r-l)/2;\n        tree[k] = min(updateUtil(tree, lazy, L, R, v, 2*k+1, l, mid), updateUtil(tree, lazy, L, R, v, 2*k+2, mid+1, r)); \n    }\n    return tree[k];\n}\n\nvoid update(vector<int>& tree, vector<int>& lazy, const int& n, const int& L, const int& R, const int& v){\n    updateUtil(tree, lazy, L, R, v, 0, 0, n-1);\n}\n\nint findUtil(vector<int>& tree, vector<int>& lazy, const int& L, const int& R, const int& k, const int& l, const int& r){\n    if(k > tree.size() || l > r) return INT_MAX;\n    if(lazy[k] >= 0){\n        tree[k] = lazy[k];\n        if(l < r){\n            lazy[2*k+1] = lazy[k];\n            lazy[2*k+2] = lazy[k];\n        }\n        lazy[k] = -1;\n    }\n    if(l > R || r < L) return INT_MAX;\n    if(l >= L && r <= R) return tree[k];\n    int mid = l+(r-l)/2;\n    return min(findUtil(tree, lazy, L, R, 2*k+1, l, mid), findUtil(tree, lazy, L, R, 2*k+2, mid+1, r));\n}\n\nint find(vector<int>& tree, vector<int>& lazy, const int& n, const int& L, const int& R){\n    return findUtil(tree, lazy, L, R, 0, 0, n-1);\n}\nint main(){\n    int n, q, com, s, t, x;\n    scanf(\"%d %d\", &n, &q);\n    int h = (int)ceil(log2(n));\n    int max_size = 2*(int)pow(2, h)-1;\n    vector<int> tree(max_size, INT_MAX);\n    vector<int> lazy(max_size, -1);\n    for(int i = 0; i < q; i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update(tree, lazy, n, s, t, x);\n        }\n        else if(com == 1){\n            scanf(\"%d\", &s);\n            printf(\"%d\\n\", find(tree, lazy, n, s, s));\n        }\n        else printf(\"undefined com\\n\");\n    }    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \n#define INF 2147483647\n#define ASTART (1<<17)\nint a[1<<18][2];\nint ti=1;\n \nint find(int i){\n  int nv=INF,t=0;\n  i+=ASTART-1;\n  nv=a[i][0];\n  t=a[i][1];\n  while (i>0){\n    i=(i-1)/2;\n    if (t<a[i][1])nv=a[i][0],t=a[i][1];\n    //cout << i << \" = \" << a[i][0]<< \" = \" << a[i][1]<< endl;\n  }\n  return nv;\n}\nvoid update(int s,int t,int x,int k,int l,int r){\n  if (l>=s&&r<t){\n    a[k][0]=x;\n    a[k][1]=ti;\n    return;\n  }\n  if (r<=s||l>=t)return;\n  int m=(l+r)/2;\n  update(s,t,x,k*2+1,l,m);\n  update(s,t,x,k*2+2,m,r);\n}\nint main(){\n  int n,q,com,s,t,x;\n  for (int i=0;i<(1<<18);i++)a[i][0]=INF,a[i][1]=0;\n  cin >> n>>q;\n \n  for (int i=0;i<q;i++){\n    cin >> com;\n    if (com==0) {\n      cin >> s >> t >> x;\n      update(s,t+1,x,0,0,ASTART);\n      ti++;\n    }else {\n      cin >> s;\n      cout << find(s)<< endl;\n    }\n    //for (int i=0;i<5;i++)cout << a[i] << endl;\n    //cout << a[ASTART];\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n// RAQ RUQ and RSQ\n// varify : https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_G\n// varify : https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_I\ntemplate<typename Monoid>\nstruct LazySegmentTree {\nprivate:\n    using Func = std::function<Monoid(Monoid, Monoid)>;\n    Func F = [](Monoid a, Monoid b) { return a + b; };\n    Monoid UNITY = 0;\n    int n;\n    std::vector<Monoid> node, lazy;\n    std::vector<int> prop; // 何を伝播させるか 1:add 2:update\n\n    // propagation\n    void eval(int k, int l, int r) {\n        if (prop[k] != 0) {\n            node[k] = lazy[k] + (prop[k] == 1 ? node[k] : 0);\n            if (r - l > 1) {\n                lazy[2 * k + 1] = lazy[k] / 2 + (prop[k] == 1 ? lazy[2 * k + 1] : 0);\n                lazy[2 * k + 2] = lazy[k] / 2 + (prop[k] == 1 ? lazy[2 * k + 2] : 0);\n                prop[2 * k + 1] = prop[2 * k + 2] = prop[k];\n            }\n            lazy[k] = 0;\n            prop[k] = 0;\n        }\n    }\npublic:\n    LazySegmentTree(int m, Monoid val = LazySegmentTree::UNITY) {\n        n = 1; while (n < m) n <<= 1;\n        node.resize(n * 2 - 1, val);\n        lazy.resize(n * 2 - 1, 0);\n        prop.resize(n * 2 - 1, 0);\n    }\n\n    LazySegmentTree(const std::vector<Monoid>& v) {\n        int sz = v.size();\n        n = 1; while (n < sz) n <<= 1;\n        node.resize(n * 2 - 1, UNITY);\n        lazy.resize(n * 2 - 1, 0);\n        prop.resize(n * 2 - 1, 0);\n        for (int i = 0; i < sz; i++) node[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    // 最後に build が必要\n    void set(int k, const Monoid &x) {\n        node[n + k - 1] = x;\n    }\n\n    void build() {\n        for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    // [a,b) add\n    void add_query(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n\n        // out of range\n        if (b <= l || r <= a) return;\n\n        if (a <= l && r <= b) {\n            prop[k] = 1;\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add_query(a, b, x, 2 * k + 1, l, (r - l) / 2 + l);\n            add_query(a, b, x, 2 * k + 2, (r - l) / 2 + l, r);\n            node[k] = F(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    // [a,b) update\n    void update_query(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n\n        // out of range\n        if (b <= l || r <= a) return;\n\n        if (a <= l && r <= b) {\n            prop[k] = 2;\n            lazy[k] = (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            update_query(a, b, x, 2 * k + 1, l, (r - l) / 2 + l);\n            update_query(a, b, x, 2 * k + 2, (r - l) / 2 + l, r);\n            node[k] = F(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    // [a,b) sum\n    Monoid get_query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return UNITY;\n        eval(k, l, r);\n        if (a <= l && r <= b) return node[k];\n        Monoid vl = get_query(a, b, 2 * k + 1, l, (r - l) / 2 + l);\n        Monoid vr = get_query(a, b, 2 * k + 2, (r - l) / 2 + l, r);\n        return F(vl, vr);\n    }\n\n    Monoid operator[](int x) {\n        return get_query(x, x + 1);\n    }\n\n    void print() {\n        for (int i = 0; i < n; i++) {\n            std::cout << i << \"\\t: \" << get_query(i, i + 1) << std::endl;\n        }\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    LazySegmentTree<ll> seg(n, INT_MAX);\n    for (int _ = 0; _ < q; _++) {\n        int p; cin >> p;\n        if (p == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            seg.update_query(s, t + 1, x);\n        }\n        else {\n            int i; cin >> i;\n            cout << seg[i] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n// ================================================= //\n\n/*\n update : [s,t) を x に変更\n query :  [s,t) の最小(大)値を出力\n */\nconst ll INIT = INT_MAX;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    \n    SegTree(int _N):init_v(INIT) {\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, -1);\n    }\n    \n    void lazy_evaluate(int k) {\n        if (lazy[k] == -1) return;\n        node[k] = lazy[k];\n        if (k < N - 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        lazy[k] = -1;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    void update(int a, int b, int x) { update(a, b, 0, 0, N, x); }\n    void update(int a, int b, int k, int l, int r, int x) {\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            lazy_evaluate(k);\n        }\n        else {\n            lazy_evaluate(k);\n            update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) {\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n};\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n,q; cin >> n >> q;\n    \n    SegTree ST(n);\n//    BIT bit(n);\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int s,t,x; cin >> s >> t >> x;\n            ST.update(s,t+1,x);\n//            ST.update(x,y);\n           // bit.add(x,y);\n        }else{\n            int i; cin >> i;\n            cout << ST.query(i,i+1) << endl;\n            //cout << ST.query(x-1,y) << endl;\n            //cout << bit.sum(y) - bit.sum(x-1) << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\ntemplate<typename Type>\nstruct SqrtDecomp {\n    int SIZE;\n    // node の前半には op2 を適用した値が入っているはずで、\n    // 後半には op1 を適用した値が入っているはず\n\n    // lazy は一様更新 → op1 を適用した値が入っているはず\n    vector<Type> node, bucket, lazy, need_upd;\n    Type (*op1) (Type x, Type y, int sz);\n    Type (*op2) (Type x, Type y);\n    Type I;\n\n    SqrtDecomp( vector<Type> vec,\n                Type (*g_op1) (Type x, Type y, int sz),\n                Type (*g_op2) (Type x, Type y),\n                Type X) {\n        int N = vec.size();\n        SIZE = 1; while(SIZE * SIZE < N) SIZE++;\n        I = X, op1 = g_op1, op2 = g_op2;\n\n        node.resize(SIZE*SIZE, I);\n        bucket.resize(SIZE, I);\n        lazy.resize(SIZE, I);\n        need_upd.resize(SIZE, 0);\n\n        for(int i=0; i<SIZE; i++) {\n            Type rep_val = I;\n            for(int j=0; j<SIZE && i*SIZE+j<N; j++) {\n                int idx = (i*SIZE + j);\n                node[idx] = vec[idx];\n                rep_val = op2(rep_val, node[idx]);\n            }\n            bucket[i] = rep_val;\n        }\n    }\n\n    void lazy_eval(int k) {\n        int l = SIZE*k, r = SIZE*(k+1);\n        // printf(\"lazy_eval: %d, lazy[k] = %d, l =  %d, r = %d\\n\", k, lazy[k], l, r);\n        if(need_upd[k]) {\n            Type seg_val = I;\n\n            // 該当する下のノードをまず更新\n            for(int i=l; i<r; i++) {\n                node[i] = op1(node[i], lazy[k], 1);\n                seg_val = op2(seg_val, node[i]);\n            }\n\n            // 上のノードを更新\n            bucket[k] = seg_val;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    void update(int l, int r, Type val) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // 左端の更新\n        lazy_eval(lidx);\n        bucket[lidx] = I;\n        for(int k=SIZE*lidx; k<SIZE*(lidx+1); k++) {\n            if(l <= k && k < r) node[k] = op1(node[k], val, 1);\n            bucket[lidx] = op2(bucket[lidx], node[k]);\n        }\n\n        if(lidx != ridx) {\n            // 真ん中 (lazy を更新)\n            for(int k=lidx+1; k<ridx; k++) {\n                lazy[k] = op1(lazy[k], val, 1);\n                need_upd[k] = true;\n            }\n\n            if(ridx != SIZE) {\n                lazy_eval(ridx);\n                bucket[ridx] = I;\n\n                // 右端の更新\n                for(int k=SIZE*ridx; k<SIZE*(ridx+1); k++) {\n                    if(k < r) node[k] = op1(node[k], val, 1);\n                    bucket[ridx] = op2(bucket[ridx], node[k]);\n                }\n            }\n        }\n    }\n\n    Type query(int l, int r) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // printf(\"lidx = %d, ridx = %d\\n\", lidx, ridx);\n        Type ret = I;\n        \n        // 左端の取得\n        for(int k=l; k<min(r, SIZE*(lidx+1)); k++) {\n            lazy_eval(lidx);\n            ret = op2(ret, node[k]);\n        }\n\n        if(lidx != ridx) {\n            for(int k=lidx+1; k<ridx; k++) {\n                // 全体の値と lazy の値を考慮して値を計算\n                Type val = (need_upd[k] ? op1(bucket[k], lazy[k], SIZE) : bucket[k]);\n                ret = op2(ret, val);\n            }\n\n            for(int k=SIZE*ridx; k<r; k++) {\n                lazy_eval(ridx);\n                ret = op2(ret, node[k]);\n            }\n        }\n\n        return ret;\n    }\n\n    void print_debug() {\n        printf(\"<< node >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %d\\n\", l, r, bucket[i]);\n        }\n        printf(\"lower bucket:\\n\");\n        for(int i=0; i<SIZE*SIZE; i++) {\n            printf(\"[%6d, %6d) -> %d\\n\", i, i+1, node[i]);\n        }\n\n        printf(\"<< lazy >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %d\\n\", l, r, lazy[i]);\n        }\n        printf(\"\\n\");\n    }\n};\n\n/*\n// Range Minimum Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a, a+1, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a, b+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// Range Sum Query\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a-1, a, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a-1, b));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n// Range Update Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int x; scanf(\"%d\", &x);\n            printf(\"%d\\n\", sqr.query(x, x+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n\n/*\n// Range Add Query\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l-1, r, x);\n        }\n        if(query == 1) {\n            int x; scanf(\"%d\", &x);\n            printf(\"%d\\n\", sqr.query(x-1, x));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// RAQ and RUQ\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            printf(\"%d\\n\", sqr.query(l, r+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// RSQ and RAQ\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l-1, r, x);\n        }\n        if(query == 1) {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            printf(\"%d\\n\", sqr.query(l-1, r));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// RMQ and RAQ\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return min(a ,b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            printf(\"%d\\n\", sqr.query(l, r+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n// Debug\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\nusing LL = int64_t;\nconst int64_t MOD = 1e9+7;\ntemplate<typename OM>\nstruct DualSegmentTree {\n    int sz;\n    vector<OM> lazy;\n    const function<OM(OM,OM)> h;\n    const OM oe;\n    // h: 作用素をマージする関数\n    // oe: 作用素の単位元\n    DualSegmentTree(\n            int n,\n            const function<OM(OM,OM)>& h,\n            const OM& oe\n            ) : h(h), oe(oe) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        lazy.assign(2*sz, oe);\n    }\n    void set(int i, const OM& x) {\n        lazy.at(i + sz) = x;\n    }\n    OM merge(const OM& a, const OM& b) {\n        if (a == oe) return b;\n        if (b == oe) return a;\n        return h(a, b);\n    }\n    void propagate(int k, int len) {\n        if (lazy[k] == oe) return;\n        if (k < sz) {\n            lazy[2*k ] = merge(lazy[2*k ], lazy[k]);\n            lazy[2*k+1] = merge(lazy[2*k+1], lazy[k]);\n            lazy[k] = oe;\n        }\n    }\n    void _update(int a, int b, const OM& x, int k, int l, int r) {\n        propagate(k, r - l);\n        if (r <= a or b <= l) return;\n        else if (a <= l and r <= b) {\n            lazy[k] = merge(lazy[k], x);\n            propagate(k, r - l);\n        } else {\n            _update(a, b, x, 2*k, l, (l+r)/2);\n            _update(a, b, x, 2*k+1, (l+r)/2, r);\n        }\n    }\n    void update(int a, int b, const OM& x) {\n        // update [a, b) with x.\n        _update(a, b, x, 1, 0, sz);\n    }\n    OM _query(int i, int k, int l, int r) {\n        if (l+1 == r) return lazy[l + sz];\n        propagate(k, r - l);\n        int m = (l+r)/2;\n        if (i < m) return _query(i, 2*k, l, m);\n        else return _query(i, 2*k+1, m, r);\n    }\n    OM operator[](int i) {\n        return _query(i, 1, 0, sz);\n    }\n};\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    DualSegmentTree<int> ruq(\n            N,\n            [](int64_t a, int64_t b){ return b; },\n            numeric_limits<int>::max()\n            );\n    while (Q--) {\n        int C; cin >> C;\n        if (C == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            ruq.update(s, t+1, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << ruq[i] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\nconst int INF = (1LL << 31) - 1;\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<bool> lazyFlag;\n  vector<int> lazyUpdate;\n  SqrtDecomposition(int n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, INF);\n    lazyFlag.assign(K, false);\n    lazyUpdate.assign(K, 0);\n  }\n  void eval(int k) {\n    if (lazyFlag[k]) {\n      lazyFlag[k] = false;\n      for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n    }\n  }\n  // [s, t)\n  void update(int s, int t, int x) {\n       int p = max(0, s / sqrtN - 1);\n        int q = min(K, t / sqrtN + 1);\n    for (int k = p; k < q; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        lazyFlag[k] = true;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n  int find(int i) {\n    int k = i / sqrtN;\n    eval(k);\n    return data[i];\n  }\n};\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  int N, Q;\n  cin >> N >> Q;\n  SqrtDecomposition decomp(N);\n  while (Q--) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      decomp.update(s, t + 1, x);\n    } else {\n      int i;\n      cin >> i;\n      cout << decomp.find(i) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\n/*\nop(operation):二項演算\nhomo(homomorphic):Monoidに作用させる準同型写像\ncomp(compose):homoをマージする\n\n頻出系\n区間update\nhomo:代入\ncomp:代入\n\n代入:auto in = [](int a,int b){return b!=e? a:b;};\n\n*/\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n\tusing F = function<Monoid(Monoid,Monoid)>;\n\tusing G = function<Monoid(Monoid,OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid,OperatorMonoid)>;\n\n\tint sz,height;\n\tvec<Monoid> data;\n\tvec<OperatorMonoid> lazy;\n\tconst F op;\n\tconst G homo;\n\tconst H comp;\n  \tconst Monoid e;\n\tconst OperatorMonoid Oe;\n\n\tLazySegmentTree(int n,const F op,const G homo,const H comp,\n\t\t\t\t\tconst Monoid &e,const OperatorMonoid Oe)\n\t\t: op(op),homo(homo),comp(comp),e(e),Oe(Oe) {\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile(sz<n) sz <<= 1,height++;\n\t\tdata.assign(2*sz,e);\n\t\tlazy.assign(2*sz,Oe);\n\t}\n\n\tvoid set(int k,const Monoid &x) {\n\t\tdata[k+sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor(int k=sz-1;k>0;k--) {\n\t\t\tdata[k] = op(data[2*k], data[2*k+1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k) {\n\t\tif(lazy[k]!=Oe) {\n\t\t\tlazy[2*k] = comp(lazy[2*k], lazy[k]);\n\t\t\tlazy[2*k+1] = comp(lazy[2*k+1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = Oe;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k) {\n\t\treturn lazy[k] == Oe? data[k]:homo(data[k],lazy[k]);\n\t}\n\n\tinline void recalc(int k) {\n\t\twhile(k>>=1) data[k] = op(reflect(2*k), reflect(2*k+1));\n\t}\n\n\tinline void thrust(int k) {\n\t\tfor(int i=height;i>0;i--) propagate(k>>i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tfor(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) lazy[l] = comp(lazy[l],x),++l;\n\t\t\tif(r&1) --r, lazy[r] = comp(lazy[r],x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tthrust(a+=sz);\n\t\tthrust(b+=sz-1);\n\t\tMonoid L = e, R = e;\n\t\tfor(int l=a, r=b+1;l<r;l>>= 1,r>>=1) {\n\t\t\tif(l&1) L = op(L,reflect(l++));\n\t\t\tif(r&1) R = op(reflect(--r),R);\n\t\t}\n\t\treturn op(L,R);\n\t}\n\n\tMonoid operator[](const int &k) {\n\t\treturn query(k,k+1);\n\t}\n\n\ttemplate<typename C>\n\tint find_subtree(int a,const C &check,Monoid &M,bool type) {\n\t\twhile(a<sz) {\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? op(reflect(2*a + type),M) : op(M, reflect(2*a+type));\n\t\t\tif(check(nxt)) a = 2*a+type;\n\t\t\telse M = nxt, a = 2*a+1-type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate<typename C>\n\tint find_first(int a,const C &check) {\n\t\tMonoid L = e;\n\t\tif(a<=0) {\n\t\t\tif(check(op(L,reflect(1)))) return find_subtree(1,check,L,false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a+sz);\n\t\tint b=sz;\n\t\tfor(a+=sz, b+=sz; a<b;a>>=1,b>>=1) {\n\t\t\tif(a&1) {\n\t\t\t\tMonoid nxt = op(L,reflect(a));\n\t\t\t\tif(check(nxt)) return find_subtree(a,check,L,false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\n\ttemplate<typename C>\n\tint find_last(int b,const C &check) {\n\t\tMonoid R = e;\n\t\tif(b>=sz) {\n\t\tif(check(op(reflect(1),R))) return find_subtree(1,check,R,true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b+sz-1);\n\t\tint a = sz;\n\t\tfor(b+=sz;a<b;a>>=1,b>>=1) {\n\t\t\tif(b&1) {\n\t\t\t\tMonoid nxt = op(reflect(--b),R);\n\t\t\t\tif(check(nxt)) return find_subtree(b,check,R,true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main(){\n    int N,Q;\n\tcin >> N >> Q;\n\tauto in = [](int a,int b){return b!=-1? b:a;};\n\tLazySegmentTree<int,int> seg(N,[](int a,int b){return min(a,b);},in,in,INT_MAX,-1);\n\tfor(int i=0;i<Q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t==0){\n\t\t\tint l,r,x;\n\t\t\tcin >> l >> r >> x;\n\t\t\tseg.update(l,r+1,x);\n\t\t}else{\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tcout << seg[q] << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 2147483647;\n\nstruct SegmentTree {\n    int n;\n    vector<int> heap;\n    \n    SegmentTree(int n): n(n) {\n        heap.assign(4 * n, INF);\n    }\n    \n    void update(int nodeId, int l, int r, int ql, int qr, int v) {\n        if (qr < l || ql > r) {\n            return;\n        }\n        else if (ql <= l && r <= qr) {\n            heap[nodeId] = v;\n        }\n        else {\n            pushdown(nodeId);\n            int m = l + (r - l)/2;\n            update(nodeId * 2, l, m, ql, qr, v);\n            update(nodeId * 2 + 1, m + 1, r, ql, qr, v);\n        }\n    }\n    \n    int query(int nodeId, int l, int r, int q) {\n        if (q < l || q > r) {\n            return -1;\n        }\n        else if (l == r) {\n            return heap[nodeId];\n        }\n        else {\n            pushdown(nodeId);\n            int m = l + (r - l)/2;\n            return max(query(nodeId * 2, l, m, q), query(nodeId * 2 + 1, m + 1, r, q));\n        }\n    }\n    \n    void pushdown(int nodeId) {\n        //cout << \"push: \" << nodeId << endl;\n        if (heap[nodeId] != -1) {\n            heap[nodeId * 2] = heap[nodeId];\n            heap[nodeId * 2 + 1] = heap[nodeId];\n            heap[nodeId] = -1;   \n        }\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int ql, qr, v;\n            cin >> ql >> qr >> v;\n            st.update(1, 0, n -1, ql, qr, v);\n//            for (int i = 0; i < 4 * n; i++) {\n//                cout << i << \":\" << st.heap[i] << endl; \n//            }\n        }\n        else {\n            int pos;\n            cin >> pos;\n            cout << st.query(1, 0, n-1, pos) << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E>\nstruct segment_tree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  typedef function<E(E,E)> H;\n  typedef function<E(E,int)> P;\n\n  vector<T> data;\n  vector<E> lazy;\n\n  F f;\n  G g;\n  H h;\n\n  int n;\n\n  T tid;\n  E eid;\n\n  P p;\n  segment_tree(int size, F f, G g, H h, T tid, E eid, P p=[](E a, int b){b=0;return a+b;}):f(f),g(g),h(h),tid(tid),eid(eid),p(p){\n    n = 1;\n    while(n<size) n<<=1;\n    data.assign(2*n-1,tid), lazy.assign(2*n-1,eid);\n  }\n  segment_tree(vector<T> v,F f, G g, H h, T tid, E eid, P p=[](E a, int b){return a;}):f(f),g(g),h(h),tid(tid),eid(eid),p(p){\n    int size = v.size();\n    n = 1;\n    while(n<size) n<<=1;\n    assign(v);\n  }\n  void assign(vector<T> v){\n    assert((int)v.size()<=n);\n    for(size_t i=0;i<v.size();++i) data[i+n-1] = v[i];\n    for(int i=v.size();i<n;++i) data[i+n-1] = tid;\n    for(int i=n-2;i>=0;--i) data[i] = f(data[2*i+1],data[2*i+2]);\n    lazy.assign(2*n-1,eid);\n  }\n  inline void eval(int k, int len){\n    if(lazy[k]!=eid){\n      data[k] = g(data[k],p(lazy[k],len));\n      // k has children.\n      if(len > 1){\n        lazy[2*k+1] = h(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2] = h(lazy[2*k+2],lazy[k]);\n      }\n      lazy[k] = eid;\n    }\n  }\n  void update(int i, E x){\n    update(i,i+1,x,0,0,n);\n  }\n  void update(int a,int b,E x){\n    update(a,b,x,0,0,n);\n  }\n  void update(int a, int b, E x,int k, int l, int r){\n    eval(k,r-l);\n\n    // [l,r) out of [a,b)\n    if(b<=l||r<=a) return;\n    // [l,r) in [a,b)\n    if(a<=l && r<=b){\n      lazy[k] = h(lazy[k],x);\n      eval(k,r-l);\n    }else{\n      update(a,b,x,2*k+1,l,(l+r)/2);\n      update(a,b,x,2*k+2,(l+r)/2,r);\n      data[k] = f(data[2*k+1],data[2*k+2]);\n    }\n  }\n  T find(int i){\n    return find(i,i+1,0,0,n);\n  }\n  // [a,b)\n  T find(int a,int b){\n    return find(a,b,0,0,n);\n  }\n  T find(int a,int b,int k,int l,int r){\n    eval(k,r-l);\n\n    // [l,r) out of [a,b)\n    if(r<=a||b<=l) return tid;\n\n    // [l,r) in [a,b)\n    if(a<=l&&r<=b) return data[k];\n\n    // else\n    return f(find(a,b,2*k+1,l,(l+r)/2),find(a,b,2*k+2,(l+r)/2,r));\n  }\n};\nstruct range_minimum_query{\n  int ui = -1;\n  function<int(int,int)> upd8 = [](int a, int b){return b!=-1?b:a;};\n  function<int(int,int)> find = [](int a, int b){return min(a,b);};\n  int mi = INT_MAX;\n  segment_tree<int,int> seg;\n  range_minimum_query(int n):seg(n,find,upd8,upd8,mi,ui){}\n\n  int getmin(int a, int b){\n    return seg.find(a,b);\n  }\n  void update(int s,int t, int x){\n    return seg.update(s,t,x);\n  }\n};\nint main(){\n  int n,q;\n  cin >> n >> q;\n  range_minimum_query rmq(n);\n  for(int i=0;i<q;++i){\n    int com,s;\n    cin >> com >> s;\n    if(com==0){\n      int t,x;cin >> t >> x;\n      rmq.update(s,t+1,x);\n    }else{\n      cout << rmq.getmin(s,s+1) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e9;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\n\nint inf=2147483647;\nint size=1;\nvector<int> tree;\nvoid init(int n){\n  while(size<n)size*=2;\n  tree.assign(size*2,inf);\n}\n\n//Range add Query [ )\nvoid update(int l,int r,int x){\n  l+=size,r+=size;\n  int nl=l,nr=r;\n  stack<int> s;\n\n  for(l/=2;1<=l;l/=2)s.emplace(l);\n  while(!s.empty()){\n    int tmp=s.top();s.pop();\n    if(tree[tmp]==-1)continue;\n    tree[2*tmp]=tree[2*tmp+1]=tree[tmp];\n    tree[tmp]=-1;\n  }\n  for(r=(r-1)/2;1<=r;r/=2)s.emplace(r);\n  while(!s.empty()){\n    int tmp=s.top();s.pop();\n    if(tree[tmp]==-1)continue;\n    tree[2*tmp]=tree[2*tmp+1]=tree[tmp];\n    tree[tmp]=-1;\n  }\n\n  for(;nl<nr;nl/=2,nr/=2){\n    if(nl%2==1)tree[nl++]=x;\n    if(nr%2==1)tree[--nr]=x;\n  }\n  return ;\n}\n\nint getvalue(int i){\n  i+=size;\n  int res=tree[i];\n  while(i/=2){\n    if(tree[i]!=-1){\n      res=tree[i];\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  init(n);\n  rep(i,q){\n    int a;\n    cin>>a;\n    if(a){\n      int x;\n      cin>>x;\n      cout<<getvalue(x)<<endl;\n    }else{\n      int s,t,x;\n      cin>>s>>t>>x;\n      t++;\n      update(s,t,x);\n    }\n  }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[105000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\n//[l,r)???x?????´??°??????.[bottom,top),node??????????????????\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\treturn;\n\t}\n\t\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\n\t//-INF???????????????????????¨?????????????????????????????¨?????¨???\n\tif (m[node] != -INF) {\n\t\tm[2 * node] = m[node];\n\t\tm[2 * node + 1] = m[node];\n\t\tm[node] = -INF;\n\t}\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{ \n\tcin >> n >> q;\n\n\tn=init(n);\n\n\tint a, s, t, x, k;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> k;\n\t\t\tcout << find(k) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename M, typename T>\nstruct lazy_segment_tree{\n\ttypedef function<M(M, M)> F;\n\ttypedef function<M(M, T)> EVAL;\n\ttypedef function<T(T, T)> G;\n\tint size;//2冪\n\tvector<M> val;//1-indexed\n\tvector<T> lazy;//遅延情報を入れる\n\tF f;//結合関数\n\tEVAL eval;//モノイドに作用素を作用させる関数\n\tG g;//作用素の結合関数 A->Bの順に作用させるとg(A, B)\n\tM em;//モノイドの単位元\n\tT et;//作用素の単位元\n\n\tlazy_segment_tree(int N, vector<M> &data, F f, EVAL eval, G g, M em, T et) : f(f), eval(eval), g(g), em(em), et(et){\n\t\tsize = 1;\n\t\twhile(size < N) size *= 2;\n\t\tval.assign(2 * size, em);\n\t\tlazy.assign(2 * size, et);\n\t\tfor(int i = 0; i < N; i++) val[size + i] = data[i];\n\t\tfor(int i = N; i < size; i++) val[size + i] = em;\n\t\tfor(int i = size - 1; i > 0; i--) val[i] = f(val[2 * i], val[2 * i + 1]);\n\t}\n\n\tvoid propagate(int k){\n\t\tif(lazy[k] != et && k < size){\n\t\t\tlazy[2 * k + 0] = g(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = g(lazy[2 * k + 1], lazy[k]);\n\t\t}\n\t\tval[k] = eval(val[k], lazy[k]);\n\t\tlazy[k] = et;\n\t}\n\n\t//[l, r)に対してAを作用させたときの[s, t)の値を求める\n\tM update(int l, int r, T A, int k, int s, int t){\n\t\tpropagate(k);\n\t\tif(t <= l || r <= s){\n\t\t\treturn val[k];\n\t\t}\n\t\telse if(l <= s && t <= r){\n\t\t\tlazy[k] = g(lazy[k], A);\n\t\t\tpropagate(k);\n\t\t\treturn val[k];\n\t\t}\n\t\telse{\n\t\t\treturn val[k] = f(update(l, r, A, 2 * k, s, (s + t) / 2), update(l, r, A, 2 * k + 1, (s + t) / 2, t));\n\t\t}\n\n\t}\n\n\t//[l, r)に対してAを作用させる\n\tvoid update(int l, int r, T A){\n\t\tM res = update(l, r, A, 1, 0, size);\n\t}\n\n\tM query(int l, int r, int k, int s, int t){\n\t\tpropagate(k);\n\t\tif(t <= l || r <= s){\n\t\t\treturn em;\n\t\t}\n\t\telse if(l <= s && t <= r){\n\t\t\treturn val[k];\n\t\t}\n\t\telse{\n\t\t\treturn f(query(l, r, 2 * k, s, (s + t) / 2), query(l, r, 2 * k + 1, (s + t) / 2, t));\n\t\t}\n\t}\n\n\t//[l, r)の演算の結果を返す\n\tM query(int l, int r){\n\t\treturn query(l, r, 1, 0, size);\n\t}\n};\n\n//query:sum\n//update:substitution\n//(pair<int, int>, int, sum, eval, g, em, et)\n//x = (値, 区間の長さ)\n\nconst pair<int, int> em(0, 0);\nconst int et = (1 << 31);\n\npair<int, int> sum(pair<int, int> x, pair<int, int> y){\n\treturn pair<int, int>(x.first + y.first, x.second + y.second);\n}\n\npair<int, int> eval(pair<int, int> x, int a){\n\tif(a == et) return x;\n\telse return pair<int, int>(a * x.second, x.second);\n}\n\nint g(int a, int b){\n\tif(b == et) return a;\n\telse return b;\n}\n\nint main(){\n\tint N, Q, i;\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > data(N, pair<int, int>(0x7fffffff, 1));\n\tlazy_segment_tree<pair<int, int>, int> t(N, data, sum, eval, g, em, et);\n\tfor(i = 0; i < Q; i++){\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\tif(c == 0){\n\t\t\tint l, r, x;\n\t\t\tscanf(\"%d%d%d\", &l, &r, &x);\n\t\t\tt.update(l, r + 1, x);\n\t\t}\n\t\telse{\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tprintf(\"%d\\n\", t.query(k, k + 1));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n\nusing namespace std;\n\n#define int long long\n#define dotimes(i, n) for (int i = 0, i##max__ = (n); i < i##max__; i++)\n#define whole(f, x, ...) ([&](decltype((x)) c) { return (f)(begin(c), end(c), ## __VA_ARGS__); })(x)\n\nint rint() {\n  int x;\n  scanf(\"%lld\", &x);\n  return x;\n}\n\nvoid wint(int x) {\n  printf(\"%lld\\n\", x);\n}\n\ntemplate<typename T> int size(T const& c) { return static_cast<int>(c.size()); }\ntemplate <typename T> bool maxs(T& a, T const& b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool mins(T& a, T const& b) { return a > b ? a = b, true : false; }\ninline int lg(int x) { return 63 - __builtin_clzll(static_cast<unsigned int>(x)); }\n\nclass segment_tree {\n  // Negative nodes delegate to their children\n  vector<int> xs;\npublic:\n  segment_tree(int n) : xs(1 << (lg(2 * n - 1) + 1), (1LL << 31) - 1) {}\n  void update(int i, int j, int x) {\n    function<void(int, int, int)> rec;\n    rec =\n      [&](int k, int a, int b) {\n        if (i <= a && b <= j)\n          xs[k] = x;\n        else {\n          if (xs[k] >= 0)\n            xs[2*k] = xs[2*k+1] = xs[k];\n          int c = a + (b - a) / 2;\n          if (j <= c)\n            rec(2*k, a, c);\n          else if (c <= i)\n            rec(2*k+1, c, b);\n          else {\n            rec(2*k, a, c);\n            rec(2*k+1, c, b);\n          }\n          xs[k] = -1;\n        }\n      };\n    rec(1, 0, ::size(xs)/2);\n  }\n  int query(const int i) {\n    function<int(int, int, int)> rec;\n    rec =\n      [&](int k, int a, int b) {\n        if (xs[k] >= 0)\n          return xs[k];\n        int c = a + (b - a) / 2;\n        return i < c ? rec(2*k, a, c) : rec(2*k+1, c, b);\n      };\n    return rec(1, 0, ::size(xs)/2);\n  }\n};\n\nsigned main() {\n  const int n = rint();\n  const int q = rint();\n  segment_tree st(n);\n  dotimes(i, q)\n    if (rint()) {\n      int i = rint();\n      wint(st.query(i));\n    } else {\n      int s = rint();\n      int t = rint();\n      int x = rint();\n      st.update(s, t+1, x);\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<functional>\n#define ll long long\n\n#define pa pair<int,int>\n#define int long long\n\nusing namespace std;\n\nint inf=(1ll<<40);\nstruct seg_rangeupd_getpoint{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<int> vec;\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, inf);\n\t}\n\tvoid shoki2(){\n\t\tvec[1]=(1ll<<31)-1;\n\t\t//初期値\n\t}\n\t\t\n\tvoid chien(int k,int l,int r){\n\t\tif(l+1<r)if(vec[k]!=inf){\n\t\t\tvec[2*k]=vec[k];\n\t\t\tvec[2*k+1]=vec[k];\n\t\t\tvec[k]=inf;\n\t\t}\n\t}\n\t\n\tvoid rangeupd(int a,int b,int w, int k=1,int l=0,int r=-3){\n\t\t//[a,b)を wに変更\n\t\tif(r<0) r=cor;\n\t\tif(a<=l && r<=b){\n\t\t\tvec[k]=w;\n\t\t\treturn ;\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn ;\n\t\t}\n\t\tchien(k,l,r);\n//\tcout<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\trangeupd(a,b,w,k*2,l,(l+r)/2);\n\t\trangeupd(a,b,w,k*2+1,(l+r)/2,r);\n\t\treturn ;\n\t}\n\t\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tint getpoint(int x){\n\t\tx+=cor;\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tif(x==0) break;\n\t\t\tif(vec[x]!=inf) ans=vec[x];\n\t\t\tx/=2;\n\t\t}\n\t\t\n\t\treturn ans;\n\t\t\n\t}\n\t\n\tvoid pre(){\n\t\tfor(int i=1;i<2*cor;i++){\n\t\t\tcout<<vec[i]<<\" \";\n\t\t\tif(((i+1)&(-(i+1)))==i+1) cout<<endl;\n\t\t}\n\t}\n\t\n};\n\n//[a,b)にxを一様加算 rangeadd(a,b,x)\n//[a,b)の和 getsum(a,b)\n\nsigned main(){\nseg_rangeupd_getpoint SE;\n\t\n\tSE.shoki1();\n//\tfor(int i=0;i<SE.cor;i++){\n//\t\tSE.vec[i+SE.cor]=i;\n//\t}\n\tSE.shoki2();\n\t\n\t\n\tint n,q;\n\tcin>>n>>q;\n\t\n\tfor(int i=0;i<q;i++){\n\tint d,a,b,c;\n\t\tcin>>a;\n\t\t\n\t\tif(a==0){\n\t\t\tcin>>b>>c>>d;\n\t\t\t\n\t\t\tSE.rangeupd(b,c+1,d);\n\t\t}\n\t\telse{\n\t\t\tcin>>b;\n\t\t\t\n\t\t\tcout<<SE.getpoint(b)<<endl;\n\t\t}\n\t\t//SE.pre();\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\nusing namespace std;\n\ntemplate <typename T, typename E>\nclass lazy_segtree {\nprivate:\n    using Op = function<T(T, T)>;\n    using Compose = function<E(E, E)>;\n    using Act = function<T(T, E)>;\n    using Power = function<E(E, int)>;\n\n    size_t N;\n    vector<T> data;\n    vector<E> lazy;\n    const T idT;\n    const E idE;\n    const Op op;\n    const Compose compose;\n    const Act act;\n    const Power power;\n\n    void eval(size_t k, size_t len) {\n        if(lazy[k] == idE) return;\n        if(2 * k + 1 < 2 * N) {\n            lazy[2 * k] = compose(lazy[2 * k], lazy[k]);\n            lazy[2 * k + 1] = compose(lazy[2 * k + 1], lazy[k]);\n        }\n        data[k] = act(data[k], power(lazy[k], len));\n        lazy[k] = idE;\n    }\n\n    void update(size_t a, size_t b, size_t k, size_t l, size_t r, E x) {\n        eval(k, r - l);\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) {\n            lazy[k] = compose(lazy[k], x);\n            eval(k, r - l);\n            return;\n        }\n        update(a, b, 2 * k, l, (l + r) / 2, x);\n        update(a, b, 2 * k + 1, (l + r) / 2, r, x);\n        data[k] = op(data[2 * k], data[2 * k + 1]);\n    }\n\n    T get(size_t a, size_t b, size_t k, size_t l, size_t r) {\n        eval(k, r - l);\n\n        if(r <= a || b <= l) return idT;\n        if(a <= l && r <= b) return data[k];\n        \n        T vl = get(a, b, 2 * k, l, (l + r) / 2);\n        T vr = get(a, b, 2 * k + 1, (l + r) / 2, r);\n        if(2 * k + 1 < 2 * N) data[k] = op(data[2 * k], data[2 * k + 1]);\n        return op(vl, vr);\n    }\n\npublic:\n    lazy_segtree(size_t n, T idT, E idE,\n    const Op op, const Compose compose,\n    const Act act, const Power power = [](E a, int b){ return a; })\n    : idT(idT), idE(idE), op(op), compose(compose), act(act), power(power) {\n        for(N = 1; N < n; N <<= 1);\n        data = vector<T>(2 * N, idT);\n        lazy = vector<E>(2 * N, idE);\n    }\n    \n    lazy_segtree(const vector<T> &init, T idT, E idE,\n    const Op op, const Compose compose,\n    const Act act, const Power power = [](E a, int b){ return a; })\n    : idT(idT), idE(idE), op(op), compose(compose), act(act), power(power) {\n        for(N = 1; N < init.size(); N <<= 1);\n        data = vector<T>(2 * N, idT);\n        lazy = vector<E>(2 * N, idE);\n        for(int i = 0; i < init.size(); ++i) data[i + N] = init[i];\n        for(int i = N - 1; i >= 0; --i) data[i] = op(data[2 * i], data[2 * i + 1]);\n    }\n\n    void update(size_t left, size_t right, E x) {\n        update(left, right, 1, 0, N, x);\n    }\n\n    T get(size_t left, size_t right) {\n        return get(left, right, 1, 0, N);\n    }\n\n    T operator[](int k) {\n        return get(k, k + 1);\n    }\n};\n\n#include <iostream>\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    lazy_segtree<int, int> st(n, (1LL << 31) - 1, -1,\n    [](int a, int b){ return min(a, b); },\n    [](int a, int b){ return b; },\n    [](int a, int b){ return b; }\n    );\n\n    while(q--) {\n        int c; cin >> c;\n        if(c == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            st.update(s, t + 1, x);\n        } else {\n            int i; cin >> i;\n            cout << st[i]<< endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid update(int s, int t,int x, vector<int>& a) {\n\tfill(a.begin() + s, a.begin() + t + 1, x);\n}\n\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_, q;  cin >> n_ >> q;\n\tvector<int> a(n_, INT_MAX);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) { int s, t, x; cin >> s >> t >> x; update(s, t, x, a); }\n\t\telse {\n\t\t\tint x; cin >> x;\n\t\t\tcout << a[x] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\ntemplate< typename OperatorMonoid >\nstruct DuelSegTree {\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  int sz, height;\n  vector< OperatorMonoid > lazy;\n  const H h;\n  const OperatorMonoid OM0;\n\n\n  DuelSegTree(int n, const H h, const OperatorMonoid OM0)\n      : h(h), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while(sz < n) sz <<= 1, height++;\n    lazy.assign(2 * sz, OM0);\n  }\n\n  inline void propagate(int k) {\n    if(lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n  }\n\n  OperatorMonoid operator[](int k) {\n    thrust(k += sz);\n    return lazy[k];\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,q;\n  cin>>n>>q;\n  auto h=[](int a,int b){return b;};\n  DuelSegTree<int> seg(n,h,inf);\n\n  while(q--){\n    int t;\n    cin>>t;\n    if(t==0){\n      int l,r,x;\n      cin>>l>>r>>x;\n      seg.update(l,r+1,x);\n    }else{\n      int x;\n      cin>>x;\n      cout<<seg[x]<<endl;\n    }\n  }\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <climits>\n#include <set>\n\n//#define int long long\ntypedef long long ll;\n//using ll = long long;\n//using R = double;\n\n//#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,bg,ed) for(ll i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\n#define MOD 1000000007\n\nconst int INF = int(1e9);\n\nusing namespace std;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\n\n\n// ???????????????1??¨?????????????????§???\n// ????????????k*2\n// ????????????k*2+1\n// ??????floor(k/2)\n// ??¨?????????\n// ???????????????1??¨????????¨????????°?????????????????????????????°?????§??????????????????????????????????????????\n// ?????°?????????????????§????????°???????????§??????????????????\n\nconst int N = 1 << 17;  // ???????????°\n//const int NIL = INT_MAX;\nconst ll NIL = 1e18;\n\nll maxi[N * 2]; // ?????????k?????????????????????????????§???\nll lazy[N * 2]; // lazy[k]????????????k???????????¨??????lazy[k]??§???????????¶?????¨?????????????????¨??????lazy[k]=NIL?????¨???????????????????????¨?´??????????\n\nvoid setLazy(int k, int v) {\n    lazy[k] = v;\n\n    // ??????????????????????????¨?????? v ??§???????????¶????????????????????????????????¶????????????k????????§??????v??§??????\n    maxi[k] = v;\n\n    // *** ?????? ***\n    // ????????????????????¶?????°???????????¨??§????????£??¨????????????\n    // ?????????O(1)????????¢?????§??¨?????§??????????????????????????????????????§???????????§????????°?????¶?????°???????????¨??§????????§?????????\n    // ?????¨?????°?????????????????¨?????????????????¶???????????????????????????????????°???????????¨??????????????§????????°???\n    //\n    // fill v := v ??§???????????¶???\n    // add v := v ???????????????\n    //\n    // ??¨??????????¨???????????????????????????????????????????\n    // add u ??????????????? fill v ??????????????¨??? (fill v) . (add u) ??¨???????????¨???????????????\n    // ????????¨?????\\????????¢????????????????????????\n    //\n    // (add v) . (add u) = (add v+u)\n    // (add v) . (fill u) = (fill v+u)\n    // (fill v) . (add u) = (fill v)\n    // (fill v) . (fill u) = (fill v)\n    //\n    // ????????????add u ??¨ fill u ????£????????????? (add or fill, Int) ??§??????????????????\n    // ?????£??????????????? add ??§????????? fill ??§???????????¨????????????????????±??¨?????????/???????????¶????????? 2 ???????????±????????£?????¨?????§?????????\n    // ?????°??????????????????????????????????????????????????????????????????????????¨???????????¨???????????????????????????????????????\n    //\n    // ?????¶?????°???????????¨??????????????????????????????????????????????????¨????????????\n    // ??????????????¶?????¬?????°???????????¨????????§???????????¨????????????\n    // ??????????????????????????????????????±???????????????????????????\n    //\n    // ????§£??????????????????????????????????????????????????????????????¶???????????¶?????¬????????????????????¨??????????????§????????????\n    // ???????????¶???????????????????????????????????°???\n    //  (timeS, valueS) . (timeT, valueT) = max((timeS, valueS), (timeT, valueT))\n    // ??¨??????????????????????????¢??§?????????\n}\n\nvoid push(int k) {\n    // ?????¶?????????????????????????????°???????????????\n    if (lazy[k] == NIL) {\n        return;\n    }\n    setLazy(k * 2 + 0, lazy[k]);\n    setLazy(k * 2 + 1, lazy[k]);\n\n    // ????????????????????¬??????????????§????????????????????????\n    lazy[k] = NIL;\n}\n\nvoid fix(int k) {\n    // ?????????k?????????????????????????????§?????????????????????????????§????????¨????????????????????§??????????????§???\n    maxi[k] = max(maxi[k * 2], maxi[k * 2 + 1]);\n}\n\n// ??????[queryL,queryR)???val??§???????????¶???\nvoid fill(int queryL, int queryR, int val, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨????????????????????????????????????????????????????????\\?????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return;\n    }\n    // ???????????????????????¨?????????????????¨??????????????????????????¶????????????????????????????????£?????¨??°???\n    if (queryL <= nodeL && nodeR <= queryR) {\n        setLazy(k, val);\n        return;\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    fill(queryL, queryR, val, k * 2 + 0, nodeL, nodeM);\n    fill(queryL, queryR, val, k * 2 + 1, nodeM, nodeR);\n\n    // ???????????????????????¨??????????????±???fix??????\n    fix(k);\n}\n\n// ??????[queryL, queryR)????????§???????±???????\nll maximum(int queryL, int queryR, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨???????????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return -(1e18);\n    }\n    // ???????????????????????¨?????????????????¨???????????????\n    if (queryL <= nodeL && nodeR <= queryR) {\n        return maxi[k];\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    ll vl = maximum(queryL, queryR, k * 2 + 0, nodeL, nodeM);\n    ll vr = maximum(queryL, queryR, k * 2 + 1, nodeM, nodeR);\n    return max(vl, vr);\n}\n\n\nint n, q;\nint com, s, t, x;\n\n\nsigned main()\n{\n    cin >> n >> q;\n\n    for (int i=0; i<N*2; i++) {\n        lazy[i] = NIL;\n    }\n\n    fill(0, n, INT_MAX);\n\n    REP(i,q) {\n        cin >> com;\n        if (com == 0) {\n            cin >> s >> t >> x;\n            fill(s, t + 1, x);\n        } else {\n            cin >> s;\n            cout << maximum(s, s + 1) << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define FOR(i,n,m) for(int i=n;i<=(int)(m);i++)\n#define RFOR(i,n,m) for(int i=(int)(n);i>=m;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(std::unique(all(x)), x.end());\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = INT_MAX;\nconst double PI=acos(-1);\nusing namespace std;\nvector<int> dx={1,0,-1,0};\nvector<int> dy={0,1,0,-1};\ntemplate<class T>\nvector<T> make_vec(size_t a){\n    return vector<T>(a);\n}\ntemplate<class T, class... Ts>\nauto make_vec(size_t a, Ts... ts){\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\n//区間更新・区間最小クエリ\nstruct LazySegmentTree {\n    int n;\n    vector<ll> node, lazy;\n    vector<bool> lazyFlag;\n    \n    LazySegmentTree(vector<ll> v) {\n        int sz=sz(v);\n        n=1;\n        while(n<sz) n*=2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, LINF);\n        lazyFlag.resize(2*n-1, false);\n        \n        rep(i,sz) node[i+n-1]=v[i];\n        rrep(i,n-1) node[i]=min(node[i*2+1], node[i*2+2]);\n    }\n    \n    void lazyEvaluate(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k]=lazy[k];\n            if(r-l>1) {\n                lazy[k*2+1]=lazy[k];\n                lazy[k*2+2]=lazy[k];\n                lazyFlag[k*2+1]=true;\n                lazyFlag[k*2+2]=true;\n            }\n            lazyFlag[k]=false;\n        }\n    }\n    \n    void update(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r<0) r=n;\n        lazyEvaluate(k, l, r);\n        if(b<=l || r<=a) return;\n        \n        if(a<=l && r<=b) {\n            lazy[k]=x;\n            lazyFlag[k]=true;\n            lazyEvaluate(k, l, r);\n        }\n        else {\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=min(node[2*k+1], node[2*k+2]);\n        }\n    }\n    \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r<0) r=n;\n        lazyEvaluate(k, l, r);\n        \n        if(b<=l || r<=a) return LINF;\n        if(a<=l && r<=b) return node[k];\n        \n        ll vl=getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\n\nint main() {\n    int n,q;\n    cin>>n>>q;\n    vector<ll> v(n,LINF);\n    LazySegmentTree segt(v);\n    while(q--) {\n        int query;\n        cin>>query;\n        if(query==0) {\n            int s,t;\n            ll x;\n            cin>>s>>t>>x;\n            segt.update(s,t+1,x);\n        }\n        else {\n            int i;\n            cin>>i;\n            cout<<segt.getmin(i,i+1)<<endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename OperatorMonoid>\nstruct DualSegmentTree{\n    typedef function<OperatorMonoid(OperatorMonoid,OperatorMonoid)> H;\n    int n,hi;\n    H h;\n    OperatorMonoid id1;\n    vector<OperatorMonoid> laz;\n    DualSegmentTree(int n_,H h,OperatorMonoid id1):h(h),id1(id1){init(n_);}\n    void init(int n_){\n        n=1,hi=0;\n        while(n<n_) n<<=1,++hi;\n        laz.assign(n<<1,id1);\n    }\n    inline void propagate(int k){\n        if (laz[k]==id1) return;\n        laz[k<<1|0]=h(laz[k<<1|0],laz[k]);\n        laz[k<<1|1]=h(laz[k<<1|1],laz[k]);\n        laz[k]=id1;\n    }\n    inline void thrust(int k){\n        for (int i=hi;i;--i) propagate(k>>i);\n    }\n    void update(int a,int b,OperatorMonoid x){\n        if (a>=b) return;\n        thrust(a+=n),thrust(b+=n-1);\n        for (int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if (l&1) laz[l]=h(laz[l],x),++l;\n            if (r&1) --r,laz[r]=h(laz[r],x);\n        }\n    }\n    void set_val(int k,OperatorMonoid x){\n        thrust(k+=n);\n        laz[k]=x;\n    }\n    OperatorMonoid operator[](int k){\n        thrust(k+=n);\n        return laz[k];\n    }\n};\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_D\n\nvoid DSL_2_D(){\n    int n,q; cin >> n >> q;\n    auto h=[](int a,int b){return b;};\n    DualSegmentTree<int> seg(n,h,INT_MAX);\n    for (;q--;){\n        int c,s,t,x,i; cin >> c;\n        if (!c){\n            cin >> s >> t >> x;\n            seg.update(s,t+1,x);\n        } else {\n            cin >> i;\n            cout << seg[i] << '\\n';\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    DSL_2_D();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n  const int sqrtN = 512;\n  const ll inf = (1LL<<31)-1;\n  int n, q;\n  cin >> n >> q;\n  int bucket_sz = (n+sqrtN-1)/sqrtN;\n  vector<ll> a(n, inf);\n  vector<ll> bucketUp(bucket_sz, 0);\n  vector<bool> bucketFlag(bucket_sz, false);\n  auto push = [&](int k) {\n    bucketFlag[k] = false;\n    int l = k*sqrtN, r = (k+1)*sqrtN;\n    for(int i = l; i < r; ++i) a[i] = bucketUp[k];\n  };\n  auto update = [&](int s, int t, int x) {\n    for(int i = 0; i < bucket_sz; ++i) {\n      int l = i*sqrtN, r = (i+1)*sqrtN;\n      if(r <= s || t <= l) continue;\n      if(s <= l && r <= t) {\n\tbucketUp[i] = x;\n\tbucketFlag[i] = true;\n      } else {\n\tif(bucketFlag[i]) push(i);\n\tfor(int j = max(s, l); j < min(t, r); ++j) {\n\t  a[j] = x;\n\t}\n      }\n    }\n  };\n  auto get = [&](int k)->ll{\n    if(bucketFlag[k/sqrtN]) push(k/sqrtN);\n    return a[k];\n  };\n  while(q--) {\n    int t;\n    cin >> t;\n    if(t == 0) {\n      ll s, t, x;\n      cin >> s >> t >> x;\n      update(s, t+1, x);\n    } else {\n      int k;\n      cin >> k;\n      cout << get(k) << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;    \ntypedef long long Int;\n\n#define SEG_LEN (1 << 18)\n\nint seg[SEG_LEN * 2];\nInt update_val[1100000];\n\nInt get(int ind){\n    ind += SEG_LEN;\n    int last_update = seg[ind];\n    while(true){\n        ind /= 2;\n        if(ind == 0)break;\n        last_update = max(last_update, seg[ind]);\n    }\n    return update_val[last_update];\n}\n\nvoid update(int l, int r, int time, Int val){\n    update_val[time] = val;\n    l += SEG_LEN;\n    r += SEG_LEN;\n    int ans = 0;\n    while(l < r){\n        if(l % 2 == 1){\n            seg[l] = time;\n            l++;\n        }\n        l /= 2;\n        if(r % 2 == 1){\n            seg[r-1] = time;\n            ans += seg[r-1];\n            r--;\n        }\n        r /= 2;\n    }\n}\n\nint main(){\n    int n, q, s, t, x, ind, com;\n    cin >> n >> q;\n    update(0, n, 0, (1LL<<31) - 1LL);\n    for(int i = 0;i < q;i++){\n        cin >> com;\n        if(com == 0){//add\n            cin >> s >> t >> x;\n            update(s, t+1, i+1, x);\n        }\n        if(com == 1){//get sum\n            cin >> ind;\n            cout << get(ind) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_INT 2147483647\nusing namespace std;\nint main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int>a(n,MAX_INT);\n  for(int i=0;i<q;i++){\n    int com;cin>>com;\n    if(com){\n      int i;\n      scanf(\"%d\",&i);\n      printf(\"%d\\n\",a[i]);\n    }else{\n      int s,t,l;\n      scanf(\"%d %d %d\",&s,&t,&l);\n      fill(a.begin()+s,a.begin()+t+1,l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\n\n// struct SqrtDecomposition { // sum\n// private:\n//     ll N, K, sqrtN;\n//     vector<ll> data, bucket;\n\n// public:\n//     SqrtDecomposition(ll n){\n//         N = n;\n//         sqrtN = sqrt(n);\n//         K = (N + sqrtN - 1) / sqrtN;\n//         data.assign(n+10, 0);\n//         bucket.assign(K+10, 0);\n//     }\n\n//     void add(ll x, ll y){\n//         ll k = x / sqrtN;\n//         data[x] += y;\n//         bucket[k] += y;\n//     }\n\n//     // [x, y)\n//     ll getSum(ll x, ll y){\n//         ll sum = 0;\n//         rep(k,0,K){\n//             ll lv = k * sqrtN, rv = (k+1) * sqrtN;\n//             if(rv <= x || y <= lv) continue;\n//             if(x <= lv && rv <= y){\n//                 sum += bucket[k];\n//             }else{\n//                 for(ll i = max(x, lv); i < min(y, rv); i++){\n//                     sum += data[i];\n//                 }\n//             }\n//         }\n//         return sum;\n//     }\n// };\n\n// struct SqrtDecomposition { // min\n// private:\n//     ll N, K, sqrtN;\n//     vector<ll> data, bucket;\n\n// public:\n//     SqrtDecomposition(ll n){\n//         N = n;\n//         sqrtN = sqrt(n);\n//         K = (N + sqrtN - 1) / sqrtN;\n//         data.assign(n+10, (1LL<<31)-1);\n//         bucket.assign(K+10, (1LL<<31)-1);\n//     }\n\n//     void update(ll x, ll y){\n//         ll k = x / sqrtN;\n//         data[x] = y;\n//         ll min_val = y;\n//         for(ll i = k * sqrtN; i < (k+1) * sqrtN; i++){\n//             min_val = min(min_val, data[i]);\n//         }\n//         bucket[k] = min_val;\n//     }\n\n//     // [x, y)\n//     ll find(ll x, ll y){\n//         ll min_val = INF;\n//         rep(k,0,K){\n//             ll lv = k * sqrtN, rv = (k+1) * sqrtN;\n//             if(rv <= x || y <= lv) continue;\n//             if(x <= lv && rv <= y){\n//                 min_val = min(min_val, bucket[k]);\n//             }else{\n//                 for(ll i = max(x, lv); i < min(y, rv); i++){\n//                     min_val = min(min_val, data[i]);\n//                 }\n//             }\n//         }\n//         return min_val;\n//     }\n// };\n\n// struct SqrtDecomposition { // range add\n// private:\n//     ll N, K, sqrtN;\n//     vector<ll> data, bucket;\n\n// public:\n//     SqrtDecomposition(ll n){\n//         N = n;\n//         sqrtN = sqrt(n);\n//         K = (N + sqrtN - 1) / sqrtN;\n//         data.assign(n+10, 0);\n//         bucket.assign(K+10, 0);\n//     }\n\n//     void add(ll s, ll t, ll x){\n//         rep(k,0,K){\n//             ll lv = k * sqrtN, rv = (k+1) * sqrtN;\n//             if(rv <= s || t <= lv) continue;\n//             if(s <= lv && rv <= t){\n//                 bucket[k] += x;\n//             }else{\n//                 for(ll i = max(s, lv); i < min(t, rv); i++){\n//                     data[i] += x;\n//                 }\n//             }\n//         }\n//     }\n\n//     ll get(ll x){\n//         return data[x] + bucket[x / sqrtN];\n//     }\n// };\n\nstruct SqrtDecomposition { // range update\nprivate:\n    ll N, K, sqrtN;\n    // vector<ll> data, bucket;\n    vector<ll> data;\n    vector<bool> lazyFlag;\n    vector<ll> lazyUpdate;\n\npublic:\n    SqrtDecomposition(ll n){\n        N = n;\n        sqrtN = sqrt(n);\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(n+10, (1LL<<31)-1);\n        lazyUpdate.assign(K+10, 0);\n        lazyFlag.assign(K+10, false);\n    }\n\n    void update(ll s, ll t, ll x){\n        rep(k,0,K){\n            ll lv = k * sqrtN, rv = (k+1) * sqrtN;\n            if(rv <= s || t <= lv) continue;\n            if(s <= lv && rv <= t){\n                lazyFlag[k] = true;\n                lazyUpdate[k] = x;\n            }else{\n                if(lazyFlag[k]){\n                    lazyFlag[k] = false;\n                    rep(i,k * sqrtN, (k+1) * sqrtN){\n                        data[i] = lazyUpdate[k];\n                    }\n                    lazyUpdate[k] = 0;\n                }\n                for(ll i = max(s, lv); i < min(t, rv); i++){\n                    data[i] = x;\n                }\n            }\n        }\n    }\n\n    ll find(ll x){\n        ll k = x / sqrtN;\n        if(lazyFlag[k]){\n            lazyFlag[k] = false;\n            for(ll i = k * sqrtN; i < (k+1) * sqrtN; i++){\n                data[i] = lazyUpdate[k];\n            }\n            lazyUpdate[k] = 0;\n            return data[x];\n        }else{\n            return data[x];\n        }\n    }\n};\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, Q;\n    cin >> N >> Q;\n    SqrtDecomposition sd(100010);\n    while(Q--){\n        ll c;\n        cin >> c;\n        if(c == 0){\n            ll s,t,x;\n            cin >> s >> t >> x;\n            sd.update(s, t+1, x);\n        }else{\n            ll x;\n            cin >> x;\n            print(sd.find(x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[n/sq+1];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int A[100000];\n    int i, s, t, x, n, q, ask;\n\n    for(i = 0; i < 100000; i++) A[i] = INT_MAX - 1;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n\t\tif(ask){\n            cin >> i;\n            cout << A[i] << endl;\n\t\t}else{\n            cin >> s >> t >> x;\n\t\t\tfor(i = s; i <= t; i++) A[i] = x;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nstatic const int MAX = 200000;\n\nint main(){\n\tint R[MAX],n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>R[i];\n\t}\n\t\n\tint maxv = -2000000000;\n\tint minv = R[0];\n\t\n\tfor(int i=1;i<n;i++){\n\t\tmaxv = max(maxv,R[i]-minv);\n\t\tminv = min(minv,R[i]);\n\t}\n\tcout<< maxv<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 1000\n\nint bucket[MAX/B][100];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && data[a/B] != INF){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n\t\t\tf1 = 0;data[a/B] = INF;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != 99){\n\t\tif(f2 && data[b/B] != INF){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n\t\t\tf2 = 0;data[b/B] = INF;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tdata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(data[x/B] != INF){\n\t\tfor(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n\t\tdata[x/B] = INF;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(data, data+MAX/B, INF);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\ntemplate<class T>\nclass sg_tree : public vector<T>{\nprivate:\n    lli n;\n    T default_value;\n    void _query(lli a,lli b,T x,lli k,lli l,lli r){\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) (*this)[k] = x;\n        else {\n            _query(a,b,x,k*2+1,l,(l+r)/2);\n            _query(a,b,x,k*2+2,(l+r)/2,r);\n            return;\n        }\n    }\npublic:\n    sg_tree():vector<T>(){\n\n    }\n    sg_tree(lli n,T d = -1):vector<T>(n*4,d){\n\t\tthis->n = 1;\n        while(n > this->n) this->n <<= 1;\n        this->default_value = d;\n    }\n    T update(lli i){\n        i += n - 1;\n        T ret = (*this)[i];\n        while(i > 0){\n            i = (i - 1) / 2;\n            ret = max(ret,(*this)[i]);\n        }\n        return ret;\n    }\n    void query(lli a,lli b,lli x){\n        _query(a,b,x,0,0,n);\n    }\n    T func(T a,T b){\n        return min(a,b);\n    }\n};\n\nlli n,q;\nlli c,s,t,x;\nlli k = 0;\nvll b;\n\nsg_tree<lli> sg;\n\nint main(){\n    cin >> n >> q;\n    sg = sg_tree<lli> (n);\n    for(lli i = 0;i < q;i++){\n        cin >> c;\n        if(c){\n            cin >> x;\n            lli t;\n            if((t = sg.update(x)) < 0) cout << 2147483647 << endl;\n            else cout << b[t] << endl;\n        }else{\n            cin >> s >> t >> x;\n            b.push_back(x);\n            sg.query(s,t+1,k);\n            k++;\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 100010;\n\nclass segTree{\n    public:\n        int n, dat[4 * MAX_N];\n        virtual int query(int, int, int, int, int) = 0;\n        void init(int n_){}\n        void init(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n            }\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            else if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n            else{\n                int res = (min(b, r) - max(a, l)) * dat[k];\n                res += query(a, b, k * 2, l, (l + r) / 2);\n                res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return res;\n            }\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n) dat[i] = dat_add[i] = 0;\n        }\n\n        void update(int i, int x){\n            add(i, i + 1, 1, 0, n, x);\n        }\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n        void add(int s, int t, int x){\n            add(s, t, 1, 0, n, x);\n        }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n\n            if(a <= l && r <= b) return dat[k];\n            else{\n                int vl = query(a, b, k * 2, l, ( l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return vl + vr;\n            }\n        }\n    public:\n        void init(int n_){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n) dat[i] = 0;\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n            else{\n                //????????§???????????°??????????????????????°????\n                int vl = query(a, b, k * 2, l, ( l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return min(vl, vr);\n            }\n        }\n    public:\n        void init(int _n){\n            n = 1;\n            while(n < _n) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n            else{\n                int vl = query(a, b, k * 2, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return min(vl, vr);\n            }\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(r <= a || b <= l) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else if(l < b && a < r){\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n){\n                dat[i] = dat_lazy[i] = INT_MAX;\n            }\n        }\n\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n        void update(int s, int t, int x){\n            update(s, t, 1, 0, n, x);\n        }\n        int get(int a){ return query(a, a + 1); };\n        void print(){\n            show(\"dat\")\n            rep(i,n * 2){ cout << (dat[i + 1] == INT_MAX ? 0 : dat[i + 1]) << ' '; }\n            cout << endl;\n            show(\"lazy\")\n            rep(i,n * 2){ cout << (dat_lazy[i + 1] == INT_MAX ? 0 : dat_lazy[i + 1]) << ' '; }\n            cout << endl;\n            cout << endl;\n        }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n\n    rangeUpdateQuery seg;\n    seg.init(n);\n    rep(i,q){\n        int com;\n        cin >> com;\n        if(com){\n            int x;\n            cin >> x;\n            cout << seg.get(x) << endl;\n        }else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n        //seg.print();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Hideaki Imamura on 2020-03-08.\n//\n# include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair <ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n# define EPS (1e-7)\n# define INF (INT_MAX)\n# define PI (acos(-1))\n//const ll mod = 1000000007;\n\ntemplate<class T>\nvoid print_vec(vector <T> v) {\n    for (auto x : v) {\n        cout << x << \" \";\n    }\n    cout << endl;\n}\n\n#ifndef ALGORITHMS_DATASTRUCTURE_LAZYSEGMENTTREE_H\n#define ALGORITHMS_DATASTRUCTURE_LAZYSEGMENTTREE_H\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1, class F0, class F1, class G, class P> class LazySegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // 定数倍高速化\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    const F0 f0;\n    const T0 u0;\n    // T1上の演算、単位元\n    const F1 f1;\n    const T1 u1;\n    // T0に対するT1の作用\n    const G g;\n    // 多数のt1(T1)に対するf1の合成\n    const P p;\n\n    LazySegmentTree(F0 f0, T0 u0, F1 f1, T1 u1, G g, P p) : f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {}\n    void set_by_vector(const vector<T0>& a) {\n        sz = a.size();\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n        for (int i = 0; i < sz; i++) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    void set_by_unit(int n) {\n        sz = n;\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n    friend string to_string(LazySegmentTree<T0, T1, F0, F1, G, P>& seg) {\n        for (int i = 0; i < seg.sz; i++) seg.query(i);\n        return to_string(vector<T0>(seg.node.begin() + (seg.N - 1), seg.node.begin() + (seg.N - 1 + seg.sz)));\n    }\n};\ntemplate <class T0, class T1, class F0, class F1, class G, class P>\nauto make_lazy_segment_tree(F0 f0, T0 u0, F1 f1, T1 u1, G g, P p) {\n    return LazySegmentTree<T0, T1, F0, F1, G, P>(f0, u0, f1, u1, g, p);\n}\n// Max && Add\n// constexpr Int INF = 1e18;\n// auto seg = make_lazy_segment_tree<Int, Int>(\n//     [](Int x, Int y) { return max(x, y); }, -INF, [](Int x, Int y) { return x + y; }, 0,\n//     [](Int x, Int y) { return x == -INF ? x : x + y; }, [](Int x, int len) { return x; });\n\n#endif //ALGORITHMS_DATASTRUCTURE_LAZYSEGMENTTREE_H\n\n// DSL_2_A\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = INF;\n//    const ll u1 = -INF;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return min(x, y); }, u0,\n//            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n//            [](ll x, ll y) { return y == u1 ? x : y; },\n//            [](ll x, int len) { return x; });\n//    seg.set_by_unit(N);\n//    for (int q= 0; q < Q; ++q) {\n//        ll com, x, y;\n//        cin >> com >> x >> y;\n//        if (com == 0) {\n//            seg.update(x, y);\n//        } else {\n//            cout << seg.query(x, y + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_B\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = 0;\n//    const ll u1 = 0;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return x + y; }, u0,\n//            [](ll x, ll y) { return x + y; }, u1,\n//            [](ll x, ll y) { return x + y; },\n//            [](ll x, int len) { return x * len; });\n//    seg.set_by_unit(N);\n//    for (int q= 0; q < Q; ++q) {\n//        ll com, x, y;\n//        cin >> com >> x >> y;\n//        if (com == 0) {\n//            x--;\n//            seg.update(x, y);\n//        } else {\n//            x--;\n//            y--;\n//            cout << seg.query(x, y + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_D\n//\nint N, Q;\n\nint main() {\n    cin >> N >> Q;\n    const ll u0 = INF;\n    const ll u1 = -INF;\n    auto seg = make_lazy_segment_tree<ll, ll> (\n            [](ll x, ll y) { return y == u0 ? x : y; }, u0,\n            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n            [](ll x, ll y) { return y == u1 ? x : y; },\n            [](ll x, int len) { return x; });\n    seg.set_by_unit(N);\n    for (int q= 0; q < Q; ++q) {\n        ll query;\n        cin >> query;\n        if (query == 0) {\n            ll s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            ll i;\n            cin >> i;\n            cout << seg.query(i, i + 1) << endl;\n        }\n    }\n    return 0;\n}\n\n// DSL_2_F\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    static constexpr ll u0 = INF;\n//    static constexpr ll u1 = - INF;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return min(x, y); }, u0,\n//            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n//            [](ll x, ll y) { return y == u1 ? x : y; },\n//            [](ll x, int len) { return x; });\n//    seg.set_by_vector(vector<ll>(N, INF));\n//    for (int i = 0; i < Q; ++i) {\n//        int q;\n//        cin >> q;\n//        if (q == 0) {\n//            ll s, t, x;\n//            cin >> s >> t >> x;\n//            seg.update(s, t + 1, x);\n//        } else {\n//            int s, t;\n//            cin >> s >> t;\n//            cout << seg.query(s, t + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_G\n//\n//int N, Q;\n//\n//signed main() {\n//    cin >> N >> Q;\n//    auto seg = make_lazy_segment_tree<ll, ll>(\n//            [](ll x, ll y) { return x + y; }, 0,\n//            [](ll x, ll y) { return x + y; }, 0,\n//            [](ll x, ll y) { return x + y; },\n//            [](ll x, int len) { return x * len; });\n//    seg.set_by_unit(N);\n//    for (ll i = 0; i < Q; ++i) {\n//        int q;\n//        cin >> q;\n//        if (q == 0) {\n//            int s, t, x;\n//            cin >> s >> t >> x;\n//            seg.update(s - 1, t, x);\n//        } else {\n//            int s, t;\n//            cin >> s >> t;\n//            cout << seg.query(s - 1, t) << endl;\n//        }\n//    }\n//    return 0;\n//}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[105000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\treturn;\n\t}\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\n\tif (m[node] != -INF) {\n\t\tm[2 * node] = m[node];\n\t\tm[2 * node + 1] = m[node];\n\t\tm[node] = -INF;\n\t}\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{\n\tcout << (1 << 17) << endl;\n\tcin >> n >> q;\n\n\tn=init(n);\n\n\tint a, s, t, x, k;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> k;\n\t\t\tcout << find(k) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, Q;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadIntArray();\n                N = line[0];\n                Q = line[1];\n            }\n\n            var S = new SegTree(N);\n\n            for(int i = 0; i < Q; i++)\n            {\n                var line = Input.ReadIntArray();\n                int C = line[0];\n                if (C == 0)\n                {\n                    int s = line[1];\n                    int t = line[2];\n                    int x = line[3];\n                    if (C == 0) S.Update(s, t+1, x);\n                }\n                else\n                {\n                    int id = line[1];\n                    Console.WriteLine(S.Query(id));\n                }\n            }\n\n        }\n    }\n\n    // libs ----------\n    internal class SegTree\n    {\n        public static bool DEBUG = false;\n\n        public int N;\n        public int NCells;\n        public int H;\n        public int[] Data;\n        public int[] KL; // 範囲のbegin\n        public int[] KR; // 範囲のend（そのセルは含まない）\n        public const int Dummy = -1; \n\n        public SegTree(int _n)\n        {\n            Init(_n);\n        }\n\n        private int GetN(int _n)\n        {\n            int n = 1;\n            H = 1;\n            while (n < _n)\n            {\n                n *= 2;\n                H++;\n            }\n            return n;\n        }\n\n        private void Init(int _n, int initialValue = Dummy)\n        {\n            N = GetN(_n);\n            NCells = 2 * N - 1;\n\n            Data = new int[NCells];\n            KL = new int[NCells];\n            KR = new int[NCells];\n\n            // KL, KRの初期化\n            for (int k = 0; k < NCells; k++)\n            {\n                if (IsRoot(k))\n                {\n                    KL[k] = 0;\n                    KR[k] = N;\n                }\n                else\n                {\n                    if (IsChildL(k))\n                    {\n                        KL[k] = KL[Parent(k)];\n                        KR[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                    }\n                    else\n                    {\n                        KL[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                        KR[k] = KR[Parent(k)];\n                    }\n                }\n            }\n\n            // 値の初期化\n            for (int k = 0; k < NCells; k++) Data[k] = initialValue;\n\n            // 全体に初期値をセット\n            Update(0, N, 2147483647);\n        }\n\n        // i番目のみの値を保持するセル\n        public int Pos(int i) { return i + N - 1; }\n\n        // 親セル・子セル\n        public int Parent(int k) { return (k - 1) / 2; }\n        public int ChildL(int k) { return k * 2 + 1; }\n        public int ChildR(int k) { return k * 2 + 2; }\n\n        // 根かどうか\n        public bool IsRoot(int k) { return k == 0; }\n\n        // 左側の子かどうか\n        public bool IsChildL(int k)\n        {\n            if (IsRoot(k)) return false;\n            return ChildL(Parent(k)) == k;\n        }\n        \n        // Update - top down\n        public void Update(int il, int ir, int a)\n        {\n            update(il, ir, 0, a);\n\n            if (DEBUG)\n            {\n                Console.WriteLine(\"--------------\");\n                int c = 2;\n                for (int i = 0; i < NCells; i++)\n                {\n                    if (i == c - 1)\n                    {\n                        Console.WriteLine();\n                        c *= 2;\n                    }\n                    Console.Write(Data[i] + \" \");\n                }\n                Console.WriteLine();\n                Console.WriteLine(\"--------------\");\n            }\n        }\n\n        private void update(int il, int ir, int k, int a)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return;\n\n            // 完全に重複している場合にその値をセット\n            if (il <= kl && kr <= ir)\n                Data[k] = a;\n            else\n            {\n                // そうでない場合、上の値を分配\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                // 子の処理を行う\n                update(il, ir, ChildL(k), a);\n                update(il, ir, ChildR(k), a);\n            }\n        }\n\n        // Query - bottom up\n        public int Query(int i)\n        {\n            query(i, i + 1, 0);\n            return Data[Pos(i)];\n        }\n\n        private void query(int il, int ir, int k)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n            if (kr <= il || ir <= kl)\n                return;\n\n            if (il <= kl && kr <= ir)\n                return;\n            else\n            {\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                query(il, ir, ChildL(k));\n                query(il, ir, ChildR(k));\n                return;\n            }\n\n        }\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// 区間更新、区間min取得\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_F\n\n\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\n\n\nconst long long INF2 = (((ll)1<<31)-1);\n\ntemplate<class T> class SegTree   // 0-indexed\n{\nprivate:\n    int n;             // 葉の数\n    vector<T> data;    // ノードの値を持つ配列\n    vector<T> lazy;    // 遅延評価を持つ配列\n    vector<bool> lazyflag;   // 遅延評価を行うべきかどうか\n\n    T def;                // 初期値かつ単位元\n    \n    T operation(T a, T b)    // 区間クエリで使う処理\n    {\n        return min(a, b);   // 区間minクエリ\n        //return a+b;           // 区間和クエリ\n    }\n\n    T update(T a, T b)      // 点更新で使う処理\n    {\n        //return a+b;   // 加算の場合\n        return b;       // 更新の場合\n    }\n\n    void eval( int k, int l, int r )   // ノードkについて遅延評価を行う\n    {\n        if(lazyflag[k]) {\n            data[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] = lazy[2*k+2] = lazy[k];\n                lazyflag[2*k+1] = lazyflag[2*k+2] = true;             \n            }\n            lazyflag[k] = false;\n        }\n        return;\n    }\n\n    void _add(int a, int b, T x, int k, int l, int r) {\n        if(r < 0) r = n;\n        eval(k, l, r);   // k 番目のノードに対して遅延評価を行う\n        \n        if(b <= l || r <= a) return;   // 範囲外なら何もしない\n    \n        // 完全に被覆しているならば、遅延配列に値を入れた後に評価\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyflag[k] = true;\n            eval(k, l, r);\n        }\n\n        // そうでないならば、子ノードの値を再帰的に計算して、\n        // 計算済みの値をもらってくる\n        else {\n            _add(a, b, x, 2*k+1, l, (l+r)/2);\n            _add(a, b, x, 2*k+2, (l+r)/2, r);\n            data[k] = operation(data[2*k+1], data[2*k+2]);\n        }\n    }\n\n    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n    T _query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return def; // 交差しない\n\n        eval(k, l, r);\n        if (a <= l && r <= b)\n            return data[k]; // a,l,r,bの順で完全に含まれる\n        else {\n            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n            return operation(c1, c2);\n        }\n    }\n \npublic:\n    SegTree(int _n) {     // _n:必要サイズ\n        def = INF2;        // 初期値かつ単位元（minのときINF2)\n        //def = 0;             // 初期値かつ単位元（和のとき0)\n        n = 1;\n        while (n < _n) n *= 2;\n        data = vector<T>(2 * n - 1, def);\n        lazy = vector<T>(2 * n - 1, 0);\n        lazyflag = vector<bool>(2 * n - 1, false);\n    }\n\n    // 場所i(0-indexed)の値をxで更新\n    void change(int i, T x) {\n        i += n - 1;\n        data[i] = update(data[i], x);\n        while (i > 0) {\n            i = (i - 1) / 2;\n            data[i] = operation(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    // 区間更新\n    void add(int a, int b, T x) {\n        return _add(a, b, x, 0, 0, n);\n    }\n\n    // [a, b)の区間クエリを実行\n    T query(int a, int b) {\n        return _query(a, b, 0, 0, n);\n    }\n \n    // 添字でアクセス\n    T operator[](int i) {\n        return data[i + n - 1];\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    int n,q;\n    scanf(\"%d%d\", &n, &q);\n    SegTree<ll> S(n);\n\n    int i;\n    for(i=0; i<q; i++) {\n        int type, s, t, x;\n        scanf(\"%d\", &type);\n        if(type==0) {\n            scanf(\"%d%d%d\", &s, &t, &x);\n            S.add(s, t+1, x);\n        }\n        else {\n            scanf(\"%d\", &s);\n            ll ans=S.query(s, s+1);\n            printf(\"%lld\\n\", ans);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nll seg[1<<19],n,q;\nvoid add(ll a,ll b,ll r,ll l,ll k,ll x){\n    if(a<=r&&l<=b){\n        seg[k]=x;\n        return;\n    }\n    if(l<a||b<r)return;\n    if(seg[k]>=0){\n        seg[k*2+1]=seg[k];\n        seg[k*2+2]=seg[k];\n        seg[k]=-1;\n\n    }\n    add(a,b,r,(r+l-1)/2,k*2+1,x);\n    add(a,b,(r+l+1)/2,l,k*2+2,x);\n}\nll find(ll x,ll r,ll l,ll k){\n    if(seg[k]>=0)return seg[k];\n    if((r+l-1)/2>=x)return find(x,r,(r+l-1)/2,k*2+1);\n    else return find(x,(r+l+1)/2,l,k*2+2);\n}\nint main(void){\n    cin>>n>>q;\n    for(ll i=0;i<(1<<19)-1;i++)seg[i]=-1;\n    seg[0]=2147483647;\n    for(ll i=0;i<q;i++){\n        ll a;\n        cin>>a;\n        if(a){\n            ll x;\n            cin>>x;\n            cout<<find(x,0,(1<<18)-1,0)<<endl;\n        }else{\n            ll s,t,x;\n            cin>>s>>t>>x;\n            add(s,t,0,(1<<18)-1,0,x);\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nconst ll INF=(1ll<<31)-1;\nint a[100001];\nint b[1005];\nint main(){\n    int n,q;\n    cin>>n>>q;\n    int sqn=sqrt(n);\n    int bn=(n+sqn-1)/sqn;\n    rep(i,n) a[i]=INF;\n    rep(i,bn) b[i]=INF;\n    int com;\n    rep(i,q){\n        cin>>com;\n        if(com==0){\n            int s,t,x;\n            //[s,t)\n            cin>>s>>t>>x;\n            ++t;\n            rep(j,bn+1){\n                int l=j*sqn,r=(j+1)*sqn;\n                if(r<=s||t<=l) continue;\n                if(s<=l&&r<=t) b[j]=x;\n                else{\n                    FOR(k,max(s,l),min(t,r)){\n                        a[k]=x;\n                    }\n                }\n            }\n        }\n        if(com==1){\n            int k;\n            cin>>k;\n            int cur=k/sqn;\n            if(b[cur]!=INF){\n                FOR(j,cur*sqn,(cur+1)*sqn){\n                    a[j]=b[cur];\n                }\n                b[cur]=INF;\n            }\n            cout<<a[k]<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n/*\nstruct M_act {\n   using T = _operand_set_; // ?????¨???????????´???????????????\n   using Monoid = _operator_monoid_; // ?????¨?´???¢?????????\n   T operator()(const Monoid::T& m, const T& a) { return _m_act_a_; } // ?????¨??????\n};\nstruct Monoid {\n   using T = _underlying_set_; // ??¢??????????????°????????????\n   T operator()(const T& a, const T& b) { return _a_op_b_; } // ????????????\n   static constexpr T identity() { return _identity_element_; } // ?????????\n};\n*/\n\nstruct Monoid {\n   using T = int; // ??¢??????????????°????????????\n   T operator()(const T& a, const T& b) { return a == INT_MAX ? b : a; } // ????????????\n   static constexpr T identity() { return INT_MAX; } // ?????????\n};\nstruct M_act {\n    using T = int; // ?????¨???????????´???????????????\n    using Monoid = Monoid; // ?????¨?´???¢?????????\n    T operator()(const Monoid::T& m, const T& a) { return m == INT_MAX ? a : m; } // ?????¨??????\n};\n\n\ntemplate <class M_act>\nclass SegTree {\n    private:\n        using T = typename M_act::T; // ?????¨???????????´????????????????????¨????????¢???\n        using M = typename M_act::Monoid::T; // ?????¨?´???¢??????????????°???????????¨????????¢???\n        M_act action; // ?????¨?????????\n        typename M_act::Monoid op; // ?????¨?´???¢?????????????????????\n        const int n, h; // ?????????????????¨?????????\n        vector<T> dat; // ?????????\n        vector<M> lazy; // ????????§?????????????????????????§?????????¨????????????????????????????????¨?????????????????°???????????§????????§?????????n??§??????\n        bool has_lazy; // ??????????????§??????????????????????????¨????????????????????????????????°\n\n        void act(int i, const M& m) { // ?????????i????????¨\n            if (i < n) lazy[i] = op(m, lazy[i]); // ?????¨????????????????????¨??¨?????¨????????¨?´???¢????????????????????§?????¨??????\n            else {\n                i -= n;\n                dat[i] = action(m, dat[i]); // ??????????????¨????????¨???????????????\n            }\n        }\n\n        void prop_from(int i) { // ?????????i????????¨??????????????????\n            act(i << 1, lazy[i]);\n            act(i << 1 | 1, lazy[i]);\n            lazy[i] = op.identity();\n        }\n\n        void prop_to(int i) { // i???????????????????????¨?????¨???????????§??????????????????\n            i += n;\n            for (int s = (i >> h ? h : h-1); s > 0; --s) prop_from(i >> s);\n        }\n\n    public:\n        SegTree(int n) : n(n), h(log(n)), dat(n, op.identity()), lazy(n, op.identity()), has_lazy() {} // ????§????x??§??????????????????????????????\n        SegTree(const vector<T>& v) : n(v.size()), h(__lg(n)), dat(v), lazy(n, op.identity()), has_lazy() {} // ????????????vector??§???????????????????????????\n\n        void act(int l, int r, const M& m) { // [l, r)???m????????¨?????????\n            prop_to(l);\n            prop_to(r-1);\n            l += n, r += n;\n            for (; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) act(l++, m);\n                if (r & 1) act(r-1, m);\n            }\n            has_lazy = true;\n        }\n\n        void prop() { // ?????????????????¨???????????¨???????????§?????????\n            for (int i = 1; i < n; ++i) prop_from(i);\n            has_lazy = false;\n        }\n\n        void set(int i, const T& x) { // i????????????????????´??°\n            prop_to(i);\n            dat[i] = x;\n        }\n        void add(int i, const T &x){\n            set(i, get(i) * x);\n        }\n\n        T get(int i) { // i?????????????????????\n            if (!has_lazy) return dat[i]; // ????????????????????¨?????????????????????????????????\n            T ret = dat[i];\n            i += n;\n            while (i >>= 1) ret = action(lazy[i], ret); // ????????§????????????????????§?????£???????????????????????????????????§????????¨????¢???£?????????\n            return ret;\n        }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n\n    SegTree<M_act> seg(n);\n    rep(i,q){\n        int com;\n        cin >> com;\n        if(com){\n            int x;\n            cin >> x;\n            cout << seg.get(x) << endl;\n        }else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.act(s, t + 1, x);\n        }\n        //seg.print();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = INT_MAX;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct SegTree {\n    int n;\n    vi node, lazy;\n\n    SegTree(int sz){\n        n = 1; while(n < sz) n *= 2;\n        node = vi(2 * n - 1, inf);\n        lazy = vi(2 * n - 1, -1);\n    }\n\n    void eval(int k, int l, int r){\n        int& cur = lazy[k];\n        if(cur == -1) return;\n        node[k] = cur;\n        if(r - l > 1){\n            lazy[2 * k + 1] = cur;\n            lazy[2 * k + 2] = cur;\n        }\n        cur = -1;\n    }\n\n    // node[a:b] := x\n    void update(int a, int b, int x, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n\n        eval(k, l, r);\n        if(a >= r or l >= b) return;\n        if(a <= l and r <= b){\n            lazy[k] = x;\n            eval(k, l, r);\n            return;\n        }\n\n        update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n        update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n        node[k] = min(node[2 * k + 1], node[2 * k + 2]);\n    }\n\n    int getmin(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        \n        eval(k, l, r);\n        if(a >= r or  l >= b) return inf;\n        if(a <= l and r <= b) return node[k];\n\n        return min(getmin(a, b, 2 * k + 1, l, (l + r) / 2), \n                   getmin(a, b, 2 * k + 2, (l + r) / 2, r));\n    }\n};\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, Q; cin >> n >> Q;\n    SegTree seg(n);\n    rep(loop, Q){\n        int op; cin >> op;\n        if(op == 0){\n            int s, t, x; cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n        else {\n            int i; cin >> i;\n            cout << seg.getmin(i, i + 1) << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define max0(a,b,c) max(max(a,b),c)\n#define min0(a,b,c) min(min(a,b),c)\n#define ft first\n#define sc second\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define mod 1000000007\nusing namespace std;\nusing Graph = vector<vector<int>>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ldouble;\ntypedef vector<int> vec;\ntypedef vector<ll> lvec;\ntypedef vector<ull> ulvec;\ntypedef vector<double> dvec;\ntypedef vector<pair<int,int>> pvec;\ntypedef vector<pair<ll,ll>> plvec;\ntypedef vector<tuple<ll,ll,ll>> tvec;\ntypedef vector<string> svec;\n\nconst int INF=(1LL<<31)-1,MAX_N=1000000;\nint n;\nint d[MAX_N*2];\n\nvoid init(int _n){\n    n=1;\n    while(n<_n) n*=2;\n    for(int i=0;i<2*n-1;i++) d[i]=INF;\n}\n\nvoid update(int a,int b,int k,int l,int r,int x){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n        d[k]=x;\n    }else{\n        if(d[k]!=INF){\n            d[2*k+1]=d[k];\n            d[2*k+2]=d[k];\n            d[k]=INF;\n        }\n        int m=(l+r)/2;\n        if(m>=b) update(a,b,2*k+1,l,m,x);\n        else if(m<=a) update(a,b,2*k+2,m,r,x);\n        else{\n            update(a,b,2*k+1,l,(l+r)/2,x);\n            update(a,b,2*k+2,(l+r)/2,r,x);\n        }\n    }\n}\n\nint find(int i,int k,int l,int r){\n    if(d[k]!=INF) return d[k];\n    if(r-l==1) return d[k];\n    int m=(l+r)/2;\n    if(i<m) return find(i,2*k+1,l,m);\n    return find(i,2*k+2,m,r);\n}\n\nint main(){\n    int N,q;\n    cin>>N>>q;\n    init(N);\n    rep(i,q){\n        int a;\n        cin>>a;\n        if(a==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            update(s,t+1,0,0,n,x);\n        }else{\n            int x;\n            cin>>x;\n            cout<<find(x,0,0,n)<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nconst int MAX_N = 1 << 19;\nconst int INIT_VALUE = INT_MAX;\nconst int INIT_LAZY = INT_MAX;\n//?????°???????????¨???????????°??????????????????\nint SIZE, dat[MAX_N], lazy[MAX_N];\n\n//?????????\nvoid init(int n_) {\n\t//?°????????????????????´???°???2???????????????\n\t//n_????¬???????????´???°, SIZE???????????°, 2*SIZE-1??????????´???°\n\tSIZE = 1;\n\twhile (SIZE < n_) {\n\t\tSIZE *= 2;\n\t}\n\t//??????????????????0???\n\tfor (int i = 0; i < 2 * SIZE - 1; i++) {\n\t\tdat[i] = INIT_VALUE;\n\t\tlazy[i] = INIT_LAZY;\n\t}\n}\n\nvoid setLazy(int k, int x){\n\tlazy[k] = x;\n\tdat[k] = x;\n}\n\nvoid lazy_evaluate(int k) {\n\tif(lazy[k]==INIT_LAZY){\n\t\treturn;\n\t}\n\tdat[k] = lazy[k];\n\tsetLazy(k*2+1, lazy[k]);\n\tsetLazy(k*2+2, lazy[k]);\n\tlazy[k] = INIT_LAZY;\n}\n\nvoid fix(int k){\n\tdat[k] = min(dat[k*2+1], dat[k*2+2]);\n}\n\nvoid update(int a, int b, int k, int l, int r, int x){\n\tif(b<=l || r<=a){\n\t\treturn;\n\t}\n\tif(a<=l&&r<=b){\n\t\tsetLazy(k, x);\n\t}else{\n\t\tlazy_evaluate(k);\n\t\tupdate(a, b, k*2+1, l, (l+r)/2, x);\n\t\tupdate(a, b, k*2+2, (l+r)/2, r, x);\n\t\tfix(k);\n\t}\n}\n\nint get(int a, int b, int k, int l, int r){\n\tif(b<=l || r<=a){\n\t\treturn INIT_VALUE;\n\t}\n\tif(a<=l&&r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\tint vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\tint vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint N, Q;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/AtCoder/jni/in.txt\");\n\tcin >> N >> Q;\n\tinit(N);\n\trep(q,0,Q)\n\t{\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(s, t+1, 0, 0, SIZE, x);\n\t\t} else {\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << get(i, i+1, 0, 0, SIZE) << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q;\nint const INF = INT_MAX;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<int> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    LazySegmentTree(vector<int> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, INF);\n        lazyFlag.resize(2*n-1, false);\n\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n\n    // k ?????????????????? ( ??????????????? [l, r) ) ?????????????????¶??????\n    void lazy_evaluate(int k, int l, int r) {\n        // ?????? lazy ???????????\\??£??????????????????\n        // ??????????????¨????????? (??? lazy) ???????????????????????????\n        if(lazyFlag[k]) {\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] = lazy[k];\n                lazy[2*k+2] = lazy[k];\n                lazyFlag[2*k+1] = true;\n                lazyFlag[2*k+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n\n    // [a, b) ??????????´??????¨??? x ?????´??°??????\n    // ????????????????????? k ??¨??????????????????????????????????????? [l, r) ??§??????\n    void update(int a, int b, int x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        lazy_evaluate(k, l, r);\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            lazy_evaluate(k, l, r);\n        }\n        else {\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[k*2+1], node[k*2+2]);\n        }\n    }\n\n    int find(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        lazy_evaluate(k, l, r);\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        int vl = find(a, b, 2*k+1, l, (l+r)/2);\n        int vr = find(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint main() {\n    cin >> N >> Q;\n    LazySegmentTree seg( vector<int>(N, INF) );\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }\n        else {\n            int i; cin >> i;\n            cout << seg.find(i, i+1) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = (int)((1ll << 31) - 1);\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\nnamespace Union_Find{\n    const int N = 1e4 + 7;\n    int f[N], n, m;\n\n    void init(int n){\n        for (int i = 0; i <= n; i++) f[i] = i;\n    }\n\n    int find_fa(int x){ return x == f[x] ? x : f[x] = find_fa(f[x]); }\n\n    void unite(int x, int y){\n        int rx = find_fa(x), ry = find_fa(y);\n        if (rx != ry) f[max(rx, ry)] = min(rx, ry);\n    }\n}\n\nnamespace Segment_Tree1{ // Interval minimum val with single point change\n    const int N = 1e5 + 7;\n    struct node{\n        int l, r, val, mn;\n    };\n    node T[N << 2];\n    int n, m;\n\n    #define ls(x) (x << 1)\n    #define rs(x) (x<<1|1)\n\n    void build(int rt, int l, int r){\n        T[rt].l = l, T[rt].r = r, T[rt].val = INF;\n        if (r <= l) return;\n        int mid = (l + r) >> 1;\n        build(ls(rt), l, mid);\n        build(rs(rt), mid + 1, r);\n    }\n\n    void pushup(int rt){ T[rt].val = min(T[ls(rt)].val, T[rs(rt)].val); }\n\n    void update(int rt, int l, int r, int val){\n        if (T[rt].l > r || T[rt].r < l) return;\n        if (l <= T[rt].l && T[rt].r <= r) { T[rt].val = val; return; }\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        if (l <= mid) update(ls(rt), l, r, val);\n        if (r > mid) update(rs(rt), l, r, val);\n        pushup(rt);\n    }\n\n    int query(int rt, int l, int r){\n        if (T[rt].l > r || T[rt].r < l) return INF;\n        if (l <= T[rt].l && T[rt].r <= r) return T[rt].val;\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        int ret = INF;\n        if (l <= mid) ret = min(ret, query(ls(rt), l, r));\n        if (r > mid) ret = min(ret, query(rs(rt), l, r));\n        return ret;\n    }\n}\n\nnamespace Segment_Tree2{ //single point change, with interval sum query \n    const int N = 1e5 + 7;\n    struct node{\n        int l, r;\n        LL sum;\n    };\n    node T[N << 2];\n    int n, m;\n\n    #define ls(x) (x << 1)\n    #define rs(x) (x<<1|1)\n\n    void build(int rt, int l, int r){\n        T[rt].l = l, T[rt].r = r, T[rt].sum = 0;\n        if (r <= l) return;\n        int mid = (l + r) >> 1;\n        build(ls(rt), l, mid);\n        build(rs(rt), mid + 1, r);\n    }\n\n    void pushup(int rt){ T[rt].sum = T[ls(rt)].sum + T[rs(rt)].sum; }\n\n    void update(int rt, int l, int r, int val){\n        if (T[rt].l > r || T[rt].r < l) return;\n        if (l <= T[rt].l && T[rt].r <= r) { T[rt].sum += val; return; }\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        if (l <= mid) update(ls(rt), l, r, val);\n        if (r > mid) update(rs(rt), l, r, val);\n        pushup(rt);\n    }\n\n    LL query(int rt, int l, int r){\n        if (T[rt].l > r || T[rt].r < l) return INF;\n        if (l <= T[rt].l && T[rt].r <= r) return T[rt].sum;\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        LL ret = 0;\n        if (l <= mid) ret += query(ls(rt), l, r);\n        if (r > mid) ret += query(rs(rt), l, r);\n        return ret;\n    }\n\n    int main(){\n        scanf(\"%d%d\", &n, &m);\n        build(1, 1, n);\n        for (int i = 0; i < m; i++){\n            int op, x, y;\n            scanf(\"%d\", &op);\n            if (op){\n                scanf(\"%d%d\", &x, &y); \n                printf(\"%lld\\n\", query(1, x, y));\n            }\n            else{\n                scanf(\"%d%d\", &x, &y);\n                update(1, x, x, y);\n            }\n        }\n        return 0;\n    }\n}\n\nconst int N = 1e5 + 7;\nstruct node{\n    int l, r, val, tag;\n};\nnode T[N << 2];\nint n, m;\n\n#define ls(x) (x << 1)\n#define rs(x) (x<<1|1)\n\nvoid build(int rt, int l, int r){\n    T[rt].l = l, T[rt].r = r, T[rt].val = INF, T[rt].tag = 1;\n    if (r <= l) return;\n    int mid = (l + r) >> 1;\n    build(ls(rt), l, mid);\n    build(rs(rt), mid + 1, r);\n}\n\nvoid push_down(int rt){ \n    if (T[rt].tag == 1) {\n        T[ls(rt)].val = T[rs(rt)].val = T[rt].val; \n        T[ls(rt)].tag = T[rs(rt)].tag = 1;\n        T[rt].tag = -1;\n    }\n}\n\nvoid update(int rt, int l, int r, int val){\n    if (T[rt].l > r || T[rt].r < l) return;\n    if (l <= T[rt].l && T[rt].r <= r) { T[rt].val = val; T[rt].tag = 1; return; }\n    int mid = (T[rt].l + T[rt].r) >> 1;\n    push_down(rt);\n    if (l <= mid) update(ls(rt), l, r, val);\n    if (r > mid) update(rs(rt), l, r, val);\n}\n\nint query(int rt, int l, int r){\n    if (T[rt].l > r || T[rt].r < l) return INF;\n    if (l <= T[rt].l && T[rt].r <= r) return T[rt].val;\n    int mid = (T[rt].l + T[rt].r) >> 1;\n    push_down(rt);\n    if (l <= mid) return query(ls(rt), l, r);\n    if (r > mid) return query(rs(rt), l, r);\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    build(1, 1, n);\n    for (int i = 0; i < m; i++){\n        int op, x, y, val;\n        scanf(\"%d\", &op);\n        if (op){\n            scanf(\"%d\", &x); x++;\n            printf(\"%d\\n\", query(1, x, x));\n        }\n        else{\n            scanf(\"%d%d%d\", &x, &y, &val); x++, y++;\n            update(1, x, y, val);\n        }\n    }   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nconst PII DATA_NIL = PII(-1, (1LL<<31) - 1);\n\nclass SegmentTree {\nprivate:\n    const int n;\n    vector<PII> dat;\n    void prop_to(int i) { dat[i] = max(dat[i<<1], dat[i<<1|1]); }\n\npublic:\n    SegmentTree(int _n) : n(_n), dat(2*n, DATA_NIL) {}\n\n    void fill(int l, int r, PII x)\n    {\n        l += n, r += n;\n        for (; l<r; l >>= 1, r >>= 1) {\n            if (l & 1) { dat[l] = max(dat[l], x); l++; }\n            if (r & 1) dat[r-1] = max(x, dat[r-1]);\n        }\n    }\n\n    int get(int i)\n    {\n        PII res = dat[i += n];\n        while (i >>= 1) { res = max(res, dat[i]); }\n        return res.second;\n    }\n\n    void dump()\n    {\n        cerr << \"-----------\" << endl;\n        int h = __lg(2*n);\n        for (int i=1; i<=h; i++) {\n            for (int j=0; j<1<<(i-1); j++) cerr << dat[(1<<(i-1)) + j].second << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------\" << endl;\n    }\n};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    int n = 1;\n    while (n < N) { n <<= 1; }\n    SegmentTree seg_tree(n);\n\n    rep(q, Q) {\n        int T; cin >> T;\n        if (T == 0) {\n            int A, B, X; \n            cin >> A >> B >> X;\n            seg_tree.fill(A, B+1, PII(q, X));\n        } else {\n            int I; cin >> I;\n            cout << seg_tree.get(I) << endl;\n        }\n        // seg_tree.dump();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nint a[100000];\n\nint main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\n\tfill(a, a + n, 2147483647);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tcin >> c;\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tcin >> s >> t >> v;\n\t\t\tfill(a + s, a + t + 1, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcin >> s;\n\t\t\tcout << a[s] << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define INF      2147483647\ntypedef unsigned int uint;\n\nuint n_array;\nuint queries;\nvector<uint> D;\n\nvoid init(uint n_req){\n  n_array = 1;\n  while( n_array < n_req ){\n    n_array *= 2;\n  }\n  D.resize(2*n_array-1);\n  for( uint i = 0 ; i <= 2*n_array-1 ; i++ ){\n    D[i] = INF;\n  }\n}\n\nvoid update(uint k, uint a){\n  k += n_array - 1; // convert array index to tree index\n  D[k] = a;\n  while( k > 0 ){\n    k = (k-1) / 2;\n    D[k] = min( D[k*2+1] ,D[k*2+2] );\n  }\n}\n\nvoid updateRange(const uint s, const uint t, const uint x){\n  for(uint i=s ; i <= t ; i++){\n    update(i,x); \n  }\n\n}\n\nuint query(uint a, uint b, uint k, uint l, uint r) {\n  if( r <= a || b <= l ){ // case 1\n    return INF;\n  }else if( a<= l && r <= b ){ // case 2\n    return D[k];\n  }\n  // case 3\n  uint vl = query( a, b, k*2+1, l, (l+r)/2 );\n  uint vr = query( a, b, k*2+2, (l+r)/2, r );\n  return min( vl, vr );\n}\n\nuint findMin(uint a, uint b){\n  return query(a, b+1, 0, 0, n_array);\n}\n\nvoid printD(){\n  int i = 0;\n  for (const auto& e : D) {\n     printf(\"[%d]\" ,i); i++;\n     std::cout << e << std::endl;\n  }\n}\n\nint main(){\n  uint n_req;\n  scanf(\"%d %d\" ,&n_req ,&queries);\n  init(n_req);\n  for(uint i = 0 ; i < queries ; i++){\n    uint com;\n    scanf(\"%d\" ,&com ); \n    if( com== 0){\n      uint s, t, x;\n      scanf(\"%d %d %d\" ,&s ,&t ,&x );\n      updateRange(s,t,x);\n    }else{\n      uint idx;\n      scanf(\"%d\" ,&idx );\n      idx += n_array - 1;  // convert array index to tree index\n      printf(\"%d\\n\" ,D[idx]);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<climits>\nusing namespace std;\nstatic const int MAX_N = 100000;\n \nint n, q;\n \nint n_;\nint laz[4 * MAX_N];\n \nvoid init(){\n    n_ = 1;\n    while(n_ < n) n_ *= 2;\n    for(int i = 0; i < 2 * n_ - 1; i++){\n        laz[i] = -1;\n    }\n    laz[0] = INT_MAX;\n}\nvoid prop(int len, int k){\n    if(laz[k] == -1) return;\n    if(2 * k + 1 < 2 * n_ - 1){\n        laz[2 * k + 1] = laz[k];\n        laz[2 * k + 2] = laz[k];\n    }\n}\nvoid update(int a, int b, int x, int k, int l, int r){\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b){\n        laz[k] = x;\n        return;\n    }\n    prop(r - l, k);\n    laz[k] = -1;\n    update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n    update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n}\n         \nint find(int index, int len, int k){\n    if(laz[k] != -1) return laz[k];\n    if(2 * k + 1 >= 2 * n_ - 1) return laz[k];\n    int diff = ((index % len < len / 2) ? 1 : 2);\n    return find(index, len / 2, 2 * k + diff);\n}\n \nint main(){\n    scanf(\"%d %d\", &n, &q);\n    init();\n    for(int i = 0; i < q; i++){\n        int op;\n        scanf(\"%d\", &op);\n        if(op == 0){\n            int s, t, x;\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update(s, t + 1, x, 0, 0, n_);\n        }else if(op == 1){\n            int index;\n            scanf(\"%d\", &index);\n            printf(\"%d\\n\", find(index, n_, 0));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nconst int MAX_N=1<<17; //nの2倍くらい\nconst ll INF=(1LL<<31)-1;\n// RSQ&RAQ\n/*\nstruct LazySegmentTree{\n    ll node[2*MAX_N-1], lazy[2*MAX_N-1], SIZE; //SIZE:nを２べきにしたもの\n    \n    //初期化\n    void init(int n_){\n        //要素数を2べきに\n        SIZE=1;\n        while(SIZE<n_) SIZE*=2;\n        \n        //全ての値をI_MAXに\n        rep(i,0,2*SIZE-1) node[i]=0;\n    }\n    \n    //k番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r){\n        // 遅延配列が空でない場合、自ノード及び子ノードへの値の伝播が起こる\n        if(lazy[k]!=0){\n            node[k]+=lazy[k];\n            // 最下段かどうかのチェックをしよう\n            if(r-l>1){\n                lazy[2*k+1]+=lazy[k]/2;\n                lazy[2*k+2]+=lazy[k]/2;\n            }\n            // 伝播が終わったので、自ノードの遅延配列を空にする\n            lazy[k] = 0;\n        }\n    }\n    \n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else{\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=node[2*k+1]+node[2*k+2];\n        }\n    }\n    \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        if(b <= l || r <= a) return 0;\n        eval(k,l,r);\n        if(a <= l && r <= b) return node[k];\n        ll vl=getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getsum(a, b, 2*k+2, (l+r)/2, r);\n        return vl+vr;\n    }\n};\n*/\n\n//RMQ&RUQ\nstruct LazySegmentTree{\n    ll node[2*MAX_N-1], lazy[2*MAX_N-1], SIZE; //SIZE:nを２べきにしたもの\n    bool lazyflag[2*MAX_N-1];\n    \n    //初期化\n    void init(int n_){\n        //要素数を2べきに\n        SIZE=1;\n        while(SIZE<n_) SIZE*=2;\n        \n        //全ての値をI_MAXに\n        rep(i,0,2*SIZE-1) node[i]=INF;\n    }\n    \n    //k番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r){\n        // 遅延配列が空でない場合、自ノード及び子ノードへの値の伝播が起こる\n        if(lazyflag[k]){\n            node[k]=lazy[k];\n            // 最下段かどうかのチェックをしよう\n            if(r-l>1){\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyflag[k*2+1] = lazyflag[k*2+2] = true;\n            }\n            lazyflag[k] = false;\n        }\n    }\n    \n    void update(int a, int b, ll x, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyflag[k]=true;\n            eval(k, l, r);\n        }\n        else{\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=min(node[2*k+1], node[2*k+2]);\n        }\n    }\n    \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl=getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nLazySegmentTree S;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n,q;\n    cin>>n>>q;\n    S.init(n);\n    rep(i,0,q){\n        int b;\n        cin>>b;\n        if(b){\n            int i;\n            cin>>i;\n            cout<<S.getmin(i, i+1)<<\"\\n\";\n        }\n        else{\n            int s,t;\n            cin>>s>>t;\n            ll x;\n            cin>>x;\n            S.update(s, t+1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1<<20)\n#define NIL -1\n\nstruct RUQ {\n\tint N;\n\tint a[N_SIZE];\n\tint seg[N_SIZE * 2];\n\tint lazy[N_SIZE * 2];\n\tint gt;\n\tvoid init(int n) {\n\t\tN = n;\n\t\tgt = 1;\n\t\twhile (N > gt)gt *= 2;\n\t\tREP(i, n)a[i] = (1LL << 31) - 1;\n\t\tREP(i, N_SIZE) {\n\t\t\tseg[i] = (1LL << 31) - 1;\n\t\t\tlazy[i] = NIL;\n\t\t}\n\t\tREP(i, n)seg[i + gt - 1] = a[i];\n\t}\n\tvoid update(int a, int b,int x) {\n\t\tupdate(a, b, 0, 0, gt, x);\n\t}\n\n\tvoid lazy_evaluate(int k) {\n\t\tseg[k] = lazy[k];\n\t\tif (k < gt) {\n\t\t\tif (lazy[2 * k + 1] != NIL)lazy[2 * k + 1] = lazy[k];\n\t\t\tif (lazy[2 * k + 1] != NIL)lazy[2 * k + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = NIL;\n\t}\n\n\tvoid update(int a, int b, int k, int l, int r, int x) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = x;\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, 2 * k + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, 2 * k + 2, (l + r) / 2, r, x);\n\t\t}\n\t}\n\n\tll query(int k) {\n\t\tk += gt - 1;\n\t\twhile (lazy[k] == NIL && k)k = (k - 1) / 2;\n\t\tif (lazy[k] != NIL)lazy_evaluate(k);\n\t\treturn seg[k];\n\t}\n\n\tvoid print() {\n\t\tREP(i, gt * 2) {\n\t\t\tcout << \"!\" << i << \" \" << seg[i] << \" \" << lazy[i] << endl;\n\t\t}\n\t}\n};\n\nRUQ ruq;\n\nint n, q;\n\nint main() {\n\tcin >> n >> q;\n\truq.init(n);\n\tREP(i, q) {\n\t\tint s, t, x;\n\t\tbool f;\n\t\tcin >> f;\n\t\tif (!f) {\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tcin >> x;\n\t\t\tcout << ruq.query(x) << endl;\n\t\t}\n\t\t//ruq.print();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n//const int MAX_N = (1 << 17)+1;\nconst int MAX_N = (1 << 10)+1;\nstruct RUQ{\n\tint n;\n\tint datx[MAX_N*2 - 1];\n\tint datc[MAX_N*2 - 1];\n\t//n?????????????????¨?????¨????????????\n\tvoid init(int n_){\n\t\tn = 1;\n\t\twhile(n<n_)n*=2;//n????????????????????§????????¨update????????°???\n\t\tREP(i,2*n-1)datx[i] = INT_MAX;\n\t\tREP(i,2*n-1)datc[i] = -1;\n\t}\n\t//[a,b)?????????x????????´(c)\n\tvoid update(int a,int b,int x,int c,int k,int l,int r){\n\t\tif(r <= a || b <= l)return;\n\t\tif(a <= l && b >= r){\n\t\t\tdatx[k] = x;\n\t\t\tdatc[k] = c;\n\t\t}else{\n\t\t\tupdate(a,b,x,c,k*2+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,c,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\t//a[i]?????????\n\tint query(int i){\n\t\ti += n-1;\n\t\tint c = -2;\n\t\tint x;\n\t\twhile(i>0){\n\t\t\tif(datc[i] > c){\n\t\t\t\tx = datx[i];\n\t\t\t\tc = datc[i];\n\t\t\t}\n\t\t\ti = (i-1)/2;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint n,q;\n\tcin >> n >> q;\n\tRUQ ruq;ruq.init(n);\n\tREP(i,q){\n\t\tint q;\n\t\tcin >> q;\n\t\tif(q){\n\t\t\tint j;cin >>j;\n\t\t\tcout << ruq.query(j) << endl;\n\t\t}else{\n\t\t\tint a,b,x;\n\t\t\tcin >> a>>b>>x;\n\t\t\tb++;\n\t\t\truq.update(a,b,x,i,0,0,ruq.n);\n\t\t}\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define int long long\nconst int INF = (1LL << 31) - 1;\nconst int MAX = 1<<9;\nstruct LazySegmentTree {\n  int N, K;\n  vector<int> D;\n  vector<bool> lazyFlag;\n  vector<int> lazy;\n  LazySegmentTree(int n) : N(n) {\n    K = (N + MAX - 1) / MAX;\n    D.assign(K * MAX, INF);\n    lazyFlag.assign(K, false);\n    lazy.assign(K, 0);\n  }\n  void eval(int k) {\n    if (lazyFlag[k]) {\n      lazyFlag[k] = false;\n      for (int i = k * MAX; i < (k + 1) * MAX; ++i) {\n        D[i] = lazy[k];\n      }\n    }\n  }\n\n  void update(int s, int t, int x) {\n    for (int k = 0; k < K; ++k) {\n      int l = k * MAX, r = (k + 1) * MAX;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        lazyFlag[k] = true;\n        lazy[k] = x;\n      } else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          D[i] = x;\n        }\n      }\n    }\n  }\n  int find(int i) {\n    int k = i / MAX;\n    eval(k);\n    return D[i];\n  }\n};\n\nsigned main() {\n  int p, q;\n  cin >> p >> q;\n  LazySegmentTree segtree(p);\n  for(int i=0; i<q; i++)  {\n    int com;\n    cin >> com;\n    if (com == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      segtree.update(s, t + 1, x);\n    } else {\n      int i;\n      cin >> i;\n      cout << segtree.find(i) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n\n  fill(a,a+n,2147483647);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      fill_n(a+s,t,x);\n    }\n    else{\n      int x;\n      cin >> x;\n      cout << a[x] << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  int a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  int lazy[nsq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+nsq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t  lazy[t/sq] = -1;\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,E)> G;\n  typedef function<T(E,E)> H;\n  int n;\n  G g;\n  H h;\n  T d1;\n  E d0;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(){};\n  SegmentTree(int n_,G g,H h,T d1,E d0,\n\t      vector<T> v=vector<T>()):\n    g(g),h(h),d1(d1),d0(d0){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(n,d1);\n    laz.clear();\n    laz.resize(2*n-1,d0);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i]=v[i];\n  }\n  void eval(int k){\n    if(k*2+1<2*n-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n      laz[k]=d0;\n    }\n  }\n  \n  void update(int a,int b,E x,int k,int l,int r){\n    eval(k);\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return;\n    }\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n  void update(int a,int b,E x){\n    update(a,b,x,0,0,n);\n  }\n  void eval2(int k){\n    if(k) eval2((k-1)/2);\n    eval(k);\n  }\n  \n  T query(int k){\n    T c=dat[k];\n    k+=n-1;\n    eval2(k);\n    return g(c,laz[k]);\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> beet(n,\n\t\t\t    [&](int a,int b){ return b<0?a:b;},\n\t\t\t    [&](int a,int b){ return b<0?a:b;},\n\t\t\t    INT_MAX,-1);\n  for(int i=0;i<q;i++){\n    int c;\n    cin>>c;\n    if(c){\n      int x;\n      cin>>x;\n      cout<<beet.query(x)<<endl;\n    }else{\n      int s,t,x;\n      cin>>s>>t>>x;\n      t++;\n      beet.update(s,t,x);\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/10/15\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T>inline bool chmax(T &a, T b){return (a < b ? a = b, true : false);}\ntemplate<typename T>inline bool chmin(T &a, T b){return (a > b ? a = b, true : false);}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst long double EPS = 1e-9;\n\ntemplate<typename T>\nclass RangeUpdateQuery {\nprivate:\n\tvector<T> data, lazy;\n\tvector<bool> valid, lazyFlag;\n\tint sz;\n\tvoid push(int l, int r, int k) {\n\t\tif (lazyFlag[k]) {\n\t\t\tvalid[k] = true;\n\t\t\tdata[k] = lazy[k];\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[2 * k + 1] = lazy[2 * k + 2] = lazy[k];\n\t\t\t\tlazyFlag[2 * k + 1] = lazyFlag[2 * k + 2] = true;\n\t\t\t}\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\tvoid update(int l, int r, int L, int R, int k, T val) {\n\t\tpush(l, r, k);\n\t\tif (L <= l && r <= R) {\n\t\t\tlazyFlag[k] = true;\n\t\t\tlazy[k] = val;\n\t\t\tpush(l, r, k);\n\t\t} else if (l < R && L < r) {\n\t\t\tconst int buf = (l + r) / 2;\n\t\t\tthis->update(l, buf, L, R, k * 2 + 1, val);\n\t\t\tthis->update(buf, r, L, R, k * 2 + 2, val);\n\t\t}\n\t}\n\tT query(int l, int r, int k, int idx) {\n\t\tpush(l, r, k);\n\t\tif (r - l == 1) {\n\t\t\tif (!valid[k]) {\n\t\t\t\tthrow exception();\n\t\t\t}\n\t\t\treturn data[k];\n\t\t}\n\t\tif (l <= idx && idx <= r) {\n\t\t\tif (idx < (l + r) / 2) {\n\t\t\t\treturn this->query(l, (l + r) / 2, k * 2 + 1, idx);\n\t\t\t} else {\n\t\t\t\treturn this->query((l + r) / 2, r, k * 2 + 2, idx);\n\t\t\t}\n\t\t}\n\t\telse assert(false);\n\t}\npublic:\n\tRangeUpdateQuery(const int n) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tdata.resize(sz * 2 - 1);\n\t\tlazy.resize(sz * 2 - 1);\n\t\tvalid.resize(sz * 2 - 1, false);\n\t\tlazyFlag.resize(sz * 2 - 1, false);\n\t}\n\tvoid update(int l, int r, T val) {\n\t\tthis->update(0, sz, l, r, 0, val);\n\t}\n\tT query(int idx) {\n\t\treturn this->query(0, sz, 0, idx);\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tRangeUpdateQuery<int> ruq(n);\n\twhile (q--) {\n\t\tint num;\n\t\tcin >> num;\n\t\tif (num) {\n\t\t\tint idx;\n\t\t\tcin >> idx;\n\t\t\ttry {\n\t\t\t\tcout << ruq.query(idx) << endl;\n\t\t\t} catch(exception e) {\n\t\t\t\tcout << (1ll << 31) - 1 << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tint s, t, val;\n\t\t\tcin >> s >> t >> val;\n\t\t\truq.update(s, t + 1, val);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, v, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u, long long v) {\n\tif (s <= p || q <= r) { seg[u] = v; return; }\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tlong long w = seg[u]; seg[u] = INF;\n\tupdate(p, q, r, (r + s) / 2, t, u * 2, w);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1, w);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((p <= r && s <= q) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> v; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_ * 2; i++)seg[i] = INF;\n\tfor (int i = 1; i <= v; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1, INF); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  ll lazy[sq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(t >= sq*sq){\n\t//cout << \"deug\" << endl;\n\tfill_n(a+sq*sq,t%sq+1,x);\n      }\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if((t-s) <= sq){\n\tfill_n(a+s,t-s+1,x);\n      }\n      else{\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-s+1,x);\n\tfill_n(a+s,f-s,x);\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else if(te == sq){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq+1,lazy[te]);\n\tcout << a[x] << endl;\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\n//const int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> node, lazy;\n    std::function<T (T,T)> op;\n    T unit;\n\npublic:\n    enum Mode {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, Mode mode) : array_size(v.size()) {\n        if (mode == RangeMinimumQuery) {\n            unit = INT_MAX;\n            op = [](T a, T b) { return std::min(a, b); };\n        }\n        else if (mode == RangeMaximumQuery) {\n            unit = -INT_MAX;\n            op = [](T a, T b) { return std::max(a, b); };\n        }\n        else if (mode == RangeSummationQuery) {\n            unit = 0;\n            op = [](T a, T b) { return a + b; };\n        }\n        else {\n            assert(false);\n        }\n\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        node.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, 0);\n\n        for (int i = 0; i < array_size; ++i) {\n            node[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            node[i] = op(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    // array[idx]\n    // log(N)\n    T access(int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] = x\n    // log(N)\n    void update(int idx, T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) = x\n    // log(N)\n    void update(int left, int right, T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(int left, int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(const int a, const int b, const LL x, const int k, const int l, const int r) {\n        eval(k, l, r);\n\n        // 範囲外\n        if (r <= a or b <= l) {\n            return node[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = x;\n            eval(k, l, r);\n            return node[k];\n        }\n        // 一部含む\n        else {\n            T vl = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T vr = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return node[k] = op(vl, vr);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(int a, int b, int k, int l, int r) {\n        eval(k, l, r);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return node[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return op(vl, vr);\n        }\n    }\n\n    void eval(int k, int l, int r) {\n        if (lazy[k] == 0) {\n            return;\n        }\n\n        node[k] = lazy[k];\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        lazy[k] = 0;\n    }\n};\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N, 2147483647);\n\n    LazySegmentTree<LL> lst(v, LazySegmentTree<LL>::Mode::RangeMinimumQuery);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> i;\n            print(lst.access(i));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = (1LL << 31) - 1;\nconst int MOD = (int)(1e9 + 7);\n\nclass RangeUpdateQuery {\npublic:\n\tint n;\n\tvector<int> d;\n\tvector<int> timestamp;\n\tint time;\n\tRangeUpdateQuery(int m) {\n\t\tfor (n = 1; n < m; n *= 2);\n\t\td.assign(n * 2, INF);\n\t\ttime = 0;\n\t\ttimestamp.assign(n * 2, 0);\n\t}\n\t//[l, r)\n\tvoid update(int l, int r, int x) {\n\t\ttime++;\n\t\tfor (; l && l + (l&-l) <= r; l += l&-l) {\n\t\t\td[(n + l) / (l&-l)] = x;\n\t\t\ttimestamp[(n + l) / (l&-l)] = time;\n\t\t}\n\t\tfor (; l < r; r -= r&-r) {\n\t\t\td[(n + r) / (r&-r) - 1] = x;\n\t\t\ttimestamp[(n + r) / (r&-r) - 1] = time;\n\t\t}\n\t}\n\tint get(int i) {\n\t\tint ret = d[n + i];\n\t\tint max_time = timestamp[n + i];\n\t\tfor (int j = (n + i) / 2; j > 0; j >>= 1) {\n\t\t\tif (max_time > timestamp[j])continue;\n\t\t\tmax_time = timestamp[j];\n\t\t\tret = d[j];\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\tRangeUpdateQuery RUQ(n);\n\trep(i, 0, q) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tRUQ.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint i; cin >> i;\n\t\t\tcout << RUQ.get(i) << endl;;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*RMQ  update:O(logN)  query:O(lonN)*/\nconst int MAX_N = 1<<17;\nint n,dat[2*MAX_N-1];\n\n//?????????\nvoid init(int n_){\n  //????´???°n???2???????????????\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=INT_MAX;\n}\n\n//[a,b)???????°????????±???????\n//query(a,b,0,0,n)\nvoid update(int a,int b,int x=-1,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return ;\n  if(a<=l&&r<=b){\n    if(x>=0)dat[k]=x;\n    return;\n  }\n  \n  if(dat[k]!=INT_MAX)dat[k*2+1]=dat[k*2+2]=dat[k];\n  dat[k]=INT_MAX;\n  update(a,b,x,k*2+1,l,(l+r)/2);\n  update(a,b,x,k*2+2,(l+r)/2,r);\n}\nint main(){\n  int q;\n  cin>>n>>q;\n  init(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd==0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      update(s,t+1,x);\n    }\n    else {\n      int idx;\n      cin>>idx;\n      update(idx,idx+1);\n      cout <<dat[idx+n-1]<<endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){ cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){ cout << x[j] << endl; break; }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                A[i] = INT_MAX;\n                cout << A[i] << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        A[i] = x[j];\n                        cout << A[i] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\n#define ld long double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Lazy Evaluation Segment tree (Proportional)\n//-------------------------------------------------\ntemplate<typename T, typename E>\nclass LazySegmentTree\n{\nprivate:\n    using F = ::std::function<T(T,T)>;\n    using G = ::std::function<T(T,E)>;\n    using H = ::std::function<E(E,E)>;\n    F f; G g; H h;\n    int n, height;\n    ::std::vector<T> seg;\n    ::std::vector<E> lazy;\n    T te; E ee;\npublic:\n    LazySegmentTree(int _n, F f, G g, H h, T te, E ee)\n        : f(f),g(g),h(h),te(te),ee(ee)\n    {\n        init(_n);\n    }\n    LazySegmentTree(::std::vector<T> &v, F f, G g, H h, T te, E ee)\n        : f(f),g(g),h(h),te(te),ee(ee)\n    {\n        int _n = v.size();\n        init(_n);\n        for(int i=n; i<n+_n; i++) seg[i] = v[i-n];\n        build();\n    }\n    void init(int _n){\n        n = 1; height=0;\n        while(n<_n) n<<=1, height++;\n        seg.resize(2*n, te);\n        lazy.resize(2*n, ee);\n    }\n    void build(){\n        for(int i=n-1; i>0; i--) seg[i] = f(seg[i<<1], seg[i<<1|1]);\n    }\n    T eval(int k){\n        int c = breadth(k);\n        return (lazy[k]==ee) ? seg[k] : g(seg[k],quantify(lazy[k], c));\n    }\n    void waveto(int k){\n        for(int i=height; i>0; i--) wave(k>>i);\n    }\n    void wave(int k){\n        seg[k] = eval(k);\n        lazy[k<<1] = h(lazy[k<<1],lazy[k]);\n        lazy[k<<1|1] = h(lazy[k<<1|1],lazy[k]);\n        lazy[k] = ee;\n    }\n    void recalc(int k){\n        for(int i=1; i<=height; i++){\n            int m = k>>i;\n            seg[m] = f(eval(m<<1), eval(m<<1|1));\n        }\n    }\n    void update(int a, int b, E x){\n        if (b<=a) return;\n        waveto(a+=n);\n        waveto(b+=n-1);\n        T L=ee, R=ee;\n        int l=a, r=b;\n        while(l<=r){\n            if (l&1) lazy[l] = h(lazy[l], x), l++;\n            if (!(r&1)) lazy[r] = h(lazy[r], x), r--;\n            l>>=1; r>>=1;\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b){\n        waveto(a+=n);\n        waveto(b+=n-1);\n        T L=te, R=te;\n        int l=a, r=b;\n        while(l<=r){\n            if (l&1) L = f(L, eval(l++));\n            if (!(r&1)) R = f(eval(r--), R);\n            l>>=1; r>>=1;\n        }\n        return f(L,R);\n    }\n    T operator[](int k){return query(k, k+1);};\n    inline int breadth(int k){\n        int ret = height-31+__builtin_clz(k);\n        return 1<<ret;\n    }\n    //return value proportional to segment's width\n    inline E quantify(E laz, int c){\n        return laz;\n    }\n};\n\nconst ll INF = INT_MAX;\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,q; cin>>n>>q;\n    LazySegmentTree<ll,ll> seg(n,\n        [](ll x, ll y){return min(x,y);},\n        [](ll x, ll y){return y;},\n        [](ll x, ll y){return (y==INF)?x:y;},\n        INF,INF\n    );\n    while(q--){\n        int c; cin>>c;\n        if (c==1){\n            int i; cin>>i;\n            cout<<seg[i]<<endl;\n        }else{\n            int s,t,x; cin>>s>>t>>x;\n            seg.update(s,t+1,x);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nconst long long INF = (1 << 31) - 1;\n\nstruct segtree{\n  int size;\n  vector<long long> updated;\n  segtree(int n){\n    size = 1;\n    while(n>size){\n      size *= 2;\n    }\n    updated.assign(2*size-1,INF);\n  }\n  void update(int a,int b,long long x,int k,int l,int r){\n    if(b<=l||r<=a) return;\n    if(a<=l&&r<=b) updated[k] = x;\n    else{\n      if(updated[k]>=0){\n        updated[2*k+1] = updated[k];\n        updated[2*k+2] = updated[k];\n        updated[k] = -1;\n      }\n      update(a,b,x,2*k+1,l,(l+r)/2);\n      update(a,b,x,2*k+2,(l+r)/2,r);\n    }\n  }\n  void update(int a,int b,long long x){\n    update(a,b+1,x,0,0,size);\n  }\n  long long find(int i,int k,int l,int r){\n    if(i<l||r<=i) return -1;\n    if(updated[k]>=0) return updated[k];\n    else return max(find(i,2*k+1,l,(l+r)/2),find(i,2*k+2,(l+r)/2,r));\n  }\n  long long find(int i){\n    return find(i,0,0,size);\n  }\n};\n\nint main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  segtree st(n);\n  for(int i=0;i<q;i++){\n    int cmd;\n    scanf(\"%d\",&cmd);\n    if(cmd==0){\n      long long s,t,x;\n      scanf(\"%lld %lld %lld\",&s,&t,&x);\n      st.update(s,t,x);\n    }else if(cmd==1){\n      int i;\n      scanf(\"%d\",&i);\n      printf(\"%lld\\n\",st.find(i));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n//BEGIN CUT HERE\ntemplate <typename E>\nstruct SegmentTree{\n  using H = function<E(E,E)>;\n  int n,height;\n  H h;\n  E ei;\n  vector<E> laz;\n  SegmentTree(H h,E ei):h(h),ei(ei){}  \n  void init(int n_){\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    laz.assign(2*n,ei);\n  }\n  inline void eval(int k){\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n    laz[k]=ei;\n  }\n  inline void thrust(int k){\n    for(int i=height;i;i--) eval(k>>i);\n  }\n  void update(int a,int b,E x){\n    thrust(a+=n);\n    thrust(b+=n-1);\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n  }\n  E get_val(int a){\n    thrust(a+=n);\n    return laz[a];\n  }\n  void set_val(int a,E x){\n    thrust(a+=n);\n    laz[a]=x;\n  }\n};\n//END CUT HERE\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned AOJ_DSL_2_D(){\n  int n,q;\n  cin>>n>>q;\n  auto h=[](int a,int b){(void)a;return b;};  \n  int ei=INT_MAX;\n  SegmentTree<int> seg(h,ei);\n  seg.init(n);\n  for(int i=0;i<q;i++){\n    int tp;\n    cin>>tp;\n    if(tp==0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      seg.update(s,t+1,x);\n    }\n    if(tp==1){\n      int s;\n      cin>>s;\n      cout<<seg.get_val(s)<<\"\\n\";\n    }    \n  }\n  cout<<flush;\n  return 0;  \n}\n\nsigned main(){\n  AOJ_DSL_2_D();\n  //AOJ_DSL_2_E();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\ntemplate<typename Monoid> class RangeActionSegTree {\n  using T = typename Monoid::value_type;\n\n  Monoid m;\n  vector<T> tree; // 1-indexed\n  int size = 1;\n\n  void push(int i) {\n    stack<int> s;\n    while (i /= 2) s.emplace(i);\n    for (int x; s.size(); s.pop()) {\n      x = s.top();\n      tree[x * 2] = m(tree[x * 2], tree[x]);\n      tree[x * 2 + 1] = m(tree[x * 2 + 1], tree[x]);\n      tree[x] = m.id();\n    }\n  }\n\npublic:\n  RangeActionSegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n  }\n\n  RangeActionSegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n    fill(tree.begin() + size, tree.end(), x);\n  }\n\n  template<typename InputIterator> RangeActionSegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, m.id());\n    copy(first, last, tree.begin() + size);\n  }\n\n  void act(int l, int r, const T &x) { // [l, r) += x\n    for (push(l += size), push((r += size) - 1); l < r; l /= 2, r /= 2) {\n      if (l & 1) tree[l] = m(tree[l], x), l++;\n      if (r & 1) --r, tree[r] = m(tree[r], x);\n    }\n  }\n\n  void update(int i, const T &x) {\n    push(i += size);\n    tree[i] = x;\n    while (i /= 2) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  T operator[](int i) {\n    T acc = tree[i += size];\n    while (i /= 2) acc = m(acc, tree[i]);\n    return acc;\n  }\n};\n\ntemplate<typename T> class RangeUpdate {\n  struct updateMonoid {\n    using value_type = pair<bool, T>;\n    value_type id() { return {false, T()}; }\n    value_type operator()(const value_type &a, const value_type &b) { return b.first ? b : a; }\n  };\n  RangeActionSegTree<updateMonoid> rast;\n\npublic:\n  RangeUpdate(const int &n = 0) : rast(n) {}\n  RangeUpdate(const int &n, const T &x) : rast(n, {true, x}) {}\n  template<typename InputIterator> RangeUpdate(InputIterator first, InputIterator last) : rast(first, last) {}\n  void update(const int &l, const int &r, const T &x) { rast.act(l, r, {true, x}); }\n  void update(const int &i, const T &x) { rast.update(i, x); }\n  T operator[](const int &i) { return rast[i].second; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  RangeUpdate<int> ru(n, 2147483647);\n  while (q--) {\n    if (in()) {\n      cout << ru[in()] << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      ru.update(s, t + 1, x);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 3000000000000000000;\n\ntemplate <typename Operator>\nstruct LazySegmentTree {\n    Operator OP;\n    using NodeType = decltype(OP.NodeE);\n    using FuncType = decltype(OP.FuncE);\n    int length, height;\n    vector<NodeType> node;\n    vector<FuncType> lazy;\n    \n    LazySegmentTree(int n) {\n        length = 1;\n        height = 0;\n        while (length < n) {\n            length <<= 1;\n            ++height;\n        }\n        node.resize(length << 1, OP.NodeE);\n        lazy.resize(length << 1, OP.FuncE);\n    }\n    \n    void eval(int n) {\n        node[n] = OP.NodeFunc(node[n], lazy[n]);\n        if (n < length) {\n            lazy[(n << 1) | 0] = OP.MergeFunc(lazy[(n << 1) | 0], lazy[n]);\n            lazy[(n << 1) | 1] = OP.MergeFunc(lazy[(n << 1) | 1], lazy[n]);\n        }\n        lazy[n] = OP.FuncE;\n    }\n    \n    void update(int a, int b, FuncType x) {\n        int l = a + length, r = b + length - 1;\n        for (int i = height; i > 0; --i) {\n            eval(l >> i);\n            eval(r >> i);\n        }\n        ++r;\n        while (r > l) {\n            if (l & 1) {\n                lazy[l] = OP.MergeFunc(lazy[l], x);\n                ++l;\n            }\n            if (r & 1) {\n                --r;\n                lazy[r] = OP.MergeFunc(lazy[r], x);\n            }\n            l >>= 1; r >>= 1;\n        }\n        l = a + length; r = b + length - 1;\n        while (l >>= 1) node[l] = OP.MergeNode(OP.NodeFunc(node[(l << 1) | 0], lazy[(l << 1) | 0]), OP.NodeFunc(node[(l << 1) | 1], lazy[(l << 1) | 1]));\n        while (r >>= 1) node[r] = OP.MergeNode(OP.NodeFunc(node[(r << 1) | 0], lazy[(r << 1) | 0]), OP.NodeFunc(node[(r << 1) | 1], lazy[(r << 1) | 1]));\n    }\n    \n    NodeType get(int a, int b) {\n        int l = a + length, r = b + length - 1;\n        for (int i = height; i >= 0; --i) {\n            eval(l >> i);\n            eval(r >> i);\n        }\n        ++r;\n        NodeType vl = OP.NodeE, vr = OP.NodeE;\n        while (l < r) {\n            if (l & 1) vl = OP.MergeNode(vl, node[l++]);\n            if (r & 1) vr = OP.MergeNode(node[--r], vr);\n            l >>= 1; r >>= 1;\n        }\n        return OP.MergeNode(vl, vr);\n    }\n};\n\nstruct hoge {\n    ll NodeE = 0;\n    ll FuncE = INF;\n    ll MergeNode(ll x, ll y) {\n        return x + y;\n    }\n    ll MergeFunc(ll x, ll y) {\n        if (y == INF) return x;\n        else return y;\n    }\n    ll NodeFunc(ll x, ll y) {\n        if (y == INF) return x;\n        else return y;\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree<hoge> LST(n);\n    LST.update(0, n, (1LL << 31) - 1);\n    REP(_, q) {\n        int num;\n        cin >> num;\n        if (!num) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            LST.update(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << LST.get(i, i + 1) << \"\\n\";\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 2 \"library/other/template.hpp\"\n#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx2\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef std::pair<int, int> P;\ntypedef std::pair<lint, lint> LP;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = DBL_EPSILON;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, lint b) {\n\tT res(1);\n\twhile(b){\n\t\tif(b&1)res*=a;\n\t\ta*=a;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nlint modpow(lint a, lint b, lint m) {\n\tlint res(1);\n\twhile(b){\n\t\tif(b&1){\n\t\t\tres*=a;res%=m;\n\t\t}\n\t\ta*=a;a%=m;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size()){\n\t\tstd::cout << vec[i];\n\t\tstd::cout<<(i==(int)vec.size()-1?\"\\n\":\" \");\n\t}\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = std::prev(r);\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nLP extGcd(lint a,lint b) {\n\tif(b==0)return {1,0};\n\tLP s=extGcd(b,a%b);\n\tstd::swap(s.first,s.second);\n\ts.second-=a/b*s.first;\n\treturn s;\n}\nLP ChineseRem(const lint& b1,const lint& m1,const lint& b2,const lint& m2) {\n\tlint p=extGcd(m1,m2).first;\n\tlint tmp=(b2-b1)*p%m2;\n\tlint r=(b1+m1*tmp+m1*m2)%(m1*m2);\n\treturn std::make_pair(r,m1*m2);\n}\n/*template<typename F>\ninline constexpr decltype(auto) lambda_fix(F&& f){\n\treturn [f=std::forward<F>(f)](auto&&... args){\n\t\treturn f(f,std::forward<decltype(args)>(args)...);\n\t};\n}*/\n#line 3 \"library/data-structure/SegTree.hpp\"\ntemplate<typename T>\nclass SegTree {\nprotected:\n\tunsigned int n = 1, rank = 0;\n\tstd::vector<T> node;\n\tT nodee;\n\tvirtual T nodef(const T&, const T&)const = 0;\npublic:\n\tSegTree(unsigned int m, T init, T nodee):nodee(nodee) {\n\t\twhile (n < m) {\n\t\t\tn *= 2;\n\t\t\trank++;\n\t\t}\n\t\tnode.resize(2 * n, nodee);\n\t\tfor (unsigned int i = n; i < 2 * n; i++)node[i] = init;\n\t}\n\tSegTree(const std::vector<T>& initvec, T nodee):nodee(nodee) {\n\t\tunsigned int m = initvec.size();\n\t\twhile (n < m) {\n\t\t\tn *= 2;\n\t\t\trank++;\n\t\t}\n\t\tnode.resize(2 * n, nodee);\n\t\tfor (unsigned int i = n; i < 2 * n; i++) {\n\t\t\tif (i - n < m)node[i] = initvec[i - n];\n\t\t}\n\t}\n\tvirtual void update(int i, T x) {\n\t\ti += n;\n\t\tnode[i] = x;\n\t\twhile (i != 1) {\n\t\t\ti >>= 1;\n\t\t\tnode[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t\t}\n\t}\n\tvirtual T query(int l, int r) {\n\t\tl += n; r += n;\n\t\tT ls = nodee, rs = nodee;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tls = nodef(ls, node[l]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tr--;\n\t\t\t\trs = nodef(node[r], rs);\n\t\t\t}\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn nodef(ls, rs);\n\t}\n\tvirtual T operator[](const int& x) {\n\t\treturn node[n + x];\n\t}\n\tvoid print() {\n\t\trep(i, n)std::cout << operator[](i) << \" \";\n\t\tstd::cout << std::endl;\n\t}\n};\nclass RSQ :public SegTree<lint> {\n\tlint nodef(const lint& lhs,const lint& rhs)const{return lhs+rhs;}\npublic:\n\tRSQ(int size, const lint& def = 0) :SegTree<lint>(size, def, 0) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n\tRSQ(const std::vector<lint>& initvec) :SegTree<lint>(initvec, 0) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n};\nclass RMiQ :public SegTree<lint> {\n\tlint nodef(const lint& lhs,const lint& rhs)const{return std::min(lhs,rhs);}\npublic:\n\tRMiQ(int size, const lint& def = 0) :SegTree<lint>(size, def, LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n\tRMiQ(const std::vector<lint>& initvec) :SegTree<lint>(initvec, LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n};\nclass RMaQ :public SegTree<lint> {\n\tlint nodef(const lint& lhs,const lint& rhs)const{return std::max(lhs,rhs);}\npublic:\n\tRMaQ(int size, const lint& def = 0) :SegTree<lint>(size, def, -LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n\tRMaQ(const std::vector<lint>& initvec) :SegTree<lint>(initvec, -LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n};\n#line 4 \"library/data-structure/IntervalSegTree.hpp\"\ntemplate<typename T, typename U>\nclass IntervalSegTree :public SegTree<T> {\nprotected:\n\tusing SegTree<T>::n;\n\tusing SegTree<T>::rank;\n\tusing SegTree<T>::node;\n\tusing SegTree<T>::nodef;\n\tusing SegTree<T>::nodee;\n\tstd::vector<U> lazy;\n\tstd::vector<bool> lazyflag;\n\tstd::vector<int> width;\n\tvirtual void lazyf(U&, const U&) = 0;\n\tvirtual void updf(T&, const U&, const unsigned int&) = 0;\n\tvoid eval(int k) {\n\t\tfor (int i = rank; i > 0; i--) {\n\t\t\tint nk = k >> i;\n\t\t\tif (lazyflag[nk]) {\n\t\t\t\tupdf(node[2 * nk], lazy[nk], width[2 * nk]);\n\t\t\t\tupdf(node[2 * nk + 1], lazy[nk], width[2 * nk + 1]);\n\t\t\t\tif (lazyflag[2 * nk])lazyf(lazy[2 * nk], lazy[nk]);\n\t\t\t\telse lazy[2 * nk] = lazy[nk];\n\t\t\t\tif (lazyflag[2 * nk + 1])lazyf(lazy[2 * nk + 1], lazy[nk]);\n\t\t\t\telse lazy[2 * nk + 1] = lazy[nk];\n\t\t\t\tlazyflag[2 * nk] = lazyflag[2 * nk + 1] = true;\n\t\t\t\tlazyflag[nk] = false;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tIntervalSegTree(unsigned int m, T init, T nodee) :SegTree<T>(m, init, nodee) {\n\t\tlazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n\t\twidth[1] = n;\n\t\tfor (unsigned int i = 2; i < 2 * n; i++) {\n\t\t\twidth[i] = width[i >> 1] >> 1;\n\t\t}\n\t}\n\tIntervalSegTree(T nodee, const std::vector<T>& initvec) :SegTree<T>(initvec, nodee) {\n\t\tlazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n\t\twidth[1] = n;\n\t\tfor (unsigned int i = 2; i < 2 * n; i++) {\n\t\t\twidth[i] = width[i >> 1] >> 1;\n\t\t}\n\t}\n\tvoid update(int i, U x) {\n\t\ti += n;\n\t\teval(i);\n\t\tupdf(node[i], x, width[i]);\n\t\tif (lazyflag[i])lazyf(lazy[i], x);\n\t\telse {\n\t\t\tlazyflag[i] = true;\n\t\t\tlazy[i] = x;\n\t\t}\n\t\twhile (i /= 2)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tvoid update(int l, int r, U x) {\n\t\tl += n; r += n;\n\t\tint nl = l, nr = r;\n\t\twhile (!(nl & 1))nl >>= 1;\n\t\twhile (!(nr & 1))nr >>= 1;\n\t\tnr--;\n\t\teval(nl); eval(nr);\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tupdf(node[l], x, width[l]);\n\t\t\t\tif (lazyflag[l])lazyf(lazy[l], x);\n\t\t\t\telse {\n\t\t\t\t\tlazyflag[l] = true;\n\t\t\t\t\tlazy[l] = x;\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tr--;\n\t\t\t\tupdf(node[r], x, width[r]);\n\t\t\t\tif (lazyflag[r])lazyf(lazy[r], x);\n\t\t\t\telse {\n\t\t\t\t\tlazyflag[r] = true;\n\t\t\t\t\tlazy[r] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\twhile (nl >>= 1)node[nl] = nodef(node[2 * nl], node[2 * nl + 1]);\n\t\twhile (nr >>= 1)node[nr] = nodef(node[2 * nr], node[2 * nr + 1]);\n\t}\n\tT query(int l, int r) {\n\t\tl += n; r += n;\n\t\teval(l); eval(r - 1);\n\t\tT ls = nodee, rs = nodee;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tls = nodef(ls, node[l]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tr--;\n\t\t\t\trs = nodef(node[r], rs);\n\t\t\t}\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn nodef(ls, rs);\n\t}\n\tT operator[](const int& x) {\n\t\teval(n + x);\n\t\treturn node[n + x];\n\t}\n\tT queryForAll() {\n\t\treturn node[1];\n\t}\n};\nclass RAQRSQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return a + b; }\n\tvoid lazyf(lint& a, const lint& b) { a += b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a += width * b; }\npublic:\n\tRAQRSQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, 0) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRAQRSQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>((lint)0, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RAQRMiQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::min(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a += b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a += b; }\npublic:\n\tRAQRMiQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRAQRMiQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RAQRMaQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::max(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a += b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a += b; }\npublic:\n\tRAQRMaQ(unsigned int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, -LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRAQRMaQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(-LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RUQRSQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return a + b; }\n\tvoid lazyf(lint& a, const lint& b) { a = b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a = width * b; }\npublic:\n\tRUQRSQ(int size, const int& def = 0) :IntervalSegTree<lint, lint>(size, def, 0) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRUQRSQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>((lint)0, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RUQRMiQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const int& a, const int& b)const { return std::min(a, b); }\n\tvoid lazyf(int& a, const int& b) { a = b; }\n\tvoid updf(int& a, const int& b, const unsigned int& width) { a = b; }\npublic:\n\tRUQRMiQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRUQRMiQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RUQRMaQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::max(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a = b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a = b; }\npublic:\n\tRUQRMaQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, -LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRUQRMaQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(-LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\n#line 3 \"main.cpp\"\nint n,q,com;\nint main(){\n\tstd::cin>>n>>q;\n\tRUQRSQ st(n,INT_MAX);\n\trep(i,q){\n\t\tstd::cin>>com;\n\t\tif(com==0){\n\t\t\tint s,t,x;\n\t\t\tstd::cin>>s>>t>>x;\n\t\t\tst.update(s,t+1,x);\n\t\t}\n\t\telse{\n\t\t\tint x;\n\t\t\tstd::cin>>x;\n\t\t\tstd::cout<<st.query(x,x+1)<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst long long Mx = 0x7FFFFFFF;\nlong long n, q, s, t, x, m = 1;\nlong long a[300000];\n\nvoid upd(long long s, long long t, long long x) {\n\tlong long ks = m - 1 + s, kt = m - 1 + t;\n\n\twhile (ks < kt) {\n\t\tif (ks % 2 == 0)\n\t\t\ta[ks] = x;\n\t\tif (kt % 2 == 1)\n\t\t\ta[kt] = x;\n\n\t\t\tks = ks / 2;\n\t\t\tkt = (kt - 2) / 2;\n\t}\n\tif (ks == kt)\n\t\ta[ks] = x;\n}\n\nlong long fd(long long s) {\n\ts = m - 1 + s;\n\n\twhile (a[s] == Mx && s > 0)\n\t\ts = (s - 1) / 2;\n\n\treturn a[s];\n}\n\nint main()\n{\n\tcin >> n >> q;\n\n\twhile (m <= n)\n\t\tm *= 2;\n\n\tfor (int i = 0; i < m * 2; i++)\n\t\ta[i] = Mx;\n\n\tfor (int j = 0; j < q; j++) {\n\t\tint p;\n\t\tcin >> p;\n\n\t\tif (p == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupd(s, t, x);\n\t\t}\n\t\telse if (p == 1) {\n\t\t\tcin >> s;\n\t\t\tcout << fd(s) << endl;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m * 2; i++)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\nconst int INF = (1LL << 31) - 1;\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<bool> lazyFlag;\n  vector<int> lazyUpdate;\n  SqrtDecomposition(int n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, INF);\n    lazyFlag.assign(K, false);\n    lazyUpdate.assign(K, 0);\n  }\n  void eval(int k) {\n    if (lazyFlag[k]) {\n      lazyFlag[k] = false;\n      for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n    }\n  }\n  // [s, t)\n  void update(int s, int t, int x) {\n       int p = max(0LL, s / sqrtN - 1);\n        int q = min(K, t / sqrtN + 1);\n    for (int k = p; k < q; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        lazyFlag[k] = true;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n  int find(int i) {\n    int k = i / sqrtN;\n    eval(k);\n    return data[i];\n  }\n};\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  int N, Q;\n  cin >> N >> Q;\n  SqrtDecomposition decomp(N);\n  while (Q--) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      decomp.update(s, t + 1, x);\n    } else {\n      int i;\n      cin >> i;\n      cout << decomp.find(i) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=INT_MAX;\nstruct segtree\n{\n    vector<int> node;\n    vector<int> lazy;\n    vector<bool> lflg;\n    int n;\n    segtree(int sz)\n    {\n        n=1;while(n<sz) n*=2;\n        node.resize(2*n,INF);\n        lazy.resize(2*n,0);\n        lflg.resize(2*n,false);\n    }\n    void lazyupdate(int k, int l, int r)\n    {\n        if(lflg[k])\n        {\n            node[k]=lazy[k];\n            push(lazy[k],k,l,r);\n            lazy[k]=0;\n            lflg[k]=false;\n        }\n    }\n    void push(int v,int k,int l,int r)\n    {\n        if(r-l>0)\n        {\n            lazy[2*k]=lazy[2*k+1]=v;\n            lflg[2*k]=lflg[2*k+1]=true;\n        }\n    }\n    void update(int qa, int qb, int v, int k=1, int l=1,int r=-1)\n    {\n        if(r<0) r=n;\n        lazyupdate(k, l, r);\n        if(qb<l||r<qa) return;\n        if(qa<=l&&r<=qb)\n        {\n            node[k]=v;\n            push(v,k,l,r);\n        }\n        else\n        {\n            int m=(l+r)/2;\n            update(qa,qb,v,2*k,l,m);\n            update(qa,qb,v,2*k+1,m+1,r);\n            node[k]=node[2*k]+node[2*k+1];\n        }\n    }\n    int get(int qa, int qb, int k=1, int l=1, int r=-1)\n    {\n        if(r<0) r=n;\n        lazyupdate(k ,l, r);\n        if(qb<l||r<qa) return INF;\n        if(qa<=l&&r<=qb) return node[k];\n        else\n        {\n            int m=(l+r)/2;\n            int lv=get(qa, qb, 2*k, l, m);\n            int rv=get(qa, qb, 2*k+1, m+1, r);\n            return min(lv,rv);\n        }\n    }\n};\n\nint main()\n{\n    int n,q;\n    scanf(\"%d %d\",&n,&q);\n    segtree tree(n);\n    for(int i=0;i<q;i++){\n        int c;\n        scanf(\"%d\",&c);\n        if(c){\n            int x;\n            scanf(\"%d\",&x);\n            cout<<tree.get(x+1,x+1)<<endl;\n        }else{\n            int s,t,v;\n            scanf(\"%d %d %d\",&s,&t,&v);\n            tree.update(s+1,t+1,v);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n//#define INF 1145141919\n#define INF 2147483647\n#define MOD 1000000007\n#define MAX_N (1<<17) // 10^5\n\nstruct SegTree {\n  int seg[MAX_N*2-1], lazy[MAX_N*2-1];\n  SegTree() {\n    for (int i=0; i<MAX_N*2-1; i++) seg[i] = INF, lazy[i] = INF;\n  }\n  inline void setLazy(int k, int v) {\n    lazy[k] = v;\n    seg[k] = v;\n  }\n  inline void fix(int k) {\n    seg[k] = max(seg[k*2+1], seg[k*2+2]);\n  }\n  inline void push(int k) {\n    if (lazy[k] == INF) return;\n    setLazy(k*2+1, lazy[k]);\n    setLazy(k*2+2, lazy[k]);\n    lazy[k] = INF;\n  }\n\n  void fill(int a, int b, int x, int k=0, int l=0, int r=MAX_N) {\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      setLazy(k, x);\n      return;\n    }\n    push(k);\n    fill(a, b, x, k*2+1, l, (l+r)/2);\n    fill(a, b, x, k*2+2, (l+r)/2, r);\n    fix(k);\n  }\n\n  int query(int a, int b, int k=0, int l=0, int r=MAX_N) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return seg[k];\n    push(k);\n    return max(\n      query(a, b, k*2+1, l, (l+r)/2),\n      query(a, b, k*2+2, (l+r)/2, r)\n    );\n  }\n};\n\nint N, Q;\nSegTree seg;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> Q;\n  rep(i, Q) {\n    int t;\n    cin >> t;\n    if (t == 0) {\n      int l, r, x;\n      cin >> l >> r >> x;\n      seg.fill(l, r+1, x);\n    }\n    else {\n      int i;\n      cin >> i;\n      cout << seg.query(i, i+1) << \"\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nconst int MAX = 2147483647;\nint min(int a, int b) {\n\treturn a < b ? a : b;\n}\nint getSegTreeSize(int len) {\n\tif (len == 0)\n\t\treturn 0;\n\tint ret, cnt = 0, memo = 1;\n\twhile (memo < len) {\n\t\tmemo *= 2;\n\t\tcnt++;\n\t}\n\tret = 1 << (cnt + 1);\n\treturn ret;\n}\nclass RUQ {\n  private:\n\tint size, length;\n\tstd::vector<int> node;\n\tRUQ() {}\n\tint find(int return_index, int index, int left, int right) {\n\t\tif (node[index] != -1)\n\t\t\treturn node[index];\n\t\tif ((left + right) / 2 < return_index)\n\t\t\treturn find(return_index, index * 2 + 1, (left + right) / 2 + 1, right);\n\t\treturn find(return_index, index * 2, left, (left + right) / 2);\n\t}\n\tvoid update(int left, int right, int element, int index, int i_left, int i_right) {\n\t\tif (element == node[index])\n\t\t\treturn;\n\t\tif (left <= i_left && i_right <= right) {\n\t\t\tnode[index] = element;\n\t\t\treturn;\n\t\t}\n\t\tif (node[index] != -1) {\n\t\t\tnode[index * 2] = node[index];\n\t\t\tnode[index * 2 + 1] = node[index];\n\t\t\tnode[index] = -1;\n\t\t}\n\t\tint middle = (i_left + i_right) / 2;\n\t\tif (middle >= left)\n\t\t\tupdate(left, right, element, index * 2, i_left, middle);\n\t\tif (middle < right)\n\t\t\tupdate(left, right, element, index * 2 + 1, middle + 1, i_right);\n\t}\n\n  public:\n\tRUQ(int size) {\n\t\tthis->size = getSegTreeSize(size) / 2;\n\t\tthis->length = getSegTreeSize(size);\n\t\tnode.resize(this->length);\n\t\tfill(node.begin(), node.end(), MAX);\n\t}\n\tvoid update(int left, int right, int element) {\n\t\tupdate(left, right, element, 1, 1, size);\n\t}\n\tint find(int index) {\n\t\treturn find(index, 1, 1, size);\n\t}\n};\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tRUQ segTree(n);\n\tfor (int i = 0; i < q; i++) {\n\t\tint com;\n\t\tstd::cin >> com;\n\t\tif (com == 0) {\n\t\t\tint l, r, e;\n\t\t\tstd::cin >> l >> r >> e;\n\t\t\tsegTree.update(l + 1, r + 1, e);\n\t\t}\n\t\telse {\n\t\t\tint index;\n\t\t\tstd::cin >> index;\n\t\t\tstd::cout << segTree.find(index + 1) << std::endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF (1 << 30) - 1 + (1 << 30)\n\nint a[262144], n2, lazy[262144];\n\nvoid lazyeval(int i) {\n  if (lazy[i] == INF) return;\n  a[i] = lazy[i];\n  if (i < n2 - 1) {\n    lazy[2 * i + 1] = lazy[2 * i + 2] = lazy[i];\n  }\n  lazy[i] = INF;\n}\n\nint findsingle(int i) {\n  int j = i + n2 - 1;\n  int val = a[i + n2 - 1];\n  if (lazy[j] != INF) val = lazy[j];\n  while (j > 0) {\n    j = (j - 1) / 2;\n    if (lazy[j] != INF) val = lazy[j];\n  }\n\n  return val;\n}\n\nvoid updaterange(int s, int t, int i, int l, int r, int x) {\n  lazyeval(i);\n  // cout << s << \" \" << t << \" \" << i << \" \" << l << \" \" << r << endl;\n  if (s <= l && r <= t) {\n    a[i] = x;\n    if (i < n2 - 1) {\n      lazy[2 * i + 1] = lazy[2 * i + 2] = a[i];\n    }\n    return;\n  }\n  if (t <= l || r <= s) return;\n  updaterange(s, t, i * 2 + 1, l, (l + r) / 2, x);\n  updaterange(s, t, i * 2 + 2, (l + r) / 2, r, x);\n\n  a[i] = min(a[i * 2 + 1], a[i * 2 + 2]);\n}\n\nint main() {\n  int n, q, com, s, t, x;\n\n  cin >> n >> q;\n  n2 = 1;\n  while (n > n2) n2 *= 2;\n  for (int i = 0; i < n2 * 2; i++) a[i] = lazy[i] = INF;\n\n  for (int i = 0; i < q; i++) {\n    cin >> com >> s;\n    if (com == 0) {\n      cin >> t >> x;\n      updaterange(s, t + 1, 0, 0, n2, x);\n    } else\n      cout << findsingle(s) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint t[(1<<18)];\n//0 2 1 0 0 \n//0 2 1 0 0 65536\n//0 2 1 0 0 2\nvoid Set(int a,int b,int x,int k=0,int l=0,int r=(1<<17)){\n  if(b<=l || r<=a)return;\n  if(a<=l && r<=b){\n    t[k]=max(t[k],x);\n    return;\n  }\n  int m=(l+r)/2;\n  \n  Set(a,b,x,k*2+1,l,m);\n  Set(a,b,x,k*2+2,m,r);\n}\n\nint Get(int i){\n  i+=(1<<17)-1;\n  int res=t[i];\n  while(i){\n    i=(i-1)/2;\n    res=max(res,t[i]);\n  }\n  return res;\n}\n\nint n,q;\nint value[100005];\n\nint main(){\n  value[0]=2147483647;\n\n  scanf(\"%d %d\",&n,&q);\n  for(int i=1;i<=q;i++){\n    int type;\n    scanf(\"%d\",&type);\n    if(type==0){\n      int l,r;\n      scanf(\"%d %d %d\",&l,&r,&value[i]);\n      r++;\n      Set(l,r,i);\n    }else{\n      int target;\n      scanf(\"%d\",&target);\n      int ans=Get(target);\n      printf(\"%d\\n\",value[ans]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\ntemplate<class V> class segtree {\nprivate:\n    int n;\n    vector<V> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    segtree(vector<V> v) {\n        int sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        lazyFlag.resize(2*n-1,false);\n        rep(i,sz){\n            node[i+n-1] = v[i];\n        }\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            range(a, b, x, 2*k+1, l, (l+r)/2);\n            range(a, b, x, 2*k+2, (l+r)/2, r);\n        }\n    }\n    V find(int a, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(r - l == 1){\n            return node[k];\n        }\n        if(a < (l+r)/2){\n            return find(a, 2*k+1, l, (l+r)/2);\n        }else{\n            return find(a, 2*k+2, (l+r)/2, r);\n        }\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin >> n >> q;\n    segtree<int> sg(vector<int>(n,INT_MAX));\n    rep(i,q){\n        int k;\n        cin >> k;\n        if(k){\n            int x;\n            cin >> x;\n            cout << sg.find(x) << \"\\n\";\n        }else{\n            int x,y,z;\n            cin >> x >> y >> z;\n            sg.range(x,y+1,z);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\n\n\ntemplate<typename T>\nclass segtree {\n    int size;\n    vector<T> valtree;\n    vector<int> ismixedtree;\n\npublic:\n    segtree(int n) {\n        size = 8;\n        while (size < n) size <<= 1;\n        valtree.resize(size*2);\n        ismixedtree.resize(size*2);\n    }\n    \n    void fill(T val){\n        std::fill(ALL(valtree), val);\n        std::fill(ALL(ismixedtree), 0);\n    }\n\n    \n    void setvalrange(int begin, int end, T val, int ptr = 0, int rangebegin = 0, int rangeend = 0) {\n        if (rangeend <= rangebegin) { rangeend = size; }\n\n        if (rangeend <= begin || end <= rangebegin) return;\n        \n        if (begin <= rangebegin && rangeend <= end) {\n            ismixedtree[ptr] = false;\n            valtree[ptr] = val;\n            return;\n        }\n        \n        int rangemid = (rangebegin + rangeend) / 2;\n        if (ismixedtree[ptr] == false){\n            // lazy\n            valtree[ptr * 2 + 1] = valtree[ptr];\n            valtree[ptr * 2 + 2] = valtree[ptr];\n            ismixedtree[ptr * 2 + 1] = false;\n            ismixedtree[ptr * 2 + 2] = false;\n        }\n        ismixedtree[ptr] = true;\n\n        setvalrange(begin, end, val, ptr * 2 + 1, rangebegin, rangemid);\n        setvalrange(begin, end, val, ptr * 2 + 2, rangemid, rangeend);\n\n    }\n\n    T getval(int index, int ptr = 0, int rangebegin = 0, int rangeend = 0) {\n        if (rangeend <= rangebegin) { rangeend = size; }\n\n        if (ismixedtree[ptr] == false) {\n            return valtree[ptr];\n        }\n\n\n        int rangemid = (rangebegin + rangeend) / 2;\n        if (index < rangemid)\n            return getval(index, ptr * 2 + 1, rangebegin, rangemid);\n        else\n            return getval(index, ptr * 2 + 2, rangemid, rangeend);\n\n    }\n};\n\n\nll m, n, kei;\n\n\nint main() {\n    int q;\n    scanner >> n >> q;\n\n    segtree<int> seg(n);\n    seg.fill(0x7FFFFFFF);\n\n    repeat(_, q) {\n        int t;\n        scanner >> t;\n        if (t == 0) {\n            int s, t, x;\n            scanner >> s >> t >> x;\n            //--s; --t;\n            seg.setvalrange(s, t + 1, x);\n        }\n        else {\n            int s, t;\n            scanner >> s;\n            //--s; --t;\n            printer << (seg.getval(s)) << '\\n';\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\npair<int,int> SegTree[1<<18];\n\nvoid update(int l,int r,int x,int t)\n{\n\twhile (l!=r)\n\t{\n\t\tif(l%2)\n\t\t{\n\t\t\tSegTree[l] = make_pair(x,t);\n\t\t\tl++;\n\t\t}\n\t\tif(r%2)\n\t\t{\n\t\t\tSegTree[r-1] = make_pair(x,t);\n\t\t\tr--;\n\t\t}\n\t\tl/=2;\n\t\tr/=2;\n\t}\n\t//SegTree[l] = make_pair(x,t);\n\t//cout<<l<<endl;\n}\n\nint get(int i)\n{\n\tpair<int,int> res(-1,-2);\n\twhile(i!=0)\n\t{\n\t\tif(SegTree[i].second>res.second)\n\t\t{\n\t\t\tres = SegTree[i];\n\t\t}\n\t\ti/=2;\n\t}\n\treturn res.first;\n}\n\n\nint main()\n{\n\t//cout<<(1<<18)<<endl;\t\n\tint n,q;\n\tcin >> n >> q;\n\tfor(int i = 0;i<(1<<18);i++)\n\t{\n\t\tSegTree[i]=make_pair(INT_MAX,-1);\n\t}\n\tfor(int i = 0;i<q;i++)\n\t{\n\t\tint op;\n\t\tcin >> op;\n\t\tif(op)\n\t\t{\n\t\t\tint I;\n\t\t\tcin >> I;\n\t\t\tI += (1<<17);\n\t\t\tcout<<get(I)<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s,t,x;\n\t\t\tcin >> s >> t >> x;\n\t\t\ts+=(1<<17);\n\t\t\tt+=(1<<17);\n\t\t\tt++;\n\t\t\tupdate(s,t,x,i);\n\n\t\t}\n\t\t//cout<<SegTree[(1<<17)].first<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nstruct RUQ{\n\tusing T = int;\n\tT operator()(const T &a, const T &b) { return min(a,b); };\n\tstatic constexpr T identity() { return INT_MAX; }\n\tvoid eval(T &a, const T &b) { a = b; };\n};\n\nstruct RAQ{\n\tusing T = int;\n\tT operator()(const T &a, const T &b) { return a + b; };\n\tstatic constexpr T identity() { return 0; }\n\tvoid eval(T &a, const T &b) { a += b; };\n};\n\ntemplate<class Monoid>\nclass rangeUpdateQuery{\n\tprivate:\n\t\tusing T = typename Monoid::T;\n\t\tMonoid op;\n\t\tconst int n;\n\t\tvector<T> dat, lazy;\n\t\tint query(int a, int b, int k, int l, int r){\n\t\t\tevaluate(k);\n\n\t\t\tif(b <= l || r <= a) return op.identity();\n\t\t\telse if(a <= l && r <= b) return dat[k];\n\t\t\telse{\n\t\t\t\tint vl = query(a, b, k * 2, l, (l + r) / 2);\n\t\t\t\tint vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\t\t\treturn op(vl, vr);\n\t\t\t}\n\t\t}\n\t\tinline void evaluate(int k){\n\t\t\tif(lazy[k] == op.identity()) return;\n\t\t\tdat[k] = lazy[k];\n\t\t\tif(k < n){\n\t\t\t\top.eval(lazy[2 * k], lazy[k]);\n\t\t\t\top.eval(lazy[2 * k + 1], lazy[k]);\n\t\t\t}\n\t\t\tlazy[k] = op.identity();\n\t\t}\n\t\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\t\tevaluate(k);\n\t\t\tif(r <= a || b <= l) return;\n\t\t\tif(a <= l && r <= b){\n\t\t\t\tlazy[k] = x;\n\t\t\t}else if(l < b && a < r){\n\t\t\t\tevaluate(k);\n\t\t\t\tupdate(a, b, k * 2, l, (l + r) / 2, x);\n\t\t\t\tupdate(a, b, k * 2 + 1, (l + r) / 2, r, x);\n\t\t\t}\n\t\t}\n\t\tint power(int n){\n\t\t\tint res = 1;\n\t\t\twhile(n >= res) res*=2;\n\t\t\treturn res;\n\t\t}\n\tpublic:\n\t\trangeUpdateQuery(int n) : n(power(n)), dat(4 * n, op.identity()), lazy(4 * n, op.identity()) {}\n\t\trangeUpdateQuery(const vector<T> &v) : n(v.size()), dat(4 * n), lazy(4 * n, op.identity()){\n\t\t\tcopy(begin(v), end(v), begin(dat) + n);\n\t\t\tfor(int i = n - 1; i > 0; i--) dat[i] = op(dat[2 * i], dat[2 * i + 1]);\n\t\t}\n\t\tint query(int a, int b){ return query(a,b,1,0,n); }\n\t\tvoid update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n\t\tint get(int a){ return query(a, a + 1); };\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\n\trangeUpdateQuery<RUQ> seg(n);\n\trep(i,q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(not com){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\t//cout << s << ' ' << t << endl;\n\t\t\tseg.update(s + 1, t + 2, x);\n\t\t}else{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tcout << seg.get(p + 1) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nstruct segtree {\n    vector<int> lazy, dat;\n    int n;\n\n    segtree(int n_, int init){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.assign(n*2, init);\n        lazy.assign(n*2, -1);\n    }\n\n\n    void set(int l, int r, int x){\n        static queue<tuple<int,int,int>> q;\n        q.emplace(0, n, 1);\n        while(q.size()){\n            int segl, segr, n;\n            tie(segl, segr, n) = q.front();\n            q.pop();\n            push(segl, segr, n);\n            if(segr <= l || r <= segl);\n            else if(l <= segl && segr <= r) lazy[n] = x;\n            else {\n                int segm = (segl + segr) / 2;\n                q.emplace(segl, segm, n*2);\n                q.emplace(segm, segr, n*2+1);\n            }\n        }\n    }\n\n    int get(int k){\n        return get(k, 0, n, 1);\n    }\n\n    int get(int k, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segl + 1 == segr) return dat[n];\n        int segm = (segl + segr) / 2;\n        if(k < segm) return get(k, segl, segm, n*2);\n        else return get(k, segm, segr, n*2+1);\n    }\n\n    void push(int segl, int segr, int node){\n        if(lazy[node] != -1){\n            dat[node] = lazy[node];\n            if(segl + 1 != segr){\n                lazy[node*2] = lazy[node];\n                lazy[node*2+1] = lazy[node];\n            }\n            lazy[node] = -1;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, q;\n    cin >> n >> q;\n    segtree st(n, 2147483647);\n    for(int iq = 0; iq < q; ++iq){\n        int t;\n        cin >> t;\n        // dump(t);\n        if(t == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            st.set(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.get(i) << '\\n';\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate <class T>\nstruct RangeSegTrees\n{\n\ttemplate<class TUpdater, class TResolver, class TAccumulator>\n\tstruct Tree\n\t{\n\t\tTree(int count, TUpdater updater, TResolver resolver, TAccumulator accumulator, T initialValue)\n\t\t\t: size(msb(count - 1) << 1)\n\t\t\t, data(size * 2), lazy(size * 2)\n\t\t\t, updater(updater), resolver(resolver), accumulator(accumulator), initialValue(initialValue)\n\t\t{\n\t\t\tlazy[1] = { true, initialValue };\n\t\t}\n\n\t\tvoid update_range(int begin, int end, T value)\n\t\t{\n\t\t\tupdate_range(begin, end, 1, 0, size, value);\n\t\t}\n\n\t\tT query(int begin, int end)\n\t\t{\n\t\t\treturn query(begin, end, 1, 0, size);\n\t\t}\n\n\tprivate:\n\t\tint size;\n\t\tvector<T> data;\n\t\tstruct LAZY { bool use; T val; };\n\t\tvector<LAZY> lazy;\n\n\t\tTUpdater updater;\n\t\tTResolver resolver;\n\t\tTAccumulator accumulator;\n\n\t\tT initialValue;\n\t\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\n\t\tvoid update_lazy(LAZY &val, T newVal)\n\t\t{\n\t\t\tif (val.use) { val.val = updater(val.val, newVal); }\n\t\t\telse { val.val = newVal; }\n\t\t\tval.use = true;\n\t\t}\n\n\t\tvoid propergate(int i, int l, int r)\n\t\t{\n\t\t\tif (lazy[i].use)\n\t\t\t{\n\t\t\t\tdata[i] = resolver(data[i], lazy[i].val, r - l);\n\t\t\t\tif (i < size)\n\t\t\t\t{\n\t\t\t\t\tupdate_lazy(lazy[i * 2], lazy[i].val);\n\t\t\t\t\tupdate_lazy(lazy[i * 2 + 1], lazy[i].val);\n\t\t\t\t}\n\t\t\t\tlazy[i] = { false, initialValue };\n\t\t\t}\n\t\t}\n\n\t\tT update_range(int s, int e, int i, int l, int r, T value)\n\t\t{\n\t\t\tif (r <= s || e <= l)\n\t\t\t{\n\t\t\t\tpropergate(i, l, r);\n\t\t\t\treturn data[i];\n\t\t\t}\n\n\t\t\tif (s <= l && r <= e)\n\t\t\t{\n\t\t\t\tupdate_lazy(lazy[i], value);\n\t\t\t\tpropergate(i, l, r);\n\t\t\t\treturn data[i];\n\t\t\t}\n\t\t\t\n\t\t\tpropergate(i, l, r);\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn data[i] = accumulator(\n\t\t\t\tupdate_range(s, e, i * 2, l, m, value),\n\t\t\t\tupdate_range(s, e, i * 2 + 1, m, r, value));\n\t\t}\n\n\t\tT query(int s, int e, int i, int l, int r)\n\t\t{\n\t\t\tpropergate(i, l, r);\n\t\t\tif (s <= l && r <= e) { return data[i]; }\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (s < m && e > m)\n\t\t\t{\n\t\t\t\treturn accumulator(query(s, e, i * 2, l, m), query(s, e, i * 2 + 1, m, r));\n\t\t\t}\n\t\t\treturn s < m\n\t\t\t\t? query(s, e, i * 2, l, m)\n\t\t\t\t: query(s, e, i * 2 + 1, m, r);\n\t\t}\n\t};\n\n\ttemplate <class TUpdater, class TResolver, class TAccumulator>\n\tstatic auto RangeSegTree(int n, TUpdater upd, TResolver res, TAccumulator acm, T initial)\n\t{\n\t\treturn Tree<TUpdater, TResolver, TAccumulator>(n, upd, res, acm, initial);\n\t}\n\n\tstatic auto RangeUpdateQuery(int n, T initial = numeric_limits<int>::max())\n\t{\n\t\treturn RangeSegTree(n, CONV2(,b,b), CONV3(,b,,b), CONV2(,b,b), initial);\n\t}\n\n\tstatic auto RangeAddQuery(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a,b,a+b), CONV3(a,b,c,a+b*c), CONV2(a,b,a+b), initial);\n\t}\n\n\tstatic auto RMQnRUQ(int n, T initial = numeric_limits<int>::max())\n\t{\n\t\treturn RangeSegTree(n, CONV2(,b,b), CONV3(,b,,b), CONV2(a, b, min(a, b)), initial);\n\t}\n\n\tstatic auto RSQnRAQ(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a,b,a+b), CONV3(a,b,c,a+b*c), CONV2(a,b,a+b), initial);\n\t}\n\n\tstatic auto RMQnRAQ(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a,b,a+b), CONV3(a,b,,a+b), CONV2(a,b,min(a,b)), initial);\n\t}\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTrees<llong>::RangeUpdateQuery(n);\n\tint origin = 0;\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s - origin, t + 1 - origin, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, s);\n\t\t\tllong v = tree.query(s - origin, s + 1 - origin);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n\n  fill(a,a+n,2147483647);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      fill_n(a+s,t+1,x);\n    }\n    else{\n      int x;\n      cin >> x;\n      cout << a[x] << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull INF = ULLONG_MAX/3;\n\nvoid latentEvaluation(int ss, vector<ull> &xList, vector<ull> &sxList){\n    int sn = sxList.size();\n    if(sxList[ss] != INF){\n        for(int i=0;i<sn;i++){\n            xList[sn*ss+i] = sxList[ss];\n        }\n        sxList[ss] = INF;\n    }\n}\n\nvoid update(int s, int t, ull x, vector<ull> &xList, vector<ull> &sxList){\n    int nn = xList.size();\n    int sn = sxList.size();\n    int ss = s/sn;\n    int tt = t/sn;\n    if(ss == tt){\n        latentEvaluation(ss, xList, sxList);\n        for (int i=0;i<t-s+1;i++){\n            xList[s+i] = x;\n        }\n    }else{\n        latentEvaluation(ss, xList, sxList);\n        for(int i=s;i<(ss+1)*sn;i++){\n            xList[i] = x;\n        }\n\n        latentEvaluation(tt, xList, sxList);\n        for(int i=tt*sn;i<t+1;i++){\n            xList[i] = x;\n        }\n\n        for(int i=ss+1;i<tt;i++){\n            sxList[i] = x;\n        }\n    }\n}\n\nvoid find(int ind, vector<ull> &xList, vector<ull> &sxList){\n    int nn = xList.size();\n    int sn = sxList.size();\n    latentEvaluation(ind/sn, xList, sxList);\n    cout << xList[ind] << endl;\n}\n\nint main(){\n    int n, q, qType, s, t,ind;\n    ull x;\n    cin >> n >> q;\n    int sn = sqrt(n)+1;\n\n    vector<ull> xList(sn*sn, (1ull << 31) -1);\n\n    vector<ull> sxList(sn, INF);\n\n    for (int i=0;i<q;i++){\n        cin >> qType;\n        if (qType == 0){\n            cin >> s >> t >> x;\n            update(s,t,x,xList,sxList);\n        }else{\n            cin >> ind;\n            find(ind, xList, sxList);\n        }\n\n        for (int i=0;i<sn*sn;i++){\n            cout << xList[i]  << \" \";\n        }\n        cout << endl;\n        for (int i=0;i<sn;i++){\n            cout << sxList[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nclass RangeSeg{\n\tint n;\n\tvector<ll> data, lazy;\npublic:\n\tRangeSeg(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n <<= 1;\n\t\tREP(i, n*2-1){\n\t\t\tdata.push_back(-1);\n\t\t\tlazy.push_back(-1);\n\t\t}\n\t}\n\n\tvoid push(int l, int r, int k){\n\t\tif(lazy[k] != -1){\n\t\t\tdata[k] = lazy[k];\n\t\t\tif(r - l > 1){\n\t\t\t\tlazy[k*2+1] = lazy[k];\n\t\t\t\tlazy[k*2+2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int l, int r, int k, int x){\n\t\tpush(l, r, k);\n\t\tif(s <= l && r <= t){\n\t\t\tlazy[k] = x;\n\t\t\tpush(l, r, k);\n\t\t}else if(l < t && s < r){\n\t\t\tupdate(s, t, (l+r)/2, r, k*2+2, x);\n\t\t\tupdate(s, t, l, (l+r)/2, k*2+1, x);\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tupdate(s, t, 0, n, 0, x);\n\t}\n\t\n\tvoid show(){\n\t\tint i = 0;\n\t\tint en = 1;\n\t\twhile(i < n*2-1){\n\t\t\tcout << \"(\" << data[i] << \", \" << lazy[i] << \") \";\n\t\t\tif(i == en*2-2){\n\t\t\t\tcout << endl;\n\t\t\t\ten *= 2;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tll find(int l, int r, int k, int i){\n\t\tpush(l, r, k);\n\t\tif(r-l == 1){\n\t\t\treturn data[k];\n\t\t}\n\t\tif(l <= i && i <= r){\n\t\t\tif((l+r)/2 <= i){\n\t\t\t\treturn find((l+r)/2, r, k*2+2, i);\n\t\t\t}else{\n\t\t\t\treturn find(l, (l+r)/2, k*2+1, i);\n\t\t\t}\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tll find(int i){\n\t\treturn find(0, n, 0, i);\n\t}\t\n};\n\nint main(void){\n\tint n, q;\n\tcin >> n >> q;\n\tRangeSeg rs(n);\n\tREP(i, q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(com == 0){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\trs.update(s, t+1, x);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tx = rs.find(x);\n\t\t\tif(x == -1)\n\t\t\t\tcout << ((ll)1 << 31)-1 << endl;\n\t\t\telse\n\t\t\t\tcout << x << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 100000\n#define MAX (1<<31)-1\nusing namespace std;\nint A[N], T[4*N], lazy[4*N];\n\nvoid build(int l, int r, int k) {\n    if (l == r) {\n        T[k] = A[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(l, mid, k * 2);\n    build(mid + 1, r, k * 2 + 1);\n    T[k] = min(T[2 * k], T[2 * k + 1]);\n}\nvoid pushdown(int k) {\n    if (lazy[k] != -1) {\n        lazy[2*k] = lazy[k];\n        lazy[2*k+1] = lazy[k];\n        T[2*k] =  lazy[k];\n        T[2*k+1] = lazy[k];\n        lazy[k] = -1;\n    }\n}\nvoid updata(int L, int R, int data ,int l, int r ,int k) {\n    if (L <= l && r <= R) {\n        T[k] = data;\n        lazy[k] = data;\n        return;\n    }\n    pushdown(k);\n    int mid = (l + r) / 2;\n    if (mid >= L) updata(L, R, data, l, mid, 2*k);\n    if (mid < R) updata(L, R, data, mid+1, r, 2*k+1);\n    T[k] = min(T[2 * k], T[2 * k + 1]);\n}\nint find(int L, int R, int l, int r, int k) {\n    if (L <= l && r <= R) return T[k];\n    pushdown(k);\n    int mid = (l + r) / 2;\n    int ans = MAX;\n    if (mid >= L) ans = min(ans, find(L, R, l, mid, k * 2));\n    if (mid < R) ans = min(ans, find(L, R, mid + 1, r, k * 2 + 1));\n    return ans;\n}\nint main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    for (int i = 0; i < n; i++)\n        A[i] = MAX;\n    for (int i = 0; i < 4*n; i++)\n        lazy[i] = -1;\n    build(0, n - 1, 1);\n    int com, s, t, x, y;\n    while (q--) {\n        scanf(\"%d\", &com);\n        if (com == 0) {\n            scanf(\"%d%d%d\", &s, &t, &x);\n            updata(s, t, x, 0, n - 1, 1);\n        }\n        else {\n            scanf(\"%d\", &x);\n            printf(\"%d\\n\", find(x, x, 0, n - 1, 1));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct SegmentTree {\nprivate:\n    //////////////////////\n    // TODO Change them //\n    //////////////////////\n    constexpr static int UPDATE_IDENTITY_ELEMENT = 0;\n    constexpr static int CALCULATE_IDENTITY_ELEMENT = INT_MAX;\n    constexpr static bool IS_LAZY = true;\n\n    inline static void update(ll &x, ll y) { x = y; }\n\n    inline static ll calculate(ll x, ll y) { return min(x, y); }\n\n    inline void evaluation(int index, int nowL, int nowR) {\n        if (changed[index]) {\n            update(data[index], lazy[index]); // TODO Change updating\n            if (nowR - nowL > 1) {\n                update(lazy[index * 2], lazy[index]), changed[index * 2] = true;\n                update(lazy[index * 2 + 1], lazy[index]), changed[index * 2 + 1] = true;\n            }\n            lazy[index] = UPDATE_IDENTITY_ELEMENT, changed[index] = false;\n        }\n    }\n    //////////////////////\n    // TODO Change them //\n    //////////////////////\n\n\n    int n;\n    vector<ll> data;\n    vector<ll> lazy;\n    vector<bool> changed;\n\n    void initialize(int size, vector<ll> &v) {\n        n = 1;\n        while (n < size)n <<= 1;\n        data.resize(2 * n);\n        if (IS_LAZY) {\n            lazy.assign(2 * n, UPDATE_IDENTITY_ELEMENT);\n            changed.resize(2 * n);\n        }\n\n        for (int i = n; i < n + v.size(); i++)data[i] = v[i - n];\n        for (int i = n - 1; i > 0; i--)data[i] = children(i);\n    }\n\n    inline ll children(int index) { return calculate(data[index * 2], data[index * 2 + 1]); }\n\n    inline void update_point(int index, int value) {\n        index += n;\n        update(data[index], value);\n        while (index > 1) {\n            index >>= 1;\n            data[index] = children(index);\n        }\n    }\n\n    inline void update_range(int wantL, int wantR, ll value, int index, int nowL, int nowR) {\n        evaluation(index, nowL, nowR);\n\n        if (nowR <= wantL || wantR <= nowL)return;\n\n        if (wantL <= nowL && nowR <= wantR) {\n            update(lazy[index], value), changed[index] = true;\n            evaluation(index, nowL, nowR);\n        } else {\n            int mid = (nowL + nowR) / 2;\n            update_range(wantL, wantR, value, index * 2, nowL, mid);\n            update_range(wantL, wantR, value, index * 2 + 1, mid, nowR);\n            data[index] = children(index);\n        }\n    }\n\n    inline ll query(int wantL, int wantR, int index, int nowL, int nowR) {\n        if (nowR <= wantL || wantR <= nowL)return CALCULATE_IDENTITY_ELEMENT;\n\n        if (IS_LAZY)evaluation(index, nowL, nowR);\n        if (wantL <= nowL && nowR <= wantR) return data[index];\n        else {\n            int mid = (nowL + nowR) / 2;\n            ll valueL = query(wantL, wantR, index * 2, nowL, mid);\n            ll valueR = query(wantL, wantR, index * 2 + 1, mid, nowR);\n            return calculate(valueL, valueR);\n        }\n    }\n\npublic:\n    SegmentTree(int size, ll value) {\n        vector<ll> tmp(size, value);\n        initialize(size, tmp);\n    }\n\n    SegmentTree(vector<ll> &v) { initialize(v.size(), v); }\n\n    inline void update(int index, ll value) {\n        if (IS_LAZY) update(index, index + 1, value);\n        else update_point(index, value);\n    }\n\n    inline void update(int indexL, int indexR, ll value) {\n        if (IS_LAZY) update_range(indexL, indexR, value, 1, 0, n);\n        else {\n            for (int i = indexL; i < indexR; i++)update(i, value);\n        }\n    }\n\n    inline ll get(int index) { return get(index, index + 1); }\n\n    inline ll get(int indexL, int indexR) { return query(indexL, indexR, 1, 0, n); }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree seg(n, INT_MAX);\n    for (int i = 0; i < q; i++) {\n        int com;\n        cin >> com;\n        if (com == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s;\n            cin >> s;\n            cout << seg.get(s) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        if(Tree[level].size() == 1)\n            return;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][iter]);\n            iter++;\n        }\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        if(n == UNDEF){\n            if(level == Tree.size() - 1){\n                DownValue(level, key);\n                return UNDEF;\n            }\n            else if(Tree[level][key].value == UNDEF)\n                return UNDEF;\n            else{\n                \n                UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n                DownValue(level, key);\n                return UNDEF;\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        \n        if(level < Tree.size() - 1){\n            UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n            DownValue(level, key, before);\n        }\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    void DownValue(int level, int key){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        Tree[level - 1][2 * key].value = tmp;\n        if(2 * key + 1 < Tree[level - 1].size())\n            Tree[level - 1][2 * key + 1].value = tmp;\n        \n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        \n        if((Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF) || level == 0)\n            return Tree[level][0].value;\n        \n        if(target <= Tree[level - 1][0].high)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= Tree[level - 1][2 * key].high || 2 * key + 1 > Tree[level - 1].size() - 1)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int A[100000];\n    int i, s, t, x, n, q, ask;\n\n    for(i = 0; i < 100000; i++) A[i] = INT_MAX;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n\t\tif(ask){\n            cin >> i;\n            cout << A[i] << endl;\n\t\t}else{\n            cin >> s >> t >> x;\n\t\t\tfor(i = s; i <= t; i++) A[i] = x;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, int> pli;\ntypedef pair<lint, lint> pll;\ntypedef complex<double> xy_t;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 200010;\n\ntemplate<typename T> struct SegTree_dual{\n    using F=function<T(T, T)>;\n    int sz=1;\n    T et;\n    F f, g;\n    vector<T> node;\n\n    SegTree_dual(int sz_, T et_, F f_, F g_): et(et_), f(f_), g(g_){\n        while(sz<sz_) sz<<=1;\n        node.resize(sz<<1, et);\n    }\n\n    void update(int l, int r, T x){\n        for(l+=sz, r+=sz; l<r; l>>=1, r>>=1){\n            if(l&1){\n                node[l]=g(node[l], x);\n                l++;\n            }\n            if(r&1){\n                --r;\n                node[r]=g(node[r], x);\n            }\n        }\n    }\n\n    T query(int i){\n        i+=sz;\n        T val=node[i];\n        i>>=1;\n        while(i){\n            val=f(val, node[i]);\n            i>>=1;\n        }\n        return val;\n    }\n};\n\nint main(){\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    auto f=[](pii a, pii b){return max(a, b);};\n    auto g=[](pii a, pii b){return b;};\n    SegTree_dual<pii> st(n, {-1, INT_MAX}, f, g);\n\n    rep(time, q){\n        int c;\n        scanf(\"%d\", &c);\n        if(c==0){\n            int s, t, x;\n            scanf(\"%d%d%d\", &s, &t, &x);\n            st.update(s, t+1, {time, x});\n        }\n        else{\n            int i;\n            scanf(\"%d\", &i);\n            printf(\"%d\\n\", st.query(i).se);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n#define INF INT_MAX\nint n;\nvi seg;\nvi lazy;\n\nvoid update(int index, int x) {\n  seg[n + index] += x;\n  for (int i = n + index; i >= 2; i /= 2) {\n    seg[i/2] = seg[i] + seg[i^1];\n  }\n}\n\nvoid propagate(int k) {\n  if (lazy[k] == INF) {\n    return;\n  }\n  seg[k] = lazy[k];\n  if (k < n) {\n    lazy[k*2] = lazy[k];\n    lazy[k*2+1] = lazy[k];\n  }\n  lazy[k] = INT_MAX;\n}\n\n// seg[k] : [l, r)\nvoid range_update(int a, int b, int k, int l, int r, int x) {\n  if (r <= a || b <= l) {\n    return;\n  }\n  if (a <= l && r <= b) {\n    lazy[k] = x;\n    propagate(k);\n    return;\n  } else {\n    propagate(k);\n    range_update(a, b, k*2, l, (l+r)/2, x);\n    range_update(a, b, k*2+1, (l+r)/2, r, x);\n  }\n}\n\nint range_get(int x, int k, int l, int r) {\n  propagate(k);\n  if (x < l || r <= x) {\n    return INF;\n  }\n  if (l == x && r == x+1) {\n    return seg[k];\n  } else {\n    return min(range_get(x, k*2, l, (l+r)/2), range_get(x, k*2+1, (l+r)/2, r));\n  }\n}\n\nint get_query(int x) {\n  return range_get(x, 1, 0, n);\n}\n\nint main() {\n  int n_, q;\n  scanf(\"%d %d\", &n_, &q);\n  n = (1 << (int)(ceil(log2(n_))));\n  seg.assign(2*n, INT_MAX);\n  lazy.assign(2*n, INT_MAX);\n  int op, s, t, x;\n  rep (i, q) {\n    scanf(\"%d\", &op);\n    if (op == 0) {\n      scanf(\"%d %d %d\", &s, &t, &x);\n      t += 1;\n      range_update(s, t, 1, 0, n, x);\n    } else {\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", get_query(x));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n \n#define siz 10000000\n \nchar buf[siz], *bit = buf;\n \ninline int nextInt(void) {\n    register int ret = 0;\n    register int neg = false;\n \n    for (; *bit < '0'; ++bit)\n        if (*bit == '-')neg ^= true;\n \n    for (; *bit >= '0'; ++bit)\n        ret = ret * 10 + *bit - '0';\n \n    return neg ? -ret : ret;\n}\n \n#define inf 2147483647\n \nint n, m;\n \nint tag[400005];\n \nint find(int t, int l, int r, int p) {\n    if (~tag[t])\n        return tag[t];\n    int mid = (l + r) >> 1;\n    if (p <= mid)\n        return find(t << 1, l, mid, p);\n    else\n        return find(t << 1 | 1, mid + 1, r, p);\n}\n \nvoid update(int t, int l, int r, int x, int y, int k) {\n    if (l == x && r == y)\n        tag[t] = k;\n    else {\n        int mid = (l + r) >> 1;\n        if (~tag[t])\n            tag[t << 1] = tag[t << 1 | 1] = tag[t], tag[t] = -1;\n        if (y <= mid)\n            update(t << 1, l, mid, x, y, k);\n        else if (x > mid)\n            update(t << 1 | 1, mid + 1, r, x, y, k);\n        else {\n            update(t << 1, l, mid, x, mid, k);\n            update(t << 1 | 1, mid + 1, r, mid + 1, y, k);\n        }\n    }\n}\n \nsigned main(void) {\n    fread(buf, 1, siz, stdin);\n \n    n = nextInt();\n    m = nextInt();\n \n    for (int i = 0; i < (n << 2); ++i)\n        tag[i] = inf;\n \n    for (int i = 1; i <= m; ++i) {\n        int c = nextInt();\n        if (c)  // find(x)\n            printf(\"%d\\n\", find(1, 1, n, nextInt() + 1));\n        else {\n            int x = nextInt();\n            int y = nextInt();\n            int k = nextInt();\n            update(1, 1, n, x + 1, y + 1, k);\n        }\n    }\n \n    //system(\"pause\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define siz 10000000\n\nchar buf[siz], *bit = buf;\n\ninline int nextInt(void) {\n\tregister int ret = 0;\n\tregister int neg = false;\n\n\tfor (; *bit < '0'; ++bit)\n\t\tif (*bit == '-')neg ^= true;\n\n\tfor (; *bit >= '0'; ++bit)\n\t\tret = ret * 10 + *bit - '0';\n\n\treturn neg ? -ret : ret;\n}\n\n#define inf 2147483647\n\nint n, m;\n\nint tag[400005];\n\nint find(int t, int l, int r, int p) {\n\tif (~tag[t])\n\t\treturn tag[t];\n\tint mid = (l + r) >> 1;\n\tif (p <= mid)\n\t\treturn find(t << 1, l, mid, p);\n\telse\n\t\treturn find(t << 1 | 1, mid + 1, r, p);\n}\n\nvoid update(int t, int l, int r, int x, int y, int k) {\n\tif (l == x && r == y)\n\t\ttag[t] = k;\n\telse {\n\t\tint mid = (l + r) >> 1;\n\t\tif (~tag[t])\n\t\t\ttag[t << 1] = tag[t << 1 | 1] = tag[t], tag[t] = -1;\n\t\tif (y <= mid)\n\t\t\tupdate(t << 1, l, mid, x, y, k);\n\t\telse if (x > mid)\n\t\t\tupdate(t << 1 | 1, mid + 1, r, x, y, k);\n\t\telse {\n\t\t\tupdate(t << 1, l, mid, x, mid, k);\n\t\t\tupdate(t << 1 | 1, mid + 1, r, mid + 1, y, k);\n\t\t}\n\t}\n}\n\nsigned main(void) {\n\tfread(buf, 1, siz, stdin);\n\n\tn = nextInt();\n\tm = nextInt();\n\n\tfor (int i = 0; i < (n << 2); ++i)\n\t\ttag[i] = inf;\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint c = nextInt();\n\t\tif (c)\t// find(x)\n\t\t\tprintf(\"%d\\n\", find(1, 1, n, nextInt() + 1));\n\t\telse {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tupdate(1, 1, n, x + 1, y + 1, k);\n\t\t}\n\t}\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n  \nint t[(1<<18)];\n  \nvoid Set(int a,int b,int x,int k=0,int l=0,int r=(1<<17)){\n  if(b<=l || r<=a)return;\n  if(a<=l && r<=b){\n    t[k]=max(t[k],x);\n    return;\n  }\n  int m=(l+r)/2;\n  Set(a,b,x,k*2+1,l,m);\n  Set(a,b,x,k*2+2,m,r);\n}\n  \nint Get(int i){\n  i+=(1<<17)-1;\n  int res=t[i];\n  while(i){\n    i=(i-1)/2;\n    res=max(res,t[i]);\n  }\n  return res;\n}\n           \nint n,q;\nint value[100005];\n  \nint main(){\n  value[0]=2147483647;\n    \n  scanf(\"%d %d\",&n,&q);\n  for(int i=1;i<=q;i++){\n    int type;\n    scanf(\"%d\",&type);\n    if(type==0){\n      int l,r;\n      scanf(\"%d %d %d\",&l,&r,&value[i]);\n      r++;\n      Set(l,r,i);\n    }else{\n      int target;\n      scanf(\"%d\",&target);\n      int ans=Get(target);\n      printf(\"%d\\n\",value[ans]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  ll lazy[sq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(t >= sq*sq){\n\t//cout << \"deug\" << endl;\n\tfill_n(a+sq*sq,t%sq+1,x);\n      }\n      if(s == t){\n\ta[s] = x;\n      }\n      else if((t-s) <= sq){\n\tfill_n(a+s,t-s+1,x);\n      }\n      else{\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-s+1,x);\n\tfill_n(a+s,f-s,x);\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else if(te == sq){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq+1,lazy[te]);\n\tcout << a[x] << endl;\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\ntemplate<typename Monoid> class RangeActionSegTree {\n  using T = typename Monoid::value_type;\n\n  Monoid m;\n  vector<T> tree; // 1-indexed\n  int size = 1;\n\n  void push(int x) {\n    if (x <= 1) return;\n    push(x /= 2);\n    tree[x * 2] = m(tree[x * 2], tree[x]);\n    tree[x * 2 + 1] = m(tree[x * 2 + 1], tree[x]);\n    tree[x] = m.id();\n  }\n\npublic:\n  RangeActionSegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n  }\n\n  RangeActionSegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n    fill(tree.begin() + size, tree.end(), x);\n  }\n\n  template<typename InputIterator> RangeActionSegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, m.id());\n    copy(first, last, tree.begin() + size);\n  }\n\n  void act(int l, int r, const T &x) { // [l, r) += x\n    for (push(l += size), push((r += size) - 1); l < r; l /= 2, r /= 2) {\n      if (l & 1) tree[l] = m(tree[l], x), l++;\n      if (r & 1) r--, tree[r] = m(tree[r], x);\n    }\n  }\n\n  T operator[](int i) {\n    T acc = tree[i += size];\n    while (i /= 2) acc = m(acc, tree[i]);\n    return acc;\n  }\n};\n\ntemplate<typename T> class RangeUpdateSegTree {\n  struct updateMonoid {\n    using value_type = pair<bool, T>;\n    value_type id() { return {false, T()}; }\n    value_type operator()(const value_type &a, const value_type &b) { return b.first ? b : a; }\n  };\n  RangeActionSegTree<updateMonoid> rast;\n\npublic:\n  RangeUpdateSegTree(const int &n = 0) : rast(n) {}\n  RangeUpdateSegTree(const int &n, const T &x) : rast(n, {true, x}) {}\n  template<typename InputIterator> RangeUpdateSegTree(InputIterator first, InputIterator last) : rast(first, last) {}\n  void update(const int &l, const int &r, const T &x) { rast.act(l, r, {true, x}); }\n  T operator[](const int &i) { return rast[i].second; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  RangeUpdateSegTree<int> rust(n, 2147483647);\n  while (q--) {\n    if (in()) {\n      int i;\n      cin >> i;\n      cout << rust[i] << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      rust.update(s, t + 1, x);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define debug //*******************************************************************************************************************************************\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// [Tips]\n// XCode??§???EOF??\\??????Ctrl+D\n// ?\\???Alt+\\\n// ans???????§?INT?????????2,147,483,647????¶????????????¨??????????????§long long?????£???????????????????????????\n// 2?????°??¨??? = dout << static_cast<bitset<8> >(x)\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n////////////////////////////////////////\n//AIZU\n//Range Update Query (RUQ)\n//\n//Segment Tree??§????£?\n////////////////////////////////////////\n\n\n#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n#include <iterator> //insert_iterator::inserter\n#include <set>\n\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //**************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scand(A) scanf(\"%d\", &(A))\n#define scans(A) scanf(\"%s\", (A))\n#define printd(A) dout << \"%d\\n\", (A))\n#define prints(A) dout << \"%s\\n\", (A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define show(A,s,g) dout << #A << \" = \"; rep(__w, (s), (g)) {disP(A[__w]);} dout << endl\n#define showi(A,s,g) dout << #A << \" = \"; rep(__w, (s), (g)) {disP(__w);} dout << endl\n#define line  dout << \"----------------\\n\"\n#define line2 dout << \"================\\n\"\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) ((i)/2)\n#define l(i) ((i)*2)\n#define r(i) ((i)*2+1)\n#define sibling(i) (i^1) //the other sibling of i (ex. 16^1 = 17, 17^1 = 16)\n#define isRightChild(i) (i&1) // ex. 16&1 = 0, 17&1 = 1\n#define isLeftChild(i) (!(i&1)) // ex. 16&1 = 1, 17&1 = 0\n\n\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = (1LL<<31)-1;\nconst int NONE = -1;\n//const ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\n//const ull INF_ULL = (ull)1e19-1ULL;\n//#define MOD 1000000007 //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\n#define N_MAX 100010 //num of vertex or element\n//#define M_MAX 124760 //num of edge\n//#define DATA_MAX 1010\n\nint N;\nint M; //N????????§??????????°????2????????????????????????a[M]?????????????????¨??????\nint a[N_MAX<<2]; //Segment Tree. Do not use a[0]\n\n\n\n\nvoid display() {\n#ifdef debug\n    dout << \"------------------------- display() ---------------------\\n\";\n    \n    //    dout << \"   \"; showi(j,0,N+1);\n    //    dout << \"C[][] = \\n\";\n    //    rep(i,0,N+1) {\n    //        disP(i); dout << \" : \";\n    //        rep(j,0,N+1) {\n    //            disP(C[i][j]);\n    //        }\n    //        dout << endl;\n    //    }\n    //    dout << endl;\n    \n    showi(i,1,M<<1);\n    dout << \"a = \";\n    rep(i,1,M<<1) disP( a[i]==INF ? 999 : a[i] );\n    dout << endl;\n    line;\n    \n    //    int w = 1;\n    //    while(w<N) w<<=1;\n    \n    dout << \"   \"; showi(i,0,M);\n    \n    for(int b=1; b<M<<1; b<<=1) {\n        \n        int m = M/b;\n        \n        disP(b); dout << \" : \";\n        rep(j,0,M) {\n            if(j%m==0) disP(a[b+j/m]==INF ? 999 : a[b+j/m]);\n            else disP(\"-\");\n        }\n        dout << endl;\n        \n    }\n    dout << endl;\n    \n    \n    \n    dout << \"------------------------- end of display() ---------------------\\n\";\n#endif\n}\n\n\n\n\n\n\nvoid lazyUpdate(int i, int x) { //a[i]??????????????????x??§update??????\n    \n#ifdef debug\n    dout << \"lazyUpdate( i=\" << i << \", x=\" << x << \" )\\n\";\n#endif\n    \n    if(i>=M<<1) return;\n    \n    if( M<=i and i<M<<1) {\n        a[i] = x;\n        return;\n    }\n    else {\n        //?????????????????????????????°????????????\n        a[i] = NONE;\n        lazyUpdate(l(i), x);\n        lazyUpdate(r(i), x);\n    }\n    \n}\n\n\n\n\nvoid recursive_update(int i, int l, int r, int s, int t, int x) { //????????????[s,t)????????????x?????´??°??????????????????????????????a[i]??§???a[i]???????????????[l,r)????????°??§??????????????????\n#ifdef debug\n    dout << \"--- rec_update( i=\" << i << \" a[i]?????????=[\" << l << \",\" << r << \") | ??´??°??????=[\" << s << \",\" << t << \"), x=\" << x << \" )\\n\";\n#endif\n    \n    //??´??°????±???????[s,t)??¨???????????????????????????a[i]???????????????[l,r)??????????????????\n    if( r<=s or t<=l ) {\n#ifdef debug\n        dout << \"????????????\\n\";\n#endif\n        return;\n    }\n    \n    //??´??°????±???????[s,t)??????????????????????????????a[i]???????????????[l,r)????????¨???????????????\n    if( s<=l and r<=t ) {\n#ifdef debug\n        dout << \"????????????????????´??°????±???????????????¨?????????????????????\\n\";\n#endif\n        a[i] = x;\n        return;\n    }\n    \n    //???????????§???a[i]?????´??°???????????£???????????´????????????????????±??????????????????????????????????????°????????????????????§???????????\\???\n    if( a[i]!=NONE ) {\n#ifdef debug\n        dout << \"a[i]????????§?????´??°???????????£??????????????§????????????????????±???????????????????????????\\n\";\n#endif\n        lazyUpdate(i, a[i]);\n        display();\n    }\n    \n    //??????????????????????????°????????????\n    recursive_update(l(i), l, (l+r)/2, s, t, x);\n    \n    //??????????????????????????°????????????\n    recursive_update(r(i), (l+r)/2, r, s, t, x);\n    \n}\n\n\n\nvoid update(int s, int t, int x) { //?????????[s,t]????????????x?????´??°??????\n#ifdef debug\n    dout << \"--- update( s=\" << s << \", t=\" << t << \", x = \" << x << \" )\\n\";\n#endif\n    \n    recursive_update(1, 0, M, s, t+1, x);\n}\n\n//void update(int s, int t, int x) {\n//#ifdef debug\n//    dout << \"--- update( s=\" << s << \", t=\" << t << \", x = \" << x << \" )\\n\";\n//#endif\n//    \n//    for(s+=N, t+=N; s<=t; s=p(s+1), t=p(t-1) ) {\n//        \n//        //lazy update check\n//        if( a[s]!=NONE ) {\n//            lazyUpdate(s, a[s]);\n//        }\n//        if( a[t]!=NONE ) {\n//            lazyUpdate(t, a[t]);\n//        }\n//        \n//        //normal procedure for update()\n//        if( isRightChild(s) ) {\n//            a[s] = x;\n//        }\n//        if( isLeftChild(t) ) {\n//            a[t] = x;\n//        }\n//        \n//    }\n//}\n\n\n\n\n\n\n\n\n\n\nint find(int i) {\n    \n#ifdef debug\n    dout << \"--- find( i=\" << i << \" )\\n\";\n#endif\n    \n    //lazy update check\n    for(int j=p(M+i); j>0; j=p(j)) {\n        \n        if(a[j]!=NONE) {\n#ifdef debug\n        dout << \"a[\" << j << \"] = \" << a[j] << \" ??¨????????´??°???????????£??????????????§????????????????????±???????????????????????????\\n\";\n#endif\n            lazyUpdate(j, a[j]);\n        }\n    }\n    \n    //just find\n    return a[M+i];\n    \n}\n\n\n\nvoid init() {\n    \n    for(M=1; M<N; M<<=1);\n    \n    rep(i,0,M) {\n        a[i] = NONE;\n    }\n    rep(i,0,M) {\n        a[i+M] = INF;\n    }\n}\n\n\n\n\n\n\n\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    \n    //read input data\n    din >> N;\n    init();\n    \n    int Q; din >> Q;\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n\n    int q, s, t, x;\n    rep(i,0,Q) {\n        \n        display();\n        \n        din >> q;\n        if(q) {\n            din >> s;\n            dout << find(s) << endl;\n        }\n        else {\n            din >> s >> t >> x;\n            update(s, t, x);\n        }\n    }\n    \n    \n    \n    \n    \n#ifdef debug\n    dout << \"=== OUTPUT ===\\n\";\n#endif\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#ifdef OUTPUTFILE\n    cout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\n/**\n * @brief Dual-Segment-Tree(双対セグメント木)\n * @docs docs/dual-segment-tree.md\n */\ntemplate< typename OperatorMonoid >\nstruct DualSegmentTree {\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  int sz, height;\n  vector< OperatorMonoid > lazy;\n  const H h;\n  const OperatorMonoid OM0;\n\n  DualSegmentTree(int n, const H h, const OperatorMonoid &OM0) : h(h), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while(sz < n) sz <<= 1, height++;\n    lazy.assign(2 * sz, OM0);\n  }\n\n  inline void propagate(int k) {\n    if(lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n  }\n\n  OperatorMonoid operator[](int k) {\n    thrust(k += sz);\n    return lazy[k];\n  }\n};\n\n\nint main() {\n  int N, Q;\n  cin >> N >> Q;\n  auto h = [](int a, int b) { return b; };\n  DualSegmentTree< int > seg(N, h, INT_MAX);\n  while(Q--) {\n    int com;\n    cin >> com;\n    if(com == 0) {\n      int l, r, x;\n      cin >> l >> r >> x;\n      seg.update(l, r + 1, x);\n    } else if(com == 1) {\n      int k;\n      cin >> k;\n      cout << seg[k] << \"\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\n#define all(v) v.begin(), v.end()\nbool chmin(ll & a, ll  b) { if (b < a) { a = b; return 1; } return 0; }\nbool chmax(ll & a, ll b) { if (b > a) { a = b; return 1; } return 0; }\nconst ll INF = (1LL<<31)-1;\nconst ll MOD = 1000000007;\nconst ll MAX_N=500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  typedef function<E(E,E)> H;\n  typedef function<E(E,ll)> P;\n  ll n;\n  F f;\n  G g;\n  H h;\n  P p;\n  T d1;\n  E d0;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(ll n_,F f,G g,H h,T d1,E d0,\n\t      vector<T> v=vector<T>(),P p=[](E a,ll b){return a;}):\n    f(f),g(g),h(h),d1(d1),d0(d0),p(p){\n    init(n_);\n    if(n_==(ll)v.size()) build(n_,v);\n  }\n  void init(ll n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n    laz.clear();\n    laz.resize(2*n-1,d0);\n  }\n  void build(ll n_, vector<T> v){\n    for(ll i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(ll i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(ll len,ll k){\n    if(laz[k]==d0) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=d0;\n  }\n  T update(ll a,ll b,E x,ll k,ll l,ll r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(ll a,ll b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(ll a,ll b,ll k,ll l,ll r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return d1;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(ll a,ll b){\n    return query(a,b,0,0,n);\n  }\n};\n    auto F = [](ll a, ll b){return min(a,b);};\n    auto G = [](ll a, ll b){return b==INF?a:b;};\n    auto H = G;\n    auto P = [](ll a, ll b){return a;};\n    SegmentTree<ll,ll> seg(MAX_N, F, G, H, INF, INF,vl(MAX_N,INF));\nint main() { cin >> n >> q; \nwhile(q--){\n    cin >> x;\n    if(x==0){\n        cin >> a >> b >> c;\n        seg.update(a, b + 1, c);\n    }\n    else{\n        cin >> a;\n        cout << seg.query(a, a + 1)<<endl;\n    }\n}}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n// Dual Segment Tree\ntemplate <class OM> struct DST {\n    int n, lev;\n    vector<OM> lz;\n    virtual OM h(OM, OM) = 0;\n    const OM e0;\n\n    DST(int n_, const OM& e0) : e0(e0) {\n        for (n = 1, lev = 0; n < n_; n <<= 1, ++lev);\n        lz.assign(n << 1, e0);\n    }\n\n    inline void push(int k) {\n        for (int i = lev; i > 0; --i) {\n            int j = k >> i;\n            if (lz[j] == e0) continue;\n            lz[(j << 1) | 0] = h(lz[(j << 1) | 0], lz[j]);\n            lz[(j << 1) | 1] = h(lz[(j << 1) | 1], lz[j]);\n            lz[j] = e0;\n        }\n    }\n\n    // [l, r)\n    // l, r: 0-indexed\n    void update(int l, int r, const OM& x) {\n        push(l += n);\n        push(r += n - 1);\n\t\tfor (++r; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lz[l] = h(lz[l], x), l++;\n            if (r & 1) --r, lz[r] = h(lz[r], x);\n\t\t}\n    }\n\n    // k: 0-indexed\n    OM query(int k) {\n        push(k += n);\n        return lz[k];\n    }\n};\n\n// Range Update Query (RUQ)\ntemplate <class OM> struct RUQ : DST<OM> {\n    RUQ(int n, OM e0 = numeric_limits<OM>::max()) : DST<OM>(n, e0) {}\n    OM h(OM a, OM b) override { return b; }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    RUQ<int> ruq(n, (1LL << 31) - 1);\n    REP (i, q) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            ruq.update(s, t + 1, x);\n        } else {\n            int j;\n            cin >> j;\n            cout << ruq.query(j) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n\n\nusing namespace std;\n\nint main(){\n    const int MAX_VALUE = pow(2, 31) - 1;\n    int n, q;\n    int com;\n    int s, t, x;\n    \n    cin >> n >> q;\n    vector<int> data(n, MAX_VALUE);\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            for(int i = s; i <= t; i++)\n                data[i] = x;\n        }\n        else{\n            cin >> t;\n            cout << data[t] << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1<<17;\n\nint n,dat[2*MAX_N-1];\n\n//?????????\nvoid init(int n_){\n  //????´???°n???2???????????????\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=INT_MAX;\n}\n\nvoid update(int a,int b,int k,int l,int r,int x){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b)dat[k]=x;\n  else{\n    if(dat[k]!=INT_MAX){\n      dat[k*2+1]=dat[k];\n      dat[k*2+2]=dat[k];\n      dat[k]=INT_MAX;\n    }\n    update(a,b,k*2+1,l,(l+r)/2,x);\n    update(a,b,k*2+2,(l+r)/2,r,x);\n  }\n}\n\nint find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return INT_MAX;\n  if(a<=l&&r<=b)return dat[k];\n  else{\n    if(dat[k]!=INT_MAX){\n      dat[k*2+1]=dat[k];\n      dat[k*2+2]=dat[k];\n      dat[k]=INT_MAX;\n    }\n    return min(find(a,b,k*2+1,l,(l+r)/2),find(a,b,k*2+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  int q;\n  cin>>n>>q;\n  \n  init(n);\n  int u,s,t,x;\n  for(int i=0;i<q;i++){\n    cin>>u;\n    if(!u){\n      cin>>s>>t>>x;\n      update(s,t+1,0,0,n,x);\n    }else{\n      cin>>s;\n      cout<<find(s,s+1,0,0,n)<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate<class T>\nstruct SegTreeT2\n{\n\tint size;\n\tvector<T> tree;\n\tvector<pair<bool, T>> lazy;\n\n\tT initialValue;\n\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\t\n\tSegTreeT2(int count, T initialValue)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, lazy(size * 2)\n\t\t, initialValue(initialValue)\n\t{\n\t\tlazy[1] = { true, initialValue };\n\t}\n\n\tvoid push(int l, int r, int i)\n\t{\n\t\tif (lazy[i].first)\n\t\t{\n\t\t\ttree[i] = lazy[i].second;\n\t\t\tif (r - l > 1)\n\t\t\t{\n\t\t\t\tlazy[i * 2 + 1] = lazy[i * 2] = lazy[i];\n\t\t\t}\n\t\t\tlazy[i].first = false;\n\t\t}\n\t}\n\n\tvoid update_range(int begin, int end, T value)\n\t{\n\t\tupdate_range(begin, end, 1, 0, size, value);\n\t}\n\n\tvoid update_range(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpush(l, r, i);\n\n\t\tif (r <= s || e <= l) { return; }\n\t\tif (s <= l && r <= e) { lazy[i] = { true, value }; return; }\n\n\t\tupdate_range(s, e, i * 2, l, (l + r) / 2, value);\n\t\tupdate_range(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpush(l, r, i);\n\t\tif (r <= s || e <= l)\n\t\t{\n\t\t\treturn value;\n\t\t}\n\t\tif (s <= l && r <= e) { return tree[i]; }\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { value += query(s, e, i * 2, l, m, value); }\n\t\tif (e > m) { value += query(s, e, i * 2 + 1, m, r, value); }\n\t\treturn value;\n\t}\n\n\tT query(int begin, int end, T initialValue) { return query(begin, end, 1, 0, size, initialValue); }\n\tT query(int begin, int end) { return query(begin, end, initialValue); }\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tSegTreeT2<int> tree = SegTreeT2<int>(n, (1LL << 31) - 1);\n\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s, t + 1, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, i);\n\t\t\tint v = tree.query(i, i + 1, 0);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int INF=2147483647;\nstruct segment_tree{\n    int map[200010];\n    void build(int now,int l,int r){\n        if(l==r){\n            map[now]=INF;\n            return;\n        }\n        map[now]=-1;\n        int mid=(l+r)/2;\n        build(now*2+1,l,mid);\n        build(now*2+2,mid+1,r);\n        return ;\n    }\n    void change(int n,int now,int L,int R,int l,int r){\n        if(R<l||L>r)return;\n        if(L>=l&&R<=r){\n            map[now]=n;\n            return;\n        }\n        if(map[now]!=-1){\n            map[now*2+1]=map[now*2+2]=map[now];\n            map[now]=-1;\n        }\n        int mid=(L+R)/2;\n        change(n,now*2+1,L,mid,l,r);\n        change(n,now*2+2,mid+1,R,l,r);\n        return ;\n    }\n    int find(int now,int L,int R,int n){\n        if(L==R)return map[now];\n        if(map[now]!=-1){map[now*2+1]=map[now*2+2]=map[now];\n            int temp=map[now];\n            map[now]=-1;\n            return temp;\n        }\n        int mid=(L+R)/2;\n        if(mid>=n)return find(now*2+1,L,mid,n);\n        else return find(now*2+2,mid+1,R,n);\n    }\n};\nint main(){\n    int n,m,k,l,r;\n    segment_tree arr;\n    scanf(\"%d%d\",&n,&m);\n    arr.build(0,0,n-1);\n    while(m--){\n        scanf(\"%d\",&k);\n        if(k==0){\n            scanf(\"%d%d%d\",&l,&r,&k);\n            arr.change(k,0,0,n-1,l,r);\n        }\n        else {\n            scanf(\"%d\",&k);\n            printf(\"%d\\n\",arr.find(0,0,n-1,k));\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nclass lazy_segment_tree{\n    private:\n        static int calc_size(int n){\n            int m = 1;\n            while(m < n){\n                m *= 2;\n            }\n            return m;\n        }\n\n        void eval(int i, int l, int r){\n            if(lazy[i] != -1){\n                node[i] = lazy[i];\n                if(r - l > 1){\n                    lazy[i * 2 + 1] = lazy[i];\n                    lazy[i * 2 + 2] = lazy[i];\n                }\n                lazy[i] = -1;\n            }\n        }\n\n        void add(int s, int t, int x, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return ;\n            }\n\n            if(s <= l && r <= t){\n                lazy[i] = x;\n                eval(i, l, r);\n                return;\n            }\n\n            int m = l + (r - l) / 2;\n            add(s, t, x, 2 * i + 1, l, m);\n            add(s, t, x, 2 * i + 2, m, r);\n            node[i] = node[2 * i + 1] + node[2 * i + 2];\n        }\n\n        T query(int s, int t, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return 0;\n            }\n\n            if(s <= l && r <= t){\n                return node[i];\n            }\n\n            int m = l + (r - l) / 2;\n            T vl = query(s, t, i * 2 + 1, l, m);\n            T vr = query(s, t, i * 2 + 2, m, r);\n            return vl + vr;\n        }\n\n    public:\n        int n;\n        vector<T> node, lazy;\n        T init;\n        function<T(T, T)> f;\n\n        lazy_segment_tree(int n, T init, function<T(T, T)> f)\n            : n(calc_size(n)), node(calc_size(n) * 2, init) , lazy(calc_size(n) * 2, -1), init(init), f(f) {}\n\n        void update(int i, const T& x){\n            node[i + n] = x;\n            for(int j = (i + n) / 2; j > 0; j /= 2){\n                node[j] = node[j * 2] + node[j * 2 + 1];\n            }\n        }\n\n        T query(int s, int t){\n            return query(s, t, 0, 0, n);\n        }\n\n        void add(int s, int t, int x){\n            add(s, t, x, 0, 0, n);\n        }\n};\n\nsigned main(){\n    int n, q;\n    cin >> n >> q;\n\n    lazy_segment_tree<int> lst(n+1, (1LL << 31)-1, [](int a, int b){return a+b;});\n    rep(i, q){\n        int qq;\n        cin >> qq;\n\n        if(qq == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            lst.add(s, t+1, x);\n        }\n\n        if(qq == 1){\n            int i;\n            cin >> i;\n            cout << lst.query(i, i+1) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass RUQ{\n\tint n,seg,init;\n\tvector<P> dat;\npublic:\n\tRUQ(int siz,int def) : n(siz),init(def),seg(1){\n\t\twhile(seg < n) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = P(init,-1);\n\t}\n\tvoid update(int a,int b,int x,int tim,int k = 0,int l = 0,int r = -1){\n\t\tif(r == -1) r = seg;\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdat[k] = P(x,tim);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,x,tim,k * 2 + 1,l,(l + r) / 2);\n\t\tupdate(a,b,x,tim,k * 2 + 2,(l + r) / 2,r);\n\t}\n\tP get(int i){\n\t\ti += seg - 1;\n\t\tP ret = dat[i];\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tret = max(ret,dat[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tint n,q;\n\tcin >> n >> q;\n\tRUQ ruq(n,(1 << 31) - 1);\n\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint s,t,x;\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s,t + 1,x,i);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << ruq.get(x).first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 100010;\n\nclass segTree{\n    public:\n        int n, dat[4 * MAX_N];\n        virtual int query(int, int, int, int, int) = 0;\n        void init(int n_){}\n        void init(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n            }\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            else if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n            else{\n                int res = (min(b, r) - max(a, l)) * dat[k];\n                res += query(a, b, k * 2, l, (l + r) / 2);\n                res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return res;\n            }\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n) dat[i] = dat_add[i] = 0;\n        }\n\n        void update(int i, int x){\n            add(i, i + 1, 1, 0, n, x);\n        }\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n        void add(int s, int t, int x){\n            add(s, t, 1, 0, n, x);\n        }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n\n            if(a <= l && r <= b) return dat[k];\n            else{\n                int vl = query(a, b, k * 2, l, ( l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return vl + vr;\n            }\n        }\n    public:\n        void init(int n_){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n) dat[i] = 0;\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n            else{\n                //????????§???????????°??????????????????????°????\n                int vl = query(a, b, k * 2, l, ( l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return min(vl, vr);\n            }\n        }\n    public:\n        void init(int _n){\n            n = 1;\n            while(n < _n) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n};\n\nclass rangeUpdateQuery : public segTree{ //????????§??£??\\??????????°?????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n            else{\n                int vl = query(a, b, k * 2, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return min(vl, vr);\n            }\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat[2 * k] = min(dat[2 * k], dat_lazy[k]);\n                dat[2 * k + 1] = min(2 * k + 1, dat_lazy[k]);\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(r <= a || b <= l) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else if(l < b && a < r){\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){\n            n = 1;\n            while(n <= n_) n *= 2;\n            rep(i,2 * n){\n                dat[i] = dat_lazy[i] = INT_MAX;\n            }\n        }\n\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n        void update(int s, int t, int x){\n            update(s, t, 1, 0, n, x);\n        }\n        int get(int a){ return query(a, a + 1); }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n\n    rangeUpdateQuery seg;\n    seg.init(n);\n    rep(i,q){\n        int com;\n        cin >> com;\n        if(com){\n            int x;\n            cin >> x;\n            cout << seg.get(x) << endl;\n        }else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int imax = INT_MAX - 1;   // INT_MAX = 2^31\n    int A[100000];\n    int i, s, t, x, n, q, ask;\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n\t\tif(ask){\n            cin >> i;\n            cout << A[i] << endl;\n\t\t}else{\n            cin >> s >> t >> x;\n\t\t\tfor(i = s; i <= t; i++) A[i] = x;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        return x*y;\n        //return x+y;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T& E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T& E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\n\n\ntemplate<typename T>\nstruct LazySegmentTree{\nprivate:\n    int n;\n    vector<T> node,lazy;\n    T E0,E1;\n\n    inline void updatef(T& lazy,T& value){\n        //lazy += value;\n        lazy = value;\n        //lazy = max(lazy, value);\n        //lazy = min(lazy, value);\n    }\n    inline void calculatef(T& node,T& lazy,int len){\n        //node += lazy * len;\n        // node += lazy ;\n        node = lazy ;\n\n    }\n    inline T queryf(T& x,T& y){\n        //return x + y;\n        //return x * y;\n        //return max(x, y);\n        return min(x, y);\n    }\npublic:\n    LazySegmentTree(int sz,T E0,T E1 = 0):E0(E0),E1(E1){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E0);\n        lazy.resize(2*n-1,E1);\n    }\n\n    LazySegmentTree(vector<T>& v,T E0,T E1 = 0):E0(E0),E1(E1){\n        n=1;\n        int sz=v.size();\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E0);\n        lazy.resize(2*n-1,E1);\n        rep(i,sz)node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; --i){\n            node[i] = queryf(node[2*i+1],node[2*i+2]);\n        }\n    }\n\n    void eval(int k,int l,int r){\n        if(lazy[k]==E1)return ;\n        calculatef(node[k], lazy[k], r-l);\n        if(r-l>1){\n            updatef(lazy[2*k+1], lazy[k]);\n            updatef(lazy[2*k+2], lazy[k]);\n        }\n        lazy[k]=E1;\n    }\n      //[a,b)にxを加算\n    void update(int a, int b, T x,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        eval(k,l,r);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            updatef(lazy[k], x);\n            eval(k,l,r);\n        }\n        else {\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n   //[a,b)での和を返す\n    T query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        eval(k,l,r);\n        if(r<=a||b<=l)return E0;\n        if(a<=l&&r<=b)return node[k];\n        T xl=query(a,b,2*k+1,l,(l+r)/2);\n        T xr=query(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\n\nint main(){\n    int n;\n    cin>>n;\n    LazySegmentTree<ll> sg(n, (1LL<<31)-1, (1LL<<31)-1) ; \n    int q;\n    cin>>q;\n    while(q--){\n        int type;\n        cin>>type;\n        if(type){\n            int i;cin>>i;\n            cout<<sg.query(i, i+1)<<endl;\n        }\n        else {\n            int l,r,x;\n            cin>>l>>r>>x;\n            sg.update(l, r+1, x);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<random>\nusing namespace std;\n\nusing Value = int;\nconst Value INI = INT_MAX;\nstruct Node {\n\tValue sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(0) {\n\t\tlazy = 0;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tdat[k].sum += dat[k].lazy * (b - a + 1);\n\t}\n\n\tValue connect(const Value l, const Value r) {\n\t\treturn l + r;\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy += dat[k].lazy;\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy += dat[k].lazy;\n\t\t}\n\t\tdat[k].lazy = 0;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy += v;\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\n\t// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn 0;\n\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tValue vl = get(l, r, 2 * k, a, m);\n\t\tValue vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\nnamespace perseg {\n\n\tstruct permanent_segtree {\n\t\tValue val;\n\t\tValue lazy;\n\t\tint l, r;\n\t\tvector<shared_ptr<permanent_segtree>>chs;\n\tpublic:\n\t\tpermanent_segtree(const int size_) :val(INI),lazy(INI), l(0), r(size_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const Value& val_, const int l_, const int r_) :val(val_), lazy(INI), l(l_), r(r_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const permanent_segtree&tree_) :val(tree_.val), lazy(tree_.lazy), l(tree_.l), r(tree_.r), chs(tree_.chs) {\n\n\t\t}\n\t\tvoid lazy_func() {\n\t\t\tif (lazy !=INI) {\n\t\t\t\tval = lazy;\n\t\t\t}\n\t\t}\n\t\tValue update_lazy(int lazy_from, int lazy_to) {\n\t\t\tif (lazy_to != INI) {\n\n\t\t\t\treturn lazy_to;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lazy_from;\n\t\t\t}\n\t\t}\n\t\tvoid lazy_evaluate_node() {\n\t\t\tlazy_func();\n\t\t\tif (l + 1 != r) {\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tgetch(i)->lazy = update_lazy(getch(i)->lazy, lazy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlazy = INI;\n\t\t}\n\t\tshared_ptr<permanent_segtree>getch(const int num_) {\n\t\t\tconst int amid = (l + r) / 2;\n\n\t\t\tif (chs[num_] == nullptr) {\n\t\t\t\tif (num_ == 0) {\n\t\t\t\t\tchs[0] = make_shared<permanent_segtree>(INI, l, amid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchs[1] = make_shared<permanent_segtree>(INI, amid, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chs[num_];\n\n\t\t}\n\t\tValue eval_value(const Value&value_l, const Value&value_r)const {\n\t\t\treturn min(value_l, value_r);\n\t\t}\n\t\t// min [a, b)\n\t\tValue  query(int a, int b, int k) {\n\t\t\tif (r <= a or b <= l) return INI;\n\t\t\tif (a <= l and r <= b) return val;\n\t\t\tlazy_evaluate_node();\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tconst Value al(getch(0)->query(a, b, k));\n\t\t\tconst Value ar(getch(1)->query(a, b, k));\n\t\t\treturn eval_value(al, ar);\n\t\t}\n\t};\n\n\tshared_ptr<permanent_segtree>immutable_update(const shared_ptr<permanent_segtree>&tree, const int l,const int r, const Value a) {\n\t\ttree->lazy_evaluate_node();\n\t\tif (tree->r <= l || r <= tree->l) {\n\t\t\treturn tree;\n\t\t}else if (l<= tree->l&&tree->r<=r) {\n\t\t\tshared_ptr<permanent_segtree>new_tree(make_shared<permanent_segtree>(INI, tree->l, tree->r));\n\t\t\tnew_tree->lazy = new_tree->update_lazy(new_tree->lazy, a);\n\t\t\tnew_tree->lazy_evaluate_node();\n\t\t\treturn new_tree;\n\t\t}\n\t\telse {\n\t\t\tshared_ptr<permanent_segtree>copy_tree = (make_shared<permanent_segtree>(*tree));\n\t\t\tassert(tree->l + 1 < tree->r);\n\t\t\tcopy_tree->chs[0] = immutable_update(tree->getch(0), l,r, a);\t\t\t\n\t\t\tcopy_tree->chs[1] = immutable_update(tree->getch(1),l,r, a);\t\n\t\t\tcopy_tree->val = copy_tree->eval_value(copy_tree->getch(0)->val, copy_tree->getch(1)->val);\n\n\t\t\treturn copy_tree;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tusing namespace perseg;\n\tvector < shared_ptr<permanent_segtree>>trees(1, nullptr);\n\ttrees[0] = make_shared<permanent_segtree>(1 << 3);\n\tint N, Q; cin >> N >> Q;\n\tint now = 0;\n\tvector<tuple<int, int>>qs;\n\tbool flag = false;\n\tfor (int i = 0; i < Q;++i){\n\t\t\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint t; cin >> t;\n\t\t\tqs.push_back(make_tuple(now, t));\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\t//if (flag) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\ttrees.push_back(immutable_update(trees[now], s,t+1,x));\n\t\t\tnow++;\n\t\t\tflag = false;\n\t\t\t/*}\n\t\t\telse {\n\t\t\t\ttrees.back() = immutable_update(trees[now], x, y);\n\t\t\t}*/\n\t\t}\n\t}\n\tfor (int i = 0; i < qs.size(); ++i) {\n\t\tint now,x;\n\t\ttie(now, x) = qs[i];\n\t\tint ans = trees[now]->query(x, x + 1, 100);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define RS resize\n#define CLR clear\n#define PB push_back\n#define ALL(x) (x).begin(), (x).end()\n#define LLI long long int\nusing namespace std;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename T, typename U> P<T,U> operator+(const P<T,U> &a, const P<T,U> &b){return {a.first + b.first, a.second + b.second};}\ntemplate <typename T, typename U> P<T,U> operator-(const P<T,U> &a, const P<T,U> &b){return {a.first - b.first, a.second - b.second};}\ntemplate <typename T> void cout_join(vector<T> &v,string d=\" \"){REP(i,v.size()){if(i>0)cout<<d;cout<<v[i];}cout<<endl;}\n\ntemplate <typename T = int>\nT minimum_power_2(T n){\n  T i = 1;\n  while(i<n) i = i<<1;\n  return i;\n}\n\ntemplate <typename T> class LazySegmentTree{\nprivate:\n  int size;\n  vector<T> vec;\n  function<T(T,T)> f, upd;\n  T e;\n\n  void propagate(int i){\n    if(i<size/2){\n      vec[i*2+1] = f(vec[i], vec[i*2+1]);\n      vec[i*2+2] = f(vec[i], vec[i*2+2]);\n      vec[i] = e;\n    }\n  }\n  \n  void update_aux(int s, int t, int i, int l, int r, T x){\n    if(r <= s || t <= l) return;\n    else if(s <= l && r <= t) vec[i] = upd(vec[i],x);\n    else{\n      propagate(i);\n      update_aux(s,t,i*2+1,l,(l+r)/2,x);\n      update_aux(s,t,i*2+2,(l+r)/2,r,x);\n    }\n  }\n  void find_aux(int i){if(i>0) find_aux((i-1)/2); propagate(i);}\n\npublic:\n  LazySegmentTree(int n, T e, function<T(T,T)> f, function<T(T,T)> upd):\n    size(minimum_power_2(n)*2-1), vec(size, e), f(f), e(e), upd(upd){}\n  \n  void update(int s, int t, T x){update_aux(s,t,0,0,size/2+1,x);}\n\n  T find(int i){\n    int j=i+size/2;\n    find_aux((j-1)/2);\n    return vec[j];\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const int inf = INT_MAX;\n\n  int n,q; cin >> n >> q;\n  LazySegmentTree<int> ruq(n, inf, [](int a, int b){return a==inf?b:a;}, [](int a, int b){return b;});\n\n  REP(i,q){\n    int com; cin >> com;\n    switch(com){\n    case 0:\n      int s,t,x; cin >> s >> t >> x;\n      ruq.update(s,t+1,x);\n      break;\n    case 1:\n      int i; cin >> i;\n      cout << ruq.find(i) << endl;\n      break;\n    }\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: barish21\nLANG: C++14\nTASK: test\n*/\n\n/****Author: Barish Namazov****/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/***TEMPLATE***/\n#define intt long long\n\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n\n#define F first\n#define S second\n#define pb push_back\n\n#define IO ios_base::sync_with_stdio(false);cin.tie();\n\nconst intt max4 = 10004;\nconst intt maxx = 100005;\nconst intt max6 = 1000006;\nconst intt max7 = 10000007;\n\nconst intt lg4 = 13;\nconst intt lg5 = 17;\nconst intt lg6 = 20;\n\nconst intt INF = 2LL * 1000000000;\n/***************/\n\n/***Additional Functions***/\n\nintt powmod (intt a, intt b, intt mod) {\n    intt res = 1;\n    a %= mod;\n    for (; b; b >>= 1) {\n        if (b & 1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n    }\n    return res;\n}\n\nintt gcd (intt a, intt b) {\n    while (b > 0) {\n        intt t = a % b;\n        a = b, b = t;\n    }\n    return a;\n}\n\nintt lcm (intt a, intt b) {\n    return (a / gcd (a, b)) * b;\n}\n\nintt is_prime (intt n) {\n    if (n <= 1 || n > 3 && (n % 2 == 0 || n % 3 == 0))\n        return 0;\n    for (intt i = 5, t = 2; i * i <= n; i += t, t = 6 - t)\n        if (n % i == 0)\n            return 0;\n    return 1;\n}\n\n/**************************/\n\nconst intt initt = (1 << 31) - 1;\n\nintt n, q;\nintt t[maxx << 2], lazy[maxx << 2];\n\nvoid init () {\n    memset (lazy, -1, sizeof (lazy));\n}\n\nvoid relax (intt v, intt l, intt r) {\n    t[v] = (r - l + 1) * lazy[v];\n    if (l != r)\n        lazy[v << 1] = lazy[v << 1 | 1] = lazy[v];\n    lazy[v] = -1;\n}\n\nvoid build (intt v, intt l, intt r) {\n    if (l == r) {\n        t[v] = initt;\n        return;\n    }\n    intt mid = (l + r) >> 1;\n    build (v << 1, l, mid);\n    build (v << 1 | 1, mid + 1, r);\n    t[v] = t[v << 1] + t[v << 1 | 1];\n}\n\nvoid update (intt v, intt l, intt r, intt i, intt j, intt val) {\n    if (lazy[v] != -1)\n        relax (v, l, r);\n    if (j < l || i > r)\n        return;\n    if (i <= l && r <= j) {\n        lazy[v] = val;\n        relax (v, l, r);\n        return;\n    }\n    intt mid = (l + r) >> 1;\n    update (v << 1, l, mid, i, j, val);\n    update (v << 1 | 1, mid + 1, r, i, j, val);\n    t[v] = t[v << 1] + t[v << 1 | 1];\n}\n\nintt query (intt v, intt l, intt r, intt i, intt j) {\n    if (j < l || i > r)\n        return 0;\n    if (lazy[v] != -1)\n        relax (v, l, r);\n    if (i <= l && r <= j)\n        return t[v];\n    intt mid = (l + r) >> 1;\n    return query (v << 1, l, mid, i, j) +\n           query (v << 1 | 1, mid + 1, r, i, j);\n}\n\nint main() {\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    //ofstream fout (\"test.out\");\n    //ifstream fin (\"test.in\");\n    IO;\n    init();\n    cin >> n >> q;\n    build (1, 1, n);\n    while (q --) {\n        intt type, i, j, val;\n        cin >> type;\n        if (type == 0)\n            cin >> i >> j >> val, i ++, j ++, update (1, 1, n, i, j, val);\n        else\n            cin >> i, i ++, cout << query (1, 1, n, i, i) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n \nint bucket[MAX/B][B];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n    int f1 = 1, f2 = 1;\n    while(a <= b && a%B != 0){\n        if(f1 && data[a/B] != -1){\n            for(int i = 0;i < B;i++)bucket[a/B][i] = data[a/B];\n            f1 = 0;data[a/B] = -1;\n        }\n        bucket[a/B][a%B] = x;\n        a++;\n    }\n    while(a <= b && b%B != B-1){\n        if(f2 && data[b/B] != -1){\n            for(int i = 0;i < B;i++)bucket[b/B][i] = data[b/B];\n            f2 = 0;data[b/B] = -1;\n        }\n        bucket[b/B][b%B] = x;\n        b--;\n    }\n    while(a < b){\n        data[a/B] = x;\n        a += B;\n    }\n}\n \nint find(int x){\n    if(data[x/B] != -1){\n        for(int i = 0;i < B;i++)bucket[x/B][i] = data[x/B];\n        data[x/B] = -1;\n    }\n    return bucket[x/B][x%B];\n}\n \nint main(){\n    int n, q, c, s, t, x, ans;\n    scanf(\"%d%d\", &n, &q);\n    fill(data, data+MAX/B, -1);\n    fill((int*)bucket, (int*)(bucket+MAX/B), INF);\n    while(q--){\n        scanf(\"%d\", &c);\n        if(!c){\n            scanf(\"%d%d%d\", &s, &t, &x);\n            update(s, t, x);\n        }else{\n            scanf(\"%d\", &x);\n            ans = find(x);\n            printf(\"%d\\n\", ans);\n        }\n    }\n    //rep(i,n)printf(\"%d \", bucket[0][i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RLUQ{\n  struct query{\n    int type;//0=empty, 1=set\n    int value;\n    query(int a=0,int b=0):type(a),value(b) {}\n  };\n  query s[(1<<18)];\n  int t[(1<<18)];\n  RLUQ(){\n    fill(t,t+(1<<18),INT_MAX);\n  }\n  void compute(int k,int l,int r){\n    query q=s[k];\n    s[k].type=0;\n    if(q.type==0||r-l==1)return;\n    s[k*2+1]=s[k*2+2]=q;  \n    t[k*2+1]=t[k*2+2]=q.value;\n  }\n  void Set(int a,int b,int x,int k=0,int l=0,int r=(1<<17)){\n    if(b<=l || r<=a)return;\n    compute(k,l,r);\n    if(a<=l && r<=b){\n      s[k]=query(1,x);\n      t[k]=x;\n    }else{\n      int m=(l+r)/2;\n      Set(a,b,x,k*2+1,l,m);\n      Set(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n  int Get(int a,int b,int k=0,int l=0,int r=(1<<17)){\n    if(b<=l || r<=a)return INT_MAX;\n    compute(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      int lv=Get(a,b,k*2+1,l,m);\n      int rv=Get(a,b,k*2+2,m,r);\n      return min(lv,rv);\n    }\n  }\n};\n\nint main(){\n  RLUQ a;\n  int n,q;\n  cin>>n>>q;\n  int c,s,t,x;\n  for(int i=0;i<q;i++){\n    cin>>c;\n    if(c){\n      cin>>s;\n      cout<<a.Get(s,s+1)<<endl;\n    }\n    else{\n      cin>>s>>t>>x;\n      a.Set(s,t+1,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate<class T, class TUpdater>\nstruct RangeSegTreeT\n{\n\tint size;\n\tvector<T> tree;\n\tvector<pair<bool, T>> lazy;\n\tTUpdater updator;\n\tT initialValue;\n\n\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\t\n\tRangeSegTreeT(int count, TUpdater updator, T initialValue)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, lazy(size * 2)\n\t\t, updator(updator)\n\t\t, initialValue(initialValue)\n\t{\n\t\tlazy[1] = { true, initialValue };\n\t}\n\n\tvoid propagate(int l, int r, int i)\n\t{\n\t\tif (lazy[i].first)\n\t\t{\n\t\t\ttree[i] = invoke_update(tree[i], lazy[i].second, r - l);\n\t\t\tif (r - l > 1)\n\t\t\t{\n\t\t\t\tlazy[i * 2] = { true, invoke_update(lazy[i * 2].second, lazy[i].second) };\n\t\t\t\tlazy[i * 2 + 1] = { true, invoke_update(lazy[i * 2 + 1].second, lazy[i].second) };\n\t\t\t}\n\t\t\tlazy[i] = { false, 0 };\n\t\t}\n\t}\n\n\tvoid update_range(int begin, int end, T value) { update_range(begin, end, 1, 0, size, value); }\n\tT query(int begin, int end) { return query(begin, end, initialValue); }\n\tT query(int begin, int end, T initialValue) { return query(begin, end, 1, 0, size, initialValue); }\n\nprivate:\n\n\tT invoke_update(T a, T b, T c = 1) { return updator(a, b, c); }\n\n\n\tvoid update_range(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpropagate(l, r, i);\n\n\t\tif (r <= s || e <= l) { return; }\n\t\tif (s <= l && r <= e) { lazy[i] = { true, invoke_update(lazy[i].second, value) }; return; }\n\t\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { update_range(s, e, i * 2, l, m, value); }\n\t\tif (e > m) { update_range(s, e, i * 2 + 1, m, r, value); }\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpropagate(l, r, i);\n\t\tif (r <= s || e <= l) { return value; }\n\t\tif (s <= l && r <= e) { return tree[i]; }\n\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { value = invoke_update(value, query(s, e, i * 2, l, m, value)); }\n\t\tif (e > m) { value = invoke_update(value, query(s, e, i * 2 + 1, m, r, value)); }\n\t\treturn value;\n\t}\n};\n\ntemplate <class T, class TUpdator>\nRangeSegTreeT<T, TUpdator> RangeSegTree(int n, TUpdator updator, int initialValue)\n{\n\treturn RangeSegTreeT<T, TUpdator>(n, updator, initialValue);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTree<int>(n, CONV3(a, b, c, b), 0);\n\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s, t + 1, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, i);\n\t\t\tint v = tree.query(i, i + 1, 0);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct LazySegmentTree {\n  private:\n    int n;\n    vector<int> node, lazy;\n\npublic:\n  LazySegmentTree(vector<int> v) {\n    int sz = (int)v.size();\n    n = 1; while(n < sz) n *= 2;\n    node.resize(2*n-1);\n    lazy.resize(2*n-1, -INF);\n\n    REP(i,sz) node[i+n-1] = v[i];\n    RREP(i,n-1) node[i] = node[i*2+1] + node[i*2+2];\n  }\n\n  void eval(int k, int l, int r) {\n    if(lazy[k] != -INF) {\n      node[k] = (r-l)*lazy[k];\n      if(r - l > 1) {\n        lazy[2*k+1] = lazy[k];\n        lazy[2*k+2] = lazy[k];\n      }\n      lazy[k] = -INF;\n    }\n  }\n\n  void update(int a, int b, int x, int k=0, int l=0, int r=-1) {\n    if(r < 0) r = n;\n    eval(k, l, r);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {\n      lazy[k] = x;\n      eval(k, l, r);\n    }\n    else {\n      update(a, b, x, 2*k+1, l, (l+r)/2);\n      update(a, b, x, 2*k+2, (l+r)/2, r);\n      node[k] = node[2*k+1] + node[2*k+2];\n    }\n  }\n\n  int query(int a, int b, int k=0, int l=0, int r=-1) {\n    if(r < 0) r = n;\n    eval(k, l, r);\n    if(b <= l || r <= a) return 0;\n    if(a <= l && r <= b) return node[k];\n    int vl = query(a, b, 2*k+1, l, (l+r)/2);\n    int vr = query(a, b, 2*k+2, (l+r)/2, r);\n    return vl + vr;\n  }\n};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,q;\n  cin >> n >> q;\n\n  LazySegmentTree seg(vec(n,(1LL<<31)-1));\n\n  REP(_,q){\n    int x;\n    cin >> x;\n    if(x){\n      cin >> x;\n      cout << seg.query(x,x+1) << endl;\n    }\n    else{\n      int s,t;\n      cin >> s >> t >> x;\n      seg.update(s,t+1,x);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)(n); i++)\n#define Loopr(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(extra_i, vector.size()) { cout << vector[extra_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(extra_i, matrix.size()) { Loop(extra_j, matrix[extra_i].size()) { cout << matrix[extra_i][extra_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e-9; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\n\ntemplate<class T>\nclass SegTree {\nprotected:\n\tint n, N; // n is the original size, while N is the extended size\n\tint base;\n\tvector<T> nodes;\n\tint left_of(int index) {\n\t\tif (index >= base) return -1;\n\t\telse return index * 2 + 1;\n\t}\n\tint right_of(int index) {\n\t\tif (index >= base) return -1;\n\t\telse return index * 2 + 2;\n\t}\n\tint parent_of(int index) {\n\t\tif (index == 0) return -1;\n\t\telse return (index - 1) / 2;\n\t}\n\tvoid local_update(int index, T(*update_rule)(T, T, T)) {\n\t\tif (index >= base) return;\n\t\tint l = left_of(index), r = right_of(index);\n\t\tnodes[index] = update_rule(nodes[index], nodes[l], nodes[r]);\n\t}\n\tvoid get_index_of_range_rec(int s, int t, int l, int r, int index, vi *v) {\n\t\tif (s == l && t == r) v->push_back(index);\n\t\telse {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (s < mid && mid < t) {\n\t\t\t\tget_index_of_range_rec(s, mid, l, mid, left_of(index), v);\n\t\t\t\tget_index_of_range_rec(mid, t, mid, r, right_of(index), v);\n\t\t\t}\n\t\t\telse if (s < mid) get_index_of_range_rec(s, t, l, mid, left_of(index), v);\n\t\t\telse if (mid < t) get_index_of_range_rec(s, t, mid, r, right_of(index), v);\n\t\t}\n\t}\npublic:\n\tSegTree(int n, T init, T(*update_rule)(T, T, T)) {\n\t\tSegTree::n = n;\n\t\tN = (int)pow(2, ceil(log2(n)));\n\t\tbase = N - 1;\n\t\tnodes = vector<T>(base + N, init);\n\t}\n\t// use either subst or update\n\tvoid subst(int index, T x, bool from_base = false) {\n\t\tif (from_base) index += base;\n\t\tnodes[index] = x;\n\t}\n\tvoid subst_range(int s, int t, T x) {\n\t\tvi indices = get_index_of_range(s, t);\n\t\tForeach(index, indices) nodes[index] = x;\n\t}\n\t// use either subst or update\n\tvoid update(int index, T x, T(*update_rule)(T, T, T), bool from_base = false) {\n\t\tif (from_base) index += base;\n\t\tnodes[index] = x;\n\t\twhile (index >= 0) {\n\t\t\tlocal_update(index, update_rule);\n\t\t\tindex = parent_of(index);\n\t\t}\n\t}\n\tT get(int index, bool from_base = false) {\n\t\tif (from_base) index += base;\n\t\treturn nodes[index];\n\t}\n\t// note: range [s, t)\n\tvi get_index_of_range(int s, int t) {\n\t\tvi ret = {};\n\t\tget_index_of_range_rec(s, t, 0, N, 0, &ret);\n\t\treturn ret;\n\t}\n\t// inclusive\n\tvi get_index_above(int index) {\n\t\tvi ret = {};\n\t\twhile (index >= 0) {\n\t\t\tret.push_back(index);\n\t\t\tindex = parent_of(index);\n\t\t}\n\t\treturn ret;\n\t}\n\tint cover_size(int index) {\n\t\tint cnt = 1;\n\t\twhile (left_of(index) != -1) {\n\t\t\tindex = left_of(index);\n\t\t\tcnt *= 2;\n\t\t}\n\t\tint l = index - base;\n\t\tint r = min(l + cnt, n);\n\t\treturn r - l;\n\t}\n\tint solve(int k) {\n\t\tint ret;\n\t\tint t = -2;\n\t\tvi indices = get_index_above(k + base);\n\t\tForeach(index, indices) {\n\t\t\tif (t < nodes[index].first) {\n\t\t\t\tret = nodes[index].second;\n\t\t\t\tt = nodes[index].first;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\ntemplate<class T>\nT nop_rule(T x, T a, T b) {\n\treturn x;\n}\n\nint update_rule(int x, int a, int b) {\n\treturn min(a, b);\n}\n\nint main() {\n\tint n, q; cin >> n >> q;\n\tSegTree<P> st(n, { -1, INT_MAX }, nop_rule);\n\tLoop(i, q) {\n\t\tint op; cin >> op;\n\t\tif (op == 0) {\n\t\t\tint s, t; cin >> s >> t; t++;\n\t\t\tint x; cin >> x;\n\t\t\tst.subst_range(s, t, { i, x });\n\t\t}\n\t\telse {\n\t\t\tint k; cin >> k;\n\t\t\tcout << st.solve(k) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 1000\n\nint bucket[MAX/B][100];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && data[a/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n\t\t\tf1 = 0;data[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != 99){\n\t\tif(f2 && data[b/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n\t\t\tf2 = 0;data[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tdata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(data[x/B] != -1){\n\t\tfor(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n\t\tdata[x/B] = -1;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(data, data+MAX/B, -1);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nclass sqrt_decomposition{\n    public:\n    const int B=1000;\n    int n;\n    vector<int> data,lazy;\n    vector<bool> flag;\n    sqrt_decomposition(int n,int init):n(n),data(n,init),lazy((n+B-1)/B),flag((n+B-1)/B){}\n\n\n    void propagate(int i){\n        assert(flag[i]);\n        flag[i]=false;\n        rep(j,0,B){\n            if(i*B+j>=n) break;\n            data[i*B+j]=lazy[i];\n        }\n    }\n\n    //[s,t)\n    void update(int s,int t,int x){\n        while(s<t and s%B!=0){\n            if(flag[s/B]) propagate(s/B);\n            data[s]=x;\n            ++s;\n        }\n        while(s<t and t%B!=0){\n            --t;\n            if(flag[t/B]) propagate(t/B);\n            data[t]=x;\n        }\n\n        while(s<t){\n            int i=s/B;\n            flag[i]=true;\n            lazy[i]=x;\n            s+=B;\n        }\n    }\n\n    int at(int i){\n        if(flag[i/B]) return lazy[i/B];\n        return data[i];\n    }\n};\n\nvoid solve(){\n    int n,q;\n    cin >> n >> q;\n    sqrt_decomposition sd(n,(1LL<<31)-1);\n\n    rep(i,0,q){\n        int k;\n        cin >> k;\n        if(k==0){\n            int s,t,x;\n            cin >> s >> t >> x;\n            ++t;\n            sd.update(s,t,x);\n        }else{\n            int i;\n            cin >> i;\n            cout << sd.at(i) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// C++17 polyfill {{{\ntemplate<bool B>\nusing BoolConstant = integral_constant<bool, B>;\n// }}}\n\n// C++20 polyfill {{{\nstruct IDENTITY {\n    using is_transparent = void;\n    template<typename T>\n    constexpr T&& operator()(T&& x) const noexcept {\n        return forward<T>(x);\n    }\n};\n// }}}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n\nusing complex32 = complex<f32>;\nusing complex64 = complex<f64>;\nusing complex80 = complex<f80>;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'017LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\n// ビット演算 {{{\n// 引数は [-INF,INF] のみ想定\n\ni64 BIT_I(i64 i) {\n    return 1LL << i;\n}\n\ni64 BIT_I_1(i64 i) {\n    return BIT_I(i) - 1;\n}\n\ni64 BIT_GET(i64 x, i64 i) {\n    return x & BIT_I(i);\n}\n\nbool BIT_TEST(i64 x, i64 i) {\n    return BIT_GET(x,i) != 0;\n}\n\ni64 BIT_SET(i64 x, i64 i) {\n    return x | BIT_I(i);\n}\n\ni64 BIT_CLEAR(i64 x, i64 i) {\n    return x & ~BIT_I(i);\n}\n\ni64 BIT_FLIP(i64 x, i64 i) {\n    return x ^ BIT_I(i);\n}\n\ni64 BIT_ASSIGN(i64 x, i64 i, bool b) {\n    return b ? BIT_SET(x,i) : BIT_CLEAR(x,i);\n}\n\ni64 BIT_COUNT_LEADING_ZEROS(i64 x) {\n    if(x == 0) return 64;\n    return __builtin_clzll(x);\n}\n\ni64 BIT_COUNT_LEADING_ONES(i64 x) {\n    return BIT_COUNT_LEADING_ZEROS(~x);\n}\n\ni64 BIT_COUNT_TRAILING_ZEROS(i64 x) {\n    if(x == 0) return 64;\n    return __builtin_ctzll(x);\n}\n\ni64 BIT_COUNT_TRAILING_ONES(i64 x) {\n    return BIT_COUNT_TRAILING_ZEROS(~x);\n}\n\n// 末尾へ続く0を識別するマスクを返す (ex. 0b10100 -> 0b00011)\n// x=0 なら -1 を返す\ni64 BIT_MASK_TRAILING_ZEROS(i64 x) {\n    return ~x & (x-1);\n}\n\n// 末尾へ続く1を識別するマスクを返す (ex. 0b10011 -> 0b00011)\n// x=-1 なら -1 を返す\ni64 BIT_MASK_TRAILING_ONES(i64 x) {\n    return x & ~(x+1);\n}\n\ni64 BIT_COUNT_ONES(i64 x) {\n    return __builtin_popcountll(x);\n}\n\ni64 BIT_COUNT_ZEROS(i64 x) {\n    return 64 - BIT_COUNT_ONES(x);\n}\n\n// 先頭から続く冗長な符号ビットを数える (ex. 1 -> 62, -1 -> 63)\ni64 BIT_COUNT_LEADING_REDUNDANT_SIGN_BITS(i64 x) {\n    return __builtin_clrsbll(x);\n}\n\n// 1の個数が奇数なら1, 偶数なら0を返す\ni64 BIT_PARITY(i64 x) {\n    return __builtin_parityll(x);\n}\n\n// 最右の0を分離する (ex. 0b11001 -> 0b00010)\n// x=-1 なら 0 を返す\ni64 BIT_EXTRACT_FIRST_ZERO(i64 x) {\n    return ~x & (x+1);\n}\n\n// 最右の1を分離する (ex. 0b10110 -> 0b00010)\n// x=0 なら 0 を返す\ni64 BIT_EXTRACT_FIRST_ONE(i64 x) {\n    return x & (-x);\n}\n\n// 最右の0を1にする (ex. 0b11001 -> 0b11011)\ni64 BIT_FLIP_FIRST_ZERO(i64 x) {\n    return x | (x+1);\n}\n\n// 最右の1を0にする (ex. 0b10110 -> 0b10100)\ni64 BIT_FLIP_FIRST_ONE(i64 x) {\n    return x & (x-1);\n}\n\n// 最右の1の位置(1-based)を得る\n// x=0 なら 0 を返す\ni64 BIT_FIND_FIRST_ONE(i64 x) {\n    return __builtin_ffsll(x);\n}\n\n// 最右の0の位置(1-based)を得る\n// x=-1 なら 0 を返す\ni64 BIT_FIND_FIRST_ZERO(i64 x) {\n    return BIT_FIND_FIRST_ONE(~x);\n}\n\n// 最右の0をそれより右に伝播する (ex. 0b11011 -> 0b11000)\n// x=-1 なら -1 を返す\ni64 BIT_PROPAGATE_FIRST_ZERO(i64 x) {\n    if(x == -1) return -1;\n    return x & (x+1);\n}\n\n// 最右の1をそれより右に伝播する (ex. 0b10100 -> 0b10111)\n// x=0 なら 0 を返す\ni64 BIT_PROPAGATE_FIRST_ONE(i64 x) {\n    if(x == 0) return 0;\n    return x | (x-1);\n}\n\n// 最右の0および末尾へ続く1を識別するマスクを返す (ex. 0b11011 -> 0b00111)\n// x=-1 なら 0 を返す\ni64 BIT_MASKTO_FIRST_ZERO(i64 x) {\n    if(x == -1) return 0;\n    return x ^ (x+1);\n}\n\n// 最右の1および末尾へ続く0を識別するマスクを返す (ex. 0b10100 -> 0b00111)\n// x=0 なら 0 を返す\ni64 BIT_MASKTO_FIRST_ONE(i64 x) {\n    if(x == 0) return 0;\n    return x ^ (x-1);\n}\n\n// 最右の連続した0を1にする (ex. 0b101001 -> 0b101111)\n// x=-1 なら -1 を返す\ni64 BIT_FLIP_FIRST_ZEROS(i64 x) {\n    return ((x&(x+1))-1) | x;\n}\n\n// 最右の連続した1を0にする (ex. 0b10110 -> 0b10000)\n// x=0 なら 0 を返す\ni64 BIT_FLIP_FIRST_ONES(i64 x) {\n    return ((x|(x-1))+1) & x;\n}\n\n// X ⊆ {0,1,...,n-1}, |X| = k なる部分集合 X を昇順に列挙する\n// comb(n,k) 個\n//\n// ex.\n// ```\n// i64 x = BIT_I_1(3);\n// do {\n//     // ...\n// } while(BIT_NEXT_SET_SIZED(x, 10));\n// ```\nbool BIT_NEXT_SET_SIZED(i64& x, i64 n) {\n    if(x == 0) return false;\n    i64 t = BIT_PROPAGATE_FIRST_ONE(x) + 1;\n    x = t | (BIT_MASK_TRAILING_ZEROS(t) >> (BIT_COUNT_TRAILING_ZEROS(x)+1));\n    return x < BIT_I(n);\n}\n\n// 集合 Y の部分集合 X を昇順に列挙する\n// 2^|Y| 個\n//\n// ex.\n// ```\n// i64 y = 0b10101;\n// i64 x = 0;\n// do {\n//     // ...\n// } while(BIT_NEXT_SUBSET(x, y));\n// ```\nbool BIT_NEXT_SUBSET(i64& x, i64 y) {\n    if(x == y) return false;\n    x = (x-y) & y;\n    return true;\n}\n\n// 集合 Y の部分集合 X を降順に列挙する\n// 2^|Y| 個\n//\n// ex.\n// ```\n// i64 y = 0b10101;\n// i64 x = y;\n// do {\n//     // ...\n// } while(BIT_PREV_SUBSET(x, y));\n// ```\nbool BIT_PREV_SUBSET(i64& x, i64 y) {\n    if(x == 0) return false;\n    x = (x-1) & y;\n    return true;\n}\n\n// 集合 Y を包含する集合 X ⊆ {0,1,...,n-1} を昇順に列挙する\n// 2^(n-|Y|) 個\n//\n// ex.\n// ```\n// i64 y = 0b00010101;\n// i64 x = y;\n// do {\n//     // ...\n// } while(BIT_NEXT_SUPERSET(x, 8, y));\n// ```\nbool BIT_NEXT_SUPERSET(i64& x, i64 n, i64 y) {\n    x = (x+1) | y;\n    return x < BIT_I(n);\n}\n// }}}\n\n// lambda で再帰 {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n// }}}\n\n// tuple {{{\ntemplate<typename... TS, SFINAE(sizeof...(TS) > 0)>\nconstexpr auto tuple_head(const tuple<TS...>& t) {\n    return get<0>(t);\n}\n\ntemplate<typename... TS, size_t i, size_t... is>\nconstexpr auto tuple_tail_helper(const tuple<TS...>& t, index_sequence<i,is...>) {\n    return make_tuple(get<is>(t)...);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) == 1)>\nconstexpr auto tuple_tail(const tuple<TS...>&) {\n    return make_tuple();\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) > 1)>\nconstexpr auto tuple_tail(const tuple<TS...>& t) {\n    return tuple_tail_helper(t, make_index_sequence<sizeof...(TS)>());\n}\n// }}}\n\n// FST/SND {{{\ntemplate<typename T1, typename T2>\nT1& FST(pair<T1,T2>& p) {\n    return p.first;\n}\n\ntemplate<typename T1, typename T2>\nconst T1& FST(const pair<T1,T2>& p) {\n    return p.first;\n}\n\ntemplate<typename T1, typename T2>\nT2& SND(pair<T1,T2>& p) {\n    return p.second;\n}\n\ntemplate<typename T1, typename T2>\nconst T2& SND(const pair<T1,T2>& p) {\n    return p.second;\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 1)>\nauto& FST(tuple<TS...>& t) {\n    return get<0>(t);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 1)>\nconst auto& FST(const tuple<TS...>& t) {\n    return get<0>(t);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nauto& SND(tuple<TS...>& t) {\n    return get<1>(t);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nconst auto& SND(const tuple<TS...>& t) {\n    return get<1>(t);\n}\n// }}}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MAX(const T& x, const T& y, Comp comp={}) {\n    return max(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MAX(initializer_list<T> ilist, Comp comp={}) {\n    return max(ilist, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MIN(const T& x, const T& y, Comp comp={}) {\n    return min(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MIN(initializer_list<T> ilist, Comp comp={}) {\n    return min(ilist, comp);\n}\n\ntemplate<typename T1, typename T2, typename T3, typename Comp=less<>, SFINAE(\n    is_integral<T1>::value &&\n    is_integral<T2>::value &&\n    is_integral<T3>::value &&\n    is_signed<T1>::value != is_unsigned<T2>::value &&\n    is_signed<T2>::value != is_unsigned<T3>::value\n)>\ncommon_type_t<T1,T2,T3> CLAMP(T1 x, T2 xmin, T3 xmax, Comp comp={}) {\n    ASSERT(!comp(xmax, xmin));\n    if(comp(x, xmin)) return xmin;\n    if(comp(xmax, x)) return xmax;\n    return x;\n}\n\ntemplate<typename T1, typename T2, typename T3, typename Comp=less<>, SFINAE(\n    is_floating_point<T1>::value &&\n    is_floating_point<T2>::value &&\n    is_floating_point<T3>::value\n)>\ncommon_type_t<T1,T2,T3> CLAMP(T1 x, T2 xmin, T3 xmax, Comp comp={}) {\n    ASSERT(!comp(xmax, xmin));\n    if(comp(x, xmin)) return xmin;\n    if(comp(xmax, x)) return xmax;\n    return x;\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& CLAMP(const T& x, const T& xmin, const T& xmax, Comp comp={}) {\n    ASSERT(!comp(xmax, xmin));\n    if(comp(x, xmin)) return xmin;\n    if(comp(xmax, x)) return xmax;\n    return x;\n}\n\ntemplate<typename T>\nT ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\nf64 ROUND(f64 x) {\n    return round(x);\n}\n\ni64 IROUND(f64 x) {\n    return llround(x);\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// GCD(0,0) = 0\ni64 GCD(i64 a, i64 b) {\n    return gcd_impl(ABS(a), ABS(b));\n}\n\n// LCM(0,x) は未定義\ni64 LCM(i64 a, i64 b) {\n    ASSERT(a != 0 && b != 0);\n    a = ABS(a);\n    b = ABS(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// lo:OK, hi:NG\ntemplate<typename Pred>\ni64 bisect_integer(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    while(lo+1 < hi) {\n        i64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ntemplate<typename Pred>\nf64 bisect_real(f64 lo, f64 hi, Pred pred, i64 iter=100) {\n    ASSERT(lo < hi);\n\n    REP(_, iter) {\n        f64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ni64 ipow(i64 x, i64 e) {\n    ASSERT(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\ni64 sqrt_floor(i64 x) {\n    ASSERT(x >= 0);\n\n    i64 lo = 0;\n    i64 hi = MIN(x/2+2, 3037000500LL);\n    return bisect_integer(lo, hi, [x](i64 r) { return r*r <= x; });\n}\n\ni64 sqrt_ceil(i64 x) {\n    i64 r = sqrt_floor(x);\n    return r*r == x ? r : r+1;\n}\n\n// 0 <= log2_ceil(x) <= 63\ni64 log2_ceil(i64 x) {\n    ASSERT(x > 0);\n    return 64 - BIT_COUNT_LEADING_ZEROS(x-1);\n}\n\n// 0 <= log2_floor(x) <= 62\ni64 log2_floor(i64 x) {\n    ASSERT(x > 0);\n    return 63 - BIT_COUNT_LEADING_ZEROS(x);\n}\n\n// 2^n - 1 の形かどうか\nbool is_mersenne(i64 x) {\n    ASSERT(x >= 0);\n    return (x&(x+1)) == 0;\n}\n\nbool is_pow2(i64 x) {\n    ASSERT(x > 0);\n    return (x&(x-1)) == 0;\n}\n\n// x > 0\ni64 pow2_ceil(i64 x) {\n    return BIT_I(log2_ceil(x));\n}\n\n// x > 0\ni64 pow2_floor(i64 x) {\n    return BIT_I(log2_floor(x));\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\n// x を align の倍数に切り上げる\ni64 align_ceil(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_ceil(x,align) * align;\n}\n\n// x を align の倍数に切り下げる\ni64 align_floor(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_floor(x,align) * align;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmax(T& xmax, const U& x, Comp comp={}) {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmin(T& xmin, const U& x, Comp comp={}) {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename Pred>\ni64 arg_find(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    FOR(x, lo, hi) {\n        if(pred(x)) return x;\n    }\n    return INF;\n}\n\ntemplate<typename F>\ni64 arg_max(i64 lo, i64 hi, F f) {\n    ASSERT(lo < hi);\n\n    i64 res = lo;\n    auto ymax = f(lo);\n    FOR(x, lo+1, hi) {\n        if(chmax(ymax, f(x)))\n            res = x;\n    }\n    return res;\n}\n\ntemplate<typename F>\ni64 arg_min(i64 lo, i64 hi, F f) {\n    ASSERT(lo < hi);\n\n    i64 res = lo;\n    auto ymin = f(lo);\n    FOR(x, lo+1, hi) {\n        if(chmin(ymin, f(x)))\n            res = x;\n    }\n    return res;\n}\n\ntemplate<typename Pred>\ni64 arg_find_r(i64 lo, i64 hi, Pred pred) {\n    i64 x = arg_find(-hi+1, lo+1, [pred](i64 xx) { return pred(-xx); });\n    return x == INF ? INF : -x;\n}\n\ntemplate<typename F>\ni64 arg_max_r(i64 lo, i64 hi, F f) {\n    return -arg_max(-hi+1, lo+1, [f](i64 x) { return f(-x); });\n}\n\ntemplate<typename F>\ni64 arg_min_r(i64 lo, i64 hi, F f) {\n    return -arg_min(-hi+1, lo+1, [f](i64 x) { return f(-x); });\n}\n\ntemplate<typename ForwardIt, typename T, typename Comp=less<>>\nForwardIt bsearch_find(ForwardIt first, ForwardIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == last || comp(x,*it)) return last;\n    return it;\n}\n\n// x 未満の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_lt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x 以下の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_le(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = upper_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x より大きい最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_gt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return upper_bound(first, last, x, comp);\n}\n\n// x 以上の最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_ge(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return lower_bound(first, last, x, comp);\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD(InputIt first, InputIt last,\n          typename iterator_traits<InputIt>::value_type init,\n          BinaryOp op)\n{\n    for(; first != last; ++first)\n        init = op(move(init), *first);\n    return init;\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD1(InputIt first, InputIt last, BinaryOp op) {\n    auto init = *first++;\n    return FOLD(first, last, init, op);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc>\nauto FLIP(BinaryFunc f) {\n    return [f](const auto& x, const auto& y) {\n        return f(y,x);\n    };\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\ntemplate<typename F>\nauto EQ_ON(F f) { return ON(equal_to<>(), f); }\n\ntemplate<typename F>\nauto NE_ON(F f) { return ON(not_equal_to<>(), f); }\n\ntemplate<typename Comp=less<>>\nauto EQUIV(Comp comp={}) {\n    return [comp](const auto& lhs, const auto& rhs) {\n        return !comp(lhs,rhs) && !comp(rhs,lhs);\n    };\n}\n\ntemplate<typename ForwardIt>\nForwardIt next_bounded(ForwardIt last, ForwardIt it, i64 n=1) {\n    auto bound = distance(it, last);\n    return next(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nForwardIt prev_bounded(ForwardIt first, ForwardIt it, i64 n=1) {\n    auto bound = distance(first, it);\n    return prev(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nvoid advance_bounded(ForwardIt first, ForwardIt last, ForwardIt& it, i64 n) {\n    if(n > 0) {\n        auto bound = distance(it, last);\n        advance(it, MIN(n, bound));\n    }\n    else if(n < 0) {\n        auto bound = distance(it, first);\n        advance(it, MAX(n, bound));\n    }\n}\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T, typename Enable=void>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename Enum>\nstruct Formatter<Enum, enable_if_t<is_enum<Enum>::value>> {\n    static ostream& write_str(ostream& out, Enum x) {\n        return WRITE_STR(out, static_cast<underlying_type_t<Enum>>(x));\n    }\n    static ostream& write_repr(ostream& out, Enum x) {\n        return WRITE_REPR(out, static_cast<underlying_type_t<Enum>>(x));\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, SFINAE(sizeof...(TS) == I)>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, SFINAE(sizeof...(TS) > I)>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, SFINAE(sizeof...(TS) == I)>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, SFINAE(sizeof...(TS) > I)>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    ASSERT(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD1(T& x) {\n    RD(x);\n    --x;\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n    cout.flush();\n#ifdef PROCON_LOCAL\n    cerr.flush();\n    exit(0);\n#else\n    _Exit(0);\n#endif\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) == 1)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, get<0>(value));\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_CARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), std::make_tuple(args))\n    #define DBG_CARRAY(expr) DBG_CARRAY_IMPL(__LINE__, CPP_STR(expr), (expr))\n    #define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, CPP_STR(first), CPP_STR(last), (first), (last))\n#else\n    #define DBG(args...)\n    #define DBG_CARRAY(expr)\n    #define DBG_RANGE(first,last)\n#endif\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// serial {{{\n\nstruct Serial {\n    i64 v_;\n    i64 step_;\n\n    explicit Serial(i64 start, i64 step=1) : v_(start), step_(step) {}\n\n    i64 next() {\n        i64 res = v_;\n        v_ += step_;\n        return res;\n    }\n\n    i64 peek() const {\n        return v_;\n    }\n};\n\n// }}}\n\n//--------------------------------------------------------------------\n\nstruct SegTree {\n    i64 n_;\n    vector<pair<i64,i64>> v_;  // 1-based\n\n    explicit SegTree(i64 n) : n_(pow2_ceil(n)), v_(2*n_,PAIR(-1,BIT_I_1(31))) {}\n\n    void update(i64 i, i64 k, const pair<i64,i64>& p) {\n        for(i64 l=i+n_, r=i+k+n_; l < r; l>>=1, r>>=1) {\n            if(l & 1) {\n                v_[l] = p;\n                ++l;\n            }\n            if(r & 1) {\n                --r;\n                v_[r] = p;\n            }\n        }\n    }\n\n    i64 query(i64 i) const {\n        auto res = v_[i+n_];\n        for(i64 j = (i+n_)>>1; j >= 1; j >>= 1) {\n            chmax(res, v_[j]);\n        }\n        return SND(res);\n    }\n};\n\nvoid solve() {\n    i64 N; RD(N);\n    i64 Q; RD(Q);\n\n    Serial serial(0);\n    SegTree seg(N);\n    REP(_, Q) {\n        i64 cmd; RD(cmd);\n        if(cmd == 0) {\n            i64 s,t; RD(s); RD(t);\n            i64 x; RD(x);\n            seg.update(s, t-s+1, {serial.next(),x});\n        }\n        else if(cmd == 1) {\n            i64 i; RD(i);\n            i64 ans = seg.query(i);\n            PRINTLN(ans);\n        }\n        else {\n            ASSERT(false);\n        }\n    }\n\n    //PRINTLN(ans);\n\n    // * 小さいケースで試した?\n    // * 不可能なケースはチェックした?\n    // * MOD はとった?\n    // * メモ化忘れてない?\n    // * 入出力の 0-based/1-based 確認した?\n    // * 時間/メモリ制限は確認した?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename T> class RangeUpdateSegTree {\n  int size = 1;\n  std::vector<pair<size_t, T>> tree; // 1-indexed\n  size_t time = 1;\n\npublic:\n  RangeUpdateSegTree(const int n = 0) {\n    while (size < n) size *= 2;\n    tree.resize(size * 2);\n  }\n\n  RangeUpdateSegTree(const int n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, {0, x});\n  }\n\n  template<typename InputIterator> RangeUpdateSegTree(InputIterator first, InputIterator last) {\n    int n = std::distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2);\n\n    auto result = tree.begin();\n    while (first != last) {\n      result->second = *first;\n      ++result, ++first;\n    }\n  }\n\n  // [l, r)\n  void update(int l, int r, const T &x) {\n    for (l += size, r += size; l < r; l /= 2, r /= 2) {\n      if (l & 1) tree[l++] = {time, x};\n      if (r & 1) tree[--r] = {time, x};\n    }\n    time++;\n  }\n\n  const T operator[](int i) const {\n    pair<size_t, T> p = tree[i += size];\n    while (i /= 2) p = max(p, tree[i]);\n    return p.second;\n  }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  RangeUpdateSegTree<int> rast(n, 2147483647);\n  while (q--) {\n    int a;\n    cin >> a;\n    if (a) {\n      int i;\n      cin >> i;\n      cout << rast[i] << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      rast.update(s, t + 1, x);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,q,d[1<<18],a,b,c,e[1<<17];\nvoid m(int l,int r,int k){if(r<=a||b<=l)return;if(a<=l&&r<=b)d[k]=q;else{m(l,(l+r)/2,k*2+1);m((l+r)/2,r,k*2+2);}}\nint main(){\n\tcin>>a>>q;n=2;while(n<a)n*=2;a=2*n;while(a--)d[a]=114514;e[114514]=INT_MAX;\n\twhile(q--){cin>>a;\n\t\tif(a){cin>>a;a+=n-1,b=d[a];while(a)a=(a-1)/2,b=min(b,d[a]);cout<<e[b]<<endl;}\n\t\telse{cin>>a>>b>>c;b++,e[q]=c;m(0,n,0);}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define FOR(I,A,B) for(int I=int(A);I<int(B);++I)\n \nstruct RUQ{//平方分割 0-index\n\tint n,rn,bn,Q=0;\n\tvector<int> a,b,at,bt;\n\tRUQ(int n_){\n\t\tn = n_; rn = sqrt(n); bn = ceil((double)n/rn);\n\t\ta.resize(n,2147483647);at.resize(n,0);\n\t\tb.resize(bn,2147483647);bt.resize(n,0);\n\t}\n\tint value(int s){\n\t\treturn (at[s]<bt[s/rn]?b[s/rn]:a[s]);\n\t}\n\tvoid updete(int s,int t,int x){\n\t\tQ++;\n\t\tFOR(i,s,t+1){\n\t\t\tif(i%rn==0 && (i+rn-1)<=t){\n\t\t\t\tb[i/rn] = x;\n\t\t\t\tbt[i/rn] = Q;\n\t\t\t\ti += rn-1;\n\t\t\t}else{\n\t\t\t\ta[i] = x;\n\t\t\t\tat[i] = Q;\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,q,s,t,x,com;\n\tcin >> n >> q;\n\tRUQ data(n);\n\tFOR(Q,1,q+1){\n\t\tcin>>com;\n\t\tif(com){//find\n\t\t\tcin >> s;\n\t\t\tcout << data.value(s) << \"\\n\";\n\t\t}else{//updete\n\t\t\tcin >> s >> t >> x;\n\t\t\tdata.updete(s,t,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\ntemplate<class V> class segtree {\nprivate:\n    int n;\n    vector<V> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    segtree(vector<V> v) {\n        int sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n-1,INT_MAX);\n        lazy.resize(2*n-1, 0);\n        lazyFlag.resize(2*n-1,false);\n        rep(i,sz){\n            node[i+n-1] = v[i];\n        }\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            range(a, b, x, 2*k+1, l, (l+r)/2);\n            range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V find(int a, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(l == a){\n            return node[k];\n        }\n        if(a < (l+r)/2){\n            return find(a, 2*k+1, l, (l+r)/2);\n        }else{\n            return find(a, 2*k+2, (l+r)/2, r);\n        }\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin >> n >> q;\n    segtree<int> sg(vector<int>(n,INT_MAX));\n    rep(i,q){\n        int k;\n        cin >> k;\n        if(k){\n            int x;\n            cin >> x;\n            cout << sg.find(x) << \"\\n\";\n        }else{\n            int x,y,z;\n            cin >> x >> y >> z;\n            sg.range(x,y+1,z);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n    int A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            cout << A[i] << endl;\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, v, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u, long long v) {\n\tif (s <= p || q <= r) { if (v != INF)seg[u] = v; return; }\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tlong long w = v; if (w == INF)w = seg[u]; seg[u] = INF;\n\tupdate(p, q, r, (r + s) / 2, t, u * 2, w);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1, w);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((r <= p && q <= s) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> v; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_ * 2; i++)seg[i] = INF;\n\tfor (int i = 1; i <= v; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1, INF); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nこのコード、と～おれ!\nBe accepted!\n∧＿∧　\n（｡･ω･｡)つ━☆・*。\n⊂　　 ノ 　　　・゜+.\n　しーＪ　　　°。+ *´¨)\n 　　　　　　　　　.· ´¸.·*´¨) ¸.·*¨)\n\t\t  　　　　　　　　　　(¸.·´ (¸.·'* ☆\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <regex>\n#include <functional>\n#include <complex>\n#include <list>\n#include <cassert>\n#include <iomanip>\n#include <set>\n#include <stack>\n/*多倍長整数/cpp_intで宣言\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace boost::multiprecision;\n*/\n\n//#pragma gcc target (\"avx2\")\n//#pragma gcc optimization (\"o3\")\n//#pragma gcc optimization (\"unroll-loops\")\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, n) for(int i = 1; i <= (n); ++i)\n#define rep2(i, n) for(int i = 2; i < (n); ++i)\n#define repr(i, n) for(int i = n; i >= 0; --i)\n#define reprm(i, n) for(int i = n - 1; i >= 0; --i)\n#define printynl(a) printf(a ? \"yes\\n\" : \"no\\n\")\n#define printyn(a) printf(a ? \"Yes\\n\" : \"No\\n\")\n#define printYN(a) printf(a ? \"YES\\n\" : \"NO\\n\")\n#define printim(a) printf(a ? \"possible\\n\" : \"imposible\\n\")\n#define printdb(a) printf(\"%.50lf\\n\", a) //少数出力\n#define printLdb(a) printf(\"%.50Lf\\n\", a) //少数出力\n#define printdbd(a) printf(\"%.16lf\\n\", a) //少数出力(桁少なめ)\n#define prints(s) printf(\"%s\\n\", s.c_str()) //string出力\n#define all(x) (x).begin(), (x).end()\n#define allsum(a, b, c) ((a + b) * c / 2.0) //等差数列の和、初項,末項,項数\n#define pb push_back\n#define priq priority_queue\n#define rpriq priq<int, vector<int>, greater<int>>\n#define deg_to_rad(deg) (((deg)/360.0L)*2.0L*PI)\n#define rad_to_deg(rad) (((rad)/2.0L/PI)*360.0L)\n#define Please return\n#define AC 0\n#define manhattan_dist(a, b, c, d) (abs(a - c) + abs(b - d)) /*(a, b) から (c, d) のマンハッタン距離 */\n\n\nusing ll = long long;\n\nconstexpr int INF = 1073741823;\nconstexpr int MINF = -1073741823;\nconstexpr ll LINF = ll(4661686018427387903);\nconstexpr ll MOD = 1000000007;\nconst long double PI = acosl(-1.0L);\n\nusing namespace std;\n\nvoid scans(string& str) {\n\tchar c;\n\tstr = \"\";\n\tscanf(\"%c\", &c);\n\tif (c == '\\n')scanf(\"%c\", &c);\n\twhile (c != '\\n' && c != -1 && c != ' ') {\n\t\tstr += c;\n\t\tscanf(\"%c\", &c);\n\t}\n}\n\nvoid scanc(char& str) {\n\tchar c;\n\tscanf(\"%c\", &c);\n\tif (c == -1)return;\n\twhile (c == '\\n') {\n\t\tscanf(\"%c\", &c);\n\t}\n\tstr = c;\n}\n\ndouble acot(double x) {\n\treturn PI / 2 - atan(x);\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll number1, ll number2) {\n\treturn number1 / gcd(number1, number2) * number2;\n}\n\nll LSB(ll n) { return (n & (-n)); }\n\n/*-----------------------------------------ここからコード-----------------------------------------*/\n\n//セグ木/0-indexed/非再帰/n の大きさ, a (単位元), 本体のマージ関数, 遅延ノードの単位元, 遅延ノードのマージ関数, 遅延ノードと本体のマージ関数 で segtree を初期化する\ntemplate<typename T, typename U>\nstruct lazysegtree {\n\t//木を配列であらわしたもの\n\tvector<T> seg;\n\t//遅延ノード\n\tvector<U> lazy;\n\t//木の1/2の大きさ\n\tint siz, height;\n\t//本体の単位元\n\tconst T sunit;\n\t//遅延ノードの単位元\n\tconst U lunit;\n\t//本体のマージ関数の型\n\tusing F = function<T(T, T)>;\n\t//遅延ノードのマージ関数の型\n\tusing F2 = function<U(U, U)>;\n\t//遅延ノードと本体のマージ関数の型\n\tusing F3 = function<T(T, U)>;\n\t//本体同士をマージする関数\n\tconst F f;\n\t//遅延ノード同士をマージする関数\n\tconst F2 f2;\n\t//遅延ノードと本体をマージする関数\n\tconst F3 f3;\n\n\t//n の大きさ, a (単位元), 本体のマージ関数, 遅延ノードの単位元, 遅延ノードのマージ関数, 遅延ノードと本体のマージ関数 で segtree を初期化する\n\tlazysegtree(int n, const T sunit, const F f, const U lunit, const F2 f2, const F3 f3) : sunit(sunit), f(f), lunit(lunit), f2(f2), f3(f3) {\n\t\tsiz = 1;\n\t\theight = 0;\n\t\twhile (siz < n)siz <<= 1, ++height;\n\t\tseg.assign(2 * siz - 1, sunit);\n\t\tlazy.assign(2 * siz - 1, lunit);\n\t\t--siz;\n\t}\n\n\t//k (0-indexed) 番目に t を代入\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//f によって木を構築\n\tvoid build() {\n\t\tfor (int i = siz - 1; i >= 0; --i) seg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t}\n\n\t//i 番目の要素を返す\n\tT operator[](const int i) {\n\t\treturn query(i, i + 1);\n\t}\n\n\t//k 番目の遅延ノードを伝播する\n\tinline T merge(int k) {\n\t\treturn (lazy[k] == lunit ? seg[k] : f3(seg[k], lazy[k]));\n\t}\n\n\t//子に伝播\n\tinline void eval(int k) {\n\t\tif (lazy[k] != lunit) {\n\t\t\tlazy[k * 2 + 1] = f2(lazy[k * 2 + 1], lazy[k]);\n\t\t\tlazy[k * 2 + 2] = f2(lazy[k * 2 + 2], lazy[k]);\n\t\t\tseg[k] = merge(k);\n\t\t\tlazy[k] = lunit;\n\t\t}\n\t}\n\n\tinline void bottomup(int k) {\n\t\twhile (k > 0) {\n\t\t\tk = ((k - 1) >> 1);\n\t\t\tseg[k] = f(merge(2 * k + 1), merge(2 * k + 2));\n\t\t}\n\t}\n\n\tinline void topdown(int k) {\n\t\tfor (int i = height; i > 0; --i) {\n\t\t\teval(((k + 1) >> i) - 1);\n\t\t}\n\t}\n\n\t//k 番目の値を a に更新\n\tvoid update(int k, T a) {\n\t\tk += siz;\n\t\t//必要であればここを変える\n\t\tseg[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = ((k - 1) >> 1);\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[l, r) の値を a に更新\n\tvoid update(int l, int r, T a) {\n\t\tint x = l + siz, y = r + siz - 1;\n\t\ttopdown(x);\n\t\ttopdown(y);\n\t\tfor (l += siz, r += siz; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (!(l & 1)) {\n\t\t\t\tlazy[l] = f2(lazy[l], a);\n\t\t\t\t++l;\n\t\t\t}\n\t\t\tif (!(r & 1)) {\n\t\t\t\t--r;\n\t\t\t\tlazy[r] = f2(lazy[r], a);\n\t\t\t}\n\t\t}\n\t\tbottomup(x);\n\t\tbottomup(y);\n\t}\n\n\t//[a, b) について f した結果を返す\n\tT query(int a, int b) {\n\t\ttopdown(a += siz);\n\t\ttopdown(b += siz - 1);\n\t\tT l = sunit, r = sunit;\n\t\tfor (++b; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(l, merge(a++));\n\t\t\tif (!(b & 1))r = f(merge(--b), r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n\n\t\n\t//[start, end) について、[l, r) を調べながら k 番目が check を満たすか二分探索 最後が true なら left, false なら right fの逆演算\n\ttemplate<typename C>\n\tint find(const int start, const int end, int l, int r, int k, const C check, T& checknum, const bool b, const function<T(T, T)> revf) {\n\t\t//cerr << checknum << '\\n';\n\t\t//範囲外またはそこがすでに満たさないとき\n\t\t//cerr << k << ',' << checknum << '\\n';\n\t\tif (start <= l && r <= end && !check(seg[k], checknum)) {\n\t\t\tchecknum = revf(checknum, seg[k]);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r <= start || l >= end)) {\n\t\t\treturn -1;\n\t\t}\n\t\t//既に葉\n\t\tif (k >= siz) {\n\t\t\treturn k - siz;\n\t\t}\n\t\tint res;\n\t\tif (b) {\n\t\t\t//左側を調べる\n\t\t\tres = find< C >(start, end, l, ((l + r) >> 1), (k << 1) + 1, check, checknum, b, revf);\n\t\t\t//左側が適してたらそれが答え\n\t\t\tif (res != -1)return (res);\n\t\t\treturn find< C >(start, end, ((l + r) >> 1), r, (k << 1) + 2, check, checknum, b, revf);\n\t\t}\n\t\telse {\n\t\t\t//右側を調べる\n\t\t\tres = find< C >(start, end, ((l + r) >> 1), r, (k << 1) + 2, check, checknum, b, revf);\n\t\t\t//右側が適してたらそれが答え\n\t\t\tif (res != -1)return (res);\n\t\t\treturn find< C >(start, end, l, ((l + r) >> 1), (k << 1) + 1, check, checknum, b, revf);\n\t\t}\n\t}\n\n\ttemplate<typename C>\n\tint find_left(int start, int end, const C check, T checknum, function<T(T, T)> revf) {\n\t\treturn find< C >(start, end, 0, siz + 1, 0, check, checknum, true, revf);\n\t}\n\n\ttemplate<typename C>\n\tint find_right(int start, int end, const C check, T checknum, function<T(T, T)> revf) {\n\t\treturn find< C >(start, end, 0, siz + 1, 0, check, checknum, false, revf);\n\t}\n\t\n};\n\nint main() {\n\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tauto f = [](ll a, ll b) {return min(a, b); };\n\tauto f2 = [](ll a, ll b) {return b == -1 ? a : b; };\n\tauto f3 = [](ll a, ll b) {return b; };\n\tlazysegtree<ll, ll> tree(n, ((1LL << 31LL) - 1LL), f, -1, f2, f2);\n\tint query, s, t, x;\n\trep(i, n)tree.set(i, ((1LL << 31LL) - 1LL));\n\ttree.build();\n\twhile (q--) {\n\t\tscanf(\"%d\", &query);\n\t\tif (query) {\n\t\t\tscanf(\"%d\", &s);\n\t\t\t++t;\n\t\t\tprintf(\"%lld\\n\", tree[s]);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\t++t;\n\t\t\ttree.update(s, t, x);\n\t\t}\n\t\t//rep(i, n)cerr << tree[i] << ' ';\n\t\t//cerr << endl;\n\t}\n\n\tPlease AC;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1LL << 31) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\ntemplate<typename T, typename E>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, size_t)>;\n    int n;\n    F f; //要素と要素のマージ\n    G g; //要素に作用素を作用\n    H h; //作用素と作用素をマージ\n    T ti; //要素の単位元?\n    E ei; //作用素の単位元?\n    P p; //b個の作用素aをマージした場合\n    vector<T> dat;\n    vector<E> laz;\n\n    SegmentTree(int n_, F f, G g, H h, T ti, E ei,\n                P p = [](E a, size_t b) {\n                    b++;\n                    return a;\n                }) :\n            f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n        dat.assign(2 * n - 1, ti);\n        laz.assign(2 * n - 1, ei);\n    }\n\n    void build(int n_, vector<T> v) {\n        for (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k) {\n        if (laz[k] == ei) return;\n        if (k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = ei;\n    }\n\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return dat[k];\n        if (a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    T update(int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return ti;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    void update(int k, T x) {\n        query(k, k + 1);//evaluate\n        k += n - 1;\n        dat[k] = x;\n        while (k) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    n++;\n    using T = pair<int, int>; //firstは値、secondはtime\n    using E = pair<int, int>;\n    auto f = [](T a, T b) {\n        if (a.second > b.second) {\n            return a;\n        } else {\n            return b;\n        }\n    }; // 要素と要素のマージ\n\n    auto g = [](T a, E b) {\n        if (a.second > b.second) {\n//            return a.first;\n            return a;\n        } else {\n//            return b.first;\n            return b;\n        }\n    }; // 要素に作用素を作用\n\n    auto h = [](E a, E b) {\n        if (a.second > b.second) {\n//            return a.first;\n            return a;\n        } else {\n//            return b.first;\n            return b;\n        }\n    }; // 作用素と作用素をマージ\n\n    auto p = [](E a, int b) {\n        return a;\n    }; // 作用素を区間加算する場合\n    T ti = T(INT_MAX, 0); //要素の単位元?\n    E ei = E(INT_MAX, 0); //作用素の単位元?\n    SegmentTree<T, E> treeone(n, f, g, h, ti, ei, p);\n\n//    cout << treeone.query(2,3).first << endl;\n    int time = 0;\n    while(q--){\n        int cmd;\n        cin >> cmd;\n        if(cmd){\n            int i;\n            cin >> i;\n            cout << treeone.query(i,i+1).first << endl;\n        }else{\n            time++;\n            int s,t,x;\n            cin >> s >> t >> x;\n            E val(x,time);\n            treeone.update(s,t+1,val);\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename Q_temp>\nusing smaller_queue = priority_queue<Q_temp, vector<Q_temp>, greater<Q_temp>>;\n\nconst ll MOD = (ll)(1e9 + 7);\nconst int INF = (int)1e9;\nconst ll LINF = (ll)4e18;\nconst double PI = acos(-1.0);\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << endl\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << endl\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << endl;\n\nvector<int> Dx = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nvector<int> Dy = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\ntemplate <typename T, typename E>\nstruct SegmentTree\n{\n  typedef function<T(T, T)> F;\n  typedef function<T(T, E)> G;\n  typedef function<E(E, E)> H;\n  typedef function<E(E, int)> P;\n  int n;\n  F f;\n  G g;\n  H h;\n  P p;\n  T d1;\n  E d0;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_, F f, G g, H h, T d1, E d0,\n              vector<T> v = vector<T>(), P p = [](E a, int b) { return a; }) : f(f), g(g), h(h), d1(d1), d0(d0), p(p)\n  {\n    init(n_);\n    if (n_ == (int)v.size())\n      build(n_, v);\n  }\n  void init(int n_)\n  {\n    n = 1;\n    while (n < n_)\n      n *= 2;\n    dat.clear();\n    dat.resize(2 * n - 1, d1);\n    laz.clear();\n    laz.resize(2 * n - 1, d0);\n  }\n  void build(int n_, vector<T> v)\n  {\n    for (int i = 0; i < n_; i++)\n      dat[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; i--)\n      dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n  inline void eval(int len, int k)\n  {\n    if (laz[k] == d0)\n      return;\n    if (k * 2 + 1 < n * 2 - 1)\n    {\n      laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n      laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n    }\n    dat[k] = g(dat[k], p(laz[k], len));\n    laz[k] = d0;\n  }\n  T update(int a, int b, E x, int k, int l, int r)\n  {\n    eval(r - l, k);\n    if (r <= a || b <= l)\n      return dat[k];\n    if (a <= l && r <= b)\n    {\n      laz[k] = h(laz[k], x);\n      return g(dat[k], p(laz[k], r - l));\n    }\n    return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                      update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n  }\n  T update(int a, int b, E x)\n  {\n    return update(a, b, x, 0, 0, n);\n  }\n  T query(int a, int b, int k, int l, int r)\n  {\n    eval(r - l, k);\n    if (r <= a || b <= l)\n      return d1;\n    if (a <= l && r <= b)\n      return dat[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n  T query(int a, int b)\n  {\n    return query(a, b, 0, 0, n);\n  }\n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(20) << setiosflags(ios::fixed);\n  int n, q;\n  cin >> n >> q;\n  SegmentTree<ll, ll> sg(\n      n,\n      [](ll a, ll b) { return a + b; },\n      [](ll a, ll b) { return b; },\n      [](ll a, ll b) { return b; },\n      0, -LINF, vector<ll>(n, (1LL << 31) - 1));\n  rep(_, q)\n  {\n    int type;\n    cin >> type;\n    if (type == 0)\n    {\n      ll s, t, x;\n      cin >> s >> t >> x;\n      sg.update(s, t + 1, x);\n    }\n    else\n    {\n      int t;\n      cin >> t;\n      cout << sg.query(t, t + 1) << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define FOR(i,x,n) for(ll i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e18)\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} cout << a[a.size()-1] << endl;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define LEAF ((ll)pow(2, 17)-1)\n#define NUM ((ll)pow(2, 18)-1)\nusing P=pair<ll, ll>;\nvector<P> seg(NUM, {(ll)pow(2,31)-1, 0});\n\nvoid update(ll s, ll t, ll x, ll n, ll l, ll r, ll k){\n    // prllf(\"%d, %d, %d\\n\", l ,r, k);\n    if(r < s || t < l) {\n        // pr(\"c\"); \n        return;}\n    if(l==r) {seg[k] = {x, n}; \n    // pr(\"a\"); \n    return;}\n    if(s<=l && r<=t) {seg[k] = {x, n}; \n    // pr(\"b\");\n     return;}\n    ll mid = (l+r)/2;\n    ll chl = 2*k+1, chr = 2*k+2;\n    update(s, t, x, n, l, mid, chl);\n    update(s, t, x, n, mid+1, r, chr);\n}\n\nll find(ll i, P p){\n    if(seg[i].second > p.second) p = seg[i];\n    if(i==0) return p.first;\n    return find((i-1)/2, p); \n}\n\nint main()\n{\n    ll n, q; cin >> n >> q;\n    ll c, s, t, x;\n    rep(i, q){\n        cin >> c;\n        if(c==1){\n            cin >> x;\n            ll k = find(LEAF + x, {0, -1});\n            pr(k);\n        }else{\n            cin >> s >> t >> x;\n            update(s, t, x, i+1, 0, LEAF, 0);\n        }\n    }\n\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1<<18;\ntypedef pair<int,int> P;\nint n_;\nP dat[2*MAX_N-1];\n\nvoid init(int n) {\n  n_=1;\n  while (n>n_) {\n    n_*=2;\n  }\n  for (int i=0; i<2*n_-1; i++) {\n    dat[i].first=-1;\n    dat[i].second=INT_MAX;\n  }\n}\nint find(int i) {\n  i+=n_-1;\n  P p=dat[i];\n  while (i>0) {\n    i=(i-1)/2;\n    p=max(p,dat[i]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n_) {\n  if (r<=a || b<=l) {\n    return;\n  }\n  if (a<=l && r<=b) {\n    dat[k]=p;\n  } else {\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  } \n}\nint main() {\n  int n, q;\n  cin >> n >> q;\n  init(n);\n  for (int i=0;i<q;i++) {\n    int f;\n    cin >> f;\n    if (!f) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      update(s,t+1,P(i,x));\n    } else {\n      int u;\n      cin >> u;\n      printf(\"%d\\n\",find(u));\n    }    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nclass RangeSeg{\n\tint n;\n\tvector<ll> data, lazy;\npublic:\n\tRangeSeg(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n <<= 1;\n\t\tREP(i, n*2-1){\n\t\t\tdata.push_back(-1);\n\t\t\tlazy.push_back(-1);\n\t\t}\n\t}\n\n\tvoid push(int l, int r, int k){\n\t\tif(lazy[k] != -1){\n\t\t\tdata[k] = lazy[k];\n\t\t\tif(r - l > 1){\n\t\t\t\tlazy[k*2+1] = lazy[k];\n\t\t\t\tlazy[k*2+2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int l, int r, int k, int x){\n\t\tpush(k, l, r);\n\t\tif(s <= l && r <= t){\n\t\t\tlazy[k] = x;\n\t\t\tpush(l, r, k);\n\t\t}else if(l < t && s < r){\n\t\t\tupdate(s, t, (l+r)/2, r, k*2+2, x);\n\t\t\tupdate(s, t, l, (l+r)/2, k*2+1, x);\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tupdate(s, t, 0, n, 0, x);\n\t}\n\t\n\tvoid show(){\n\t\tint i = 0;\n\t\tint en = 1;\n\t\twhile(i < n*2-1){\n\t\t\tcout << \"(\" << data[i] << \", \" << lazy[i] << \") \";\n\t\t\tif(i == en*2-2){\n\t\t\t\tcout << endl;\n\t\t\t\ten *= 2;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tll find(int l, int r, int k, int i){\n\t\tpush(l, r, k);\n\t\tif(r-l == 1){\n\t\t\treturn data[k];\n\t\t}\n\t\tif(l <= i && i <= r){\n\t\t\tif((l+r)/2 <= i){\n\t\t\t\treturn find((l+r)/2, r, k*2+2, i);\n\t\t\t}else{\n\t\t\t\treturn find(l, (l+r)/2, k*2+1, i);\n\t\t\t}\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tll find(int i){\n\t\treturn find(0, n, 0, i);\n\t}\t\n};\n\nint main(void){\n\tint n, q;\n\tcin >> n >> q;\n\tRangeSeg rs(n);\n\tREP(i, q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(com == 0){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\trs.update(s, t+1, x);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tx = rs.find(x);\n\t\t\tif(x == -1)\n\t\t\t\tcout << (1 << 31)-1 << endl;\n\t\t\telse\n\t\t\t\tcout << x << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\ntypedef pair<pll, pll> P;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\ntemplate<typename T>\nstruct LazySegTree {\n\tvector<T> node, lazy;\n\tvector<bool> done;\n\tint n;\n\tT init_val;\n\t\n\tLazySegTree(int _n, T init_val) : init_val(init_val) {\n\t\tn = 1;\n\t\twhile (n < _n) n *= 2;\n\t\tnode.resize(n * 2 - 1, init_val);\n\t\tlazy.resize(n * 2 - 1);\n\t\tdone.resize(n * 2 - 1, true);\n\t}\n\t\n\tvoid eval(int k, int l, int r) {\n\t\tif (done[k]) return;\n\t\tnode[k] = lazy[k];\n\t\t\n\t\tif (r - l > 1) {\n\t\t\tlazy[k * 2 + 1] = lazy[k]; done[k * 2 + 1] = false;\n\t\t\tlazy[k * 2 + 2] = lazy[k]; done[k * 2 + 2] = false;\n\t\t}\n\t\tdone[k] = true;\n\t}\n\t\n\tvoid update(int a, int b, T x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\teval(k, l, r);\n\t\t\n\t\tif (a >= r || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tdone[k] = false;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\t\tnode[k] = min(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\teval(k, l, r);\n\t\t\n\t\tif (a >= r || b <= l) return init_val;\n\t\tif (a <= l && r <= b) return node[k];\n\t\t\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tLazySegTree<ll> st(n, (1ll<<31) - 1);\n\t\n\twhile (q--) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b;\n\t\tif (a == 0) {\n\t\t\tcin >> c >> d;\n\t\t\tst.update(b, c + 1, d);\n\t\t}\n\t\telse {\n\t\t\tcout << st.query(b, b + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  ll lazy[sq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(t >= sq*sq && s < sq*sq){\n\t//cout << \"deug\" << endl;\n\tfill_n(a+sq*sq,t%sq+1,x);\n\tt = sq*sq-1;\n      }\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tfill_n(a+s,t-s+1,x);\n\t//cout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s) <= 2*sq){\n\tfill_n(a+s,t-s+1,x);\n\tlazy[t/sq] = -1;\n\tlazy[s/sq] = -1;\n\t//cout << \"debug2\" << endl;\n      }\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tfill_n(a+s,f-s,x);\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      if(te > sq-1){\n\tcout << a[x] << endl;\n      }\n      else if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq+1,lazy[te]);\n\tcout << a[x] << endl;\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RS {\n\tusing t1 = int;\n\tusing t2 = int;\n\tstatic t2 id2() { return 0; }\n\tstatic t1 op2(const t1& l, const t2& r) { return l + r; }\n\tstatic t2 op3(const t2& l, const t2& r) { return l + r; }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tvector<T1> data;\n\tvector<T2> lazy;\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tlazy[node << 1] = M::op3(lazy[node << 1], lazy[node]);\n\t\tlazy[(node << 1) | 1] = M::op3(lazy[(node << 1) | 1], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\npublic:\n\tlazy_segment_tree(int n_, T1 v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n_, v1), lazy(n << 1, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(data_), lazy(n << 1, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\tT1 find(int p) {\n\t\tT1 res = data[p]; p += n;\n\t\twhile (p) res = M::op2(res, lazy[p]), p >>= 1;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tlazy_segment_tree<RS> lst(n, 0);\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x; s--, t--;\n\t\t\tlst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint p;\n\t\t\tcin >> p; p--;\n\t\t\tprintf(\"%d\\n\", lst.find(p));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\n\ntemplate <typename T> class LazySegmentTree {\n\nprivate:\n\n    int n;\n    vector < bool > flag;\n    vector < T > node, lazy;\n    const T INF = numeric_limits<T>::max() / 2;\n    \n    void  lazy_eval (int l, int r, int k) {\n        if (flag[k]) {\n            node[k] = lazy[k];\n            flag[k] = false;\n            if (r - l > 1) {\n                lazy[2 * k + 1] = lazy[k];\n                lazy[2 * k + 2] = lazy[k];\n                flag[2 * k + 1] = true;\n                flag[2 * k + 2] = true;\n            }\n        }\n    }\n    \n    void _update (int a, int b, T val, int k, int l, int r) {\n        lazy_eval(l, r, k);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = val;\n            flag[k] = true;\n            lazy_eval(l, r, k);\n        } else {\n            _update (a, b, val, 2 * k + 1, l, (l + r) / 2);\n            _update (a, b, val, 2 * k + 2, (l + r) / 2, r);\n            node[k] = min(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    T _get_min (int a, int b, int k, int l, int r) {\n        lazy_eval (l, r, k);\n        if (b <= l || r <= a) return INF;\n        if (a <= l && r <= b) return node[k];\n        T vl = _get_min (a, b, 2 * k + 1, l, (l + r) / 2);\n        T vr = _get_min (a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n    \npublic:\n    \n    LazySegmentTree (int _n) : n(1) {\n        while (n < _n) n <<= 1;\n        node.resize (2 * n, INF);\n        lazy.resize (2 * n, INF);\n        flag.resize (2 * n, false);\n    }\n    \n    void update (int l, int r, T val) {\n        _update (l, r, val, 0, 0, n);\n    }\n    \n    T get_min (int l, int r) {\n        return _get_min (l, r, 0, 0, n);\n    }\n    \n};\n\nint main() {\n    \n    int n,q; cin >> n >> q;\n    \n    LazySegmentTree < ll > inst(100010);\n    \n    const ll INF = numeric_limits<ll>::max() / 2;\n    \n    REP(i,q) {\n        int a,l,r;\n        cin >> a;\n        if (a == 0) {\n            int l,r;\n            cin >> l >> r;\n            ll x; cin >> x;\n            inst.update(l, r + 1, x);\n        } else {\n            int i; cin >> i;\n            ll ans = inst.get_min(i, i + 1);\n            if (ans == INF) {\n                cout << ((1LL << 31LL) - 1LL) << endl;\n            } else {\n                cout << ans << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n\ntemplate<class T>\nstruct dual_segment_tree {\n\tusing value_type = T;\n\tusing size_type = std::size_t;\n\tusing Binary_Operation = std::function<T(T, T)>;\nprivate : \n\tsize_type n;\n\tconst Binary_Operation op;\n\tconst value_type identity;\n\tstd::vector<value_type> node;\n\n\tvoid propagate (size_type i) noexcept {\n\t\tif (node[i] == identity) return;\n\t\tnode[i << 1 | 0] = op(node[i << 1 | 0], node[i]);\n\t\tnode[i << 1 | 1] = op(node[i << 1 | 1], node[i]);\n\t\tnode[i] = identity;\n\t}\n\n\tvoid topdown_update (size_type i) noexcept {\n\t\tif (i == 0) return;\n\t\tconst size_type ctz = __builtin_ctz(i);\n\t\tfor (size_type h = 31 - __builtin_clz(i); h != ctz; h--) {\n\t\t\tpropagate(i >> h);\n\t\t}\n\t}\n\npublic : \n\texplicit constexpr dual_segment_tree (const value_type &identity, const Binary_Operation &op) noexcept : identity(identity), op(op) { }\n\n\tvoid assign (size_type _size) noexcept {\n\t\tn = _size;\n\t\tnode.assign(n << 1, identity);\n\t}\n\n\tvoid assign (size_type _size, const value_type &value) noexcept {\n\t\tassign(_size);\n\t\tfor (size_type i = n; i < (n << 1); i++) {\n\t\t\tnode[i] = value;\n\t\t}\n\t}\n\n\ttemplate<class InputIterator>\n\tvoid assign (InputIterator first, InputIterator last) noexcept {\n\t\tassign(last - first);\n\t\tfor (size_type i = n; first != last; i++, first++) {\n\t\t\tnode[i] = (*first);\n\t\t}\n\t}\n\n\tvoid update (size_type l, size_type r, const value_type &value) noexcept {\n\t\ttopdown_update(l + n); topdown_update(r + n);\n\t\tfor (l += n, r += n; l != r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) { node[l] = op(node[l], value); l++; }\n\t\t\tif (r & 1) { r--; node[r] = op(node[r], value); }\n\t\t}\n\t}\n\n\tvalue_type fold (size_type i) noexcept {\n\t\tvalue_type value = node[(i += n)];\n\t\tfor (i >>= 1; i > 0; i >>= 1) {\n\t\t\tvalue = op(value, node[i]);\n\t\t}\n\t\treturn value;\n\t}\n\n\tvalue_type operator[] (size_type i) noexcept {\n\t\treturn fold(i);\n\t}\n\n\tvalue_type at (size_type i) noexcept {\n\t\treturn fold(i);\n\t}\n\n};\n\ntemplate<class InputIterator, class T, class Binary_Operation>\ndual_segment_tree<T> make_dualsegtree (InputIterator first, InputIterator last, const T &identity, const Binary_Operation &op) {\n\tdual_segment_tree<T> segtree(identity, op);\n\tsegtree.assign(first, last);\n\treturn segtree;\n}\n\n\n\n#include <iostream>\n#include <limits>\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\t\n\tstd::size_t n;\n\tint q;\n\tstd::cin >> n >> q;\n\t\n\tstd::vector<int> v(n, std::numeric_limits<int>::max());\n\t\n\tauto seg = make_dualsegtree(v.begin(), v.end(), -1, [](int a, int b) { return (b == -1 ? a : b); });\n\t\n\twhile (q--) {\n\t\tint type;\n\t\tstd::cin >> type;\n\t\tif (type == 0) {\n\t\t\tstd::size_t l, r;\n\t\t\tint x;\n\t\t\tstd::cin >> l >> r >> x;\n\t\t\tseg.update(l, r + 1, x);\n\t\t} else {\n\t\t\tstd::size_t i;\n\t\t\tstd::cin >> i;\n\t\t\tstd::cout << seg[i] << '\\n';\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing uint=unsigned int;\nusing update_t=pair<int,uint>;//time value\nconst int MAXN=1e5+10;\n\nstruct Node{\n    int lbound,rbound;\n    update_t update;\n    Node *left,*right;\n};\n\nint A[MAXN];\nNode segtree[MAXN*2];\nNode* next_pos=segtree;\nint n,q;\n\nNode* build(int left,int right){\n    auto* cur=next_pos;\n    next_pos++;\n    cur->lbound=left;\n    cur->rbound=right;\n    cur->update=update_t(0,(1u<<31)-1);\n    int mid=(left+right)/2;\n    if (right-left==1) return cur;\n    cur->left=build(left,mid);\n    cur->right=build(mid,right);\n    return cur;\n}\n\nvoid update(Node& self,int l,int r,update_t u){\n    // puts(\"s\");\n    int mid=(self.lbound+self.rbound)/2;\n    if (l==self.lbound&&r==self.rbound){\n        self.update=u;\n    }else if (l>=mid){\n        update(*self.right,l,r,u);\n    }else if (r<=mid){\n        update(*self.left,l,r,u);\n    }else{\n        update(*self.left,l,mid,u);\n        update(*self.right,mid,r,u);\n    }\n}\n\nupdate_t query(Node& self,int i){\n    // puts(\"q\");\n    if (self.rbound-self.lbound==1&&self.lbound==i) return self.update;\n    int mid=(self.lbound+self.rbound)/2;\n    if (i>=mid) return max(query(*self.right,i),self.update);\n    else return max(query(*self.left,i),self.update);\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    build(0,n);\n    // puts(\"yes\");\n\n    for(int time=1;time<=q;time++){\n        int t;\n        scanf(\"%d\",&t);\n        if (t==0) {\n            int s,t,x;\n            scanf(\"%d%d%d\",&s,&t,&x);\n            update(segtree[0],s,t+1,update_t(time,x));\n            // puts(\"updated\");\n        }else{\n            int i;\n            // puts(\"ok\");\n            scanf(\"%d\",&i);\n            \n            auto v=query(segtree[0],i).second;\n            \n            printf(\"%u\\n\",v);\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T>inline bool chmax(T &a, T b){return (a < b ? a = b, true : false);}\ntemplate<typename T>inline bool chmin(T &a, T b){return (a > b ? a = b, true : false);}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst long double EPS = 1e-9;\n\n\n\ntemplate<typename T>\nclass RangeUpdateQuery {\nprivate:\n\tvector<T> data, lazy;\n\tvector<bool> valid, lazyFlag;\n\tint sz;\n\tvoid push(int k) {\n\t\tif (this->lazyFlag[k]) {\n\t\t\tthis->valid[k] = true;\n\t\t\tthis->data[k] = this->lazy[k];\n\t\t\tif (k * 2 + 2 < sz * 2 - 1) {\n\t\t\t\tthis->lazy[k * 2 + 1] = this->lazy[k * 2 + 2] = this->lazy[k];\n\t\t\t\tthis->lazyFlag[k * 2 + 1] = this->lazyFlag[k * 2 + 2] = true;\n\t\t\t}\n\t\t\tthis->lazyFlag[k] = false;\n\t\t}\n\t}\n\tvoid update(int l, int r, int L, int R, int k, T val) {\n\t\tthis->push(k);\n\t\tif (L <= l && r <= R) {\n\t\t\tthis->lazy[k] = val;\n\t\t\tthis->lazyFlag[k] = true;\n\t\t\tthis->push(k);\n\t\t} else if (r < L || R < l) {\n\t\t\treturn;\n\t\t} else if (r - l > 1) {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tthis->update(l, mid, L, R, k * 2 + 1, val);\n\t\t\tthis->update(mid, r, L, R, k * 2 + 2, val);\n\t\t}\n\t}\n\tT query(int l, int r, int idx, int k) {\n\t\tthis->push(k);\n\t\tif (r - l == 1) {\n\t\t\tif (!valid[k]) {\n\t\t\t\tthrow exception();\n\t\t\t}\n\t\t\treturn this->data[k];\n\t\t} else if (l <= idx && idx <= r) {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tif (idx < mid) {\n\t\t\t\treturn this->query(l, mid, idx, k * 2 + 1);\n\t\t\t} else {\n\t\t\t\treturn this->query(mid, r, idx, k * 2 + 2);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tRangeUpdateQuery(const int n) {\n\t\tthis->sz = 1;\n\t\twhile (this->sz < n) this->sz <<= 1;\n\t\tthis->data.resize(this->sz * 2 - 1);\n\t\tthis->lazy.resize(this->sz * 2 - 1);\n\t\tthis->valid.resize(this->sz * 2 - 1, false);\n\t\tthis->lazyFlag.resize(this->sz * 2 - 1, false);\n\t}\n\tvoid update(int l, int r, T val) {\n\t\tthis->update(0, sz, l, r, 0, val);\n\t}\n\tT query(int idx) {\n\t\treturn this->query(0, sz, idx, 0);\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tRangeUpdateQuery<int> ruq(n);\n\twhile (q--) {\n\t\tint num; cin >> num;\n\t\tif (num) {\n\t\t\tint idx; cin >> idx;\n\t\t\ttry {\n\t\t\t\tcout << ruq.query(idx) << endl;\n\t\t\t} catch (exception e) {\n\t\t\t\tcout << (1ll << 31) - 1 << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[n/sq+1];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f < to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\n\n\ntemplate<class T, class OP, class PROP>\nclass Lazy_Segment_Tree {//0-indexed ??????\npublic:\n\tvector<T> data, lazy;\n\tvector<bool> isupd;\n\tint n;\n\tLazy_Segment_Tree(int a) :n(1) {\n\t\twhile (n < a) n *= 2;\n\t\tdata.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tisupd.resize(n * 2 - 1);\n\t}\n\n\tvoid prop(int num, int s) {\n\t\tif (isupd[num]) {\n\t\t\tdata[num] = PROP()(data[num], lazy[num], 1, s);\n\t\t\tif (num < n - 1) {\n\t\t\t\tlazy[num * 2 + 1] = PROP()(lazy[num * 2 + 1], lazy[num]);\n\t\t\t\tlazy[num * 2 + 2] = PROP()(lazy[num * 2 + 2], lazy[num]);\n\t\t\t\tisupd[num * 2 + 1] = 1;\n\t\t\t\tisupd[num * 2 + 2] = 1;\n\t\t\t}\n\t\t\tlazy[num] = T();\n\t\t\tisupd[num] = 0;\n\t\t}\n\t}\n\tvoid op(int a, int b, T v, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\tprop(num,r-l);\n\t\tif (a == l && b == r) {\n\t\t\tisupd[num] = 1;\n\t\t\tlazy[num] = PROP()(lazy[num], v);\n\t\t\tprop(num, r-l);\n\t\t}\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tif (nr > a) op(a, min(b, nr), v, num * 2 + 1, base * 2);\n\t\t\tif (nr < b) op(max(a, nr), b, v, num * 2 + 2, base * 2);\n\t\t\tprop(num * 2 + 1, (r - l) / 2), prop(num * 2 + 2, (r - l) / 2);\n\t\t\tdata[num] = OP()(data[num * 2 + 1], data[num * 2 + 2]);\n\t\t}\n\t}\n\n\tT query(int a, int b, int num = 0, int base = 1) {\n\t\tint l = (num + 1 - base) * (n / base), r = l + n / base;\n\t\t\n\t\tprop(num,r-l);\n\n\t\tif (a == l && b == r)\n\t\t\treturn data[num];\n\t\telse {\n\t\t\tint nr = (l + r) / 2;\n\t\t\tT ret = T();\n\t\t\tif (nr > a) ret = OP()(ret,query(a, min(b, nr), num * 2 + 1, base * 2));\n\t\t\tif (nr < b) ret = OP()(ret,query(max(a, nr), b, num * 2 + 2, base * 2));\n\t\t\treturn ret;\n\t\t}\n\t}\n};\n\n\ntemplate<class T>\nclass ADD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn a + b;\n\t}\n};\n\ntemplate<class T>\nclass UPD {\npublic:\n\tT operator ()(const T a, const T b, const int ra = 1, int rb = 1) {\n\t\treturn b;\n\t}\n};\n\ntemplate<class T>\nclass RMQ {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn min(a, b);\n\t}\n};\ntemplate<class T>\nclass SUM {\npublic:\n\tT operator ()(const T a, const T b) {\n\t\treturn a+b;\n\t}\n};\n\nstruct N {\npublic:\n\tint num;\n\tN(int num) : num(num) {}\n\tN():num((1<<30)-1) {}\n\tN operator + (const N obj) const{\n\t\treturn N(obj.num + num);\n\t}\n\tbool operator < (const N obj)const {\n\t\treturn obj.num > num;\n\t}\n};\nsigned main() {\n\tint n, q;\n\n\tscanf(\"%d %d\", &n, &q);\n\tLazy_Segment_Tree<N, RMQ<N>, UPD<N>> seg(n);\n\tREP(i, q) {\n\t\tint t;\n\t\tscnaf(\"%d\", &t);\n\t\tif (!t) {\n\t\t\tint a, b, c;\n\t\t\tscnaf(\"%d %d %d\", &a, &b, &c);\n\t\t\tseg.op(a, b+1, c);\n\t\t}\n\t\telse {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tprintf(\"%d\\n\", seg.query(a,a+1));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = (1ll << 31) - 1;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nstruct SegmentTree {\n\tint n;\n\tvector<int>d;\n\tSegmentTree(int m) {\n\t\tfor (n = 1; n < m; n <<= 1);\n\t\td.assign(2 * n, INF);\n\t}\n\tvoid update(int a, int b, int x = -1, int k = 1, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\tif (r <= a || b <= l)return;\n\t\telse if (a <= l&&r <= b) {\n\t\t\tif (x >= 0)d[k] = x;\n\t\t}\n\t\telse {\n\t\t\tif (d[k] != INF)d[2 * k] = d[2 * k + 1] = d[k], d[k] = INF;\n\t\t\tupdate(a, b, x, 2 * k, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) / 2, r);\n\t\t}\n\t}\n\tint find(int i) {\n\t\tupdate(i, i + 1);\n\t\treturn d[n + i];\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tSegmentTree seg(n);\n\trep(i, 0, q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint x; cin >> x;\n\t\t\tcout << seg.find(x) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tseg.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(vector<T>v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nmain()\n{\n\tint n,q;cin>>n>>q;\n\tlazysegtree<int>S(n,2147483647,[](int a,int b){return a==2147483647?b:a;},[](int a,int b){return b;},[](int a,int b,unsigned int c){return b;});\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint c;cin>>c;\n\t\tif(c)\n\t\t{\n\t\t\tint s;cin>>s;\n\t\t\tcout<<S.query(s,s+1)<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s,t,x;cin>>s>>t>>x;\n\t\t\tS.update(s,t+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\ntemplate <class T, class T2>\nclass LazySegTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, T2)>;\n    using H = function<T2(T2, T2)>;\n    using P = function<T2(T2, int)>;\n    int n;\n    vector<T> data;\n    vector<T2> lazy;\n    const F f;\n    const G g;\n    const H h;\n    const P p;\n    const T e;\n    const T2 e2;\n\npublic:\n    LazySegTree(const vector<T>& as, const F f, const G g, const H h, const P p, const T& e, const T2 e2) : f(f), g(g), h(h), p(p), e(e), e2(e2) {\n        n = 1;\n        while (n < as.size()) n <<= 1;\n        data.assign(2 * n, e);\n        lazy.assign(2 * n, e2);\n        for (int i = 0; i < as.size(); i++) {\n            data[n + i] = as[i];\n        }\n        for (int i = n - 1; i > 0; i--) {\n            data[i] = f(data[2 * i], data[2 * i + 1]);\n        }\n    }\n\n    void propagate(int k, int len) {\n        if (lazy[k] != e2) {\n            if (k < n) {\n                lazy[2 * k] = h(lazy[2 * k], lazy[k]);\n                lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            }\n            data[k] = g(data[k], p(lazy[k], len));\n            lazy[k] = e2;\n        }\n    }\n\n    T update(int a, int b, const T2& x, int k, int l, int r) {\n        propagate(k, r - l);\n        if (r <= a || b <= l) {\n            return data[k];\n        } else if (a <= l && r <= b) {\n            lazy[k] = h(lazy[k], x);\n            propagate(k, r - l);\n            return data[k];\n        } else {\n            return data[k] = f(update(a, b, x, 2 * k, l, (l + r) >> 1), update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n        }\n    }\n\n    T update(int a, int b, const T2& x) {\n        return update(a, b, x, 1, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        propagate(k, r - l);\n        if (r <= a || b <= l) {\n            return e;\n        } else if (a <= l && r <= b) {\n            return data[k];\n        } else {\n            return f(query(a, b, 2 * k, l, (l + r) >> 1), query(a, b, 2 * k + 1, (l + r) >> 1, r));\n        }\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 1, 0, n);\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vi as(n, (i64(1) << 31) - 1);\n\n    // RUQ, RMQ\n    auto f = [](i64 a, i64 b) {return min(a, b);};\n    auto g = [](i64 a, i64 b) {return b < 0 ? a : b;};\n    auto h = [](i64 a, i64 b) {return b < 0 ? a : b;};\n    auto p = [](i64 a, int b) {return a;};\n    LazySegTree<i64, i64> tree(as, f, g, h, p, 1e18, -1);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            tree.update(s, t + 1, x);\n        } else {\n            int s;\n            cin >> s;\n            cout << tree.query(s, s + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nint a[100000];\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tfill(a, a + n, 2147483647);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tfill(a + s, a + t + 1, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << a[s] << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nclass sqrt_decomposition{\n    public:\n    const int B=1000;\n    int n;\n    vector<int> data,lazy;\n    vector<bool> flag;\n    sqrt_decomposition(int n,int init):n(n),data(n,init),lazy((n+B-1)/B),flag((n+B-1)/B){}\n\n\n    void propagate(int i){\n        assert(flag[i]);\n        flag[i]=false;\n        rep(j,0,B){\n            if(i*B+j>=n) break;\n            data[i*B+j]=lazy[j];\n        }\n    }\n\n    //[s,t)\n    void update(int s,int t,int x){\n        while(s<t and s%B!=0){\n            if(flag[s/B]) propagate(s/B);\n            data[s]=x;\n            ++s;\n        }\n        while(s<t and t%B!=0){\n            --t;\n            if(flag[t/B]) propagate(t/B);\n            data[t]=x;\n        }\n\n        while(s<t){\n            int i=s/B;\n            flag[i]=true;\n            lazy[i]=x;\n            s+=B;\n        }\n    }\n\n    int at(int i){\n        if(flag[i/B]) return lazy[i/B];\n        return data[i];\n    }\n};\n\nvoid solve(){\n    int n,q;\n    cin >> n >> q;\n    sqrt_decomposition sd(n,(1LL<<31)-1);\n\n    rep(i,0,q){\n        int k;\n        cin >> k;\n        if(k==0){\n            int s,t,x;\n            cin >> s >> t >> x;\n            ++t;\n            sd.update(s,t,x);\n        }else{\n            int i;\n            cin >> i;\n            cout << sd.at(i) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, q, p, s, t, x;\nlong long a[100000];\n\nint main()\n{\n\tcin >> n >> q;\n\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = 0x7FFFFFFF;\n\n\tfor (int j = 0; j < q; j++) {\n\t\tcin >> p;\n\n\t\tif (p == 0) {\n\t\t\tcin >> s >> t >> x;\n\n\t\t\tfor (int i = s; i <= t; i++)\n\t\t\t\ta[i] = x;\n\t\t}\n\t\telse if (p == 1) {\n\t\t\tcin >> s;\n\t\t\tcout << a[s] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = (1ll << 31) - 1;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nstruct RangeUpdateQuery {\n\tint n;\n\tvector<int>d;\n\tRangeUpdateQuery(int m) {\n\t\tfor (n = 1; n < m; n <<= 1);\n\t\td.assign(2 * n, INF);\n\t}\n\tvoid update(int a, int b, int x = -1, int k = 1, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tif (x >= 0)d[k] = x;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (d[k] != INF)d[2 * k] = d[2 * k + 1] = d[k], d[k] = INF;\n\t\t\tupdate(a, b, x, 2 * k, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) / 2, r);\n\t\t}\n\t}\n\tint find(int i) {\n\t\tupdate(i, i + 1);\n\t\treturn d[n + i];\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tRangeUpdateQuery ruq(n);\n\trep(z, 0, q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint i; cin >> i;\n\t\t\tcout << ruq.find(i) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\truq.update(s, t+1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                A[i] = INT_MAX;\n                cout << A[i] << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        A[i] = x[j];\n                        cout << A[i] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, v, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u, long long v) {\n\tif (s <= p || q <= r) { seg[u] = v; return; }\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tlong long w = seg[u]; seg[u] = INF;\n\tupdate(p, q, r, (r + s) / 2, t, u * 2, w);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1, w);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((r <= p && q <= s) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> v; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_ * 2; i++)seg[i] = INF;\n\tfor (int i = 1; i <= v; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1, INF); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, q, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u) {\n\tif (s <= p || q <= r)return;\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tupdate(p, q, r, (r + s) / 2, t, u * 2);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((p <= r && s <= q) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> q; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_; i++)seg[i] = INF;\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint arr[100005 << 2], value[100005], n, q;\n\nvoid updata(int a, int b, int x, int k = 0, int l = 0, int r = (1 << 17)){\n\tif (b <= l || r <= a)return;\n\tif (a <= l && r <= b){\n\t\tarr[k] = max(arr[k], x);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tupdata(a, b, x, k * 2 + 1, l, m);\n\tupdata(a, b, x, k * 2 + 2, m, r);\n}\n\nint query(int x){\n\tx += (1 << 17) - 1;\n\tint res = arr[x];\n\twhile (x){\n\t\tx = (x - 1) / 2;\n\t\tres = max(res, arr[x]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tvalue[0] = 2147483647;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= q; ++i){\n\t\tint ch, a, b;\n\t\tscanf(\"%d\", &ch);\n\t\tif (ch){\n\t\t\tscanf(\"%d\", &a);\n\t\t\tprintf(\"%d\\n\", value[query(a)]);\n\t\t}else{\n\t\t\tscanf(\"%d%d%d\", &a, &b, &value[i]);\n\t\t\t++b;\n\t\t\tupdata(a, b, i);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n \n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n#define TRUE__  \"Yes\"\n#define FALSE__ \"No\"\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define RS resize\n#define CINV(v, N) do {\\\n\tv.RS(N);\\\n\trep(i, N) cin >> v[i];\\\n} while (0);\n#define RCINV(v, N) do {\\\n\tv.RS(N);\\\n\trrep(i, N) cin >> v[i];\\\n} while (0);\n \n#define MOD 1000000007\n\nvoid init();\nvoid solve();\n\nint main()\n{\n    init();\n    solve();\n}\n\n#define INF INT_MAX\n\nstruct LSGT {\n    int n;\n    vector<int> node, lazy;\n    vector<bool> flag;\n    void init(int sz) {\n        n = 1;\n        while (n < sz) n <<= 1;\n        node.RS(2*n-1, INF);\n        lazy.RS(2*n-1, INF);\n        flag.RS(2*n-1, false);\n    }\n    void eval(int k, int l, int r) {\n        if (!flag[k]) return;\n        flag[k] = false;\n        node[k] = lazy[k];\n        if (r - l > 1) {\n            lazy[k*2+1] = lazy[k];\n            lazy[k*2+2] = lazy[k];\n            flag[k*2+1] = true;\n            flag[k*2+2] = true;\n        }\n    }\n    void update(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            flag[k] = true;\n            eval(k, l, r);\n        } else {\n            update(a, b, x, k*2+1, l, (l+r) / 2);\n            update(a, b, x, k*2+2, (l+r) / 2, r);\n        }\n    }\n    int getval(int a, int k = 0, int l = 0, int r = -1) {\n        int b = a + 1;\n        if (r < 0) r = n;\n        eval(k, l, r);\n        if (b <= l || r <= a) return INF;\n        if (r - l > 1) {\n            return min(getval(a, k*2+1, l, (l+r) / 2), getval(a, k*2+2, (l+r) / 2, r));\n        }\n        return node[k];\n    }\n};\n\nint N, Q;\n\nvoid init()\n{\n    cin >> N >> Q;\n}\n\nvoid solve()\n{\n    LSGT seg;\n    seg.init(N);\n    rep(i, Q) {\n        int q;\n        cin >> q;\n        if (q == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        } else {\n            int x;\n            cin >> x;\n            cout << seg.getval(x) << endl;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <math.h>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <assert.h>\nusing ll=long long;\n#define int ll\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define SZ(x) x.size()\n#define fi first\n#define se second\nconst int INF = (1ll<<31)-1;\nusing namespace std;\n\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class T>\ninline bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>\ninline bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  int n,height;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){}\n\n  void init(int n_){\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    dat.assign(2*n,ti);\n    laz.assign(2*n,ei);\n  }\n\n  void build(const vector<T> &v){\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n\n  inline T reflect(int k){\n    return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n  }\n\n  inline void propagate(int k){\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n    dat[k]=reflect(k);\n    laz[k]=ei;\n  }\n\n  inline void thrust(int k){\n    for(int i=height;i;i--) propagate(k>>i);\n  }\n\n  inline void recalc(int k){\n    while(k>>=1)\n      dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n  }\n\n  void update(int a,int b,E x){\n    if(a>=b) return;\n    thrust(a+=n);\n    thrust(b+=n-1);\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  void set_val(int a,T x){\n    thrust(a+=n);\n    dat[a]=x;laz[a]=ei;\n    recalc(a);\n  }\n\n  T query(int a,int b){\n    if(a>=b) return ti;\n    thrust(a+=n);\n    thrust(b+=n-1);\n    T vl=ti,vr=ti;\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,reflect(l++));\n      if(r&1) vr=f(reflect(--r),vr);\n    }\n    return f(vl,vr);\n  }\n\n  template<typename C>\n  int find(int st,C &check,T &acc,int k,int l,int r){\n    if(l+1==r){\n      acc=f(acc,reflect(k));\n      return check(acc)?k-n:-1;\n    }\n    propagate(k);\n    int m=(l+r)>>1;\n    if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n    if(st<=l&&!check(f(acc,dat[k]))){\n      acc=f(acc,dat[k]);\n      return -1;\n    }\n    int vl=find(st,check,acc,(k<<1)|0,l,m);\n    if(~vl) return vl;\n    return find(st,check,acc,(k<<1)|1,m,r);\n  }\n\n  template<typename C>\n  int find(int st,C &check){\n    T acc=ti;\n    return find(st,check,acc,1,0,n);\n  }\n};\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout<<fixed<<setprecision(20);\n\n    int n,q; cin >> n >> q;\n    auto f=[](pi a,pi b){return max(a,b);};\n    pi ti=pi(-1,INF),ei=pi(-1,INF);\n    SegmentTree<pi,pi> seg(f,f,f,ti,ei);\n    vc<pi> v(n,pi(-1,INF));\n    seg.build(v);\n    rep(i,q){\n        int a; cin >> a;\n        if(a==0){\n            int s,t,u; cin >> s >> t >> u;\n            seg.update(s,t+1,pi(i,u));\n        }\n        else {\n            int s; cin >> s;\n            cout << seg.query(s,s+1).second << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N,Q;\nconst int INF=INT_MAX;\nstruct LazySegmentTree{\n  private:\n  int n;\n  vector<int> node,lazy;\n  vector<bool> lazyFlag;\n  \n  public:\n  LazySegmentTree(vector<int> v){\n    int sz=(int)v.size();\n    n=1;  while(n<sz)n*=2;\n    node.resize(2*n-1);\n    lazy.resize(2*n-1,INF);\n    lazyFlag.resize(2*n-1,false);\n    for(int i=0;i<sz;i++)node[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--){node[i]=min(node[2*i+1],node[2*i+2]);}\n  }\n  void lazyEvaluate(int k,int l,int r){\n    if(lazyFlag[k]){\n      node[k]=lazy[k];\n      if(r-l>1){\n        lazy[2*k+1]=lazy[2*k+2]=lazy[k];\n        lazyFlag[2*k+1]=lazyFlag[2*k+2]=true;\n      }\n      lazyFlag[k]=false;\n    }\n  }\n  void update(int a,int b,int x,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    lazyEvaluate(k,l,r);\n    if(b<=l || r<=a)return;\n    if(a<=l && r<=b){\n      lazy[k]=x;\n      lazyFlag[k]=true;\n      lazyEvaluate(k,l,r);\n    }\n    else{\n      update(a,b,x,2*k+1,l,(l+r)/2);\n      update(a,b,x,2*k+2,(l+r)/2,r);\n      node[k]=min(node[2*k+1],node[2*k+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    lazyEvaluate(k,l,r);\n    if(b<=l || r<=a)return INF;\n    if(a<=l && r<=b)return node[k];\n    int vl=find(a,b,2*k+1,l,(l+r)/2);\n    int vr=find(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\nint main(){\n  cin >> N >> Q;\n  LazySegmentTree seg(vector<int>(N,INF));\n  for(int i=0;i<Q;i++){\n    int q; cin >> q;\n    if(q==0){\n      int s,t,x; cin >> s >> t >> x;\n      seg.update(s,t+1,x);\n    }\n    else{\n      int i; cin >> i;\n      cout << seg.find(i,i+1) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n} \n\nconst ll sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<ll> data;\n  vector<ll> bucket;\n  SqrtDecomposition(int n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, (1LL<<31)-1);\n    bucket.assign(K, -1);\n  }\n  void update(int s,int t,ll x) {\n    for(int k=0;k<K;++k){\n        int l=k*sqrtN,r=(k+1)*sqrtN;\n        if (r <= s || t <= l)\n          continue;\n        if (s <= l && r <= t) {\n            bucket[k]=x;\n        } \n        else {\n            for (int i = max(s, l); i < min(t, r); ++i) {\n                if(bucket[k]!=-1){\n                    for(int j=k*sqrtN;j<(k+1)*sqrtN;j++){\n                        data[j]=bucket[k];\n                    }\n                    bucket[k]=-1;\n                }\n                data[i]=x;\n            }\n        }\n    }\n  }\n  // [x, y)\n  int get(int x) {\n    int k=x/sqrtN;\n    if(bucket[k]!=-1){\n        for(int i=k*sqrtN;i<(k+1)*sqrtN;i++){\n            data[i]=bucket[k];\n        }\n        bucket[k]=-1;\n    }\n    return data[x];\n  }\n};\n\n\n\nint main(){\n    ll n,q;cin >> n >> q;\n    SqrtDecomposition sq(n);\n    while(q--){\n        ll a;cin >> a;\n        if(a){\n            ll s;cin >> s;\n            cout << sq.get(s) <<endl;\n        }\n        else{\n            ll s,t,x;cin >> s >> t>>x;t++;\n            sq.update(s,t,x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#define null NULL\n///delta不能初始化为0，因为这里所有的是值要更新为delta，delta=0的时候也要更新\n///此处和RAQ有差别，需要注意一个data取不到的数据，不用下传的标志\n#define maxn -1\n#define inf (1<<31)-1\nusing namespace std;\n/** 区间表示：[p->dl,p->dr]\n *  从0开始计数，[0,n-1]\n *  线段树RSQ\n *\n */\n\nstruct Node\n{\n    long long dl,dr,s,delta;\n    Node *pl,*pr;\n};\nint n,q;\n\nvoid build(Node *&p,int l,int r)\n{\n    p=(Node *)malloc(sizeof(Node));\n    p->dl=l,p->dr=r,p->s=inf,p->delta=maxn;\n    p->pl=null,p->pr=null;\n    int mid=(l+r)/2;\n    if(r>l)\n    {\n        build(p->pl,l,mid);\n        build(p->pr,mid+1,r);\n    }\n}\n\nvoid preorder(Node *p)\n{\n    if(p!=null)\n    {\n        printf(\"%lld %lld %lld %lld\\n\",p->dl,p->dr,p->s,p->delta);\n        preorder(p->pl);\n        preorder(p->pr);\n    }\n}\n///在其他节点更新和查询的过程中都要向下延迟修改\nvoid pushdown(Node *&p,int delta)\n{\n    p->pl->s = p->delta;\n    p->pr->s = p->delta;\n    p->pl->delta = p->delta;\n    p->pr->delta = p->delta;\n    ///注意delta的值，maxn表示不用下传\n    p->delta=maxn;\n}\n///当前区间的更新只更新到某些节点，下边节点的更新需要下次延迟修改\nvoid update(Node *&p,int l,int r,int data)\n{\n    ///[l,r]必然位于[p->dl,p->dr]子区间\n    ///当前节点的所有数据都是正确的！！\n    ///延迟修改-lazy-tag技术\n    ///此处下行的是之前的数据\n    if(p->delta!=maxn && p->dr>p->dl)\n        pushdown(p,p->delta);\n\n    if(p->dl==l && p->dr==r)\n    {\n        p->s=data;\n        p->delta=data;\n        return ;\n    }\n    int mid=(p->dl+p->dr)/2;\n    if(r<=mid)\n        update(p->pl,l,r,data);\n    else if(l>mid)\n        update(p->pr,l,r,data);\n    else\n        update(p->pl,l,mid,data),update(p->pr,mid+1,r,data);\n    p->s=min(p->pl->s,p->pr->s);\n}\n///当前节点的所有数据都是正确的！！\n///即使不正确，在进入到这个之前也被pushdown过了,，所以一定是正确的\nlong long query(Node *&p,int l,int r)\n{\n    ///一个查询区间最终必然被分成若干个小的区间和，最后一个定会完全和区间贴合\n    if(p->delta!=maxn && p->dr>p->dl)\n        pushdown(p,p->delta);\n\n    if(p->dl==l &&p->dr==r)\n        return p->s;\n    int mid=(p->dl+p->dr)/2;\n    ///判断查询区间与当前区间的位置关系\n    //全部位于左侧\n    if(r<=mid)\n        return query(p->pl,l,r);\n    //全部位于右侧\n    else if(l>mid)\n        return query(p->pr,l,r);\n    //两个都有\n    else\n        return min(query(p->pl,l,mid),query(p->pr,mid+1,r));\n}\n\nint main()\n{\n    int i,type,tx,ty,x;\n    Node *tree=null;\n    scanf(\"%d%d\",&n,&q);\n    build(tree,0,n-1);\n    for(i=0;i<q;i++)\n    {\n        scanf(\"%d\",&type);\n        if(type==0)\n        {\n            scanf(\"%d%d%d\",&tx,&ty,&x);\n            update(tree,tx,ty,x);\n        }else\n        {\n            scanf(\"%d\",&tx);\n            long long ans=query(tree,tx,tx);\n            printf(\"%lld\\n\",ans);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\n// ----- LazySegTree -----\n// Referring to the following great materials.\n//  - tsutaj-san's article: https://tsutaj.hatenablog.com/entry/2017/03/30/224339\n//  - drken-san's article: https://drken1215.hatenablog.com/entry/2019/02/19/110200\n//  - tsutaj-san's libary: https://tsutaj.github.io/cpp_library/library/structure/strc_021_dynamic_lazy_segtree.cpp.html\n// Many thanks to them.\n\ntemplate <typename Monoid, typename Action>\nclass SegTree\n{\n  struct SegNode\n  {\n    bool need_update;\n    unique_ptr<SegNode> left, right;\n    Monoid value;\n    Action lazy_value;\n\n    SegNode() {}\n    SegNode(Monoid value, Action lazy_value) : need_update{false}, left{nullptr}, right{nullptr}, value{value}, lazy_value{lazy_value} {}\n  };\n\n  using FuncAction = function<void(Monoid &, Action)>;\n  using FuncMonoid = function<Monoid(Monoid, Monoid)>;\n  using FuncLazy = function<void(Action &, Action)>;\n  using FuncIndex = function<Action(Action, int)>;\n\n  // fields\n  int N;\n  unique_ptr<SegNode> root;\n  // unities\n  Monoid unity_monoid;\n  Action unity_action;\n  // functions\n  FuncAction func_update;\n  FuncMonoid func_combine;\n  FuncLazy func_lazy;\n  FuncIndex func_accumulate;\n\npublic:\n  SegTree() {}\n  SegTree(int n, Monoid unity_monoid, Action unity_action, FuncAction func_update, FuncMonoid func_combine, FuncLazy func_lazy, FuncIndex func_accumulate) : N{1}, root{make_unique<SegNode>(unity_monoid, unity_action)}, unity_monoid(unity_monoid), unity_action(unity_action), func_update(func_update), func_combine(func_combine), func_lazy(func_lazy), func_accumulate(func_accumulate)\n  {\n    while (N < n)\n    {\n      N <<= 1;\n    }\n  }\n\n  void update(int a, int b, Action const &x) { update(root.get(), a, b, x, 0, N); }\n  void update(int a, Action const &x) { update(a, a + 1, x); }\n  Monoid get(int a, int b) { return get(root.get(), a, b, 0, N); }\n  Monoid get(int a) { return get(a, a + 1); }\n  Monoid operator[](size_t i) { return get(static_cast<int>(i)); }\n\nprivate:\n  void node_maker(unique_ptr<SegNode> &pt) const\n  {\n    if (!pt)\n    {\n      pt = make_unique<SegNode>(unity_monoid, unity_action);\n    }\n  }\n\n  void evaluate(SegNode *node, int l, int r)\n  {\n    if (!node->need_update)\n    {\n      return;\n    }\n    func_update(node->value, func_accumulate(node->lazy_value, r - l));\n    if (r - l > 1)\n    {\n      node_maker(node->left);\n      func_lazy(node->left->lazy_value, node->lazy_value);\n      node->left->need_update = true;\n      node_maker(node->right);\n      func_lazy(node->right->lazy_value, node->lazy_value);\n      node->right->need_update = true;\n    }\n    node->lazy_value = unity_action;\n    node->need_update = false;\n  }\n\n  void update(SegNode *node, int a, int b, Action const &x, int l, int r)\n  {\n    evaluate(node, l, r);\n    if (b <= l || r <= a)\n    {\n      return;\n    }\n    if (a <= l && r <= b)\n    {\n      func_lazy(node->lazy_value, x);\n      node->need_update = true;\n      evaluate(node, l, r);\n    }\n    else\n    {\n      auto mid{(l + r) >> 1};\n      node_maker(node->left);\n      update(node->left.get(), a, b, x, l, mid);\n      node_maker(node->right);\n      update(node->right.get(), a, b, x, mid, r);\n      node->value = func_combine(node->left->value, node->right->value);\n    }\n  }\n\n  Monoid get(SegNode *node, int a, int b, int l, int r)\n  {\n    if (b <= l || r <= a)\n    {\n      return unity_monoid;\n    }\n    evaluate(node, l, r);\n    if (a <= l && r <= b)\n    {\n      return node->value;\n    }\n    auto mid{(l + r) >> 1};\n    auto vl{(node->left ? get(node->left.get(), a, b, l, mid) : unity_monoid)};\n    auto vr{(node->right ? get(node->right.get(), a, b, mid, r) : unity_monoid)};\n    return func_combine(vl, vr);\n  }\n};\n\ntemplate <typename Monoid, typename Action>\nSegTree<Monoid, Action> RangeUpdateQuery(int N, Monoid const &unity_monoid, Action const &unity_action)\n{\n  return SegTree<Monoid, Action>{N, unity_monoid, unity_action, [](Monoid &x, Monoid y) { x = y; }, [](Monoid x, Monoid y) { return min(x, y); }, [](Action &x, Action y) { return x = y; }, [](Action x, int y) { return x; }};\n}\n\ntemplate <typename Monoid, typename Action>\nSegTree<Monoid, Action> RangeUpdateQuery(int N)\n{\n  return RangeUpdateQuery<Monoid, Action>(N, numeric_limits<Monoid>::max(), numeric_limits<Action>::max());\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  auto tree{RangeUpdateQuery<int, int>(N)};\n  int Q;\n  cin >> Q;\n  for (auto q{0}; q < Q; ++q)\n  {\n    int t;\n    cin >> t;\n    if (t == 0)\n    {\n      int s, t, x;\n      cin >> s >> t >> x;\n      tree.update(s, t + 1, x);\n    }\n    else\n    {\n      int k;\n      cin >> k;\n      cout << tree[k] << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nstruct Lonoid {\n  int64_t x;\n  Lonoid() {}\n  Lonoid(int64_t x) : x(x) {}\n  static Lonoid ident() { return Lonoid(-1); }\n  static Lonoid multiply(Lonoid f, Lonoid g) {\n    if (f == Lonoid::ident()) return g;\n    return f;\n  }\n  bool operator==(const Lonoid &rhs) const { return x == rhs.x; }\n};\n\ntemplate <typename L>\nstruct SegmentTree {\n  int n;\n  L e;\n  vector<L> laz;\n  SegmentTree(int n0) {\n    n = 1;\n    e = L::ident();\n    while (n < n0) {\n      n *= 2;\n    }\n    laz.resize(n * 2 - 1, e);\n  }\n  void _update(int i, L f) { laz[i] = L::multiply(f, laz[i]); }\n  void update(int ql, int qr, L f) { update(ql, qr, f, 0, 0, n); }\n  void update(int ql, int qr, L f, int i, int il, int ir) {\n    if (qr <= il or ir <= ql) return;\n    if (ql <= il and ir <= qr) {\n      _update(i, f);\n    } else {\n      auto m = (il + ir) / 2, lch = i * 2 + 1, rch = i * 2 + 2;\n      _update(lch, laz[i]);\n      _update(rch, laz[i]);\n      laz[i] = e;\n      update(ql, qr, f, lch, il, m);\n      update(ql, qr, f, rch, m, ir);\n    }\n  }\n  L composite(int i) {\n    auto f = L::ident();\n    for (int k = i + n - 1; k > 0; k = (k - 1) / 2) {\n      f = L::multiply(laz[k], f);\n    }\n    return L::multiply(laz[0], f);\n  }\n};\n\nint main() {\n\n  int n, q;\n  cin >> n >> q;\n  SegmentTree<Lonoid> seg(n);\n  while (q--) {\n    int o;\n    cin >> o;\n    if (o == 0) {\n      int s, t;\n      int64_t x;\n      cin >> s >> t >> x;\n      seg.update(s, t + 1, Lonoid(x));\n    } else {\n      int i;\n      cin >> i;\n      auto ans = seg.composite(i).x;\n      if (ans < 0) ans = (1LL << 31) - 1;\n      cout << ans << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nclass lazy_segment_tree{\n    private:\n        static int calc_size(int n){\n            int m = 1;\n            while(m < n){\n                m *= 2;\n            }\n            return m;\n        }\n\n        void eval(int i, int l, int r){\n            if(lazy[i] != -1){\n                node[i] = lazy[i];\n                if(r - l > 1){\n                    lazy[i * 2 + 1] = lazy[i];\n                    lazy[i * 2 + 2] = lazy[i];\n                }\n                lazy[i] = -1;\n            }\n        }\n\n        void update(int s, int t, int x, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return ;\n            }\n\n            if(s <= l && r <= t){\n                lazy[i] = x;\n                eval(i, l, r);\n                return;\n            }\n\n            int m = l + (r - l) / 2;\n            update(s, t, x, 2 * i + 1, l, m);\n            update(s, t, x, 2 * i + 2, m, r);\n            node[i] = node[2 * i + 1] + node[2 * i + 2];\n        }\n\n        T query(int s, int t, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return 0;\n            }\n\n            if(s <= l && r <= t){\n                return node[i];\n            }\n\n            int m = l + (r - l) / 2;\n            T vl = query(s, t, i * 2 + 1, l, m);\n            T vr = query(s, t, i * 2 + 2, m, r);\n            return vl + vr;\n        }\n\n    public:\n        int n;\n        vector<T> node, lazy;\n        T init;\n        function<T(T, T)> f;\n\n        lazy_segment_tree(int n, T init, function<T(T, T)> f)\n            : n(calc_size(n)), node(calc_size(n) * 2, init) , lazy(calc_size(n) * 2, -1), init(init), f(f) {}\n\n        T query(int s, int t){\n            return query(s, t, 0, 0, n);\n        }\n\n        void update(int s, int t, int x){\n            update(s, t, x, 0, 0, n);\n        }\n};\n\nsigned main(){\n    int n, q;\n    cin >> n >> q;\n\n    lazy_segment_tree<int> lst(n+1, (1LL << 31)-1, [](int a, int b){return a+b;});\n    rep(i, q){\n        int qq;\n        cin >> qq;\n\n        if(qq == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            lst.update(s, t+1, x);\n        }\n\n        if(qq == 1){\n            int i;\n            cin >> i;\n            cout << lst.query(i, i+1) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nstruct RUP{\n  int n;\n  vector<P> dat;\n  RUP(){}\n  RUP(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1);\n    for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=INT_MAX;\n  }\n  int query(int k){\n    k+=n-1;\n    P p=dat[k];\n    while(k>0){\n      k=(k-1)/2;\n      p=max(p,dat[k]);\n    }\n    return p.second;\n  }\n  void update(int a,int b,P p,int k,int l,int r){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b) {\n      dat[k]=p;\n    }else{\n      update(a,b,p,k*2+1,l,(l+r)/2);\n      update(a,b,p,k*2+2,(l+r)/2,r);\n    }\n  }\n  \n  void update(int a,int b,P p){\n    update(a,b,p,0,0,n);\n  }\n};\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  RUP rup(n);\n  for(int i=0;i<q;i++){\n    int f;\n    cin>>f;\n    if(!f){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rup.update(s,t+1,P(i,x));\n    }else{\n      int u;\n      cin>>u;\n      cout<<rup.query(u)<<endl;\n    }\n  }\n  return 0;\n}\n\n/*\nverified on 2017/02/24\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<climits>\n#include<math.h>\nusing namespace std;\n\nint min(const int& a, const int& b){\n    return a < b? a : b;\n}\nint updateUtil(vector<int>& tree, vector<int>& lazy, const int& L, const int& R, const int& v, const int& k, const int& l, const int& r){\n    if(k > tree.size() || l > r) return INT_MAX;\n    if(lazy[k] > 0){\n        tree[k] = lazy[k];\n        if(l < r){\n            lazy[2*k+1] = lazy[k];\n            lazy[2*k+2] = lazy[k];\n        }\n        lazy[k] = 0;\n    }\n    if(l > R || r < L) return tree[k];\n    if(l >= L && r <= R){\n        tree[k] = v;\n        if(l < r){\n            lazy[2*k+1] = v;\n            lazy[2*k+2] = v;\n        }\n    }\n    else{\n        int mid = l+(r-l)/2;\n        tree[k] = min(updateUtil(tree, lazy, L, R, v, 2*k+1, l, mid), updateUtil(tree, lazy, L, R, v, 2*k+2, mid+1, r)); \n    }\n    return tree[k];\n}\n\nvoid update(vector<int>& tree, vector<int>& lazy, const int& n, const int& L, const int& R, const int& v){\n    updateUtil(tree, lazy, L, R, v, 0, 0, n-1);\n}\n\nint findUtil(vector<int>& tree, vector<int>& lazy, const int& L, const int& R, const int& k, const int& l, const int& r){\n    if(k > tree.size() || l > r) return INT_MAX;\n    if(lazy[k] > 0){\n        tree[k] = lazy[k];\n        if(l < r){\n            lazy[2*k+1] = lazy[k];\n            lazy[2*k+2] = lazy[k];\n        }\n        lazy[k] = 0;\n    }\n    if(l > R || r < L) return INT_MAX;\n    if(l >= L && r <= R) return tree[k];\n    int mid = l+(r-l)/2;\n    return min(findUtil(tree, lazy, L, R, 2*k+1, l, mid), findUtil(tree, lazy, L, R, 2*k+2, mid+1, r));\n}\n\nint find(vector<int>& tree, vector<int>& lazy, const int& n, const int& L, const int& R){\n    return findUtil(tree, lazy, L, R, 0, 0, n-1);\n}\nint main(){\n    int n, q, com, s, t, x;\n    scanf(\"%d %d\", &n, &q);\n    int h = (int)ceil(log2(n));\n    int max_size = 2*(int)pow(2, h)-1;\n    vector<int> tree(max_size, INT_MAX);\n    vector<int> lazy(max_size, 0);\n    for(int i = 0; i < q; i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update(tree, lazy, n, s, t, x);\n        }\n        else if(com == 1){\n            scanf(\"%d\", &s);\n            printf(\"%d\\n\", find(tree, lazy, n, s, s));\n        }\n        else printf(\"undefined com\\n\");\n    }    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint bit[100001], n, q;\nvoid add(int k, int x) {\n\twhile (k <= n) {\n\t\tbit[k] += x;\n\t\tk += k&-k;\n\t}\n}\nint sum(int k) {\n\tint res = 0;\n\twhile (k) {\n\t\tres += bit[k];\n\t\tk -= k&-k;\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tadd(1, INT_MAX);\n\trep(i, q) {\n\t\tint t; scanf(\"%d\", &t);\n\t\tif (t == 0) {\n\t\t\tint a, b, x; scanf(\"%d%d%d\", &a, &b, &x); a++; b++;\n\t\t\tint s = x - sum(a);\n\t\t\tadd(a, s); add(b + 1, -s);\n\t\t}\n\t\telse {\n\t\t\tint a; scanf(\"%d\", &a); a++;\n\t\t\tprintf(\"%d\\n\", sum(a));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(vector<T>v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nmain()\n{\n\tint n,q;cin>>n>>q;\n\tlazysegtree<int>S(n,2147483647,[](int a,int b){return a;},[](int a,int b){return b;},[](int a,int b,unsigned int c){return b;});\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint c;cin>>c;\n\t\tif(c)\n\t\t{\n\t\t\tint s;cin>>s;\n\t\t\tS.eval(s+S.n-1,s,s+1);\n\t\t\tcout<<S.dat[s+S.n-1]<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s,t,x;cin>>s>>t>>x;\n\t\t\tS.update(s,t+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n#define int long long\n\n/*\n//1点変更クエリ\n//Range Minimum query\n//Range Maximum query\n//Range Sum Query\nclass SqrtDecomposition{\nprivate:\n    int n; //元の配列のサイズ\n    int sz; //1つのバケットが担当する区間の長さ\n    int num; //バケットの個数\n    vector<int> v,bucket;\n    int init;\n\n    int combine(int a, int b){\n        //return min(a,b);\n        //return max(a,b);\n        return a+b;\n    }\n\n    int idx(int i){\n        return i/sz;\n    }\n    void build(){\n        sz = sqrt(n);\n        num = (n + sz-1)/sz;\n        bucket = vector<int>(num,init);\n        //bucketの更新\n        for(int i = 0; i < n; i++){\n            bucket[idx(i)] = combine(bucket[idx(i)], v[i]);\n        }\n    }\n    void recalc(int id){\n        bucket[id] = init;\n        for(int i = id*sz; i < min((id+1)*sz,n); i++){\n            bucket[id] = combine(bucket[id], v[i]);\n        }\n    }\npublic:\n    SqrtDecomposition(){\n    }\n    SqrtDecomposition(int size, int initial){\n        n = size;\n        init = initial;\n        v = vector<int> (n,init);\n        build();\n    }\n    SqrtDecomposition(vector<int> in, int initial){\n        n = in.size();\n        init = initial;\n        v = in;\n        build();\n    }\n    void update(int ind, int x){\n        //v[ind]をxに変更する\n        v[ind] = x;\n        recalc(idx(ind));\n    }\n    void add(int ind, int x){\n        //v[ind]にxを足す\n        v[ind] += x;\n        recalc(idx(ind));\n    }\n    int query_min(int l, int r){\n        //[l,r)の最小値を求める\n        int ret = init;\n        int lid = idx(l);\n        int rid = idx(r);\n        if(lid == rid){\n            for(int i = l; i < r; i++){\n                ret = min(ret, v[i]);\n            }\n            return ret;\n        }\n        for(int i = l; i < (lid+1)*sz; i++){\n            ret = min(ret, v[i]);\n        }\n        for(int i = lid+1; i < rid; i++){\n            ret = min(ret, bucket[i]);\n        }\n        for(int i = rid*sz; i < r; i++){\n            ret = min(ret, v[i]);\n        }\n        return ret;\n    }\n    int query_sum(int l, int r){\n        //[l,r)の総和を求める\n        int ret = init;\n        int lid = idx(l);\n        int rid = idx(r);\n        if(lid == rid){\n            for(int i = l; i < r; i++){\n                ret += v[i];\n            }\n            return ret;\n        }\n        for(int i = l; i < (lid+1)*sz; i++){\n            ret += v[i];\n        }\n        for(int i = lid+1; i < rid; i++){\n            ret += bucket[i];\n        }\n        for(int i = rid*sz; i < r; i++){\n            ret += v[i];\n        }\n        return ret;\n    }\n    void show(){\n        cout << endl;\n        cout << \"n = \" << n;\n        cout << \", sz = \" << sz;\n        cout << \", num = \" << num;\n        cout << endl;\n        cout << \"v:\";\n        for(int i = 0; i < n; i++)cout << \" \" << v[i];cout << endl;\n        cout << \"bucket:\";\n        for(int i = 0; i < num; i++)cout << \" \" << bucket[i];cout << endl;\n        cout << endl;\n    }\n};\n*/\n\n//区間変更1点参照\nclass SqrtDecomposition{\nprivate:\n    int n; //元の配列のサイズ\n    int sz; //1つのバケットが担当する区間の長さ\n    int num; //バケットの個数\n    vector<int> v,bucket;\n    vector<bool> change;\n    int init;\n\n    int combine(int a, int b){\n        //return min(a,b);//min\n        //return max(a,b);//max\n        //return a+b;//sum\n        return b;//update\n    }\n\n    int idx(int i){\n        return i/sz;\n    }\n    void build(){\n        sz = sqrt(n);\n        num = (n + sz-1)/sz;\n        bucket = vector<int>(num,init);\n        change = vector<bool>(num,0);\n    }\n    void recalc(int id){\n        bucket[id] = init;\n        for(int i = id*sz; i < min((id+1)*sz,n); i++){\n            bucket[id] = combine(bucket[id], v[i]);\n        }\n    }\npublic:\n    SqrtDecomposition(){\n    }\n    SqrtDecomposition(int size, int initial){\n        n = size;\n        init = initial;\n        v = vector<int> (n,init);\n        build();\n    }\n    SqrtDecomposition(vector<int> in, int initial){\n        n = in.size();\n        init = initial;\n        v = in;\n        build();\n    }\n    void update_range(int l, int r, int x){\n        //[l,r)にxを適用する\n        int lid = idx(l);\n        int rid = idx(r);\n        //cout << \"!\" << lid << \" \" << rid << endl;\n        if(lid == rid){\n            for(int i = lid*sz; i < min((lid+1)*sz,n); i++){\n                if(change[lid])v[i] = combine(v[i], bucket[lid]);\n                if(l <= i && i < r)v[i] = combine(v[i], x);\n            }\n            change[lid] = false;\n        }else{\n            for(int i = lid*sz; i < (lid+1)*sz; i++){\n                if(change[lid])v[i] = combine(v[i], bucket[lid]);\n                if(l <= i)v[i] = combine(v[i], x);\n            }\n            change[lid] = false;\n            for(int i = lid+1; i < rid; i++){\n                change[i] = true;\n                bucket[i] = combine(bucket[i], x);\n            }\n            for(int i = rid*sz; i < min((rid+1)*sz,n); i++){\n                if(change[rid])v[i] = combine(v[i], bucket[rid]);\n                if(i < r)v[i] = combine(v[i], x);\n            }\n            if(rid < num)change[rid] = false;\n        }\n    }\n    /*\n    void add(int ind, int x){\n        //v[ind]にxを足す\n        v[ind] += x;\n        recalc(idx(ind));\n    }\n    int query_min(int l, int r){\n        //[l,r)の最小値を求める\n        int ret = init;\n        int lid = idx(l);\n        int rid = idx(r);\n        if(lid == rid){\n            for(int i = l; i < r; i++){\n                ret = min(ret, v[i]);\n            }\n            return ret;\n        }\n        for(int i = l; i < (lid+1)*sz; i++){\n            ret = min(ret, v[i]);\n        }\n        for(int i = lid+1; i < rid; i++){\n            ret = min(ret, bucket[i]);\n        }\n        for(int i = rid*sz; i < r; i++){\n            ret = min(ret, v[i]);\n        }\n        return ret;\n    }*/\n    int query_find(int ind){\n        //v[ind]を求める\n        int id = idx(ind);\n        if(change[id]){\n            return combine(v[ind], bucket[id]);\n        }\n        return v[ind];\n    }\n    void show(){\n        cout << endl;\n        cout << \"n = \" << n;\n        cout << \", sz = \" << sz;\n        cout << \", num = \" << num;\n        cout << endl;\n        cout << \"v:\";\n        for(int i = 0; i < n; i++)cout << \" \" << v[i];cout << endl;\n        cout << \"bucket:\";\n        for(int i = 0; i < num; i++)cout << \" \" << bucket[i];cout << endl;\n        cout << \"change:\";\n        for(int i = 0; i < num; i++)cout << \" \" << change[i];cout << endl;\n        cout << endl;\n    }\n};\n\n/*\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4398822#1\n//Range Minimum Query\nvoid dsl2a(){\n    int n,q;\n    cin >> n >> q;\n    long init = (1LL<<31)-1;\n    vector<int> in(n,init);\n    SqrtDecomposition sd(in,init);\n    while(q--){\n        int com,x,y;\n        cin >> com >> x >> y;\n        if(com == 0){//a_xをyに変更する\n            sd.update(x,y);\n        }else{//a_x ~ a_yの最小値を出力する\n            //sd.show();\n            cout << sd.query_min(x,y+1) << endl;\n        }\n    }\n}\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4398962#1\n//Range Sum Query\nvoid dsl2b(){\n    int n,q;\n    cin >> n >> q;\n    long init = 0;\n    vector<int> in(n,init);\n    SqrtDecomposition sd(in,init);\n    while(q--){\n        int com,x,y;\n        cin >> com >> x >> y;\n        if(com == 0){//a_xにyを加える\n            x--;\n            sd.add(x,y);\n        }else{//a_x ~ a_yの総和を出力する\n            //sd.show();\n            x--,y--;\n            cout << sd.query_sum(x,y+1) << endl;\n        }\n    }\n}*/\n//Range Update Query\nvoid dsl2d(){\n    int n,q;\n    cin >> n >> q;\n    long init = (1LL<<31)-1;\n    vector<int> in(n,init);\n    SqrtDecomposition sd(in,init);\n    while(q--){\n        int com;\n        cin >> com;\n        if(com == 0){//a_s ~ a_tをxに変更する\n            int s,t,x;\n            cin >> s >> t >> x;\n            sd.update_range(s,t+1,x);\n            //sd.show();\n        }else{//a_iの値を出力する\n            //sd.show();\n            int i;\n            cin >> i;\n            cout << sd.query_find(i) << endl;\n        }\n    }\n}\n\nsigned main(){\n    dsl2d();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<int> tp(Q), s(Q), t(Q), x(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tscanf(\"%d%d\", &tp[i], &s[i]);\n\t\tif (tp[i] == 0) scanf(\"%d%d\", &t[i], &x[i]), t[i]++;\n\t}\n\tvector<int> d(N, 2147483647);\n\tint B = sqrt(Q);\n\tfor (int i = 0; i < B; i++) {\n\t\tint l = 1LL * i * Q / B, r = 1LL * (i + 1) * Q / B;\n\t\tfor (int j = l; j < r; j++) {\n\t\t\tif (tp[j] == 1) {\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int k = j - 1; k >= l; k--) {\n\t\t\t\t\tif (tp[k] == 0 && s[k] <= s[j] && s[j] < t[k]) {\n\t\t\t\t\t\tprintf(\"%d\\n\", x[k]); flag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) printf(\"%d\\n\", d[s[j]]);\n\t\t\t}\n\t\t}\n\t\tvector<int> cp = { 0, N };\n\t\tfor (int j = l; j < r; j++) {\n\t\t\tcp.push_back(s[j]);\n\t\t\tcp.push_back(t[j]);\n\t\t}\n\t\tsort(cp.begin(), cp.end());\n\t\tcp.erase(unique(cp.begin(), cp.end()), cp.end());\n\t\tvector<int> f(cp.size() - 1, -1);\n\t\tfor (int j = l; j < r; j++) {\n\t\t\tint pl = lower_bound(cp.begin(), cp.end(), s[j]) - cp.begin();\n\t\t\tint pr = lower_bound(cp.begin(), cp.end(), t[i]) - cp.begin();\n\t\t\tfor (int k = pl; k < pr; k++) f[k] = x[j];\n\t\t}\n\t\tfor (int j = 0; j < cp.size() - 1; j++) {\n\t\t\tif (f[j] != -1) {\n\t\t\t\tfor (int k = cp[j]; k < cp[j + 1]; k++) d[k] = f[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int MOD = (int)(1e9) + 7;\nconst int INF = (1ll << 31) - 1;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nstruct Segtree {\n\tint n;\n\tvector<int>d;\n\tSegtree(int m) {\n\t\tfor (n = 1; n < m; n <<= 1);\n\t\td.assign(2 * n, INF);\n\t}\n\tvoid update(int a, int b, int x = -1, int k = 1, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tif (x >= 0)d[k] = x;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (d[k] != INF) {\n\t\t\t\td[2 * k] = d[2 * k + 1] = d[k];\n\t\t\t\td[k] = INF;\n\t\t\t}\n\t\t\tupdate(a, b, x, 2 * k, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) / 2, r);\n\t\t}\n\t}\n\tint find(int i) {\n\t\tupdate(i, i + 1);\n\t\treturn d[n + i];\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, Q; cin >> N >> Q;\n\tSegtree seg(N);\n\trep(i, 0, Q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint x; cin >> x;\n\t\t\tcout << seg.find(x) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tseg.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF 2147483647\n\nint tree[1000000];\n\nvoid Update(int s, int t, int m, int left = 0, int right = (1 << 17), int key = 0){\n    if(t < left || right <= s) return;\n    if(s <= left && right - 1 <= t){ tree[key] = max(tree[key], m); return; }\n    Update(s, t, m, left, (left + right) / 2, 2 * key + 1);\n    Update(s, t, m, (left + right) / 2, right, 2 * key + 2);\n}\n\nint Query_find(int i){\n    i += (1 << 17) - 1;\n    int m = tree[i];\n    while(i){\n        i = (i - 1) / 2;\n        m = max(tree[i], m);\n    };\n    return m;\n}\n\n\n\nint main(){\n\n  int n, q, x[1000000],i;\n  for(i=0; i<1000000; i++) {tree[i]=0; x[i]=INF;}\n\n  cin >> n >> q;\n  int c, s, t, value, m=1;\n  for (int j=0; j<q; j++) {\n    cin >> c;\n    if(c){\n      cin >> i;\n      cout << x[Query_find(i)] << endl;\n    }else{\n      cin >> s >> t >> value;\n      x[m] = value;\n      Update(s, t, m);\n      m++;\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <map>\n#include <utility>\nusing namespace std;\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = cmb_f(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = lzy_f(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lzy_f(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = cmb_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\n\n// Verified on Apr 27, 2019\nvoid DSL_2_D() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, INT_MAX, INT_MAX,\n                                  [](int a, int b) { return b;         },  // upd\n                                  [](int a, int b) { return min(a, b); },  // cmb\n                                  [](int a, int b) { return b;         },  // lzy\n                                  [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\nvoid DSL_2_D_pair() {\n    int N, Q; cin >> N >> Q;\n    using Pair = pair<int, int>;\n    LazySegmentTree<int, Pair> seg(N, INT_MAX, make_pair(0, 0),\n                                   [](int x, Pair p) {\n                                       if(p.second == 0) return x;\n                                       return p.first;\n                                   },\n                                   [](int a, int b) { return min(a, b); },\n                                   [](Pair a, Pair b) {\n                                       return b.second ? b : a;\n                                   },\n                                   [](Pair a, int x) { return a; },\n                                   vector<int>(N, INT_MAX));\n\n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int q; cin >> q;\n        if(q == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            s -= indexed, t -= indexed, t++;\n            seg.update(s, t, make_pair(x, 1));\n        }\n        if(q == 1) {\n            int x; cin >> x; x -= indexed;\n            cout << seg.query(x, x+1) << endl;\n        }\n    }\n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_E() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, 0, 0,\n                                  [](int a, int b) { return a + b; },  // upd\n                                  [](int a, int b) { return a + b; },  // cmb\n                                  [](int a, int b) { return a + b; },  // lzy\n                                  [](int a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_F() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, INT_MAX, 0,\n                                  [](int a, int b) { return b;         },  // upd\n                                  [](int a, int b) { return min(a, b); },  // cmb\n                                  [](int a, int b) { return b;         },  // lzy\n                                  [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_G() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                  [](ll a, ll  b) { return a + b; },  // upd\n                                  [](ll a, ll  b) { return a + b; },  // cmb\n                                  [](ll a, ll  b) { return a + b; },  // lzy\n                                  [](ll a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, INT_MAX, 0,\n                                [](ll a, ll  b) { return a + b;     },  // upd\n                                [](ll a, ll  b) { return min(a, b); },  // cmb\n                                [](ll a, ll  b) { return a + b;     },  // lzy\n                                [](ll a, int x) { return a;         },  // acc\n                                vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                [](ll a, ll  b) { return b;     },  // upd\n                                [](ll a, ll  b) { return a + b; },  // cmb\n                                [](ll a, ll  b) { return b;     },  // lzy\n                                [](ll a, int x) { return a * x; },  // acc\n                                vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on May 31, 2019\nvoid ABC128_E() {\n    int N, Q; cin >> N >> Q;\n\n    map<int, int> cmp; int id = 0;\n    vector<int> s(N), t(N), x(N), p(Q);\n    for(int i=0; i<N; i++) {\n        cin >> s[i] >> t[i] >> x[i];\n        s[i] = max(0, s[i] - x[i]);\n        t[i] = max(0, t[i] - x[i]);\n        cmp[ s[i] ]++; cmp[ t[i] ]++; cmp[ t[i] - 1 ]++;\n    }\n    for(int i=0; i<Q; i++) {\n        cin >> p[i];\n        cmp[ p[i] ]++;\n    }\n    for(auto &e : cmp) e.second = id++;\n    for(int i=0; i<N; i++) {\n        s[i] = cmp[ s[i] ], t[i] = cmp[ t[i] ];\n    }\n    for(int i=0; i<Q; i++) {\n        p[i] = cmp[ p[i] ];\n    }\n    \n    LazySegmentTree<int, int> seg(id, INT_MAX, INT_MAX,\n                                  [](int a, int b) { return min(a, b); },\n                                  [](int a, int b) { return min(a, b); },\n                                  [](int a, int b) { return min(a, b); },\n                                  [](int a, int x) { return a; });\n    \n    for(int i=0; i<N; i++) {\n        seg.update(s[i], t[i], x[i]);\n    }\n    for(int i=0; i<Q; i++) {\n        int res = seg.query(p[i], p[i]+1);\n        if(res == INT_MAX) cout << -1 << endl;\n        else cout << res << endl;\n    }\n}\n\n/*\nvoid yuki_749() {\n    int N, Q; cin >> N >> Q;\n\n    \n    \n}\n*/\n\nint main() {\n    // DSL_2_D();\n    DSL_2_D_pair();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    // DSL_2_I();\n    // ABC128_E();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nclass RangeSeg{\n\tint n;\n\tvector<ll> data, lazy;\npublic:\n\tRangeSeg(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n <<= 1;\n\t\tREP(i, n*2-1){\n\t\t\tdata.push_back((1<<31)-1);\n\t\t\tlazy.push_back((1<<31)-1);\n\t\t}\n\t}\n\n\tvoid push(int l, int r, int k){\n\t\tif(lazy[k] != (1<<31)-1){\n\t\t\tdata[k] = lazy[k];\n\t\t\tif(r - l > 1){\n\t\t\t\tlazy[k*2+1] = lazy[k];\n\t\t\t\tlazy[k*2+2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = (1<<31)-1;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int l, int r, int k, int x){\n\t\tpush(k, l, r);\n\t\tif(s <= l && r <= t){\n\t\t\tlazy[k] = x;\n\t\t\tpush(l, r, k);\n\t\t}else if(l < t && s < r){\n\t\t\tupdate(s, t, (l+r)/2, r, k*2+2, x);\n\t\t\tupdate(s, t, l, (l+r)/2, k*2+1, x);\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tupdate(s, t, 0, n, 0, x);\n\t}\n\t\n\tvoid show(){\n\t\tint i = 0;\n\t\tint en = 1;\n\t\twhile(i < n*2-1){\n\t\t\tcout << \"(\" << data[i] << \", \" << lazy[i] << \") \";\n\t\t\tif(i == en*2-2){\n\t\t\t\tcout << endl;\n\t\t\t\ten *= 2;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tll find(int l, int r, int k, int i){\n\t\tpush(l, r, k);\n\t\tif(r-l == 1){\n\t\t\treturn data[k];\n\t\t}\n\t\tif(l <= i && i <= r){\n\t\t\tif((l+r)/2 <= i){\n\t\t\t\treturn find((l+r)/2, r, k*2+2, i);\n\t\t\t}else{\n\t\t\t\treturn find(l, (l+r)/2, k*2+1, i);\n\t\t\t}\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tll find(int i){\n\t\treturn find(0, n, 0, i);\n\t}\t\n};\n\nint main(void){\n\tint n, q;\n\tcin >> n >> q;\n\tRangeSeg rs(n);\n\tREP(i, q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(com == 0){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\trs.update(s, t+1, x);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << rs.find(x) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\n\n#define NUM 2147483647\n\nint N = 1;\nint* value;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\n//update(s, t, value, 0, 0, N-1)でas,as+1,...,atの値をxに変更する\nvoid update(int update_left,int update_right,int new_value,int node_id,int node_left,int node_right){\n\tif(update_right < node_left || update_left > node_right)return;\n\telse if(update_left <= node_left && update_right >= node_right){\n\t\tvalue[node_id] = new_value;\n\t}else{\n\t\tif(value[node_id] >= 0){\n\t\t\tvalue[2*node_id+1] = value[node_id];\n\t\t\tvalue[2*node_id+2] = value[node_id];\n\t\t\tvalue[node_id] = -1;\n\t\t}\n\t\tupdate(update_left,update_right,new_value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left,update_right,new_value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\n//query(loc, loc, 0, 0, N-1)でalocの値を出す(sumもあるかもしれないが要検討)\nint query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\tif(search_right < node_left || search_left > node_right){\n\t\treturn -1;\n\t}else if(node_left <= search_left && node_right >= search_right && value[node_id] >= 0){\n\t\treturn value[node_id];\n\t}else{\n\t\tint left = query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tint right = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn max(left,right);\n\t}\n}\n\n//問題は0-indexedで渡されている\nint main(){\n\tint n, q; cin >> n >> q;\n\tinit(n);\n\n\tvalue = new int[270000];\n\n\tfor(int i = 0; i <= 2*N-2; i++) value[i] = NUM;\n\n\tint command, left, right, value, loc;\n\n\tfor(int i = 0; i < q; i++){\n\t\tcin >> command;\n\n\t\tif(command == 0){\n\t\t\tcin >> left >> right >> value;\n\t\t\tupdate(left,right,value,0,0,N-1);\n\t\t}else{\n\t\t\tcin >> loc;\n\t\t\tcout << query(loc, loc, 0, 0, N-1) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RU {\n\tusing t1 = int;\n\tusing t2 = int;\n\tstatic t2 id2() { return -1; }\n\tstatic t1 op2(const t1& l, const t2& r) { return r == id2() ? l : r; }\n\tstatic t2 op3(const t2& l, const t2& r) { return r == id2() ? l : r; }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tvector<T1> data;\n\tvector<T2> lazy;\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tif (node < n) {\n\t\t\tlazy[node << 1] = M::op3(lazy[node << 1], lazy[node]);\n\t\t\tlazy[(node << 1) + 1] = M::op3(lazy[(node << 1) + 1], lazy[node]);\n\t\t}\n\t\tlazy[node] = M::id2();\n\t}\npublic:\n\tlazy_segment_tree(int n_, T1 v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n, v1), lazy(n << 1, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(data_), lazy(n << 1, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\tT1 find(int p) {\n\t\tT1 res = data[p]; p += n;\n\t\twhile (p) res = M::op2(res, lazy[p]), p >>= 1;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tlazy_segment_tree<RU> lst(n, INT_MAX);\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tlst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tprintf(\"%d\\n\", lst.find(p));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto x:v)cerr<<x<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define EPS 1e-9\ntypedef long long ll;\n\nstruct RangeUpdateQuery{\n  vector<long long> data;\n  long long sq;\n  vector<long long> lazy;\n  void boot(long long n){\n    data.resize(n);\n    sq = round(sqrt((double)n));\n    lazy.resize(n/sq+1);\n    for(long long i = 0;i < lazy.size();i++)lazy[i] = -1000000000000000007;\n  }\n  void update(long long s,long long t,long long num){\n    if(lazy[s/sq] != -1000000000000000007){\n      for(long long i = s/sq*sq;i < min((s/sq+1)*sq,(long long)data.size());i++)data[i] = lazy[s/sq];\n      lazy[s/sq] = -1000000000000000007;\n    }\n    if(lazy[t/sq] != -1000000000000000007){\n      for(long long i = t/sq*sq;i < min((t/sq+1)*sq,(long long)data.size());i++)data[i] = lazy[t/sq];\n      lazy[t/sq] = -1000000000000000007;\n    }\n    while(s%sq && s<=t){\n      data[s] = num;\n      s++;\n    }\n    while((t-s+1)/sq){\n      lazy[s/sq] = num;\n      s += sq;\n    }\n    while(s <= t){\n      data[s] = num;\n      s++;\n    }\n    return;\n  }\n  long long find(long long s){\n    if(lazy[s/sq] != -1000000000000000007){\n      for(long long i = s/sq*sq;i < min((s/sq+1)*sq,(long long)data.size());i++)data[i] = lazy[s/sq];\n      lazy[s/sq] = -1000000000000000007;\n    }\n    return data[s];\n  }\n};\n\nsigned main(){\n  RangeUpdateQuery RUQ;\n  int n,q;\n  cin >> n >> q;\n  int query,s,t,x;\n  RUQ.boot(n);\n  RUQ.update(0,n-1,(ll)2147483647);\n  vector<long long> ans;\n  FOR(i,0,q){\n    cin >> query;\n    if(query == 0){\n      cin >> s >> t >> x;\n      RUQ.update(s,t,x);\n    }\n    else{\n      cin >> s;\n      ans.pb(RUQ.find(s));\n    }\n  }\n  for(auto x:ans)cout << x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n\nclass SegmentTree {\n\tstd::vector<std::vector<int>> _array;\n\tstd::vector<int> _size;\n\tstatic constexpr int undefined = -1;\n\tvoid make_upper_undefined(int pos, int depth = 1) {\n\t\tif (depth == _array.size()) return;\n\t\tmake_upper_undefined(pos / 2, depth + 1);\n\t\tswitch (_array[depth][pos]) {\n\t\tcase undefined: return;\n\t\tdefault:\n\t\t\t_array[depth - 1][pos * 2] = _array[depth][pos];\n\t\t\tif (pos * 2 + 1 < _array[depth - 1].size()) _array[depth - 1][pos * 2 + 1] = _array[depth][pos];\n\t\t\t_array[depth][pos] = undefined;\n\t\t}\n\t}\npublic:\n\tSegmentTree(int size) :_array{}, _size{} {\n\t\tfor (auto i = size; i > 1; i = (i + 1) / 2) {\n\t\t\t_size.push_back(i);\n\t\t}\n\t\t_size.push_back(1);\n\t\t_array = std::vector<std::vector<int>>(_size.size());\n\t\tfor (auto i = 0; i < _array.size(); ++i) {\n\t\t\t_array[i] = std::vector<int>(_size[i], undefined);\n\t\t}\n\t\t_array[_array.size() - 1][0] = 2147483647;\n\t}\n\tvoid update(int from, int to, int new_value) {\n\t\tauto depth = 0;\n\t\twhile (from < to) {\n\t\t\tif (from % 2 == 1) {\n\t\t\t\tmake_upper_undefined(from / 2, depth + 1);\n\t\t\t\t_array[depth][from] = new_value;\n\t\t\t\t++from;\n\t\t\t}\n\t\t\tif (to % 2 == 0) {\n\t\t\t\tmake_upper_undefined(to / 2, depth + 1);\n\t\t\t\t_array[depth][to] = new_value;\n\t\t\t\t--to;\n\t\t\t}\n\t\t\tfrom >>= 1; to >>= 1; ++depth;\n\t\t}\n\t\tif (from == to) {\n\t\t\tmake_upper_undefined(from / 2, depth + 1);\n\t\t\t_array[depth][from] = new_value;\n\t\t}\n\t}\n\tint find(int pos) const {\n\t\tfor (auto i = _array.size() - 1; i >= 0; --i) {\n\t\t\tswitch (_array[i][pos >> i]) {\n\t\t\tcase undefined: continue;\n\t\t\tdefault: return _array[i][pos >> i];\n\t\t\t}\n\t\t}\n\t}\n};\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tauto stree = SegmentTree(n);\n\tint query, s, t, x, i;\n\tfor (auto count = 0; count < q; ++count) {\n\t\tstd::cin >> query;\n\t\tswitch (query) {\n\t\tcase 0:\n\t\t\tstd::cin >> s >> t >> x;\n\t\t\tstree.update(s, t, x);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cin >> i;\n\t\t\tstd::cout << stree.find(i) << std::endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        cout << x[j] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint A[300000],B[300000];\nint flag[300000];\nint n,q;\nvoid evaluate(int k){\n  if(flag[k]==0) return ;\n  A[k*2+1]=A[k*2+2]=B[k];\n  B[k*2+1]=B[k*2+2]=B[k];\n  flag[k*2+1]=flag[k*2+2]=1;\n  flag[k]=0;\n  return ;\n}\nint update(int s,int t,int x,int k,int l,int r){\n  if(s>=r || l>=t) return A[k];\n  if(s<=l && r<=t){\n    A[k]=x;\n    B[k]=x;\n    flag[k]=1;\n    return A[k];\n  }\n  evaluate(k);\n  int al=update(s,t,x,k*2+1,l,(l+r)/2);\n  int ar=update(s,t,x,k*2+2,(l+r)/2,r);\n\n  return A[k]=min(al,ar);\n}\nint find(int i,int k){\n  if(flag[k]) A[i]=B[k];\n  if(k==0) return A[i];\n  return find(i,(k-1)/2);\n}\nint main(){\n  int com,s,t,x,k;\n  for(int i=0;i<300000;i++) A[i]=B[i]=INT_MAX;\n  cin>>n>>q;\n  int ra=1;\n  while(ra<=n) ra*=2;\n  n=ra;\n  for(int i=0;i<q;i++){\n    cin>>com;\n    if(com==0){\n      cin>>s>>t>>x;\n      update(s,t+1,x,0,0,n);\n    }\n    else if(com==1){\n      cin>>k;\n      cout<<find(k+n-1,k+n-1)<<endl;\n    }\n  }\n  //for(int i=0;i<10;i++) cout<<A[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = (1ll << 31) - 1;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T>\nstruct RangeUpdateQuery {\n\tint n;\n\tvector<T>d;\n\tRangeUpdateQuery(int m) {\n\t\tfor (n = 1; n < m; n <<= 1);\n\t\td.assign(2 * n, INF);\n\t}\n\tint get(int i) {\n\t\tupdate(i, i + 1, -1);\n\t\treturn d[n + i];\n\t}\n\tvoid update(int a, int b, T x) {\n\t\treturn update(a, b, x, 1, 0, n);\n\t}\n\tvoid update(int a, int b, T x, int k, int l, int r) {\n\t\t// [a,b) [l,r)\n\t\tif (r <= a || b <= l)return;\n\t\telse if (a <= l&&r <= b) {\n\t\t\tif (x >= 0)d[k] = x;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (d[k] != INF)d[2 * k] = d[2 * k + 1] = d[k], d[k] = INF;\n\t\t\tupdate(a, b, x, 2 * k, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) / 2, r);\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tRangeUpdateQuery<int> ruq(n);\n\trep(i, 0, q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint i; cin >> i;\n\t\t\tcout << ruq.get(i) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  ll lazy[nsq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t  lazy[t/sq] = -1;\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull INF = ULLONG_MAX/3;\n\nvoid latentEvaluation(int ss, vector<ull> &xList, vector<ull> &sxList){\n    int sn = sxList.size();\n    if(sxList[ss] != INF){\n        for(int i=0;i<sn;i++){\n            xList[sn*ss+i] = sxList[ss];\n        }\n        sxList[ss] = INF;\n    }\n}\n\nvoid update(int s, int t, ull x, vector<ull> &xList, vector<ull> &sxList){\n    int nn = xList.size();\n    int sn = sxList.size();\n    int ss = s/sn;\n    int tt = t/sn;\n    if(ss == tt){\n        latentEvaluation(ss, xList, sxList);\n        for (int i=0;i<t-s+1;i++){\n            xList[s+i] = x;\n        }\n    }else{\n        latentEvaluation(ss, xList, sxList);\n        for(int i=s;i<(ss+1)*sn;i++){\n            xList[i] = x;\n        }\n\n        latentEvaluation(tt, xList, sxList);\n        for(int i=tt*sn;i<t+1;i++){\n            xList[i] = x;\n        }\n\n        for(int i=ss+1;i<tt;i++){\n            sxList[i] = x;\n        }\n    }\n}\n\nvoid find(int ind, vector<ull> &xList, vector<ull> &sxList){\n    int nn = xList.size();\n    int sn = sxList.size();\n    latentEvaluation(ind/sn, xList, sxList);\n    cout << xList[ind] << endl;\n}\n\nint main(){\n    int n, q, qType, s, t,ind;\n    ull x;\n    cin >> n >> q;\n    int sn = sqrt(n)+1;\n\n    vector<ull> xList(sn*sn, (1ull << 31) -1);\n\n    vector<ull> sxList(sn, INF);\n\n    for (int i=0;i<q;i++){\n        cin >> qType;\n        if (qType == 0){\n            cin >> s >> t >> x;\n            update(s,t,x,xList,sxList);\n        }else{\n            cin >> ind;\n            find(ind, xList, sxList);\n        }\n        /*\n        for (int i=0;i<sn*sn;i++){\n            cout << xList[i]  << \" \";\n        }\n        cout << endl;\n        for (int i=0;i<sn;i++){\n            cout << sxList[i] << \" \";\n        }\n        cout << endl;\n        */\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2147483647;\nusing namespace std;\n\nconst int sqrtN = 512;\n\nclass sqdiv{\n    public:\n        int N, K;\n        vector<int> data;\n        vector<bool> lazy_flag;\n        vector<int> lazy_update;\n        sqdiv(int n){ //?????±???????????????????????´\n            N = n;\n            K = (N + sqrtN - 1) / sqrtN;\n            data.assign(K * sqrtN, INF);\n            lazy_flag.assign(K, false);\n            lazy_update.assign(K, 0);\n        }\n        void eval(int k){\n            if(lazy_flag[k]){\n                lazy_flag[k] = false;\n                for(int i = k * sqrtN; i < (k + 1) * sqrtN; i++){\n                    data[i] = lazy_update[k];\n                }\n            }\n        }\n        void update(int x, int y, int a){\n            rep(k,K){\n                int l = k * sqrtN, r = (k + 1) * sqrtN;\n                if(r <= x || y <= l) continue;\n                if(x <= l && r <= y){\n                    lazy_flag[k] = true;\n                    lazy_update[k] = a;\n                }else{\n                    eval(k);\n                    for(int i = max(x, l); i < min(y, r); i++){\n                        data[i] = a;\n                    }\n                }\n            }\n        }\n        int find(int a){\n            int k = a / sqrtN;\n            eval(k);\n            return data[a];\n        }\n};\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    sqdiv ob(n);\n    rep(i,q){\n        bool com;\n        int a, b, c;\n        cin >> com;\n        if(com){\n            cin >> a;\n            cout << ob.find(a) << endl;\n        }else{\n            cin >> a >> b >> c;\n            ob.update(a,b + 1,c);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\ntemplate<typename Type>\nstruct SqrtDecomp {\n    int SIZE;\n    // node の前半には op2 を適用した値が入っているはずで、\n    // 後半には op1 を適用した値が入っているはず\n\n    // lazy は一様更新 → op1 を適用した値が入っているはず\n    vector<Type> node, lazy, need_upd;\n    Type (*op1) (Type x, Type y, int sz);\n    Type (*op2) (Type x, Type y);\n    Type I;\n\n    SqrtDecomp( vector<Type> vec,\n                Type (*g_op1) (Type x, Type y, int sz),\n                Type (*g_op2) (Type x, Type y),\n                Type X) {\n        int N = vec.size();\n        SIZE = 1; while(SIZE * SIZE < N) SIZE++;\n        I = X, op1 = g_op1, op2 = g_op2;\n\n        node.resize(SIZE*SIZE + SIZE, I);\n        lazy.resize(SIZE, I);\n        need_upd.resize(SIZE, 0);\n\n        for(int i=0; i<SIZE; i++) {\n            Type rep_val = I;\n            for(int j=0; j<SIZE && i*SIZE+j<N; j++) {\n                int idx = SIZE + (i*SIZE + j);\n                node[idx] = vec[j];\n                rep_val = op2(rep_val, node[idx]);\n            }\n            node[i] = rep_val;\n        }\n    }\n\n    void lazy_eval(int k) {\n        int l = SIZE*k, r = SIZE*(k+1);\n        // printf(\"lazy_eval: %d, lazy[k] = %d, l =  %d, r = %d\\n\", k, lazy[k], l, r);\n        if(need_upd[k]) {\n            Type seg_val = I;\n\n            // 該当する下のノードをまず更新\n            for(int i=l; i<r; i++) {\n                int idx = SIZE + i;\n                node[idx] = op1(node[idx], lazy[k], 1);\n                seg_val = op2(seg_val, node[idx]);\n            }\n\n            // 上のノードを更新\n            node[k] = seg_val;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    void update(int l, int r, Type val) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // 左端の更新\n        for(int k=l; k<min(r, SIZE*(lidx+1)); k++) {\n            lazy_eval(lidx);\n            int idx = SIZE + k;\n            node[idx] = op1(node[idx], val, 1);\n            node[lidx] = op2(node[lidx], val);\n        }\n\n        if(lidx != ridx) {\n            // 真ん中 (lazy を更新)\n            for(int k=lidx+1; k<ridx; k++) {\n                lazy[k] = op1(lazy[k], val, 1);\n                need_upd[k] = true;\n            }\n\n            // 右端の更新\n            for(int k=SIZE*ridx; k<r; k++) {\n                lazy_eval(ridx);\n                int idx = SIZE + k;\n                node[idx] = op1(node[idx], val, 1);\n                node[ridx] = op2(node[ridx], val);\n            }\n        }\n    }\n\n    Type query(int l, int r) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // printf(\"lidx = %d, ridx = %d\\n\", lidx, ridx);\n        Type ret = I;\n        \n        // 左端の取得\n        for(int k=l; k<min(r, SIZE*(lidx+1)); k++) {\n            lazy_eval(lidx);\n            int idx = SIZE + k;\n            ret = op2(ret, node[idx]);\n        }\n\n        if(lidx != ridx) {\n            for(int k=lidx+1; k<ridx; k++) {\n                // 全体の値と lazy の値を考慮して値を計算\n                Type val = (need_upd[k] ? op1(node[k], lazy[k], SIZE) : node[k]);\n                ret = op2(ret, val);\n            }\n\n            for(int k=SIZE*ridx; k<r; k++) {\n                lazy_eval(ridx);\n                int idx = SIZE + k;\n                ret = op2(ret, node[idx]);\n            }\n        }\n\n        return ret;\n    }\n\n    void print_debug() {\n        printf(\"<< node >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %d\\n\", l, r, node[i]);\n        }\n        printf(\"lower bucket:\\n\");\n        for(int i=0; i<SIZE*SIZE; i++) {\n            int idx = SIZE + i;\n            printf(\"[%6d, %6d) -> %d\\n\", i, i+1, node[idx]);\n        }\n\n        printf(\"<< lazy >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %d\\n\", l, r, lazy[i]);\n        }\n        printf(\"\\n\");\n    }\n};\n\n/*\n// Range Minimum Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a, a+1, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a, b+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// Range Sum Query\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a-1, a, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a-1, b));\n        }\n        sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n// Range Update Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int x; scanf(\"%d\", &x);\n            printf(\"%d\\n\", sqr.query(x, x+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1<<17\nint n,dat[2*(MAX_N)-1];\nint valu[2*(MAX_N)-1];//更新順\n\n//INT＿MAXで初期化\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=INT_MAX;\n    valu[i]=-1;\n  }\n}\n\n//k番目の要素を返す\nint find(int k){\n  k+=n-1;\n  int ans=dat[k];\n  int va=valu[k];\n  while(k>0){\n    k=(k-1)/2;\n    if(valu[k]>va){\n      ans=dat[k];\n      va=valu[k];\n    }\n  }\n  return ans;\n}\n\n//[a,b)の範囲を更新\nvoid update(int a,int b,int x,int i,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return; \n  if(a<=l&&r<=b){\n    valu[k]=i;\n    dat[k]=x;\n  }else{\n    update(a,b,x,i,k*2+1,l,(l+r)/2);\n    update(a,b,x,i,k*2+2,(l+r)/2,r); \n  }\n}\n\nint main(){\n  int q;\n  cin>>n>>q;\n  init(n);\n  for(int i=0;i<q;i++){\n    int com,s,t,x;\n    cin>>com; //com=1でfind,elseでupdate\n    if(com){\n      cin>>s;\n      cout<<find(s)<<endl;\n    }else{\n      cin>>s>>t>>x;\n      update(s,t+1,x,i);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF (1 << 31) - 1\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,q,cnt = 1;\nP dat[300000];\n\nvoid init(){\n\tint nn = 1;\n\twhile(nn < n) nn *= 2;\n\tn = nn;\n\tfor(int i = 0;i < n * 2 - 1;i++){\n\t\tdat[i] = P(INF,0);\n\t}\n}\n\nvoid update(int a,int b,int x,int k,int l,int r){\n\tif(r <= a || b <= l) return;\n\tif(a <= l && r <= b){\n\t\tdat[k] = P(x,cnt);\n\t\treturn;\n\t}\n\tupdate(a,b,x,k * 2 + 1,l,(l + r) / 2);\n\tupdate(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n\nint get(int i){\n\ti = i + n - 1;\n\tint last = dat[i].second,val = dat[i].first;\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tif(last < dat[i].second){\n\t\t\tlast = dat[i].second;\n\t\t\tval = dat[i].first;\n\t\t}\n\t}\n\treturn val;\n}\n\nint main(){\n\tcin >> n >> q;\n\tinit();\n\tfor(int i = 0;i < q;i++){\n\t\tint v;\n\t\tcin >> v;\n\t\tif(v == 0){\n\t\t\tint s,t,x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(s,t + 1,x,0,0,n);\n\t\t\tcnt++;\n\t\t}\n\t\telse{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << get(x) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n/*\nstruct M_act {\n   using T = _operand_set_; // ?????¨???????????´???????????????\n   using Monoid = _operator_monoid_; // ?????¨?´???¢?????????\n   T operator()(const Monoid::T& m, const T& a) { return _m_act_a_; } // ?????¨??????\n};\nstruct Monoid {\n   using T = _underlying_set_; // ??¢??????????????°????????????\n   T operator()(const T& a, const T& b) { return _a_op_b_; } // ????????????\n   static constexpr T identity() { return _identity_element_; } // ?????????\n};\n*/\n\nstruct Monoid {\n   using T = int; // ??¢??????????????°????????????\n   T operator()(const T& a, const T& b) { return a == INT_MAX ? b : a; } // ????????????\n   static constexpr T identity() { return INT_MAX; } // ?????????\n};\nstruct M_act {\n    using T = int; // ?????¨???????????´???????????????\n    using Monoid = Monoid; // ?????¨?´???¢?????????\n    T operator()(const Monoid::T& m, const T& a) { return m == INT_MAX ? a : m; } // ?????¨??????\n};\n\n\ntemplate <class M_act>\nclass SegTree {\n    private:\n        using T = typename M_act::T; // ?????¨???????????´????????????????????¨????????¢???\n        using M = typename M_act::Monoid::T; // ?????¨?´???¢??????????????°???????????¨????????¢???\n        M_act action; // ?????¨?????????\n        typename M_act::Monoid op; // ?????¨?´???¢?????????????????????\n        const int n, h; // ?????????????????¨?????????\n        vector<T> dat; // ?????????\n        vector<M> lazy; // ????????§?????????????????????????§?????????¨????????????????????????????????¨?????????????????°???????????§????????§?????????n??§??????\n        bool has_lazy; // ??????????????§??????????????????????????¨????????????????????????????????°\n\n        void act(int i, const M& m) { // ?????????i????????¨\n            if (i < n) lazy[i] = op(m, lazy[i]); // ?????¨????????????????????¨??¨?????¨????????¨?´???¢????????????????????§?????¨??????\n            else {\n                i -= n;\n                dat[i] = action(m, dat[i]); // ??????????????¨????????¨???????????????\n            }\n        }\n\n        void prop_from(int i) { // ?????????i????????¨??????????????????\n            act(i << 1, lazy[i]);\n            act(i << 1 | 1, lazy[i]);\n            lazy[i] = op.identity();\n        }\n\n        void prop_to(int i) { // i???????????????????????¨?????¨???????????§??????????????????\n            i += n;\n            for (int s = (i >> h ? h : h-1); s > 0; --s) prop_from(i >> s);\n        }\n\n    public:\n        SegTree(int n) : n(n), h(log(n)), dat(n, op.identity()), lazy(n, op.identity()), has_lazy() {} // ????§????x??§??????????????????????????????\n        SegTree(const vector<T>& v) : n(v.size()), h(__lg(n)), dat(v), lazy(n, op.identity()), has_lazy() {} // ????????????vector??§???????????????????????????\n\n        void act(int l, int r, const M& m) { // [l, r)???m????????¨?????????\n            prop_to(l);\n            prop_to(r-1);\n            l += n, r += n;\n            for (; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) act(l++, m);\n                if (r & 1) act(r-1, m);\n            }\n            has_lazy = true;\n        }\n\n        void prop() { // ?????????????????¨???????????¨???????????§?????????\n            for (int i = 1; i < n; ++i) prop_from(i);\n            has_lazy = false;\n        }\n\n        void set(int i, const T& x) { // i????????????????????´??°\n            prop_to(i);\n            dat[i] = x;\n        }\n        void add(int i, const T &x){\n            set(i, get(i) * x);\n        }\n\n        T get(int i) { // i?????????????????????\n            if (!has_lazy) return dat[i]; // ????????????????????¨?????????????????????????????????\n            T ret = dat[i];\n            i += n;\n            while (i >>= 1) ret = action(lazy[i], ret); // ????????§????????????????????§?????£???????????????????????????????????§????????¨????¢???£?????????\n            return ret;\n        }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n\n    SegTree<M_act> seg(n);\n    rep(i,q){\n        int com;\n        cin >> com;\n        if(com){\n            int x;\n            cin >> x;\n            cout << seg.get(x) << endl;\n        }else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.act(s, t + 1, x);\n        }\n        //seg.print();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,q,d[1<<18],a,b,c,e[1<<17];\nvoid m(int l,int r,int k){\n\tif(r<=a||b<=l)return;\n\tif(a<=l&&r<=b)d[k]=q;\n\telse{m(l,(l+r)/2,k*2+1);m((l+r)/2,r,k*2+2);}\n}\nint main(){\n\tcin>>a>>q;n=2;while(n<a)n*=2;a=2*n;\n\twhile(a--)d[a]=114514;e[114514]=INT_MAX;\n\twhile(q--){\n\t\tcin>>a;\n\t\tif(a){cin>>a;a+=n-1,b=d[a];\n\t\t\twhile(a)a=(a-1)/2,b=min(b,d[a]);\n\t\t\tcout<<e[b]<<endl;\n\t\t}\n\t\telse{cin>>a>>b>>c;b++,e[q]=c;m(0,n,0);}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define INF (1 << 30) - 1\n#define LLINF (1LL << 61) - 1\n// #define int ll\nusing namespace std;\nconst int MOD = 1000000007;\nconst int MAX = 510000;\n\nstatic const int MAX_N = 1<<17;\npii dat[2 * MAX_N -1];\nint n;\n\nstruct SegmentTree{\n    \n    \n    \n    SegmentTree(int n_){\n        n=1;\n        while(n<n_) n*= 2;\n        for(int i=0;i<2*n-1;i++){\n            dat[i].first = -1;\n            dat[i].second=(1LL<<31)-1;\n        }\n    }\n    int query(int k){\n        k += n-1;\n        pii value=dat[k];\n        while(k>0){\n            k=(k-1)/2;\n            value=max(value,dat[k]);\n        }\n        return value.second;\n    }\n    void update(int a,int b,int k,pii P,int l,int r){\n        if(r<=a || b<=l) return;\n        if(a<=l && r<=b){\n            dat[k]=P;\n        }\n        else{\n            update(a,b,k*2+1,P,l,(l+r)/2);\n            update(a,b,k*2+2,P,(l+r)/2,r);\n        }\n    }\n    \n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int _n,q;\n    cin>>_n>>q;\n    SegmentTree sg(_n);\n    rep(i,q){\n        int c;\n        cin>>c;\n        if(!c){\n            int s,t,x;\n            cin>>s>>t>>x;\n            sg.update(s,t+1,0,pii(i,x),0,n);\n        } else{\n            int x;\n            cin>>x;\n            cout<<sg.query(x)<<endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<long long>;\nusing pll = pair<long long, long long>;\n#define REP(i,n) for(long long i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\nll INF = 1LL << 60;\nconst ll sqrtN = 512; //* 512*512=262144 > 10^5\n\n//* reference: https://kujira16.hateblo.jp/entry/2016/12/15/000000\n//* Range Sum Query (RSQ) implemented using sqrt decomposition\nstruct RSQ{ \n    ll N, K; //* N length of data, K number of buckets\n    vll data;\n    vll bucketSum;\n    //* allocate memory with zeros\n    void init(ll n){\n        N = n;\n        K = (n + sqrtN - 1) / sqrtN; //* number of buckets = ceil(n/sqrtN)\n        data.assign(K * sqrtN, 0);\n        bucketSum.assign(K, 0);\n    }\n    //* constructor\n    RSQ(ll n){ init(n);}\n    //* constructor with init vector data\n    RSQ(ll n, vll &a){\n        init(n);\n        REP(i, n){\n            data[i] = a[i];\n        }\n        REP(k, K){\n            ll sum = 0;\n            for(ll j = k * sqrtN; j < (k + 1)* sqrtN; j++){\n                sum += data[j];\n            }\n            bucketSum[k] = sum;\n        }\n    }\n    //* update (add(i, x) -> a[i]+= x)\n    void add(ll i, ll x){\n        ll k = i / sqrtN; //* corresponding bucket\n        data[i] += x;\n        ll sum = 0;\n        for(ll j = k * sqrtN ; j < (k + 1)*sqrtN; j ++){\n            sum += data[j];\n        }\n        bucketSum[k] = sum;\n    }\n    //* getSum(s, t)-> return a[s]+a[s+1]+...+a[t-1]\n    //* [x, y)\n    ll getSum(ll x, ll y){\n        ll sum = 0;\n        REP(k, K){\n            ll l= k * sqrtN, r = (k+1) * sqrtN; //* bucket [l, r)\n            if(r <= x || y <= l) //* no intersection\n                continue;\n            if(x <= l && r <= y) {//* [l, r) in [x, y)\n                sum += bucketSum[k]; //* use bucket data\n            }\n            else{ //* has intersection on boundary\n                for(ll i = max(l, x); i < min(r, y); i++){\n                    sum += data[i];\n                }\n            }\n        }\n        return sum;\n    }\n};\n//* reference: https://kujira16.hateblo.jp/entry/2016/12/15/000000\n//* Range Minimum Query (RMQ) implemented using sqrt decomposition\nstruct RMQ{\n    ll N, K;\n    vll data;\n    vll bucketMin;\n    //* allocate memory with zeros\n    void init(ll n){\n        N = n;\n        K = (n + sqrtN - 1) / sqrtN; //* number of buckets = ceil(n/sqrtN)\n        data.assign(K * sqrtN, INF);\n        bucketMin.assign(K, INF);\n    }\n    //* constructor\n    RMQ(ll n){ init(n);}\n    //* constructor with init vector data\n    RMQ(ll n, vll &a){\n        init(n);\n        REP(i, n){\n            data[i] = a[i];\n        }\n        REP(k, K){\n            ll tmp = INF;\n            for(ll j = k * sqrtN; j < (k + 1)* sqrtN; j++){\n                tmp =min(tmp, data[j]);\n            }\n            bucketMin[k] = tmp;\n        }\n    }\n    //* update a[i] = x\n    void update(ll i, ll x){\n        ll k = i / sqrtN; //* corresponding bucket\n        if(x <= data[i]){ //* fast update\n            data[i] = x;\n            bucketMin[k] = min(x, bucketMin[k]);\n            return;\n        }\n        data[i] = x;\n        ll tmp = x;\n        for(ll j = k * sqrtN; j < (k+1)*sqrtN; j++){\n            tmp = min(tmp, data[j]);\n        }\n\n        bucketMin[k] = tmp;\n    }\n    //* find(s, t)-> return min(a[s], a[s+1], ..., a[t-1])\n    //* [x, y)\n    ll find(ll x, ll y){\n        ll tmp = INF;\n        REP(k, K){\n            ll l= k * sqrtN, r = (k+1) * sqrtN; //* bucket [l, r)\n            if(r <= x || y <= l) //* no intersection\n                continue;\n            if(x <= l && r <= y) {//* [l, r) in [x, y)\n                tmp = min(tmp, bucketMin[k]); //* use bucket data\n            }\n            else{ //* has intersection on boundary\n                for(ll i = max(l, x); i < min(r, y); i++){\n                    tmp = min(tmp, data[i]);\n                }\n            }\n        }\n        return tmp;\n    }\n};\n//* reference: https://kujira16.hateblo.jp/entry/2016/12/15/000000\n//* Range Add Query (RAQ) implemented using sqrt decomposition\nstruct RAQ{\n    ll N, K;\n    vll data;\n    vll bucketAdd;\n    //* init using 0 data\n    void init(ll n){ \n        N = n;\n        K = (n + sqrtN - 1) / sqrtN; //* number of buckets = ceil(n/sqrtN)\n        data.assign(K * sqrtN, 0);\n        bucketAdd.assign(K, 0);\n    }\n    //* constructor\n    RAQ(ll n){ init (n); }\n    RAQ(ll n, vll const &a){\n        init(n);\n        REP(i, n){\n            data[i] = a[i];\n        }\n        //* zero initialization is enough\n    }\n    //* update [s, t) with addition x\n    void add(ll s, ll t, ll x){\n        REP(k, K){\n            ll l= k * sqrtN, r = (k + 1) * sqrtN; //* bucket [l, r)\n            if(r <= s || t <= l) //* no intersection\n                continue;\n            if(s <= l && r <= t) {//* [l, r) in [x, y)\n                bucketAdd[k] += x; //* update bucket data\n            }\n            else{ //* has intersection on boundary\n                for(ll i = max(l, s); i < min(r, t); i++){\n                    data[i] += x;\n                }\n            }\n        }\n    }\n    //* get i-th data\n    ll get(ll i){\n        ll k = i / sqrtN;\n        return data[i] + bucketAdd[k];\n    }\n\n};\n//* reference: https://kujira16.hateblo.jp/entry/2016/12/15/000000\n//* Range Update Query (RUQ) implemented using sqrt decomposition\nstruct RUQ{\n    ll N, K;\n    vll data;\n    vll lazyUpdate;\n    vector<bool> lazyFlag;\n    //* allocate memory\n    void init(ll n){\n        N = n;\n        K = (n + sqrtN - 1) / sqrtN; //* number of buckets = ceil(n/sqrtN)\n        data.assign(K * sqrtN, 0);\n        lazyUpdate.assign(K, 0);\n        lazyFlag.assign(K, false);\n    }\n    //* constructor\n    RUQ(ll n){ init(n);}\n    RUQ(ll n, vll &a){\n        init(n);\n        REP(i, n){\n            data[i] = a[i];\n        }\n    }\n    //* update data using lazyUpdate data\n    void eval(ll k) {\n        if (lazyFlag[k]) {\n            //* lazyFlag of the bucket set to false\n            lazyFlag[k] = false;\n            //* update data in the bucket\n            for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n                data[i] = lazyUpdate[k];\n            }\n        }\n    }\n    //* [s, t) update with x\n    void update(ll s, ll t, ll x){\n        REP(k, K){\n            ll l= k * sqrtN, r = (k+1) * sqrtN; //* bucket [l, r)\n            if(r <= s || t <= l) //* no intersection\n                continue;\n            if(s <= l && r <= t) {//* [l, r) in [x, y)\n                lazyUpdate[k] = x;\n                lazyFlag[k] = true;\n            }\n            else{\n                eval(k); //* for O(1) buckets we just update the data\n                for(ll i = max(l, s); i < min(r, t); i++){\n                    data[i] = x;\n                }\n            }\n        }\n    }\n    //* find i-th data\n    ll find(ll i){\n        ll k = i / sqrtN; //* bucket index\n        eval(k);\n        return data[i];\n    }\n};\n\nvoid solveRSQ(){\n    ll N, Q;\n    cin >> N >> Q;\n    RSQ st(N);\n    REP(q, Q){\n        ll com;\n        cin >> com;\n        if(com){\n            ll x, y;\n            cin >> x >> y;\n            cout << st.getSum(x-1, y)<<endl;\n        }\n        else{\n            ll i, x;\n            cin >> i >> x;\n            st.add(i-1, x);\n        }\n    }\n\n}\n\nvoid solveRMQ(){\n    ll n, q;\n    cin >> n >> q;\n    vll a(n, (1LL<<31)-1);\n    RMQ st(n, a);\n    REP(_, q){\n        ll com;\n        cin >> com;\n        if(com){//* \n            ll x, y;\n            cin >> x >> y;\n            cout << st.find(x, y+1) << endl;\n        }\n        else{ //* update\n            ll i, y;\n            cin >> i >> y;\n            st.update(i, y);\n        }\n    }\n}\n\nvoid solveRAQ(){\n    ll N, Q;\n    cin >> N >> Q;\n    RAQ st(N);\n    REP(q, Q){\n        ll com;\n        cin >> com;\n        if(com){\n            ll i;\n            cin >> i;\n            cout << st.get(i-1)<<endl;\n        }\n        else{\n            ll s, t, x;\n            cin >> s >> t >> x;\n            st.add(s-1, t, x);\n        }\n    }\n}\n\nvoid solveRUQ(){\n    ll N, Q;\n    cin >> N >> Q;\n    vll a(N, ((1LL<<31)-1));\n    RUQ st(N, a);\n    REP(q, Q){\n        ll com;\n        cin >> com;\n        if(com == 0){ //* update(s, t, x)\n            ll s, t, x;\n            cin >> s >> t >> x;\n            t++;\n            st.update(s, t, x);\n        }\n        else{ //* com == 1\n            ll i;\n            cin >> i; \n            cout << st.find(i)<<endl;\n        }\n    }\n}\n\nint main(){\n    //* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B\n    // solveRSQ();\n    //* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_A\n    // solveRMQ();\n    //* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_E&lang=ja\n    // solveRAQ();\n    //* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n    solveRUQ();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst int INF = 0x3fffffff;\nconst int MOD = 1000000007;\nconst int MODD = 998244353;\nconst ld DINF = numeric_limits<ld>::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,...) for(auto&& i:__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n \n \ntemplate<class T>\nstruct DualSegmentTree{\n    virtual void c(T&, const T&) = 0;\n    ll size = 1, rank = 0;\n    vector<T> lazy;\n    const T def_lazy;\n    DualSegmentTree(ll n, const T& def_value, const T& def_lazy): def_lazy(def_lazy){\n        while(size < n){\n            size *= 2;\n            rank++;\n        }\n        lazy.assign(size * 2, def_lazy);\n        for(ll i = size; i < size * 2; i++) lazy[i] = def_value;\n    }\n    DualSegmentTree(const vector<T>& v, const T& def_lazy): def_lazy(def_lazy){\n        while(size < v.size()){\n            size *= 2;\n            rank++;\n        }\n        lazy.assign(size * 2, def_lazy);\n        for(ll i = 0; i < v.size(); i++) lazy[size + i] = v[i];\n    }\n    void push(ll at){\n        if(!at) return;\n        ll r = 31 - __builtin_clz(at);\n        for(ll i = r; i > 0; i--){\n            ll a = at >> i;\n            if(lazy[a] != def_lazy){\n                c(lazy[a * 2], lazy[a]);\n                c(lazy[a * 2 + 1], lazy[a]);\n                lazy[a] = def_lazy;\n            }\n        }\n    }\n    T operator[](ll at){\n        at += size;\n        push(at);\n        return lazy[at];\n    }\n    void set(ll at, const T& val){\n        at += size;\n        push(at);\n        lazy[at] = val;\n    }\n    void query(ll l, ll r, const T& val){\n        if(l >= r) return;\n        l += size;\n        r += size;\n        ll L = l >> __builtin_ctz(l), R = (r >> __builtin_ctz(r)) - 1;\n        push(L);\n        push(R);\n        for(; l < r; l /= 2, r /= 2){\n            if(l & 1) c(lazy[l++], val);\n            if(r & 1) c(lazy[--r], val);\n        }\n    }\n};\ntemplate<class T>\nstruct RAQ : DualSegmentTree<T>{\n    using Base = DualSegmentTree<T>;\n    void c(T& a, const T& b){ a += b; }\n    RAQ(ll n, const T& def_value = T()) : Base(n, def_value, def_value){}\n    RAQ(const vector<T>& v, const T& def_value = T()) : Base(v, def_value){}\n};\ntemplate<class T>\nstruct RUQ : DualSegmentTree<T>{\n    using Base = DualSegmentTree<T>;\n    void c(T& a, const T& b){ a = b; }\n    RUQ(ll n, const T& def_value, const T& def_lazy = numeric_limits<T>::max()) : Base(n, def_value, def_lazy){}\n    RUQ(const vector<T>& v, const T& def_lazy = numeric_limits<T>::max()) : Base(v, def_lazy){}\n};\ntemplate<class T>\nstruct RchmQ : DualSegmentTree<T>{\n    using Base = DualSegmentTree<T>;\n    void c(T& a, const T& b){ chmin(a, b); }\n    RchmQ(ll n, const T& def_value, const T& def_lazy = numeric_limits<T>::max()) : Base(n, def_value, def_lazy){}\n    RchmQ(const vector<T>& v, const T& def_lazy = numeric_limits<T>::max()) : Base(v, def_lazy){}\n};\nsigned main(){\n    LL(n, q);\n    RUQ<ll> seg(n, 0x7fffffff);\n    rep(q){\n        LL(type);\n        if(type){\n            LL(x);\n            out(seg[x]);\n        }\n        else{\n            LL(l, r, x);\n            seg.query(l, r + 1, x);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n#define fi first\n#define se second\nconst ll INFLL=LLONG_MAX;\nconst int INF=INT_MAX;\n#define eb emplace_back\n#define emp emplace\n#define mp(a,b) make_pair(a,b)\ntemplate<class T> using min_heap=priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T>\nvoid sort(vector<T>& v){\n\tsort(v.begin(),v.end());\n}\ntemplate <class T, class U>\nvoid sort(vector<T>& v,U func){\n\tsort(v.begin(),v.end(),func);\n}\ntemplate <class T>\nint lb_index(vector<T>& v,T k){\n\treturn lower_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate <class T>\nint ub_index(vector<T>& v,T k){\n\treturn upper_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate<class T>\nstruct segtree{\nprivate:\n\tT init;\n\tint n;\n\tfunction<T(T,T)> op;\n\tvector<T>arr;\n\tvector<T>st;\n\tvector<T>lz;\n\tvoid build(int lo,int hi,int u){\n\t\tif(lo==hi){\n\t\t\tst[u]=arr[lo];\n\t\t}\n\t\telse{\n\t\t\tint mi=(hi+lo)>>1;\n\t\t\tbuild(lo,mi,u<<1);\n\t\t\tbuild(mi+1,hi,u<<1|1);\n\t\t\tst[u]=op(st[u<<1],st[u<<1|1]);\n\t\t}\n\t}\n\tvoid apply(T x,int u,int lo,int hi){\n// \t\tst[u]+=x*(hi-lo+1);\n// \t\tst[u]+=x;\n//\t\tst[u]=x;\n \t\tst[u]=x*(hi-lo+1);\n// \t\tlz[u]+=x;\n\t\tlz[u]=x;\n\t}\n\tvoid push(int u,int lo,int hi){\n\t\tif(lz[u]!=init){\n\t\t\tint mi=(lo+hi)>>1;\n\t\t\tapply(lz[u],u<<1,lo,mi);\n\t\t\tapply(lz[u],u<<1|1,mi+1,hi);\n\t\t\tlz[u]=init;\n\t\t}\n\t}\n\tvoid modify(int l,int r,T x,int u,int lo,int hi){\n\t\tif(r<lo||l>hi||l>r)return;\n\t\tif(l<=lo&&r>=hi){\n\t\t\tapply(x,u,lo,hi);\n\t\t\treturn;\n\t\t}\n\t\tpush(u,lo,hi);\n\t\tint mi=(lo+hi)>>1;\n\t\tif(mi>=r){\n\t\t\tmodify(l,r,x,u<<1,lo,mi);\n\t\t}\n\t\telse if(mi<l){\n\t\t\tmodify(l,r,x,u<<1|1,mi+1,hi);\n\t\t}\n\t\telse{\n\t\t\tmodify(l,mi,x,u<<1,lo,mi);\n\t\t\tmodify(mi+1,r,x,u<<1|1,mi+1,hi);\n\t\t}\n\t\tst[u]=op(st[u<<1],st[u<<1|1]);\n\t}\n\tT query(int l,int r,int u,int lo,int hi){\n\t\tif(l>r||l>hi||r<lo)return init;\n\t\tif(l<=lo&&r>=hi){\n\t\t\treturn st[u];\n\t\t}\n\t\tpush(u,lo,hi);\n\t\tint mi=(hi+lo)>>1;\n\t\tif(mi>=r){\n\t\t\treturn query(l,r,u<<1,lo,mi);\n\t\t}\n\t\telse if(mi<l){\n\t\t\treturn query(l,r,u<<1|1,mi+1,hi);\n\t\t}\n\t\telse{\n\t\t\treturn op(query(l,mi,u<<1,lo,mi),query(mi+1,r,u<<1|1,mi+1,hi));\n\t\t}\n\t}\npublic:\n\tsegtree(T n,function<T(T,T)> op):n(n),st(n*4),op(op),lz(n*4){\n\t\tinit=T();\n\t}\n\tsegtree(vector<T> v,function<T(T,T)> op):n(v.size()),st(v.size()*4),op(op),lz(v.size()*4){\n\t\tinit=T();\n\t\tarr=v;\n\t\tbuild(0,n-1,1);\n\t}\n\tT query(int l,int r){\n\t\treturn query(l,r,1,0,n-1);\n\t}\n\tT query(int p){\n\t\treturn query(p,p);\n\t}\n\tvoid setinit(T x){\n\t\tinit=x;\n\t\tfor(int i=0;i<4*n;i++){\n\t\t\tst[i]=init;\n\t\t\tlz[i]=init;\n\t\t}\n\t}\n\tvoid modify(int l,int r,T x){\n\t\tmodify(l,r,x,1,0,n-1);\n\t}\n\tvoid modify(int p,T x){\n\t\tmodify(p,p,x);\n\t}\n\tvoid debug(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i;j<n;j++){\n\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<query(i,j)<<\"\\n\";\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tsegtree<int> seg(n,[](int a,int b){\n\t\treturn a+b;\n\t});\n\tseg.setinit(INF);\n\twhile(q--){\n\t\tint c;\n\t\tcin>>c;\n\t\tif(c){\n\t\t\tint l;\n\t\t\tcin>>l;\n\t\t\tcout<<seg.query(l)<<\"\\n\";\n\t\t}\n\t\telse{\n\t\t\tint l,r,x;\n\t\t\tcin>>l>>r>>x;\n\t\t\tseg.modify(l,r,x);\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <functional>\n#include <vector>\n\ntemplate<typename Monoid, typename OperatorMonoid = Monoid>\nclass lazy_segment_tree {\n\tusing value_type = Monoid;\n\tusing operator_type = OperatorMonoid;\n\tusing size_type = size_t;\n\n\tusing F = std::function<value_type (value_type, value_type)>;\n\tusing G = std::function<value_type (value_type, operator_type, int, int)>;\n\tusing H = std::function<operator_type (operator_type, operator_type)>;\n\t\n\tsize_type size_;\n\tsize_type height_;\n\n\tF f;\n\tG g;\n\tH h;\n\tvalue_type id;\n\toperator_type id_op;\n\tstd::vector<value_type> data;\n\tstd::vector<operator_type> lazy;\n\tstd::vector<size_type> depth;\n\t\n\tconst size_type get_height(const size_type& size) const {\n\t\tsize_type height = 1;\n\t\twhile(1 << height < size) height++;\n\t\treturn height;\n\t}\n\tconst size_type base_size() const {\n\t\treturn 1 << height_;\n\t}\n\tconst value_type reflect(const size_type & k) {\n\t\tif(lazy[k] == id_op) return data[k];\n\t\tint l = (k - (1 << depth[k])) * (base_size() >> depth[k]);\n\t\tint r = l + (base_size() >> depth[k]);\n\t\treturn g(data[k], lazy[k], l, r);\n\t}\n\tvoid eval(const size_type & k) {\n\t\tif(lazy[k] == id_op) return;\n\t\tlazy[k << 1 ^ 0] = h(lazy[k << 1 ^ 0], lazy[k]);\n\t\tlazy[k << 1 ^ 1] = h(lazy[k << 1 ^ 1], lazy[k]);\n\t\tdata[k] = reflect(k);\n\t\tlazy[k] = id_op;\n\t}\n\tvoid thrust(const size_type & k) {\n\t\tfor(int i = height_; i; i--) eval(k >> i);\n\t}\n\tvoid recalc(size_type k) {\n\t\twhile(k >>= 1) data[k] = f(reflect(k << 1 ^ 0), reflect(k << 1 ^ 1));\n\t}\n\t\n\tpublic:\n\tlazy_segment_tree() {}\n\tlazy_segment_tree(int n, const F & f, const G & g, const H & h, const value_type & id, const operator_type & id_op) :\n\t\tsize_(n), f(f), g(g), h(h), id(id), id_op(id_op) {\n\t\theight_ = get_height(size_);\n\t\tdata.assign(base_size() << 1, id);\n\t\tlazy.assign(base_size() << 1, id_op);\n\t\tdepth.assign(base_size() << 1, 0);\n\t\tfor(int i = 0; i < height_ + 1; i++)\n\t\t\tfor(int j = (1 << i); j < (1 << (i + 1)); j++)\n\t\t\t\tdepth[j] = i;\n\t}\n\tvoid update(size_type a, size_type b, operator_type x) {\n\t\tthrust(a += base_size());\n\t\tthrust(b += base_size() - 1);\n\t\tfor(size_type l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif(l & 1) lazy[l] = h(lazy[l], x), l++;\n\t\t\tif(r & 1) --r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\tvoid change(size_type k, const value_type x) {\n\t\tthrust(k += base_size());\n\t\tdata[k] = x;\n\t\tlazy[k] = id_op;\n\t\trecalc(k);\n\t}\n\tconst value_type fold(size_type a, size_type b) {\n\t\tthrust(a += base_size());\n\t\tthrust(b += base_size() - 1);\n\n\t\tvalue_type left_value = id;\n\t\tvalue_type right_value = id;\n\t\tfor(size_type l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif(l & 1) left_value = f(left_value, reflect(l++));\n\t\t\tif(r & 1) right_value = f(reflect(--r), right_value);\n\t\t}\n\t\treturn f(left_value, right_value);\n\t}\n\n\tconst value_type operator[](const size_type & k) {\n\t\treturn fold(k, k + 1);\n\t}\n};\n\n\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\n\tauto f = [](int a, int b) { return a + b; };\n\tauto g = [](int a, int b, int l, int r) { return b; };\n\tauto h = [](int a, int b) { return b; };\n\tlazy_segment_tree<int> seg(n, f, g, h, 0, -1);\n\tfor(int i = 0; i < n; i++) seg.change(i, (1LL << 31) - 1);\n\t\n\twhile(q--) {\n\t\tint type; scanf(\"%d\", &type);\n\n\t\tif(type == 0) {\n\t\t\tint s, t, x; scanf(\"%d%d%d\", &s, &t, &x);\n\n\t\t\tseg.update(s, t + 1, x);\n\t\t} else if(type == 1) {\n\t\t\tint i; scanf(\"%d\", &i);\n\t\t\t\n\t\t\tprintf(\"%d\\n\", seg[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  if(n%sq == 0){\n    nsq = n/sq;\n  }\n  ll lazy[nsq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t  lazy[t/sq] = -1;\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  int n;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(){};\n  SegmentTree(int n_,G g,H h,T ti,E ei):\n    g(g),h(h),ti(ti),ei(ei){\n    init(n_);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(n,ti);\n    laz.clear();\n    laz.resize(2*n-1,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i]=v[i];\n  }\n  void eval(int k){\n    if(k*2+1<2*n-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n      laz[k]=ei;\n    }\n  }\n  void update(int a,int b,E x,int k,int l,int r){\n    eval(k);\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return;\n    }\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n  void update(int a,int b,E x){\n    update(a,b,x,0,0,n);\n  }\n  void eval2(int k){\n    if(k) eval2((k-1)/2);\n    eval(k);\n  }  \n  T query(int k){\n    T c=dat[k];\n    k+=n-1;\n    eval2(k);\n    return g(c,laz[k]);\n  }\n};\n//END CUT HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> beet(n,\n\t\t\t    [&](int a,int b){ return b<0?a:b;},\n\t\t\t    [&](int a,int b){ return b<0?a:b;},\n\t\t\t    INT_MAX,-1);\n  for(int i=0;i<q;i++){\n    int c;\n    cin>>c;\n    if(c){\n      int x;\n      cin>>x;\n      cout<<beet.query(x)<<endl;\n    }else{\n      int s,t,x;\n      cin>>s>>t>>x;\n      t++;\n      beet.update(s,t,x);\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2018/03/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define siz 10000000\n\nchar buf[siz], *bit = buf;\n\ninline int nextInt(void) {\n\tregister int ret = 0;\n\tregister int neg = false;\n\n\tfor (; *bit < '0'; ++bit)\n\t\tif (*bit == '-')neg ^= true;\n\n\tfor (; *bit >= '0'; ++bit)\n\t\tret = ret * 10 + *bit - '0';\n\n\treturn neg ? -ret : ret;\n}\n\n#define inf 2147483647\n\nint n, m;\n\nint tag[400005];\n\nint find(int t, int l, int r, int p) {\n\tif (~tag[t])\n\t\treturn tag[t];\n\tint mid = (l + r) >> 1;\n\tif (p <= mid)\n\t\treturn find(t << 1, l, mid, p);\n\telse\n\t\treturn find(t << 1 | 1, mid + 1, r, p);\n}\n\nvoid update(int t, int l, int r, int x, int y, int k) {\n\tif (l == x && r == y)\n\t\ttag[t] = k;\n\telse {\n\t\tint mid = (l + r) >> 1;\n\t\tif (~tag[t])\n\t\t\ttag[t << 1] = tag[t << 1 | 1] = tag[t], tag[t] = -1;\n\t\tif (y <= mid)\n\t\t\tupdate(t << 1, l, mid, x, y, k);\n\t\telse if (x > mid)\n\t\t\tupdate(t << 1 | 1, mid + 1, r, x, y, k);\n\t\telse {\n\t\t\tupdate(t << 1, l, mid, x, mid, k);\n\t\t\tupdate(t << 1 | 1, mid + 1, r, mid + 1, y, k);\n\t\t}\n\t}\n}\n\nsigned main(void) {\n\tfread(buf, 1, siz, stdin);\n\n\tn = nextInt();\n\tm = nextInt();\n\n\tfor (int i = 0; i < (n << 2); ++i)\n\t\ttag[i] = inf;\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint c = nextInt();\n\t\tif (c)\t// find(x)\n\t\t\tprintf(\"%d\\n\", find(1, 1, n, nextInt() + 1));\n\t\telse {\n\t\t\tint x = nextInt();\n\t\t\tint y = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tupdate(1, 1, n, x + 1, y + 1, k);\n\t\t}\n\t}\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint t[(1<<18)];\n \nvoid Set(int a,int b,int x,int k=0,int l=0,int r=(1<<17)){\n  if(b<=l || r<=a)return;\n  if(a<=l && r<=b){\n    t[k]=max(t[k],x);\n    return;\n  }\n  int m=(l+r)/2;\n  Set(a,b,x,k*2+1,l,m);\n  Set(a,b,x,k*2+2,m,r);\n}\n \nint Get(int i){\n  i+=(1<<17)-1;\n  int res=t[i];\n  while(i){\n    i=(i-1)/2;\n    res=max(res,t[i]);\n  }\n  return res;\n}\n          \nint n,q;\nint value[100005];\n \nint main(){\n  value[0]=2147483647;\n   \n  scanf(\"%d %d\",&n,&q);\n  for(int i=1;i<=q;i++){\n    int type;\n    scanf(\"%d\",&type);\n    if(type==0){\n      int l,r;\n      scanf(\"%d %d %d\",&l,&r,&value[i]);\n      r++;\n      Set(l,r,i);\n    }else{\n      int target;\n      scanf(\"%d\",&target);\n      int ans=Get(target);\n      printf(\"%d\\n\",value[ans]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n\tint A[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                A[i] = INT_MAX;\n                cout << A[i] << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        A[i] = x[j];\n                        cout << A[i] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define inf 10e17\n#define rep(i,n) for(long long i=0; i<n; i++)\n#define repr(i,n,m) for(long long i=m; i<n; i++)\n#define mod 1000000007\n#define sorti(x) sort(x.begin(), x.end())\n#define sortd(x) sort(x.begin(), x.end(), std::greater<long long>())\n#define debug(x) std::cerr << (x) << std::endl;\n#define roll(x) for (auto&& itr : x) { cerr << (itr) << \" \"; }\n\ntemplate <class T> inline void chmax(T &ans, T t) { if (t > ans) ans = t;}\ntemplate <class T> inline void chmin(T &ans, T t) { if (t < ans) ans = t;}\n\ntemplate <typename _Tp>\nstruct LazySegmentTree {\n  _Tp n;\n  vector<_Tp> node, lazy;\n\n  LazySegmentTree(vector<_Tp> const& v) {\n    _Tp sz = v.size();\n    n = 1;\n    while (sz > n) n *= 2;\n    node.resize(2*n-1);\n    lazy.resize(2*n-1, -1);\n\n    for (int i = 0; i < sz; ++i) {\n      node[i+n-1] = v[i];\n    }\n/*\n    for (int i = n-2; i >= 0; --i) {\n      node[i] = node[i*2+1] + node[i*2+2];\n    }\n    */\n  }\n\n  void eval(int k, int l, int r) {\n    if (lazy[k] != -1) {\n      node[k] = lazy[k]; // 自分自身に遅延評価を反映\n\n      // 最下段でないならば評価を伝搬させる。\n      if (r - l > 1) {\n        lazy[2*k+1] = lazy[k];\n        lazy[2*k+2] = lazy[k];\n      }\n\n      lazy[k] = -1;\n    }\n  }\n\n  void update(int a, int b, _Tp value, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(k,l,r);\n\n    // 範囲外ならば切る。\n    if (b <= l || r <= a) {\n      // cout << 1 << endl;\n      return;\n    }\n\n    if (a <= l && r <= b) {\n      lazy[k] = value;\n      eval(k,l,r);\n      return;\n    } else {\n      update(a,b,value,2*k+1,l,(r+l)/2);\n      update(a,b,value,2*k+2,(l+r)/2,r);\n      node[k] = value;\n    }\n  }\n\n  _Tp get(int idx, int k = 0, int l = 0, int r = -1) {\n    int a = idx, b = idx+1;\n    if (r < 0) {\n      r = n;\n    }\n\n    eval(k,l,r);\n\n    // cout << a << \" \"<< b << \" \" << l << \" \" << r << endl;\n\n    if (a <= l && r <= b) {\n      return node[k];\n    }\n\n    if (b <= l || r <= a) return -1;\n    else {\n      auto lv = get(idx, 2*k+1, l, (l+r)/2);\n      auto rv = get(idx, 2*k+2, (l+r)/2, r);\n      return max(lv, rv);\n    }\n  }\n};\n\nll fi = (1L << 31) - 1;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vector<ll> v(n, fi);\n  LazySegmentTree<ll> seg_tree(v);\n  rep(i, q) {\n    int com;\n    cin >> com;\n    if (com == 0) {\n      int s,t,n;\n      cin >> s >> t >> n;\n      seg_tree.update(s,t+1,n);\n    } else {\n      int idx;\n      cin >> idx;\n      cout << seg_tree.get(idx) << \"\\n\";\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/DSL_2_D.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\"\n\n#line 2 \"test/aoj/../../monoid/fill.hpp\"\n#include <utility>\n\nnamespace monoid {\ntemplate <class T>\nstruct fill {\n  typedef std::pair<bool, T> value_t;\n  value_t identity() const { return std::make_pair(false, T()); }\n  value_t merge(value_t a, value_t b) const { return b.first ? b : a; }\n};\n} // namespace monoid#line 4 \"test/aoj/DSL_2_D.test.cpp\"\n// #include \"../../datastructure/lazy-segment-tree.cpp\"\n#line 1 \"test/aoj/../../datastructure/dual-segment-tree.cpp\"\n#include <cassert>\n#line 1 \"test/aoj/../../datastructure/lazy-segment-tree.cpp\"\n#include <cassert>\n#include <functional>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n// FIXME: coding styleを統一する\n// FIXME: 要素に作用素を適用する関数であるGをclass化する\ntemplate <class Monoid, class OperatorMonoid>\nstruct LazySegmentTree {\n  typedef typename Monoid::value_t value_t;\n  typedef typename OperatorMonoid::value_t operator_t;\n  const Monoid monoid;\n  const OperatorMonoid op_monoid;\n  using G = function< value_t(value_t, operator_t) >;\n  const G g;\n  int n; // n_以上の最小の2冪\n  int height; // 木の深さ. n == pow(2, height)\n  vector<value_t> data;\n  vector<operator_t> lazy;\n  LazySegmentTree(const G g): monoid(), op_monoid(), g(g) {}\n\n  void init(int n_) {\n    n = 1;\n    height = 0;\n    while (n < n_) { n *= 2; ++height; }\n    data.assign(2*n, monoid.identity());\n    lazy.assign(2*n, op_monoid.identity());\n  }\n\n  void set(int k, value_t x) {\n    data[k + n] = x;\n  }\n\n  void build(const vector<value_t> &v) {\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) data[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      data[i] = monoid.merge(data[(i<<1)|0], data[(i<<1)|1]);\n  }\n\n  inline void propagate(int k) {\n    if(lazy[k] != op_monoid.identity()) {\n      lazy[2 * k + 0] = op_monoid.merge(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = op_monoid.merge(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = op_monoid.identity();\n    }\n  }\n\n  inline value_t reflect(int k) {\n    return lazy[k] == op_monoid.identity() ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(int k) {\n    while(k >>= 1) data[k] = monoid.merge(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, operator_t x) { // 0-indexed, [a, b)\n    thrust(a += n);\n    thrust(b += n - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = op_monoid.merge(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = op_monoid.merge(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  value_t query(int a, int b) { // 0-indexed, [a, b)\n    thrust(a += n);\n    thrust(b += n - 1);\n    value_t vl = monoid.identity(), vr = monoid.identity();\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) vl = monoid.merge(vl, reflect(l++));\n      if(r & 1) vr = monoid.merge(reflect(--r), vr);\n    }\n    return monoid.merge(vl, vr);\n  }\n\n  value_t operator[](const int &k) {\n    return query(k, k + 1);\n  }\n};\n#line 3 \"test/aoj/../../datastructure/dual-segment-tree.cpp\"\n\n// 区間更新、一点取得がO(logN)でできるやつ\n// 定数倍は悪そうだが、似たコードをたくさん管理したくないのでLazySegmentTreeを使い回す\ntemplate <class OperatorMonoid>\nstruct DualSegmentTree {\n  typedef typename OperatorMonoid::value_t operator_t;\n  LazySegmentTree<OperatorMonoid, OperatorMonoid> lst;\n  DualSegmentTree() : lst([](operator_t a, operator_t b) { return OperatorMonoid().merge(a, b); }) {}\n  void build(const vector<operator_t> &v) { lst.build(v); }\n  void update(int a, int b, operator_t x) { lst.update(a, b, x); }\n  operator_t query(int a, int b) {\n    assert(a+1 == b); // 一点取得のみを認める\n    return lst.query(a, b);\n  }\n  operator_t operator[](const int &k) { return lst[k]; }\n};\n#line 6 \"test/aoj/DSL_2_D.test.cpp\"\n\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nusing p_bi = pair<bool, int>;\n\nint main() {\n  int n, q; cin >> n >> q;\n  // auto g=[](p_bi a, p_bi b) -> p_bi { return monoid::fill<int>().merge(a, b); };\n  // LazySegmentTree<monoid::fill<int>, monoid::fill<int>> st(g);\n  DualSegmentTree<monoid::fill<int>> st;\n  st.build(vector<p_bi>(n, {true, INT_MAX}));\n  for (int i = 0; i < q; ++i) {\n    int c; cin >> c;\n    if (c == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      st.update(s, t+1, {true, x});\n    }\n    else {\n      int s; cin >> s;\n      cout << st[s].second << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)INT_MAX)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nstruct segTree{\n\tvi val,lazy;\n\tvector<bool> lazyFlag;\n\tint N;\n\tsegTree():segTree(100000){}\n\tsegTree(int n){\n\t\tN=1;\n\t\twhile(N<n)N*=2;\n\t\tval.resize(N*2,INF);\n\t\tlazy.resize(N*2,0);\n\t\tlazyFlag.resize(N*2,false);\n\t}\n\t\n\tvoid eval(int k, int l, int r){\n\t\tif(lazyFlag[k]){\n\t\t\tval[k]=lazy[k];\n\t\t\tif(r-l>1){\n\t\t\t\tlazy[2*k]=lazy[2*k+1]=lazy[k];\n\t\t\t\tlazyFlag[2*k]=lazyFlag[2*k+1]=true;\n\t\t\t}\n\t\t\tlazyFlag[k]=false;\n\t\t}\n\t}\n\n\tvoid update(int a, int b, int x){return update(a,b,1,0,N,x);}\n\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\teval(k,l,r);\n\t\tif(r<=a or l>=b) return;\n\t\tif(a<=l and r<=b) {\n\t\t\tlazy[k]=x;\n\t\t\tlazyFlag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}else{\n\t\t\tint m=(l+r)/2;\n\t\t\tupdate(a,b,2*k,l,m,x);\n\t\t\tupdate(a,b,2*k+1,m,r,x);\n\t\t\tval[k]=min(val[2*k],val[2*k+1]);\n\t\t}\n\t}\n\t\n\tint minimum(int a, int b){return minimum(a,b,1,0,N);}\n\tint minimum(int a, int b, int k, int l, int r){\n\t\teval(k,l,r);\n\t\tif(r<=a or l>=b) return INF;\n\t\tif(a<=l and r<=b) return val[k];\n\t\tint m=(l+r)/2;\n\t\treturn min(minimum(a,b,k*2,l,m),minimum(a,b,k*2+1,m,r));\n\t}\t\n\t\n\tint getData(int k){return minimum(k,k+1);}\n};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,q;\n\twhile(cin>>n>>q){\n\t\tsegTree st(n);\n\t\trep(_,q){\n\t\t\tint c,s,t,x;\n\t\t\tcin>>c;\n\t\t\tif(c==0){\n\t\t\t\tcin>>s>>t>>x;\n\t\t\t\tst.update(s,t+1,x);\n\t\t\t} else {\n\t\t\t\tcin>>x;\n\t\t\t\tcout<<st.getData(x)<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 2147483647;\n\nstruct SegmentTree {\n    int n;\n    vector<int> heap;\n    \n    SegmentTree(int n): n(n) {\n        heap.assign(4 * n, INF);\n    }\n    \n    void update(int nodeId, int l, int r, int ql, int qr, int v) {\n        if (qr < l || ql > r) {\n            return;\n        }\n        else if (ql <= l && r <= qr) {\n            heap[nodeId] = v;\n        }\n        else {\n            pushdown(nodeId);\n            int m = l + (r - l)/2;\n            update(nodeId * 2, l, m, ql, qr, v);\n            update(nodeId * 2 + 1, m + 1, r, ql, qr, v);\n        }\n    }\n    \n    int query(int nodeId, int l, int r, int q) {\n        if (q < l || q > r) {\n            return -1;\n        }\n        else if (heap[nodeId] != -1) {\n            return heap[nodeId];\n        }\n        else {\n            int m = l + (r - l)/2;\n            return max(query(nodeId * 2, l, m, q), query(nodeId * 2 + 1, m + 1, r, q));\n        }\n    }\n    \n    void pushdown(int nodeId) {\n        //cout << \"push: \" << nodeId << endl;\n        if (heap[nodeId] != -1) {\n            heap[nodeId * 2] = heap[nodeId];\n            heap[nodeId * 2 + 1] = heap[nodeId];\n            heap[nodeId] = -1;   \n        }\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int ql, qr, v;\n            cin >> ql >> qr >> v;\n            st.update(1, 0, n -1, ql, qr, v);\n//            for (int i = 0; i < 4 * n; i++) {\n//                cout << i << \":\" << st.heap[i] << endl; \n//            }\n        }\n        else {\n            int pos;\n            cin >> pos;\n            cout << st.query(1, 0, n-1, pos) << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\ntemplate<typename T, typename U>\nclass SegmentTree{\n    int n;\n    int height;\n    vector<T> node;\n    vector<U> lazy;\n    vector<int> len;\n\n    using F = function<T(T, T)>;\n    using G = function<T(T, U)>;\n    using H = function<U(U, U)>;\n    using S = function<U(U, int)>;\n\n    F f;\n    G g;\n    H h;\n    S s;\n    T en;\n    U el;\n\n    void evaluate(int k){\n        if(lazy[k] == el){\n            return;\n        }\n\n        if(k < n){\n            lazy[k << 1] = h(lazy[k << 1], lazy[k]);\n            lazy[(k << 1) | 1] = h(lazy[(k << 1) | 1], lazy[k]);\n        }\n\n        node[k] = g(node[k], s(lazy[k], len[k]));\n        lazy[k] = el;\n\n        return;\n    }\n\n    void evaluate(int l, int r){\n        for(int i = height ; 0 < i ; --i){\n            evaluate(l >> i);\n            evaluate(r >> i);\n        }\n\n        return;\n    }\n\n    void update(int k){\n        evaluate(k << 1);\n        evaluate((k << 1) | 1);\n        node[k] = f(node[k << 1], node[(k << 1) | 1]);\n        return;\n    }\n\npublic:\n    SegmentTree(int n_, F f_, G g_, H h_, S s_, T en_, U el_){\n        init(n_, f_, g_, h_, s_, en_, el_);\n    }\n\n    SegmentTree(const vector<T>& dat, F f_, G g_, H h_, S s_, T en_, U el_){\n        build(dat, f_, g_, h_, s_, en_, el_);\n    }\n\n    void init(int n_, F f_, G g_, H h_, S s_, T en_, U el_){\n        n = 1;\n        height = 0;\n        while(n < n_){\n            n <<= 1;\n            ++height;\n        }\n        f = f_;\n        g = g_;\n        h = h_;\n        s = s_;\n        en = en_;\n        el = el_;\n\n        node.resize(n << 1);\n        fill(node.begin(), node.end(), en);\n        lazy.resize(n << 1);\n        fill(lazy.begin(), lazy.end(), el);\n\n        len.resize(n << 1);\n        fill(len.begin(), len.end(), 0);\n\n        for(int i = 0 ; i < n_ ; ++i){\n            len[i + n] = 1;\n        }\n\n        for(int i = n - 1 ; 0 < i ; --i){\n            len[i] = len[i << 1] + len[(i << 1) | 1];\n        }\n\n        return;\n    }\n\n    void build(const vector<T>& dat, F f_, G g_, H h_, S s_, T en_, U el_){\n        int n_ = (int)dat.size();\n\n        init(n_, f_, g_, h_, s_, en_, el_);\n\n        for(int i = 0 ; i < n_ ; ++i){\n            node[i + n] = dat[i];\n        }\n\n        for(int i = n - 1 ; 0 < i ; --i){\n            node[i] = f(node[i << 1], node[(i << 1) | 1]);\n        }\n\n        return;\n    }\n\n    void update(int l, int r, U x){\n        l += n;\n        r += n - 1;\n\n        evaluate(l, r);\n\n        int tl = l;\n        int tr = r;\n\n        ++r;\n        while(l < r){\n            if(l & 1){\n                lazy[l] = h(lazy[l], x);\n                evaluate(l++);\n            }\n            l >>= 1;\n            if(r & 1){\n                lazy[--r] = h(lazy[r], x);\n                evaluate(r);\n            }\n            r >>= 1;\n        }\n\n        while(tl >>= 1, tr >>= 1, tl){\n            if(lazy[tl] == el){\n                update(tl);\n            }\n            if(lazy[tr] == el){\n                update(tr);\n            }\n        }\n\n        return;\n    }\n\n    T get(int l, int r){\n        l += n;\n        r += n - 1;\n\n        evaluate(l, r);\n\n        T res = en;\n        ++r;\n        while(l < r){\n            if(l & 1){\n                evaluate(l);\n                res = f(res, node[l++]);\n            }\n            l >>= 1;\n            if(r & 1){\n                evaluate(--r);\n                res = f(res, node[r]);\n            }\n            r >>= 1;\n        }\n\n        return res;\n    }\n};\n\n#include<iostream>\n#include<unordered_map>\n\ntemplate<typename T>\nT gcd(T x, T y){\n    T r;\n    while(y){\n        r = x % y;\n        x = y;\n        y = r;\n    }\n    return x;\n}\n\ntemplate<typename T>\nint compress(vector<T> v, unordered_map<T, int> &zip, vector<T> &unzip){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    unzip.resize(v.size());\n    for(int i = 0, i_len = (int)v.size() ; i < i_len ; ++i){\n        zip[v[i]] = i;\n        unzip[i] = v[i];\n    }\n    return (int)v.size();\n}\n\nusing lint = long long;\n\nint main(){\n    int n, q, c, s, t, x;\n    cin >> n >> q;\n\n    SegmentTree<lint, lint> seg(n, [](lint l, lint r){ return min(l, r); }, [](lint l, lint r){ return r; },\n    [](lint l, lint r){ return r; }, [](lint l, int r){ return l; }, (1LL << 31) - 1, 1LL << 31);\n\n    while(q--){\n        cin >> c >> s;\n        if(c == 0){\n            cin >> t >> x;\n            seg.update(s, t + 1, x);\n        }else if(c == 1){\n            cout << seg.get(s, s + 1) << endl;\n        }\n\n        // cout << endl;\n        // cout << q << endl;\n        // for(int i = 0 ; i < n ; ++i){\n        //     cout << i << \" \" << seg.get(i, i + 1) << endl;\n        // }\n        // cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n\nint bucket[MAX/B][B];\nint udata[MAX/B], data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && udata[a/B] != -1){\n\t\t\tfor(int i = 0;i < MAX;i++)bucket[a/B][i] = udata[a/B];\n\t\t\tf1 = 0;udata[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != MAX-1){\n\t\tif(f2 && udata[b/B] != -1){\n\t\t\tfor(int i = 0;i < MAX;i++)bucket[b/B][i] = udata[b/B];\n\t\t\tf2 = 0;udata[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tudata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(udata[x/B] != -1){\n\t\tfor(int i = 0;i < MAX;i++)bucket[x/B][i] = udata[x/B];\n\t\tudata[x/B] = -1;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(udata, udata+MAX/B, -1);\n\tfill(data, data+MAX/B, INF);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(i) sort(i.begin(),i.end())\n#define rSORT(i) sort(i.rbegin(),i.rend())\n#define fSORT(i,a) sort(i.begin(),i.end(),a)\n#define all(i) i.begin(),i.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nconstexpr int inf = INT_MAX;\nint main() {\n    init();\n\n    int n; cin >> n;\n    int sq = sqrt(n);\n    VI a(n, inf), b((n + sq - 1) / sq, -1);\n\n    int q; cin >> q;\n    while (q--) {\n        int type; cin >> type;\n        if (type == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            ++t;\n            for (int i = s; i < t;) {\n                int num = i / sq;\n                if (i % sq || t < min(i + sq, n)) {\n                    if (b[num] != -1) {\n                        for (int j = num * sq; j < min(sq * (num + 1), n); ++j) {\n                            a[j] = b[num];\n                        }\n                        b[num] = -1;\n                    }\n                    a[i] = x;\n                    ++i;\n                }\n                else {\n                    b[num] = x;\n                    i += sq;\n                }\n            }\n        }\n        else {\n            int idx; cin >> idx;\n            int num = idx / sq;\n            if (b[num] != -1) {\n                for (int i = num * sq; i < min(sq * (num + 1), n); ++i) {\n                    a[i] = b[num];\n                }\n                b[num] = -1;\n            }\n            print(a[idx]);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int64_t i64;\n\nconstexpr i64 llinf=4611686018427387903LL;\n\ntemplate <class T_>\nclass rupdq{\npublic:\n    i64 n;\n    i64 h;\n    T_ *lz;\n    void make(i64 N){\n        n=1;\n        h=0;\n        while(n<N){\n            n*=2;\n            h++;\n        }\n\t\tlz=new i64[n*2]{};\n        for(i64 i=0;i<n*2;i++) lz[i]=(T_)llinf;\n    }\n    void update(i64 A,i64 B,T_ X){\n        thrust(A+=n);\n        thrust(B+=n-1);\n        for(i64 l=A,r=B+1;l<r;l/=2,r/=2){\n            if(l%2==1){\n                lz[l]=X;\n                l++;\n            }\n            if(r%2==1){\n                r--;\n                lz[r]=X;\n            }\n        }\n    }\n    T_ query(i64 K){\n        thrust(K+=n);\n        return lz[K];\n    }\n    void thrust(i64 K){\n        for(i64 i=h;i>0;i--){\n            i64 k=K>>i;\n            if(lz[k]==(T_)llinf) continue;\n            lz[k*2]=lz[k];\n            lz[k*2+1]=lz[k];\n            lz[k]=(T_)llinf;\n        }\n    }\n};\n\nint main(void){\n    i64 n,q;\n    scanf(\"%lli%lli\",&n,&q);\n    rupdq<i64> r;\n    r.make(n);\n    for(i64 i=0;i<q;i++){\n        i64 c;\n        scanf(\"%lli\",&c);\n        if(c==0){\n            i64 s,t,x;\n            scanf(\"%lli%lli%lli\",&s,&t,&x);\n            r.update(s,t+1,x);\n        }\n        if(c==1){\n            i64 j;\n            scanf(\"%lli\",&j);\n            j=r.query(j);\n            if(j==llinf) printf(\"2147483647\\n\");\n            else printf(\"%lli\\n\",j);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define N 131072 //100000\n#define MAXVAL 2147483647 //((long int) ((unsigned long) (1 << 31) - 1))  //*2\nint min(int a, int b){return a>b?b:a;}\nint data[2*131072+100];      //the size of array, for present the tree\n\n//range update and single query\n\n/*\nalways binary [node_left,node_right]\n*/ \nvoid update(int update_left, int update_right, int x, int current_node,int node_left,int node_right){\n\t//not in the range\n\tif(update_right<node_left||update_left>node_right){\n\t\treturn;\t\n\t}else if(update_left<=node_left&&update_right>=node_right){\n\t\tdata[current_node] = x;\n\t}else{\n\t\t//how to check if the\n\t\t//unfold the node\n\t\tif(data[current_node]!=-1){\n\t\t\tupdate(node_left, node_right,data[current_node],current_node*2+1,node_left,(node_left+node_right)/2);\n\t\t\tupdate(node_left, node_right,data[current_node],current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t\t\tdata[current_node]=-1;\n\t\t}\n\t\t//update \n\t\tupdate(update_left, update_right, x, current_node*2+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left, update_right, x, current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t}\n\t\n\t\n}\n//segment of thr last layer\n//I did notdeal with 0\nint search(int index){\n\tif(index==0) return data[index];\n\tif(index<0) return MAXVAL;\n\tif(data[index]!=MAXVAL) return data[index];\n\t\n\t\n\treturn search((index-1)/2);\n}\nint main(){\n\tint n, q;\n\t//FILE *fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\tint N = 1;\n\twhile(N<n) N = N<<1;\n\tfor(int i = 0; i<=2*N-2; i++){\n\t\tdata[i] = MAXVAL;\n\t}\n\t//printf(\"%d\",(-1/2));\n\tfor(int i = 0; i<q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tint a,b,c;\n\t\t\n\t\tif(temp == 0) {  //update\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tupdate(a,b,c,0,0,N-1);\n\t\t} else if(temp == 1){ //search\n\t\t\tscanf(\"%d\",&a);\n\t\t\tprintf(\"%d\\n\",search(a+N-1));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n//0-index 抽象化半開区間遅延セグツリー\ntemplate<typename T, typename E>\nclass segment_tree{\n    typedef function<T(T,T)> F; //要素に適用する演算\n    typedef function<T(T,E)> G; //作用素の適用\n    typedef function<E(E,E)> H; //作用素の合成\n    typedef function<E(E,int)> P;\nprivate:\n    int num_of_elm_;\n    vector<T> dat_, lazy_;\n    F f_;\n    G g_;\n    H h_;\n    P p_;\n    T ident_;\n    E op_ident_;\npublic:\n    segment_tree(int n, F f, G g, H h, P p, T ident, E op_ident):f_(f), g_(g), h_(h), p_(p), ident_(ident), op_ident_(op_ident){\n        num_of_elm_ = 1;\n        while(num_of_elm_<n)num_of_elm_*=2;\n        dat_ .resize(2*num_of_elm_,ident);\n        lazy_.resize(2*num_of_elm_,op_ident);\n    }\n    \n    void eval(int k, int len){\n        if(lazy_[k] == op_ident_)return ;\n        \n        if(k<num_of_elm_){\n            lazy_[k*2]=h_(lazy_[k*2], lazy_[k]);\n            lazy_[k*2+1]=h_(lazy_[k*2+1], lazy_[k]);\n        }\n        dat_[k] = g_(dat_[k],p_(lazy_[k], len));\n        lazy_[k] = op_ident_;\n    }\n    \n    T update(int L, int R, int val, int l=0, int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return dat_[k];\n        else if(L<=l && r<=R){\n            lazy_[k] = h_(lazy_[k], val);\n            return g_(dat_[k], p_(lazy_[k], r-l));\n        }\n        else{\n            return dat_[k] = f_(update(L,R,val,l,(l+r)/2,k*2), update(L,R,val,(l+r)/2,r,k*2+1));\n        }\n        \n    }\n    \n    T query(int L, int R,int l=0,int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return ident_;\n        else if(L<=l && r<=R){\n            return dat_[k];\n        }\n        else{\n            return f_(query(L,R,l,(l+r)/2,k*2), query(L,R,(l+r)/2,r,k*2+1));\n        }\n    }\n};\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    auto f = [](int a, int b){return min(a,b);};\n    auto g = [](int a, int b){return b;};\n    auto h = g;\n    auto p = [](int a, int len){return a;};\n    segment_tree<int,int> st(n, f, g, h, p, (1<<31)-1, -1);\n    rep(i,q){\n        int com;\n        cin>>com;\n        if(com==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            st.update(s,t+1,x);\n        }else{\n            int x;\n            cin>>x;\n            cout<<st.query(x,x+1)<<endl;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nstruct SD\n{\n\tint n;\n\tint lsize;\n\tint sn;\n\tvector<int> data;\n\tvector<int> lazyData;\n\n\tSD(int n) :n(n), lsize(sqrt(n)), sn(n / lsize + 1), data(n, 2147483647), lazyData(sn, -1){}\n\n\tvoid applyLazy(int k)\n\t{\n\t\tif (lazyData[k] == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = k*lsize; i < (min(n, (k + 1)*lsize)); i++)\n\t\t{\n\t\t\tdata[i] = lazyData[k];\n\t\t}\n\t\tlazyData[k] = -1;\n\t}\n\n\tvoid update(int t, int s, int v)\n\t{\n\t\tfor (int i = 0; i < sn; i++)\n\t\t{\n\t\t\tint l = i*lsize;\n\t\t\tint r = (i + 1)*lsize - 1;\n\n\t\t\tif (s < l || r < t)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (t <= l&&r <= s)\n\t\t\t{\n\t\t\t\tlazyData[i] = v;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplyLazy(i);\n\t\t\t\tfor (int j = t; j <= s; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[j] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int index)\n\t{\n\t\tint k = index / lsize;\n\t\tapplyLazy(k);\n\t\treturn data[index];\n\t}\n};\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tSD sd(n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tsd.update(s, t, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << sd.find(s) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(v) (v).begin(), (v).end()\ntypedef long long int lint;\nusing namespace std;\n\n//遅延セグメント木\n// ref:https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct segment_tree_lazy {\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    int sz, height;\n    vector<Monoid> data;\n    vector<OperatorMonoid> lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid e;\n    const OperatorMonoid id;\n    segment_tree_lazy(int _sz, const F _f, const G _g, const H _h,\n                      const Monoid& _e, const OperatorMonoid _id)\n        : f(_f), g(_g), h(_h), e(_e), id(_id) {\n        sz = 1, height = 0;\n        while (sz < _sz) sz <<= 1, height++;\n        data.assign(2 * sz, e);\n        lazy.assign(2 * sz, id);\n    }\n    void set(const int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n    void build() {\n        for (int i = sz - 1; i > 0; i--)\n            data[i] = f(data[i * 2], data[i * 2] + 1);\n    }\n    Monoid reflect(int k) {\n        return lazy[k] == id ? data[k] : g(data[k], lazy[k]);\n    }\n    void propagate(int k) {\n        if (lazy[k] != id) {\n            lazy[2 * k] = h(lazy[2 * k], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = id;\n        }\n    }\n    void recalc(int k) {\n        while (k >>= 1) data[k] = f(data[2 * k], data[2 * k + 1]);\n    }\n    //自分より上にあるやつ全てに対して上から順にpropagate\n    void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n    // a~bにxを作用させる\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz), thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), l++;\n            if (r & 1) r--, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a), recalc(b);\n    }\n    Monoid query(int a, int b) {\n        thrust(a += sz), thrust(b += sz - 1);\n        Monoid L = e, R = e;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) L = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    segment_tree_lazy<int> seg(\n        n, [](int a, int b) { return min(a, b); },\n        [](int a, int b) { return b == INT_MAX ? a : b; },\n        [](int a, int b) { return b == INT_MAX ? a : b; }, INT_MAX, INT_MAX);\n    for (int i = 0; i < q; i++) {\n        int t;\n        cin >> t;\n        if (t) {\n            int k;\n            cin >> k;\n            cout << seg.query(k, k + 1) << endl;\n        } else {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n  int sq = sqrt(n);\n  ll lazy[sq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(t >= sq*sq && s < sq*sq){\n\t//cout << \"deug\" << endl;\n\tfill_n(a+sq*sq,t%sq+1,x);\n\tt = sq*sq-1;\n      }\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tfill_n(a+s,t-s+1,x);\n\t//cout << \"debug1\" <<endl;\n      }\n      else if(t/sq != s/sq && (t-s) <= 2*sq){\n\tfill_n(a+s,t-s+1,x);\n\t//cout << \"debug2\" << endl;\n      }\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tfill_n(a+s,f-s,x);\n\tf = f/sq;\n\tto = to/sq;\n\tfill_n(lazy+f,to-f+1,x);\n\t\n      }\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      if(te > sq-1){\n\tcout << a[x] << endl;\n      }\n      else if(lazy[te] < 0){\n\tcout << a[x] << endl;\n      }\n      else{\n\tfill_n(a+te*sq,sq+1,lazy[te]);\n\tcout << a[x] << endl;\n      }\n      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n - 1; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i <= n; i++)\n#define FORR(i, m, n) for(int i = m; i >= n; i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n \nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing P = pair<ll, ll>;\n\n\nint B = 320;\n// バケット i は [i*B, (i+1)*B) の記録を持つ\n// lazy[i] :=  バケットi の遅延を記録する\n// 遅延が-1 ... 制約よりそんなことは発生しないことを利用して, これを遅延の単位元とできる\n// i.e. lazy[i] == -1 def 消化時に何も伝播させないという遅延を与えるとみなす\nvector<int> lazy(B, -1), a(100000, (1LL << 31) - 1);\n \n// a_s, ..., a_t を x に変更する\nvoid update(int s, int t, int x)\n{\n    // s の属するバケット, t の属するバケット\n    int st = s / B, gt = t / B;\n\n    // st や gt に遅延が存在するとき更新前に消化しておく\n    // 遅延はパケットごとに考えるから, 遅延が存在⇔パケット内は全て等しい値で更新されている\n    // 区間に被覆されるパケットについてはこのあと新しい値へ更新されるので消化しなくてOK\n    if (lazy[st] != -1){\n        for (int i = st * B; i < (st + 1) * B; i++) a[i] = lazy[st];\n        lazy[st] = -1;\n    }\n    if (lazy[gt] != -1){\n        for (int i = gt * B; i < (gt + 1) * B; i++) a[i] = lazy[gt];\n        lazy[gt] = -1;\n    }\n    //... || ... s ... t ... || ...\n    //更新が同一パケット内で済むなら直接更新しても間に合う\n    if (st == gt){\n        for (int i = s; i <= t; i++) a[i] = x;\n    }\n\n    //... s ... || (被覆されるパケット) || ... t ...\n    else{\n        //端が属するパケット内は直接更新\n        for (int i = s; i < (st + 1) * B; i++) a[i] = x;\n        for (int i = gt * B; i <= t; i++) a[i] = x;\n\n        //区間に被覆されるパケットについては更新を遅延に残す\n        for (int i = st + 1; i < gt; i++){\n            lazy[i] = x;\n        }\n    }\n}\n \n// a_i を返す\nint find(int s){\n    int st = s / B;\n    //遅延を処理する\n    if (lazy[st] != -1){\n        for (int i = st * B; i < (st + 1) * B; i++) a[i] = lazy[st];\n        lazy[st] = -1;\n    }\n    return a[s];\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    REP(i, q){\n        int type;\n        cin >> type;\n        if(type == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            update(s, t, x);\n        }\n        else{\n            int s;\n            cin >> s;\n            cout << find(s) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*RMQ  update:O(logN)  query:O(lonN)*/\nconst int MAX_N = 1<<17;\nint n,dat[2*MAX_N-1];\n\n//?????????\nvoid init(int n_){\n  //????´???°n???2???????????????\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=INT_MAX;\n}\n\n//[a,b)???????°????????±???????\n//query(a,b,0,0,n)\nvoid update(int a,int b,int x=-1,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return ;\n  if(a<=l&&r<=b){\n    if(x>=0)dat[k]=x;\n    return;\n  }\n  \n  if(dat[k]!=INT_MAX)dat[k*2+1]=dat[k*2+2]=dat[k];\n  dat[k]=INT_MAX;\n  update(a,b,x,k*2+1,l,(l+r)/2);\n  update(a,b,x,k*2+2,(l+r)/2,r);\n}\n\nint main(){\n  int q;\n  cin>>n>>q;\n  init(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd==0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      update(s,t+1,x);\n    }\n    else {\n      int idx;\n      cin>>idx;\n      update(idx,idx+1);\n      cout <<dat[idx+n-1]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector <int> res;\n  ll a[n];\n  int sq = sqrt(n);\n  int nsq = n/sq+1;\n  if(n%sq == 0){\n    nsq = n/sq;\n  }\n  ll lazy[nsq];\n  fill(a,a+n,2147483647);\n  fill(lazy,lazy+n/sq,-1);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n\n      /*if(s == t){\n\ta[s] = x;\n\t}*/\n      if(t/sq == s/sq){\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(t-s+1 == sq){\n\t  lazy[t/sq] = x;\n\t}\n\telse{\n\t  fill_n(a+s,t-s+1,x);\n\t}\n\t//cout << \"debug1\" <<endl;\n      }\n\n      else{\n\t//cout << \"debug3\" << endl;\n\tint f = s,to = t;\n\twhile(to%sq != (sq - 1)){\n\t  to--;\n\t}\n\twhile(f%sq != 0){\n\t  f++;\n\t}\n\tif(lazy[t/sq] >= 0){\n\t  fill_n(a+(t/sq)*sq,sq,lazy[t/sq]);\n\t}\n\tif(lazy[s/sq] >= 0){\n\t  fill_n(a+(s/sq)*sq,sq,lazy[s/sq]);\n\t}\n\tfill_n(a+to+1,t-to,x);\n\tlazy[t/sq] = -1;\n\tfill_n(a+s,f-s,x);\n\tlazy[s/sq] = -1;\n\tf = f/sq;\n\tto = to/sq;\n\tif(f <= to){\n\t  fill_n(lazy+f,to-f+1,x);\n\t}\n\t\n      }\n      /*REP(i,n)\n\tcout << a[i] << \"  \";\n\tcout << endl;*/\n    }\n    else{\n      int x;\n      cin >> x;\n      int te = x / sq;\n      \n      if(lazy[te] < 0){\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n      }\n      else{\n\tfill_n(a+te*sq,sq,lazy[te]);\n\tlazy[te] = -1;\n\t//cout << a[x] << endl;\n\tres.pb(a[x]);\n\n      }\n      \n    }\n    \n  }\n  for(int i = 0;i < res.size();i++){\n    cout << res[i] << endl;\n  }\n  //cout << res.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nconst ll INF = 1LL << 60; //MAX 9223372036854775807\n//https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_D\n//区間加算　区間和クエリ\n//演算の定義\nauto query = [](ll x, ll y) { return x+y; };\n//単位元\nconst ll unit = 0;\nstruct LazySegTree\n{\nprivate:\n  ll n;\n  vector<ll> node,lazy;\n\npublic:\n  LazySegTree(vector<ll> v)\n  {\n    node.resize((1LL << 64 - __builtin_clzll(v.size())) * 2 - 1, unit); \n    lazy.resize((1LL << 64 - __builtin_clzll(v.size())) * 2 - 1,-1); \n    n = 1LL << 64 - __builtin_clzll(v.size());\n    for (ll i = 0; i < v.size(); i++)\n      node[i + n - 1] = v[i]; //最下段から構築\n    for (ll i = n - 2; i >= 0; i--)\n      node[i] = query(node[2 * i + 1], node[2 * i + 2]);\n  }\n  \n  // k 番目のノードについて遅延評価を行う\n  void eval(int k, int l, int r){ \n    // 遅延配列が空でない場合、自ノード及び子ノードへの\n    // 値の伝播が起こる\n    if (lazy[k] != -1){\n      node[k] = lazy[k];\n      // 最下段かどうかのチェックをしよう\n      // 子ノードは親ノードの 1/2 の範囲であるため、\n      // 伝播させるときは半分にする\n      if (r - l > 1){\n        lazy[2 * k + 1] = lazy[k] / 2;\n        lazy[2 * k + 2] = lazy[k] / 2;\n      }\n      // 伝播が終わったので、自ノードの遅延配列を空にする\n      lazy[k] = -1;\n    }\n  }\n\n  void update(int a, int b, ll x, int k = 0, int l = 0, int r = -1){\n    if (r < 0)\n      r = n;\n    // k 番目のノードに対して遅延評価を行う\n    eval(k, l, r);\n    // 範囲外なら何もしない\n    if (b <= l || r <= a)\n      return;\n    // 完全に被覆しているならば、遅延配列に値を入れた後に評価\n    if (a <= l && r <= b){\n      lazy[k]= (r - l) * x;\n      eval(k, l, r);\n    }\n    // そうでないならば、子ノードの値を再帰的に計算して、\n    // 計算済みの値をもらってくる\n    else{\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = node[2 * k + 1] + node[2 * k + 2];\n    }\n  }\n\n  // 要求区間 [a, b) 中の要素の和を答える k := 自分がいるノードのインデックス 対象区間は [l, r) にあたる\n  ll get(ll a, ll b, ll k = 0, ll l = 0, ll r = -1)\n  {\n    // 最初に呼び出されたときの対象区間は [0, n)\n    if (r < 0)\n      r = n;\n    // 要求区間と対象区間が交わらない -> 適当に返す\n    if (r <= a || b <= l)\n      return unit;\n    // 要求区間が対象区間を完全に被覆 -> 対象区間を答えの計算に使う\n    // 関数が呼び出されたら評価！\n    eval(k, l, r);\n    if (a <= l && r <= b)\n      return node[k];\n    // 要求区間が対象区間の一部を被覆 -> 子について探索を行う\n    // 左側の子を vl ・ 右側の子を vr としている\n    // 新しい対象区間は、現在の対象区間を半分に割ったもの\n    ll vl = get(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll vr = get(a, b, 2 * k + 2, (l + r) / 2, r);\n    return query(vl, vr);\n  }\n};\n\nint main()\n{\nll n , q ;\ncin >> n >> q ;\n\nvector<ll> t(n,(1LL<<31)-1);\nLazySegTree s(t);\nvector<ll> ans;\nrep(i,q){\n  ll a  ;\n  cin >> a  ;\n  if(!a){\n    ll b , c , d ;\n    cin >> b >> c >> d ;\n    s.update(b, c+1, d);\n  }\n  else {\n    ll b ;\n    cin >> b ;\n    ans.push_back(s.get(b, b+1));\n  }\n}\n\nrep(i,ans.size())cout<<ans[i]<<\"\\n\";\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n\t\t\tif(i < s_min || i > t_max){ cout << INT_MAX << endl; }\n            else{\n                for(j = m; j >= 0; j--){\n\t\t\t\t\tif(s[j] <= i && t[j] >= i){ cout << x[j] << endl; break; }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            if(s[m] < s_min) s_min = s[m];\n            if(t[m] > t_max) t_max = t[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\n// F : T x T -> T\n// G : T x E -> T\n// H : E x E -> E\ntemplate<typename T, typename E, typename F, typename G, typename H>\nstruct SegL{\nprivate:\n    vector<T> node;\n    vector<E> lazy;\n    int n;\n    T defVal;\n    E defOp;\n    F f;    // merge elements(T)\n    G g;    // update element(T) \n    H h;    // merge operators(E)\n\npublic:\n    SegL(int siz, T defVal, E defOp, F f, G g, H h) : defVal(defVal), defOp(defOp), f(f), g(g), h(h){\n        n = 1;\n        while(n < siz)  n *= 2;\n        node.resize(2*n-1, defVal);\n        lazy.resize(2*n-1, defOp);\n    }\n    SegL(vector<T> v, T defVal, E defOp, F f, G g, H h) : defVal(defVal), defOp(defOp), f(f), g(g), h(h){\n        n = 1;\n        while(n < v.size())  n *= 2;\n        node.resize(2*n-1, defVal);\n        for(int i = 0; i < v.size(); i++)   node[n-1+i] = v[i];\n        for(int i = n-2; i >= 0; i--)   node[i] = f(node[2*i+1], node[2*i+2]);\n    }\n\n    void eval(int k){\n        if(lazy[k] == defOp)    return;\n        if(k < n-1){\n            lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n        }\n        node[k] = g(node[k], lazy[k]);\n        lazy[k] = defOp;\n    }\n\n    void update(int a, int b, E x, int k=0, int l=0, int r=-1){\n        if(r < 0)   r = n;\n        eval(k);\n        if(b <= l || r <= a){\n            return;\n        }else if(a <= l && r <= b){\n            lazy[k] = h(lazy[k], x);\n            //eval(k);    // needless?\n        }else{\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0)   r = n;\n        eval(k);\n        if(b <= l || r <= a)    return defVal;\n        if(a <= l && r <= b)    return node[k];\n        T lx = query(a, b, 2*k+1, l, (l+r)/2);\n        T rx = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(lx, rx);\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    auto f = [](int x, int y)->int{return min(x, y);};\n    auto g = [](int x, int y)->int{return y==-1 ? x : y;};\n    auto h = [](int x, int y)->int{return y==-1 ? x : y;};\n    int defv = INT_MAX;\n    int defop = -1;\n    SegL<int, int, decltype(f), decltype(g), decltype(h)> seg(n, defv, defop, f, g, h);\n    while(q--){\n        int op;\n        cin >> op;\n        if(op == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }else{\n            int i;\n            cin >> i;\n            cout << seg.query(i, i+1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<pair<ll,ll> > vpll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vc> vvc;\ntypedef vector<vs> vvs;\ntypedef vector<vll> vvll;\ntypedef map<int,int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(ll i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define arep(i,v) for(auto i : v)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define fi first\n#define se second\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ntemplate <class T> inline void dump(T &v){irep(i, v){cout<<*i<<((i==--v.end())?'\\n':' ');}}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconstexpr ll LLINF = 1LL<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-11;\n\ntemplate <typename T>\nclass Sum {\npublic:\n    // 単位元\n    T unit;\n    \n    Sum(void) {\n        // 単位元\n        unit = 0;\n    }\n\n    // 演算関数\n    T calc(T a, T b) {\n        return a + b; \n    }\n};\n\ntemplate <typename T>\nstruct Min {\npublic:\n    // 単位元\n    T unit;\n    \n    Min(void) {\n        // 単位元\n        unit = INF;\n    }\n\n    // 演算関数\n    T calc(T a, T b) {\n        return min(a, b); \n    }\n};\n\ntemplate <typename T, class MONOID>\nclass SegmentTree {\npublic:\n    // セグメント木の葉の要素数\n    int n;\n\n    // セグメント木\n    vector<T> tree;\n    vector<T> time;\n\n    // モノイド\n    MONOID mono;\n\n    SegmentTree(vector<T> &v) : n(1 << (int)ceil(log2(v.size()))), tree(vector<T>(n << 1,-1)), time(vector<T>(n << 1,-1)) {\n    }\n\n    // k番目の値(0-indexed)をxに変更\n    int get(int k) {\n        k += n;\n        int res = tree[k];\n        int maxTime=time[k];\n        for(k = k >> 1; k > 0; k >>= 1){\n            if(time[k]>maxTime){\n                res=tree[k];\n                maxTime=time[k];\n            }\n        }\n        return res;\n    }\n\n    // [l, r)の最小値(0-indexed)を求める．\n    void update(int l, int r, T x, int t) {\n        l += n;\n        r += n;\n        while(l < r) {\n            if(l & 1) {\n                tree[l]=x;\n                time[l]=t;\n                l++;\n            }\n            if(r & 1) {\n                tree[r-1]=x;\n                time[r-1]=t;\n                r--;\n            }\n            l >>= 1;\n            r >>= 1;\n        }\n    }\n\n    T operator[](int k) {\n        // st[i]で添字iの要素の値を返す\n        if(k - n >= 0 || k < 0) {\n            return -INF;\n        }\n        return tree[tree.size() - n + k];\n    }\n\n    void show(void) {\n        int ret = 2;\n        for(int i = 1; i < 2*n; ++i) {\n            if(tree[i] == mono.unit) cout << \"UNIT \";\n            else cout << tree[i] << \" \";\n            if(i == ret - 1) {\n                cout << endl;\n                ret <<= 1;\n            }\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    \n    int n,q;\n    cin>>n>>q;\n    vi v(n,-1);\n    SegmentTree<int,Sum<int>> st(v);\n    rep(i,q){\n        int com;\n        cin>>com;\n        if(com==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            st.update(s,t+1,x, i);\n        }\n        else {\n            int idx;\n            cin>>idx;\n            int ans=st.get(idx);\n            \n            if(ans!=-1)fin(ans);\n            else fin(2147483647);\n        }\n        // st.show();\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        cout << x[j] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n// 完成版。\n\nint tree[(1 << 18)];\n\nvoid Update(int s, int t, int m, int left = 0, int right = (1 << 17), int key = 0){\n    if(t < left || right <= s) return;\n    if(s <= left && right - 1 <= t){ tree[key] = max(tree[key], m); return; }\n    Update(s, t, m, left, (left + right) / 2, 2 * key + 1);\n    Update(s, t, m, (left + right) / 2, right, 2 * key + 2);\n}\n\nint Find(int i){\n    i += (1 << 17) - 1;\n    int m = tree[i];\n    while(i){\n        i = (i - 1) / 2;\n        m = max(tree[i], m);\n    };\n    return m;\n}\n\nint main(){\n    int i;\n    for(i = 0; i < (1 << 18); i++) tree[i] = 0;\n    int n, q;\n    int x[100000];\n    for(i = 0; i < 100000; i++) x[i] = INT_MAX;\n    int s, t, value, m;\n    m = 1;\n    \n    cin >> n >> q;\n    int query;\n    while(q){\n        q--;\n        cin >> query;\n        if(query){\n            cin >> i;\n            cout << x[Find(i)] << endl;\n        }else{\n            cin >> s >> t >> value;\n            x[m] = value;\n            Update(s, t, m);\n            m++;\n        }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\n//const int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> node, lazy;\n    std::function<T (T,T)> op;\n    T unit;\n\npublic:\n    enum Mode {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, Mode mode) : array_size(v.size()) {\n        if (mode == RangeMinimumQuery) {\n            unit = INT_MAX;\n            op = [](T a, T b) { return std::min(a, b); };\n        }\n        else if (mode == RangeMaximumQuery) {\n            unit = -INT_MAX;\n            op = [](T a, T b) { return std::max(a, b); };\n        }\n        else if (mode == RangeSummationQuery) {\n            unit = 0;\n            op = [](T a, T b) { return a + b; };\n        }\n        else {\n            assert(false);\n        }\n\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        node.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, -1);\n\n        for (int i = 0; i < array_size; ++i) {\n            node[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            node[i] = op(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    // array[idx]\n    // log(N)\n    T access(int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] = x\n    // log(N)\n    void update(int idx, T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) = x\n    // log(N)\n    void update(int left, int right, T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(int left, int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(const int a, const int b, const LL x, const int k, const int l, const int r) {\n        eval(k, l, r);\n\n        // 範囲外\n        if (r <= a or b <= l) {\n            return node[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = x;\n            eval(k, l, r);\n            return node[k];\n        }\n        // 一部含む\n        else {\n            T vl = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T vr = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return node[k] = op(vl, vr);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(int a, int b, int k, int l, int r) {\n        eval(k, l, r);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return node[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return op(vl, vr);\n        }\n    }\n\n    void eval(int k, int l, int r) {\n        if (lazy[k] == -1) {\n            return;\n        }\n\n        node[k] = lazy[k];\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        lazy[k] = -1;\n    }\n};\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N, 2147483647);\n\n    LazySegmentTree<LL> lst(v, LazySegmentTree<LL>::Mode::RangeMinimumQuery);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> i;\n            print(lst.access(i));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int a[100000];\n    const int max = pow(2, 31) - 1;\n    fill(a, a + 100000, max);\n    int n, q;\n    cin >> n >> q;\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            for (int j = s; j < t + 1; j++) {\n                a[j] = x;\n            }\n        }\n        else {\n            int i;\n            cin >> i;\n            cout << a[i] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\ntemplate <class Monoid> class dual_segment_tree {\n  using size_t = std::size_t;\n  using T = typename Monoid::value_type;\n\npublic:\n  using value_type = T;\n  using size_type = size_t;\n\nprivate:\n  static size_t lsb(const size_t x) { return __builtin_ctz(x); }\n  static size_t msb(const size_t x) { return 31 - __builtin_clz(x); }\n  static void add(T &x, const T y) { x = Monoid::operation(x, y); }\n\n  std::vector<T> tree;\n\n  void push(const size_t index) {\n    add(tree[index * 2], tree[index]);\n    add(tree[index * 2 + 1], tree[index]);\n    tree[index] = Monoid::identity;\n  }\n  void propagate(const size_t index) {\n    if (index == 0)\n      return;\n    const size_t lsb_ = lsb(index);\n    for (size_t h = msb(index); h != lsb_; h -= 1)\n      push(index >> h);\n  }\n\npublic:\n  dual_segment_tree() = default;\n  explicit dual_segment_tree(const size_t n) : tree(n * 2, Monoid::identity) {}\n\n  size_t size() const noexcept { return tree.size() / 2; }\n\n  T fold(size_t index) const {\n    assert(index < size());\n    index += size();\n    T ret = tree[index];\n    while (index != 1) {\n      index /= 2;\n      add(ret, tree[index]);\n    }\n    return ret;\n  }\n\n  void update(size_t first, size_t last, const T x) {\n    assert(first <= last);\n    assert(last <= size());\n    first += size();\n    last += size();\n    propagate(first);\n    propagate(last);\n    while (first != last) {\n      if (first % 2 != 0) {\n        add(tree[first], x);\n        first += 1;\n      }\n      first /= 2;\n      if (last % 2 != 0) {\n        last -= 1;\n        add(tree[last], x);\n      }\n      last /= 2;\n    }\n  }\n};\n\n#include <utility>\n\ntemplate <class T> class assign_monoid {\npublic:\n  using value_type = std::pair<T, bool>;\n\n  static constexpr value_type operation(const value_type &x,\n                                        const value_type &y) noexcept {\n    return y.second ? y : x;\n  }\n  static constexpr value_type identity = {T{}, false};\n};\ntemplate <class T>\nconstexpr typename assign_monoid<T>::value_type assign_monoid<T>::identity;\n\n#include <cstdio>\n\nint scan() {\n  int r = 0;\n  int c;\n  while ((c = getchar_unlocked() - '0') >= 0)\n    r = r * 10 + c;\n  return r;\n}\n\nint main() {\n  const int n = scan();\n  const int q = scan();\n\n  dual_segment_tree<assign_monoid<int>> dst(n);\n  dst.update(0, n, {2147483647, true});\n\n  for (int k = 0; k != q; k += 1) {\n    if (scan() == 0) {\n      const int s = scan();\n      const int t = scan() + 1;\n      const int x = scan();\n      dst.update(s, t, {x, true});\n    } else {\n      const int i = scan();\n      printf(\"%d\\n\", dst.fold(i).first);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 1000\n\nint bucket[MAX/B][1000];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && data[a/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n\t\t\tf1 = 0;data[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != 99){\n\t\tif(f2 && data[b/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n\t\t\tf2 = 0;data[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tdata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(data[x/B] != -1){\n\t\tfor(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n\t\tdata[x/B] = -1;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(data, data+MAX/B, -1);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n//0-index 抽象化半開区間遅延セグツリー\ntemplate<typename T, typename E>\nclass segment_tree{\n    typedef function<T(T,T)> F; //要素に適用する演算\n    typedef function<T(T,E)> G; //作用素の適用\n    typedef function<E(E,E)> H; //作用素の合成\n    typedef function<E(E,int)> P;\nprivate:\n    int num_of_elm_;\n    vector<T> dat_, lazy_;\n    F f_;\n    G g_;\n    H h_;\n    P p_;\n    T ident_;\n    E op_ident_;\npublic:\n    segment_tree(int n, F f, G g, H h, P p, T ident, E op_ident):f_(f), g_(g), h_(h), p_(p), ident_(ident), op_ident_(op_ident){\n        num_of_elm_ = 1;\n        while(num_of_elm_<n)num_of_elm_*=2;\n        dat_ .resize(2*num_of_elm_,ident);\n        lazy_.resize(2*num_of_elm_,op_ident);\n    }\n    \n    void eval(int k, int len){\n        if(lazy_[k] == op_ident_)return ;\n        \n        if(k<num_of_elm_){\n            lazy_[k*2]=h_(lazy_[k*2], lazy_[k]);\n            lazy_[k*2+1]=h_(lazy_[k*2+1], lazy_[k]);\n        }\n        dat_[k] = g_(dat_[k],p_(lazy_[k], len));\n        lazy_[k] = op_ident_;\n    }\n    \n    T update(int L, int R, int val, int l=0, int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return dat_[k];\n        else if(L<=l && r<=R){\n            lazy_[k] = h_(lazy_[k], val);\n            return g_(dat_[k], p_(lazy_[k], r-l));\n        }\n        else{\n            return dat_[k] = f_(update(L,R,val,l,(l+r)/2,k*2), update(L,R,val,(l+r)/2,r,k*2+1));\n        }\n        \n    }\n    \n    T query(int L, int R,int l=0,int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return ident_;\n        else if(L<=l && r<=R){\n            return dat_[k];\n        }\n        else{\n            return f_(query(L,R,l,(l+r)/2,k*2), query(L,R,(l+r)/2,r,k*2+1));\n        }\n    }\n};\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    auto f = [](int a, int b){return min(a,b);};\n    auto g = [](int a, int b){return b;};\n    auto h = g;\n    auto p = [](int a, int len){return a;};\n    segment_tree<int,int> st(n, f, g, h, p, (1LL<<31)-1, -1);\n    rep(i,q){\n        int com;\n        cin>>com;\n        if(com==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            st.update(s,t+1,x);\n        }else{\n            int x;\n            cin>>x;\n            cout<<st.query(x,x+1)<<endl;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1<<20)\n#define NIL -1\n\nstruct RUQ {\n\tint N;\n\tint a[N_SIZE];\n\tint seg[N_SIZE * 2];\n\tint lazy[N_SIZE * 2];\n\tint gt;\n\tvoid init(int n) {\n\t\tN = n;\n\t\tgt = 1;\n\t\twhile (N > gt)gt *= 2;\n\t\tREP(i, n)a[i] = (1LL << 31) - 1;\n\t\tREP(i, N_SIZE) {\n\t\t\tseg[i] = (1LL << 31) - 1;\n\t\t\tlazy[i] = NIL;\n\t\t}\n\t\tREP(i, n)seg[i + gt - 1] = a[i];\n\t}\n\n\tvoid lazy_evaluate(int k) {\n\t\tseg[k] = lazy[k];\n\t\tif (k < gt) {\n\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\tlazy[2 * k + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = NIL;\n\t}\n\n\t//[a,b)\n\tvoid update(int a, int b, int x) { update(a, b, 0, 0, gt, x); }\n\tvoid update(int a, int b, int k, int l, int r, int x) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b)lazy[k] = x;\n\t\telse {\n\t\t\tif (lazy[k] != NIL)lazy_evaluate(k);\n\t\t\tupdate(a, b, 2 * k + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, 2 * k + 2, (l + r) / 2, r, x);\n\t\t}\n\t}\n\n\t//[a,b)\n\tll query(int a, int b) { return query(a, b, 0, 0, gt); }\n\tll query(int a, int b, int k, int l, int r) {\n\t\tll res = NIL;\n\t\tif (r <= a || b <= l)return res;\n\t\tif (a <= l&&r <= b) {\n\t\t\tif (lazy[k] != NIL)lazy_evaluate(k);\n\t\t\treturn seg[k];\n\t\t}\n\t\telse {\n\t\t\tif (lazy[k] != NIL)lazy_evaluate(k);\n\t\t\tll num[2] = { query(a, b, 2 * k + 1, l, (l + r) / 2),\n\t\t\t\tquery(a, b, 2 * k + 2, (l + r) / 2, r) };\n\t\t\tREP(i, 2)if (num[i] != NIL)res = num[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid print() {\n\t\tREP(i, gt * 2)cout << \"!\" << i << \" \" << seg[i] << \" \" << lazy[i] << endl;\n\t}\n};\n\nRUQ ruq;\n\nint n, q;\n\nint main() {\n\tcin >> n >> q;\n\truq.init(n);\n\tREP(i, q) {\n\t\tint s, t, x;\n\t\tbool f;\n\t\tcin >> f;\n\t\tif (!f) {\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tcin >> x;\n\t\t\tcout << ruq.query(x, x + 1) << endl;\n\t\t}\n\t\t//ruq.print();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\ntemplate <class Monoid, class OperatorMonoid = Monoid> class LazySegmentTree {\n  using F = std::function<Monoid(Monoid, Monoid)>;\n  using G = std::function<Monoid(Monoid, OperatorMonoid, int)>;\n  using H = std::function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  private:\n    int n;\n    std::vector<Monoid> seg;\n    std::vector<OperatorMonoid> lazy;\n\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM1;\n\n    void lazyUpdate(int k, int l, int r) {\n      if(lazy[k] == OM1) return;\n\n      if(2 * k + 1 < 2 * n - 1) {\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n        lazy[2 * k + 2] = h(lazy[2 * k + 2], lazy[k]);\n      }\n      seg[k] = g(seg[k], lazy[k], r - l);\n      lazy[k] = OM1;\n    }\n\n  public:\n    LazySegmentTree(int sz, const F f, const G g, const H h, const Monoid &M1, const OperatorMonoid &OM1) : f(f), g(g), h(h), M1(M1), OM1(OM1) {\n      n = 1;\n      while(n < sz) n *= 2;\n      seg.resize(2 * n - 1, M1);\n      lazy.resize(2 * n - 1, OM1);\n    }\n\n    void update(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n      if(r < 0) r = n;\n\n      lazyUpdate(k, l, r);\n\n      if(b <= l || r <= a) return;\n\n      if(a <= l && r <= b) {\n        lazy[k] = h(lazy[k], x);\n        lazyUpdate(k, l, r);\n      }\n      else {\n        update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n        update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n        seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n      }\n    }\n\n    Monoid query(int a, int b, int k = 0, int l = 0, int r = -1) {\n      if(r < 0) r = n;\n\n      lazyUpdate(k, l, r);\n\n      if(b <= l || r <= a) return M1;\n      if(a <= l && r <= b) return seg[k];\n      Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n      Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n      return f(vl, vr);\n    }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n  LazySegmentTree<int> seg(n, [](int a, int b){ return min(a, b); },\n                              [](int a, int b, int len){ return b; },\n                              [](int a, int b){ return b; }, INT_MAX, INT_MAX);\n  rep(i, 0, q) {\n    int c;\n    cin >> c;\n    if(c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n    else {\n      int x;\n      cin >> x;\n      cout << seg.query(x, x + 1) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF 2147483647\nvector<pair<int,int> > a(300000,pair<int,int>(INF,0));\nint n,si;\nint find(int);\nvoid update(int,int,int,int,int,int,int);\n\nint main(){\n  int q,f;\n  si = 1;\n  cin >> n >> q;\n  for(int i = 0;;i++){\n    si*=2;\n    if(si >= n)break;\n  }\n  for(int i = 0;i<q;i++){\n    cin >> f;\n    if(f == 1){\n      int po,dat;\n      cin >> po;\n      dat = find(po);\n      cout << dat << endl;\n    }\n    else{\n      int st,go,d;\n      cin >> st >> go>>d;\n      update(st,go+1,0,0,si,d,i+1);\n    }\n  }\n  return 0;\n}\nint find(int p){\n  int ca = si-1+p;\n  pair<int,int> ma = a[ca];\n  while(ca>0){\n    ca=(ca-1)/2;\n    if(ma.second<a[ca].second){\n      ma=a[ca];\n    }\n  }\n  return ma.first;\n}\n\nvoid update (int s,int t,int k,int l,int r,int d,int ti){\n  int m=(l+r)/2;\n  if(s<=l&&r<=t){\n    a[k].first=d;\n    a[k].second=ti;\n    return;\n  }\n  else if(r<=s||t<=l)return;\n\n  else{\n    update(s,t,k*2+1,l,m,d,ti);\n    update(s,t,k*2+2,m,r,d,ti);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\ntemplate<typename Type>\nstruct SqrtDecomp {\n    int SIZE;\n    // node の前半には op2 を適用した値が入っているはずで、\n    // 後半には op1 を適用した値が入っているはず\n\n    // lazy は一様更新 → op1 を適用した値が入っているはず\n    vector<Type> node, lazy, need_upd;\n    Type (*op1) (Type x, Type y, int sz);\n    Type (*op2) (Type x, Type y);\n    Type I;\n\n    SqrtDecomp( vector<Type> vec,\n                Type (*g_op1) (Type x, Type y, int sz),\n                Type (*g_op2) (Type x, Type y),\n                Type X) {\n        int N = vec.size();\n        SIZE = 1; while(SIZE * SIZE < N) SIZE++;\n        I = X, op1 = g_op1, op2 = g_op2;\n\n        node.resize(SIZE*SIZE + SIZE, I);\n        lazy.resize(SIZE, I);\n        need_upd.resize(SIZE, 0);\n\n        for(int i=0; i<SIZE; i++) {\n            Type rep_val = I;\n            for(int j=0; j<SIZE && i*SIZE+j<N; j++) {\n                int idx = SIZE + (i*SIZE + j);\n                node[idx] = vec[j];\n                rep_val = op2(rep_val, node[idx]);\n            }\n            node[i] = rep_val;\n        }\n    }\n\n    void lazy_eval(int k) {\n        int l = SIZE*k, r = SIZE*(k+1);\n        if(need_upd[k]) {\n            Type seg_val = I;\n\n            // 該当する下のノードをまず更新\n            for(int i=l; i<r; i++) {\n                node[i] = op1(node[i], lazy[k], SIZE);\n                seg_val = op2(seg_val, node[i]);\n            }\n\n            // 上のノードを更新\n            node[k] = seg_val;\n        }\n        need_upd[k] = false;\n    }\n\n    void update(int l, int r, Type val) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // 左端の更新\n        for(int k=l; k<min(r, SIZE*(lidx+1)); k++) {\n            lazy_eval(lidx);\n            int idx = SIZE + k;\n            node[idx] = op1(node[idx], val, 1);\n            node[lidx] = op2(node[lidx], val);\n        }\n\n        if(lidx != ridx) {\n            // 真ん中 (lazy を更新)\n            for(int k=lidx+1; k<ridx; k++) {\n                lazy[k] = op1(lazy[k], val, SIZE);\n                need_upd[k] = true;\n            }\n\n            // 右端の更新\n            for(int k=SIZE*ridx; k<r; k++) {\n                lazy_eval(ridx);\n                int idx = SIZE + k;\n                node[idx] = op1(node[idx], val, 1);\n                node[ridx] = op2(node[ridx], val);\n            }\n        }\n    }\n\n    Type query(int l, int r) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // printf(\"lidx = %d, ridx = %d\\n\", lidx, ridx);\n        Type ret = I;\n        \n        // 左端の取得\n        for(int k=l; k<min(r, SIZE*(lidx+1)); k++) {\n            lazy_eval(lidx);\n            int idx = SIZE + k;\n            ret = op2(ret, node[idx]);\n        }\n\n        if(lidx != ridx) {\n            for(int k=lidx+1; k<ridx; k++) {\n                // 全体の値と lazy の値を考慮して値を計算\n                Type val = (need_upd[k] ? op1(node[k], lazy[k], SIZE) : node[k]);\n                ret = op2(ret, val);\n            }\n\n            for(int k=SIZE*ridx; k<r; k++) {\n                lazy_eval(ridx);\n                int idx = SIZE + k;\n                ret = op2(ret, node[idx]);\n            }\n        }\n\n        return ret;\n    }\n\n    void print_debug() {\n        printf(\"<< node >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %d\\n\", l, r, node[i]);\n        }\n        printf(\"lower bucket:\\n\");\n        for(int i=0; i<SIZE*SIZE; i++) {\n            int idx = SIZE + i;\n            printf(\"[%6d, %6d) -> %d\\n\", i, i+1, node[idx]);\n        }\n\n        printf(\"<< lazy >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %d\\n\", l, r, lazy[i]);\n        }\n        printf(\"\\n\");\n    }\n};\n\n/*\n// Range Minimum Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a, a+1, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a, b+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// Range Sum Query\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a-1, a, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a-1, b));\n        }\n        sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n// Range Update Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int x; scanf(\"%d\", &x);\n            printf(\"%d\\n\", sqr.query(x, x+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define MAX 500005\n//#define INF 1001001001\n\ntemplate <typename T>\nstruct RMQ {\n  const T INF = numeric_limits<T>::max();\n  int n;\n  vector<T> dat, lazy;\n  RMQ(int _n) : n(), dat(_n*4,INF), lazy(_n*4,INF) {\n    int x = 1;\n    while (x < _n) x <<= 1;\n    n = x;\n  }\n\n  void update(int i, T x) {\n    i += n-1;\n    dat[i] = x;\n    while (i > 0) {\n      i = (i-1)/2;\n      dat[i] = min(dat[i*2+1],dat[i*2+2]);\n    }\n  }\n\n  T query(int a, int b, int k, int l, int r) {\n    eval(k);\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat[k];\n    T mid = (l+r)>>1;\n    T vl = query(a,b,k*2+1,l,mid);\n    T vr = query(a,b,k*2+2,mid,r);\n    return min(vl,vr);\n  }\n  T query(int a, int b) { return query(a,b,0,0,n); }\n\n  void eval(int k) {\n    if (lazy[k] == INF) return;\n    if (k < n-1) lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n    dat[k] = lazy[k];\n    lazy[k] = INF;\n  }\n\n  void update(int a, int b, int x, int k, int l, int r) {\n    eval(k);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] = x;\n      eval(k);\n    } else {\n      int mid = (l+r)>>1;\n      update(a,b,x,k*2+1,l,mid);\n      update(a,b,x,k*2+2,mid,r);\n      dat[k] = min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  void update(int a, int b, int x) { update(a,b,x,0,0,n); }\n\n  inline T operator[](int a) { return query(a,a+1); }\n};\n\nint main(int, char**)\n{\n  int n, q;\n  cin >> n >> q;\n  RMQ<int> rmq(n);\n\n  vector<int> ans;\n  rep(i,q) {\n    int command; cin >> command;\n    if (command == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      rmq.update(s,t+1,x);\n    } else if (command == 1) {\n      int i; cin >> i;\n      ans.push_back(rmq[i]);\n    }\n  }\n  for (auto a : ans) cout << a << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"unroll-loops\")\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace::std;\n//struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n__attribute__((constructor))\nvoid init(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(15);\n}\n// random_device rd;\n// mt19937 mt(rd());\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/dynamic_bitset.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n// #include <boost/math/tools/minima.hpp>\n// using boost::math::tools::brent_find_minima;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\n// #include <boost/unordered_map.hpp>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\ntemplate<typename T=long long>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pqueue =__gnu_pbds::priority_queue<T, less<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntemplate<typename T>using Vec=vector<T>;\ntemplate<typename T>using Mat=vector<vector<T>>;\ntemplate<typename T>using Mat3=vector<vector<vector<T>>>;\ntemplate<typename T>using Mat4=vector<vector<vector<vector<T>>>>;\ntemplate<typename S,typename T>using pvec=vector<pair<S,T>>;\ntemplate<typename S,typename T>using pmat=vector<vector<pair<S,T>>>;\ntemplate<typename S,typename T>using pmat3=vector<vector<vector<pair<S,T>>>>;\ntemplate<typename S,typename T>using pmat4=vector<vector<vector<vector<pair<S,T>>>>>;\ntemplate<typename... T>using tvec=vector<tuple<T...>>;\ntemplate<typename... T>using tmat=vector<vector<tuple<T...>>>;\ntemplate<typename... T>using tmat3=vector<vector<vector<tuple<T...>>>>;\ntemplate<typename... T>using tmat4=vector<vector<vector<vector<tuple<T...>>>>>;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n//#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n//#define MOD 998244353LL\n//#define MOD 1000000007LL\n#define MOD 65537LL\n#define endl \"\\n\"\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(int i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(int i=0;i<t.size();i++)output(t[i]);}\nauto Y=[&](auto f){return[&](auto... args){return f(f, args...);};};\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ntemplate<typename T=lint>inline T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<typename T=lint>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<typename T>inline T minq(T a,T b){return min(a,b);}\ntemplate<typename T>inline T maxq(T a,T b){return max(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={-1,1,0,0,1,1,-1,-1};\nconst vector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\n\ntemplate<typename T,typename E>\nclass lazy_segment_tree{\n    template<typename Getter>\n    class iterator{\n        int i;\n        Getter getter;\n        public:\n        iterator(const int& i,const Getter& getter):i(i),getter(getter){}\n        inline auto operator*()noexcept{return getter(i);}\n        inline constexpr iterator operator++()noexcept{++i;return *this;}\n        inline constexpr iterator operator--()noexcept{--i;return *this;}\n        inline constexpr iterator operator++(int n)noexcept{++i;return *this;}\n        inline constexpr iterator operator--(int n)noexcept{--i;return *this;}\n        inline constexpr iterator operator+=(const int& rhs)noexcept{i+=rhs;return *this;}\n        inline constexpr iterator operator-=(const int& rhs)noexcept{i-=rhs;return *this;}\n        inline constexpr iterator operator+(const int& rhs)const noexcept{return iterator(*this)+=rhs;}\n        inline constexpr iterator operator-(const int& rhs)const noexcept{return iterator(*this)-=rhs;}\n        inline constexpr bool operator!=(const iterator& rhs)const noexcept{return i!=rhs.i;}\n        inline constexpr bool operator==(const iterator& rhs)const noexcept{return i==rhs.i;}\n    };\n    inline auto make_iterator(const int& i)noexcept{\n        static auto getter=[this](const int& i){return get(i,i+1);};\n        return iterator<decltype(getter)>(i,getter);\n    }\n    int n=1,sz;\n    T* node;\n    E* lazy;\n    int ids[64];\n    int idx;\n    T et;E ee;\n    void eval(const auto& t)noexcept{\n        if(lazy[t]==ee)return;\n        node[t]=h(node[t],lazy[t],n>>(int)(log2(t+1)));\n        if(t<n-1){\n            lazy[(t<<1)+1]=g(lazy[(t<<1)+1],lazy[t]);\n            lazy[(t<<1)+2]=g(lazy[(t<<1)+2],lazy[t]);\n        }\n        lazy[t]=ee;\n    }\n    void get_eval(auto l,auto r)noexcept{\n        l+=n;r+=n;\n        const int lm=(l/(l&-l))>>1;\n        const int rm=(r/(r&-r))>>1;\n        idx=0;\n        while(r>l){\n            if(r<=rm&&r)ids[idx++]=r-1;\n            if(l<=lm&&l)ids[idx++]=l-1;\n            l>>=1;r>>=1;\n        }\n        while(l){\n            ids[idx++]=l-1;\n            l>>=1;\n        }\n    }\n\tpublic:\n    lazy_segment_tree(const vector<T>& v,const T& et,const E& ee):sz(v.size()),et(et),ee(ee){\n        while(n<v.size())n<<=1;\n        node=new T[(n<<1)-1];\n        lazy=new E[(n<<1)-1];\n        for(int i=(int)v.size()+n-1;i<(n<<1)-1;i++)node[i]=et;\n        for(int i=0;i<(n<<1)-1;i++)lazy[i]=ee;\n        for(int i=0;i<(int)v.size();i++)node[i+n-1]=v[i];\n        for(int i=n;i>=0;i--)node[i]=f(node[(i<<1)+1],node[(i<<1)+2]);\n    }\n    lazy_segment_tree(const auto& sz,const T& et,const E& ee):sz(sz),et(et),ee(ee){\n        while(n<sz)n<<=1;\n        node=new T[(n<<1)-1];\n        lazy=new E[(n<<1)-1];\n        for(int i=0;i<(n<<1)-1;i++)node[i]=et;\n        for(int i=0;i<(n<<1)-1;i++)lazy[i]=ee;\n    }\n    constexpr void update(auto l,auto r,E val)noexcept{\n        get_eval(l,r);\n        for(int i=idx-1;i>=0;i--)eval(ids[i]);\n        l+=n;r+=n;\n        while(l<r){\n            if(l&1){lazy[l-1]=g(lazy[l-1],val);eval(l-1);++l;}\n            if(r&1){--r;lazy[r-1]=g(lazy[r-1],val);eval(r-1);}\n            l>>=1;r>>=1;\n        }\n        for(int i=0;i<idx;i++){\n            eval((ids[i]<<1)+1);\n            eval((ids[i]<<1)+2);\n            node[ids[i]]=f(node[(ids[i]<<1)+1],node[(ids[i]<<1)+2]);\n        }\n    }\n    T get(auto l,auto r){\n        get_eval(l,r);\n        for(int i=idx-1;i>=0;i--)eval(ids[i]);\n        l+=n;r+=n;\n        T res=et;\n        while(l<r){\n            if(l&1){eval(l-1);res=f(res,node[l-1]);l++;}\n            if(r&1){--r;eval(r-1);res=f(res,node[r-1]);}\n            l>>=1;r>>=1;\n        }\n        return res;\n    }\n    inline auto begin()noexcept{return make_iterator(0);}\n    inline auto end()noexcept{return make_iterator(sz);}\n\tprivate:\n\tT f(const T& a,const T& b){\n\t\treturn update(a,b);\n\t}\n\tT h(const T& a,const E& b,const auto& sz){\n\t\treturn update(a,b);\n\t}\n\tE g(const E& a,const E& b){\n\t\treturn update(a,b);\n\t}\n\tauto update(auto a,auto b){return b==ee?a:b;}\n};\n\nint main(){\n\tlint n,q;\n\tcin>>n>>q;\n\tlazy_segment_tree<lint,lint> seg(n,(1LL<<31)-1,-1);\n\trep(i,q){\n\t\tlint x;\n\t\tcin>>x;\n\t\tif(x){\n\t\t\tlint i;\n\t\t\tcin>>i;\n\t\t\tcout<<seg.get(i,i+1)<<endl;\n\t\t}else{\n\t\t\tlint s,t,u;\n\t\t\tcin>>s>>t>>u;\n\t\t\tseg.update(s,t+1,u);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<random>\nusing namespace std;\n\nusing Value = int;\nconst Value INI = INT_MAX;\nstruct Node {\n\tValue sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(0) {\n\t\tlazy = 0;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tdat[k].sum += dat[k].lazy * (b - a + 1);\n\t}\n\n\tValue connect(const Value l, const Value r) {\n\t\treturn l + r;\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy += dat[k].lazy;\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy += dat[k].lazy;\n\t\t}\n\t\tdat[k].lazy = 0;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy += v;\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\n\t// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn 0;\n\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tValue vl = get(l, r, 2 * k, a, m);\n\t\tValue vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\nnamespace perseg {\n\n\tstruct permanent_segtree {\n\t\tValue val;\n\t\tValue lazy;\n\t\tint l, r;\n\t\tvector<shared_ptr<permanent_segtree>>chs;\n\tpublic:\n\t\tpermanent_segtree(const int size_) :val(INI),lazy(INI), l(0), r(size_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const Value& val_, const int l_, const int r_) :val(val_), lazy(INI), l(l_), r(r_), chs(2, nullptr) {\n\n\t\t}\n\t\tpermanent_segtree(const permanent_segtree&tree_) :val(tree_.val), lazy(tree_.lazy), l(tree_.l), r(tree_.r), chs(tree_.chs) {\n\n\t\t}\n\t\tvoid lazy_func() {\n\t\t\tif (lazy !=INI) {\n\t\t\t\tval = lazy;\n\t\t\t}\n\t\t}\n\t\tValue update_lazy(int lazy_from, int lazy_to) {\n\t\t\tif (lazy_to != INI) {\n\n\t\t\t\treturn lazy_to;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lazy_from;\n\t\t\t}\n\t\t}\n\t\tvoid lazy_evaluate_node() {\n\t\t\tlazy_func();\n\t\t\tif (l + 1 != r) {\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tgetch(i)->lazy = update_lazy(getch(i)->lazy, lazy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlazy = INI;\n\t\t}\n\t\tshared_ptr<permanent_segtree>getch(const int num_) {\n\t\t\tconst int amid = (l + r) / 2;\n\n\t\t\tif (chs[num_] == nullptr) {\n\t\t\t\tif (num_ == 0) {\n\t\t\t\t\tchs[0] = make_shared<permanent_segtree>(INI, l, amid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchs[1] = make_shared<permanent_segtree>(INI, amid, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chs[num_];\n\n\t\t}\n\t\tValue eval_value(const Value&value_l, const Value&value_r)const {\n\t\t\treturn min(value_l, value_r);\n\t\t}\n\t\t// min [a, b)\n\t\tValue  query(int a, int b, int k) {\n\t\t\tlazy_evaluate_node();\n\t\t\tif (r <= a or b <= l) return INI;\n\t\t\tif (a <= l and r <= b) return val;\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tconst Value al(getch(0)->query(a, b, k));\n\t\t\tconst Value ar(getch(1)->query(a, b, k));\n\t\t\treturn eval_value(al, ar);\n\t\t}\n\t};\n\n\tshared_ptr<permanent_segtree>immutable_update(const shared_ptr<permanent_segtree>&tree, const int l,const int r, const Value a) {\n\t\ttree->lazy_evaluate_node();\n\t\tif (tree->r <= l || r <= tree->l) {\n\t\t\treturn tree;\n\t\t}else if (l<= tree->l&&tree->r<=r) {\n\t\t\tshared_ptr<permanent_segtree>new_tree(make_shared<permanent_segtree>(INI, tree->l, tree->r));\n\t\t\tnew_tree->lazy = new_tree->update_lazy(new_tree->lazy, a);\n\t\t\tnew_tree->lazy_evaluate_node();\n\t\t\treturn new_tree;\n\t\t}\n\t\telse {\n\t\t\tshared_ptr<permanent_segtree>copy_tree = (make_shared<permanent_segtree>(*tree));\n\t\t\tassert(tree->l + 1 < tree->r);\n\t\t\tcopy_tree->chs[0] = immutable_update(tree->getch(0), l,r, a);\t\t\t\n\t\t\tcopy_tree->chs[1] = immutable_update(tree->getch(1),l,r, a);\t\n\t\t\tcopy_tree->val = copy_tree->eval_value(copy_tree->getch(0)->val, copy_tree->getch(1)->val);\n\n\t\t\treturn copy_tree;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tusing namespace perseg;\n\tvector < shared_ptr<permanent_segtree>>trees(1, nullptr);\n\ttrees[0] = make_shared<permanent_segtree>(1 << 3);\n\tint N, Q; cin >> N >> Q;\n\tint now = 0;\n\tvector<tuple<int, int>>qs;\n\tbool flag = false;\n\tfor (int i = 0; i < Q;++i){\n\t\t\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint t; cin >> t;\n\t\t\tqs.push_back(make_tuple(now, t));\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\t//if (flag) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\ttrees.push_back(immutable_update(trees[now], s,t+1,x));\n\t\t\tnow++;\n\t\t\tflag = false;\n\t\t\t/*}\n\t\t\telse {\n\t\t\t\ttrees.back() = immutable_update(trees[now], x, y);\n\t\t\t}*/\n\t\t}\n\t}\n\tfor (int i = 0; i < qs.size(); ++i) {\n\t\tint anow,x;\n\t\ttie(anow, x) = qs[i];\n\t\tint ans = trees[anow]->query(x, x + 1, 100);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int A[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n    for(i = 0; i < n; i++) A[i] = INT_MAX;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            cout << A[i] << endl;\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n            for(i = s[m]; i <= t[m]; i++) A[i] = x[m];\n            m++;\n         }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][iter]);\n            iter++;\n        }\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        if(n == UNDEF){\n            if(Tree[level][key].value == UNDEF)\n                return UNDEF;\n            else if(level == Tree.size() - 1){\n                DownValue(level, key, before);\n                return UNDEF;\n            }\n            else{\n                DownValue(level, key, before);\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        DownValue(level, key, before);\n        if(level < Tree.size() - 1)\n            UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        int pivot = (Tree[level][0].high - Tree[level][0].low) / 2;\n        Node now = Tree[level][0];\n        \n        if(Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF)\n            return Tree[level][0].value;\n        \n        if(target <= pivot)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        Node now = Tree[level][key];\n        int pivot = (Tree[level][key].high - Tree[level][key].low) / 2 + Tree[level][key].low;\n        \n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= pivot)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \n    void PrintTree(){\n        static ofstream fout(\"tree.txt\");\n        for(int i = (int)Tree.size() - 1; i >= 0; i--){\n            for(vector<Node>::size_type j = 0; j < Tree[i].size(); j++){\n                fout << \"(\";\n                if(Tree[i][j].value == MAX_VALUE)\n                    fout << \"∞\";\n                else\n                    fout << Tree[i][j].value;\n                fout << \", [\" << Tree[i][j].low << \", \" << Tree[i][j].high << \"])\";\n            }\n            fout << endl;\n        }\n        fout << endl;\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = (1LL<<31)-1;\nconst int mod = 1e9 + 7;\n\nstruct SegmentTree {\n  vector<int> data, lazy;\n  int sz;\n  SegmentTree(int n) {\n    sz = 1; while(sz < n) sz <<= 1;\n    data.resize(2*sz-1, inf);\n    lazy.resize(2*sz-1, -1);\n  }\n  void lazy_evaluate(int k, int l, int r) {\n    if(~lazy[k]) {\n      data[k] = lazy[k];\n      if(r - l > 1) {\n\tlazy[2*k+1] = lazy[k];\n\tlazy[2*k+2] = lazy[k];\n      }\n      lazy[k] = -1;\n    }\n  }\n  void update(int a, int b, int x, int k, int l, int r) {\n    lazy_evaluate(k, l, r);\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) {\n      lazy[k] = x;\n      lazy_evaluate(k, l, r);\n      return;\n    }\n    update(a, b, x, 2*k+1, l, (l+r)/2);\n    update(a, b, x, 2*k+2, (l+r)/2, r);\n  }\n  void update(int a, int b, int x) {\n    update(a, b, x, 0, 0, sz);\n  }\n  int query(int i, int k, int l, int r) {\n    lazy_evaluate(k, l, r);\n    if(r - l == 1) return data[k];\n    if(l <= i && i <= r) {\n      if(i < (l+r)/2) return query(i, 2*k+1, l, (l+r)/2);\n      else return query(i, 2*k+2, (l+r)/2, r);\n    }\n    return inf;\n  }\n  int query(int i) {\n    return query(i, 0, 0, sz);\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, q;\n  cin >> n >> q;\n  SegmentTree seg(n);\n  rep(i, q) {\n    int com, s, t, x;\n    cin >> com >> s;\n    if(com == 0) cin >> t >> x, seg.update(s, t+1, x);\n    else cout << seg.query(s) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 2147483647;\n\nstruct SegmentTree {\n    int n;\n    vector<int> heap;\n    \n    SegmentTree(int n): n(n) {\n        heap.assign(4 * n, INF);\n    }\n    \n    void update(int nodeId, int l, int r, int ql, int qr, int v) {\n        if (qr < l || ql > r) {\n            return;\n        }\n        else if (ql <= l && r <= qr) {\n            heap[nodeId] = v;\n        }\n        else {\n            pushdown(nodeId);\n            int m = l + (r - l)/2;\n            update(nodeId * 2, l, m, ql, qr, v);\n            update(nodeId * 2 + 1, m + 1, r, ql, qr, v);\n        }\n    }\n    \n    int query(int nodeId, int l, int r, int q) {\n        if (q < l || q > r) {\n            return -1;\n        }\n        else if (l <= q && q <= r && heap[nodeId] != -1) {\n            return heap[nodeId];\n        }\n        else {\n            int m = l + (r - l)/2;\n            return max(query(nodeId * 2, l, m, q), query(nodeId * 2 + 1, m + 1, r, q));\n        }\n    }\n    \n    void pushdown(int nodeId) {\n        //cout << \"push: \" << nodeId << endl;\n        if (heap[nodeId] > 0) {\n            heap[nodeId * 2] = heap[nodeId];\n            heap[nodeId * 2 + 1] = heap[nodeId];\n            heap[nodeId] = -1;   \n        }\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int ql, qr, v;\n            cin >> ql >> qr >> v;\n            st.update(1, 0, n -1, ql, qr, v);\n//            for (int i = 0; i < 4 * n; i++) {\n//                cout << i << \":\" << st.heap[i] << endl; \n//            }\n        }\n        else {\n            int pos;\n            cin >> pos;\n            cout << st.query(1, 0, n-1, pos) << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n// ================================================= //\n\n/*\n update(s,t,x): [s,t) をxに変更する。\n find(s,t): [s,t) の最小値を出力する。\n */\n\nconst ll INIT = INT_MAX;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    \n    SegTree(int _N):init_v(INIT) {\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, -1);\n    }\n    \n    void lazy_evaluate(int k) {\n        if (lazy[k] == -1) return;\n        node[k] = lazy[k];\n        if (k < N - 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        lazy[k] = -1;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    ll update(int a, int b, int x) { return update(a, b, 0, 0, N, x); }\n    ll update(int a, int b, int k, int l, int r, int x) {\n        if (r <= a || b <= l) {\n            lazy_evaluate(k); // nodeの値を見るときは必ず遅延評価を更新する\n            return node[k]; // updateでは全体の中の最小を見つける必要があるため, [l,r)外になっても値を参照\n        }\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            ll vr = update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n            return node[k] = min(vl, vr);\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) {\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n};\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n,q; cin >> n >> q;\n    \n    SegTree ST(n);\n//    BIT bit(n);\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int s,t,x; cin >> s >> t >> x;\n            ST.update(s,t+1,x);\n//            ST.update(x,y);\n           // bit.add(x,y);\n        }else{\n            int i; cin >> i;\n            cout << ST.query(i,i+1) << endl;\n            //cout << ST.query(x-1,y) << endl;\n            //cout << bit.sum(y) - bit.sum(x-1) << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        if(Tree[level].size() == 1)\n            return;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][iter]);\n            iter++;\n        }\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        if(n == UNDEF){\n            if(level == Tree.size() - 1){\n                DownValue(level, key);\n                return UNDEF;\n            }\n            else if(Tree[level][key].value == UNDEF)\n                return UNDEF;\n            else{\n                \n                UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n                DownValue(level, key);\n                return UNDEF;\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        \n        if(level < Tree.size() - 1)\n            UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n        DownValue(level, key, before);\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    void DownValue(int level, int key){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        Tree[level - 1][2 * key].value = tmp;\n        if(2 * key + 1 < Tree[level - 1].size())\n            Tree[level - 1][2 * key + 1].value = tmp;\n        \n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        \n        if((Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF) || level == 0)\n            return Tree[level][0].value;\n        \n        if(target <= Tree[level - 1][0].high)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= Tree[level - 1][2 * key].high || 2 * key + 1 > Tree[level - 1].size() - 1)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ DSL_2_D Range Update Query\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// intersects returns whether [a1, b1) \\cap [a2, b2) is nonempty\nbool intersects(int a1, int b1, int a2, int b2) {\n  return ((a2 >= a1 and a2 < b1) or (a1 >= a2 and a1 < b2));\n}\n\nstruct Seg {\n  int start;\n  int end;\n  int x;\n  int pending;\n  bool flag = false;\n  Seg *l;\n  Seg *r;\n  Seg(int start, int end, int x) : start(start), end(end), x(x) {\n    if (end > start + 1) {\n      l = new Seg(start, (start + end) / 2, x);\n      r = new Seg((start + end) / 2, end, x);\n    }\n  }\n  int Get(int s, int t) {\n    Update();\n    if (s <= start and t >= end) {\n      return x;\n    }\n    int res = 0;\n    if (intersects(s, t, l->start, l->end))\n      res += l->Get(s, t);\n    if (intersects(s, t, r->start, r->end))\n      res += r->Get(s, t);\n    return res;\n  }\n  void Modify(int s, int t, int operand) { // 1-indexed\n    if (s <= start and t >= end) {\n      flag = true;\n      pending = UpdatePending(pending, operand);\n    } else if (end - start > 1) {\n      if (intersects(s, t, l->start, l->end)) {\n        l->Modify(s, t, operand);\n      }\n      if (intersects(s, t, r->start, r->end)) {\n        r->Modify(s, t, operand);\n      }\n      l->Update();\n      r->Update();\n      int res = 0;\n      if (intersects(s, t, l->start, l->end))\n        res += l->Get(s, t);\n      if (intersects(s, t, r->start, r->end))\n        res += r->Get(s, t);\n      x = res;\n    }\n  }\n  void Update() {\n    if (!flag)\n      return;\n    x = pending; // 2D: Range Update\n    if (end - start > 1) {\n      l->pending = UpdatePending(l->pending, pending);\n      r->pending = UpdatePending(r->pending, pending);\n      l->flag = true;\n      r->flag = true;\n    }\n    flag = false;\n  }\n  int UpdatePending(int old_pending, int new_pending) { return new_pending; }\n};\n\nint main() {\n  // interface: 0-indexing, closed intervals\n  // internal: 1-indexing, open intervals\n  int n, q;\n  cin >> n >> q;\n  auto seg = new Seg(1, n + 1, numeric_limits<int>::max());\n  int c;\n  while (cin >> c) {\n    if (c == 0) { // update(s,t,x): each i=s,..,t set a[i]:=x\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg->Modify(s + 1, t + 2, x);\n    }\n    if (c == 1) { // find(i): output a[i]\n      int i;\n      cin >> i;\n      cout << seg->Get(i + 1, i + 2) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n#include<utility>\n#include<numeric>\n#include<iterator>\n#include<random>\n\nusing namespace std;\nusing ll = long long;\nusing grid = vector<vector<char>>;\n\n/*\nメモ書き\ncout << setw(5) << setfill('0') << 〇〇 << endl;\nは5つ右寄せで0埋め出力\n*/\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\n\nstruct all_init{\n\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(nullptr);\n\t\tcin.tie(nullptr);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//フローで使う容量を意味するcapaも追加\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\tll capa;\n\n\tedge(int s, int d) : from(s), to(d) {\n\t\tcost = 0; capa = 0;\n\t}\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) { capa = 0; }\n\tedge(int s, int d, ll x, ll y) :from(s), to(d), cost(x), capa(y) {  }\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\nusing graph = vector<vector<edge>>;\nusing graph_bool = vector<vector<bool>>;\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n#define ALL(vec_etc) vec_etc.begin(),vec_etc.end()\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define WARSHALL vector<vector<ll>> g(n,vector<ll>(n,LONGINF))\n#define endl '\\n'\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<typename T>istream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>void resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>void resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\ntemplate<ll mod> struct ModInt {\n\t//けんちょんさん作modをとる整数\n\t//名前だけ変えた\n\t//これがないと二項係数が動かないので注意\n\t//普通に計算するとmodがとれる\n\tlong long val;\n\tconstexpr ModInt(long long v = 0) noexcept : val(v % mod) {\n\t\tif (val < 0) v += mod;\n\t}\n\tconstexpr int getmod() { return mod; }\n\tconstexpr ModInt operator - () const noexcept {\n\t\treturn val ? mod - val : 0;\n\t}\n\tconstexpr ModInt operator + (const ModInt& r) const noexcept { return ModInt(*this) += r; }\n\tconstexpr ModInt operator - (const ModInt& r) const noexcept { return ModInt(*this) -= r; }\n\tconstexpr ModInt operator * (const ModInt& r) const noexcept { return ModInt(*this) *= r; }\n\tconstexpr ModInt operator / (const ModInt& r) const noexcept { return ModInt(*this) /= r; }\n\tconstexpr ModInt& operator += (const ModInt& r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= mod) val -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator -= (const ModInt& r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += mod;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator *= (const ModInt& r) noexcept {\n\t\tval = val * r.val % mod;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator /= (const ModInt& r) noexcept {\n\t\tlong long a = r.val, b = mod, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % mod;\n\t\tif (val < 0) val += mod;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator == (const ModInt& r) const noexcept {\n\t\treturn this->val == r.val;\n\t}\n\tconstexpr bool operator != (const ModInt& r) const noexcept {\n\t\treturn this->val != r.val;\n\t}\n\tfriend ostream& operator << (ostream &os, const ModInt<mod>& x) noexcept {\n\t\treturn os << x.val;\n\t}\n\tfriend istream& operator >> (istream &is, ModInt<mod>& x) noexcept {\n\t\treturn is >> x.val;\n\t}\n\tfriend constexpr ModInt<mod> modpow(const ModInt<mod> &a, long long n) noexcept {\n\t\tif (n == 0) return 1;\n\t\tauto t = modpow(a, n / 2);\n\t\tt = t * t;\n\t\tif (n & 1) t = t * a;\n\t\treturn t;\n\t}\n};\ntemplate<class T> struct nCk {\n\t//けんちょんさん作二項係数ライブラリ\n\t//名前だけ変えた\n\t//nCk<ModInt<MOD>> c(200000);\n\t//↑のような感じで初期化\n\tvector<T> fact_, inv_, finv_;\n\tconstexpr nCk() {}\n\tconstexpr nCk(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n\t\tinit(n);\n\t}\n\tconstexpr void init(int n) noexcept {\n\t\tfact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n\t\tint MOD = fact_[0].getmod();\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tfact_[i] = fact_[i - 1] * i;\n\t\t\tinv_[i] = -inv_[MOD%i] * (MOD / i);\n\t\t\tfinv_[i] = finv_[i - 1] * inv_[i];\n\t\t}\n\t}\n\tconstexpr T com(int n, int k) const noexcept {\n\t\tif (n < k || n < 0 || k < 0) return 0;\n\t\treturn fact_[n] * finv_[k] * finv_[n - k];\n\t}\n\tconstexpr T fact(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn fact_[n];\n\t}\n\tconstexpr T inv(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn inv_[n];\n\t}\n\tconstexpr T finv(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn finv_[n];\n\t}\n};\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll PowMod(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll Gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? Gcd(b, a % b) : a;\n}\nll Lcm(ll a, ll b) {//最小公倍数\n\treturn a / Gcd(a, b) * b;\n}\nvector<string> Split(string s, string t) {\n\t//文字列を文字列で分割する\n\tvector<string> v;\n\tint p = s.find(t);\n\tif (p != s.npos) {\n\t\tv.push_back(s.substr(0, p));\n\t\ts = s.substr(p + t.size());\n\t}\n\tv.push_back(s);\n\treturn v;\n}\nvector<int> Lis(const vector<int>& a) {\n\t//#define Index_of(as, x) distance(as.begin(), lower_bound(as.begin(), as.end(), x))\n\t#define Index_of(as, x) distance(as.begin(), upper_bound(as.begin(), as.end(), x))\n//upper_boundを使用すると、重複を許した最長増加部分列になる\n//-1倍した値を入れれば、最長減少部分列になる\n\tconst int n = a.size();\n\tvector<int> A(n, INF);\n\tvector<int> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = Index_of(A, a[i]);\n\t\tA[id[i]] = a[i];\n\t}\n\tint m = *max_element(id.begin(), id.end());\n\tvector<int> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;//最長部分列のどれか1つ\n}\nstring LcsAlphabeticalMinOrder(string a, string b) {\n\tif (a.size() < b.size()) { swap(a, b); }\n\n\tint n = a.size(), m = b.size();\n\n\tvector<string> dp(m + 1);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<string> to(m + 1);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (a[i] == b[j]) {\n\t\t\t\tto[j + 1] = dp[j] + a[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (to[j].size() > dp[j + 1].size()) { to[j + 1] = to[j]; }\n\t\t\t\telse if (to[j].size() < dp[j + 1].size()) { to[j + 1] = dp[j + 1]; }\n\t\t\t\telse if (to[j] < dp[j + 1]) { to[j + 1] = to[j]; }\n\t\t\t\telse {to[j + 1] = dp[j + 1];}\n\t\t\t}\n\t\t}\n\t\tdp.swap(to);\n\t}\n\treturn dp[m];\n}\nstring Lcs(const string &s,const string &t) {\n\tint dp[3001][3001];\n\tint n = s.size();\n\tint m = t.size();\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (s[i - 1] == t[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tstring ans = \"\";\n\tint i = s.size(), j = t.size();\n\twhile (i > 0 && j > 0) {\n\t\tif (s[i - 1] == t[j - 1]) {\n\t\t\tans += s[i - 1];\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\telse if (dp[i - 1][j] >= dp[i][j - 1])\n\t\t\ti--;\n\t\telse\n\t\t\tj--;\n\t}\n\treverse(ans.begin(), ans.end());\n\treturn ans;\n}\nvector<int> LcsInteger(const vector<int> &a, const vector<int> &b) {\n\t#define index_of(as, x) distance(as.begin(), lower_bound(as.begin(), as.end(), x))\n\tstruct node {\n\t\tint value;\n\t\tnode *next;\n\t\tnode(int value, node *next) : value(value), next(next) { }\n\t};\n\tconst int n = a.size(), m = b.size();\n\tmap< int, vector<int> > M;\n\tfor (int j = m - 1; j >= 0; --j)\n\t\tM[b[j]].push_back(j);\n\tvector<int> xs(n + 1, INF); xs[0] = -INF;\n\tvector< node* > link(n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (M.count(a[i])) {\n\t\t\tvector<int> ys = M[a[i]];\n\t\t\tfor (int j = 0; j < (int)ys.size(); ++j) {\n\t\t\t\tint k = index_of(xs, ys[j]);\n\t\t\t\txs[k] = ys[j];\n\t\t\t\tlink[k] = new node(b[ys[j]], link[k - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> c;\n\tint l = index_of(xs, INF - 1) - 1;\n\tfor (node *p = link[l]; p; p = p->next)\n\t\tc.push_back(p->value);\n\treverse(c.begin(), c.end());\n\treturn c;\n}\nbool IsPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nll MergeCount(vector<int> &a) {\n\t//反転数を数える\n\tll count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += MergeCount(b);\n\t\tcount += MergeCount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool  WarshallFloyd(vector<vector<ll>> &c) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tint V = c.size();\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> Dijkstra(int i, vector<vector<edge>> graph) {\n\t//i:始点\n\t//graph:重み付きグラフ\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool BellmanFord(int start, int V, int E, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:V 頂点数\n\t//第三引数:E 辺の数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\t//負の閉路検出でfalseが返り値\n\tresize(d, V);\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\t/*\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (t[V - 1]) {\n\t\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nbool TopologicalSort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> ArticulationNode(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//与えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nvector<vector<edge>> ToRootTree(const vector<vector<edge>> &g, int r) {\n\t//根付き木へ変換する。\n\t//動作未確認。\n\tint n = g.size();\n\tvector<vector<edge>> G(n);\n\tvector<int> ord(n, -1);\n\n\tqueue<int> q;\n\n\tq.push(r);\n\tint k = 0;\n\n\twhile (q.size()) {\n\t\tint u = q.front(); q.pop();\n\n\t\tfor (auto &e : g[u]) {\n\t\t\tint v = e.to;\n\t\t\tif (ord[v] == -1) {\n\t\t\t\tord[v] = k; k++;\n\t\t\t\tq.push(v);\n\t\t\t\tG[u].emplace_back(e);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn G;\n}\nedge TreeDiameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<int> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<int> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tll d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\nvoid add_edge(vector<vector<edge>> &g, int a, int b, ll cost, ll cap) {\n\t//graph(vector<vector<edge>>)に対して無向辺として辺を貼る関数\n\t//graph以外には当然使えないので注意\n\tg[a].emplace_back(a, b, cost, cap);\n\tg[b].emplace_back(b, a, cost, cap);\n}\npair<vector<int>, vector<edge>> bridge(const vector<vector<edge>>& g) {\n\t//グラフの橋となる辺を列挙する\n\t//戻り値のfirst:二重辺連結成分分解の番号となる\n\t//戻り値のsecond:橋となる辺を列挙したもの\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int> ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tvector<edge> brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1) {dfs(w, v);}\n\t\t\telse if (u != w && onS[w]) {\n\t\t\t\twhile (ord[roots[t - 1]] > ord[w]) { --t; }\n\t\t\t}\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v, 0);\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest_num\n\t//forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\nclass Dinic {\n\t//最大流を求める\nprivate:\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<ll>> cap, flow;\n\tvector<vector<int>> g;\n\tll inf;\npublic:\n\tDinic(const vector<vector<edge>> &graph) :\n\t\tn(graph.size()),\n\t\tcap(n, vector<ll>(n)),//\n\t\tflow(n, vector<ll>(n)),\n\t\tg(n, vector<int>()),\n\t\tinf(LONGINF) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.from, v = e.to;\n\t\t\t\tll c = e.capa;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline ll residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tll solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tll res = 0;\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v])\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tll augment(int v, ll lim) {\n\t\tll res = 0;\n\t\tif (v == t) return lim;\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst ll aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\nclass MinimumCostFlow {\nprivate:\n\n\tusing Flow = ll;\n\tusing Cost = ll;\n\tstruct Edge {\n\t\tint d;\n\t\tFlow c, f;\n\t\tCost w;\n\t\tint r, is_r;\n\t\tEdge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n\t\t\t: d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\npublic:\n\n\tMinimumCostFlow(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n\n\tvoid add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n\t\tint rsrc = g[dst].size();\n\t\tint rdst = g[src].size();\n\t\tg[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n\t\tg[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n\t}\n\n\tCost solve(int s, int t, Flow f) {\n\t\tCost res = 0;\n\n\t\tvector<Cost> h(n + 10), dist(n);\n\t\tvector<int> prevv(n + 10), preve(n + 10);\n\n\t\tusing pcv = pair<Cost, int>;\n\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LONGINF);\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(0, s);\n\t\t\twhile (q.size()) {\n\t\t\t\tCost cd;\n\t\t\t\tint v;\n\t\t\t\ttie(cd, v) = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif (dist[v] < cd) continue;\n\t\t\t\tfor (int i = 0; i < (int)(g[v].size()); ++i) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif (residue(e) == 0) continue;\n\t\t\t\t\tif (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n\t\t\t\t\t\tdist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n\t\t\t\t\t\tprevv[e.d] = v;\n\t\t\t\t\t\tpreve[e.d] = i;\n\t\t\t\t\t\tq.emplace(dist[e.d], e.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist[t] == LONGINF) return -1;  // 経路が見つからなかった\n\n\t\t\t// s-t 間を最短路に沿って目一杯流す\n\t\t\tfor (int i = 0; i < n; ++i) h[i] += dist[i];\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tchmin(d, residue(g[prevv[v]][preve[v]]));\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.f += d;\n\t\t\t\tg[v][e.r].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tFlow residue(const Edge &e) { return e.c - e.f; }\n\n\t// 流量を表示\n\tvoid show() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < (int)(g[i].size()); ++j) {\n\t\t\t\tEdge &e = g[i][j];\n\t\t\t\tif (e.is_r) continue;\n\t\t\t\tcout << i << \"->\" << e.d << \"(flow:\" << e.f << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\nclass BipartiteMatching {\nprivate:\n\tint V;\n\tvector<int> match;\n\tvector<bool> used;\n\tvector<vector<int>> g;\n\tvector<pair<int, int>> match_pair;\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tint w = match[u];\n\t\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch_pair.emplace_back(make_pair(u, v));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\npublic:\n\tBipartiteMatching(int n) {\n\t\tV = n;\n\t\tresize(match, n);\n\t\tresize(used, n);\n\t\tresize(g, n);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\n\tint MatchingSolve() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<pair<int, int>> get_pair() {\n\t\tfor (auto x : match_pair) {\n\t\t\tcout << x.first << \"  \" << x.second << endl;\n\t\t}\n\t\treturn match_pair;\n\t}\n\n};\nclass Lca {\nprivate:\n\tint n;\n\tint log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\n\tvoid dfs(const vector<vector<edge>> &g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (e.to != p) { dfs(g, e.to, v, d + 1); }\n\t\t}\n\t}\n\npublic:\n\n\tLca(const vector<vector<edge>> &g, int root) {\n\t\tn = g.size();\n\t\tlog2_n = (int)log2(n) + 1;\n\t\tresize(parent, log2_n, n);\n\t\tresize(depth, n);\n\n\t\tdfs(g, root, -1, 0);\n\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0) {\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint get_lca(int u, int v) {\n\t\tif (depth[u] > depth[v]) { swap(u, v); }//u≦v\n\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) { return u; }\n\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\n\tint get_depth(int v) {\n\t\treturn depth[v];\n\t}\n};\nclass DAG {\n\t//有向グラフをゴニョゴニョするクラス\n\t//機能:longest_path 有向パスの最長経路(含まれる辺の数)を求める\nprivate:\n\tint n;\n\tvector<vector<edge>> g;\n\tvector<int> visited;\n\tvector<int> dp;\n\tvector<int> topological;\n\n\tint dfs(int s) {\n\t\tif ((int)g[s].size() == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (dp[s] > 0) { return dp[s]; }\n\n\t\tint mx = 1;\n\t\tfor (auto j : g[s]) {\n\t\t\tif (visited[j.to]==0) {\n\t\t\t\tvisited[j.to] = 1;\n\t\t\t\tint l = 0;\n\t\t\t\tl = dfs(j.to);\n\t\t\t\tchmax(mx, l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmax(mx, dp[j.to]);\n\t\t\t}\n\t\t}\n\t\treturn dp[s] = mx + 1;\n\t}\npublic:\n\tDAG(const vector<vector<edge>> &f) {\n\t\tg = f;\n\t\tn = f.size();\n\t\tresize(visited, n + 1);\n\t\tfill(visited.begin(), visited.end(), 0);\n\t\tresize(dp, n + 1);\n\t\tfill(dp.begin(), dp.end(), -1);\n\t\tresize(topological, n);\n\t}\n\tDAG(int x) {\n\t\tn = x;\n\t\tresize(g, n);\n\t\tresize(visited, n + 1);\n\t\tfill(visited.begin(), visited.end(), 0);\n\t\tresize(dp, n + 1);\n\t\tfill(dp.begin(), dp.end(), -1);\n\t}\n\n\tvoid add_edge(int a,int b) {\n\t\tg[a].emplace_back(a, b);\n\t}\n\tvoid add_edge(int a, int b, ll c) {\n\t\tg[a].emplace_back(a, b, c);\n\t}\n\tvoid add_edge(int a, int b, ll c, ll d) {\n\t\tg[a].emplace_back(a, b, c, d);\n\t}\n\n\tint longest_path() {\n\t\tint mx = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = 0;\n\t\t\tif (visited[i]==0) {\n\t\t\t\th = dfs(i);\n\t\t\t\tchmax(mx, h);\n\t\t\t}\n\t\t}\n\t\treturn mx - 1;\n\t}\n\n\tbool TopologicalSort() {\n\t\t//trueが帰る時、トポロジカルソートが成功\n\t\t//falseはトポロジカルソートの失敗\n\t\tint k = 0;\n\t\tvector<int> ord(n), in(n);\n\t\tfor (auto &es : g) {\n\t\t\tfor (auto &e : es) {\n\t\t\t\tin[e.to]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (in[i] == 0) q.push(i);\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tord[k++] = v;\n\t\t\tfor (auto &e : g[v]) {\n\t\t\t\tif (--in[e.to] == 0) { q.push(e.to); }\n\t\t\t}\n\t\t}\n\t\ttopological = ord;\n\t\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\t\treturn false;\n\t}\n\n};\nclass RangeMinimumQuerySegmentTree {\n\t//区間最小値を求めることが出来るセグメント木\n\t//query:指定した半開区間においての最小値を求める\n\t//update:指定した半開区間の値を変更する\nprivate:\n\tint n;\n\tll inf = (1LL << 31) - 1;//2^31-1\n\tvector<ll> dat, lazy;\n\n\tvoid eval(int len, int k) {\n\t\tif (lazy[k] == inf) return;\n\t\tif (k * 2 + 1 < n * 2 - 1) {\n\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\tlazy[2 * k + 2] = lazy[k];\n\t\t}\n\t\tdat[k] = lazy[k];\n\t\tlazy[k] = inf;\n\t}\npublic:\n\tRangeMinimumQuerySegmentTree() {}\n\tRangeMinimumQuerySegmentTree(int n_) {\n\t\tn = 1; while (n < n_) n *= 2;\n\t\tdat.assign(n * 2, inf);\n\t\tlazy.assign(n * 2, inf);\n\t}\n\n\t// [a, b)\n\tll update(int a, int b, ll x, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\tif (b <= l || r <= a) return dat[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\treturn lazy[k];\n\t\t}\n\t\treturn dat[k] = min(update(a, b, x, 2 * k + 1, l, (l + r) / 2), update(a, b, x, 2 * k + 2, (l + r) / 2, r));\n\t}\n\tll update(int a, int b, ll x) { return update(a, b, x, 0, 0, n); }\n\n\t// [a, b)\n\tll query(int a, int b, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\tif (b <= l || r <= a) return inf;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tll query(int a, int b) { return query(a, b, 0, 0, n); }\n};\nclass RangeSumQuerySegmentTree {\n\t//区間和を求めることが出来るセグメント木\n\t//update:指定した要素に加算\n\t//query:指定した半開区間の合計を返す\n\t//0-indexed\n\t//半開区間\nprivate:\n\tstruct Node {\n\t\tNode *left, *right;\n\t\tll v;\n\n\t\tNode() : left(nullptr), right(nullptr), v(0) {}\n\t};\n\tNode *root;\n\tll n, n0;\n\tll query(ll a, ll b, Node *n, ll l, ll r) {\n\t\tif (a <= l && r <= b) {\n\t\t\treturn n->v;\n\t\t}\n\t\tif (r <= a || b <= l) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tll lv = n->left ? query(a, b, n->left, l, (l + r) >> 1) : 0;\n\t\tll rv = n->right ? query(a, b, n->right, (l + r) >> 1, r) : 0;\n\t\treturn (lv + rv) % MOD;\n\t}\npublic:\n\tRangeSumQuerySegmentTree(ll n) : n(n) {\n\t\tn0 = 1;\n\t\twhile (n0 < n) n0 <<= 1;\n\t\troot = new Node();\n\t}\n\t~RangeSumQuerySegmentTree() {\n\t\tdelete root; root = nullptr;\n\t}\n\n\tvoid update(ll k, ll x) {\n\t\tNode *n = root;\n\t\tll l = 0, r = n0;\n\t\tn->v = (n->v + x) % MOD;\n\t\twhile (r - l > 1) {\n\t\t\tll m = (l + r) >> 1;\n\t\t\tif (k < m) {\n\t\t\t\tif (!n->left) n->left = new Node();\n\t\t\t\tn = n->left;\n\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!n->right) n->right = new Node();\n\t\t\t\tn = n->right;\n\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\tn->v = (n->v + x) % MOD;\n\t\t}\n\t}\n\n\tll query(ll a, ll b) {\n\t\treturn query(a, b, root, 0, n0);\n\t}\n\n\tll lquery(ll b) {\n\t\treturn query(0, b, root, 0, n0);\n\t}\n\n\tll rquery(ll a) {\n\t\treturn query(a, n0, root, 0, n0);\n\t}\n};\nclass KDimensionalTree{\n\t//2Dの点がある区間内にあるかどうかを判定し、その点を列挙する\n\t//makeKDTreeで前計算\n\t//findが実際に探す部分\npublic:\n\tstruct Node {\n\t\tint location;\n\t\tint p, l, r;\n\t\tNode() {}\n\t};\n\tstruct Point {\n\t\tint id,x, y;\n\t\tPoint() {}\n\t\tPoint(int i, int a, int b) {\n\t\t\tid = i;\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\t\tbool operator<(const Point &p)const {\n\t\t\treturn id < p.id;\n\t\t}\n\t\tvoid print() {\n\t\t\tcout << id << endl;\n\t\t}\n\t};\n\tstatic const ll NIL = -1;\n\tstatic bool lessX(const Point &p1, const Point &p2) { return p1.x < p2.x; }\n\tstatic bool lessY(const Point &p1, const Point &p2) { return p1.y < p2.y; }\n\n\tint N;\n\tvector<Point> P;\n\tvector<Node> T;\n\tint np;\n\n\tKDimensionalTree() {}\n\tKDimensionalTree(int N) { init(N); }\n\n\tvoid init(int n) {\n\t\tN = n;\n\t\tP.clear();\n\t\tT.clear();\n\t\tresize(P, N);\n\t\tresize(T, N);\n\t\tnp = 0;\n\t}\n\n\tint makeKDTree(int l, int r, int depth) {\n\t\tif (l >= r) { return NIL; }\n\t\tint mid = (l + r) / 2;\n\t\tint t = np++;\n\t\tif (depth & 1) {\n\t\t\tsort(P.begin() + l, P.begin() + r, lessY);\n\t\t}\n\t\telse {\n\t\t\tsort(P.begin() + l, P.begin() + r, lessX);\n\t\t}\n\t\tT[t].location = mid;\n\t\tT[t].l = makeKDTree(l, mid, depth + 1);\n\t\tT[t].r = makeKDTree(mid + 1, r, depth + 1);\n\t\treturn t;\n\t}\n\tvoid find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans) {\n\t\tint x = P[T[v].location].x;\n\t\tint y = P[T[v].location].y;\n\t\tif (sx <= x && x <= tx && sy <= y && y <= ty) {\n\t\t\tans.push_back(P[T[v].location]);\n\t\t}\n\t\tif (depth % 2 == 0) {\n\t\t\tif (T[v].l != NIL) {\n\t\t\t\tif (sx <= x) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t\t}\n\t\t\tif (T[v].r != NIL) {\n\t\t\t\tif (x <= tx) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (T[v].l != NIL) {\n\t\t\t\tif (sy <= y) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t\t}\n\t\t\tif (T[v].r != NIL) {\n\t\t\t\tif (y <= ty) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t\t}\n\t\t}\n\t}\n\tvoid add_point(int i, int x, int y) {\n\t\tP[i].id = i;\n\t\tP[i].x = x;\n\t\tP[i].y = y;\n\t\tT[i].l = T[i].r = T[i].p = NIL;\n\t}\n};\n\n\n\nint main() {\n\tint n, q; cin >> n >> q;\n\tRangeMinimumQuerySegmentTree s(n);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint x; cin >> x;\n\t\tif (x) {\n\t\t\tint a; cin >> a;\n\t\t\tcout << s.query(a, a + 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ts.update(a, b + 1, c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n参考\nhttps://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\n\nhttps://firiexp.github.io/library/library/lazysegtree.html\n\nhttps://smijake3.hatenablog.com/entry/2018/11/03/100133#%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E6%9C%A8%E3%81%AE%E6%A6%82%E8%A6%81\nverify:\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_F\n*/\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1LL << 55\n#define MAX (1LL << 31) -1\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//typedef pair<pair<int,int>,int> p;\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\n#define rad_to_deg(rad) (((rad) / 2 / M_PI) * 360)\nstruct edge{ll to,cost,val;};\ntemplate<class T,class U>bool chmin(T&a,const U&b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>bool chmax(T&a,const U&b){if(a>=b)return false;a=b;return true;}\n//__builtin_popcount(S);\n//C.erase(unique(C.begin(),C.end()),C.end());\n//#define int ll\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n//#define F function<T(T,T)>\n\ntemplate<typename T,typename L>\nstruct LazySegmentTree{\n    //using\n    using F=function<T(T,T)>;\n    using G=function<T(T,L)>;\n    using H=function<L(L,L)>; //二番目が後に追加されたもの\n\n    //データ\n    int sz;\n    int height;\n    vector<T> seg;\n    vector<L> lazy;\n    const T sut;\n    const L lut;\n    const F f;\n    const G g;\n    const H h;\n\n    LazySegmentTree(int n,const T sut,const L lut,const F &f,const G &g,const H &h):sut(sut),lut(lut),f(f),g(g),h(h){\n        sz=1;\n        height=0;\n        while(sz<n) sz<<=1,height++;\n        seg.assign((sz<<1),sut);\n        lazy.assign((sz<<1),lut);        \n    }\n\n    inline void set(int k,const T &x){\n        seg[k+sz]=x;\n    }\n    inline void build(){\n        for(int k=sz-1;k>0;k--){\n            seg[k]=f(seg[(k<<1)],seg[(k<<1)+1]);\n        }\n    }\n    inline T reflect(int k){\n        return (lazy[k]==lut) ? seg[k]:g(seg[k],lazy[k]);\n    }\n    //子にlazyを伝える(updateで丸々収まる所を更新した尻ぬぐい)\n    //lazy[k]とlazy[2*k]が違った場合,lazy[k]の方が後に更新されたもの\n    inline void propagate(int k){\n        if(lazy[k]!=lut){\n            lazy[(k<<1)]=h(lazy[(k<<1)],lazy[k]);\n            lazy[(k<<1)+1]=h(lazy[(k<<1)+1],lazy[k]);\n            seg[k]=reflect(k);\n            lazy[k]=lut;\n        }\n    }\n    //ボトムアップで更新していく\n    inline void recalc(int k){\n        while(k>>=1) seg[k]=f(reflect((k<<1)),reflect((k<<1)+1));\n    }\n    //トップダウンで更新していく(これでseg[k]が正しい値になる)\n    inline void thrust(int k){\n        for(int i=height;i>0;i--) propagate(k>>i);\n    }\n    void update(int a,int b,const L &x){\n        //トップダウンでlazy[i]!=lutのものを更新\n        thrust(a+=sz);\n        thrust(b+=sz-1);\n        //丸々収まるところを更新\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) lazy[l]=h(lazy[l],x),l++;\n            if(r&1) --r,lazy[r]=h(lazy[r],x);\n        }\n        //ボトムアップで新しく更新\n        recalc(a);\n        recalc(b);\n    }\n\n    //[a:b)\n    T query(int a,int b){\n        //トップダウンで関係あってlazy[i]!=lutのものを更新\n        thrust(a+=sz);\n        thrust(b+=sz-1);\n        //更新した後は普通のセグ木と同じ\n        T l=sut,r=sut;\n        for(a,b+=1;a<b;a>>=1,b>>=1){\n            if(a&1) l=f(l,reflect(a++));\n            if(b&1) r=f(reflect(--b),r);\n        }\n        return f(l,r);\n    }\n    //セグ木と違い、log(n)かかる\n    T operator[](const int k){\n        return query(k,k+1);\n    }\n\n};\n\n//[](int a,int b){return min(a,b);}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n,q;\n    cin>>n>>q;\n    auto f=[](int a,int b){return min(a,b);};\n    auto g=[](int a,int b){return b;};\n    auto h=[](int a,int b){return b;};\n    LazySegmentTree<int,int> l(n,MAX,-1,f,g,h);\n    while(q--){\n        int a;\n        cin>>a;\n        if(a==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            l.update(s,t+1,x);\n        }else{\n            int x;\n            cin>>x;\n            cout<<l[x]<<endl;\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\ntemplate <class Monoid, class OperatorMonoid = Monoid> class LazySegmentTree {\n  using F = std::function<Monoid(Monoid, Monoid)>;\n  using G = std::function<Monoid(Monoid, OperatorMonoid, int)>;\n  using H = std::function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  private:\n    int n;\n    std::vector<Monoid> seg;\n    std::vector<OperatorMonoid> lazy;\n\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM1;\n\n    void lazyUpdate(int k, int l, int r) {\n      if(lazy[k] == OM1) return;\n\n      seg[k] = g(seg[k], lazy[k], r - l);\n      if(r - l > 1) {\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n        lazy[2 * k + 2] = h(lazy[2 * k + 2], lazy[k]);\n      }\n      lazy[k] = OM1;\n    }\n\n  public:\n    LazySegmentTree(int sz, const F f, const G g, const H h, const Monoid &M1, const OperatorMonoid &OM1) : f(f), g(g), h(h), M1(M1), OM1(OM1) {\n      n = 1;\n      while(n < sz) n *= 2;\n      seg.resize(2 * n - 1, M1);\n      lazy.resize(2 * n - 1, OM1);\n    }\n\n    void update(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n      if(r < 0) r = n;\n\n      lazyUpdate(k, l, r);\n\n      if(b <= l || r <= a) return;\n\n      if(a <= l && r <= b) {\n        lazy[k] = h(lazy[k], x);\n        lazyUpdate(k, l, r);\n      }\n      else {\n        update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n        update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n        seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n      }\n    }\n\n    Monoid query(int a, int b, int k = 0, int l = 0, int r = -1) {\n      if(r < 0) r = n;\n\n      lazyUpdate(k, l, r);\n\n      if(b <= l || r <= a) return M1;\n      if(a <= l && r <= b) return seg[k];\n      Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n      Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n      return f(vl, vr);\n    }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n  LazySegmentTree<int> seg(n, [](int a, int b){ return min(a, b); },\n                              [](int a, int b, int len){ return b; },\n                              [](int a, int b){ return b; }, INT_MAX, INT_MAX);\n  rep(i, 0, q) {\n    int c;\n    cin >> c;\n    if(c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n    else {\n      int x;\n      cin >> x;\n      cout << seg.query(x, x + 1) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass Segment_Tree {\n\tvector<long long int>v;\n\tvector<long long int>add;\n\tvector<long long int>modi;\n\tvector<int>l;\n\tvector<int>r;\n\tint num;\n\tlong long int ret;\n\tbool is_min;\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tif (is_min) {\n\t\t\tv[place] = min(Update(place * 2), Update(place * 2 + 1));\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = max(Update(place * 2), Update(place * 2 + 1));\n\t\treturn v[place];\n\t}\n\tvoid Modify(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tmodi[place] = num;\n\t\t\tv[place] = num;\n\t\t\tadd[place] = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tModify(a, b, num, place * 2);\n\t\tModify(a, b, num, place * 2 + 1);\n\t\tif(is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\n\tvoid Add(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tadd[place] += num;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tAdd(a, b, num, place * 2);\n\t\tAdd(a, b, num, place * 2 + 1);\n\t\tif (is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\n\tvoid RMQ(int a, int b, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tif (is_min)ret = min(ret, v[place] + add[place]);\n\t\t\telse ret = max(ret, v[place] + add[place]);\n\t\t\treturn;\n\t\t}\n\t\tif (l[place]>b || r[place]<a) return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tRMQ(a, b, place * 2);\n\t\tRMQ(a, b, place * 2 + 1);\n\t\treturn;\n\t}\npublic:\n\tSegment_Tree(int n, bool min) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2) {\n\t\t\tnum *= 2;\n\t\t}\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tis_min = min;\n\t\tif (min) {\n\t\t\tv.resize(num, LLONG_MAX);\n\t\t}\n\t\telse v.resize(num, LLONG_MIN);\n\t\tadd.resize(num, 0);\n\t\tmodi.resize(num, LLONG_MAX);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Insert(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] = num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tif (is_min)v[place] = min(v[place * 2], v[place * 2 + 1]);\n\t\t\telse v[place] = max(v[place * 2], v[place * 2 + 1]);\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid Modify(int a, int b, long long int num) {\n\t\tModify(a, b, num, 1);\n\t}\n\tvoid Add(int a, int b, long long int num) {\n\t\tAdd(a, b, num, 1);\n\t}\n\tvoid Init() {\n\t\tUpdate(1);\n\t}\n\tlong long int RMQ(int a, int b) {\n\t\tif (is_min)ret = LLONG_MAX;\n\t\telse ret = LLONG_MIN;\n\t\tRMQ(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tSegment_Tree sg(N, true);\n\tfor (int i = 0; i < N; i++) {\n\t\tsg.Insert(i, (1LL << 31) - 1,false);\n\t}\n\tsg.Init();\n\tvector<int>ans;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> M;\n\t\tif (M) {\n\t\t\tcin >> L;\n\t\t\tans.push_back(sg.RMQ(L, L));\n\t\t}\n\t\telse {\n\t\t\tcin >> L >> R >> H;\n\t\t\tsg.Modify(L, R, H);\n\t\t\t//for (int j = 0; j < N; j++) {\n\t\t\t//\tfor (int k = j; k < N; k++) {\n\t\t\t//\t\tcout << j << \" \" << k << \" \" << sg.RMQ(j, k) << endl;\n\t\t\t//\t}\n\t\t\t//}\n\t\t}\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <climits>\n#include <set>\n\n//#define int long long\ntypedef long long ll;\n//using ll = long long;\n//using R = double;\n\n//#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,bg,ed) for(ll i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\n#define MOD 1000000007\n\nconst int INF = int(1e9);\n\nusing namespace std;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\n\n\n// ???????????????1??¨?????????????????§???\n// ????????????k*2\n// ????????????k*2+1\n// ??????floor(k/2)\n// ??¨?????????\n// ???????????????1??¨????????¨????????°?????????????????????????????°?????§??????????????????????????????????????????\n// ?????°?????????????????§????????°???????????§??????????????????\n\nconst int N = 1 << 17;  // ???????????°\nconst int NIL = INT_MAX;\n\nint maxi[N * 2]; // ?????????k?????????????????????????????§???\nint lazy[N * 2]; // lazy[k]????????????k???????????¨??????lazy[k]??§???????????¶?????¨?????????????????¨??????lazy[k]=NIL?????¨???????????????????????¨?´??????????\n\nvoid setLazy(int k, int v) {\n    lazy[k] = v;\n\n    // ??????????????????????????¨?????? v ??§???????????¶????????????????????????????????¶????????????k????????§??????v??§??????\n    maxi[k] = v;\n\n    // *** ?????? ***\n    // ????????????????????¶?????°???????????¨??§????????£??¨????????????\n    // ?????????O(1)????????¢?????§??¨?????§??????????????????????????????????????§???????????§????????°?????¶?????°???????????¨??§????????§?????????\n    // ?????¨?????°?????????????????¨?????????????????¶???????????????????????????????????°???????????¨??????????????§????????°???\n    //\n    // fill v := v ??§???????????¶???\n    // add v := v ???????????????\n    //\n    // ??¨??????????¨???????????????????????????????????????????\n    // add u ??????????????? fill v ??????????????¨??? (fill v) . (add u) ??¨???????????¨???????????????\n    // ????????¨?????\\????????¢????????????????????????\n    //\n    // (add v) . (add u) = (add v+u)\n    // (add v) . (fill u) = (fill v+u)\n    // (fill v) . (add u) = (fill v)\n    // (fill v) . (fill u) = (fill v)\n    //\n    // ????????????add u ??¨ fill u ????£????????????? (add or fill, Int) ??§??????????????????\n    // ?????£??????????????? add ??§????????? fill ??§???????????¨????????????????????±??¨?????????/???????????¶????????? 2 ???????????±????????£?????¨?????§?????????\n    // ?????°??????????????????????????????????????????????????????????????????????????¨???????????¨???????????????????????????????????????\n    //\n    // ?????¶?????°???????????¨??????????????????????????????????????????????????¨????????????\n    // ??????????????¶?????¬?????°???????????¨????????§???????????¨????????????\n    // ??????????????????????????????????????±???????????????????????????\n    //\n    // ????§£??????????????????????????????????????????????????????????????¶???????????¶?????¬????????????????????¨??????????????§????????????\n    // ???????????¶???????????????????????????????????°???\n    //  (timeS, valueS) . (timeT, valueT) = max((timeS, valueS), (timeT, valueT))\n    // ??¨??????????????????????????¢??§?????????\n}\n\nvoid push(int k) {\n    // ?????¶?????????????????????????????°???????????????\n    if (lazy[k] == NIL) {\n        return;\n    }\n    setLazy(k * 2 + 0, lazy[k]);\n    setLazy(k * 2 + 1, lazy[k]);\n\n    // ????????????????????¬??????????????§????????????????????????\n    lazy[k] = NIL;\n}\n\nvoid fix(int k) {\n    // ?????????k?????????????????????????????§?????????????????????????????§????????¨????????????????????§??????????????§???\n    maxi[k] = max(maxi[k * 2], maxi[k * 2 + 1]);\n}\n\n// ??????[queryL,queryR)???val??§???????????¶???\nvoid fill(int queryL, int queryR, int val, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨????????????????????????????????????????????????????????\\?????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return;\n    }\n    // ???????????????????????¨?????????????????¨??????????????????????????¶????????????????????????????????£?????¨??°???\n    if (queryL <= nodeL && nodeR <= queryR) {\n        setLazy(k, val);\n        return;\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    fill(queryL, queryR, val, k * 2 + 0, nodeL, nodeM);\n    fill(queryL, queryR, val, k * 2 + 1, nodeM, nodeR);\n\n    // ???????????????????????¨??????????????±???fix??????\n    fix(k);\n}\n\n// ??????[queryL, queryR)????????§???????±???????\nint maximum(int queryL, int queryR, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨???????????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return INT_MIN;\n    }\n    // ???????????????????????¨?????????????????¨???????????????\n    if (queryL <= nodeL && nodeR <= queryR) {\n        return maxi[k];\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    int vl = maximum(queryL, queryR, k * 2 + 0, nodeL, nodeM);\n    int vr = maximum(queryL, queryR, k * 2 + 1, nodeM, nodeR);\n    return max(vl, vr);\n}\n\n\nint n, q;\nint com, s, t, x;\n\n\nsigned main()\n{\n    cin >> n >> q;\n\n    for (int i=0; i<N*2; i++) {\n        lazy[i] = NIL;\n    }\n\n    fill(0, n, INT_MAX);\n\n    REP(i,q) {\n        cin >> com;\n        if (com == 0) {\n            cin >> s >> t >> x;\n            fill(s, t + 1, x);\n        } else {\n            cin >> s;\n            cout << maximum(s, s + 1) << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tDSL: domain-specific language\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/5/2017\n\tTLE: 17/22 10^10 must change the data structure--> binary tree\n\tupdate the data: set the priority\n\tWA 2/22\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 131072 //100000\n#define MAXVAL ((long int) ((unsigned long) (1 << 31) - 1))\ntypedef struct Node{\n\tint val;\n\tint priority;\n}node;\nvoid find(int i);\nvoid add(int s,int t, int x,int i);\nnode array[2*N+100];      //the size of array, for present the tree\n//BEGIN FROM 1;\nint main(){\n\tint n = 0, q = 0;\n\tint a,b,c;\n\t//FILE *fp;\n\t//fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\t\n\t//how to calculate the beginning index (the last layer of the tree)\n\tint count = 0;\n\tint temp = n;\n\twhile(n!=1){\n\t\tn = n/2;\n\t\tcount++;  \n\t}\n\tif(pow(2,count)!=temp) count++;\n\t//printf(\"count:%d\",count);\n\tint B = pow(2,count)-1;\n\tfor(int i = 0; i<=B;i++){ //special case forn==1, need i = 0;\n\t\tarray[i].val =  MAXVAL;\n\t\tarray[i].priority = 0;\n\t}\n\tfor(int i = 1; i<=n; i++){\n\t\tarray[i+B].val = MAXVAL;\t//e.g.begin from 8 (the last element of previous layer is 7)\n\t\tarray[i].priority = 0;\n\t}//printf(\"%d\\n\", array[B].val);\n\tB = B+1;\n\tfor(int i = 0; i < q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tadd(a+B,b+B,c,i);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfind(a+B);\n\t\t}\n\t}\n\treturn 0;\n}\n//add elements\n//s means: left pointer\n//t means : right pointer\nvoid add(int s,int t, int x,int i){\n\t//signle node\n\tif(s==t) {\n\t\tarray[s].val = x;\n\t\tarray[s].priority = i;\n\t\treturn;\n\t}\n\t//range update\n\t//check the left pointer\n\twhile(s<t){\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t\tif(s%2==0){ //left child, level up\n\t\t\ts = s/2;\n\t\t}else{ //right child: mark and level up + 1\n\t\t\tarray[s].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\ts = s/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tif(t%2==0){//left child: \n\t\t\tarray[t].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\tt = t/2;\n\t\t\tt--;\n\t\t} else { //right child\n\t\t\tt/= 2; \t\n\t\t}\n\t\tif(s==t) {\n\t\t\tarray[s].val =x;\n\t\t\tarray[s].priority = i;\n\t\t}// works for 1-4,1-3, 1-5\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t}\n\t\n\t//test for \n\t/*for(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", i);\n\t}printf(\"\\n\");\n\tfor(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", array[i]);\n\t}*/\n\t\n}\n\nvoid find(int i) {//the index of the tree\n\tint res = array[i].val;\n\tint max = 0; //the priority\n\t//printf(\"%d\\n\", array[i].val);\n\twhile(i>=1){\n\t\tif(array[i].priority>max){\n\t\t\tres=array[i].val;\n\t\t\t//printf(\"array:%d\",res);\n\t\t\tmax = array[i].priority;\t\n\t\t}\n\t\ti = i/2;\n\t}\n\t\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tDSL: domain-specific language\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/5/2017\n\tTLE: 17/22 10^10 must change the data structure--> binary tree\n\tupdate the data: set the priority\n\tWA 2/22\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 131072 //100000\ntypedef struct Node{\n\tint val;\n\tint priority;\n}node;\nvoid find(int i);\nvoid add(int s,int t, int x,int i);\nnode array[2*N+100];      //the size of array, for present the tree\n//BEGIN FROM 1;\nint main(){\n\tint n = 0, q = 0;\n\tint a,b,c;\n\tFILE *fp;\n\tfp = fopen(\"in.txt\",\"r\");\n\tfscanf(fp,\"%d %d\",&n,&q);\n\t\n\t//how to calculate the beginning index (the last layer of the tree)\n\tint count = 0;\n\tint temp = n;\n\twhile(n!=1){\n\t\tn = n/2;\n\t\tcount++;  \n\t}\n\tif(pow(2,count)!=temp) count++;\n\t//printf(\"count:%d\",count);\n\tint B = pow(2,count)-1;\n\tfor(int i = 0; i<=B;i++){ //special case forn==1, need i = 0;\n\t\tarray[i].val =  pow(2,31) - 1;\n\t\tarray[i].priority = 0;\n\t}\n\tfor(int i = 1; i<=n; i++){\n\t\tarray[i+B].val = pow(2,31) - 1;\t//e.g.begin from 8 (the last element of previous layer is 7)\n\t\tarray[i].priority = 0;\n\t}//printf(\"%d\\n\", array[B].val);\n\tfor(int i = 0; i < q; i++){\n\t\tint temp = 0;\n\t\tfscanf(fp,\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tfscanf(fp,\"%d %d %d\",&a,&b,&c);\n\t\t\tadd(a+B,b+B,c,i);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tfscanf(fp,\"%d\",&a);\n\t\t\tfind(a+B);\n\t\t}\n\t}\n\treturn 0;\n}\n//add elements\n//s means: left pointer\n//t means : right pointer\nvoid add(int s,int t, int x,int i){\n\t//signle node\n\tif(s==t) {\n\t\tarray[s].val = x;\n\t\tarray[s].priority = i;\n\t\treturn;\n\t}\n\t//range update\n\t//check the left pointer\n\twhile(s<t){\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t\tif(s%2==0){ //left child, level up\n\t\t\ts = s/2;\n\t\t}else{ //right child: mark and level up + 1\n\t\t\tarray[s].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\ts = s/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tif(t%2==0){//left child: \n\t\t\tarray[t].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\tt = t/2;\n\t\t\tt--;\n\t\t} else { //right child\n\t\t\tt/= 2; \t\n\t\t}\n\t\tif(s==t) {\n\t\t\tarray[s].val =x;\n\t\t\tarray[s].priority = i;\n\t\t}// works for 1-4,1-3, 1-5\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t}\n\t\n\t//test for \n\t/*for(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", i);\n\t}printf(\"\\n\");\n\tfor(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", array[i]);\n\t}*/\n\t\n}\n\nvoid find(int i) {//the index of the tree\n\tint res = array[i].val;\n\tint max = 0; //the priority\n\t//printf(\"%d\\n\", array[i].val);\n\twhile(i>=1){\n\t\tif(array[i].priority>max){\n\t\t\tres=array[i].val;\n\t\t\t//printf(\"array:%d\",res);\n\t\t\tmax = array[i].priority;\t\n\t\t}\n\t\ti = i/2;\n\t}\n\t\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T> struct Inf { static constexpr T inf() { return std::numeric_limits<T>::has_infinity() ? std::numeric_limits<T>::infinty() : std::numeric_limits<T>::max(); } };\ntemplate <> struct Inf<int> { static constexpr int inf() { return 0x3f3f3f3f; } };\ntemplate <> struct Inf<long long> { static constexpr long long inf() { return 0x3f3f3f3f3f3f3f3fLL; } };\nconstexpr int INF = Inf<int>::inf(); constexpr ll BINF = Inf<ll>::inf();\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\n// Lazy Segment Tree {{{\ntemplate <class T, class LazyOp>\nclass LazySegmentTree {\nprivate:\n\tLazyOp op;\n\tint n, h;\n\tstd::vector<T> tree, lazy;\n\tstd::vector<bool> tag;\n\n\tvoid calc(int p, int len) {\n\t\ttree[p] = op(tree[p << 1], tree[p << 1 | 1]);\n\t\tif (tag[p]) op.upd(tree[p], lazy[p], len);\n\t}\n\n\tvoid apply(int p, const T &val, int len) {\n\t\top.upd(tree[p], val, len);\n\t\tif (p < n) op.upd(lazy[p], val), tag[p] = true;\n\t}\n\n\tvoid build(int p) {\n\t\tint len = 2;\n\t\tfor (p += n; p >>= 1; len <<= 1) calc(p, len);\n\t}\n\n\tvoid push(int p) {\n\t\tint s = h, len = 1 << (h - 1);\n\t\tfor (p += n; s > 0; s--, len >>= 1) {\n\t\t\tint i = p >> s;\n\t\t\tif (tag[i]) {\n\t\t\t\tapply(i << 1, lazy[i], len);\n\t\t\t\tapply(i << 1 | 1, lazy[i], len);\n\t\t\t\tlazy[i] = op.udef(), tag[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tLazySegmentTree(const std::vector<T> &init) : n(init.size()), h(0), tree(n), lazy(n + n, op.udef()), tag(n + n) {\n\t\tfor (const T &x : init) tree.push_back(x);\n\t\twhile ((1 << h) <= n) h++;\n\t\tfor (int i=n-1;i>0;i--) tree[i] = op(tree[i << 1], tree[i << 1 | 1]);\n\t}\n\n\tvoid modify(int l, int r, const T &val) {\n\t\tpush(l); push(r);\n\t\tint l0 = l, r0 = r, len = 1;\n\t\tfor (l += n, r += n + 1; l < r; l >>= 1, r >>= 1, len <<= 1) {\n\t\t\tif (l & 1) apply(l++, val, len);\n\t\t\tif (r & 1) apply(--r, val, len);\n\t\t}\n\t\tbuild(l0); build(r0);\n\t}\n\n\tT query(int l, int r) {\n\t\tpush(l); push(r);\n\t\tT res = op.def();\n\t\tfor (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) res = op(res, tree[l++]);\n\t\t\tif (r & 1) res = op(tree[--r], res);\n\t\t}\n\t\treturn res;\n\t}\n\n};\n// }}}\n\n// Segment Tree Operators {{{\ntemplate <class T> struct SegOpTemp {\n\tconstexpr virtual T operator()(const T &lhs, const T &rhs) = 0; // query (e.g. range max/sum)\n\tconstexpr virtual T &upd(T &lhs, const T &rhs, int len = 1) = 0; // update (e.g. range add/assign)\n\tconstexpr virtual const T def() = 0; // default value for result (e.g. INF for min query)\n\tconstexpr virtual const T udef() = 0; // default value for update (e.g. 0 for add updates)\n};\n\ntemplate <class T> struct SumAdd : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return lhs + rhs; }\n\tconstexpr T &upd(T &lhs, const T &rhs, int len = 1) { return lhs += rhs * len; }\n\tconstexpr const T def() { return 0; }\n\tconstexpr const T udef() { return 0; }\n};\n\ntemplate <class T> struct SumAsg : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return lhs + rhs; }\n\tconstexpr T &upd(T &lhs, const T &rhs, int len = 1) { return lhs = rhs * len; }\n\tconstexpr const T def() { return 0; }\n\tconstexpr const T udef() { return 0; }\n};\n\ntemplate <class T> struct MinAdd : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return min(lhs, rhs); }\n\tconstexpr T &upd(T &lhs, const T &rhs, int = 1) { return lhs += rhs; }\n\tconstexpr const T def() { return Inf<T>::inf(); }\n\tconstexpr const T udef() { return 0; }\n};\n\ntemplate <class T> struct MinAsg : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return min(lhs, rhs); }\n\tconstexpr T &upd(T &lhs, const T &rhs, int = 1) { return lhs = rhs; }\n\tconstexpr const T def() { return Inf<T>::inf(); }\n\tconstexpr const T udef() { return 0; }\n};\n// }}}\n\nint solve() {\n\tint n, q; cin >> n >> q;\n\tvll init(n, (1LL << 31) - 1);\n\tLazySegmentTree<ll, MinAsg<ll>> lst(init);\n\twhile (q--) {\n\t\tint op; cin >> op;\n\t\tif (op == 0) {\n\t\t\tint l, r, v; cin >> l >> r >> v;\n\t\t\t// l--, r--;\n\t\t\tlst.modify(l, r, v);\n\t\t} else {\n\t\t\tint l; cin >> l;\n\t\t\tcout << lst.query(l, l) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << \"Case #\" << i << \": \", solve();\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\n\n\nstruct seg_zenbu{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\tint max_inf=inf*1000000ll;\n\tint min_inf=-max_inf;\n\t\n\t\n\tstruct node{\n\t\tint mi;\n\t\tint ma;\n\t\tint su;\n\t};\n\t\n\tstruct sayo{\n\t\tint a;\n\t\tint b;\n\t\t\n\t\t\n\t\tbool operator==(sayo v){\n\t\t\treturn a==v.a && b==v.b;\n\t\t}\n\t\n\t};\n\t\n\tsayo yuni={1,0};\n\t\n\tnode node_merge(node x,node y){\n\t\treturn {min(x.mi,y.mi),max(x.ma,y.ma),x.su+y.su};\n\t}\n\t\n\t\n\tvector<node> vec;\n\tvector<sayo> lazy;\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, {0,0,0});\n\t\tlazy.resize(2*cor+3,yuni);\n\t}\n\tvoid shoki2(){\n\t\tfor(int i=cor-1;i>0;i--) vec[i]=node_merge(vec[2*i],vec[2*i+1]);\n\t}\n\t\n\tsayo merge_sayo(sayo x,sayo y){\n\t\tint t1=x.a*y.a;\n\t\tint t2=x.b*y.a+y.b;\n\t\treturn {t1,t2};\n\t}\n\t\n\tnode node_sayo(node x,sayo y,int l,int r){\n\t\tif(y.a==0){\n\t\t\treturn {y.b,y.b,y.b*(r-l)};\n\t\t}\n\t\telse if(y.a>0){\n\t\t\treturn {x.mi*y.a+y.b,x.ma*y.a+y.b,x.su*y.a+(r-l)*y.b};\n\t\t}\n\t\telse{\n\t\t\treturn {x.ma*y.a+y.b,x.mi*y.a+y.b,x.su*y.a+(r-l)*y.b};\n\t\t}\n\t}\n\t\t\n\tvoid chien(int k,int l,int r){\n\t\tif(lazy[k]==yuni) return;\n\t\tif(l+1<r){\n\t\t\tvec[k]=node_sayo(vec[k],lazy[k],l,r);\n\t\t\tlazy[2*k]=merge_sayo(lazy[2*k],lazy[k]);\n\t\t\tlazy[2*k+1]=merge_sayo(lazy[2*k+1],lazy[k]);\n\t\t\tlazy[k]=yuni;\n\t\t}\n\t\telse {\n\t\t\tvec[k]=node_sayo(vec[k],lazy[k],l,r);\n\t\t\tlazy[k]=yuni;\n\t\t}\n\t}\n\t\n\tnode rangeshori(int a,int b,sayo w, int k=1,int l=0,int r=-3){\n\t\t//[a,b)を w.a倍してw.bをたす\n\t\tif(r<0) r=cor;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]=merge_sayo(lazy[k],w);\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\t\n\t\tchien(k,l,r);\n//\tcout<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\tnode w1=rangeshori(a,b,w,k*2,l,(l+r)/2);\n\t\tnode w2=rangeshori(a,b,w,k*2+1,(l+r)/2,r);\n\t\tvec[k]=node_merge(w1,w2);\n\t\treturn vec[k];\n\t}\n\t\n\t////////////////////////\n\t////////////////////////\n\t//       区間 update ///\n\t////////////////////////\t\n\t////////////////////////\n\t\n\tvoid range_upd(int l,int r,int v){\n\t\t\trangeshori(l,r,(sayo){0,v});\n\t}\n\t\n\t\n\t\n\t////////////////////////\n\t////////////////////////\n\t//       区間 add    ///\n\t////////////////////////\t\n\t////////////////////////\n\t\n\t\n\tvoid range_add(int l,int r,int v){\n\t\t\trangeshori(l,r,(sayo){1,v});\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\t\n\tint getmin(int a,int b,int k=1,int l=0,int r=-1){\n\t\t//[a,b)のminを取得\n\t\tif(r<0) r=cor;\n\t\tchien(k,l,r);\n\t\tif(r<=a || b<=l){// 区間外\n\t\t\treturn max_inf;\n\t\t}\n\t\t\n\t\tif(a<=l && r<=b){// 完全含む\n\t\t\t\n\t\t\treturn vec[k].mi;\n\t\t}\n\t\tint w1=getmin(a,b,k*2,l,(l+r)/2);\n\t\tint w2=getmin(a,b,k*2+1,(l+r)/2,r);\n\t\treturn min(w1,w2);\n\t}\n\t\n\t\n\tint getmax(int a,int b,int k=1,int l=0,int r=-1){\n\t\t//[a,b)のminを取得\n\t\tif(r<0) r=cor;\n\t\tchien(k,l,r);\n\t\tif(r<=a || b<=l){// 区間外\n\t\t\treturn min_inf;\n\t\t}\n\t\t\n\t\tif(a<=l && r<=b){// 完全含む\n\t\t\t\n\t\t\treturn vec[k].ma;\n\t\t}\n\t\tint w1=getmax(a,b,k*2,l,(l+r)/2);\n\t\tint w2=getmax(a,b,k*2+1,(l+r)/2,r);\n\t\treturn max(w1,w2);\n\t}\n\t\n\tint getsum(int a,int b,int k=1,int l=0,int r=-1){\n\t\tif(r<0) r=cor;\n\t\tchien(k,l,r);\n\t\tif(r<=a || b<=l){// 区間外\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(a<=l && r<=b){// 完全含む\n\t\t\t\n\t\t\treturn vec[k].su;\n\t\t}\n\t\tint w1=getsum(a,b,k*2,l,(l+r)/2);\n\t\tint w2=getsum(a,b,k*2+1,(l+r)/2,r);\n\t\treturn (w1+w2);\n\t}\n};\n\nseg_zenbu ss;\n\nsigned main(){\n\n\t  cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\tss.shoki1();\n\tss.shoki2();\n\tint n,q;\n\tcin>>n>>q;\n\t\n\tss.range_upd(0,n,(1ll<<31)-1);\n\tfor(int i=0;i<q;i++){\n\t\tint t;\n\t\tcin>>t;\n\t\tif(t){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tcout<<ss.getsum(y,y+1)<<endl;\n\t\t}\n\t\telse{\n\t\t\tint s,t,x;\n\t\t\tcin>>s>>t>>x;\n\t\t\tt++;\n\t\t\tss.range_upd(s,t,x);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nstruct segtree {\n    vector<int> lazy, dat;\n    int n;\n\n    segtree(int n_, int init){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.assign(n*2, init);\n        lazy.assign(n*2, -1);\n    }\n\n    void set(int l, int r, int x){\n        set(l, r, x, 0, n, 1);\n    }\n\n    void set(int l, int r, int x, int segl, int segr, int n){\n        // cout << l << ' ' << r << ' ' << x << ' ' << segl << ' ' << segr << ' ' << n << endl;\n        push(segl, segr, n);\n        if(segr <= l || r <= segl);\n        else if(l <= segl && segr <= r) lazy[n] = x;\n        else {\n            int segm = (segl + segr) / 2;\n            set(l, r, x, segl, segm, n*2);\n            set(l, r, x, segm, segr, n*2+1);\n        }\n    }\n\n    int get(int k){\n        return get(k, 0, n, 1);\n    }\n\n    int get(int k, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segl + 1 == segr) return dat[n];\n        int segm = (segl + segr) / 2;\n        if(k < segm) return get(k, segl, segm, n*2);\n        else return get(k, segm, segr, n*2+1);\n    }\n\n    void push(int segl, int segr, int node){\n        if(lazy[node] != -1){\n            dat[node] = lazy[node];\n            if(segl + 1 != segr){\n                lazy[node*2] = lazy[node];\n                lazy[node*2+1] = lazy[node];\n            }\n            lazy[node] = -1;\n        }\n    }\n};\n\nint main(){\n    int n, q;\n    while(cin >> n >> q){\n        segtree st(n, 2147483647);\n        for(int iq = 0; iq < q; ++iq){\n            int t;\n            cin >> t;\n            // dump(t);\n            if(t == 0){\n                int s, t, x;\n                cin >> s >> t >> x;\n                ++t;\n                st.set(s, t, x);\n            } else {\n                int i;\n                cin >> i;\n                cout << st.get(i) << '\\n';\n            }\n\n            // for(int i = 1; i < (int)st.dat.size(); ++i){\n            //     cout << '[' << st.dat[i] << ' ' << st.lazy[i] << ']';\n            //     if(i == 1 || i == 3 || i == 7 || i == 15) cout << endl;\n            // }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\ntemplate <typename MonoidType, typename OperatorType, class SegFunc>\nstruct LazySegmentTree {\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    void build(int m, const vector<MonoidType> &v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = SegFunc::combine(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = SegFunc::update(node[k], SegFunc::accumulate(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = SegFunc::lazy_update(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = SegFunc::lazy_update(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = SegFunc::lazy_update(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = SegFunc::combine(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return SegFunc::combine(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\n\n// Verified on Apr 27, 2019\nvoid DSL_2_D() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int b) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, INT_MAX);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\n/*\n// Verified on Apr 27, 2019\nvoid DSL_2_E() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, 0, 0,\n                                  [](int a, int b) { return a + b; },  // upd\n                                  [](int a, int b) { return a + b; },  // cmb\n                                  [](int a, int b) { return a + b; },  // lzy\n                                  [](int a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_F() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, INT_MAX, 0,\n                                  [](int a, int b) { return b;         },  // upd\n                                  [](int a, int b) { return min(a, b); },  // cmb\n                                  [](int a, int b) { return b;         },  // lzy\n                                  [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_G() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                  [](ll a, ll  b) { return a + b; },  // upd\n                                  [](ll a, ll  b) { return a + b; },  // cmb\n                                  [](ll a, ll  b) { return a + b; },  // lzy\n                                  [](ll a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, INT_MAX, 0,\n                                [](ll a, ll  b) { return a + b;     },  // upd\n                                [](ll a, ll  b) { return min(a, b); },  // cmb\n                                [](ll a, ll  b) { return a + b;     },  // lzy\n                                [](ll a, int x) { return a;         },  // acc\n                                vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                [](ll a, ll  b) { return b;     },  // upd\n                                [](ll a, ll  b) { return a + b; },  // cmb\n                                [](ll a, ll  b) { return b;     },  // lzy\n                                [](ll a, int x) { return a * x; },  // acc\n                                vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nvoid yuki_749() {\n    int N, Q; cin >> N >> Q;\n\n    \n    \n}\n*/\n\nint main() {\n    DSL_2_D();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    // DSL_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<memory>\nusing Size = int;\ntemplate<typename T> class SegmentTree {\n public:\n  SegmentTree(Size SIZE, T INF = 2e9) : SIZE(SIZE), INF(INF), ROOT(std::make_unique<Node>(0, INF)) {\n    ROOT->update = 0;\n  }\n  void update(Size a, Size b, T v) {update(a, b, v, ROOT, 0, SIZE);}\n  void add(Size a, Size b, T v) {add(a, b, v, ROOT, 0, SIZE);}\n  T sum(Size a, Size b) {return query(a, b).sum;}\n  T min(Size a, Size b) {return query(a, b).min;}\n  T max(Size a, Size b) {return query(a, b).max;}\n  Size lower_bound(T v) {}\n  void debug() {\n    traverse(ROOT, 0, SIZE, 0);\n  }\n  void traverse(const auto& n, Size l, Size r, Size d) {\n    // LEAF\n//     push(n, l, r);\n//     auto m = (l + r) / 2;\n//     if(l + 1 == r) std::cout << n->sum << \" : \" << n->min << \" : \" << n->max << std::endl;\n//     else {\n//       traverse(n->r_child, m, r, d + 1);\n//       traverse(n->l_child, l, m, d + 1);\n//     }\n    // ALL\n    push(n, l, r);\n    auto m = (l + r) / 2;\n    if(l+1 != r) traverse(n->r_child, m, r, d + 1);\n    for(auto i = 0; i < d; ++i) std::cout << \"    \";\n    std::cout << n->sum << \":\" << n->min << \":\" << n->max;\n//     std::cout << l << \" to \" << r;\n    std::cout << std::endl;\n    if(l+1 != r) traverse(n->l_child, l, m, d + 1);\n  }\n private:\n  struct Node {\n    T sum;\n    T min;\n    T max;\n    T update;\n    T add;\n    std::unique_ptr<Node> l_child, r_child;\n    Node(T v, T INF) : sum(v), min(v), max(v), update(INF), add(INF) {}\n  };\n  inline void push(const auto& n, Size l, Size r) {\n    if(not n->l_child) n->l_child = std::make_unique<Node>(0, INF);\n    if(not n->r_child) n->r_child = std::make_unique<Node>(0, INF);\n    if(n->update != INF) {\n      n->add = INF;\n      n->l_child->update = n->r_child->update = n->update;\n      n->sum = (r - l) * n->update;\n      n->min = n->update;\n      n->max = n->update;\n      n->update = INF;\n    }\n    if(n->add != INF) {\n      if(n->l_child->add != INF) n->l_child->add += n->add;\n      else                       n->l_child->add = n->add;\n      if(n->r_child->add != INF) n->r_child->add += n->add;\n      else                       n->r_child->add = n->add;\n      if(n->l_child->update != INF) n->l_child->update += n->add;\n      if(n->r_child->update != INF) n->r_child->update += n->add;\n      n->sum += (r - l) * n->add;\n      n->min += n->add;\n      n->max += n->add;\n      n->add = INF;\n    }\n  }\n  inline void fix(const auto& n) {\n    n->sum = n->l_child->sum + n->r_child->sum;\n    n->min = std::min(n->l_child->min, n->r_child->min);\n    n->max = std::max(n->l_child->max, n->r_child->max);\n  }\n  void update(Size a, Size b, T v, const auto& n, Size l, Size r) {\n    push(n, l, r);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {\n      n->update = v;\n      push(n, l, r);\n      return;\n    }\n    auto m = (l + r) / 2;\n    update(a, b, v, n->l_child, l, m);\n    update(a, b, v, n->r_child, m, r);\n    fix(n);\n  }\n  void add(Size a, Size b, T v, const auto& n, Size l, Size r) {\n    push(n, l, r);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {\n      n->add = v;\n      push(n, l, r);\n      return;\n    }\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n    fix(n);\n  }\n  Node query(Size a, Size b) {\n    Node res(0, INF);\n    res.min = INF;\n    res.max = -INF;\n    query(res, a, b, ROOT, 0, SIZE);\n    return res;\n  }\n  void query(auto& res, Size a, Size b, const auto& n, Size l, Size r) {\n    push(n, l, r);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {\n      res.sum += n->sum;\n      res.min = std::min(res.min, n->min);\n      res.max = std::max(res.max, n->max);\n      return;\n    }\n    auto m = (l + r) / 2;\n    query(res, a, b, n->l_child, l, m);\n    query(res, a, b, n->r_child, m, r);\n  }\n  const Size SIZE;\n  const T INF;\n  const std::unique_ptr<Node> ROOT;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, q;\n  cin >> n >> q;\n  SegmentTree<long long> segtree(n);\n  segtree.update(0, n, 2147483647);\n  for(auto i = 0; i < q; ++i) {\n    int type;\n    cin >> type;\n    if(type) {\n      int i;\n      cin >> i;\n      cout << segtree.sum(i, i+1) << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      segtree.update(s, t+1, x);\n    }\n  }\n//   segtree.debug();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<vector>\n#include<climits>\n#include<map>\n#include<string>\n#include<functional>\n#include<iomanip>\n#include<deque>\n#include<random>\n#include<set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef double lldo;\n#define mp make_pair\n#define pub push_back\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define sz(x) int(x.size())\nll gcd(ll a, ll b) { if (a % b == 0) { return b; } else  return gcd(b, a % b); }\nll lcm(ll a, ll b) { if (a == 0) { return b; }return a / gcd(a, b) * b; }\ntemplate<class T>ll LBI(vector<T>& ar, T in) { return lower_bound(ar.begin(), ar.end(), in) - ar.begin(); }\ntemplate<class T>ll UBI(vector<T>& ar, T in) { return upper_bound(ar.begin(), ar.end(), in) - ar.begin(); }\n\nll n, q, com, s, t, x, i;\n\nconst int INF = (1LL << 31) - 1;\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n\tint N, K;\n\tvector<int> data;\n\tvector<bool> lazyFlag;\n\tvector<int> lazyUpdate;\n\tSqrtDecomposition(int n) : N(n) {\n\t\tK = (N + sqrtN - 1) / sqrtN;\n\t\tdata.assign(K * sqrtN, INF);\n\t\tlazyFlag.assign(K, false);\n\t\tlazyUpdate.assign(K, 0);\n\t}\n\tvoid eval(int k) {\n\t\tif (lazyFlag[k]) {\n\t\t\tlazyFlag[k] = false;\n\t\t\tfor (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n\t\t\t\tdata[i] = lazyUpdate[k];\n\t\t\t}\n\t\t}\n\t}\n\t// [s, t)\n\tvoid update(int s, int t, int x) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tint l = k * sqrtN, r = (k + 1) * sqrtN;\n\t\t\tif (r <= s || t <= l)\n\t\t\t\tcontinue;\n\t\t\tif (s <= l && r <= t) {\n\t\t\t\tlazyFlag[k] = true;\n\t\t\t\tlazyUpdate[k] = x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\teval(k);\n\t\t\t\tfor (int i = max(s, l); i < min(t, r); ++i) {\n\t\t\t\t\tdata[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint find(int i) {\n\t\tint k = i / sqrtN;\n\t\teval(k);\n\t\treturn data[i];\n\t}\n};\n\nint main() {\n\tcin >> n >> q;\n\tSqrtDecomposition ruq(n);\n\trep(j, q) {\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tcin >> i;\n\t\t\tcout << ruq.find(i) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    std::vector<bool> lazyFlag;\n    const function<T (T, T)> f;     // 要素に適用する演算\n    const function<T (T, T)> g;     // 作用素の適用\n    const function<T (T, T)> h;     // 作用素の合成\n    const function<T (T, int)> p;\n    const T unit;\n\npublic:\n    class Mode {\n    public:\n        function<T (T, T)> f;\n        function<T (T, T)> g;\n        function<T (T, T)> h;\n        function<T (T, int)> p;\n        T unit;\n    };\n\n    enum Query {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum Operation {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, const Mode mode) : array_size(v.size()),  f(mode.f), g(mode.g), h(mode.h), p(mode.p), unit(mode.unit){\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, 0);\n        lazyFlag.resize(2 * n - 1, false);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    static Mode getMode(const Query query, const Operation operation) {\n        Mode mode;\n        if (query == RangeMinimumQuery) {\n            mode.unit = INT_MAX;\n            mode.f = [](T a, T b) { return std::min(a, b); };\n\n            if (operation == Update) {\n                mode.g = [](T a, T b) { return b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeMaximumQuery) {\n            mode.unit = -INT_MAX;\n            mode.f = [](T a, T b) { return std::max(a, b); };\n            if (operation == Update) {\n                mode.g = [](T a, T b) { return b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeSummationQuery) {\n            mode.unit = 0;\n            mode.f = [](T a, T b) { return a + b; };\n\n            if (operation == Update) {\n                mode.g = [](T a, T b) { return b;};\n                mode.h = mode.g;\n                mode.p = [](T a, int len) {return a * len;};\n            }\n            else if (operation == Add) {\n                mode.g = [](T a, T b) { return b;};\n                mode.h = [](T a, T b) { return a + b;};\n                mode.p = [](T a, int len) {return a * len;};\n            }\n        }\n        else {\n            assert(false);\n        }\n        return mode;\n    }\n\n    // array[idx]\n    // log(N)\n    T access(const int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] += x\n    // log(N)\n    void update(const int idx, const T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) += x\n    // log(N)\n    void update(const int left, const int right, const T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(const int left, const int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(const int a, const int b, const T x, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            lazyFlag[k] = true;\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(const int a, const int b, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (not lazyFlag[k]) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazyFlag[2 * k + 1] = true;\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n            lazyFlag[2 * k + 2] = true;\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazyFlag[k] = false;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1, 2147483647);\n\n    auto mode = LazySegmentTree<LL>::getMode(LazySegmentTree<LL>::Query::RangeMinimumQuery, LazySegmentTree<LL>::Operation::Update);\n    LazySegmentTree<LL> lst(v, mode);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> i;\n            print(lst.access(i));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvoid update(vector<int> &a, int s, int t, int x) {\n    for(int i=s; i<=t; ++i) {\n        a[i] = x;\n    }\n}\n\nint find(vector<int> a, int i) {\n    return a[i];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n, pow(2, 31) - 1);\n\n    vector<int> com, s, t, x;\n\n    for(int i=0; i<q; ++i) {\n        int a;\n        cin >> a;\n        if(a == 0) {\n            int b, c, d;\n            cin >> b >> c >> d;\n            com.push_back(a);\n            s.push_back(b);\n            t.push_back(c);\n            x.push_back(d);\n        } else {\n            int b;\n            cin >> b;\n            com.push_back(a);\n            s.push_back(b);\n            t.push_back(0);\n            x.push_back(0);\n        }\n    }\n\n    for(int i=0; i<q; ++i) {\n        if(com[i] == 0) {\n            update(a, s[i], t[i], x[i]);\n        } else if(com[i] == 1) {\n            cout << find(a, s[i]) << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nconst ll INF=(1ll<<31)-1;\nint a[100001];\nint b[1005];\nint main(){\n    int n,q;\n    cin>>n>>q;\n    int sqn=sqrt(n);\n    int bn=(n+sqn-1)/sqn;\n    rep(i,n) a[i]=INF;\n    rep(i,bn) b[i]=INF;\n    int com;\n    rep(i,q){\n        cin>>com;\n        if(com==0){\n            int s,t,x;\n            //[s,t)\n            cin>>s>>t>>x;\n            ++t;\n            rep(j,bn+1){\n                int l=j*sqn,r=(j+1)*sqn;\n                if(r<=s||t<=l) continue;\n                if(s<=l&&r<=t) b[j]=x;\n                else{\n                    FOR(k,l,r){\n                        if(k>=max(s,l)&&k<min(t,r)) a[k]=x;\n                        else if(b[j]!=INF) a[k]=b[j];\n                    }\n                    b[j]=INF;\n                }\n            }\n        }\n        if(com==1){\n            int k;\n            cin>>k;\n            int cur=k/sqn;\n            if(b[cur]!=INF){\n                FOR(j,cur*sqn,(cur+1)*sqn){\n                    a[j]=b[cur];\n                }\n                b[cur]=INF;\n            }\n            cout<<a[k]<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int maxn=400005;\n\nstruct {\n\tll mn=0x7fffffff,lazy=-1;\t\n} S[maxn];\nint n,q;\n\nvoid update(int id,int ql,int qr,int v,int l,int r) {\n\tif (ql==l && qr==r) {\n\t\tS[id].lazy=v;\n\t\treturn;\n\t}\n\tif (S[id].lazy!=-1) {\n\t\tS[id].mn=S[id].lazy;\n\t\tif (l!=r) S[id<<1].lazy=S[id<<1|1].lazy=S[id].lazy;\n\t\tS[id].lazy=-1;\n\t}\n\tint m=l+r>>1;\n\tif (qr<=m) update(id<<1,ql,qr,v,l,m);\n\telse if (ql>m) update(id<<1|1,ql,qr,v,m+1,r);\n\telse update(id<<1,ql,m,v,l,m), update(id<<1|1,m+1,qr,v,m+1,r);\n\tint lm=S[id<<1].lazy==-1?S[id<<1].mn:S[id<<1].lazy;\n\tint rm=S[id<1|1].lazy==-1?S[id<<1|1].mn:S[id<<1|1].lazy;\n\tS[id].mn=min(lm,rm);\n}\n\nint query(int id,int i,int l,int r) {\n\tif (S[id].lazy!=-1) {\n\t\tS[id].mn=S[id].lazy;\n\t\tif (l!=r) S[id<<1].lazy=S[id<<1|1].lazy=S[id].lazy;\n\t\tS[id].lazy=-1;\n\t}\n\tif (l==r) return S[id].mn;\n\tint m=l+r>>1;\n\tif (i<=m) return query(id<<1,i,l,m);\n\telse return query(id<<1|1,i,m+1,r);\n}\n\nint main() {\n\tcin>>n>>q;\n\tfor (int i=0;i<q;i++) {\n\t\tbool op; cin>>op;\n\t\tif (op) {\n\t\t\tint k; cin>>k;\n\t\t\tcout<<query(1,k,0,n-1)<<'\\n';\n\t\t}\n\t\telse {\n\t\t\tint s,t,x;\n\t\t\tcin>>s>>t>>x;\n\t\t\tupdate(1,s,t,x,0,n-1);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 2147483647\ntypedef long long ll;\nusing namespace std;\n#define N (1<<17)\nclass RUQ{\nprivate:\n    int dat[2*N];\n    vector<int> hs;\n    void dfs(int l,int r,int a,int b,int k,int x){\n\tif(l<=a&&b<=r){dat[k]=x;return;}\n\tif(b<=l||r<=a)return;\n\tint m=(a+b)/2;\n\tdfs(l,r,a,m,k*2+1,x);\n\tdfs(l,r,m,b,k*2+2,x);\n    }\npublic:\n    void Init(){\n\ths.push_back(mod);\n\tlol(i,2*N)dat[i]=0;\n    }\n    void Update(int l,int r,int x){\n\tdfs(l,r+1,0,N,0,hs.size());\n\ths.push_back(x);\n    }\n    int Query(int i){\n\ti+=N-1;\n\tint maxi=dat[i];\n\twhile(i){\n\t    i=(i-1)/2;\n\t    maxi=max(maxi,dat[i]);\n\t}\n\treturn hs[maxi];\n    }\n};\nint main(){\n    int n,q;cin>>n>>q;\n    RUQ ruq;ruq.Init();\n    while(q--){\n\tint c;cin>>c;\n\tif(c==0){\n\t    int a,b,x;cin>>a>>b>>x;\n\t    ruq.Update(a,b,x);\n\t}\n\tif(c==1){\n\t    int x;cin>>x;\n\t    cout<<ruq.Query(x)<<endl;\n\t}\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define SORT(a) sort((a).begin(),(a).end())\n#define oorret 0\n#define oor(x) [&](){try{x;} catch(const out_of_range& oor){return oorret;} return x;}()\n#define IOS cin.tie(0),ios::sync_with_stdio(false)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<ll, ll> P;\ntemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class Type>struct is_vector : std::false_type {};\ntemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\ntemplate <typename T> inline std::ostream& operator << (std::ostream& out, const std::vector<T>& v) {\n    if (v.empty())return out;\n    constexpr bool is_vector_v = is_vector<T>::value;\n    if (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n    else for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n    return out;\n}\ninline void put() {}\ntemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\ntemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\ninline void putn() {}\ntemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\ntemplate<typename T>\nclass LazySegmentTree{\npublic:\n    int sz = 1;\n    T elemUp; // upの単位元\n    T elemPr; // procの単位元\n    vector<T> seg; // セグメント木のデータ配列\n    vector<T> lazy; // 遅延評価用の配列\n    T up(T& a,T b){ // 更新関数\n        if(b==elemUp)return a;\n        if(a==elemUp)return b;\n        return b; // 代入\n    }\n    T proc(T& a,T b){ // 評価関数\n        if(b==elemPr)return a;\n        if(a==elemPr)return b;\n        if(a>b)return a;// max\n        return b;\n    }\n    T cont(T& a,int b){ // aをb回procした値\n        if(b<=0)return elemPr;\n        if(b%2==0){\n            T c = cont(a,b/2);\n            return proc(c,c);\n        }else{\n            return proc(a,b-1);\n        }\n        return a;\n    }\n    T contSum(T& a,int b){ // procが加算のとき\n        return a*b;\n    }\n    T contId(T& a,int b){ // 繰り返しても同じ値になるもの(max,min,etc...)\n        return a;\n    }\n    LazySegmentTree(int n,T ep=0,T eu=0):elemPr(ep),elemUp(eu){\n        while (sz < n) sz <<= 1;\n        seg.clear();\n        lazy.clear();\n        seg.resize(sz * 2, elemPr);\n        lazy.resize(sz * 2, elemUp);\n    }\n    void init(std::vector<T> ary){ // aryで初期化する\n        const int n = (int)ary.size();\n        for(int64_t i=0;i<n;++i){\n            set(i,ary[i]);\n        }\n        for(int64_t i=sz-2;i>=0;--i){\n            proc(seg[2*i+1], seg[2*i+2]);\n        }\n    }\n    inline void set(const int& k, const T& x) {// 左からk番目の葉にxを代入する\n        seg[sz - 1 + k] = x;\n    }\n    \n    // k 番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r, int c = 0) { // k = [l,r)\n        if(lazy[k] != elemUp) {\n            seg[k] = up(seg[k],lazy[k]);\n            int len = r-l;\n            if(len > 1){\n                lazy[2*k+1] = up(lazy[2*k+1],lazy[k]);\n                lazy[2*k+2] = up(lazy[2*k+2],lazy[k]);\n            }\n            if(c==0){\n                seg[k] = up(seg[k],cont(lazy[k],len));\n            }else if(c==1){\n                seg[k] = up(seg[k],contSum(lazy[k],len));\n            }else if(c==2){\n                seg[k] = up(seg[k],contId(lazy[k],len));\n            }\n            lazy[k] = elemUp;\n        }\n    }\n    void update(int a,int b,T x,int k=0,int l=0,int r=-1){ // i in [a,b)に更新up(seg[i],a)を適用\n        if(r < 0) r = sz;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){// 被覆\n            lazy[k] = up(lazy[k],x);\n            eval(k, l, r);\n        }else{// 非被覆\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            seg[k] = proc(seg[2*k+1], seg[2*k+2]);\n        }\n    }\n    T query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = sz;\n        if(b <= l || r <= a) return elemPr;\n        eval(k, l, r);\n        if(a <= l && r <= b) return seg[k];\n        T vl = query(a, b, 2*k+1, l, (l+r)/2);\n        T vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return proc(vl, vr);\n    }\n};\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    LazySegmentTree<int> lst(n,INT_MAX,-1);\n    REP(i,q){\n        int que;\n        cin >> que;\n        if(que==0){\n            int s,t,x;\n            cin >> s >> t >> x;\n            lst.update(s,t+1,x);\n        }else{\n            int j;\n            cin >> j;\n            put(lst.query(j,j+1));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nclass RangeSeg{\n\tint n;\n\tvector<ll> data, lazy;\npublic:\n\tRangeSeg(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n <<= 1;\n\t\tREP(i, n*2-1){\n\t\t\tdata.push_back(-1);\n\t\t\tlazy.push_back(-1);\n\t\t}\n\t}\n\n\tvoid push(int l, int r, int k){\n\t\tif(lazy[k] != -1){\n\t\t\tdata[k] = lazy[k];\n\t\t\tif(r - l > 1){\n\t\t\t\tlazy[k*2+1] = lazy[k];\n\t\t\t\tlazy[k*2+2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int l, int r, int k, int x){\n\t\tpush(k, l, r);\n\t\tif(s <= l && r <= t){\n\t\t\tlazy[k] = x;\n\t\t\tpush(l, r, k);\n\t\t}else if(l < t && s < r){\n\t\t\tupdate(s, t, (l+r)/2, r, k*2+2, x);\n\t\t\tupdate(s, t, l, (l+r)/2, k*2+1, x);\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tupdate(s, t, 0, n, 0, x);\n\t}\n\t\n\tvoid show(){\n\t\tint i = 0;\n\t\tint en = 1;\n\t\twhile(i < n*2-1){\n\t\t\tcout << \"(\" << data[i] << \", \" << lazy[i] << \") \";\n\t\t\tif(i == en*2-2){\n\t\t\t\tcout << endl;\n\t\t\t\ten *= 2;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tll find(int l, int r, int k, int i){\n\t\tpush(l, r, k);\n\t\tif(r-l == 1){\n\t\t\treturn data[k];\n\t\t}\n\t\tif(l <= i && i <= r){\n\t\t\tif((l+r)/2 <= i){\n\t\t\t\treturn find((l+r)/2, r, k*2+2, i);\n\t\t\t}else{\n\t\t\t\treturn find(l, (l+r)/2, k*2+1, i);\n\t\t\t}\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tll find(int i){\n\t\treturn find(0, n, 0, i);\n\t}\t\n};\n\nint main(void){\n\tint n, q;\n\tcin >> n >> q;\n\tRangeSeg rs(n);\n\tREP(i, q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(com == 0){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\trs.update(s, t+1, x);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tx = rs.find(x);\n\t\t\tif(x == -1)\n\t\t\t\tcout << (ll)(1 << 31)-1 << endl;\n\t\t\telse\n\t\t\t\tcout << x << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <limits.h>\nint n; //the sieze of the target array\nint l; // the real size of tree;\nint q; //number of querys\nint *D; //segment tree, D[i] = min value in range node i\nint s;\nint t;\nint x;\nint com;\nint INF;\nint array2tree(int k){return k+n-1;}\nint parent(int k){return (k-1)/2;}\nint left_child(int k){return 2*k+1;}\nint right_child(int k){return 2*k+2;}\nint MIN(int ki){ if(D[left_child(ki)] > D[right_child(ki)]){return D[right_child(ki)];}else{return D[left_child(ki)];}    }\nint min(int a, int b){if (a > b){return b;}else{return a;} }\n\nvoid initRMQ();\nvoid update_leaf();\nvoid update(int ki, int ks, int kt);\nint find(int ki);\nvoid fetch();\n\nint main(){\n\tscanf(\"%d %d\",&n,&q);\n\tinitRMQ();\n\twhile(q>0){\n\t\tfetch();\n\t\tq--;\n\t}\n}\n\nvoid initRMQ(){\n\tINF = INT_MAX;\n\tint i = 1;\n\twhile( i< n ){\n\t\ti *= 2;\n\t}\n\tif(i>1){\n\tl = 2*i-1-1;\n\t}else {l = 1;};\n\tD = new int[l];\n\tif(!D){printf(\"new a D array falied \\n\");return;}\n\tfor(i = 0; i<l;i++){\n\t\tD[i] = INF;\n\t}\n\n}// end of initRMQ\n\nvoid fetch(){\n\tscanf(\"%d\",&com);\n\tif(com){\n\t\tscanf(\"%d\",&s);\n\t\tprintf(\"%d\\n\",find(s));\n\t}else{\n\t\tscanf(\"%d %d %d\",&s,&t,&x);\n\t\tt++;\n\t\t//update_leaf();\n\t\tupdate(0,0,l);\n\t}\n}\nint find(int ki){\n\t//check range\n\t//if(ks>kt || ks>t || kt<s){return INF;}\n//\n\t//if(ks >= s && kt <= t){\n\t//\treturn D[ki];\n\t//}\n\t// start recursive\n\t//int mid = (ks+kt)/2;\n\t//return min(find(left_child(ki),ks, mid), find(right_child(ki), mid+1, kt));\n\tif(n > 1){\n\treturn D[l - (n - ki)];}\n\telse{\n\t\treturn D[0];\n\t}\n}\nvoid update_leaf(){\n\tint i;\n\tint ks = s+ n -1;\n\tint kt = t + n-1;\n\tfor(i = ks; i <= kt; i++){\n\t\tD[i] = x;\n\t}\n}\nvoid update(int ki, int ks, int kt){\n\tint i;\n\tint mid = (ks+kt)/2;\n\t//check range\n\tif(kt <= s  || t <= ks ){return;}\n\n\t\n\tif(s <= ks && kt <= t){\n\t\tif(ki < l-n){\n\t\t\tupdate(left_child(ki),ks, mid);\n\t\t\tupdate(right_child(ki), mid, kt);\n\t\t}else {\n\t\tif(ks != kt){\n\t\t\tupdate(ki+1,ks+1,kt);\n\t\t}\n\t\t}\n\n\t\tD[ki] = x;\n\t\treturn;\n\t}\n\n\t// start recursive\n\tif(ki < l-n){\n\tupdate(left_child(ki),ks, mid);\n\tupdate(right_child(ki), mid, kt);\n\tD[ki] = MIN(ki);\n\t}else {if(ks != kt){\n\t\tupdate(ki+1, ks+1, kt);\n\t}}\n\n\t\n}// end of update\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#include <functional>\nusing namespace std;\n\n// 動的遅延セグメント木 (必要なところだけノードを作る)\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegNode {\n    MonoidType value;\n    OperatorType lazy_value;\n    bool need_update;\n    LazySegNode *ch[2];\n    \n    LazySegNode() {}\n    LazySegNode(MonoidType value_, OperatorType lazy_value_) :\n        value(value_), lazy_value(lazy_value_) {\n        need_update = false;\n        ch[0] = ch[1] = nullptr;\n    }\n};\n\ntemplate <typename MonoidType, typename OperatorType, typename IdxType = int>\nstruct DynamicLazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n    using LNode = LazySegNode<MonoidType, OperatorType>;\n\n    // node, identity element\n    IdxType n;\n    LNode *root;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    DynamicLazySegmentTree() {}\n    DynamicLazySegmentTree(IdxType n_, MonoidType E0_, OperatorType E1_,\n                           MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        root = new LNode(E0_, E1_);\n        n = 1; while(n < n_) n *= 2;\n    }\n\n    void eval(LNode *node, IdxType l, IdxType r) {\n        if(!node->need_update) return;\n        node->value = upd_f(node->value, acc_f(node->lazy_value, r - l));\n        if(r - l > 1) {\n            if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n            if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n            node->ch[0]->lazy_value = lzy_f(node->ch[0]->lazy_value, node->lazy_value);\n            node->ch[1]->lazy_value = lzy_f(node->ch[1]->lazy_value, node->lazy_value);\n            node->ch[0]->need_update = node->ch[1]->need_update = true;\n        }\n        node->lazy_value = E1;\n        node->need_update = false;\n    }\n\n    void update(LNode *node, IdxType a, IdxType b, OperatorType x,\n                IdxType l, IdxType r) {\n        eval(node, l, r);\n        if(b <= l or r <= a) return;\n        if(a <= l and r <= b) {\n            node->lazy_value = lzy_f(node->lazy_value, x);\n            node->need_update = true;\n            eval(node, l, r);\n        }\n        else {\n            IdxType mid = (l + r) / 2;\n            if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n            if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n            update(node->ch[0], a, b, x, l, mid);\n            update(node->ch[1], a, b, x, mid, r);\n            node->value = cmb_f(node->ch[0]->value, node->ch[1]->value);\n        }\n    }\n\n    MonoidType query(LNode *node, IdxType a, IdxType b, IdxType l, IdxType r) {\n        if(b <= l or r <= a) return E0;\n        eval(node, l, r);\n        if(a <= l and r <= b) return node->value;\n        IdxType mid = (l + r) / 2;\n        MonoidType vl = (node->ch[0] ? query(node->ch[0], a, b, l, mid) : E0);\n        MonoidType vr = (node->ch[1] ? query(node->ch[1], a, b, mid, r) : E0);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value: x)\n    void update(IdxType a, IdxType b, OperatorType x) {\n        update(root, a, b, x, 0, n);\n    }\n\n    // range query for [a, b)\n    MonoidType query(IdxType a, IdxType b) {\n        return query(root, a, b, 0, n);\n    }\n};\n\n\nvoid DSL_2_D() {\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int> seg(N, INT_MAX, INT_MAX,\n                                         [](int a, int b) { return b; },\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return b; },\n                                         [](int a, int b) { return a; });\n\n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int q; cin >> q;\n        if(q == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            s -= indexed; t -= indexed; t++;\n            seg.update(s, t, x);\n        }\n        if(q == 1) {\n            int k; cin >> k;\n            k -= indexed;\n            cout << seg.query(k, k+1) << endl;\n        }\n    }\n}\n\nint main() {\n    DSL_2_D();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = -1 * (((1<<30)-1)*2+1) ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nclass Bucket{\n  public:\n  vector<ll> buc,v;\n  ll N,sqn,K;\n  Bucket(){};\n  Bucket(ll n){\n    N = n;\n    sqn = sqrt(N);\n    K = (n + sqn - 1) /sqn;\n    buc.assign(K,-inf);\n    v.assign(K * sqn,-inf);\n  }\n  ll find(int x){\n    lazyupdate(x/sqn);\n    return v[x];\n  }\n  void lazyupdate(int k){\n    if(buc[k] != -inf){\n      for(int i = k * sqn; i < (k+1) * sqn;++i){\n        v[i] = buc[k];\n      }\n    }\n    buc[k] = -inf;\n  }\n  void update(int x,int y,int n){\n    for (int k = 0; k < K; ++k) {\n      int l = k * sqn, r = (k + 1) * sqn;\n      if (r <= x || y <= l)\n        continue;\n      if (x <= l && r <= y) {\n        buc[k] = n;\n      } else {\n        if(l <= x){\n          lazyupdate(k);\n        }\n        if(r > y){\n          lazyupdate(k+1);\n        }\n        for (int i = max(x, l); i < min(y, r); ++i) {\n          v[i] = n;\n        }\n      }\n    }\n  }\n  void Debug(){\n    for(int i = 0; i < N;++i){\n      cout << buc[i/sqn] << ' ';\n    }\n    cout << endl;\n    for(int i = 0; i < N;++i){\n      cout << v[i] << ' ';\n    }\n    cout << endl;\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n, q,s,t,x,a;\n  cin >> n >> q;\n  Bucket buc(n);\n  rep(i,q){\n    cin >> a;\n    if(a){\n      cin >> s;\n      cout << buc.find(s) << endl;\n    }\n    else{\n      cin >> s >> t >> x;\n      buc.update(s,t+1,x);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename Tp, typename Op>\nclass segtree{\n    size_t length;\n    Tp vid;\n    Op fid;\n    Tp (*action)(Op, Tp);\n    Op (*composite)(Op, Op);\n    Op *otree;\n    Tp *value;\n\n    void eval(size_t pos){\n        if(otree[pos] == fid) return;        \n        size_t ch = pos << 1;\n        if(ch < length){\n            otree[ch+0] = composite(otree[pos], otree[ch+0]);\n            otree[ch+1] = composite(otree[pos], otree[ch+1]);\n        }else{\n            ch -= length;\n            value[ch+0] = action(otree[pos], value[ch+0]);\n            value[ch+1] = action(otree[pos], value[ch+1]);\n        }\n        otree[pos] = fid;\n    }\npublic:\n    segtree(size_t n, Tp e, Op id, Tp (*action_)(Op, Tp), Op (*composite_)(Op, Op))\n    : length(n), vid(e), fid(id), action(action_), composite(composite_){\n        otree = new Op[n];\n        value = new Tp[n];\n        for(size_t i=0;i<length;++i){ otree[i] = fid; value[i] = vid; }\n    }\n    void operate(Op f, size_t left, size_t right){\n        left  += length;\n        right += length;\n        for(size_t pos = 1, b = sizeof(unsigned int) * CHAR_BIT - __builtin_clz(left ) - 1; b > 0; pos = (pos << 1) | (left  >> --b & 1)) eval(pos);\n        for(size_t pos = 1, b = sizeof(unsigned int) * CHAR_BIT - __builtin_clz(right) - 1; b > 0; pos = (pos << 1) | (right >> --b & 1)) eval(pos);\n\n        if(left  & 1){ value[left    - length] = action(f, value[left    - length]); left++; }\n        if(right & 1){ value[right-1 - length] = action(f, value[right-1 - length]); }\n        left >>= 1; right >>= 1;\n        while(left < right){\n            if(left  & 1){ otree[left   ] = composite(f, otree[left   ]); ++left; }\n            if(right & 1){ otree[right-1] = composite(f, otree[right-1]); }\n            left >>= 1; right >>= 1;\n        }\n    }\n    void set(size_t i, Tp val){\n        i += length;\n        for(size_t pos = 1, b = sizeof(unsigned int) * CHAR_BIT - __builtin_clz(i) - 1; b > 0; pos = (pos << 1) | (i >> --b & 1)) eval(pos);\n        value[i - length] = val;\n    }\n    Tp get(size_t i){\n        i += length;\n        for(size_t pos = 1, b = sizeof(unsigned int) * CHAR_BIT - __builtin_clz(i) - 1; b > 0; pos = (pos << 1) | (i >> --b & 1)) eval(pos);\n        return value[i - length];\n    }\n};\n\nusing namespace std;\nint main(){\n    size_t n, q;\n    cin >> n >> q;\n    segtree<int, int> st{ n, (1U<<31) - 1, (1U<<31) - 1, [](int f, int x){ return f; }, [](int y, int x){ return y; }};\n    while(q--){\n        int tp, i, s, t, x;\n        cin >> tp;\n        if(tp == 0){\n            cin >> s >> t >> x;\n            st.operate(x, s, t+1);\n        }else{\n            cin >> i;\n            cout << st.get(i) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<class T, class Func = function<T(T,T)>>\nstruct foldMonoid{\n    T e;\n    const Func f;\n    foldMonoid(T e_, const Func f_) : e(e_),f(f_){};\n};\n\ntemplate<class T, class Func = function<T(T,T)>>\nstruct ActionMonoid{\n    T e;\n    const Func g,h,p;\n    ActionMonoid(T e_,const Func g_, const Func h_, const Func p_) : e(e_),g(g_), h(h_), p(p_){};\n};\n/*\n       g : T × E -> T s.t apply E to T\n       h : E × E -> merge E and E\n       p : E × N -> p(a,b):= g(a,a,......a ),\n                               |__________|\n                                    b\n*/\ntemplate<class T, class Func = function<T(T,T)>>\nclass LazySegtree{\nprivate:\n    const size_t N;\n    const ActionMonoid<T> action_monoid;\n    const foldMonoid<T> fold_monoid;\n    size_t offset;\n    vector<T>obj, lazy;\n    Func action_updater, lazy_updater;\n    /* re-size vectors capacity */\n    size_t bufsize(size_t num) {\n        int i = 1;\n        for (; (int) num + 1 > i; i <<= 1);\n        offset = i - 1;\n        return (i << 1) - 1;\n    }\n    /* update k-node*/\n    void flush(int k, int l, int r){\n        if(lazy[k] == action_monoid.e){\n            // There is no vlaue to propagate\n        } else {\n            obj[k] = action_monoid.g(obj[k],action_monoid.p(lazy[k],r - l));\n            // if(r - l <= 1) -> least\n            if(r - l > 1) {\n                lazy[2 * k + 1] = action_monoid.h( lazy[2 * k + 1],lazy[k]);\n                lazy[2 * k + 2] = action_monoid.h( lazy[2 * k + 2],lazy[k]);\n            }\n            lazy[k] = action_monoid.e;\n        }\n    }\n    void action(int a, int b, T val, int k, int l, int r){\n        if (r < 0) r = (int)offset + 1;\n        flush(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            // perfectly coverd range\n            // TODO := why f???\n            lazy[k] = action_monoid.h(lazy[k], val);\n            flush(k, l, r);\n        } else {\n            action(a, b, val, 2 * k + 1, l, (l+r)/2);\n            action(a, b, val, 2 * k + 2, (l+r)/2, r);\n            obj[k] = fold_monoid.f(obj[2 * k + 1],obj[2 * k + 2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        flush(k,l,r);\n        if (r <= a || b <= l)return fold_monoid.e;\n        if (a <= l && r <= b)return obj[k];\n        else return fold_monoid.f(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n    }\npublic:\n    void action(int l,int r, T val){\n        action(l,r,val,0,0,-1);\n    }\n    T query(int a, int b) {//[a,b)\n        return query(a, b, 0, 0, (int)offset + 1);\n    }\n    \n    LazySegtree(size_t treesize_,T init_, foldMonoid<T>foldM, ActionMonoid<T>ActionM)\n    : N(treesize_),fold_monoid(foldM), action_monoid(ActionM)\n    {\n        obj  = vector<T>(bufsize(N), init_);\n        lazy = vector<T>(bufsize(N), action_monoid.e);\n        \n    }\n    \n};\nauto Add = [](Int a, Int b ) {return a + b;};\nauto Mul = [](Int a, Int b ) {return a * b;};\nauto g = [](int a, int b){return b;};\nInt e = 0LL;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n; cin >> n;\n    int q; cin >> q;\n    ActionMonoid<Int>act(-10000000,g,g,Mul);\n    foldMonoid<Int>fm(e,Add);\n    LazySegtree<Int>lsgt(n,(1LL << 31) - 1,fm,act);\n    for(int i = 0; i < q; ++i){\n        int Q; cin >> Q;\n        if(Q == 1){\n            int s,t; cin >> s;\n            ++t;\n            cout << lsgt.query(s,s+1) << endl;\n        } else {\n            int s,t,x; cin >> s >> t >> x;\n            ++t;\n            lsgt.action(s,t,(Int)x);\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a,b) make_pair(a,b)\n\n\n//RUQ RMQ セグメント木\nstruct SegmentTree{\nprivate:\n\tint n;\n\tvector<long long> nodes,lazy;\n\tvector<bool> lazyFlg;\npublic:\n\tvoid init(int N){ //初期化する O(N)\n\t\tnodes.clear();\n\t\tlazy.clear();\n\t\tn = 1;\n\t\twhile(n < N) n *= 2;\n\t\tn = 2 * n -1;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnodes.push_back((1LL<<31)-1);\n\t\t\tlazy.push_back(0);\n\t\t\tlazyFlg.push_back(false);\n\t\t}\n\t}\n\tvoid eval(int k, int l, int r){ //遅延評価を行う\n\t\tif(!lazyFlg[k]) return;\n\t\tnodes[k] = lazy[k];\n\t\tif(r-l > 1){\n\t\t\tlazy[2*k+1] = lazy[k];\n\t\t\tlazyFlg[2*k+1] = true;\n\t\t\tlazy[2*k+2] = lazy[k];\n\t\t\tlazyFlg[2*k+2] = true;\n\t\t}\n\t\tlazy[k] = 0;\n\t\tlazyFlg[k] = false;\n\t}\n\tvoid update(int a, int b, long long x){ //区間に対して値を変更する O(log N)\n\t\tupdate_query(a, b, x, 0, 0, n/2+1);\n\t}\n\tvoid update_query(int a, int b, long long x, int k, int l, int r){\n\t\teval(k, l, r);\n\t\tif(r <= a || b <= l) return; //交差する場合\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tlazy[k] = x;\n\t\t\tlazyFlg[k] = true;\n\t\t\teval(k, l, r);\n\t\t\treturn;\n\t\t}\n\t\tupdate_query(a, b, x, 2*k+1, l, (l+r)/2);\n\t\tupdate_query(a, b, x, 2*k+2, (l+r)/2, r);\n\t\tnodes[k] = min(nodes[2*k+1], nodes[2*k+2]);\n\t}\n\tlong long minimum(int a, int b){ //[a,b)の最小値を求める O(log N)\n\t\treturn minimum_query(a, b, 0, 0, n/2+1);\n\t}\n\tlong long minimum_query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return 1LL<<62; //交差する場合\n\t\teval(k, l, r);\n\t\tif(a <= l && r <= b) return nodes[k]; //完全に含む場合\n\t\tlong long valueL = minimum_query(a, b, k*2+1, l, (l+r)/2);\n\t\tlong long valueR = minimum_query(a, b, k*2+2, (l+r)/2, r);\n\t\treturn min(valueL, valueR);\n\t}\n\tvoid print(){\n\t\tcout << \"nodes\" << endl;\n\t\tint sp = n;\n\t\tint nx = 0;\n\t\tfor(int i=0; i<nodes.size(); i++){\n\t\t\tcout << nodes[i];\n\t\t\tfor(int j=0; j<sp; j++) cout << \" \";\n\t\t\tif(i == nx){\n\t\t\t\tnx = nx*2+2;\n\t\t\t\tsp /= 2;\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tcout << \"lazy\" << endl;\n\t\tsp = n;\n\t\tnx = 0;\n\t\tfor(int i=0; i<lazy.size(); i++){\n\t\t\tcout << lazy[i];\n\t\t\tfor(int j=0; j<sp; j++) cout << \" \";\n\t\t\tif(i == nx){\n\t\t\t\tnx = nx*2+2;\n\t\t\t\tsp /= 2;\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nint main(){\n\t\n\tint n,q;\n\tcin >> n >> q;\n\tSegmentTree st;\n\tst.init(n);\n\tfor(int i=0; i<q; i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint a,b;\n\t\t\tLL x;\n\t\t\tcin >> a >> b >> x;\n\t\t\tb++;\n\t\t\tst.update(a, b, x);\n\t\t}\n\t\telse{\n\t\t\tint a,b;\n\t\t\tcin >> a;\n\t\t\tcout << st.minimum(a, a+1) << endl;\n\t\t}\n\t\t//st.print();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\n#define NUM 2147483647\n\nint N = 1;\nint* data;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int update_left,int update_right,int new_value,int node_id,int node_left,int node_right){\n\tif(update_right < node_left || update_left > node_right)return;\n\telse if(update_left <= node_left && update_right >= node_right){\n\t\tdata[node_id] = new_value;\n\t}else{\n\t\tif(data[node_id] >= 0){\n\t\t\tdata[2*node_id+1] = data[node_id];\n\t\t\tdata[2*node_id+2] = data[node_id];\n\t\t\tdata[node_id] = -1;\n\t\t}\n\t\tupdate(update_left,update_right,new_value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left,update_right,new_value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nint query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\tif(search_right < node_left || search_left > node_right){\n\t\treturn -1;\n\t}else if(node_left <= search_left && node_right >= search_right && data[node_id] >= 0){\n\t\treturn data[node_id];\n\t}else{\n\t\tint left = query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tint right = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn max(left,right);\n\t}\n}\n\nint main(){\n\tint first_N,Q;\n\tscanf(\"%d %d\",&first_N,&Q);\n\n\tinit(first_N);\n\n\tdata = new int[270000];\n\n\tfor(int i = 0; i <= 2*N-2; i++)data[i] = NUM;\n\n\tint command,left,right,value,loc;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&command);\n\n\t\tif(command == 0){\n\t\t\tscanf(\"%d %d %d\",&left,&right,&value);\n\t\t\tupdate(left,right,value,0,0,N-1);\n\t\t}else{\n\t\t\tscanf(\"%d\",&loc);\n\t\t\tprintf(\"%d\\n\",query(loc,loc,0,0,N-1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int MAX_N=1<<17;\nconst ll INF=(1ll<<31)-1;\nll dat[2*MAX_N-1];\npint dat2[2*MAX_N-1];\nint N;\n//RMQ\nvoid init(int n_){\n    N=1;\n    while(N<n_) N*=2;\n    //rep(i,2*N-1) dat[i]=INF;\n    rep(i,2*N-1) dat2[i]=mp(-1,INF);\n}\nvoid update(int k,ll a){\n    k+=N-1;\n    dat[k]=a;\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n//range [a,b)\nll query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return INF;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n        ll vl=query(a,b,k*2+1,l,(l+r)/2);\n        ll vr=query(a,b,k*2+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n}\n//RUQ\n//range [a,b)\nvoid r_update(int a,int b,pint x,int k,int l,int r){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n        dat2[k]=x;return;\n    }\n    else{\n        r_update(a,b,x,k*2+1,l,(l+r)/2);\n        r_update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n}\nll r_query(int i){\n    i+=N-1;\n    pint res=dat2[i];\n    while(i>0){\n        i=(i-1)/2;\n        res=max(res,dat2[i]);\n    }\n    return res.second;\n}\n\nint main(){\n    //int n,q,c,x,y;\n    int n,q,c,s,t,x;\n    cin>>n>>q;\n    init(n);\n    rep(i,q){\n        cin>>c;\n        //if(c==0) update(x,y);\n        if(c==0){\n            cin>>s>>t>>x;\n            r_update(s,t+1,mp(i,x),0,0,N);\n        }\n        else{\n            ll ans;\n            cin>>x;\n            //ans=query(x,y+1,0,0,N);\n            ans=r_query(x);\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, q, c, s, t, x;\n  scanf(\"%lld%lld\", &n, &q);\n  ll f = 1;\n  std::pair<ll, ll> seg[4 * n];\n  while(f < n) f *= 2;\n  for(i = f; i < f * 2; ++i) seg[i].first = 2147483647, seg[i].second = 0;\n  for(i = 0; i < f; ++i) seg[i].first = -1, seg[i].second = -1;\n  for(i = 1; i <= q; ++i) {\n    scanf(\"%lld\", &c);\n    if(!c) {\n      scanf(\"%lld%lld%lld\", &s, &t, &x);\n      ll r = s + f;\n      while(1) {\n        ll las, ra = 1;\n        while(!(r % 2)) r /= 2;\n        while(ra <= r) ra *= 2;\n        ra /= 2;\n        las = f / ra * (r + 1 - ra) - 1;\n        while(las > t) {\n          r *= 2;\n          ra *= 2;\n          las = f / ra * (r + 1 - ra) - 1;\n        }\n        seg[r].first = x;\n        seg[r].second = i;\n        if(las == t) break;\n        r++;\n      }\n    } else {\n      scanf(\"%d\", &s);\n      int now = s + f, nowa, nown = -1;\n      while(now) {\n         if(seg[now].second > nown) nowa = seg[now].first, nown = seg[now].second;\n         now /= 2;\n      }\n      printf(\"%lld\\n\", nowa);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nstruct segtree {\n    vector<int> lazy, dat;\n    int n;\n\n    segtree(int n_, int init){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.assign(n*2, init);\n        lazy.assign(n*2, -1);\n    }\n\n\n    void set(int l, int r, int x){\n        static queue<tuple<int,int,int>> q;\n        q.emplace(0, n, 1);\n        while(q.size()){\n            int segl, segr, n;\n            tie(segl, segr, n) = q.front();\n            q.pop();\n            push(segl, segr, n);\n            // if(segr <= l || r <= segl);\n            if(l <= segl && segr <= r) lazy[n] = x;\n            else {\n                int segm = (segl + segr) / 2;\n                if(l < segm && segl < r) q.emplace(segl, segm, n*2);\n                if(l < segr && segm < r) q.emplace(segm, segr, n*2+1);\n            }\n        }\n    }\n\n    int get(int k){\n        return get(k, 0, n, 1);\n    }\n\n    int get(int k, int segl, int segr, int n){\n        push(segl, segr, n);\n        if(segl + 1 == segr) return dat[n];\n        int segm = (segl + segr) / 2;\n        if(k < segm) return get(k, segl, segm, n*2);\n        else return get(k, segm, segr, n*2+1);\n    }\n\n    void push(int segl, int segr, int node){\n        if(lazy[node] != -1){\n            dat[node] = lazy[node];\n            if(segl + 1 != segr){\n                lazy[node*2] = lazy[node];\n                lazy[node*2+1] = lazy[node];\n            }\n            lazy[node] = -1;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, q;\n    cin >> n >> q;\n    segtree st(n, 2147483647);\n    for(int iq = 0; iq < q; ++iq){\n        int t;\n        cin >> t;\n        // dump(t);\n        if(t == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            st.set(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.get(i) << '\\n';\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct OwnNode\n{\n\tint num;\n\tint l, r;\n\tOwnNode* left;\n\tOwnNode* right;\n\n\tOwnNode(int l,int r):l(l),r(r),num(2147483647),left(nullptr),right(nullptr){}\n\t\n\tvoid Build()\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tleft = new OwnNode(l, m);\n\t\tright = new OwnNode(m + 1, r);\n\t\tleft->Build();\n\t\tright->Build();\n\t}\n\n\tvoid update(int s, int t, int v)\n\t{\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\tnum = v;\n\t\t\treturn;\n\t\t}\n\t\tif (l == r)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tif (right != nullptr)\n\t\t{\n\t\t\tif (num >= 0)\n\t\t\t{\n\t\t\t\tright->num = num;\n\t\t\t}\n\t\t\tif (m + 1 <= t)\n\t\t\t{\n\t\t\t\tright->update(s, t, v);\n\t\t\t}\n\t\t}\n\t\tif (left != nullptr)\n\t\t{\n\t\t\tif (num >= 0)\n\t\t\t{\n\t\t\t\tleft->num = num;\n\t\t\t}\n\t\t\tif (s <= m)\n\t\t\t{\n\t\t\t\tleft->update(s, t, v);\n\t\t\t}\n\t\t}\n\t\tnum = -1;\n\t}\n\n\tint find(int s, int t)\n\t{\n\t\tif (num >= 0)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t\tint mini = 2147483647;\n\t\tint m = (l + r) / 2;\n\t\tif (right != nullptr)\n\t\t{\n\t\t\tif (m + 1 <= t)\n\t\t\t{\n\t\t\t\tmini = min(mini, right->find(s, t));\n\t\t\t}\n\t\t}\n\t\tif (left != nullptr)\n\t\t{\n\t\t\tif (s <= m)\n\t\t\t{\n\t\t\t\tmini = min(mini, left->find(s, t));\n\t\t\t}\n\t\t}\n\t\treturn mini;\n\t}\n};\n\nusing namespace std;\n\nOwnNode* root;\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\troot = new OwnNode(0, n - 1);\n\troot->Build();\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\troot->update(s, t, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << root->find(s, s) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n\nint bucket[MAX/B][B];\nint udata[MAX/B], data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && udata[a/B] != -1){\n\t\t\tfor(int i = 0;i < B;i++)bucket[a/B][i] = udata[a/B];\n\t\t\tf1 = 0;udata[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != B-1){\n\t\tif(f2 && udata[b/B] != -1){\n\t\t\tfor(int i = 0;i < B;i++)bucket[b/B][i] = udata[b/B];\n\t\t\tf2 = 0;udata[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tudata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(udata[x/B] != -1){\n\t\tfor(int i = 0;i < B;i++)bucket[x/B][i] = udata[x/B];\n\t\tudata[x/B] = -1;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(udata, udata+MAX/B, -1);\n\tfill(data, data+MAX/B, INF);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <limits>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" <<\"LINE:\"<<__LINE__<<\"  \"<< #i <<\":\"<< i << std::endl\n\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if ((a == 0)||(mod!=-1&&a%mod==0)) {\n    return 0;\n  }\n \n  long long x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\n//遅延セグ木\ntemplate<typename T,typename E>\nclass LazySegmentTree{\n  private:\n  int n,n0;\n  std::vector<T> dat;\n  std::vector<E> lazy;\n\n  T init_t;\n  E init_e;\n\n  using F=std::function<T(T,T)>;\n  using G=std::function<T(T,E)>;\n  using H=std::function<E(E,E)>;\n  using P=std::function<E(E,int)>;\n\n  F f;\n  G g;\n  H h;\n  P p;\n\n  T update(int a,int b,T val,int l,int r,int k){\n    if(lazy[k]!=init_e){\n      if(k<n0-1){\n        lazy[2*k+1]=h(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2]=h(lazy[2*k+2],lazy[k]);\n      }\n      dat[k]=g(dat[k],p(lazy[k],r-l));\n      lazy[k]=init_e;\n    }\n\n    if(r<=a||b<=l)return dat[k];\n    if(a<=l&&r<=b){\n      lazy[k]=h(lazy[k],val);\n      return g(dat[k],p(lazy[k],r-l));\n    }\n\n    return dat[k]=f(update(a,b,val,l,l+(r-l)/2,2*k+1),update(a,b,val,l+(r-l)/2,r,2*k+2));\n  }\n\n  T query(int a,int b,int l,int r,int k){\n    if(lazy[k]!=init_e){\n      if(k<n0-1){\n        lazy[2*k+1]=h(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2]=h(lazy[2*k+2],lazy[k]);\n      }\n      dat[k]=g(dat[k],p(lazy[k],r-l));\n      lazy[k]=init_e;\n    }\n\n    if(r<=a||b<=l)return init_t;\n    if(a<=l&&r<=b)return dat[k];\n    T lval=query(a,b,l,l+(r-l)/2,2*k+1);\n    T rval=query(a,b,l+(r-l)/2,r,2*k+2);\n    return f(lval,rval);\n  }\n\n  public:\n\n  LazySegmentTree(int n_,F f_,G g_,H h_,T t,E e,std::vector<T> dat_=std::vector<T>(),P p_=[](E a,int n){return a;})\n    :n(n_),init_t(t),init_e(e),f(f_),g(g_),h(h_),p(p_){\n\n    n0=1;\n    while(n0<n)n0<<=1;\n    dat=std::vector<T>(2*n0-1,init_t);\n    lazy=std::vector<E>(2*n0-1,init_e);\n    if(n_==dat_.size()){\n      for(int i=0;i<n_;i++)dat[i+n0-1]=dat_[i];\n      for(int i=n0-2;i>=0;i--)dat[i]=f(dat[2*i+1],dat[2*i+2]);\n    }\n  }\n\n  void update(int a,int b,T val){\n    update(a,b,val,0,n0,0);\n  }\n\n  T query(int a,int b){\n    return query(a,b,0,n0,0);\n  }\n};\n\nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n,q;\n  std::cin>>n>>q;\n\n  LazySegmentTree<ll,ll> seg(n,[](ll a,ll b){return std::min(a,b);},\n                              [](ll a,ll b){return (b==(1ll)<<31)?a:b;},\n                              [](ll a,ll b){return (b==(1ll)<<31)?a:b;},\n                              (1ll<<31)-1,1ll<<31);\n\n  rep(_,0,q){\n    ll com;\n    std::cin>>com;\n    if(com==0){\n      ll s,t,x;\n      std::cin>>s>>t>>x;\n\n      seg.update(s,t+1,x);\n    }else{\n      ll s;\n      std::cin>>s;\n\n      ll ans=seg.query(s,s+1);\n      std::cout<<ans<<\"\\n\";\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate<class T, class TUpdater>\nstruct RangeSegTreeT\n{\n\tint size;\n\tvector<T> tree;\n\tvector<pair<bool, T>> lazy;\n\tTUpdater updator;\n\tT initialValue;\n\n\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\t\n\tRangeSegTreeT(int count, TUpdater updator, T initialValue)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, lazy(size * 2)\n\t\t, updator(updator)\n\t\t, initialValue(initialValue)\n\t{\n\t\tlazy[1] = { true, initialValue };\n\t}\n\n\tvoid push(int l, int r, int i)\n\t{\n\t\tif (lazy[i].first)\n\t\t{\n\t\t\ttree[i] = updator(tree[i], lazy[i].second);\n\t\t\tif (r - l > 1)\n\t\t\t{\n\t\t\t\tlazy[i * 2] = { true, updator(lazy[i * 2].second, lazy[i].second) };\n\t\t\t\tlazy[i * 2 + 1] = { true, updator(lazy[i * 2 + 1].second, lazy[i].second) };\n\t\t\t}\n\t\t\tlazy[i] = { false, 0 };\n\t\t}\n\t}\n\n\tvoid update_range(int begin, int end, T value)\n\t{\n\t\tupdate_range(begin, end, 1, 0, size, value);\n\t}\n\n\tvoid update_range(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpush(l, r, i);\n\n\t\tif (r <= s || e <= l) { return; }\n\t\tif (s <= l && r <= e) { lazy[i] = { true, updator(lazy[i].second, value) }; return; }\n\t\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { update_range(s, e, i * 2, l, m, value); }\n\t\tif (e > m) { update_range(s, e, i * 2 + 1, m, r, value); }\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpush(l, r, i);\n\t\tif (r <= s || e <= l) { return value; }\n\t\tif (s <= l && r <= e) { return tree[i]; }\n\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { value += query(s, e, i * 2, l, m, value); }\n\t\tif (e > m) { value += query(s, e, i * 2 + 1, m, r, value); }\n\t\treturn value;\n\t}\n\n\tT query(int begin, int end, T initialValue) { return query(begin, end, 1, 0, size, initialValue); }\n\tT query(int begin, int end) { return query(begin, end, initialValue); }\n};\n\ntemplate <class T, class TUpdator = const T&(*)(const T&, const T&)>\nRangeSegTreeT<T, TUpdator> RangeSegTree(int n, TUpdator updator = min<T>, int initialValue = INF)\n{\n\treturn RangeSegTreeT<T, TUpdator>(n, updator, initialValue);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTree<int>(n, CONV2(a,b,b), (1LL << 31) - 1);\n\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s, t + 1, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, i);\n\t\t\tint v = tree.query(i, i + 1, 0);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n         const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n         sz = 1;\n         while(sz < n) sz <<= 1;\n         data.assign(2 * sz, M1);\n         lazy.assign(2 * sz, OM0);\n      }\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n               update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\ntemplate<typename T> struct RUQ {\n   LazySegmentTree<T> lsegt;\n   RUQ(int n, int init) : lsegt(n,\n      [](int a,int b){ return min(a,b); },\n      [](int a,int b,int c){ return b; },\n      [](int a,int b){ return b; }, init, INF){}\n   void update(int a, int b, int x) { lsegt.update(a, b, x); }\n   T query(int i) { return lsegt[i]; }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q), id(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> id[i];\n      }\n   }\n\n   RUQ<int> ruq(n, (1LL<<31)-1);\n   REP(i, q) {\n      if (c[i] == 0) {\n         ruq.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << ruq.query(id[i]) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct lazy_segment_tree{\n  int n;\n  vector<T> dat,lazy;\n  T de,le;\n\n  T f(T a,T b){\n    return min(a,b);\n  }\n  T g(T& a,T b){\n    a = b;\n  }\n  T h(T& a,T b){\n    a = b;\n  }\n\n  lazy_segment_tree(){}\n  lazy_segment_tree(int sz){\n    n = 1;\n    while(n<=sz)n<<=1;\n    de = (1LL<<31)-1;\n    le = (1LL<<31)-1;\n    dat.resize(2*n-1,de);\n    lazy.resize(2*n-1,le);\n  }\n  lazy_segment_tree(vector<T> const& v){\n    int sz = v.size();\n    n = 1;\n    while(n<=sz)n<<=1;\n    de = (1LL<<31)-1;\n    le = (1LL<<31)-1;\n    dat.resize(2*n-1,de);\n    lazy.resize(2*n-1,le);\n    for(int i=0;i<sz;++i){\n      dat[i+n-1] = v[i];\n    }\n    for(int i=n-2;i>=0;--i){\n      dat[i] = f(dat[i*2+1],dat[i*2+2]);\n    }\n  }\n\n  void eval(int k,int l,int r){\n    if(lazy[k]!=le){\n      g(dat[k],lazy[k]);\n      if(r-l>1){\n        h(lazy[2*k+1],lazy[k]);\n        h(lazy[2*k+2],lazy[k]);\n      }\n      lazy[k] = le;\n    }\n  }\n\n  void update(int a,int b,T x,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    eval(k,l,r);\n    if(b<=l||r<=a)return;\n    if(a<=l&&r<=b){\n      h(lazy[k],x);\n      eval(k,l,r);\n    }else{\n      update(a,b,x,2*k+1,l,(r+l)/2);\n      update(a,b,x,2*k+2,(r+l)/2,r);\n      dat[k] = f(dat[2*k+1],dat[2*k+2]);\n    }\n  }\n\n  T query(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    if(b<=l||r<=a)return de;\n    eval(k,l,r);\n    if(a<=l&&r<=b)return dat[k];\n    T vl = query(a,b,2*k+1,l,(r+l)/2);\n    T vr = query(a,b,2*k+2,(r+l)/2,r);\n    return f(vl,vr);\n  }\n\n  T operator[](int k){\n    return query(k,k+1);\n  }\n\n};\n\nvoid RUQ(){\n  int n,q;\n  cin>>n>>q;\n  lazy_segment_tree<int> seg(n);\n  while(q--){\n    int com;\n    cin>>com;\n    if(com){\n      int i;\n      cin>>i;\n      cout<<(seg[i])<<endl;\n    }else{\n      int s,t,x;\n      cin>>s>>t>>x;\n      seg.update(s,t+1,x);\n    }\n  }\n}\n\nint main(){\n  RUQ();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define rep(i,n) for(int i=0, i##_len=(int)(n); i<i##_len; i++)\n#define reps(i,n) for(int i=1 , i##_len=(int)(n);i<=i##_len;i++)\n#define rrep(i,n) for(int i=((int)(n)-1);i>=0;i--)\n#define rreps(i,n) for(int i=((int)(n));i>0;i--)\n#define repi(i,x) for(auto i=(x).begin(),i##_fin=(x).end();i!=i##_fin;i++)\n#define all(x) (x).begin(), (x).end()\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define solve(a) ((a)?\"Yes\":\"No\")\ntypedef vector<int> Vi;\ntypedef vector<Vi> VVi;\ntypedef pair<int , int> Pi;\ntypedef vector<Pi> VPi;\ntypedef vector<long long> V;\ntypedef vector<V> VV;\ntypedef pair<long long , long long> P;\ntypedef vector<P> VP;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1;} return 0;}\nconst long long INFLL = 1LL<<60;\nconst int INF = 1<<30;\nconst double PI=acos(-1);\n//SegmentTree \ntemplate<class T>class SegmentTree_Delayed{\n\tvector<T> seg;\n\tvector<T> memo;\n\tpublic:\n\tint size; //size of segmenttree\n\tT init;\n\tSegmentTree_Delayed (int _legth,T _init=0){\n\t\tsize=1;\n\t\tinit=_init;\n\t\twhile(size <=_legth){\n\t\t\tsize<<=1;\n\t\t}\n\t\tseg.assign(size<<1,init);\n\t\tmemo.assign(size << 1, init);\n\t} \n\tT get(int index){\n\t\treturn seg[size+index];\n\t}\n\tvoid show(){\n\t\trep(i,size*2){\n\t\t\t //clog<<seg[i]<<\" \";\n\t\t}\n\t\t //clog<<endl;\n\t\trep(i, size * 2)\n\t\t{\n\t\t\t //clog << memo[i] << \" \";\n\t\t}\n\t //clog<<endl;\n\t}\n\t//change value \n\tvoid update(int index, T value){\n\t\tseg[size+index]=value;\n\t\tint ter=index+size;\n\t\twhile(ter!=1){\n\t\t\tter/=2;\n\t\t\tseg[ter]=upquary(ter*2);\n\t\t} show();\n\t}\n\tvoid write(int l, int r,T value){\n\t\t/*\n\t\tmemoのindexStart-indexStop間にvalueを書き換える\n\t\t書き換えは要素のアクセス時に行う\n\t\t*/\n\t\twritequary(l, r, 1, 0, size,value);\n\t\t //show()();\n\t}\n\n\tvoid writequary(int left, int right, int index, int atStart, int atStop,T value)\n\t{\n\t\t //clog << \"index: \" << index << \" Start: \" << atStart << \" stop: \" << atStop << \":: \";\n\t\tif ((left <= atStart) and (atStop-1 <= right))\n\t\t{ //対象範囲に完全に囲まれる\n\t\t\t //clog << \" compleatety ; \" << seg[index] << endl;\n\t\t\tmemo[index]=value;\n\t\t\treturn ;\n\t\t}\n\t\tif ((atStop <= left) or (right < atStart))\n\t\t{ //対象範囲に全く関わらない\n\t\t\t //clog << \" ignore ; \" << init << endl;\n\t\t\treturn ;\n\t\t}\n\t\tif (index >= size)\n\t\t{ //範囲外\n\t\t\t //clog << \" out of range/finary ; \" << seg[index] << endl;\n\t\t\tmemo[index]=value;\n\t\t\treturn ;\n\t\t}\n\t\t //clog << \" partitical\" << endl;\n\t\t//対象範囲に一部が含まれる\n\t\tload(index*2);\n\t\tload(index*2+1);\n\t\twritequary(left, right, index * 2, atStart, atStart + (atStop - atStart) / 2,value);\n\t\twritequary(left, right, index * 2 + 1, atStart + (atStop - atStart) / 2, atStop,value);\n\t\treturn ;\n\t}\n\n\t//-------------------//\n\tT findquary(int left,int right,int index,int atStart,int atStop){\n\t\tload(index);\n\t\t //show()();\n\t\t //clog<<\"index: \"<<index<<\" Start: \"<<atStart<<\" stop: \"<<atStop<<\":: \";\n\t\tif ((left <= atStart) and (atStop <= right)){//対象範囲に完全に囲まれる\n\t\t\t //clog<<\" compleatety ; \"<<seg[index]<<endl;\n\t\t\treturn seg[index];\n\t\t}if((atStop <= left) or ( right < atStart)){//対象範囲に全く関わらない\n\t\t\t //clog<<\" ignore ; \"<<init<<endl;\n\t\t\treturn init;\n\t\t}if (index >= size){//範囲外\n\t\t //clog<<\" out of range/finary ; \"<<seg[index]<<endl;\n\t\t\treturn seg[index];\n\t\t}\n\t\t //clog<<\" partitical\"<<endl;\n\t\t//対象範囲に一部が含まれる\n\t\tT aL=findquary(left, right, index * 2, atStart, atStart + (atStop - atStart) / 2);\n\t\tT aR= findquary(left, right, index * 2 +1,  atStart +(atStop - atStart) / 2, atStop);\n\t\treturn min(aL,aR);\n\t}\n\tvoid load(int index){\n\t\tif(memo[index]==init){\n\t\t\treturn ;\n\t\t}\n\t\tseg[index] = memo[index];\n\n\t\tif (not (index >= size))\n\t\t{\n\t\t\tmemo[index*2]=memo[index];\n\n\t\t\tmemo[index*2+1]=memo[index];\n\t\t}\n\t\tmemo[index] = init;\n\t}\n\tT upquary(int index){ //q1\n\t\treturn min(seg[index],seg[index+1]);\n\t}\n\tT find(int l, int r){ //q2\n\t\tT res = seg[size + l];\n\t\t //clog<<\"left: \"<<l<<\" right \"<<r<<endl;\n\t\tres = findquary(l, r,1,0, size);\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint n,q;\n\tint ans=0;\n\tcin >>n>>q;\n\tSegmentTree_Delayed<int> a(n,-1LL+(1LL<<31));\n\tint id,x,y,z;\n\trep(i,q){\n\t\tcin>>id>>x;\n\t\t\n\t\tif(id==0){\n\t\t\tcin>>y>>z;\n\t\t\ta.write(x,y,z);\n\t\t}else{\n\t\t\tcout<<a.find(x,x)<<endl;;\n\t\t}\n\t}\n\t//cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RU {\n\tusing t1 = int;\n\tusing t2 = int;\n\tstatic t2 id2() { return -1; }\n\tstatic t1 op2(const t1& l, const t2& r) { return r == id2() ? l : r; }\n\tstatic t2 op3(const t2& l, const t2& r) { return r == id2() ? l : r; }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tvector<T1> data;\n\tvector<T2> lazy;\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tlazy[node << 1] = M::op3(lazy[node << 1], lazy[node]);\n\t\tlazy[(node << 1) | 1] = M::op3(lazy[(node << 1) | 1], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\npublic:\n\tlazy_segment_tree(int n_, T1 v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n_, v1), lazy(n << 1, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(data_), lazy(n << 1, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\tT1 find(int p) {\n\t\tT1 res = data[p]; p += n;\n\t\twhile (p) res = M::op2(res, lazy[p]), p >>= 1;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tlazy_segment_tree<RU> lst(n, INT_MAX);\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tlst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tprintf(\"%d\\n\", lst.find(p));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nconst int MAX_N = 1 << 19;\nconst int INIT_VALUE = INT_MAX;\nconst int INIT_LAZY = INT_MAX;\n//?????°???????????¨???????????°??????????????????\nint SIZE, dat[MAX_N], lazy[MAX_N];\n\n//?????????\nvoid init(int n_) {\n\t//?°????????????????????´???°???2???????????????\n\t//n_????¬???????????´???°, SIZE???????????°, 2*SIZE-1??????????´???°\n\tSIZE = 1;\n\twhile (SIZE < n_) {\n\t\tSIZE *= 2;\n\t}\n\t//??????????????????0???\n\tfor (int i = 0; i < 2 * SIZE - 1; i++) {\n\t\tdat[i] = INIT_VALUE;\n\t\tlazy[i] = INIT_LAZY;\n\t}\n}\n\nvoid setLazy(int k, int x){\n\tlazy[k] = x;\n\tdat[k] = x;\n}\n\nvoid lazy_evaluate(int k) {\n\tif(lazy[k]==INIT_LAZY){\n\t\treturn;\n\t}\n\tdat[k] = lazy[k];\n\tsetLazy(k*2+1, lazy[k]);\n\tsetLazy(k*2+2, lazy[k]);\n\tlazy[k] = INIT_LAZY;\n}\n\nvoid fix(int k){\n\tdat[k] = min(dat[k*2+1], dat[k*2+2]);\n}\n\nvoid update(int a, int b, int k, int l, int r, int x){\n\tif(b<=l || r<=a){\n\t\treturn;\n\t}\n\tif(a<=l&&r<=b){\n\t\tsetLazy(k, x);\n\t}else{\n\t\tlazy_evaluate(k);\n\t\tupdate(a, b, k*2+1, l, (l+r)/2, x);\n\t\tupdate(a, b, k*2+2, (l+r)/2, r, x);\n\t\tfix(k);\n\t}\n}\n\nint get(int a, int b, int k, int l, int r){\n\tif(b<=l || r<=a){\n\t\treturn INIT_VALUE;\n\t}\n\tif(a<=l&&r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\tint vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\tint vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\nint N, Q;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/AtCoder/jni/in.txt\");\n\tcin >> N >> Q;\n\tinit(N);\n\trep(q,0,Q)\n\t{\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(s, t+1, 0, 0, SIZE, x);\n\t\t} else {\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << get(i, i+1, 0, 0, SIZE) << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n\nint bucket[MAX/B][B];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && data[a/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n\t\t\tf1 = 0;data[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != 99){\n\t\tif(f2 && data[b/B] != -1){\n\t\t\tfor(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n\t\t\tf2 = 0;data[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tdata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(data[x/B] != -1){\n\t\tfor(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n\t\tdata[x/B] = -1;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(data, data+MAX/B, -1);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int a[100000];\n    const int max = pow(2, 31) - 1;\n    fill(a, a + 100000, max);\n    int n, q;\n    cin >> n >> q;\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            fill(a + s, a + t+1, x);\n        }\n        else {\n            int i;\n            cin >> i;\n            cout << a[i] << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, q, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u) {\n\tif (s <= p || q <= r)return;\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tupdate(p, q, r, (r + s) / 2, t, u * 2);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((p <= r && s <= q) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> q; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_; i++)seg[i] = INF;\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\ntemplate<typename OperatorMonoid>\nclass DualSegmentTree {\n  using H = OperatorMonoid(*)(OperatorMonoid, OperatorMonoid);\n  int n, sz, height;\n  vector<OperatorMonoid> lazy;\n  const H h;\n  const OperatorMonoid om;\npublic:\n  DualSegmentTree(int n, const H h, const OperatorMonoid om) : n(n), sz(1), height(0), h(h), om(om) {\n    while (sz < n) sz <<= 1, height++;\n    lazy.resize(2 * sz, om);\n  }\n\n  inline void propagate(int k) {\n    if (lazy[k] != om) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      lazy[k] = om;\n    }\n  }\n\n  inline void thrust(int k) {\n    for (int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid& x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if (r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n  }\n\n  OperatorMonoid operator[](int k) {\n    thrust(k += sz);\n    return lazy[k];\n  }\n\n  vector<OperatorMonoid> data() {\n    return lazy;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n, q;\n  cin >> n >> q;\n  DualSegmentTree<int> seg(n, [](int a, int b) { return b; }, INT_MAX);\n  //dump(seg.data());\n  rep(_, q) {\n    int t, x, y, z;\n    cin >> t;\n    switch (t) {\n    case 0:\n      cin >> x >> y >> z;\n      seg.update(x, y + 1, z);\n      break;\n    case 1:\n      cin >> x;\n      cout << seg[x] << '\\n';\n      break;\n    }\n    //dump(seg.data());\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debugos clog\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_reference<remove_const<decltype(l)>::type>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ninline void assert_call(bool assertion, function<void()> f) { if (!assertion) { cerr << \"assertion fault:\" << endl; f(); abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream& os, const Vec& a) {\n    os << '['; for (const auto& e : a) os << ' ' << e << ' '; os << ']'; return os;\n}\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) noexcept {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc < '0' || '9' < cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() noexcept { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) noexcept { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) noexcept { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) noexcept {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) noexcept { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) noexcept { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) noexcept { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) noexcept { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = ' ') { for (bool b = 0; begin != end; ++begin, b = 1) b ? *this << sep << *begin : *this << *begin; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\ntemplate<typename T>\n//using T = ll;\nclass SegmentTree {\npublic:\n    struct IdxVal {\n        int index;\n        T value;\n        inline IdxVal(int _i = 0, const T& _v = T()) :index(_i), value(_v) { }\n        inline void set(int i, const T& v) { index = i; value = v; }\n        inline bool operator<(const T& t) const { return value < t; }\n        inline bool operator==(const T& t) const { return value == t; }\n        inline bool operator<(const IdxVal& iv) const { return value < iv.value || (value == iv.value && index < iv.index); }\n        inline bool operator==(const IdxVal& iv) const { return index == iv.index && value == iv.value; }\n    };\n\n    enum struct Cmd{\n        None, Add, Flat\n    };\n\n    struct Node {\n        T sum, lazyValue;\n        IdxVal max;\n        Cmd lazyType;\n    };\n\nprivate:\n    const int size_;\n    vector<T> leaf_data_;\n    vector<Node> node_data_;\n    T* leaf_;\n    Node* node_;\n\n    void _resize() {\n        leaf_data_.resize(size_);\n        node_data_.resize(size_ - 1);\n\n        leaf_ = &leaf_data_[0];\n        node_ = &node_data_[0] - 1;\n    }\n\n    void _init() {\n        for (int i = size_ - 1; 0 < i; --i) {\n            int c = i << 1;\n            if (size_ <= c)\n                node_[i].max.set(c - size_, leaf_[c - size_]);\n            else\n                node_[i].max = node_[c].max;\n            node_[i].lazyType = Cmd::None;\n            node_[i].sum = node_[i].lazyValue = 0;\n        }\n    }\npublic:\n\n    inline void fill(T val) {\n        std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n        _init();\n    }\n\n    SegmentTree(int _n) :\n        size_([](int _n) {int s = 8; while (s < _n) s <<= 1; return s; }(_n))\n    {\n        _resize();\n        _init();\n    }\n    SegmentTree(int _n, const T& _fillVal) :\n        size_([](int _n) {int s = 8; while (s < _n) s <<= 1; return s; }(_n))\n    {\n        _resize();\n        fill(_fillVal);\n    }\n\n\nprivate:\n    // lazyを適応する(子を呼ぶ前に呼ぶ)\n    // width: ptrが担当するnodeの範囲の大きさ(ptr = 1 ならば size_)\n    inline void _applyDown(int ptr, int width) {\n        width >>= 1;\n        //if (size_ <= ptr) return;\n        if (node_[ptr].lazyType == Cmd::Add) {\n            int c = ptr << 1;\n\n            if (size_ <= c) {\n                leaf_[c - size_] += node_[ptr].lazyValue;\n                leaf_[c + 1 - size_] += node_[ptr].lazyValue;\n            }\n            else {\n                node_[c].sum += node_[ptr].lazyValue * width;\n                node_[c].max.value += node_[ptr].lazyValue;\n                node_[c].lazyValue += node_[ptr].lazyValue;\n                if (node_[c].lazyType == Cmd::None)\n                    node_[c].lazyType = Cmd::Add;\n\n                node_[c + 1].sum += node_[ptr].lazyValue * width;\n                node_[c + 1].max.value += node_[ptr].lazyValue;\n                node_[c + 1].lazyValue += node_[ptr].lazyValue;\n                if (node_[c + 1].lazyType == Cmd::None)\n                    node_[c + 1].lazyType = Cmd::Add;\n            }\n\n            node_[ptr].lazyType = Cmd::None;\n            node_[ptr].lazyValue = 0;\n        }\n        else if (node_[ptr].lazyType == Cmd::Flat) {\n            node_[ptr].lazyType = Cmd::None;\n            int c = ptr << 1;\n\n            if (size_ <= c) {\n                leaf_[c - size_] = node_[ptr].lazyValue;\n                leaf_[c + 1 - size_] = node_[ptr].lazyValue;\n            }\n            else {\n                node_[c].sum = node_[ptr].lazyValue * width;\n                node_[c].max.value = node_[ptr].lazyValue;\n                node_[c].lazyValue += node_[ptr].lazyValue;\n                node_[c].lazyType = Cmd::Flat;\n\n                node_[c + 1].sum = node_[ptr].lazyValue * width;\n                node_[c + 1].max.value = node_[ptr].lazyValue;\n                node_[c + 1].lazyValue += node_[ptr].lazyValue;\n                node_[c + 1].lazyType = Cmd::Flat;\n            }\n\n            node_[ptr].lazyType = Cmd::None;\n            node_[ptr].lazyValue = 0;\n        }\n    }\n\n    // lazyを適応する(子を呼んだ後に呼ぶ)\n    inline void _applyUp(int ptr) {\n        if (size_ <= ptr << 1) {\n            int i = (ptr << 1) - size_;\n            if (leaf_[i] < leaf_[i + 1])\n                node_[ptr].max.set(i + 1, leaf_[i + 1]);\n            else\n                node_[ptr].max.set(i, leaf_[i]);\n            node_[ptr].sum = leaf_[i] + leaf_[i + 1];\n        }\n        else {\n            if (node_[(ptr << 1)].max.value < node_[(ptr << 1) + 1].max.value)\n                node_[ptr].max = node_[(ptr << 1) + 1].max;\n            else\n                node_[ptr].max = node_[(ptr << 1)].max;\n            node_[ptr].sum = node_[ptr << 1].sum + node_[(ptr << 1) + 1].sum;\n        }\n    }\n\n    // _downward_applyDown(ptr1): leaf[ptr1]の値を正しくする．\n    void _downward_applyDown(int ptr1, int width = 1) {\n        if (1 < ptr1) _downward_applyDown(ptr1 >> 1, width << 1);\n        _applyDown(ptr1, width);\n    }\n\n\n    void _setValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n\n        if (rangeend <= begin || end <= rangebegin) return; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr) {\n                leaf_[rangebegin] = val;\n            }\n            else {\n                node_[ptr].sum = val * (rangeend - rangebegin);\n                node_[ptr].max.value = val;\n                node_[ptr].lazyType = Cmd::Flat;\n                node_[ptr].lazyValue = val;\n            }\n            return;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        _setValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        _setValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        _applyUp(ptr);\n    }\n\n    void _addValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n\n        if (rangeend <= begin || end <= rangebegin) return; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr) {\n                leaf_[rangebegin] += val;\n            }\n            else {\n                node_[ptr].sum += val * (rangeend - rangebegin);\n                node_[ptr].max.value += val;\n                node_[ptr].lazyValue += val;\n                if (node_[ptr].lazyType == Cmd::None)\n                    node_[ptr].lazyType = Cmd::Add;\n            }\n            return;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        _addValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        _addValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        _applyUp(ptr);\n    }\n\n    T _getSumRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return 0; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr)\n                return leaf_[rangebegin];\n            else\n                return node_[ptr].sum;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        return _getSumRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1)\n            + _getSumRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n    }\n\n    IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return IdxVal(-1); // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr)\n                return IdxVal(rangebegin, leaf_[rangebegin]);\n            else\n                return node_[ptr].max;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        if (l.index == -1) return move(r);\n        if (r.index == -1) return move(l);\n        return l.value < r.value ? move(r) : move(l);\n    }\n\npublic:\n    // [index] の値を求める\n    inline T getValue(int index) {\n        _downward_applyDown((index + size_) >> 1);\n        return leaf_[index];\n    }\n\n    // [index] の値を書き換える\n    inline T setValue(int index, T val) {\n        _downward_applyDown((index + size_) >> 1);\n        T diff = val - leaf_[index];\n        leaf_[index] = val;\n\n        for (int ptr = (index + size_); 1 < ptr;) {\n            ptr >>= 1;\n            node_[ptr].sum -= diff;\n            _applyUp(ptr);\n        }\n    }\n\n    // [index] の値に加算する\n    inline T addValue(int index, T val) {\n        _downward_applyDown((index + size_) >> 1);\n        leaf_[index] += val;\n\n        for (int ptr = (index + size_); 1 < ptr;) {\n            ptr >>= 1;\n            node_[ptr].sum += val;\n            _applyUp(ptr);\n        }\n    }\n\n    // 区間[begin,end)全てにvalをセットする\n    inline void setValueRange(int begin, int end, T val) {\n        _setValueRange(begin, end, val, 1, 0, size_);\n    }\n\n    // 区間[begin,end)に一様にvalを加算する\n    inline void addValueRange(int begin, int end, T val) {\n        _addValueRange(begin, end, val, 1, 0, size_);\n    }\n\n    // 区間[begin,end)の和を求める\n    inline T getSumRange(int begin, int end) {\n        return _getSumRange(begin, end, 1, 0, size_);\n    }\n\n    // 区間[begin,end)の最大値とその位置を求める\n    inline IdxVal getMaxRange(int begin, int end) {\n        return _getMaxRange(begin, end, 1, 0, size_);\n    }\n};\n\n\nint main_dsl_2_A() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N, -2147483647);\n    repeat(_, Q) {\n        int c, x, y;\n        scanner >> c >> x >> y;\n        if (c == 0) {\n            segtree.setValue(x, -y);\n        }\n        else if (c == 1) {\n            auto a = segtree.getMaxRange(x, y + 1);\n            printer << -a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_B() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N, 0);\n    repeat(_, Q) {\n        int c, x, y;\n        scanner >> c >> x >> y;\n        if (c == 0) {\n            segtree.addValue(x - 1, y);\n        }\n        else if (c == 1) {\n            auto a = segtree.getSumRange(x - 1, y);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_D() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N, 2147483647);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s;\n            auto a = segtree.getValue(s);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_E() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N);\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.addValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s;\n            auto e = segtree.getValue(s);\n            printer << e << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_F() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N, -2147483647);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, -x);\n        }\n        else if (c == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getMaxRange(s, t + 1);\n            printer << -a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_G() {\n    int m, n;\n    int q;\n    scanner >> n >> q;\n\n    SegmentTree<ll> seg(n);\n\n    repeat(_, q) {\n        int t;\n        scanner >> t;\n        if (t == 0) {\n            int s, t, x;\n            scanner >> s >> t >> x;\n            --s; --t;\n            seg.addValueRange(s, t + 1, x);\n        }\n        else {\n            int s, t;\n            scanner >> s >> t;\n            --s; --t;\n            printer << (seg.getSumRange(s, t + 1)) << '\\n';\n        }\n    }\n    return 0;\n}\n\nint main_dsl_2_H() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N);\n    repeat(_, Q) {\n        int q, s, t, x;\n        scanner >> q;\n        if (q == 0) {\n            scanner >> s >> t >> x;\n            segtree.addValueRange(s, t + 1, -x);\n        }\n        else if (q == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getMaxRange(s, t + 1);\n            printer << a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_I() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getSumRange(s, t + 1);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\n\nint main() {\n    // main_dsl_2_A();\n    // main_dsl_2_B();\n    main_dsl_2_D();\n    // main_dsl_2_E();\n    // main_dsl_2_F();\n    // main_dsl_2_G();\n    // main_dsl_2_H();\n    // main_dsl_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = -1 * (((1<<30)-1)*2+1) ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nclass Bucket{\n  public:\n  vector<ll> buc,v;\n  ll N,sqn,K;\n  Bucket(){};\n  Bucket(ll n){\n    N = n;\n    sqn = sqrt(N);\n    K = (n + sqn - 1) /sqn;\n    buc.assign(K,-inf);\n    v.assign(K * sqn,-inf);\n  }\n  ll find(int x){\n    lazyupdate(x/sqn);\n    return v[x];\n  }\n  void lazyupdate(int k){\n    if(k >= K) return ;\n    if(buc[k] != -inf){\n      for(int i = k * sqn; i < (k+1) * sqn;++i){\n        v[i] = buc[k];\n      }\n    }\n    buc[k] = -inf;\n  }\n  void update(int x,int y,int n){\n    for (int k = 0; k < K; ++k) {\n      int l = k * sqn, r = (k + 1) * sqn;\n      if (r <= x || y <= l)\n        continue;\n      if (x <= l && r <= y) {\n        buc[k] = n;\n      } else {\n        lazyupdate(k);\n        for (int i = max(x, l); i < min(y, r); ++i) {\n          v[i] = n;\n        }\n      }\n    }\n  }\n  void Debug(){\n    for(int i = 0; i < N;++i){\n      cout << buc[i/sqn] << ' ';\n    }\n    cout << endl;\n    for(int i = 0; i < N;++i){\n      cout << v[i] << ' ';\n    }\n    cout << endl;\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n, q,s,t,x,a;\n  cin >> n >> q;\n  Bucket buc(n);\n  rep(i,q){\n    cin >> a;\n    if(a){\n      cin >> s;\n      cout << buc.find(s) << endl;\n    }\n    else{\n      cin >> s >> t >> x;\n      buc.update(s,t+1,x);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<typename T>\nclass RangeUpdateQuery {\npublic:\n    explicit RangeUpdateQuery(int n, T def) : N(calcN_(n)) {\n        mVal.assign(2*N+1, make_pair(-1, def));\n    }\n    void update(int l, int r, T value, int ts){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ mVal[offset+l-1].first = ts; mVal[offset+l-1].second = value; l++; }\n            if(r&1){ mVal[offset+r-2].first = ts; mVal[offset+r-2].second = value; }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            res = max(mVal[i], res);\n        }\n        return res.second;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    const int N;\n    vector<pair<int,T>> mVal;\n};\n\nint main(){\n    int n, q;\n    while(cin >> n >> q){\n        const int INF = 0x7FFFFFFF;\n        RangeUpdateQuery<int> ruq(n, INF);\n        for(int i=0;i<q;i++){\n            int c; cin >> c;\n            if(c == 0){\n                int s, t, x; cin >> s >> t >> x;\n                ruq.update(s, t+1, x, i);\n            } else {\n                int p; cin >> p;\n                cout << ruq.get(p) << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename Monoid>\nclass LazySegmentTree{\n  public:\n    using T = typename Monoid::value_type;\n    using E = typename Monoid::lazy_type;\n    int n;\n    T identity;\n    E lazy_def;\n    vector<T> val;\n    vector<E> lazy;\n\n    LazySegmentTree(){}\n    LazySegmentTree(int n_, vector<T> v=vector<T>()){\n      identity = Monoid::identity;\n      lazy_def = Monoid::lazy_def;\n      n = 1;\n      while(n < n_)n *= 2;\n      val.assign(2*n-1, identity);\n      lazy.assign(2*n-1, lazy_def);\n\n      for(size_t i = 0; i < v.size(); i++){\n        val[i+n-1] = v[i];\n      }\n      for(int i = n - 2; i >= 0; i--){\n        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);\n      }\n    }\n    void eval(int k, int len){\n      if(lazy[k] == lazy_def)return;\n      if(k < n - 1){\n        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);\n        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);\n      }\n      val[k] = Monoid::lazy_update(val[k], lazy[k], len);\n      lazy[k] = lazy_def;\n    }\n    T update(int a,int b, E &e, int k, int l, int r){\n      eval(k, r - l);\n      if(r <= a || b <= l)return val[k];\n      else if(a <= l && r <= b){\n        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);\n        eval(k, r - l);\n        return val[k];\n      }else{\n        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);\n        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);\n        return val[k] = Monoid::operation(lv, rv);\n      }\n    }\n    T update(int a, int b, E e){\n      return update(a, b, e, 0, 0, n);\n    }\n    T query(int a, int b, int k, int l, int r){\n      eval(k, r - l);\n      if(r <= a || b <= l)return identity;\n      if(a <= l && r <= b)return val[k];\n      T lv = query(a, b, 2*k+1, l, (l+r)/2);\n      T rv = query(a, b, 2*k+2, (l+r)/2, r);\n      return Monoid::operation(lv, rv);\n    }\n    T query(int a, int b){\n      return query(a, b, 0, 0, n);\n    }\n    T get(int i){\n      return query(i, i + 1);\n    }\n};\n\ntemplate <typename T, typename E>\nclass RUQ{\n  public:\n    using value_type = T;\n    using lazy_type = E;\n    const static T identity = 0;\n    const static E lazy_def = numeric_limits<E>::min();\n    RUQ(){}\n    static T operation(T &l, T &r){\n      return l + r;\n    }\n    static E lazy_accumulate(E &l, E &r){\n      return r;\n    }\n    static T lazy_update(T &t, E &e, int len){\n      return e * len;\n    }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  int n, q; cin >> n >> q;\n  LazySegmentTree<RUQ<ll, ll>> seg(n, vector<ll>(n, INT_MAX));\n  rep(i_, q){\n    int c; cin >> c;\n    if(c == 0){\n      int s, t; cin >> s >> t;\n      ll x; cin >> x;\n      seg.update(s, t + 1, x);\n    }else{\n      int i; cin >> i;\n      cout << seg.get(i) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing int64 = long long;\n\n#define all(_) begin(_), end(_)\n#define rall(_) rbegin(_), rend(_)\n\ntemplate <class M, class F>\nclass SegmentTree {\n public:\n  SegmentTree(const std::vector<M>& data, M ie, F f)\n      : ie_(ie), data_(data), f_(f) {\n    build();\n  }\n\n  void update(int pos, M val) {\n    assert(0 <= pos && pos < n_);\n    pos += n_;\n    node_[pos] = val;\n    while (pos > 0) {\n      pos >>= 1;\n      node_[pos] = f_(node_[2 * pos], node_[2 * pos + 1]);\n    }\n  }\n\n  // return f_[l, r)\n  // if l >= r, return ie_\n  M query(int l, int r) {\n    assert(0 <= l && l < n_ && 0 <= r && r < n_ + 1);\n    M vl = ie_, vr = ie_;\n    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) vl = f_(vl, node_[l++]);\n      if (r & 1) vr = f_(node_[--r], vr);\n    }\n    return f_(vl, vr);\n  }\n\n  M operator[](int pos) const {\n    assert(0 <= pos && pos < n_);\n    return node_[n_ + pos];\n  }\n\n private:\n  int n_;\n  M ie_;\n  std::vector<M> data_;\n  std::vector<M> node_;\n  F f_;\n\n  void build() {\n    int sz = data_.size();\n    n_ = 1;\n    while (n_ < sz) n_ <<= 1;\n    node_.assign(2 * n_, ie_);\n    for (int i = 0; i < sz; ++i) node_[i + n_] = data_[i];\n    for (int i = n_ - 1; i > 0; --i)\n      node_[i] = f_(node_[2 * i], node_[2 * i + 1]);\n  }\n};\n\ntemplate <class M, class F>\nclass DualSegmentTree {\n public:\n  DualSegmentTree(const std::vector<M>& data, M ie, F f)\n      : ie_(ie), data_(data), f_(f) {\n    build();\n  }\n\n  // modify data_[l, r) -> f_(data_[l], val), ..., f_(data[r - 1], val)\n  void modify(int l, int r, M val) {\n    thrust(l + n_);\n    thrust(r + n_ - 1);\n    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) lazy_[l] = f_(lazy_[l], val), ++l;\n      if (r & 1) --r, lazy_[r] = f_(lazy_[r], val);\n    }\n  }\n\n  M operator[](int pos) {\n    pos += n_;\n    thrust(pos);\n    return f_(data_[pos - n_], lazy_[pos]);\n  }\n\n private:\n  int n_, h_;\n  std::vector<M> data_;\n  std::vector<M> lazy_;\n  F f_;\n  M ie_;\n\n  void build() {\n    int sz = data_.size();\n    n_ = 1;\n    h_ = 0;\n    while (n_ < sz) n_ <<= 1, ++h_;\n    lazy_.assign(2 * n_, ie_);\n  }\n\n  inline void propagate(int k) {\n    if (lazy_[k] != ie_) {\n      lazy_[2 * k + 0] = f_(lazy_[2 * k + 0], lazy_[k]);\n      lazy_[2 * k + 1] = f_(lazy_[2 * k + 1], lazy_[k]);\n      lazy_[k] = ie_;\n    }\n  }\n\n  inline void thrust(int k) {\n    for (int i = h_; i > 0; --i) propagate(k >> i);\n  }\n};\n\nvoid DSL_2_D() {\n  int n, q; cin >> n >> q;\n  constexpr int inf = 2147483647;\n  auto f = [](int x, int y){ return y; };\n  DualSegmentTree<int, decltype(f)> seg(vector<int>(n, inf), inf, f);\n  while (q--) {\n    int op; cin >> op;\n    if (op == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      seg.modify(s, t + 1, x);\n    } else {\n      int pos; cin >> pos;\n      cout << seg[pos] << '\\n';\n    }\n  }\n}\n\nvoid DSL_2_E() {\n  int n, q; cin >> n >> q;\n  auto f = [](int x, int y){ return x + y; };\n  DualSegmentTree<int, decltype(f)> seg(vector<int>(n, 0), 0, f);\n  while (q--) {\n    int op; cin >> op;\n    if (op == 0) {\n      int s, t, x; cin >> s >> t >> x; --s; --t;\n      seg.modify(s, t + 1, x);\n    } else {\n      int pos; cin >> pos; --pos;\n      cout << seg[pos] << '\\n';\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  DSL_2_D();\n  //DSL_2_E();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[100000];\n    int t[100000];\n    int x[100000];\n    int i, j, m, s_min, t_max, n, q, ask; \n    s_min = 100000;\n    t_max = 0;\n    m = 0;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){ cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){ cout << x[j] << endl; break; }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF=INT_MAX;\n\nstruct lst\n{\n    private:\n        int n;\n        vector<int> node;\n        vector<int> lazy;\n        vector<bool> lflg;\n    public:\n        lst(int sz)\n        {\n            n=1; while(n<sz) n*=2;\n            node.resize(2*n-1, INF);\n            lazy.resize(2*n-1, 0);\n            lflg.resize(2*n-1, false);\n        }\n    void lazy2node(int k, int l, int r)\n    {\n        if(lflg[k])\n        {\n            node[k]=lazy[k];\n            lflg[k]=false;\n            prop(k, l, r);\n        }\n    }\n    void prop(int k, int l, int r)\n    {\n        if (r-l>0)\n        {\n            lazy[2*k+1]=lazy[2*k+2]=node[k];\n            lflg[2*k+1]=lflg[2*k+2]=true;\n        }\n    }\n\n    void update(int qa, int qb, int v, int k=0, int l=0, int r=-1)\n    {\n        if(r<0) r=n-1;\n        lazy2node(k, l, r);\n        if(qb<l || r<qa) return;\n        if(qa<=l && r<=qb) \n        {\n            node[k] = v;\n            prop(k, l, r);\n        }\n        else\n        {\n            int m=(l+r)/2;\n            update(qa, qb, v, 2*k+1, l, m);\n            update(qa, qb, v, 2*k+2, m+1, r);\n        }\n    }\n\n    int get(int qa, int qb, int k=0, int l=0, int r=-1)\n    {\n        if(r<0) r=n-1;\n        lazy2node(k, l, r);\n        if(qb<l || r<qa) return INF;\n        if(qa<=l && r<=qb) return node[k];\n        else\n        {\n            int m=(l+r)/2;\n            int lv = get(qa, qb, 2*k+1, l, m);\n            int lr = get(qa, qb, 2*k+2, m+1, r);\n            return min(lv, lr);\n        }\n    }\n};\n\nint main()\n{\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    lst tree = lst(n);\n    for(int i=0; i<q; i++)\n    {\n        int t;\n        scanf(\"%d\", &t);\n        if(t)\n        {\n            int s;\n            scanf(\"%d\", &s);\n            printf(\"%d\\n\", tree.get(s,s));\n        }\n        else\n        {\n            int s, t, v;\n            scanf(\"%d %d %d\", &s, &t, &v);\n            tree.update(s, t, v);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\n#include <array>\nusing namespace std;\n\nstruct SgTree{\nprivate:\n\tvector<pair<long long, bool>> node;\n\tlong long defval;\n\tint N;\n\tint n;\npublic:\n\tvoid init(int n, long long defval = INT64_MAX){\n\t\tN = 1;\n\t\twhile(N < n)N<<=1;\n\t\tthis->n = n;\n\t\tthis->defval = defval;\n\t\tnode.assign(N*2-1, make_pair(defval, false));\n\t}\n\tlong long query(int a, int b, int l = 0, int r = -1, int i = 0){\n\t\tif(r == -1) r = N;\n\t\tif(b <= l || r <= a) return defval;\n\t\tif(a <= l && r <= b) return node[i].first;\n\t\tif(node[i].second) return node[i].first;\n\t\treturn min(query(a,b,l,(l+r)/2,i*2+1),query(a,b,(l+r)/2,r,i*2+2));\n\t}\n\tvoid update2(int a, int b, long long v, int l, int r, int i, long long defv){\n\t\tif(b <= l || r <= a) { node[i] = make_pair(defv, true); return; }\n\t\tif(a <= l && r <= b) { node[i] = make_pair(v, true); return; }\n\t\t\n\t\tupdate2(a,b,v,l,(l+r)/2,i*2+1,defv);\n\t\tupdate2(a,b,v,(l+r)/2,r,i*2+2,defv);\n\n\t\tnode[i].second = false;\n\t\tnode[i].first = min(node[i*2+1].first, node[i*2+2].first);\n\t}\n\tvoid update(int a, int b, long long v, int l = 0, int r = -1, int i = 0){\n\t\tif(r == -1) r = N;\n\t\tif(b <= l || r <= a) return;\n\t\tif(a <= l && r <= b) { node[i] = make_pair(v, true); return; }\n\t\tif(node[i].second) return update2(a,b,v,l,r,i,node[i].first);\n\t\t\n\t\tupdate(a,b,v,l,(l+r)/2,i*2+1);\n\t\tupdate(a,b,v,(l+r)/2,r,i*2+2);\n\n\t\tnode[i].first = min(node[i*2+1].first, node[i*2+2].first);\n\t}\n\n};\n\n\nint main() {\n\tint n, q; cin >> n >> q;\n\tSgTree tr; tr.init(n, INT_MAX);\n\n\tvector<long long> ans;\n\n\tfor(int i = 0; i < q; i++){\n\t\tint c; cin >> c;\n\t\tif(c == 0){\n\t\t\tint s,t,x; cin >> s >> t >> x;\n\t\t\ttr.update(s, t+1, x);\n\t\t}\n\t\telse {\n\t\t\tint i; cin >> i;\n\t\t\tans.push_back(tr.query(i, i+1));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tcout << ans[i] << endl;\n\t}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define all(V) (V).begin(),(V).end()\n#define umap unordered_map\n#define uset unordered_set\n#define br cout<<\"\\n\";\n\nconst int MAXN=1e5+10, MOD=1e9+7;\nint n,m;\nint arr[MAXN];\nint t[5*MAXN],lazy[5*MAXN];\n\nint doit(int a,int b){\n\treturn a+b;\n}\n\nvoid build(int start,int end,int index=1){\n\tif(start==end){\n\t\tt[index]=INT_MAX;\n\t\treturn ;\n\t}\n\tint mid = start+end >> 1;\n\tbuild(start,mid,index << 1);\n\tbuild(mid+1,end,index<<1|1);\n\tt[index] = doit(t[index<<1], t[index<<1|1]);\n}\n\nvoid propagate(int start,int end,int index){\n\tt[index] = (end-start+1)*lazy[index];\n\t// bcz leaf not hv childs\n\tif(start!=end){\n\t\tlazy[index<<1] = lazy[index];\n\t\tlazy[index<<1|1] = lazy[index];\n\t}\n\tlazy[index]=-1;\n}\n\nint Query(int start,int end,int l,int r,int index=1){\n\n\tif(lazy[index]!=-1){\n\t\tpropagate(start,end,index);\n\t}\n\t// out range\n\tif(r<start or end<l){\n\t\treturn 0;\n\t}\n\t// in Raange\n\tif( l<=start and end<=r){\n\t\treturn t[index];\n\t}\n\tint mid = start+end >>1;\n\treturn doit(Query(start,mid,l,r,index<<1), Query(mid+1,end,l,r,index<<1|1));\n}\n\nvoid pUpdate(int start,int end,int point,int val,int index=1){\n\tif(start==end){\n\t\tt[index]=val;\n\t\treturn ;\n\t}\n\tint mid = start+end>>1;\n\tif(point <= mid){\n\t\tpUpdate(start,mid,point,val,index<<1);\n\t}\n\telse{\n\t\tpUpdate(mid+1,end,point,val,index<<1|1);\n\t}\n\tt[index] = doit(t[index <<  1] , t[index << 1 | 1]);\n}\n\n\nvoid rangeUpdate(int start,int end,int l,int r,int val,int index){\n\tif(lazy[index]!= -1){\n\t\tpropagate(start,end,index);\n\t}\n\tif(l>end or r<start){\n\t\treturn;\n\t}\n\t// in range\n\tif(l<=start and end<=r){\n\t\tlazy[index]=val;\n\t\tpropagate(start,end,index);\n\t\treturn;\n\t}\n\tint mid = start+end>>1;\n\trangeUpdate(start,mid,l,r,val,index<<1);\n\trangeUpdate(mid+1,end,l,r,val,index<<1|1);\n\tt[index] = doit(t[index<<1],t[index<<1|1]);\n}\n\n\n\n\nsigned main()\n{\n// \t#ifndef ONLINE_JUDGE\n// \t\tfreopen(\"./input.txt\",\"r\",stdin);\n// \t\tfreopen(\"./output.txt\",\"w\",stdout);\n// \t#endif\n\tios::sync_with_stdio(false); cin.tie(nullptr);\n\tcin>>n>>m;\n\tmemset(lazy,-1,sizeof lazy);\n\tbuild(0,n-1);\n\tfor(int i=1; i<=m; i++){\n\t\tint q; cin>>q;\n\t\tif(q==1){\n\t\t\tint t; cin>>t;\n\t\t\tcout<<Query(0,n-1,t,t,1); br;\n\t\t}\n\t\telse{\n\t\t\tint s,t,x; cin>>s>>t>>x;\n\t\t\trangeUpdate(0,n-1,s,t,x,1);\n\t\t}\n\t}\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debugos clog\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_reference<remove_const<decltype(l)>::type>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ninline void assert_call(bool assertion, function<void()> f) { if (!assertion) { cerr << \"assertion fault:\" << endl; f(); abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream& os, const Vec& a) {\n    os << '['; for (const auto& e : a) os << ' ' << e << ' '; os << ']'; return os;\n}\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) noexcept {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc < '0' || '9' < cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() noexcept { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) noexcept { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) noexcept { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) noexcept {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) noexcept { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) noexcept { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) noexcept { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) noexcept { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = ' ') { for (bool b = 0; begin != end; ++begin, b = 1) b ? *this << sep << *begin : *this << *begin; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\ntemplate<typename T>\n//using T = ll;\nclass SegmentTree {\npublic:\n    struct IdxVal {\n        int index;\n        T value;\n        inline IdxVal(int _i = 0, const T& _v = T()) :index(_i), value(_v) { }\n        inline void set(int i, const T& v) { index = i; value = v; }\n        inline bool operator<(const T& t) const { return value < t; }\n        inline bool operator==(const T& t) const { return value == t; }\n        inline bool operator<(const IdxVal& iv) const { return value < iv.value || (value == iv.value && index < iv.index); }\n        inline bool operator==(const IdxVal& iv) const { return index == iv.index && value == iv.value; }\n    };\n\n    enum struct Cmd{\n        None, Add, Flat\n    };\n\n    struct Node {\n        T sum, lazyValue;\n        IdxVal max;\n        Cmd lazyType;\n    };\n\nprivate:\n    const int size_;\n    vector<T> leaf_data_;\n    vector<Node> node_data_;\n    T* leaf_;\n    Node* node_;\n\n    void _resize() {\n        leaf_data_.resize(size_);\n        node_data_.resize(size_ - 1);\n\n        leaf_ = &leaf_data_[0];\n        node_ = &node_data_[0] - 1;\n    }\n\n    void _init() {\n        for (int i = size_ - 1; 0 < i; --i) {\n            int c = i << 1;\n            if (size_ <= c)\n                node_[i].max.set(c - size_, leaf_[c - size_]);\n            else\n                node_[i].max = node_[c].max;\n            node_[i].lazyType = Cmd::None;\n            node_[i].sum = node_[i].lazyValue = 0;\n        }\n    }\npublic:\n\n    inline void fill(T val) {\n        std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n        _init();\n    }\n\n    SegmentTree(int _n) :\n        size_([](int _n) {int s = 8; while (s < _n) s <<= 1; return s; }(_n))\n    {\n        _resize();\n        _init();\n    }\n    SegmentTree(int _n, const T& _fillVal) :\n        size_([](int _n) {int s = 8; while (s < _n) s <<= 1; return s; }(_n))\n    {\n        _resize();\n        fill(_fillVal);\n    }\n\n\nprivate:\n    // lazyを適応する(子を呼ぶ前に呼ぶ)\n    // width: ptrが担当するnodeの範囲の大きさ(ptr = 1 ならば size_)\n    inline void _applyDown(int ptr, int width) {\n        width >>= 1;\n        //if (size_ <= ptr) return;\n        if (node_[ptr].lazyType == Cmd::Add) {\n            int c = ptr << 1;\n\n            if (size_ <= c) {\n                leaf_[c - size_] += node_[ptr].lazyValue;\n                leaf_[c + 1 - size_] += node_[ptr].lazyValue;\n            }\n            else {\n                node_[c].sum += node_[ptr].lazyValue * width;\n                node_[c].max.value += node_[ptr].lazyValue;\n                node_[c].lazyValue += node_[ptr].lazyValue;\n                if (node_[c].lazyType == Cmd::None)\n                    node_[c].lazyType = Cmd::Add;\n\n                node_[c + 1].sum += node_[ptr].lazyValue * width;\n                node_[c + 1].max.value += node_[ptr].lazyValue;\n                node_[c + 1].lazyValue += node_[ptr].lazyValue;\n                if (node_[c + 1].lazyType == Cmd::None)\n                    node_[c + 1].lazyType = Cmd::Add;\n            }\n\n            node_[ptr].lazyType = Cmd::None;\n            node_[ptr].lazyValue = 0;\n        }\n        else if (node_[ptr].lazyType == Cmd::Flat) {\n            node_[ptr].lazyType = Cmd::None;\n            int c = ptr << 1;\n\n            if (size_ <= c) {\n                leaf_[c - size_] = node_[ptr].lazyValue;\n                leaf_[c + 1 - size_] = node_[ptr].lazyValue;\n            }\n            else {\n                node_[c].sum = node_[ptr].lazyValue * width;\n                node_[c].max.value = node_[ptr].lazyValue;\n                node_[c].lazyValue = node_[ptr].lazyValue;\n                node_[c].lazyType = Cmd::Flat;\n\n                node_[c + 1].sum = node_[ptr].lazyValue * width;\n                node_[c + 1].max.value = node_[ptr].lazyValue;\n                node_[c + 1].lazyValue = node_[ptr].lazyValue;\n                node_[c + 1].lazyType = Cmd::Flat;\n            }\n\n            node_[ptr].lazyType = Cmd::None;\n            node_[ptr].lazyValue = 0;\n        }\n    }\n\n    // lazyを適応する(子を呼んだ後に呼ぶ)\n    inline void _applyUp(int ptr) {\n        if (size_ <= ptr << 1) {\n            int i = (ptr << 1) - size_;\n            if (leaf_[i] < leaf_[i + 1])\n                node_[ptr].max.set(i + 1, leaf_[i + 1]);\n            else\n                node_[ptr].max.set(i, leaf_[i]);\n            node_[ptr].sum = leaf_[i] + leaf_[i + 1];\n        }\n        else {\n            if (node_[(ptr << 1)].max.value < node_[(ptr << 1) + 1].max.value)\n                node_[ptr].max = node_[(ptr << 1) + 1].max;\n            else\n                node_[ptr].max = node_[(ptr << 1)].max;\n            node_[ptr].sum = node_[ptr << 1].sum + node_[(ptr << 1) + 1].sum;\n        }\n    }\n\n    // _downward_applyDown(ptr1): leaf[ptr1]の値を正しくする．\n    void _downward_applyDown(int ptr1, int width = 1) {\n        if (1 < ptr1) _downward_applyDown(ptr1 >> 1, width << 1);\n        _applyDown(ptr1, width);\n    }\n\n\n    void _setValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n\n        if (rangeend <= begin || end <= rangebegin) return; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr) {\n                leaf_[rangebegin] = val;\n            }\n            else {\n                node_[ptr].sum = val * (rangeend - rangebegin);\n                node_[ptr].max.value = val;\n                node_[ptr].lazyType = Cmd::Flat;\n                node_[ptr].lazyValue = val;\n            }\n            return;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        _setValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        _setValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        _applyUp(ptr);\n    }\n\n    void _addValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n\n        if (rangeend <= begin || end <= rangebegin) return; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr) {\n                leaf_[rangebegin] += val;\n            }\n            else {\n                node_[ptr].sum += val * (rangeend - rangebegin);\n                node_[ptr].max.value += val;\n                node_[ptr].lazyValue += val;\n                if (node_[ptr].lazyType == Cmd::None)\n                    node_[ptr].lazyType = Cmd::Add;\n            }\n            return;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        _addValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        _addValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        _applyUp(ptr);\n    }\n\n    T _getSumRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return 0; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr)\n                return leaf_[rangebegin];\n            else\n                return node_[ptr].sum;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        return _getSumRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1)\n            + _getSumRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n    }\n\n    IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return IdxVal(-1); // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr)\n                return IdxVal(rangebegin, leaf_[rangebegin]);\n            else\n                return node_[ptr].max;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        if (l.index == -1) return move(r);\n        if (r.index == -1) return move(l);\n        return l.value < r.value ? move(r) : move(l);\n    }\n\npublic:\n    // [index] の値を求める\n    inline T getValue(int index) {\n        _downward_applyDown((index + size_) >> 1);\n        return leaf_[index];\n    }\n\n    // [index] の値を書き換える\n    inline T setValue(int index, T val) {\n        _downward_applyDown((index + size_) >> 1);\n        T diff = val - leaf_[index];\n        leaf_[index] = val;\n\n        for (int ptr = (index + size_); 1 < ptr;) {\n            ptr >>= 1;\n            node_[ptr].sum -= diff;\n            _applyUp(ptr);\n        }\n    }\n\n    // [index] の値に加算する\n    inline T addValue(int index, T val) {\n        _downward_applyDown((index + size_) >> 1);\n        leaf_[index] += val;\n\n        for (int ptr = (index + size_); 1 < ptr;) {\n            ptr >>= 1;\n            node_[ptr].sum += val;\n            _applyUp(ptr);\n        }\n    }\n\n    // 区間[begin,end)全てにvalをセットする\n    inline void setValueRange(int begin, int end, T val) {\n        _setValueRange(begin, end, val, 1, 0, size_);\n    }\n\n    // 区間[begin,end)に一様にvalを加算する\n    inline void addValueRange(int begin, int end, T val) {\n        _addValueRange(begin, end, val, 1, 0, size_);\n    }\n\n    // 区間[begin,end)の和を求める\n    inline T getSumRange(int begin, int end) {\n        return _getSumRange(begin, end, 1, 0, size_);\n    }\n\n    // 区間[begin,end)の最大値とその位置を求める\n    inline IdxVal getMaxRange(int begin, int end) {\n        return _getMaxRange(begin, end, 1, 0, size_);\n    }\n};\n\n\nint main_dsl_2_A() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N, -2147483647);\n    repeat(_, Q) {\n        int c, x, y;\n        scanner >> c >> x >> y;\n        if (c == 0) {\n            segtree.setValue(x, -y);\n        }\n        else if (c == 1) {\n            auto a = segtree.getMaxRange(x, y + 1);\n            printer << -a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_B() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N, 0);\n    repeat(_, Q) {\n        int c, x, y;\n        scanner >> c >> x >> y;\n        if (c == 0) {\n            segtree.addValue(x - 1, y);\n        }\n        else if (c == 1) {\n            auto a = segtree.getSumRange(x - 1, y);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_D() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N, 2147483647);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s;\n            auto a = segtree.getValue(s);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_E() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N);\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.addValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s;\n            auto e = segtree.getValue(s);\n            printer << e << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_F() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N, -2147483647);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, -x);\n        }\n        else if (c == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getMaxRange(s, t + 1);\n            printer << -a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_G() {\n    int m, n;\n    int q;\n    scanner >> n >> q;\n\n    SegmentTree<ll> seg(n);\n\n    repeat(_, q) {\n        int t;\n        scanner >> t;\n        if (t == 0) {\n            int s, t, x;\n            scanner >> s >> t >> x;\n            --s; --t;\n            seg.addValueRange(s, t + 1, x);\n        }\n        else {\n            int s, t;\n            scanner >> s >> t;\n            --s; --t;\n            printer << (seg.getSumRange(s, t + 1)) << '\\n';\n        }\n    }\n    return 0;\n}\n\nint main_dsl_2_H() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N);\n    repeat(_, Q) {\n        int q, s, t, x;\n        scanner >> q;\n        if (q == 0) {\n            scanner >> s >> t >> x;\n            segtree.addValueRange(s, t + 1, -x);\n        }\n        else if (q == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getMaxRange(s, t + 1);\n            printer << a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_I() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getSumRange(s, t + 1);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\n\nint main() {\n    // main_dsl_2_A();\n    // main_dsl_2_B();\n    main_dsl_2_D();\n    // main_dsl_2_E();\n    // main_dsl_2_F();\n    // main_dsl_2_G();\n    // main_dsl_2_H();\n    // main_dsl_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\nusing ll = long long int;\n\ntemplate<typename Type>\nstruct SqrtDecomp {\n    int SIZE;\n    vector<Type> node, bucket, lazy, need_upd;\n    Type (*op1) (Type x, Type y, int sz);\n    Type (*op2) (Type x, Type y);\n    Type I_op1, I_op2;\n\n    SqrtDecomp( vector<Type> vec,\n                Type (*g_op1) (Type x, Type y, int sz),\n                Type (*g_op2) (Type x, Type y),\n                Type X_op1, Type X_op2) {\n        int N = vec.size();\n        SIZE = 1; while(SIZE * SIZE < N) SIZE++;\n        op1 = g_op1, op2 = g_op2;\n        I_op1 = X_op1, I_op2 = X_op2;\n\n        node.resize(SIZE*SIZE, I_op2);\n        bucket.resize(SIZE, I_op2);\n        lazy.resize(SIZE, I_op1);\n        need_upd.resize(SIZE, 0);\n\n        for(int i=0; i<SIZE; i++) {\n            Type rep_val = I_op2;\n            for(int j=0; j<SIZE && i*SIZE+j<N; j++) {\n                int idx = (i*SIZE + j);\n                node[idx] = vec[idx];\n                rep_val = op2(rep_val, node[idx]);\n            }\n            bucket[i] = rep_val;\n        }\n    }\n\n    void lazy_eval(int k) {\n        int l = SIZE*k, r = SIZE*(k+1);\n        if(need_upd[k]) {\n            Type seg_val = I_op2;\n\n            // 該当する下のノードをまず更新\n            for(int i=l; i<r; i++) {\n                node[i] = op1(node[i], lazy[k], 1);\n                seg_val = op2(seg_val, node[i]);\n            }\n\n            // 上のノードを更新\n            bucket[k] = seg_val;\n        }\n        lazy[k] = I_op1;\n        need_upd[k] = false;\n    }\n\n    void update(int l, int r, Type val) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        // 左端の更新\n        lazy_eval(lidx);\n        bucket[lidx] = I_op2;\n        for(int k=SIZE*lidx; k<SIZE*(lidx+1); k++) {\n            if(l <= k && k < r) node[k] = op1(node[k], val, 1);\n            bucket[lidx] = op2(bucket[lidx], node[k]);\n        }\n\n        if(lidx != ridx) {\n            // 真ん中 (lazy を更新)\n            for(int k=lidx+1; k<ridx; k++) {\n                lazy[k] = op1(lazy[k], val, 1);\n                need_upd[k] = true;\n            }\n\n            if(ridx != SIZE) {\n                lazy_eval(ridx);\n                bucket[ridx] = I_op2;\n\n                // 右端の更新\n                for(int k=SIZE*ridx; k<SIZE*(ridx+1); k++) {\n                    if(k < r) node[k] = op1(node[k], val, 1);\n                    bucket[ridx] = op2(bucket[ridx], node[k]);\n                }\n            }\n        }\n    }\n\n    Type query(int l, int r) {\n        int lidx = l / SIZE, ridx = r / SIZE;\n        Type ret = I_op2;\n        \n        // 左端の取得\n        for(int k=l; k<min(r, SIZE*(lidx+1)); k++) {\n            lazy_eval(lidx);\n            ret = op2(ret, node[k]);\n        }\n\n        if(lidx != ridx) {\n            for(int k=lidx+1; k<ridx; k++) {\n                // 全体の値と lazy の値を考慮して値を計算\n                Type val = (need_upd[k] ? op1(bucket[k], lazy[k], SIZE) : bucket[k]);\n                ret = op2(ret, val);\n            }\n\n            for(int k=SIZE*ridx; k<r; k++) {\n                lazy_eval(ridx);\n                ret = op2(ret, node[k]);\n            }\n        }\n\n        return ret;\n    }\n\n    /*\n    void print_debug() {\n        printf(\"<< node >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %lld\\n\", l, r, bucket[i]);\n        }\n        printf(\"lower bucket:\\n\");\n        for(int i=0; i<SIZE*SIZE; i++) {\n            printf(\"[%6d, %6d) -> %lld\\n\", i, i+1, node[i]);\n        }\n\n        printf(\"<< lazy >>\\n\");\n        printf(\"upper bucket:\\n\");\n        for(int i=0; i<SIZE; i++) {\n            int l = SIZE*i, r = SIZE*(i+1);\n            printf(\"[%6d, %6d) -> %lld\\n\", l, r, lazy[i]);\n        }\n        printf(\"\\n\");\n    }\n    */\n};\n\n/*\n// Range Minimum Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a, a+1, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a, b+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// Range Sum Query\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0);\n\n    while(Q--) {\n        int query, a, b; scanf(\"%d%d%d\", &query, &a, &b);\n        if(query == 0) {\n            sqr.update(a-1, a, b);\n        }\n        if(query == 1) {\n            printf(\"%d\\n\", sqr.query(a-1, b));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n\n// Range Update Query\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int x; scanf(\"%d\", &x);\n            printf(\"%d\\n\", sqr.query(x, x+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n\n/*\n// Range Add Query\nint upd_f(int a, int b, int sz) {\n    return a + sz * b;\n}\nint qry_f(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, 0), upd_f, qry_f, 0, 0);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l-1, r, x);\n        }\n        if(query == 1) {\n            int x; scanf(\"%d\", &x);\n            printf(\"%d\\n\", sqr.query(x-1, x));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// RMQ and RUQ\nint upd_f(int a, int b, int sz) {\n    return b;\n}\nint qry_f(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<int> sqr(vector<int>(N, INT_MAX), upd_f, qry_f, INT_MAX, INT_MAX);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            printf(\"%d\\n\", sqr.query(l, r+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// RSQ and RAQ\nll upd_f(ll a, ll b, int sz) {\n    return a + sz * b;\n}\nll qry_f(ll a, ll b) {\n    return a + b;\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<ll> sqr(vector<ll>(N, 0), upd_f, qry_f, 0, 0);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l-1, r, x);\n        }\n        if(query == 1) {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            printf(\"%lld\\n\", sqr.query(l-1, r));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n\n/*\n// RMQ and RAQ\nconst ll INF = 1LL << 60;\nll upd_f(ll a, ll b, int sz) {\n    return a + b;\n}\nll qry_f(ll a, ll b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    SqrtDecomp<ll> sqr(vector<ll>(N, 0), upd_f, qry_f, 0, INF);\n\n    while(Q--) {\n        int query; scanf(\"%d\", &query);\n        if(query == 0) {\n            int l, r, x; scanf(\"%d%d%d\", &l, &r, &x);\n            sqr.update(l, r+1, x);\n        }\n        if(query == 1) {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            printf(\"%lld\\n\", sqr.query(l, r+1));\n        }\n        // sqr.print_debug();\n    }\n    return 0;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\nclass Segtree{\n\t\n\tprivate:\n\tint V;\n\ttypedef struct st{\n\t\tll a;\n\t}st;\n\tst st0=(st){(ll)1e18};\n\ttypedef struct op{\n\t\tll a;\n\t}op;\n\top op0=(op){-1};\n\tst f(st p,st q){\n\t\treturn (st){min(p.a,q.a)};\n\t}\n\tvoid g(st &p,op q){\n\t\tif(q.a==-1)return;\n\t\tp.a=q.a;\n\t}\n\tvoid h(op &p,op q){\n\t\tif(q.a==-1)return;\n\t\tp.a=q.a;\n\t}\n\t\n\tst *dat;\n\top *laz;\n\t\n\tst propagate(ll k){\n\t\tif(k<V){\n\t\t\th(laz[k*2],laz[k]);\n\t\t\th(laz[k*2+1],laz[k]);\n\t\t}\n\t\tg(dat[k],laz[k]);\n\t\tlaz[k]=op0;\n\t\treturn dat[k];\n\t}\n\tvoid upd(ll l,ll r,op p){\n\t\tl+=V,r+=V+1;\n\t\tfor(ll d=20;d>=0;d--){\n\t\t\tpropagate(l>>d);\n\t\t\tpropagate(r>>d);\n\t\t}\n\t\tfor(ll a=l,b=r;a<b;a>>=1,b>>=1){\n\t\t\tif(a&1){h(laz[a],p);a++;}\n\t\t\tif(b&1){b--;h(laz[b],p);}\n\t\t}\n\t\tfor(ll a=l,b=r;a+b;a>>=1,b>>=1){\n\t\t\tdat[a/2]=f(propagate(a/2*2),propagate(a/2*2+1));\n\t\t\tdat[b/2]=f(propagate(b/2*2),propagate(b/2*2+1));\n\t\t}\n\t}\n\tst qry(ll l,ll r){\n\t\tl+=V,r+=V+1;\n\t\tfor(ll d=20;d>=0;d--){\n\t\t\tpropagate(l>>d);\n\t\t\tpropagate(r>>d);\n\t\t}\n\t\tst L=st0,R=st0;\n\t\tfor(ll a=l,b=r;a<b;a>>=1,b>>=1){\n\t\t\tif(a&1){L=f(L,propagate(a));a++;}\n\t\t\tif(b&1){b--;R=f(propagate(b),R);}\n\t\t}\n\t\tst res=f(L,R);\n\t\treturn res;\n\t}\n\t\n\tpublic:\n\tvoid init(int ns){\n\t\tV=1;\n\t\twhile(V<=ns)V*=2;\n\t\tdat=new st[2*V];\n\t\tlaz=new op[2*V];\n\t\tfor(int i=0;i<2*V;i++){\n\t\t\tdat[i]=st0;\n\t\t\tlaz[i]=op0;\n\t\t}\n\t}\n\tvoid update(ll l,ll r,ll a){\n\t\tupd(l,r,(op){a});\n\t}\n\tll query(ll l,ll r){\n\t\tst res=qry(l,r);\n\t\treturn res.a;\n\t}\n};\nSegtree seg;\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tseg.init(n);\n\trep(i,n)seg.update(i,i,2147483647);\n\twhile(q--){\n\t\tll p,s,t,x;\n\t\tcin>>p;\n\t\tif(p==0){\n\t\t\tcin>>s>>t>>x;\n\t\t\tseg.update(s,t,x);\n\t\t}\n\t\tif(p==1){\n\t\t\tcin>>s;\n\t\t\tcout<<seg.query(s,s)<<\"\\n\";\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n#include <bits/stdc++.h>\nusing namespace std;\nconst ll INF = pow(2,33);\n\ntemplate<typename T>\nstruct SegmentTree{\n    vector<T> node;\n    ll cou;\n    ll size;\n    SegmentTree(int n=1, T first_value = 0 ){\n        cou = 0;\n        while( n > (int)pow(2,cou) ) cou++;\n        cou++;\n        node.resize((int)pow(2,cou),first_value);\n        size = (int)pow(2,cou);\n    }\n    // void update(int index, T value ){\n    //     update_node(convert(index),value);\n    // }\n    \n    void update_range(int s,int t,int k,int l,int r, T value ){\n        // std::cout << l<<\" \"<<r <<\" \"<<k << std::endl;\n        if(r <= s || t <= l ) return;\n        if(s <= l && r <= t ) {\n            node[k] = value;\n            return ;\n        }   \n        update_range(s,t,child1(k),l,(l+r)/2,value);\n        update_range(s,t,child1(k)+1,(l+r)/2,r,value);\n    }\n    \n    // void update_node(int node_index, T value ){\n    //     // 本人と親を更新\n        \n    //     // 処理次第\n    //     node[node_index] = value;\n        \n    //     if( node_index == 0 ) return;\n\n    //     update_node(parent(node_index),value);\n    // }\n    // // [a,b)に対して答える\n\n    // ll query(int a, int b, int k, int l, int r) {\n    //     // std::cout << l<<\" \"<<r << std::endl;\n    //     if (r <= a || b <= l){\n    //         return 0;\n    //     }\n    //     if (a <= l && r <= b){\n    //         return node[k]; // ノード k の担当範囲がクエリ区間 [a, b) に完全に含まれる\n    //     }else {\n    //         // 一部だけ範囲が被る場合は左右の子に委託する\n    //         ll c1 = query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子に値を聞く\n    //         ll c2 = query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子に値を聞く\n    //         return c1+c2; // 左右の子の値の min を取る\n    //     }\n    // }\n    ll find(int x){\n        ll now = -2;\n        ll result = 0;\n        ll now_node = convert(x);\n        while(true){\n            if(node[now_node].first > now){\n                // std::cout << node[now_node].second << std::endl;\n                result = node[now_node].second;\n                now = node[now_node].first;\n            }\n            if(now_node == 0) break;\n            now_node = parent(now_node);\n        }\n        return result;\n    }\n\n    int parent(int node_index){\n        return (node_index-1)/2;\n    }\n    int convert(int origin){\n        return origin    +(int)(pow(2,cou-1)-1);\n    }\n    int rconvert(int node_index){\n        return node_index-(int)(pow(2,cou-1)-1);\n    }\n    int child1( int node_index){\n        return node_index*2+1;\n    }\n    // TLEうんでるっぽい\n    // // 元の配列のindexを返す[l,r)\n    // pair<int,int> cover(int node_index){\n    //     if(rconvert(node_index)>=0){\n    //         return {rconvert(node_index),rconvert(node_index)+1};\n    //     }\n\n    //     return {\n    //         cover(  child1(node_index) ).first,\n    //         cover(  child1(node_index)+1 ).second\n    //     };\n    // }\n    void debug(){\n        ll v = 0;\n        for (int i = 0; i < cou; i++) {\n            for (int j = 0; j < (int)pow(2,i) ; j++) {\n                std::cout << node[v].first<<\",\"<<node[v].second<<\" \";\n                v++;\n            }\n            std::cout << std::endl;\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main(void){\n    ll n,q;\n    std::cin >> n>>q;\n    SegmentTree< pair<ll,ll> > seg(n,make_pair(-1,(int)(pow(2,31)-1)));\n\n    for (int i = 0; i < q; i++) {\n        int c;\n        std::cin >> c;\n        \n        if(c==0){\n            ll s,t,x;\n            std::cin >> s>>t>>x;\n            seg.update_range(s,t+1,0,0,seg.size/2,{i,x});\n            // seg.debug();\n        }else{\n            ll x;\n            std::cin >> x;\n            std::cout << seg.find(x) << std::endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nclass kin{\npublic:\n\tinline void open(FILE *,int);\n\tinline void close(void);\n\tinline void scan(void);\n\tinline kin &operator>(char &);\n\tinline kin &operator>(int &);\n\tinline kin &operator>(long long &);\n\tinline kin &operator>(double &);\n\tinline kin &operator>(long double &);\n\tinline kin &operator>(char *);\n\ttemplate<class T>\n\tinline void get(T *,int);\nprivate:\n\tFILE *fp;\n\tchar *buf;\n\tint siz;\n\tint idx;\n}in;\n\nclass kout{\npublic:\n\tinline void open(FILE *,int);\n\tinline void close(void);\n\tinline void print(void);\n\tinline kout &operator<(char);\n\tinline kout &operator<(int);\n\tinline kout &operator<(long long);\n\tinline kout &operator<(double);\n\tinline kout &operator<(long double);\n\tinline kout &operator<(const char *);\n\ttemplate<class T>\n\tinline void put(T *,int,char,char);\nprivate:\n\tFILE *fp;\n\tchar *buf;\n\tint siz;\n\tint idx;\n}out;\n\ntemplate<class T,class F,class G>\nclass rpseg{\npublic:\n\tinline void open(int);\n\tinline void close(void);\n\tinline void put(int,int,T);\n\tinline T get(int);\n\tinline void set(int,T);\n\tinline void build(void);\n\tinline rpseg(T);\n\tinline rpseg(T,int);\nprivate:\n\tint siz;\n\tint hgt;\n\tint node;\n\tT *dat;\n\tT id;\n\tF appf;\n\tG appg;\n\tinline void update(int);\n};\n\nint main(int argc,char **argv){\n\tin.open(stdin,512);\n\tout.open(stdout,512);\n\tin.scan();\n\tstruct fnf{inline int operator()(int par,int ch){return par;}};\n\tstruct fng{inline int operator()(int val,int dat){return val;}};\n\tint n;\n\tin>n;\n\trpseg<int,fnf,fng> t(2147483647,n);\n\tint q;\n\tin>q;\n\tfor(int i=0;i<q;++i){\n\t\tint c;\n\t\tin>c;\n\t\tif(c==0){\n\t\t\tint l,r,x;\n\t\t\tin>l>r>x;\n\t\t\tt.put(l,r+1,x);\n\t\t}\n\t\telse{\n\t\t\tint p;\n\t\t\tin>p;\n\t\t\tout<t.get(p)<'\\n';\n\t\t}\n\t}\n\tout.print();\n\tin.close();\n\tout.close();\n\treturn 0;\n}\n\ntemplate<class T,class F,class G>\ninline void rpseg<T,F,G>::open(int siza){\n\tsiz=1;\n\thgt=0;\n\twhile(siz<siza){\n\t\tsiz*=2;\n\t\t++hgt;\n\t}\n\tsiz=siza;\n\tnode=siz-1;\n\tint n=node+siz;\n\tdat=new T[n];\n\tfor(int i=0;i<n;++i) dat[i]=id;\n\treturn;\n}\ntemplate<class T,class F,class G>\ninline void rpseg<T,F,G>::close(void){\n\tsiz=hgt=node=0;\n\tdelete[] dat;\n\tdat=nullptr;\n\treturn;\n}\ntemplate<class T,class F,class G>\ninline void rpseg<T,F,G>::put(int first,int last,T val){\n\tupdate(first);\n\tupdate(last-1);\n\tfirst+=node;\n\tlast+=node;\n\twhile(first<last){\n\t\tif(!(first&1)) dat[first]=appg(val,dat[first]);\n\t\tif(!(last&1)){\n\t\t\tdat[last-1]=appg(val,dat[last-1]);\n\t\t\t--last;\n\t\t}\n\t\tfirst/=2;\n\t\tlast/=2;\n\t}\n\treturn;\n}\ntemplate<class T,class F,class G>\ninline T rpseg<T,F,G>::get(int num){\n\tupdate(num);\n\treturn dat[num+node];\n}\ntemplate<class T,class F,class G>\ninline void rpseg<T,F,G>::update(int num){\n\tint k=0;\n\tint h=num+node<(1<<hgt)-1?hgt-1:hgt;\n\tfor(int i=h-1;i>=0;--i){\n\t\tif(dat[k]!=id){\n\t\t\tdat[k*2+1]=appf(dat[k],dat[k*2+1]);\n\t\t\tdat[k*2+2]=appf(dat[k],dat[k*2+2]);\n\t\t\tdat[k]=id;\n\t\t}\n\t\tk=k*2+1+(num+siz>>i&1);\n\t}\n\treturn;\n}\ntemplate<class T,class F,class G>\ninline rpseg<T,F,G>::rpseg(T ida){\n\tid=ida;\n\tsiz=hgt=node=0;\n\tdat=nullptr;\n}\ntemplate<class T,class F,class G>\ninline rpseg<T,F,G>::rpseg(T ida,int siza){\n\tid=ida;\n\topen(siza);\n}\n\ninline void kin::open(FILE *fpa,int siza){\n\tfp=fpa;\n\tbuf=new char[siza];\n\tsiz=siza;\n\tidx=0;\n\treturn;\n}\ninline void kin::close(void){\n\tfp=nullptr;\n\tdelete[] buf;\n\tbuf=nullptr;\n\tsiz=0;\n\tidx=0;\n\treturn;\n}\ninline void kin::scan(void){\n\tint readsiz=(int)std::fread((void *)buf,(std::size_t)1,(std::size_t)siz,fp);\n\tif(readsiz!=siz) buf[readsiz]='\\x00';\n\tidx=0;\n\treturn;\n}\ninline kin &kin::operator>(char &var){\n\tif(!buf[idx]){\n\t\tvar='\\x00';\n\t\treturn *this;\n\t}\n\tvar=buf[idx];\n\tif(++idx==siz) scan();\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(int &var){\n\tif(!buf[idx]){\n\t\tvar=0;\n\t\treturn *this;\n\t}\n\tint sign=-1;\n\tif(buf[idx]=='-'){\n\t\tsign=1;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10-(int)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(long long &var){\n\tif(!buf[idx]){\n\t\tvar=0LL;\n\t\treturn *this;\n\t}\n\tlong long sign=-1LL;\n\tif(buf[idx]=='-'){\n\t\tsign=1LL;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0LL;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10LL-(long long)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(double &var){\n\tif(!buf[idx]){\n\t\tvar=0.0;\n\t\treturn *this;\n\t}\n\tdouble sign=-1.0;\n\tif(buf[idx]=='-'){\n\t\tsign=1.0;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0.0;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10.0-(double)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tif(buf[idx]=='.'){\n\t\tif(++idx==siz) scan();\n\t\tdouble dig=1.0;\n\t\twhile(buf[idx]>='0'){\n\t\t\tvar-=(double)(buf[idx]-'0')*(dig/=10.0);\n\t\t\tif(++idx==siz) scan();\n\t\t}\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(long double &var){\n\tif(!buf[idx]){\n\t\tvar=0.0L;\n\t\treturn *this;\n\t}\n\tlong double sign=-1.0L;\n\tif(buf[idx]=='-'){\n\t\tsign=1.0L;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0.0L;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10.0L-(long double)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tif(buf[idx]=='.'){\n\t\tif(++idx==siz) scan();\n\t\tlong double dig=1.0L;\n\t\twhile(buf[idx]>='0'){\n\t\t\tvar-=(long double)(buf[idx]-'0')*(dig/=10.0L);\n\t\t\tif(++idx==siz) scan();\n\t\t}\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(char *var){\n\tif(!buf[idx]){\n\t\tvar[0]='\\x00';\n\t\treturn *this;\n\t}\n\tint ptr=0;\n\twhile(buf[idx]>='!'){\n\t\tvar[ptr++]=buf[idx];\n\t\tif(++idx==siz) scan();\n\t}\n\tvar[ptr]='\\x00';\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ntemplate<class T>\ninline void kin::get(T *var,int num){\n\tfor(int i=0;i<num;++i) (*this)>var[i];\n\treturn;\n}\n\ninline void kout::open(FILE *fpa,int siza){\n\tfp=fpa;\n\tbuf=new char[siza];\n\tsiz=siza;\n\tidx=0;\n\treturn;\n}\ninline void kout::close(void){\n\tfp=nullptr;\n\tdelete[] buf;\n\tbuf=nullptr;\n\tsiz=0;\n\tidx=0;\n\treturn;\n}\ninline void kout::print(void){\n\tstd::fwrite((void *)buf,(std::size_t)1,(std::size_t)idx,fp);\n\tidx=0;\n\treturn;\n}\ninline kout &kout::operator<(char val){\n\tbuf[idx]=val;\n\tif(++idx==siz) print();\n\treturn *this;\n}\ninline kout &kout::operator<(int val){\n\tif(val<0){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1;\n\tchar dig[10];\n\tint ptr=0;\n\tdo{\n\t\tint tmp=val/10;\n\t\tdig[ptr++]=(char)-(val-tmp*10)+'0';\n\t\tval=tmp;\n\t}while(val);\n\twhile(ptr--){\n\t\tbuf[idx]=dig[ptr];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(long long val){\n\tif(val<0LL){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1LL;\n\tchar dig[19];\n\tint ptr=0;\n\tdo{\n\t\tlong long tmp=val/10LL;\n\t\tdig[ptr++]=(char)-(val-tmp*10LL)+'0';\n\t\tval=tmp;\n\t}while(val);\n\twhile(ptr--){\n\t\tbuf[idx]=dig[ptr];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(double val){\n\tif(val<0.0){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1.0;\n\tdouble dig=1.0;\n\twhile(val/dig<=-10.0) dig*=10.0;\n\tint tmp;\n\twhile(dig>=1.0){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(double)tmp*dig;\n\t\tdig/=10.0;\n\t}\n\tbuf[idx]='.';\n\tif(++idx==siz) print();\n\tfor(int i=0;i<12;++i){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(double)tmp*dig;\n\t\tdig/=10.0;\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(long double val){\n\tif(val<0.0L){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1.0L;\n\tlong double dig=1.0L;\n\twhile(val/dig<=-10.0L) dig*=10.0L;\n\tint tmp;\n\twhile(dig>=1.0L){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(long double)tmp*dig;\n\t\tdig/=10.0L;\n\t}\n\tbuf[idx]='.';\n\tif(++idx==siz) print();\n\tfor(int i=0;i<16;++i){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(long double)tmp*dig;\n\t\tdig/=10.0L;\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(const char *val){\n\tfor(int i=0;val[i];++i){\n\t\tbuf[idx]=val[i];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ntemplate<class T>\ninline void kout::put(T *val,int num,char spc,char end){\n\t--num;\n\tfor(int i=0;i<num;++i) (*this)<val[i]<spc;\n\t(*this)<val[num]<end;\n\treturn;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 2147483647;\nint const TREE_SIZE = 1 << 20;\nlong long int seg_tree[TREE_SIZE];\nlong long int T[TREE_SIZE];\n\nint find(int a){\n\t\n\ta += TREE_SIZE / 2;\n\t\n\tint ret = seg_tree[a];\n\tint tmax = T[a];\n\t\n\tfor(int x = a / 2; x > 0; x /= 2){\n\t\tif(T[x] > tmax){\n\t\t\ttmax = T[x];\n\t\t\tret = seg_tree[x];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid update(int a, int b, int index, int num, int time, int l, int r){\n\t\n\t// 外からは query(a, b, 1, 0, TREE_SIZE / 2) のように呼ぶ\n\t\n\tif(r <= a || b <= l){\n\t\treturn;\n\t}\n\tif(a <= l && r <= b){\n\t\tseg_tree[index] = num;\n\t\tT[index] = time;\n\t\treturn;\n\t}\n\tupdate(a, b, index * 2, num, time, l, (l + r) / 2);\n\tupdate(a, b, index * 2 + 1, num, time, (l + r) / 2, r);\n\treturn;\n}\n\nint main(){\n\t\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tfor(int i = 0; i < TREE_SIZE; i++){\n\t\tseg_tree[i] = INF;\n\t\tT[i] = -1;\n\t}\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tlong long int num, a, b, c;\n\t\tcin >> num;\n\t\tif(num == 0){\n\t\t\tcin >> a >> b >> c;\n\t\t\tupdate(a, b + 1, 1, c, i, 0, TREE_SIZE / 2);\n\t\t}else{\n\t\t\tcin >> a;\n\t\t\tcout << find(a) << endl;\n\t\t}\n\t\t/*\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << find(j) << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nclass RUQ{\npublic:\n  \n  typedef pair<int,int> P;\n  \n  int n, cnt;\n  vector<P> A;\n  \n  const int INF = (1LL<<31)-1;\n  \n  RUQ(){}\n\n  RUQ(int n_){\n    n = 1;\n    while( n_ > n ) n *= 2;\n    A.resize( n * 2 - 1, P( 0, INF ) );\n    cnt = 0;\n  }\n  \n  int find(int x){\n    P res = P( 0, INF );\n    x += n - 1;\n    res = max( res, A[x] );\n    while(x){\n      x = ( x + 1 ) / 2 - 1;\n      res = max( res, A[x] );\n    }\n    return res.second;\n  }\n  \n  void update(int a, int b, int l, int r, int k, P x){\n    if( r <= a || b <= l ) return;\n    if( a <= l && r <= b ){\n      A[k] = x;\n      return;\n    }\n    update( a, b, l, (l+r)/2, k*2+1, x );\n    update( a, b, (l+r)/2, r, k*2+2, x );\n  }\n  \n  void update(int a, int b, int x){\n    cnt++;\n    update(a,b,0,n,0,P(cnt,x));\n  }\n  \n};\n\nsigned main(){\n  \n  int n, q;\n  cin>>n>>q;\n  \n  RUQ ruq(n);\n  \n  while(q--){\n    \n    int com;\n    cin>>com;\n\n    if( com == 0 ){\n      int s, t, x;\n      cin>>s>>t>>x;\n      ruq.update(s,t+1,x);\n    }\n    else{\n      int x;\n      cin>>x;\n      cout<<ruq.find(x)<<endl;\n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid lazy_query(int k, vector<int>& node, vector<int>& lazy, int n) {\n\tif (lazy[k] == INT_MAX)return;\n\tnode[k] = lazy[k];\n\tif (k < n - 1) {\n\t\tlazy[2 * k + 1] = lazy[k];\n\t\tlazy[2 * k + 2] = lazy[k];\n\t}\n\tlazy[k] = INT_MAX;\n}\n\nvoid update(int a, int b, int x, int k, int l, int r, vector<int>&node, vector<int>& lazy, int n) {\n\tlazy_query(k, node, lazy, n);\n\tif (r <= a || b <= l)return;\n\tif (a <= l && r <= b) {\n\t\tlazy[k] = x;\n\t\tlazy_query(k, node, lazy, n);\n\t\treturn;\n\t}\n\telse {\n\t\tlazy_query(k, node, lazy, n);\n\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2, node, lazy, n);\n\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r, node, lazy, n);\n\t\tnode[k] = min(node[2 * k + 1], node[2 * k + 2]);\n\t\treturn;\n\t}\n}\n\nint find(int a, int b, int k, int l, int r, vector<int>&node, vector<int>& lazy, int n) {\n\tlazy_query(k, node, lazy, n);\n\tif (r <= a || b <= l)return INT_MAX;\n\tif (a <= l && r <= b) {\n\t\treturn node[k];\n\t}\n\telse {\n\t\tlazy_query(k, node, lazy, n);\n\t\tint vl = find(a, b, 2 * k + 1, l, (l + r) / 2, node, lazy, n);\n\t\tint vr = find(a, b, 2 * k + 2, (l + r) / 2, r, node, lazy, n);\n\t\t//node[k] = min(node[2 * k + 1], node[2 * k + 2]);\n\t\treturn min(vr, vl);\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_, q;  cin >> n_ >> q;\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<int> node(2 * n - 1, INT_MAX);\n\tvector<int> lazy(2 * n - 1, INT_MAX);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tupdate(s, t + 1, x, 0, 0, n, node, lazy, n);\n\t\t}\n\t\telse {\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << find(s, t + 1, 0, 0, n, node, lazy, n) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\ntemplate <class T, class U = T>\nstruct LazySegTree {\n    int n, height;\n    // 値配列, 値の単位元\n    vector<T> data;\n    T dataId;\n    // 遅延配列, 遅延値の単位元\n    vector<U> lazy;\n    U lazyId;\n\n    function<T(T, T)> fOperate;\n    function<T(T, U)> fAct;\n    function<U(U, U)> fMerge;\n\n    LazySegTree(\n        int _n, T _did = INF, U _lid = INF,\n        function<T(T, T)> _op = [](T t1, T t2) { return min(t1, t2); },\n        function<T(T, U)> _ac = [](T t1, U u1) { return min(t1, u1); },\n        function<U(U, U)> _me = [](U u1, U a) { return a; }\n    )\n        : dataId(_did), lazyId(_lid), fOperate(_op), fAct(_ac), fMerge(_me) {\n        n = 1, height = 0;\n        while (n < _n) n *= 2, height++;\n        data = vector<T>(2 * n, dataId);\n        lazy = vector<U>(2 * n, lazyId);\n    }\n\n    T act(int k){\n        return lazy[k] == lazyId ? data[k] : fAct(data[k], lazy[k]);\n    }\n\n    void propagate(int k){\n        if (lazy[k] == lazyId) return;\n        lazy[2 * k + 0] = fMerge(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = fMerge(lazy[2 * k + 1], lazy[k]);\n        data[k] = act(k), lazy[k] = lazyId;\n    }\n\n\n    // [a, b)を更新\n    void update(int a, int b, U x) {\n        a += n, b += n - 1;\n        for (int i = height; i > 0; i--) propagate(a >> i), propagate(b >> i);\n        for (int l = a, r = b + 1; l < r; l /= 2, r /= 2) {\n            if (l & 1) lazy[l] = fMerge(lazy[l], x), l++;\n            if (r & 1) r--, lazy[r] = fMerge(lazy[r], x);\n        }\n        for (int l = a / 2, r = b / 2; l > 0; l /= 2, r /= 2) {\n            data[l] = fOperate(act(2 * l + 0), act(2 * l + 1));\n            data[r] = fOperate(act(2 * r + 0), act(2 * r + 1));\n        }\n    }\n\n    // [l, r)の区間クエリ\n    T query(int a, int b){\n        a += n, b += n - 1;\n        for (int i = height; i > 0; i--) propagate(a >> i);\n        if (lazy[a] != lazyId) data[a] = lazy[a];\n        // T Lret = dataId, Rret = dataId;\n        // for (int l = a, r = b + 1; l < r; l /= 2, r /= 2){\n        //     if (l & 1) Lret = fOperate(Lret, act(l++));\n        //     if (r & 1) Rret = fOperate(act(--r), Rret);\n        // }\n        // return fOperate(Lret, Rret);\n        return data[a];\n    }\n\n    void build(vector<T> vec){\n        for (int i = 0; i < vec.size(); i++) data[i + n] = vec[i];\n        for (int i = n - 1; i > 0; i--) data[i] = fOperate(data[2 * i + 0], data[2 * i + 1]);\n    }\n\n    // 添字でアクセス\n    T& operator[](int i) {\n        return data[i + n];\n    }\n};\n// LazySegTree<T, U = T> seg(N, dataId, lazyId, fOp, fMe, fAc)\n// 要素数, 要素単位元, 遅延値単位元, 要素ｘ要素, 要素ｘ作用素, 作用素ｘ作用素\n// デフォルト引数　dataId = INF, lazyId = INF, fOp : min, fAct : min, fMerge : update\n\n\nint main() {\n    init();\n    ll N, Q;\n    cin >> N >> Q;\n\n    auto f = [](ll a, ll b) { return b; };\n    ll inf = (1ll << 31) - 1;\n    LazySegTree<ll> seg(N, inf, inf, f, f, f);\n\n\n    rep(_, Q){\n        ll q, a, b, x;\n        cin >> q;\n        if(q==0){\n            cin >> a >> b >> x;\n            seg.update(a, b + 1, x);\n        }else{\n            cin >> a;\n            cout << seg.query(a, a + 1) << '\\n';\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define debug2(x, y) cerr << #x << \": \" << (x) << \" \" << #y << \": \" << y << endl;\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    // if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int sz; // 元の配列のサイズ\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : sz(a.size()), f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    assert(0 <= a && a < b && b <= sz);\n    update(a, b, x, 0, 0, N);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n};\n\nsigned main() {\n  int n, q; cin >> n >> q;\n  // Min & Update\n  SegmentTree<int, int> seg(\n    VI(n, (1LL << 31) - 1),\n    [](int x, int y) { return min(x, y); }, 1e18,\n    [](int x, int y) { return y == 1e18 ? x : y; }, 1e18,\n    [](int x, int y) { return y == 1e18 ? x : y; },\n    [](int y, int len) { return y; }\n  );\n\n  // // Sum & Add\n  // SegmentTree<int, int> seg(\n  //   VI(n, 0),\n  //   plus<int>(), 0,\n  //   plus<int>(), 0,\n  //   plus<int>(),\n  //   multiplies<int>()\n  // );\n\n  // // Min & Add\n  // SegmentTree<int, int> seg(\n  //   VI(n, 0),\n  //   [](int x, int y) { return min(x, y); }, 1e18,\n  //   plus<int>(), 0,\n  //   plus<int>(),\n  //   [](int y, int len) { return y; }\n  // );\n\n  // // Sum & Update\n  // constexpr int u1 = 1e18;\n  // SegmentTree<int, int> seg(\n  //   VI(n),\n  //   plus<int>(), 0,\n  //   [](int x, int y) { return y == u1 ? x : y; }, u1,\n  //   [](int x, int y) { return y == u1 ? x : y; },\n  //   [](int y, int len) { return y == u1 ? u1 : y * len; }\n  // );\n  \n  while (q--) {\n    int z; cin >> z;\n    if (z == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    } else {\n      int i; cin >> i;\n      cout << seg.query(i, i + 1) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct SqrtDecomposition {\n    const ll sqrtN = 512;\n    ll N, K;\n    vector<ll> data;\n    vector<ll> bucketSum, bucketAdd;\n    vector<bool> lazyFlag;\n    vector<ll> lazyUpdate;\n    SqrtDecomposition(ll n, ll x = 0LL) : N(n) {\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(K * sqrtN, x);\n        bucketSum.assign(K, x*sqrtN);\n        bucketAdd.assign(K, 0ll);\n        lazyFlag.assign(K, false);\n        lazyUpdate.assign(K, x);\n    }\n    void eval(ll k) {\n        if (lazyFlag[k]) {\n            lazyFlag[k] = false;\n            for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n                data[i] = lazyUpdate[k];\n            }\n        }\n    }\n    // [s, t)\n    void add(ll s, ll t, ll x) {\n        for (ll k = 0; k < K; ++k) {\n            ll l = k * sqrtN, r = (k + 1) * sqrtN;\n            if (r <= s || t <= l) continue;\n            if (s <= l && r <= t) {\n                bucketAdd[k] += x;\n            } else {\n                for (ll i = max(s, l); i < min(t, r); ++i) {\n                    data[i] += x;\n                    bucketSum[k] += x;\n                }\n            }\n        }\n    }\n    // [s, t)\n    void update(ll s, ll t, ll x) {\n        for (ll k = 0; k < K; ++k) {\n            ll l = k * sqrtN, r = (k + 1) * sqrtN;\n            if (r <= s || t <= l) continue;\n            if (s <= l && r <= t) {\n                bucketSum[k] = x * sqrtN;\n                bucketAdd[k] = 0ll;\n                lazyFlag[k] = true;\n                lazyUpdate[k] = x;\n            } else {\n                eval(k);\n                for (ll i = l; i < r; ++i) {\n                    data[i] = data[i] + bucketAdd[k];\n                }\n                bucketAdd[k] = 0;\n                for (ll i = max(s, l); i < min(t, r); ++i) {\n                    data[i] = x;\n                }\n                ll &sumVal = bucketSum[k] = 0ll;\n                for (ll i = l; i < r; ++i) {\n                    sumVal = sumVal + data[i];\n                }\n            }\n        }\n    }\n    // [s, t)\n    ll getSum(ll s, ll t) {\n        ll sumVal = 0;\n        for (ll k = 0; k < K; ++k) {\n            ll l = k * sqrtN, r = (k + 1) * sqrtN;\n            if (r <= s || t <= l) continue;\n            if (s <= l && r <= t) {\n                sumVal = sumVal + bucketSum[k] + bucketAdd[k] * sqrtN;\n            } else {\n                eval(k);\n                for (ll i = max(s, l); i < min(t, r); ++i) {\n                    sumVal = sumVal + data[i] + bucketAdd[k];\n                }\n            }\n        }\n        return sumVal;\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SqrtDecomposition ruq(n, (1LL<<31)-1);\n    for(int i=0; i<q; i++){\n        int c;\n        cin >> c;\n        if(c){\n            int k;\n            cin >> k;\n            cout << ruq.getSum(k,k+1) << endl;\n        }\n        else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            ruq.update(s,t+1,x);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <algorithm>\n\n#define lson l, m, o << 1\n#define rson m + 1, r, o << 1 | 1\n\nconst int N = 1e5 + 1;\n\nint mn[N << 2];\nint lazy[N << 2];\n\nvoid up(int o) {\n  mn[o] = std::min(mn[o << 1], mn[o << 1 | 1]);\n}\n\nvoid down(int o) {\n  if (lazy[o] != -1) {\n    mn[o << 1] = lazy[o];\n    mn[o << 1 | 1] = lazy[o];\n    lazy[o << 1] = lazy[o];\n    lazy[o << 1 | 1] = lazy[o];\n    lazy[o] = -1;\n  }\n}\n\nvoid build(int l, int r, int o) {\n  lazy[o] = -1;\n  if (l == r) {\n    mn[o] = INT_MAX;\n    return;\n  }\n  int m = (l + r) >> 1;\n  build(lson);\n  build(rson);\n  up(o);\n}\n\nvoid modify(int v, int L, int R, int l, int r, int o) {\n  if (L <= l && R >= r) {\n    lazy[o] = v;\n    mn[o] = v;\n    return;\n  }\n  down(o);\n  int m = (l + r) >> 1;\n  if (L <= m) modify(v, L, R, lson);\n  if (R > m) modify(v, L, R, rson);\n  up(o);\n}\n\nint query(int L, int R, int l, int r, int o) {\n  if (L <= l && R >= r) {\n    return mn[o];\n  }\n  down(o);\n  int m = (l + r) >> 1;\n  int res = INT_MAX;\n  if (L <= m) res = std::min(res, query(L, R, lson));\n  if (R > m) res = std::min(res, query(L, R, rson));\n  return res;\n}\n\nint main() {\n  int n, q;\n  while (std::cin >> n >> q) {\n    build(1, n, 1);\n    while (q --) {\n      int op;\n      std::cin >> op;\n      if (op == 0) {\n        int l, r, v;\n        std::cin >> l >> r >> v;\n        l ++;\n        r ++;\n        modify(v, l, r, 1, n, 1);\n      } else {\n        int l;\n        std::cin >> l;\n        l ++;\n        std::cout << query(l, l, 1, n, 1) << std::endl;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nstruct SD\n{\n\tint n;\n\tint lsize;\n\tint sn;\n\tvector<int> data;\n\tvector<int> lazyData;\n\n\tSD(int n) :n(n), lsize(sqrt(n)), sn(n / lsize + 1), data(n, 2147483647), lazyData(sn, -1){}\n\n\tvoid applyLazy(int k)\n\t{\n\t\tif (lazyData[k] == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = k*lsize; i < (min(n, (k + 1)*lsize)); i++)\n\t\t{\n\t\t\tdata[i] = lazyData[k];\n\t\t}\n\t\tlazeData[k] = -1;\n\t}\n\n\tvoid update(int t, int s, int v)\n\t{\n\t\tfor (int i = 0; i < sn; i++)\n\t\t{\n\t\t\tint l = i*lsize;\n\t\t\tint r = (i + 1)*lsize - 1;\n\n\t\t\tif (s < l || r < t)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (t <= l&&r <= s)\n\t\t\t{\n\t\t\t\tlazyData[i] = v;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplyLazy(i);\n\t\t\t\tfor (int j = t; j <= s; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[j] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int index)\n\t{\n\t\tint k = index / lsize;\n\t\tapplyLazy(k);\n\t\treturn data[index];\n\t}\n};\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tSD sd(n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tsd.update(s, t, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << sd.find(s) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct SegmentTree\n{\n  vector< pair< int, int > > lazy;\n  int sz, timestamp;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    lazy.assign(2 * sz - 1, {-1, 2147483647});\n    timestamp = 0;\n  }\n\n  void update(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n\n    } else if(a <= l && r <= b) {\n      lazy[k] = {timestamp, x};\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      update(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    }\n  }\n\n  void update(int a, int b, int x)\n  {\n    update(a, b, x, 0, 0, sz);\n    ++timestamp;\n  }\n\n  int query(int k)\n  {\n    k += sz - 1;\n    auto ret = lazy[k];\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      ret = max(ret, lazy[k]);\n    }\n    return (ret.second);\n  }\n};\n\nint main()\n{\n  int N, Q;\n  scanf(\"%d %d\", &N, &Q);\n  SegmentTree tree(N);\n  while(Q--) {\n    int t;\n    scanf(\"%d\", &t);\n    if(t == 0) {\n      int s, t, x;\n      scanf(\"%d %d %d\", &s, &t, &x);\n      tree.update(s, ++t, x);\n    } else {\n      int i;\n      scanf(\"%d\", &i);\n      printf(\"%d\\n\", tree.query(i));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <climits>\nusing namespace std;\n\n// 双対セグメント木 (Dual Segment Tree)\n// ref: https://kimiyuki.net/blog/2019/02/22/dual-segment-tree/\ntemplate <typename MonoidType, typename OperatorType, class SegFunc>\nstruct DualSegmentTree {\n    int n;\n    vector<MonoidType> bottom;\n    vector<OperatorType> lazy;\n    OperatorType E;\n\n    inline void build(const vector<MonoidType> &v) {\n        int m = v.size();\n        n = 1; while(n < m) n *= 2;\n        bottom = v; bottom.resize(n);\n        lazy.resize(n - 1, E);\n    }\n\n    DualSegmentTree() {}\n    DualSegmentTree(OperatorType E_, vector<MonoidType> v) : E(E_) {\n        build(v);\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        if(b <= l or r <= a) return;\n        if(a <= l and r <= b) {\n            if(k < lazy.size())\n                lazy[k] = SegFunc::lazy_update(lazy[k], x);\n            else\n                bottom[k-n+1] = SegFunc::update(bottom[k-n+1], x);\n        }\n        else {\n            int mid = (l + r) >> 1;\n            update(0, n, lazy[k], l, mid, 2*k+1);\n            update(0, n, lazy[k], mid, r, 2*k+2);\n            lazy[k] = E;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n        }\n    }\n\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    MonoidType query(int k) {\n        MonoidType res = bottom[k];\n        for(k = (k+n)>>1; k>0; k>>=1) { // 1-indexed\n            res = SegFunc::update(res, lazy[k-1]);\n        }\n        return res;\n    }\n};\n\n\nvoid DSL_2_D() {\n    using Pair = pair<int, int>;\n    struct SegFunc {\n        static Pair lazy_update(Pair a, Pair b) { return b.second ? b : a; }\n        static int update(int x, Pair p) {\n            if(p.second == 0) return x;\n            return p.first;\n        }\n    };\n\n    int N, Q; cin >> N >> Q;\n    DualSegmentTree<int, Pair, SegFunc> seg(make_pair(0, 0), vector<int>(N, INT_MAX));\n\n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int q; cin >> q;\n        if(q == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            s -= indexed, t -= indexed, t++;\n            seg.update(s, t, make_pair(x, 1));\n        }\n        if(q == 1) {\n            int x; cin >> x; x -= indexed;\n            cout << seg.query(x) << endl;\n        }\n    }\n}\n\nint main() {\n    DSL_2_D();\n    // DSL_2_E();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define INIVAL 2147483647\n\nint *a, *ts, c, s, t, v;\n\nvoid update(int k, int l, int r)\n{\n  if (r<s || t<=l) return;\n  if (s<=l && r<=t) {\n    a[k] = v;\n    ts[k] = c;\n  } else if (l<r-1) {\n    update(((k+1)<<1)-1, l, (l+r)>>1);\n    update((k+1)<<1, (l+r)>>1, r);\n  }\n}\n\nint main()\n{\n  int i, k, n, z, w, latest;\n  char *p,buf[64] = {0};\n  buf[62] = '\\n';\n  fgets(buf, 64, stdin);\n  for (n=0,p=buf; *p>' '; n=n*10+*(p++)-'0');\n  w = n>1 ? pow(2,(int)ceil(log2(n)))-1 : 1;\n  ts = (a = (int*)malloc((w+n)*2*sizeof(int))) + w+n;\n  for (i=0; i<w+n; i++)  ts[i] = -1;\n  a[0] = INIVAL;\n  ts[0] = 0;\n  c = 0;\n  while (fgets(buf, 64, stdin)) {\n    for (s=0,p=buf+2; *p>' '; s=s*10+*(p++)-'0');\n    if (*buf=='0') { // update(s, t, x)\n      for (t=0,p++; *p>' '; t=t*10+*(p++)-'0');\n      for (v=0,p++; *p>' '; v=v*10+*(p++)-'0');\n      t++;\n      update(0, 0, w+1);\n      c++;\n    } else { // find(x) x->s\n      latest = -1;\n      for (k=w+s; ; k=(k-1)>>1) {\n\tif (ts[k]>latest) {\n          latest = ts[k];\n          z = a[k];\n        }\n\tif (k==0) break;\n      }\n      if (z<10) {\n\tputc_unlocked('0'+z, stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n        for (i=62; z>0; buf[--i]='0'+z%10,z/=10);\n        fputs(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\n// ini：上限（下限）,base：元の配列,monoid：モノイド,tree：セグ木,depth：treeの深さ,\n// basesize：baseの要素数,treesize：treeの要素数,num：treesize-basesize\n// 初期値（上限とか下限）を決定\ntemplate <class num_type>\nstruct segtree {\n    int num, depth, basesize, treesize;\n    vector<num_type> base, tree, lazy;\n    // #####  monoidのiniの設定  #####\n    // 区間和のとき\n    // num_type ini = 0;\n    // 区間最小値のとき\n    num_type ini = pow(2, 31) - 1;\n    // #####  operatorのiniの設定  #####\n    // 区間加算のとき\n    // num_type ini_op = 0;\n    // 区間更新のとき\n    num_type ini_op = pow(10, 12);\n    // #####  モノイド #####\n    // 区間和のとき\n    // num_type monoid(num_type& x, num_type& y) { return x + y; }\n    // 区間最小値のとき\n    num_type monoid(num_type& x, num_type& y) { return min(x, y); }\n    // #####  lazyをスケール変換する関数 #####\n    // 区間和のとき\n    // num_type modify(int width, num_type& value) { return width * value; }\n    // 区間最小値のとき\n    num_type modify(int width, num_type& value) {\n        UNUSED(width);\n        return value;\n    }\n    // #####  yにxを作用させる関数  #####\n    // 区間加算のとき\n    // num_type operate(num_type& x, num_type& y) { return x + y; }\n    // 区間更新のとき\n    num_type operate(num_type& x, num_type& y) {\n        UNUSED(y);\n        return x;\n    }\n    // 元の配列, モノイド, 初期値\n    segtree(vector<num_type> temp) : base(temp) {\n        basesize = (int)base.size();\n        num = 1;\n        depth = 1;\n        while (num < basesize) {\n            num *= 2;\n            depth++;\n        }\n        num--;\n        treesize = num * 2 + 1;\n        tree.assign(treesize, ini);\n        lazy.assign(treesize, ini_op);\n        for (int i = num; i < num + basesize; i++) { tree[i] = base[i - num]; }\n        for (int i = num + basesize; i < treesize; i++) { tree[i] = ini; }\n        for (int i = num - 1; i > -1; i--) {\n            tree[i] = monoid(tree[2 * i + 1], tree[2 * i + 2]);\n        }\n    }\n    // modifyとoperateを同時に行う関数\n    num_type mod_op(int width, int node) {\n        if (lazy[node] != ini_op) {\n            num_type temp = modify(width, lazy[node]);\n            return operate(temp, tree[node]);\n        } else {\n            return tree[node];\n        }\n    }\n    // 半開区間[lower,upper)の最小値（とか）を探す関数\n    num_type search(int lower, int upper) {\n        num_type ret = ini, temp;\n        vector<tuple<int, int, int>> stack(1, make_tuple(0, num + 1, 0));\n        int l, r, m, node;\n        while (stack.size()) {\n            tie(l, r, node) = stack.back();\n            stack.pop_back();\n            m = (l + r) / 2;\n            if (lower <= l && r <= upper) {\n                temp = mod_op(r - l, node);\n                ret = monoid(ret, temp);\n            } else {\n                eval(l, r, node);\n                if (upper <= m) {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                } else if (m <= lower) {\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                } else {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                }\n            }\n        }\n        return ret;\n    }\n    // 葉方向に伝播させる関数\n    void eval(int& l, int& r, int& node) {\n        if (lazy[node] != ini_op) {\n            if (2 * node + 1 < treesize) {\n                if (num <= node * 2 + 1) {\n                    tree[node * 2 + 1] =\n                        operate(lazy[node], tree[node * 2 + 1]);\n                    tree[node * 2 + 2] =\n                        operate(lazy[node], tree[node * 2 + 2]);\n                } else {\n                    lazy[node * 2 + 1] =\n                        operate(lazy[node], lazy[node * 2 + 1]);\n                    lazy[node * 2 + 2] =\n                        operate(lazy[node], lazy[node * 2 + 2]);\n                }\n            }\n            num_type temp = modify(r - l, lazy[node]);\n            tree[node] = operate(temp, tree[node]);\n            lazy[node] = ini_op;\n        }\n    }\n    // base[l:r)をsに更新してセグ木全体を更新する関数\n    void update(int lower, int upper, num_type new_value) {\n        vector<tuple<int, int, int>> stack(1, make_tuple(0, num + 1, 0));\n        set<tuple<int, int>> nodeset;\n        int l, r, m, node, parent, width;\n        num_type value;\n        while (stack.size()) {\n            tie(l, r, node) = stack.back();\n            stack.pop_back();\n            m = (l + r) / 2;\n            width = r - l;\n            if (lower <= l && r <= upper) {\n                lazy[node] = operate(new_value, lazy[node]);\n                value = modify(width, new_value);\n                if (node != 0) {\n                    parent = (node - 1) / 2;\n                    nodeset.insert(make_tuple(parent, width));\n                }\n                if (width == 1) {\n                    value = modify(width, value);\n                    tree[node] = operate(value, tree[node]);\n                    lazy[node] = ini_op;\n                }\n            } else {\n                eval(l, r, node);\n                if (upper <= m) {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                } else if (m <= lower) {\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                } else {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                }\n            }\n        }\n        num_type tmp1, tmp2;\n        while (nodeset.size()) {\n            tie(node, width) = *rbegin(nodeset);\n            nodeset.erase(make_tuple(node, width));\n            tmp1 = mod_op(width, node * 2 + 1);\n            tmp2 = mod_op(width, node * 2 + 2);\n            tree[node] = monoid(tmp1, tmp2);\n            if (node != 0) {\n                nodeset.insert(make_tuple((node - 1) >> 1, width << 1));\n            }\n        }\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n, m;\n    INPUT(n, m);\n\n    ll ini = (ll)(pow(10, 12));\n    vector<ll> iniv(n, ini);\n    segtree<ll> seg(iniv);\n    ll c, x, y, z;\n    for (int i = 0; i < m; i++) {\n        INPUT(c, x);\n        if (c == 0) {\n            INPUT(y, z);\n            seg.update((int)x, (int)y + 1, z);\n        } else {\n            PRINT(seg.search((int)x, (int)x + 1));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = int_fast64_t;\n\ntemplate <class operator_monoid> class dual_segment_tree{\npublic:\n\ttypedef typename operator_monoid::underlying_type underlying_type;\n\ttypedef typename operator_monoid::value_type value_type;\n\tsize_t n;\n\tvector<underlying_type> v;\n\tvector<value_type> w;\n\tunderlying_type e = operator_monoid::unit();\n\tdual_segment_tree(size_t size){\n\t\tn = 1;\n\t\twhile(n < size) n <<= 1;\n\t\tv.resize(2*n, e);\n\t\tw.resize(size, operator_monoid::default_value());\n\t}\n\tdual_segment_tree(vector<value_type> _w){\n\t\tsize_t size = w.size();\n\t\tn = 1;\n\t\twhile(n < size) n <<= 1;\n\t\tv.resize(2*n, e);\n\t\tw(_w);\n\t}\n\tvoid range_operate(underlying_type f, size_t a, size_t b, size_t k, size_t l, size_t r){\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) v[k] = operator_monoid::compose(f, v[k]);\n\t\telse{\n\t\t\tif(2*k < v.size())\n\t\t\t\tv[2*k] = operator_monoid::compose(v[k], v[2*k]);\n\t\t\tif(2*k+1 < v.size())\n\t\t\t\tv[2*k+1] = operator_monoid::compose(v[k], v[2*k+1]);\n\t\t\tv[k] = operator_monoid::unit();\n\t\t\trange_operate(f, a, b, 2*k, l, (l+r+1)/2);\n\t\t\trange_operate(f, a, b, 2*k+1, (l+r+1)/2, r);\n\t\t}\n\t}\n\tvoid range_operate(underlying_type f, size_t a, size_t b){\n\t\trange_operate(f, a, b, 1, 0, n);\n\t}\n\tvalue_type point_get(size_t i){\n\t\trange_operate(e, i, i+1, 1, 0, n);\n\t\treturn operator_monoid::operate(v[i+n], w[i]);\n\t}\n};\nstruct assign_operator_monoid{\n\tusing underlying_type = pair<bool, Int>;\n\tusing value_type = Int;\n\tstatic underlying_type unit(){\n\t\treturn pair<bool, int>(true, 0);\n\t}\n\tstatic underlying_type compose(underlying_type l, underlying_type r){\n\t\tif(l == unit()) return r;\n\t\treturn l;\n\t}\n\tstatic value_type default_value(){\n\t\treturn (1ll<<31)-1;\n\t}\n\tstatic value_type operate(underlying_type f, value_type x){\n\t\treturn f.first ? x : f.second;\n\t}\n};\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\tInt n, q; cin >> n >> q;\n\tdual_segment_tree<assign_operator_monoid> dst(n);\n\twhile(q--){\n\t\tInt p; cin >> p;\n\t\tif(p == 0){\n\t\t\tInt s, t, x; cin >> s >> t >> x;\n\t\t\tdst.range_operate(pair<bool, Int>(false, x), s, t+1);\n\t\t}else{\n\t\t\tInt i; cin >> i;\n\t\t\tcout << dst.point_get(i) << \"\\n\";\n//\t\t\tif(i == 5)\n//\t\t\t\tfor(Int j=0; j<64; ++j)\n//\t\t\t\t\tcout << j << \" \" << (dst.v[j].first ? \"id\" : \"no\") << \" \" << dst.v[j].second << \"\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstruct RangeUpdateQuery{\n    int n, now;\n    std::vector<int> dat, time;\n\n    void init(int n_){\n        n = 1;\n        now = 0;\n        while(n < n_) n *= 2;\n        dat.resize(2 * n - 1, std::numeric_limits<int>::max());\n        time.resize(2 * n - 1, 0);\n    }\n\n    void update(int a, int b, int k, int l, int r, int x){\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b){\n            dat[k] = x;\n            time[k] = now;\n        }\n        else{\n            update(a, b, k * 2 + 1, l, (l + r) / 2, x);\n            update(a, b, k * 2 + 2, (l + r) / 2, r, x);\n        }\n    }\n\n    void update(int a, int b, int x){\n        now++;\n        update(a, b, 0, 0, n, x);\n    }\n\n    int query(int k){\n        k += n - 1;\n        int res = dat[k], recent = time[k];\n        while(k > 0) {\n            k = (k - 1) / 2;\n            if(recent < time[k]){\n                recent = time[k];\n                res = dat[k];\n            }\n        }\n        return res;\n    }\n};\n\n\nusing namespace std;\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    RangeUpdateQuery ruq;\n    ruq.init(n);\n    while(q--){\n        int com;\n        cin >> com;\n        if(com){\n            int i;\n            cin >> i;\n            cout << ruq.query(i) << \"\\n\";\n        }else{\n            int s, t, x;\n            cin >> s >> t >> x;\n            ruq.update(s, t + 1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct OwnNode\n{\n\tint num;\n\tint l, r;\n\tint left, right;\n\n\tOwnNode(int l,int r):l(l),r(r),num(2147483647),left(-1),right(-1){}\n};\n\nvector<OwnNode> nodes;\n\nint Build(int l, int r)\n{\n\tint id = nodes.size();\n\tnodes.push_back(OwnNode(l, r));\n\tint m = (l + r) / 2;\n\tif (l + 1 != r)\n\t{\n\t\tnodes[id].left = Build(l, m);\n\t\tnodes[id].right = Build(m, r);\n\t}\n\treturn id;\n}\n\nvoid update(int id, int s, int t, int v)\n{\n\tif (t <= nodes[id].l || nodes[id].r <= s)\n\t{\n\t\treturn;\n\t}\n\tif (s <= nodes[id].l&&nodes[id].r <= t)\n\t{\n\t\tnodes[id].num = v;\n\t\treturn;\n\t}\n\tint m = (nodes[id].l + nodes[id].r) / 2;\n\tif (nodes[id].right != -1)\n\t{\n\t\tif (nodes[id].num >= 0)\n\t\t{\n\t\t\tnodes[nodes[id].right].num = nodes[id].num;\n\t\t}\n\t\tif (m < t)\n\t\t{\n\t\t\tupdate(nodes[id].right, s, t, v);\n\t\t}\n\t}\n\tif (nodes[id].left != -1)\n\t{\n\t\tif (nodes[id].num >= 0)\n\t\t{\n\t\t\tnodes[nodes[id].left].num = nodes[id].num;\n\t\t}\n\t\tif (s < m)\n\t\t{\n\t\t\tupdate(nodes[id].left, s, t, v);\n\t\t}\n\t}\n\tnodes[id].num = -1;\n}\n\nint find(int id,int s, int t)\n{\n\tif (t <= nodes[id].l || nodes[id].r <= s)\n\t{\n\t\treturn 2147483647;\n\t}\n\tif (nodes[id].num >= 0)\n\t{\n\t\treturn nodes[id].num;\n\t}\n\tint mini = 2147483647;\n\tint m = (nodes[id].l + nodes[id].r) / 2;\n\tif (nodes[id].right != -1)\n\t{\n\t\tif (m < t)\n\t\t{\n\t\t\tmini = min(mini, find(nodes[id].right,s, t));\n\t\t}\n\t}\n\tif (nodes[id].left != -1)\n\t{\n\t\tif (s < m)\n\t\t{\n\t\t\tmini = min(mini, find(nodes[id].left, s, t));\n\t\t}\n\t}\n\treturn mini;\n}\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tBuild(0, n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tupdate(0, s, t + 1, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << find(0, s, s + 1) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\nconst int MAX = (1LL << 31) - 1LL;\nconst int MAX_N = (1 << 17)+1;\nstruct RUQ{\n\tint n;\n\tint datx[MAX_N*2 - 1];\n\tint datc[MAX_N*2 - 1];\n\t//n?????????????????¨?????¨????????????\n\tvoid init(int n_){\n\t\tn = 1;\n\t\twhile(n<n_)n*=2;//n????????????????????§????????¨update????????°???\n\t\tREP(i,2*n-1)datx[i] = MAX;\n\t\tREP(i,2*n-1)datc[i] = -1;\n\t}\n\t//[a,b)?????????x????????´(c)\n\tvoid update(int a,int b,int x,int c,int k,int l,int r){\n\t\tif(r <= a || b <= l)return;\n\t\tif(a <= l && b >= r){\n\t\t\tdatx[k] = x;\n\t\t\tdatc[k] = c;\n\t\t}else{\n\t\t\tupdate(a,b,x,c,k*2+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,c,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\t//a[i]?????????\n\tint query(int i){\n\t\ti += n-1;\n\t\tint c = -1;\n\t\tint x = MAX;\n\t\twhile(true){\n\t\t\tif(datc[i] > c){\n\t\t\t\tx = datx[i];\n\t\t\t\tc = datc[i];\n\t\t\t}\n\t\t\tif(i == 0)break;//?????????i??¨i==0????§???????????????????\n\t\t\ti = (i-1)/2;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint n,q;\n\tcin >> n >> q;\n\tRUQ ruq;ruq.init(n);\n\tREP(i,q){\n\t\tint q;\n\t\tcin >> q;\n\t\tif(q){\n\t\t\tint j;cin >>j;\n\t\t\tcout << ruq.query(j) << endl;\n\t\t}else{\n\t\t\tint a,b,x;\n\t\t\tcin >> a>>b>>x;\n\t\t\tb++;\n\t\t\truq.update(a,b,x,i,0,0,ruq.n);\n\t\t}\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node\n{\n\tint num,l,r,ls,rs,lazy;\n\tnode(int _l,int _r)\n\t{\n\t\tnum=INT_MAX;\n\t\tl=_l;\n\t\tr=_r;\n\t}\n};\n\nvector<node> T;\n\nint make(int l,int r)\n{\n\tint id=T.size();\n\tT.push_back(node(l,r));\n\tT[id].ls=(l+1==r?-1:make(l,(l+r)/2));\n\tT[id].rs=(l+1==r?-1:make((l+r)/2,r));\n\treturn id;\n}\n\nvoid update(int id,int l,int r,int t)\n{\n\tif(l==r||T[id].l>=r||T[id].r<=l)\n\t\treturn ;\n\tif(T[id].l>=l&&T[id].r<=r)\n\t{\n\t\tT[id].num=t;\n\t\treturn ;\n\t}\n\tint mid=(T[id].l+T[id].r)>>1;\n\tif(T[id].num>=0)\n\t\tT[T[id].ls].num=T[T[id].rs].num=T[id].num;\n\tif(l<mid)\n\t\tupdate(T[id].ls,l,r,t);\n\tif(r>mid)\n\t\tupdate(T[id].rs,l,r,t);\n\tT[id].num=-1;\n}\n\nint getmin(int id,int l,int r)\n{\n\tif(l==r||T[id].l>=r||T[id].r<=l)\n\t\treturn INT_MAX; \n\tif(T[id].num>=0)\n\t\treturn T[id].num;\n\tint mid=(T[id].l+T[id].r)>>1,mi=INT_MAX;\n\tif(l<mid)\n\t\tmi=min(mi,getmin(T[id].ls,l,r));\n\tif(r>mid)\n\t\tmi=min(mi,getmin(T[id].rs,l,r));\n\treturn mi;\n}\n\nint main()\n{\n\tT.reserve(200100);\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tmake(0,n);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint com;\n\t\tscanf(\"%d\",&com);\n\t\tif(com==0)\n\t\t{\n\t\t\tint s,t,x;\n\t\t\tscanf(\"%d%d%d\",&s,&t,&x);\n\t\t\tupdate(0,s,t+1,x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s;\n\t\t\tscanf(\"%d\",&s);\n\t\t\tprintf(\"%d\\n\",getmin(0,s,s+1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\ntemplate<class T>\nclass sg_tree : public vector<T>{\nprivate:\n    lli n;\n    T default_value;\n    void _query(lli a,lli b,T x,lli k,lli l,lli r){\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) (*this)[k] = x;\n        else {\n            _query(a,b,x,k*2+1,l,(l+r)/2);\n            _query(a,b,x,k*2+2,(l+r)/2,r);\n            return;\n        }\n    }\npublic:\n    sg_tree():vector<T>(){\n\n    }\n    sg_tree(lli n,T d = -1):vector<T>(n*4,d){\n\t\tthis->n = 1;\n        while(n > this->n) this->n <<= 1;\n        this->default_value = d;\n    }\n    T update(lli i){\n        i += n - 1;\n        T ret = (*this)[i];\n        while(i > 0){\n            i = (i - 1) / 2;\n            ret = max(ret,(*this)[i]);\n        }\n        return ret;\n    }\n    void query(lli a,lli b,lli x){\n        _query(a,b,x,0,0,n);\n    }\n    T func(T a,T b){\n        return min(a,b);\n    }\n};\n\nlli n,q;\nlli c,s,t,x;\nlli k = 0;\nvll b;\n\nsg_tree<lli> sg;\n\nint main(){\n    cin >> n >> q;\n    sg = sg_tree<lli> (n);\n    for(lli i = 0;i < q;i++){\n        cin >> c;\n        if(c){\n            cin >> x;\n            lli t;\n            if((t = sg.update(x)) < 0) cout << ((1 << 31) - 1) << endl;\n            else cout << b[t] << endl;\n        }else{\n            cin >> s >> t >> x;\n            b.push_back(x);\n            sg.query(s,t+1,k);\n            k++;\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 1000\n \nint bucket[MAX/B][B];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n    int f1 = 1, f2 = 1;\n    while(a <= b && a%B != 0){\n        if(f1 && data[a/B] != -1){\n            for(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n            f1 = 0;data[a/B] = -1;\n        }\n        bucket[a/B][a%B] = x;\n        a++;\n    }\n    while(a <= b && b%B != 99){\n        if(f2 && data[b/B] != -1){\n            for(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n            f2 = 0;data[b/B] = -1;\n        }\n        bucket[b/B][b%B] = x;\n        b--;\n    }\n    while(a < b){\n        data[a/B] = x;\n        a += B;\n    }\n}\n \nint find(int x){\n    if(data[x/B] != -1){\n        for(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n        data[x/B] = -1;\n    }\n    return bucket[x/B][x%B];\n}\n \nint main(){\n    int n, q, c, s, t, x, ans;\n    scanf(\"%d%d\", &n, &q);\n    fill(data, data+MAX/B, -1);\n    fill((int*)bucket, (int*)(bucket+MAX/B), INF);\n    while(q--){\n        scanf(\"%d\", &c);\n        if(!c){\n            scanf(\"%d%d%d\", &s, &t, &x);\n            update(s, t, x);\n        }else{\n            scanf(\"%d\", &x);\n            ans = find(x);\n            printf(\"%d\\n\", ans);\n        }\n    }\n    //rep(i,n)printf(\"%d \", bucket[0][i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass RUQSegmentTree {\n\tconst int n;\n\tconst int flag = -1;\n\tconst int id = 1;\n\tvector<int> data, data2;\n\tint size(int n) {\n\t\tint res = 1;\n\t\twhile (res < n) res <<= 1;\n\t\treturn res;\n\t}\n\tvoid sub(int l, int r, int node, int lb, int ub, int val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (data[node] == val) return;\n\t\tif (l <= lb && ub <= r) {\n\t\t\tdata[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint left = node * 2, right = node * 2 + 1;\n\t\tif (data[node] != flag) {\n\t\t\tdata[left] = data[node];\n\t\t\tdata[right] = data[node];\n\t\t}\n\t\tdata[node] = flag;\n\t\tsub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tsub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata2[node] = min(data[left] == flag ? data2[left] : data[left], data[right] == flag ? data2[right] : data[right]);\n\t}\npublic:\n\tRUQSegmentTree(int n_) :\n\t\tn(size(n_)), data(n * 2, INT_MAX), data2(n * 2, INT_MAX) {}\n\tvoid update(int l, int r, int val) {\n\t\tsub(l, r + 1, 1, 0, n, val);\n\t}\n\tint find(int i) {\n\t\ti += n;\n\t\tint res = data[i];\n\t\twhile (i >>= 1) {\n\t\t\tif (data[i] != flag) res = data[i];\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint n, q, b, i, s, t, x;\n\tcin >> n >> q;\n\tRUQSegmentTree ruq(n);\n\twhile (q--) {\n\t\tcin >> b;\n\t\tif (b) {\n\t\t\tcin >> i;\n\t\t\tcout << ruq.find(i) << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tDSL: domain-specific language\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/5/2017\n\tTLE: 17/22 10^10 must change the data structure--> binary tree\n\tupdate the data: set the priority\n\tWA 2/22\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 131072 //100000\n#define MAXVAL ((long int) ((unsigned long) (1 << 31) - 1))\ntypedef struct Node{\n\tint val;\n\tint priority;\n}node;\nvoid find(int i);\nvoid add(int s,int t, int x,int i);\nnode array[2*N+100];      //the size of array, for present the tree\n//BEGIN FROM 1;\nint main(){\n\tint n = 0, q = 0;\n\tint a,b,c;\n\t//FILE *fp;\n\t//fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\t\n\t//how to calculate the beginning index (the last layer of the tree)\n\tint count = 0;\n\tint temp = n;\n\twhile(n!=1){\n\t\tn = n/2;\n\t\tcount++;  \n\t}\n\tif(pow(2,count)!=temp) count++;\n\t//printf(\"count:%d\",count);\n\tint B = pow(2,count)-1;\n\tfor(int i = 0; i<=B;i++){ //special case forn==1, need i = 0;\n\t\tarray[i].val =  MAXVAL;\n\t\tarray[i].priority = 0;\n\t}\n\tfor(int i = 1; i<=n; i++){\n\t\tarray[i+B].val = MAXVAL;\t//e.g.begin from 8 (the last element of previous layer is 7)\n\t\tarray[i].priority = 0;\n\t}//printf(\"%d\\n\", array[B].val);\n\tB = B+1;\n\tfor(int i = 1; i <= q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tadd(a+B,b+B,c,i);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfind(a+B);\n\t\t}\n\t}\n\treturn 0;\n}\n//add elements\n//s means: left pointer\n//t means : right pointer\nvoid add(int s,int t, int x,int i){\n\t//signle node\n\tif(s==t) {\n\t\tarray[s].val = x;\n\t\tarray[s].priority = i;\n\t\treturn;\n\t}\n\t//range update\n\t//check the left pointer\n\twhile(s<t){\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t\tif(s%2==0){ //left child, level up\n\t\t\ts = s/2;\n\t\t}else{ //right child: mark and level up + 1\n\t\t\tarray[s].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\ts = s/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tif(t%2==0){//left child: \n\t\t\tarray[t].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\tt = t/2;\n\t\t\tt--;\n\t\t} else { //right child\n\t\t\tt/= 2; \t\n\t\t}\n\t\tif(s==t) {\n\t\t\tarray[s].val =x;\n\t\t\tarray[s].priority = i;\n\t\t}// works for 1-4,1-3, 1-5\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t}\n\t\n\t//test for \n\t/*for(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", i);\n\t}printf(\"\\n\");\n\tfor(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", array[i]);\n\t}*/\n\t\n}\n\nvoid find(int i) {//the index of the tree\n\tint res = array[i].val;\n\tint max = 0; //the priority\n\t//printf(\"%d\\n\", array[i].val);\n\twhile(i>=1){\n\t\tif(array[i].priority>max){\n\t\t\tres=array[i].val;\n\t\t\t//printf(\"array:%d\",res);\n\t\t\tmax = array[i].priority;\t\n\t\t}\n\t\ti = i/2;\n\t}\n\t\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define dom 998244353\n#define all(c) begin(c),end(c)\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n#define long long long\n#define List vector\n#define var auto\n#define Count size()\n#define Length size()\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\ntemplate <typename T, typename U>\nstruct LazySegTree {\n\tint n;\n\tfunction<T(T, T)> calc;\n\tfunction<T(T, U, int)> apply;\n\tfunction<U(U, U)> merge;\n\tT ex;\n\tvector<T> data;\n\tvector<U> lazy;\n\tvector<bool> is_lazy;\n\tLazySegTree(int n_, function<T(T, T)> calc,\n\t\tfunction<T(T, U, int)> apply,\n\t\tfunction<U(U, U)> merge,\n\t\tT ex){\n\t\tthis->calc = calc;\n\t\tthis->apply = apply;\n\t\tthis->merge = merge;\n\t\tthis->ex = ex;\t\n\t\tinit(n_);\n\t}\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\t\tdata.clear();\n\t\tdata.resize(2 * n - 1, ex);\n\t\tlazy.clear();\n\t\tlazy.resize(2 * n - 1, U());\n\t\tis_lazy.clear();\n\t\tis_lazy.resize(2 * n - 1, false);\n\t}\n\tvoid assign_lazy(int k, U x)\n\t{\n\t\tif (k >= (int)lazy.size()) return;\n\t\tif (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n\t\telse\n\t\t{\n\t\t\tis_lazy[k] = true;\n\t\t\tlazy[k] = x;\n\t\t}\n\t}\n\tvoid eval(int len, int k) {\n\t\tif (!is_lazy[k]) return;\n\t\tassign_lazy(k * 2 + 1, lazy[k]);\n\t\tassign_lazy(k * 2 + 2, lazy[k]);\n\t\tdata[k] = apply(data[k], lazy[k], len);\n\t\tis_lazy[k] = false;\n\t}\n\tT update(int a, int b, U x, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\tif (r <= a || b <= l) return data[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tassign_lazy(k, x);\n\t\t\treturn apply(data[k], lazy[k], r - l);\n\t\t}\n\t\treturn data[k] = calc(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n\t\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t// [a, b]に対する閉区間更新 0-indexed\n\tT update(int a, int b, U x) {\n\t\tb++;\n\t\treturn update(a, b, x, 0, 0, n);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\tif (r <= a || b <= l) return ex;\n\t\tif (a <= l && r <= b) return data[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn calc(vl, vr);\n\t}\n\t// return node [a,b] 閉区間クエリ 0-indexed\n\tT query(int a, int b) {\n\t\tb++;\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\t//デバッグ用\n\tvector<T> items()\n\t{\n\t\tvector<T> ret(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tret[i] = query(i, i);\n\t\t}\n\t\treturn ret;\n\t}\n};\n//呼び出し方\n//区間Add区間Sum(1点取得)\n//LazySegTree<long, long> raq_rsq(N,\n//\t[](long a, long b) { return a + b; },\n//\t[](long a, long b, int len) { return a + b * len; },\n//\t[](long a, long b) { return a + b; },\n//\t0);\n\n//区間Add区間Min\n// 要素は一点の値だからlenを掛けない 最小値だからexはINF\n//LazySegTree<long, long> raq_rmq(N,\n//\t[](long a, long b) { return min(a, b); },\n//\t[](long a, long b, int len) { return a + b; },\n//\t[](long a, long b) { return a + b; },\n//\tINT_MAX);\n// 0に初期化する場合\n//raq_rmq.update(0, N - 1, -INT_MAX);\n\n//区間変更区間Min\n//LazySegTree<int, int> ruq_rmq(N,\n//\t[](int a, int b) { return min(a, b); },\n//\t[](int a, int b, int len) {return b; },\n//\t[](int a, int b) {return b; },\n//\tINT_MAX);\n\n//区間変更区間Sum(1点取得)\n//LazySegTree<long, long> ruq_rsq(N,\n//\t[](long a, long b) { return a + b; },\n//\t[](long a, long b, int len) { return b * len; },\n//\t[](long a, long b) { return b; },\n//\t0);\n\nvoid solve()\n{\n\tint N, Q;\n\tcin >> N >> Q;\n\n\tLazySegTree<long, long> ruq_rsq(N,\n\t[](long a, long b) { return a + b; },\n\t[](long a, long b, int len) { return b * len; },\n\t[](long a, long b) { return b; },\n\t0);\n\truq_rsq.update(0, N - 1, INT_MAX);\n\n\trep(i, Q)\n\t{\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0)\n\t\t{\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\truq_rsq.update(s, t, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s, t;\n\t\t\tcin >> s;\n\t\t\tcout << ruq_rsq.query(s, s) << endl;\n\t\t}\n\t}\n\t//auto p = ruq_rsq.items();\n\t//rep(i, p.size())\n\t//{\n\t//\tcout << p[i] << \" \";\n\t//}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int A[100000];\n    int i, s, t, x, n, q, ask;\n\n    for(i = 0; i < 100000; i++) A[i] = INT_MAX;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n\t\tif(ask){\n            cin >> i;\n            printf(\"%d\\n\", A[i]);\n\t\t}else{\n            cin >> s >> t >> x;\n\t\t\tfor(i = s; i <= t; i++) A[i] = x;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nll pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b == 1) {\n\t\treturn a;\n\t}\n\tll ans = pow(a, b / 2);\n\tans *= ans;\n\tans *= b % 2 == 1 ? a : 1;\n\treturn ans;\n}\n\nnamespace SOLVE {\n\tVI A;\n\n\tstruct SegTree {\n\t\tstatic const int maxn = 100000;\n\n\t\tstruct node {\n\t\t\tint l, r, value, lazy;\n\t\t};\n\n\t\tnode no[maxn * 4];\n\n\t\tvoid push_up(int ind) {\n\t\t\t// shouldnt push up\n\t\t}\n\t\tvoid push_down(int ind) {\n\t\t\tif (no[ind].lazy == 1) {\n\t\t\t\tno[ind * 2].value = no[ind].value;\n\t\t\t\tno[ind * 2 + 1].value = no[ind].value;\n\t\t\t\tno[ind].lazy = 0;\n\t\t\t\tno[2 * ind].lazy = 1;\n\t\t\t\tno[2 * ind + 1].lazy = 1;\n\t\t\t}\n\t\t}\n\t\tvoid build(int l, int r, int ind) {\n\t\t\tno[ind].l = l;\n\t\t\tno[ind].r = r;\n\t\t\tno[ind].lazy = 0;\n\n\t\t\tif (l == r) {\n\t\t\t\tno[ind].value = A[l];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tbuild(l, mid, lson);\n\t\t\t\tbuild(mid + 1, r, rson);\n\t\t\t\tpush_up(ind);\n\t\t\t}\n\t\t}\n\t\tvoid update(int l, int r, int ind, int val) {\n\t\t\tif (l > no[ind].r || r < no[ind].l)return;\n\t\t\tif (l <= no[ind].l && no[ind].r <= r) {\n\t\t\t\tno[ind].value = val;\n\t\t\t\tif (l != r) {\n\t\t\t\t\tno[ind].lazy = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpush_down(ind);\n\t\t\t\tupdate(l, r, lson, val);\n\t\t\t\tupdate(l, r, rson, val);\n\t\t\t\tpush_up(ind);\n\t\t\t}\n\t\t}\n\n\t\tvoid query(int x, int ind, int& ans) {\n\t\t\tif (no[ind].lazy == 1) {\n\t\t\t\tans = no[ind].value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (x == no[ind].l && no[ind].r == x) {\n\t\t\t\tans = no[ind].value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint mid = (no[ind].l + no[ind].r) / 2;\n\t\t\t\tif (x <= mid) {\n\t\t\t\t\tquery(x, lson, ans);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquery(x, rson, ans);\n\t\t\t\t}\n\t\t\t\tpush_up(ind);\n\n\t\t\t}\n\t\t}\n\t\tvoid show(int m) {\n\t\t\tREP(i, 0, m) {\n\t\t\t\tnode n = no[i];\n\t\t\t\tcout << \"show \" << n.l << ' ' << n.r << ' ' << n.value << endl;\n\t\t\t}\n\t\t}\n\t};\n\n\tSegTree tree;\n\n\tvoid main() {\n\t\tint n, q, a, b, c, d, ans;\n\t\tcin >> n >> q;\n\n\t\tA.resize(n + 5, pow(2,31)-1);\n\t\ttree.build(0, n-1, 1);\n\n\t\tREP(i, 0, q) {\n\t\t\tcin >> a;\n\t\t\tif (a == 0) {\n\t\t\t\tcin >> b >> c >> d;\n\t\t\t\ttree.update(b, c, 1, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> b;\n\t\t\t\ttree.query(b, 1, ans);\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<typename T>\nclass RangeUpdateQuery {\npublic:\n    explicit RangeUpdateQuery(int n, T def) : N(calcN_(n)) {\n        mVal.assign(2*N+1, make_pair(-1, def));\n    }\n    void update(int l, int r, T value, int ts){\n        updateImpl_(l, r, make_pair(ts, value), 0, 0, N);\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            res = max(mVal[i], res);\n        }\n        return res.second;\n    }\n    void debug() { for(auto t: mVal) cout << t.first<<\",\"<<t.second << \" \"; cout << endl; }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    void updateImpl_(int l, int r, pair<int, T> value, int idx, int rangeL, int rangeR){\n        if(r <= rangeL || rangeR <= l) return;\n        if(l <= rangeL && rangeR <= r){\n            mVal[idx] = value;\n        } else {\n            int rangeM = (rangeL+rangeR)/2;\n            updateImpl_(l, r, value, 2*idx+1, rangeL, rangeM);\n            updateImpl_(l, r, value, 2*idx+2, rangeM, rangeR);\n        }\n    }\n    const int N;\n    vector<pair<int,T>> mVal; \n};\n\nint main(){\n    int n, q;\n    while(cin >> n >> q){\n        const int INF = 0x7FFFFFFF;\n        RangeUpdateQuery<int> ruq(n, INF);\n        for(int i=0;i<q;i++){\n            int c; cin >> c;\n            if(c == 0){\n                int s, t, x; cin >> s >> t >> x;\n                ruq.update(s, t+1, x, i);\n            } else {\n                int p; cin >> p;\n                cout << ruq.get(p) << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[420000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\n//[l,r)???x?????´??°??????.[bottom,top),node??????????????????\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\treturn;\n\t}\n\t\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\n\t//-INF???????????????????????¨?????????????????????????????¨?????¨???\n\tif (m[node] != -INF) {\n\t\tm[2 * node] = m[node];\n\t\tm[2 * node + 1] = m[node];\n\t\tm[node] = -INF;\n\t}\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{ \n\tcin >> n >> q;\n\n\tn=init(n);\n\n\tint a, s, t, x, k;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> k;\n\t\t\tcout << find(k) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = (int)((1ll << 31) - 1);\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\nnamespace Union_Find{\n    const int N = 1e4 + 7;\n    int f[N], n, m;\n\n    void init(int n){\n        for (int i = 0; i <= n; i++) f[i] = i;\n    }\n\n    int find_fa(int x){ return x == f[x] ? x : f[x] = find_fa(f[x]); }\n\n    void unite(int x, int y){\n        int rx = find_fa(x), ry = find_fa(y);\n        if (rx != ry) f[max(rx, ry)] = min(rx, ry);\n    }\n}\n\nnamespace Segment_Tree1{ // Interval minimum val with single point change\n    const int N = 1e5 + 7;\n    struct node{\n        int l, r, val, mn;\n    };\n    node T[N << 2];\n    int n, m;\n\n    #define ls(x) (x << 1)\n    #define rs(x) (x<<1|1)\n\n    void build(int rt, int l, int r){\n        T[rt].l = l, T[rt].r = r, T[rt].val = INF;\n        if (r <= l) return;\n        int mid = (l + r) >> 1;\n        build(ls(rt), l, mid);\n        build(rs(rt), mid + 1, r);\n    }\n\n    void pushup(int rt){ T[rt].val = min(T[ls(rt)].val, T[rs(rt)].val); }\n\n    void update(int rt, int l, int r, int val){\n        if (T[rt].l > r || T[rt].r < l) return;\n        if (l <= T[rt].l && T[rt].r <= r) { T[rt].val = val; return; }\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        if (l <= mid) update(ls(rt), l, r, val);\n        if (r > mid) update(rs(rt), l, r, val);\n        pushup(rt);\n    }\n\n    int query(int rt, int l, int r){\n        if (T[rt].l > r || T[rt].r < l) return INF;\n        if (l <= T[rt].l && T[rt].r <= r) return T[rt].val;\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        int ret = INF;\n        if (l <= mid) ret = min(ret, query(ls(rt), l, r));\n        if (r > mid) ret = min(ret, query(rs(rt), l, r));\n        return ret;\n    }\n}\n\nnamespace Segment_Tree2{ //single point change, with interval sum query \n    const int N = 1e5 + 7;\n    struct node{\n        int l, r;\n        LL sum;\n    };\n    node T[N << 2];\n    int n, m;\n\n    #define ls(x) (x << 1)\n    #define rs(x) (x<<1|1)\n\n    void build(int rt, int l, int r){\n        T[rt].l = l, T[rt].r = r, T[rt].sum = 0;\n        if (r <= l) return;\n        int mid = (l + r) >> 1;\n        build(ls(rt), l, mid);\n        build(rs(rt), mid + 1, r);\n    }\n\n    void pushup(int rt){ T[rt].sum = T[ls(rt)].sum + T[rs(rt)].sum; }\n\n    void update(int rt, int l, int r, int val){\n        if (T[rt].l > r || T[rt].r < l) return;\n        if (l <= T[rt].l && T[rt].r <= r) { T[rt].sum += val; return; }\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        if (l <= mid) update(ls(rt), l, r, val);\n        if (r > mid) update(rs(rt), l, r, val);\n        pushup(rt);\n    }\n\n    LL query(int rt, int l, int r){\n        if (T[rt].l > r || T[rt].r < l) return INF;\n        if (l <= T[rt].l && T[rt].r <= r) return T[rt].sum;\n        int mid = (T[rt].l + T[rt].r) >> 1;\n        LL ret = 0;\n        if (l <= mid) ret += query(ls(rt), l, r);\n        if (r > mid) ret += query(rs(rt), l, r);\n        return ret;\n    }\n\n    int main(){\n        scanf(\"%d%d\", &n, &m);\n        build(1, 1, n);\n        for (int i = 0; i < m; i++){\n            int op, x, y;\n            scanf(\"%d\", &op);\n            if (op){\n                scanf(\"%d%d\", &x, &y); \n                printf(\"%lld\\n\", query(1, x, y));\n            }\n            else{\n                scanf(\"%d%d\", &x, &y);\n                update(1, x, x, y);\n            }\n        }\n        return 0;\n    }\n}\n\nconst int N = 1e5 + 7;\nstruct node{\n    int l, r, val, tag;\n};\nnode T[N << 2];\nint n, m;\n\n#define ls(x) (x << 1)\n#define rs(x) (x<<1|1)\n\nvoid build(int rt, int l, int r){\n    T[rt].l = l, T[rt].r = r, T[rt].val = INF, T[rt].tag = 1;\n    if (r <= l) return;\n    int mid = (l + r) >> 1;\n    build(ls(rt), l, mid);\n    build(rs(rt), mid + 1, r);\n}\n\nvoid push_down(int rt){ \n    if (T[rt].tag == 1) {\n        T[ls(rt)].val = T[rs(rt)].val = T[rt].val; \n        T[rt].tag = -1;\n    }\n}\n\nvoid update(int rt, int l, int r, int val){\n    if (T[rt].l > r || T[rt].r < l) return;\n    if (l <= T[rt].l && T[rt].r <= r) { T[rt].val = val; T[rt].tag = 1; return; }\n    int mid = (T[rt].l + T[rt].r) >> 1;\n    push_down(rt);\n    if (l <= mid) update(ls(rt), l, r, val);\n    if (r > mid) update(rs(rt), l, r, val);\n}\n\nint query(int rt, int l, int r){\n    if (T[rt].l > r || T[rt].r < l) return INF;\n    if (l <= T[rt].l && T[rt].r <= r) return T[rt].val;\n    int mid = (T[rt].l + T[rt].r) >> 1;\n    push_down(rt);\n    if (l <= mid) return query(ls(rt), l, r);\n    if (r > mid) return query(rs(rt), l, r);\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    build(1, 1, n);\n    for (int i = 0; i < m; i++){\n        int op, x, y, val;\n        scanf(\"%d\", &op);\n        if (op){\n            scanf(\"%d\", &x); x++;\n            printf(\"%d\\n\", query(1, x, x));\n        }\n        else{\n            scanf(\"%d%d%d\", &x, &y, &val); x++, y++;\n            update(1, x, y, val);\n        }\n    }   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF 2147483647\nvector<pair<int,int> > a(300000,pair<int,int>(INF,0));\nint n,si;\nint find(int);\nvoid update(int,int,int,int,int,int,int);\n\nint main(){\n  int q,f;\n  si=1;\n  cin >> n >> q;\n  for(int i=0;;i++){\n    si*=2;\n    if(si>=n)break;\n  }\n  for(int i=0;i<q;i++){\n    cin >> f;\n    if(f==1){\n      int po,dat;\n      cin >> po;\n      dat=find(po);\n      cout << dat << endl;      \n    }\n    else{\n      int st,go,d;\n      cin >> st >> go>>d;\n      update(st,go+1,0,0,si,d,i+1);\n    }\n  }\n  return 0;\n}\nint find(int p){\n  int ko=si-1+p;\n  pair<int,int> ma=a[ko];\n  while(ko>0){\n    ko=(ko-1)/2;\n    if(ma.second<a[ko].second){\n      ma=a[ko];\n    }\n  }\n  return ma.first;\n}\n\nvoid update (int s,int t,int k,int l,int r,int d,int ti){\n  int m=(l+r)/2;\n  if(s<=l&&r<=t){\n    a[k].first=d;\n    a[k].second=ti;\n    return;\n  }\n  else if(r<=s||t<=l)return;\n  \n  else{ \n    update(s,t,k*2+1,l,m,d,ti);\n    update(s,t,k*2+2,m,r,d,ti);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, double> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nclass LazySegTree {\npublic:\n\tint n;\n\tvector<ll> dat;\n\tvector<ll> lazy;\n\tvector<int> depth;\n\tvector<int> width;\n\tconst int NIL = -INF;\n\n\tll def = INT32_MAX;\n\tll operation(int a, int b) {\n\t\treturn min(a, b);\n\t}\n\n\t// ????????????_n????????????????´???°???\n\tLazySegTree(int _n) {\n\t\tn = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, def);\n\t\tlazy = vector<ll>(2 * n - 1, NIL);\n\t\tdepth = vector<int>(2 * n - 1);\n\t\twidth = vector<int>(2 * n - 1);\n\t\tdepth[0] = 0;\n\t\twidth[0] = n;\n\t\trepl(i, 1, 2 * n - 1) {\n\t\t\tdepth[i] = depth[(i - 1) / 2] + 1;\n\t\t\twidth[i] = width[(i - 1) / 2] / 2;\n\t\t}\n\t}\n\n\t// ????????????????????????k???Lazy???v????????????\n\tvoid setLazy(int k, int v) {\n\t\t//cout << k << \", \" << v << endl;\n\t\t// ???????????¶???\n\t\tlazy[k] = v;\n\t\t// ??????\n\t\t//lazy[k] += v;\n\n\t\t// min,max?????´???\n\t\tdat[k] = v;\n\n\t\t// sum?????´???\n\t\t//dat[k] = lazy[k] * width[k];\n\t}\n\n\tvoid push(int k) {\n\t\t//cout << \"push: \" << k << endl;\n\t\tif (lazy[k] == NIL)return;\n\t\tsetLazy(k * 2 + 1, lazy[k]);\n\t\tsetLazy(k * 2 + 2, lazy[k]);\n\t\tlazy[k] = NIL;\n\t}\n\n\t// ??????[a,b)???v??§???????????¶???\n\tvoid fill(int a, int b, int v, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\t//cout << k << \", \" << a << \", \" << b << \", \" << l << \", \" << r << endl;\n\t\tif (r <= a || b <= l)return;  // ???????????????\n\t\tif (a <= l && r <= b) {   // a,l,r,b????????§?????¨???????????????\n\t\t\tsetLazy(k, v);\n\t\t\treturn;\n\t\t}\n\n\t\tpush(k);\n\n\t\tfill(a, b, v, 2 * k + 1, l, (l + r) / 2);    // ?????????\n\t\tfill(a, b, v, 2 * k + 2, (l + r) / 2, r);    // ?????????\n\t}\n\n\t// ??´???i(0-indexed)???x????¶????\n\tvoid add(int i, ll x) {\n\t\ti += n - 1;\n\t\tdat[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// ??´???i(0-indexed)?????????x?????´??°\n\tvoid change(int i, ll x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = operation(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// ??????[a,b)?????????????????????k=[l,r)????????????????????????\n\tll _query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return def;  // ???????????????\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,b????????§?????¨???????????????\n\n\t\tpush(k);\n\n\t\tll c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2);    // ?????????\n\t\tll c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r);    // ?????????\n\t\treturn operation(c1, c2);\n\t}\n\n\t// ?????¨?????¨???_query()???????????????\n\tll query(int a, int b) {\n\t\treturn _query(a, b, 0, 0, n);\n\t}\n\n\tll &operator[](int i) {\n\t\t//return dat[i + n - 1];\n\t\tll ans = query(i, i + 1);\n\t\treturn ans;\n\t}\n};\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\tLazySegTree seg(N+1);\n\trep(q, Q) {\n\t\tint c;\n\t\tcin >> c;\n\t\tif (c == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.fill(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << seg.query(i, i + 1) << endl;\n\t\t}\n\t\t/*\n\t\trep(i, N) {\n\t\t\tcout << seg[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <tuple>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <climits>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define _ << \" \" <<\n#define all(X) (X).begin(), (X).end()\n#define len(X) (X).size()\n#define Pii pair<int, int>\n#define Pll pair<ll, ll>\n#define Tiii tuple<int, int, int>\n#define Tlll tuple<ll, ll, ll>\n\nclass SegTree_Delay {\npublic:\n    int f;\n    int INIT = INT_MAX;\n    vector<int> dat, lazy;\n\n    SegTree_Delay(int n) {\n        f = 1;\n        while (f < n) f *= 2;\n        dat.assign(2 * f, INIT);\n        lazy.assign(2 * f, INIT);\n    }\n\n    void eval(int k) {\n        if (lazy[k] == INIT) return;\n        if (k < f - 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        dat[k] = lazy[k];\n        lazy[k] = INIT;\n    }\n\n    void update(int a, int b, int x, int k, int l, int r) {\n        eval(k);\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            eval(k);\n        }\n        else if (a < r && l < b) {\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    void update(int a, int b, int x) {\n        update(a, b, x, 0, 0, f);\n    }\n\n    int query(int a, int b) {\n        return query(a, b, 0, 0, f);\n    }\n\n    int query(int a, int b, int k, int l, int r) {\n        eval(k);\n        if (r <= a || b <= l) return INIT;\n        if (a <= l && r <= b) return dat[k];\n        else {\n            int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n};\n\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegTree_Delay st = SegTree_Delay(n);\n    while (q--) {\n        int m;\n        cin >> m;\n        if (m) {\n            int i;  cin >> i;\n            cout << st.query(i, i + 1) << endl;\n        }\n        else {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(s, t + 1, x);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass RUQSegmentTree {\n\tconst int n;\n\tconst int flag = -1;\n\tconst int id = 1;\n\tvector<int> data, data2;\n\tint size(int n) {\n\t\tint res = 1;\n\t\twhile (res < n) res <<= 1;\n\t\treturn res;\n\t}\n\tvoid sub(int l, int r, int node, int lb, int ub, int val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (data[node] == val) return;\n\t\tif (l <= lb && ub <= r) {\n\t\t\tdata[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint left = node * 2, right = node * 2 + 1;\n\t\tif (data[node] != flag) {\n\t\t\tdata[left] = data[node];\n\t\t\tdata[right] = data[node];\n\t\t}\n\t\tdata[node] = flag;\n\t\tsub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tsub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata2[node] = min(data[left] == flag ? data2[left] : data[left], data[right] == flag ? data2[right] : data[right]);\n\t}\npublic:\n\tRUQSegmentTree(int n_) :\n\t\tn(size(n_)), data(n * 2, INT_MAX), data2(n * 2, INT_MAX) {}\n\tvoid update(int l, int r, int val) {\n\t\tsub(l, r + 1, 1, 0, n, val);\n\t}\n\tint find(int i) {\n\t\ti += n;\n\t\tint res = data[i];\n\t\twhile (i >>= 1) {\n\t\t\tif (data[i] == flag) break;\n\t\t\tres = data[i];\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint n, q, b, i, s, t, x;\n\tcin >> n >> q;\n\tRUQSegmentTree ruq(n);\n\twhile (q--) {\n\t\tcin >> b;\n\t\tif (b) {\n\t\t\tcin >> i;\n\t\t\tcout << ruq.find(i) << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\n// https://onlinejudge.u-aizu.ac.jp/solutions/problem/DSL_2_D/review/3635072/beet/C++14\ntemplate<typename E>\nstruct SegmentTree {\n    using H = function<E(E, E)>;\n    int n, height;\n    H h;\n    E ei;\n    vector<E> laz;\n\n    SegmentTree(H h, E ei) : h(h), ei(ei) {}\n\n    void init(int n_) {\n        n = 1;\n        height = 0;\n        while (n < n_) n <<= 1, height++;\n        laz.assign(2 * n, ei);\n    }\n\n    inline void eval(int k) {\n        if (laz[k] == ei) return;\n        laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);\n        laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);\n        laz[k] = ei;\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i; i--) eval(k >> i);\n    }\n\n    void update(int a, int b, E x) {\n        thrust(a += n);\n        thrust(b += n - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) laz[l] = h(laz[l], x), l++;\n            if (r & 1) --r, laz[r] = h(laz[r], x);\n        }\n    }\n\n    E get_val(int a) {\n        thrust(a += n);\n        return laz[a];\n    }\n\n    void set_val(int a, E x) {\n        thrust(a += n);\n        laz[a] = x;\n    }\n};\n\n\nint main() {\n\n    int n, q;\n    cin >> n >> q;\n    auto h = [](int a, int b) {\n        (void) a;\n        return b;\n    };\n    SegmentTree<int> st(h, INT_MAX);\n    st.init(n);\n\n    rep(i, q) {\n        int query;\n        cin >> query;\n\n        if (query == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(s, t + 1, x);\n        } else if (query == 1) {\n            int x;\n            cin >> x;\n            cout << st.get_val(x) << endl;\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int a[100000];\n    const int max = pow(2, 31) - 1;\n    fill(a, a + 100000, max);\n    int n, q;\n    cin >> n >> q;\n    for (int i = 0; i < q; i++) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            fill(a + s, a + t, x);\n        }\n        else {\n            int i;\n            cin >> i;\n            cout << a[i] << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\n\n\n// quoted from beet-aizu\ntemplate <typename T,typename E, typename F, typename G, typename H>\nstruct LazySegmentTree{\n    //using F = function<T(T,T)>;\n    //using G = function<T(T,E)>;\n    //using H = function<E(E,E)>;\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    LazySegmentTree(F f,G g,H h,T ti,E ei):\n        f(f),g(g),h(h),ti(ti),ei(ei){}\n\n    void init(int n_){\n        n=1;height=0;\n        while(n<n_) n<<=1,height++;\n        dat.assign(2*n,ti);\n        laz.assign(2*n,ei);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n        return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n        if(laz[k]==ei) return;\n        laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n        laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=ei;\n    }\n    inline void thrust(int k){\n        for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){    \n        while(k>>=1)\n            dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) laz[l]=h(laz[l],x),l++;\n            if(r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    void set_val(int a,T x){\n        thrust(a+=n);\n        dat[a]=x;laz[a]=ei;\n        recalc(a);\n    }\n    T query(int a,int b){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=ti,vr=ti;\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,reflect(l++));\n            if(r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n};\n\nsigned main(){\n    \n    int n, q; cin >> n >> q;\n    auto f = [](int a, int b){ return a + b; };\n    auto g = [](int a, int b){ return b != -1 ? b : a; };\n    auto h = [](int a, int b){ return b != -1 ? b : a; };\n    LazySegmentTree<int, int, decltype(f), decltype(g), decltype(h)> sg(f, g, h, 0, -1);\n    sg.build(vector<int>(n, INT_MAX));\n    \n    for(int i = 0; i < q; i++){\n        int com; cin >> com;\n        if(!com){\n            int s, t, x; cin >> s >> t >> x;\n            sg.update(s, t + 1, x);\n        }else{\n            int idx; cin >> idx;\n            cout << sg.query(idx, idx + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define dhoom ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);  \ntypedef long long ll;\n#define fi first\n#define se second\n#define sc scanf\n#define pr printf\n#define pb push_back\nconst ll inf = 1e18;\nconst int nax = 2e6 + 7;\nll mod;\nint n , q;\nusing namespace std;\nll exp(ll a , ll b){\n\tif(b == 0)\treturn 1;\n\tint x = b % 2 == 0 ?   ((exp(a , b/2)%mod)*(exp(a , b / 2)%mod))%mod :  (a%mod*exp(a , b - 1) % mod)%mod;\n\treturn x;\n}\nll tree[nax];\nll arr[nax];\nint marked[nax];\nvoid build(ll tl , ll tr , ll pos){\n\tif(tl == tr)\n\t{\n\t\ttree[pos] = arr[tl];\n\t\treturn ;\n\t}\n\tll mid = tl + (tr - tl)/2;\n\tbuild(tl , mid , 2 * pos);\n\tbuild(mid + 1 , tr , 2 * pos + 1);\n}\nvoid update(ll l , ll r , ll val , ll tl , ll tr , ll pos){\n\tif(l > r)\n\t\treturn ;\n\tif(tl == l && tr == r){\n\t\ttree[pos] = val;\n\t\tmarked[pos] = 1;\n\t\treturn ;\n\t}\n\tll mid = tl + (tr - tl)/2;\n\tif(marked[pos]){\n\t\ttree[2 * pos] = tree[pos];\n\t\ttree[2*pos + 1] = tree[pos];\n\t\tmarked[pos*2] = marked[pos*2 + 1] = 1;\n\t\tmarked[pos] = 0;\n\t}\n\tupdate(l , min(r , mid),val ,  tl , mid , 2 * pos );\n\tupdate(max(l , mid + 1), r , val , mid + 1 , tr , 2 * pos + 1);\n\t//tree[pos] = tree[2*pos] + tree[ 2* pos + 1];\n}\nll query(ll ind, ll tl , ll tr , ll pos){\n\tif(tl == tr)\n\t\treturn tree[pos];\n\tll mid = tl + (tr - tl)/2;\n\tif(marked[pos]){\n\t\ttree[2 * pos] = tree[pos];\n\t\ttree[2*pos + 1] = tree[pos];\n\t\tmarked[pos*2] = marked[pos*2 + 1] = 1;\n\t\tmarked[pos] = 0;\t\n\t}\n\tif(ind <= mid)\n\t\treturn query(ind , tl , mid , 2*pos);\n\telse \n\t\treturn query(ind , mid + 1 , tr , 2*pos + 1);\t\n}\nint main(int argc,char ** argv){\n\tdhoom;\n\n\tcin >> n >> q;\n\tll x = pow(2LL , 31LL) - 1;\n//\tcout << \"HEY\" << endl;\n\t//cout << x << endl;\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tarr[i] = x;\n\t//cout << \"building\" << endl;\n\tbuild(1 , n , 1);\n\t//cout << \" hi \" << endl;\n\tfor(int i = 0 ; i < q ; i++){\n\t\tll a , b , c , d;\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\t\tcin >> b >> c >> d;\n\t\t\t\tupdate(b+1 , c+1 , d , 1 , n , 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\tcout << query(b + 1, 1 , n , 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\n// [begin, end) of an array\n// [left, right): range of the query\n// current_idx: index of the node in segment_tree corresponding to a range in the original array\nvoid updateQuery(int segment_tree[], int lazy[], int left, int right, int begin, int end, int current_idx, int value){\n\tif(lazy[current_idx] != -1){\n\t\tsegment_tree[current_idx] = lazy[current_idx];\n\t\tif(begin != end - 1){\n\t\t\tlazy[2 * current_idx + 1] = lazy[current_idx];\n\t\t\tlazy[2 * current_idx + 2] = lazy[current_idx];\n\n\t\t}\n\t\tlazy[current_idx] = -1;\n\t}\n\tif(end <= left || begin >= right){\n\t\treturn;\n\t}\n\tif(left <= begin && right >= end){\n\t\tsegment_tree[current_idx] = value;\n\t\tif(begin != end - 1){\n\t\t\tlazy[2 * current_idx + 1] = value;\n\t\t\tlazy[2 * current_idx + 2] = value;\n\n\t\t}\n\t\treturn;\n\t}\n\n\tupdateQuery(segment_tree, lazy, left, right, begin, (begin + end) / 2, 2 * current_idx + 1, value); // value of the left child (left half range)\n\tupdateQuery(segment_tree, lazy, left, right, (begin + end) / 2, end, 2 * current_idx + 2, value); // value of the right child (right half range)\n\t// segment_tree[current_idx] = min(segment_tree[2 * current_idx + 1], segment_tree[2 * current_idx + 2]);\n\tsegment_tree[current_idx] = segment_tree[2 * current_idx + 1];\n}\n\n// [left, right]\nvoid update(int segment_tree[], int lazy[], int n, int left, int right, int value){\n\tupdateQuery(segment_tree, lazy, left, right + 1, 0, n, 0, value);\n}\n\n\n// [begin, end) of an array\n// [left, right): range of the query\n// current_idx: index of the node in segment_tree corresponding to a range in the original array\nint query(int segment_tree[], int lazy[], int left, int right, int begin, int end, int current_idx){\n\tif(lazy[current_idx] != -1){\n\t\tsegment_tree[current_idx] = lazy[current_idx];\n\t\tif(begin != end - 1){\n\t\t\tlazy[2 * current_idx + 1] = lazy[current_idx];\n\t\t\tlazy[2 * current_idx + 2] = lazy[current_idx];\n\n\t\t}\n\t\tlazy[current_idx] = -1;\n\t}\n\n\tif(end <= left || begin >= right){\n\t\treturn INF;\n\t}\n\tif(left <= begin && right >= end){\n\t\treturn segment_tree[current_idx];\n\t}\n\n\tint left_val = query(segment_tree, lazy, left, right, begin, (begin + end) / 2, 2 * current_idx + 1); // value of the left child (left half range)\n\tint right_val = query(segment_tree, lazy, left, right, (begin + end) / 2, end, 2 * current_idx + 2); // value of the right child (right half range)\n\treturn min(left_val, right_val);\n}\n\n// [left, right]\nint find(int segment_tree[], int lazy[], int n, int left, int right){\n\treturn query(segment_tree, lazy, left, right + 1, 0, n, 0);\n}\n\nint initRMQ(int original_size){\n\tint n = 1;\n\t// make the size of the array to be power of n\n\twhile(n < original_size){\n\t\tn *= 2;\n\t}\n\treturn n;\n}\n\nint main(){\n\tint original_size, q;\n\tcin >> original_size >> q;\n\tint n = initRMQ(original_size);\n\tint segment_tree[2 * n - 1];\n\tint lazy[2 * n - 1];\n\tfor(auto i = 0; i < 2 * n - 1; ++i){\n\t\tsegment_tree[i] = INF;\n\t\tlazy[i] = -1;\n\t}\n\n\tfor(auto i = 0; i < q; ++i){\n\t\tint cmd;\n\t    cin >> cmd;\n\t\tif(cmd == 0){\n\t\t\tint left, right, val;\n\t\t\tcin >> left >> right >> val;\n\t\t\tupdate(segment_tree, lazy, n, left, right, val);\n\t\t}else if(cmd == 1){\n\t\t\tint idx;\n\t\t\tcin >> idx;\n\t\t\tcout << find(segment_tree, lazy, n, idx, idx) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nstruct SD\n{\n\tint n;\n\tint lsize;\n\tint sn;\n\tvector<int> data;\n\tvector<int> lazyData;\n\n\tSD(int n) :n(n), lsize(sqrt(n)), sn(n / lsize + 1), data(n, 2147483647), lazyData(sn, -1){}\n\n\tvoid applyLazy(int k)\n\t{\n\t\tif (lazyData[k] == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = k*lsize; i < (min(n, (k + 1)*lsize)); i++)\n\t\t{\n\t\t\tdata[i] = lazyData[k];\n\t\t}\n\t\tlazyData[k] = -1;\n\t}\n\n\tvoid update(int t, int s, int v)\n\t{\n\t\tfor (int i = t / lsize; i < (s / lsize)+1; i++)\n\t\t{\n\t\t\tint l = i*lsize;\n\t\t\tint r = (i + 1)*lsize - 1;\n\n\t\t\tif (s < l || r < t)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (t <= l&&r <= s)\n\t\t\t{\n\t\t\t\tlazyData[i] = v;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tapplyLazy(i);\n\t\t\t\tfor (int j = t; j <= s; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[j] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int index)\n\t{\n\t\tint k = index / lsize;\n\t\tapplyLazy(k);\n\t\treturn data[index];\n\t}\n};\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tSD sd(n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tsd.update(s, t, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << sd.find(s) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 1000\n \nint bucket[MAX/B][B];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n    int f1 = 1, f2 = 1;\n    while(a <= b && a%B != 0){\n        if(f1 && data[a/B] != -1){\n            for(int i = 0;i < B;i++)bucket[a/B][i] = data[a/B];\n            f1 = 0;data[a/B] = -1;\n        }\n        bucket[a/B][a%B] = x;\n        a++;\n    }\n    while(a <= b && b%B != B-1){\n        if(f2 && data[b/B] != -1){\n            for(int i = 0;i < B;i++)bucket[b/B][i] = data[b/B];\n            f2 = 0;data[b/B] = -1;\n        }\n        bucket[b/B][b%B] = x;\n        b--;\n    }\n    while(a < b){\n        data[a/B] = x;\n        a += B;\n    }\n}\n \nint find(int x){\n    if(data[x/B] != -1){\n        for(int i = 0;i < B;i++)bucket[x/B][i] = data[x/B];\n        data[x/B] = -1;\n    }\n    return bucket[x/B][x%B];\n}\n \nint main(){\n    int n, q, c, s, t, x, ans;\n    scanf(\"%d%d\", &n, &q);\n    fill(data, data+MAX/B, -1);\n    fill((int*)bucket, (int*)(bucket+MAX/B), INF);\n    while(q--){\n        scanf(\"%d\", &c);\n        if(!c){\n            scanf(\"%d%d%d\", &s, &t, &x);\n            update(s, t, x);\n        }else{\n            scanf(\"%d\", &x);\n            ans = find(x);\n            printf(\"%d\\n\", ans);\n        }\n    }\n    //rep(i,n)printf(\"%d \", bucket[0][i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define mp make_pair\nusing namespace std;\nint t, n, q, l = 0, r = 123456, x = 2147483647, q1;\npair<int, int>t1[123456], t2[12345], t3[1234], t4[123], t5[12];\nvoid f1() {\n\tr++;\n\twhile (l < r) {\n\t\tif (l % 10000 == 0 && l + 10000 <= r) {\n\t\t\tt5[l / 10000] = mp(t, x);\n\t\t\tl += 10000;\n\t\t}\n\t\telse if (l % 1000 == 0 && l + 1000 <= r) {\n\t\t\tt4[l / 1000] = mp(t, x);\n\t\t\tl += 1000;\n\t\t}\n\t\telse if (l % 100 == 0 && l + 100 <= r) {\n\t\t\tt3[l / 100] = mp(t, x);\n\t\t\tl += 100;\n\t\t}\n\t\telse if (l % 10 == 0 && l + 10 <= r) {\n\t\t\tt2[l / 10] = mp(t, x);\n\t\t\tl += 10;\n\t\t}\n\t\telse {\n\t\t\tt1[l] = mp(t, x); l++;\n\t\t}\n\t}\n}\nint f2(int i) {\n\tint t = t1[i].first, x = t1[i].second;\n\ti /= 10;\n\tif (t < t2[i].first) {\n\t\tt = t2[i].first; x = t2[i].second;\n\t}\n\ti /= 10;\n\tif (t < t3[i].first) {\n\t\tt = t3[i].first; x = t3[i].second;\n\t}\n\ti /= 10;\n\tif (t < t4[i].first) {\n\t\tt = t4[i].first; x = t4[i].second;\n\t}\n\ti /= 10;\n\tif (t < t5[i].first) {\n\t\tt = t5[i].first; x = t5[i].second;\n\t}\n\treturn x;\n}\nsigned main() {\n\tcin >> n >> q;\n\tfor0(i, n)t1[i] = mp(0, x);\n\tfor (t = 1; t <= q; t++) {\n\t\tcin >> q1;\n\t\tif (q1) {\n\t\t\tint i; cin >> i; cout << f2(i) << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> l >> r >> x;\tf1();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int INF = (1LL << 31) - 1;\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<bool> lazyFlag;\n  vector<int> lazyUpdate;\n  SqrtDecomposition(int n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, INF);\n    lazyFlag.assign(K, false);\n    lazyUpdate.assign(K, 0);\n  }\n  void eval(int k) {\n    if (lazyFlag[k]) {\n      lazyFlag[k] = false;\n      for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n    }\n  }\n  // [s, t)\n  void update(int s, int t, int x) {\n    for (int k = 0; k < K; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        lazyFlag[k] = true;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n  int find(int i) {\n    int k = i / sqrtN;\n    eval(k);\n    return data[i];\n  }\n};\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  int N, Q;\n  cin >> N >> Q;\n  SqrtDecomposition decomp(N);\n  while (Q--) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      decomp.update(s, t + 1, x);\n    } else {\n      int i;\n      cin >> i;\n      cout << decomp.find(i) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n\n  fill(a,a+n,2147483647);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(s == t){\n\ta[s] = x;\n      }\n      else{\n\n\tfill_n(a+s,t+1,x);\n      }\n    }\n    else{\n      int x;\n      cin >> x;\n      cout << a[x] << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint n,node[444444],lazy[444444];\n\nint main(){\n\tint q;\n\tcin>>n>>q;\n\trep(i,q){\n\t\tint Q;\n\t\tcin>>Q;\n\t\tif(Q==0){\n\t\t\tint s,t,x;\n\t\t\tcin>>s>>t>>x;\n\t\t}\n\t\telse{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    OOtoO upd_f;\n    MMtoM cmb_f;\n    MOtoM lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = cmb_f(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    OOtoO upd_f_, MMtoM cmb_f_, MOtoM lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = lzy_f(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lzy_f(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = cmb_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"E \");\n            else fprintf(stderr, \"%d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"E \");\n            else fprintf(stderr, \"%d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\n\nvoid DSL_2_D() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, INT_MAX, INT_MAX,\n                                  [](int a, int b) { return b;         },  // upd\n                                  [](int a, int b) { return min(a, b); },  // cmb\n                                  [](int a, int b) { return b;         },  // lzy\n                                  [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\nint main() {\n    DSL_2_D();\n    // DSL_2_E();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define N 131072 //100000\n#define MAXVAL 2147483647 //((long int) ((unsigned long) (1 << 31) - 1))  //*2\nint min(int a, int b){return a>b?b:a;}\nint data[2*131072+100];      //the size of array, for present the tree\n\n//range update and single query\n\n/*\nalways binary [node_left,node_right]\n*/ \nvoid update(int update_left, int update_right, int x, int current_node,int node_left,int node_right){\n\t//not in the range\n\tif(update_right<node_left||update_left>node_right){\n\t\treturn;\t\n\t}else if(update_left<=node_left&&update_right>=node_right){\n\t\tdata[current_node] = x;\n\t}else{\n\t\t//how to check if the\n\t\t//unfold the node\n\t\tif(data[current_node]!=-1){\n\t\t\tupdate(node_left, node_right,data[current_node],current_node*2+1,node_left,(node_left+node_right)/2);\n\t\t\tupdate(node_left, node_right,data[current_node],current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t\t\tdata[current_node]=-1;\n\t\t}\n\t\t//update \n\t\tupdate(update_left, update_right, x, current_node*2+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left, update_right, x, current_node*2+2,(node_left+node_right)/2+1, node_right);\n\t}\n\t\n\t\n}\n//segment of thr last layer\n//I did notdeal with 0\nint search(int index,int origin_index){\n\tif(index==0) {\n\t\tif(data[index]==-1||data[index]==MAXVAL)\n\t\t\treturn data[origin_index];\n\t\telse return data[index];\n\t}\n\t//if(index<0) return MAXVAL;\n\tif(data[index]!=MAXVAL&&data[index]!=-1) return data[index];\n\t\n\t\n\treturn search((index-1)/2,origin_index);\n}\nint main(){\n\tint n, q;\n\t//FILE *fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\tint N = 1;\n\twhile(N<n) N = N<<1;\n\tfor(int i = 0; i<=2*N-2; i++){\n\t\tdata[i] = MAXVAL;\n\t}\n\t//printf(\"%d\",(-1/2));\n\tfor(int i = 0; i<q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tint a,b,c;\n\t\t\n\t\tif(temp == 0) {  //update\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tupdate(a,b,c,0,0,N-1);\n\t\t} else if(temp == 1){ //search\n\t\t\tscanf(\"%d\",&a);\n\t\t\tprintf(\"%d\\n\",search(a+N-1,a+N-1));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 2147483647\n#define ASTART (1<<17)\nint a[1<<18][2];\nint ti=1;\n\nint find(int i){\n  int nv=INF,t=0;\n  i+=ASTART-1;\n  nv=a[i][0];\n  t=a[i][1];\n  while (i>0){\n    i=(i-1)/2;\n    if (t<a[i][1])nv=a[i][0],t=a[i][1];\n    //cout << i << \" = \" << a[i][0]<< \" = \" << a[i][1]<< endl;\n  }\n  return nv;\n}\nvoid update(int s,int t,int x,int k,int l,int r){\n  if (l>=s&&r<=t){\n    a[k][0]=x;\n    a[k][1]=ti;\n    return;\n  }\n  if (r<=s||l>=t)return;\n  int m=(l+r)/2;\n  update(s,t,x,k*2+1,l,m);\n  update(s,t,x,k*2+2,m,r);\n}\nint main(){\n  int n,q,com,s,t,x;\n  for (int i=0;i<(1<<18);i++)a[i][0]=INF,a[i][1]=0;\n  cin >> n>>q;\n\n  for (int i=0;i<q;i++){\n    cin >> com;\n    if (com==0) {\n      cin >> s >> t >> x;\n      update(s,t+1,x,0,0,ASTART);\n      ti++;\n    }else {\n      cin >> s;\n      cout << find(s)<< endl;\n    }\n    //for (int i=0;i<5;i++)cout << a[i] << endl;\n    //cout << a[ASTART];\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n// 完成版。\n\nint tree[(1 << 18)];\n\nvoid Update(int s, int t, int m, int left = 0, int right = (1 << 17), int key = 0){\n    if(t < left || right <= s) return;\n    if(s <= left && right - 1 <= t){ tree[key] = max(tree[key], m); return; }\n    Update(s, t, m, left, (left + right) / 2, 2 * key + 1);\n    Update(s, t, m, (left + right) / 2, right, 2 * key + 2);\n}\n\nint Find(int i){\n    i += (1 << 17) - 1;\n    int m = tree[i];\n    while(i){\n        i = (i - 1) / 2;\n        m = max(tree[i], m);\n    };\n    return m;\n}\n\nint main(){\n    int i;\n    for(i = 0; i < (1 << 18); i++) tree[i] = 0;\n    int n, q;\n    int x[100000];\n    for(i = 0; i < 100000; i++) x[i] = INT_MAX;\n    int s, t, value, m;\n    m = 1;\n    \n    cin >> n >> q;\n    int query;\n    while(q){\n        q--;\n        cin >> query;\n        if(query){\n            cin >> i;\n            //cout << x[Find(i)] << endl;\n            printf(\"%d\\n\", x[Find(i)]);\n        }else{\n            cin >> s >> t >> value;\n            x[m] = value;\n            Update(s, t, m);\n            m++;\n        }\n    };\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 100000000\n//#define INF 300000000000000000\n#define MOD 1000000007\n#define mod 1000000007\n#define INT_MAX_ 2147483647\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define rep(i,n)for (ll i = 0; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\n#define me memset\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[5]={-1,0,1,0,0};\nint dy[5]={0,-1,0,1,0};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp1(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\ntemplate <typename T>\nstruct RMQ {\n    const T INF = numeric_limits<T>::max();\n    int n;\n    vector<T> dat, lazy;\n    RMQ(int n_) : n(), dat(n_ * 4, INF), lazy(n_ * 4, INF) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n    /* lazy eval */\n    void eval(int k) {\n        if (lazy[k] == INF) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {             // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = lazy[k];\n            lazy[k * 2 + 2] = lazy[k];\n        }\n        // 自身を更新\n        dat[k] = lazy[k];\n        lazy[k] = INF;\n    }\n    void update(int a, int b, T x, int k, int l, int r) {\n        eval(k);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = x;\n            eval(k);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, T x) { update(a, b, x, 0, 0, n); }\n    T query_sub(int a, int b, int k, int l, int r) {\n        eval(k);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return INF;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    T query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n    /* debug */\n    inline T operator[](int a) { return query(a, a + 1); }\n    void print() {\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            cout << (*this)[i];\n            if (i != n) cout << \",\";\n        }\n        cout << endl;\n    }\n};\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    ll n,q;cin>>n>>q;\n    RMQ<int>rmq(n);\n\n    for(ll i=0;i<q;i++){\n        ll co;cin>>co;\n        if(co==1){\n            ll x;cin>>x;\n            cout<<rmq.query(x,x+1)<<endl;\n        }  \n        else{\n            ll x,y,z;cin>>x>>y>>z;\n            rmq.update(x,y+1,z);\n        }\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // ver2.3.5\n#define int long long\n#define endl \"\\n\"\n#define ALL(v) (v).begin(),(v).end()\n#define COUNT(a,k) upper_bound(ALL(a),k)-lower_bound(ALL(a),k)\n#define BIGGER(a,k) a.end()-upper_bound(ALL(a),k)\n#define SMALLER(a,k) lower_bound(ALL(a),k)-a.begin()\n#define Vi vector<int>\n#define VVi vector<Vi>\n#define Vs vector<string>\n#define Pii pair<int,int>\n#define VPii vector<Pii>\n#define Tiii tuple<int,int,int>\n#define VTiii vector<Tiii>\n#define PQi priority_queue<int>\n#define PQir priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define itos to_string\n#define stoi stoll\n#define FI first\n#define SE second\n#define cYES cout<<\"YES\"<<endl\n#define cNO cout<<\"NO\"<<endl\n#define cYes cout<<\"Yes\"<<endl\n#define cNo cout<<\"No\"<<endl\n#define cyes cout<<\"yes\"<<endl\n#define cno cout<<\"no\"<<endl\n#define _ <<' '<<\n#define sortr(v) sort(v,greater<>())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repeq(i,a,b) for(int i=a;i<=b;i++)\n#define repreq(i,a,b) for(int i=a;i>=b;i--)\n#define leng(n) (int)(log10(n)+1)\n#define dem(a,b) ((a+b-1)/(b))\n#define Vin(a) rep(iI,0,a.size())cin>>a[iI]\n//#define INF 3000000000000000000  //  3.0*10^18(MAXの1/3くらい)\n#define MAX LLONG_MAX\n#define PI 3.141592653589793238462\n#define MOD 1000000007  //  10^9 + 7\nusing namespace std;\n\n/* デバッグ用 */\nvoid Vout(auto a){if(a.size()==0) cout<<\".\"<<endl;\nelse{rep(i,0,a.size()-1)cout<<a[i]<<' ';if(a.size()>0)cout<<a.back()<<endl;}return;}\nvoid Verr(auto a){if(a.size()==0) cerr<<\".\"<<endl;\nelse{rep(i,0,a.size()-1)cerr<<a[i]<<' ';if(a.size()>0)cerr<<a.back()<<endl;}return;}\nvoid VVout(auto a){if(a.size()==0)cout<<\".\"<<endl;\nelse{rep(i,0,a.size())Vout(a[i]);}return;}\nvoid VVerr(auto a){if(a.size()==0)cerr<<\".\"<<endl;\nelse{rep(i,0,a.size())Verr(a[i]);}return;}\nvoid VPout(auto a){if(a.size()==0)cout<<\".\"<<endl;\nelse{rep(i,0,a.size())cout<<a[i].FI<<' '<<a[i].SE<<endl;}return;}\nvoid VPerr(auto a){if(a.size()==0)cerr<<\".\"<<endl;\nelse{rep(i,0,a.size())cerr<<a[i].FI<<' '<<a[i].SE<<endl;}return;}\n\n/* 便利関数 */\nint gcd(int a,int b){return b?gcd(b,a%b):a;} // 最大公約数gcd\nint lcm(int a,int b){return a/gcd(a,b)*b;} // 最小公倍数lcm\nint mypow(int x, int n, int m){ // 累乗x^n(mod m) O(log(n))\nif(n==0)return 1;if(n%2==0)return mypow(x*x%m,n/2,m);else return x*mypow(x,n-1,m)%m;}\nint scomb(int n, int r){if((n-r)<r)r=n-r; // nCr(小さい場合)\nint a=1;for(int i=n;i>n-r;--i){a=a*i;}for(int i=1;i<r+1;++i){a=a/i;}return a;}\nint comb(int n, int r){if((n-r)<r)r=n-r; // nCr(%MOD)\nint a=1;for(int i=n;i>n-r;--i){a=a*i%MOD;}for(int i=1;\ni<r+1;++i){a=a*mypow(i,MOD-2,MOD)%MOD;}return a%MOD;}\nVi stpowV(){Vi a(100001);\na[0]=1;repeq(i,1,100000)a[i]=a[i-1]*i%MOD;return a;}\n//Vi stpow = stpowV();  // 階乗配列(%MOD)\nvoid press(auto &v){v.erase(unique(ALL(v)),v.end());} // 圧縮\nVi Vsum(Vi &v){Vi S(v.size()+1);rep(i,1,S.size())S[i]+=v[i-1]+S[i-1];return S;} // 累積和\nint keta(int k,int i){string s = itos(k);return s[s.size()-i]-'0';} // i桁目の数字\n\n\n#define INF 2147483647\n\nstruct RUQ {\n  \n  /*　使い方まとめ　*/\n  \n  /*\n  \n  RUQ myvec(n) // 宣言 nは必要な要素数 (以下すべて0-index)\n  myvec.at(i) // 配列のi番目にアクセス\n  myvec.update(i,k) // 配列のi番目をkに更新\n  myvec.rupdate(L,R,k) // 配列のL番目からR番目をkに更新\n  \n  myvec.debug() // 元データ配列とバケット配列を標準エラー出力\n  \n  */\n  \n  vector<int> data;\n  vector<int> bucket;\n  int sq;\n  \n  RUQ(int n) {\n    sq = sqrt(n);\n    if(sq*sq==n) sq--;\n    sq++;\n    data = Vi(sq*sq,INF); // 初期値はすべてINF\n    bucket = Vi(sq,-INF); // 無しのとき(-INF)\n  }\n  \n  void update(int i,int k) {\n    data[i] = k;\n  }\n  \n  void rupdate(int L,int R,int k) { // [L,R]は範囲\n    R++;\n    int minn = INF;\n    int dL,dR;\n    \n    rep(i,0,sq+1) {\n      dL = i*sq,dR = (i+1)*sq; // [dL,dR]は小範囲(バケット)\n      \n      if(dR <= L || R <= dL) continue; // 小範囲が完全に範囲外\n      \n      if(L <= dL && dR <= R) { // 小範囲が完全に範囲内\n        bucket[i] = k;\n      }\n      \n      else { // 小範囲が範囲と一部重なる\n        if(bucket[i]!=-INF){\n          rep(j,dL,dR) data[j] = bucket[i];\n          bucket[i] = -INF;\n        }\n        \n        rep(j,max(L,dL),min(R,dR)) {\n          data[j] = k;\n        }\n      }\n    }\n  }\n  \n  int at(int i) {\n    int ib = i/sq;\n    if(bucket[ib]==-INF) return data[i];\n    else {\n      int L = (i/sq)*sq,R = L+sq;\n      rep(j,L,R) data[j] = bucket[ib];\n      bucket[ib] = -INF;\n      return data[i];\n    }\n  }\n  \n  void debug(){\n    Verr(data);\n    Verr(bucket);\n  }\n  \n};\n\n\nsigned main() {\n  cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(12);\n  int n,q;\n  cin >> n >> q;\n  int qw,er,ty,ui;\n  \n  RUQ vec(n);\n  \n  rep(i,0,q){\n    cin >> qw;\n    if(qw==0){\n      cin >> er >> ty >> ui;\n      vec.rupdate(er,ty,ui);\n    }\n    else {\n      cin >> er;\n      cout << vec.at(er) << endl;\n    }\n  }\n  //vec.debug();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nclass SegTree { // index starts at 0.\npublic:\n  int N;\n  int* dat;\n\n  SegTree(int n) {\n    N = 1;\n    while (N < n) N *= 2;\n    dat = new int[2 * N - 1];\n    for (auto i = 0; i < 2 * N - 1; ++i) {\n      dat[i] = -1;\n    }\n  }\n\n  ~SegTree() {\n    delete[] dat;\n  }\n\n  int find(int k) {\n    k += N - 1;\n    int ans = dat[k];\n    while (k > 0) {\n      k = (k - 1)/2;\n      if (dat[k] != -1) ans = dat[k];\n    }\n    return ans;\n  }\n\n  void update(int v, int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) {\n      return;\n    }\n    if (a <= l && r <= b) {\n      dat[k] = v;\n      return;\n    }\n    if (dat[k] != -1) {\n      dat[2 * k + 1] = dat[k];\n      dat[2 * k + 2] = dat[k];\n      dat[k] = -1;\n    }\n    update(v, a, b, k * 2 + 1, l, (l + r) / 2);\n    update(v, a, b, k * 2 + 2, (l + r) / 2, r);\n  }\n  \n  void update(int v, int a, int b) {\n    update(v, a, b, 0, 0, N);\n  }\n  \n};\n\nint main () {\n  int n, q;\n  cin >> n >> q;\n  SegTree st(n);\n  for (auto i = 0; i < n; ++i) {\n    st.update(2147483647, i, i+1);\n  }\n  for (auto i = 0; i < q; ++i) {\n    int com;\n    cin >> com;\n    if (com == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      st.update(x, s, t+1);\n    } else {\n      int k;\n      cin >> k;\n      cout << st.find(k) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "import Prelude hiding (elem)\nimport Control.Applicative\nimport Control.Monad.State\ndata LazySegTree a =  Leaf a | Elem { eSize :: Int, elem :: a} | Tree { size :: Int\n                                                                      , left :: LazySegTree a\n                                                                      , right :: LazySegTree a\n                                                                      , lazy :: Bool\n                                                                      } deriving (Show)\n\nmain = do\n    [n, q] <- map read.words<$>getLine\n    let init = fromList $ replicate n (2^31 - 1)\n    print (n,q)\n    evalStateT (query q) init\n\nquery :: Int -> StateT (LazySegTree Int) IO ()\nquery 0 = return ()\nquery n  = do\n    getQuery\n    query (n-1)\n\ngetQuery :: StateT (LazySegTree Int) IO ()\ngetQuery = do\n    (x:xs) <- lift $ map read.words<$>getLine\n    case x of\n      0 -> let [s,t,x] = xs in modify (\\tr -> updateT tr s t x)\n      1 -> let [i] = xs in get >>= \\tr -> (lift $ print $ findT tr i)\n\nisElem :: LazySegTree a -> Bool\nisElem (Elem _ _) = True\nisElem _          = False\n\nfromList :: [a] -> LazySegTree a\nfromList xs = fl n xs\n    where n = length xs\n\nfl :: Int -> [a] -> LazySegTree a\nfl n [x] = Leaf x\nfl n xs = Tree n leftT rightT True\n    where n' = n `div` 2\n          (xsL, xsR) = splitAt n' xs\n          leftT = fl n' xsL\n          rightT = fl (n-n') xsR\n\nupdateT :: LazySegTree a -> Int -> Int -> a -> LazySegTree a\nupdateT (Leaf a) _ _ x = Leaf x\nupdateT tr s t x\n  | isElem tr = elemUpdateT tr s t x\n  | n <= s = tr { lazy = False, right = updateT (right tr) (s-n) (t-n) x }\n  | n > t  = tr { lazy = False, left = updateT (left tr) s t x }\n  | t-s+1 == size tr = Elem (size tr) x\n  | otherwise = tr { lazy = False\n                   , left = updateT (left tr) s (n-1) x\n                   , right = updateT (right tr) 0 (t-n) x\n                   }\n    where n = size tr `div` 2\n\nelemUpdateT tr s t x\n  | eSize tr == 1 = Leaf x\n  | n <= s = Tree { size = eSize tr, lazy = False, left = lt, right = elemUpdateT rt (s-n) (t-n) x}\n  | n > t = Tree { size = eSize tr, lazy = False, left = elemUpdateT lt s t x, right = rt }\n  | t - s + 1 == eSize tr = tr { elem = x }\n  | otherwise = Tree { lazy = False\n                     , left = elemUpdateT lt s (n-1) x\n                     , right = elemUpdateT rt 0 (t-n) x\n                     , size = eSize tr\n                     }\n    where n = eSize tr `div` 2\n          lt = Elem n (elem tr)\n          rt = Elem (eSize tr - n) (elem tr)\n\nfindT (Leaf x) 0 = x\nfindT tr i\n  | isElem tr = elem tr\n  | n <= i = findT (right tr) (i-n)\n  | n > i = findT (left tr) i\n    where n = size tr `div` 2\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n//////////////////////////////////////////////////\n// Range Query - RMQ and RUQ with Lazy Segment Tree\n// https://www.slideshare.net/iwiwi/ss-3578491\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_F&lang=jp\n\nstruct LazySegmentTree{\n    // for vertex n\n    // par (n-1)/2\n    // chi 2n+1,2n+2\n\n    // index i\n    // bottom vertex n+i-1\n    const int NONNUM = -1; //ありえない数字\n    int segn2; // imply actually vertex number\n    vector<ll> data,lazy; \n     \n    LazySegmentTree(int n){\n        segn2=1;\n        while(segn2<n) segn2*=2; //必要分2^Mを取る\n         \n        data.resize(segn2*2,INT_MAX);\n        lazy.resize(segn2*2,NONNUM);\n    }\n    \n    //lazy_propagate -- lazy[v] = xはvの表す区間がxに変更されることを表す．\n    inline void eval(int k,int l,int r){\n        if (lazy[k] != NONNUM){ // lazy nonzero\n            data[k] = lazy[k]; // itself\n            \n            if (r-l > 1){\n                lazy[2*k+1] = lazy[k];\n                lazy[2*k+2] = lazy[k];\n            }\n\n            lazy[k] = NONNUM;\n        }\n    }\n\n    ll query(int a,int b,int l=0,int r=-1,int k=0){\n        if(r<0) r=segn2; // when calling function at first\n        if (r <= a || b <= l) return INT_MAX; //disjoint\n\n        eval(k,l,r);\n\n        if (a <= l && r <= b) return data[k]; //include\n        \n        ll vl = query(a,b,l,(l+r)/2,k*2+1);\n        ll vr = query(a,b,(l+r)/2,r,k*2+2);\n        return min(vl,vr);\n    }\n     \n    \n    void update(int a,int b ,ll x, int l = 0, int r=-1,int k = 0){\n        if(r==-1) r=segn2;\n\n        eval(k,l,r);\n        \n        if (b <= l || r <= a) return;\n\n        if (a <= l && r <= b){\n            lazy[k] = x;\n            eval(k,l,r);\n            return;\n        }else{\n            //一部のみ含むとき，子ノードを計算してその結果をもらう\n            update(a,b,x,l,(l+r)/2,2*k+1);\n            update(a,b,x,(l+r)/2,r,2*k+2);\n            data[k] = min(data[2*k+1] , data[2*k+2]);\n        }\n        \n    }\n};\n\n// 0-indexed\n// sum [s,t) --> s,t+1\n// update [s,t,x) --> s,t+1,x\n\nint main(){\n    int N,q;\n    SCD2(N,q);\n    LazySegmentTree seg(N);\n\n    REP(i,q){\n        int d; SCD(d);\n        if (d==0){\n            int s,t,x;\n            SCD3(s,t,x);\n            seg.update(s,t+1,(ll)x);\n        }else{\n            int s,t; SCD(s);\n            PRINTLLD(seg.query(s,s+1));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\ntemplate <typename T>\nstruct RUQ //calculateはminimum\n{\n    int n;\n    const T ex = 1ll << 60; //初期値\n    vector<T> dat, lazy; //tree本体\n    RUQ(vector<T> v){\n        int x = 1;\n        int i;\n        n = v.size();\n        while(x < n) x <<= 1;\n        n = x; \n        dat.resize(2*n-1, ex);\n        lazy.resize(2*n-1, ex);\n        for(i = 0;i < v.size();++i){\n            dat.at(i + n - 1) = v.at(i);\n        }\n        for(i = n-2;i >= 0;--i){\n            dat.at(i) = calculate(dat.at(2*i+1), dat.at(2*i+2));\n        }\n    }\n    \n    T calculate(T a, T b){\n        return min(a, b);\n    }\n    \n    void eval(int now){\n        if(lazy.at(now) == ex) return;\n        if(now < n - 1){\n            lazy.at(2*now + 1) = lazy.at(now);\n            lazy.at(2*now + 2) = lazy.at(now);\n        }\n        dat.at(now) = lazy.at(now);\n        lazy.at(now) = ex;\n    }\n    \n    void update(int a, int b, T x, int now, int l, int r){\n        eval(now);\n        if(a <= l && r<= b){\n            lazy.at(now) = x; //上から書き換える。\n            eval(now);\n        }else if(a < r && l < b){\n            update(a, b, x, 2*now + 1, l, (l + r)/2);\n            update(a, b, x, 2*now + 2, (l + r)/2, r);\n            dat.at(now) = calculate(dat.at(2*now + 1), dat.at(2*now + 2));\n        }\n    }\n    void update(int a, int b, T x){update(a, b, x, 0, 0, n);}\n    \n    T query(int a, int b){return query_sub(a, b, 0, 0, n);}\n    T query_sub(int a, int b, int now, int l, int r){\n        eval(now);\n        if(r <= a || b <= l) return ex;\n        else if(a <= l && r <= b) return dat.at(now);\n        else{\n            T vl = query_sub(a, b, 2*now + 1, l, (l + r)/2);\n            T vr = query_sub(a, b, 2*now + 2, (l + r)/2, r);\n            return calculate(vl, vr);\n        }\n    }\n};\n\nint main()\n{\n    ll i,j;\n    ll n,q;\n    cin >> n >> q;\n    vector<ll> a(n,(1ll << 31) - 1);\n    RUQ<ll> ruq(a);\n    for(i = 0;i < q;++i){\n        ll com;\n        cin >> com;\n        if(com == 0){\n            ll s,t,x;\n            cin >> s >> t >> x;\n            ruq.update(s, t+1, x);\n        }else{\n            ll ind;\n            cin >> ind;\n            cout << ruq.query(ind, ind+1) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate<class...> class Container=::std::vector>\nclass LazySegTree{\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier = Modifier;\n\tusing const_reference = const value_type &;\n\tusing container_value_type = Container<value_type>;\n\tusing container_operator_type = Container<operator_type>;\n\tusing size_type = typename container_value_type::size_type;\n\nprivate:\n\tcontainer_value_type tree;\n\tcontainer_operator_type lazy;\n\tsize_type size_, height;\n\n\tstatic size_type getsize(const size_type x){\n\t\tsize_type ret = 1;\n\t\twhile(ret < x)\n\t\t\tret <<= 1;\n\t\treturn ret;\n\t}\n\n\tstatic size_type getheight(const size_type x){\n\t\tsize_type ret = 0;\n\t\twhile((static_cast<size_type>(1) << ret) < x){\n\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tinline static value_type calc(const value_type a, const value_type b){\n\t\treturn value_structure::operation(a, b);\n\t}\n\n\tinline static void apply(operator_type &data, const operator_type a){\n\t\tdata = operator_structure::operation(data, a);\n\t}\n\n\tinline static value_type reflect(const value_type v, const operator_type o){\n\t\treturn modifier::operation(v, o);\n\t}\n\n\tinline void push(const size_type index){\n\t\ttree[index] = reflect(tree[index], lazy[index]);\n\t\tapply(lazy[index << 1], lazy[index]);\n\t\tapply(lazy[index << 1 | 1], lazy[index]);\n\t\tlazy[index] = operator_structure::identity();\n\t}\n\n\tinline void calc_node(const size_type index){\n\t\tif(tree.size() <= (index << 1 | 1)) return;\n\t\tassert(0 < index);\n\t\ttree[index] = calc(reflect(tree[index << 1],  lazy[index << 1]),\n\t\t\t\treflect(tree[index << 1 | 1], lazy[index << 1 | 1]));\n\t}\n\n\tvoid build(size_type index){\n\t\twhile(index >>= 1){\n\t\t\tcalc_node(index);\n\t\t}\n\t}\n\n\tvoid propagate(const size_type index){\n\t\tfor(size_type shift = height; shift ; --shift){\n\t\t\tpush(index >> shift);\n\t\t}\n\t}\n\npublic:\n\tLazySegTree() : size_(0), height(0), tree(), lazy(){}\n\tLazySegTree(const size_type size)\n\t\t\t: size_(size), height(getheight(size)),\n\t\t\t\ttree(size << 1, value_structure::identity()),\n\t\t\t\tlazy(size << 1, operator_structure::identity()){}\n\ttemplate<class InputIterator>\n\tLazySegTree(InputIterator first, InputIterator last)\n\t\t\t: size_(::std::distance(first, last)){\n\t\theight = getheight(size_);\n\t\ttree(size_, value_structure::identity());\n\t\ttree.insert(tree.end(), first, last);\n\t\tlazy(size_ << 1, operator_structure::identity());\n\t\tfor(size_type i = size_;i > 0;i--){\n\t\t\tcalc_node(i);\n\t\t}\n\t}\n\n\tsize_type size() const { return size_; }\n\tconst_reference operator[](const size_type k) const {\n\t\tassert(k < size_);\n\t\tpropagate(k+size_);\n\t\ttree[k+size_] = reflect(tree[k+size_], lazy[k+size_]);\n\t\treturn tree[k+size_];\n\t}\n\n\tvalue_type query(size_type l, size_type r){\n\t\tassert(l <= r);\n\t\tassert(0 <= l && l < size_);\n\t\tassert(0 <= r && r <= size_);\n\t\tvalue_type retl = value_structure::identity(),\n\t\t\t\t\t\t\t retr = value_structure::identity();\n\t\tl += size_;\n\t\tr += size_;\n\t\tpropagate(l);\n\t\tpropagate(r-1);\n\t\tfor(; l < r ; l >>= 1, r >>= 1){\n\t\t\tif(l&1){\n\t\t\t\tretl = calc(retl, reflect(tree[l], lazy[l]));\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(r&1){\n\t\t\t\tr--;\n\t\t\t\tretr = calc(reflect(tree[r], lazy[r]), retr);\n\t\t\t}\n\t\t}\n\t\treturn calc(retl, retr);\n\t}\n\n\tvoid update(size_type l, size_type r, const operator_type& data){\n\t\tassert(l <= r);\n\t\tassert(0 <= l && l < size_);\n\t\tassert(0 <= r && r <= size_);\n\t\tl += size_;\n\t\tr += size_;\n\t\tpropagate(l);\n\t\tpropagate(r - 1);\n\t\tfor(size_type l_ = l, r_ = r; l_ < r_ ; l_ >>= 1, r_ >>= 1){\n\t\t\tif(l_ & 1) apply(lazy[l_++], data);\n\t\t\tif(r_ & 1) apply(lazy[--r_], data);\n\t\t}\n\t\tbuild(l);\n\t\tbuild(r - 1);\n\t}\n\n\ttemplate<class F>\n\tvoid update(size_type index, const F& f){\n\t\tassert(0 <= index && index < size());\n\t\tindex += size_;\n\t\tpropagate(index);\n\t\ttree[index] = f(::std::move(tree[index]));\n\t\tlazy[index] = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\n\t/*\n\ttemplate<class F>\n\tsize_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n\t\tif(f(value_structure::identity()))\n\t\t\treturn 0;\n\t\tif(!f(tree[1]))\n\t\t\treturn size_+1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile(i < \n\t}\n\t*/\n};\n\nclass ValueMonoid{\npublic:\n\tusing value_type = int;\n\tstatic value_type identity(){ return (1LL << 31)-1; }\n\tstatic value_type operation(value_type a, value_type b){\n\t\tif(a == identity())\n\t\t\treturn b;\n\t\treturn a;\n\t}\n};\n\nclass OpMonoid{\npublic:\n\tusing value_type = int;\n\tstatic value_type identity(){ return (1LL << 31)-1; }\n\tstatic value_type operation(value_type a, value_type b){\n\t\tif(b != identity())\n\t\t\treturn b;\n\t\treturn a;\n\t}\n};\n\nclass Modifier{\npublic:\n\tstatic ValueMonoid::value_type operation(\n\t\t\tValueMonoid::value_type a, OpMonoid::value_type b){\n\t\tif(b == OpMonoid::identity())\n\t\t\treturn a;\n\t\treturn b;\n\t}\n};\n\nvoid scan(int &d) {\n    d = 0;\n    int c;\n    while (c = fgetc(stdin), c == '\\n' || c == ' ');\n    do d = d * 10 + c - '0'; while (c = fgetc(stdin), c != '\\n'&&c != ' ');\n}\n\nint main(void){\n\tint n, q;\n\tint ty, s, t, x;\n\tscan(n); scan(q);\n\tLazySegTree<ValueMonoid, OpMonoid, Modifier> lsg(n);\n\twhile(q--){\n\t\tscan(ty);\n\t\tif(ty == 0){\n\t\t\tscan(s); scan(t); scan(x);\n\t\t\tlsg.update(s, t+1, x);\n\t\t}else{\n\t\t\tscan(s);\n\t\t\tprintf(\"%d\\n\", lsg.query(s, s+1));\n\t\t}\n\t}\n}\n\n/*\nverify: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3162647#1\n\t\t\t\thttp://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3162648#1\n\ntemplate<ValueMonoid, OperatorMonoid, Modifier, Container>\nclass LazySegTree\n\nValueMonoid\n\t- 役割\n\t\t- 扱う要素の値\n\t-\t要求\n\t\t- value_type\n\t\t- identity() -> value_type : 単位元を返す\n\t\t- operation(value_type, value_type) -> value_type : 演算結果を返す\n\t\t\n\t\t- 必要時\n\t\t\t- size_type value_type::len : ノードの幅\n\nOperatorMonoid\n\t- 役割\n\t\t- 扱う要素に適用させる値\n\t- 要求\n\t\t- value_type\n\t\t- identity() -> value_type : 単位元を返す\n\t\t- operation(value_type, value_type) -> value_type : 作用素を結合する\n\nModifier<ValueMonoid, OperatorMonoid>\n\t- 役割\n\t\t- OperatorMonoidをValueMonoidに適用させる\n\t- 要求\n\t\t- operation(value_type, operator_type) -> value_type : 作用素を適用させた結果を返す\n\nLazySegTree\n\t- 提供\n\t\t- query(size_type l, size_type r) -> value_type\n\t\t\t- 計算量 O(log N)\n\t\t\t- [l, r)までの計算結果\n\n\t\t- update(size_type l, size_type r, operator_type x)\n\t\t\t- 計算量 O(log N)\n\t\t\t- [l, r)にxを適用させた結果に変更する\n\n\t\t- update(size_type k, function f)\n\t\t\t- 計算量 O(log N)\n\t\t\t- kth elementをfを適用した結果に変更する\n\n\t\t* 未実装\n\t\t- search(function f) -> size_type\n\t\t\t- 計算量 O(log N)?\n\t\t\t- f([0, k)) is true and f([0, k+1)) is falseとなるkを返す\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pairInt;\ntypedef tuple<int, int, int> tuple3Int;\n#define FOR(i, n) for (int i = 0; i < int(n); i++)\n#define FOR1(i, m, n) for (int i = int(m); i < int(n); i++)\n#define MAX(a, b) ((a) >= (b) ? (a) : (b))\n#define MIN(a, b) ((a) <= (b) ? (a) : (b))\n\nll pow(ll base, uint exp) {\n  if (exp == 0)\n    return 1;\n\n  if (exp % 2 == 0) {\n    return pow(base * base, exp / 2);\n  } else {\n    return base * pow(base * base, exp / 2);\n  }\n}\n\nclass SegTree {\nprivate:\n  int num;\n  int exp;\n  int seq;\n  vector<pair<int, ll>> vec;\n\npublic:\n  SegTree(int n) : num(n), seq(0){\n    exp = 0;\n    int x = 1;\n    while (x < n) {\n      exp ++;\n      x <<= 1;\n    }\n\n    vec.resize(2 * pow(2, exp) - 1, make_pair(-1, pow(2, 31) - 1));\n  }\n\n  void update(int s, int t, ll x) {\n    _update(s, t, x, 0, 0, pow(2, exp) - 1);\n    seq ++;\n  }\n\n  ll get(int i) {\n    return _get(i, 0, 0, pow(2, exp) - 1).second;\n  }\n\nprivate:\n  void _update(int s, int t, ll x, int index, int from, int to) {\n    if (s <= from && to <= t) {\n      vec[index].first = seq;\n      vec[index].second = x;\n    } else {\n      if (s <= (from + to) / 2)\n        _update(s, t, x, 2 * index + 1, from, (from + to) / 2);\n\n      if ((from + to) / 2 < t)\n        _update(s, t, x, 2 * index + 2, (from + to) / 2 + 1, to);\n    }\n  }\n\n  pair<int, ll> _get(int i, int index, int from, int to) {\n    pair<int, ll> p;\n    if (from == to) {\n      return vec[index];\n    }\n\n    if (i <= (from + to) / 2)\n      p = _get(i, 2 * index + 1, from, (from + to) / 2);\n    else\n      p = _get(i, 2 * index + 2, (from + to) / 2 + 1, to);\n\n    if (p.first < vec[index].first)\n      return vec[index];\n    else\n      return p;\n  }\n\n};\n\nint main(int argc, char *argv[])\n{\n  int n, q;\n\n  scanf(\"%d%d\", &n, &q);\n\n  SegTree st(n);\n\n  FOR(i, q) {\n    int a;\n    scanf(\"%d\", &a);\n\n    if (a == 0) {\n      int s, t, x;\n      scanf(\"%d%d%d\", &s, &t, &x);\n      st.update(s, t, x);\n    } else {\n      int b;\n      scanf(\"%d\", &b);\n      printf(\"%lld\\n\", st.get(b));\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\ntemplate<class V> class segtree {\nprivate:\n    int n;\n    vector<V> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    segtree(vector<V> v) {\n        int sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        lazyFlag.resize(2*n-1,false);\n        rep(i,sz){\n            node[i+n-1] = v[i];\n        }\n        for(int i=n-2; i>=0; i--){\n            node[i] = min(node[i*2+1],node[i*2+2]);\n        }\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            range(a, b, x, 2*k+1, l, (l+r)/2);\n            range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return INT_MAX;\n        }\n        if(a <= l && r <= b){\n            return node[k];\n        }\n        V vl = query(a, b, 2*k+1, l, (l+r)/2);\n        V vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin >> n >> q;\n    segtree<int> sg(vector<int>(n,INT_MAX));\n    rep(i,q){\n        int k;\n        cin >> k;\n        if(k){\n            int x;\n            cin >> x;\n            cout << sg.query(x,x+1) << \"\\n\";\n        }else{\n            int x,y,z;\n            cin >> x >> y >> z;\n            sg.range(x,y+1,z);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n\n#define MOD 1000000007\nusing ll = long long;\n\nbool operator<(const pair<int, int>& a, const pair<int, int>& b) {\n\tif (a.first == b.first) {\n\t\treturn a.second < b.second;\n\t}\n\treturn a.first < b.first;\n}\n\n\nconst int sqrtN = 512;\n\nstruct SqrtDecomposition {\n\tint N, K;\n\tvector<pair<int,int>> data; //内部の値, どのタイミングで変更したか\n\tvector<pair<int, int>> bucketUpdate;\n\tSqrtDecomposition(int n) : N(n) {\n\t\tK = (N + sqrtN - 1) / sqrtN;\n\t\tdata.assign(K*sqrtN, make_pair(INT_MAX, 0));\n\t\tbucketUpdate.assign(K, make_pair(INT_MAX, 0));\n\t}\n\n\t// [s, t)\n\tvoid update(int s, int t, int x, int num) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tint l = k * sqrtN, r = (k + 1) *sqrtN;\n\t\t\tif (r <= s || t <= l) continue;\n\t\t\tif (s <= l && r <= t) {\n\t\t\t\tbucketUpdate[k] = make_pair(x, num);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = max(s, l); i < min(t, r); ++i) {\n\t\t\t\t\tdata[i] = make_pair(x, num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//[x, y)\n\tint find(int i) {\n\t\tint k = i / sqrtN;\n\t\tif (data[i].second > bucketUpdate[k].second) return data[i].first;\n\t\telse return bucketUpdate[k].first;\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tint n, q; cin >> n >> q;\n\tSqrtDecomposition sd(n);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tsd.update(s, t+1, x, i+1);\n\t\t}\n\t\telse {\n\t\t\tint t; cin >> t;\n\t\t\tcout << sd.find(t) << endl;\n\t\t}\n\t}\n\tint a; cin >> a;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define lP pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint n, q, s, t, x, u;\niP a[1<<18];\nbool b;\n\nint update(int s, int t, int x, int k, int l, int r, int i) {\n\tif (t < l || r < s)return 0;\n\telse if (s <= l&&r <= t) {\n\t\ta[k] = mkp(x, i);\n\t\treturn 0;\n\t}\n\telse {\n\t\tupdate(s, t, x, k * 2, l, (l + r) / 2, i);\n\t\tupdate(s, t, x, k * 2 + 1, (l + r) / 2 + 1, r, i);\n\t\treturn 0;\n\t}\n}\nint find(int x) {\n\tint y, z = -2;\n\tx += u;\n\twhile (x) {\n\t\tif (z < a[x].second) {\n\t\t\ty = a[x].first;\n\t\t\tz = a[x].second;\n\t\t}\n\t\tx /= 2;\n\t}\n\treturn y;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 1;; ++i) {\n\t\tif ((1 << i) / n >= 2) {\n\t\t\tu = (1 << i - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; i != u * 2; ++i)\n\t\ta[i] = mkp(intmax, -1);\n\tfor (int i = 0; i != q; ++i) {\n\t\tcin >> b >> s;\n\t\tif (b) {\n\t\t\tcout << find(s) << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> t >> x;\n\t\t\tupdate(s, t, x, 1, 0, u - 1, i);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\tDSL: domain-specific language\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\t12/5/2017\n\tTLE: 17/22 10^10 must change the data structure--> binary tree\n\tupdate the data: set the priority\n\tWA 2/22\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 131072 //100000\n#define MAXVAL ((long int) ((unsigned long) (1 << 31) - 1))\ntypedef struct Node{\n\tint val;\n\tint priority;\n}node;\nvoid find(int i);\nvoid add(int s,int t, int x,int i);\nnode array[2*N+100];      //the size of array, for present the tree\n//BEGIN FROM 1;\nint main(){\n\tint n = 0, q = 0;\n\tint a,b,c;\n\t//FILE *fp;\n\t//fp = fopen(\"in.txt\",\"r\");\n\tscanf(\"%d %d\",&n,&q);\n\t\n\t//how to calculate the beginning index (the last layer of the tree)\n\tint count = 0;\n\tint temp = n;\n\twhile(n!=1){\n\t\tn = n/2;\n\t\tcount++;  \n\t}\n\tif(pow(2,count)!=temp) count++;\n\t//printf(\"count:%d\",count);\n\tint B = pow(2,count)-1;\n\tn = temp;\n\tfor(int i = 0; i<=B;i++){ //special case forn==1, need i = 0;\n\t\tarray[i].val =  MAXVAL;\n\t\tarray[i].priority = 0;\n\t}\n\tfor(int i = 1; i<=n; i++){\n\t\tarray[i+B].val = MAXVAL;\t//e.g.begin from 8 (the last element of previous layer is 7)\n\t\tarray[i+B].priority = 0;\n\t}//printf(\"%d\\n\", array[B].val);\n\tB = B+1;\n\tfor(int i = 1; i <= q; i++){\n\t\tint temp = 0;\n\t\tscanf(\"%d\",&temp);\n\t\tif(temp==0){\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tadd(a+B,b+B,c,i);\n\t\t}\n\t\telse if(temp==1){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfind(a+B);\n\t\t}\n\t}\n\treturn 0;\n}\n//add elements\n//s means: left pointer\n//t means : right pointer\nvoid add(int s,int t, int x,int i){\n\t//signle node\n\tif(s==t) {\n\t\tarray[s].val = x;\n\t\tarray[s].priority = i;\n\t\treturn;\n\t}\n\t//range update\n\t//check the left pointer\n\twhile(s<t){\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t\tif(s%2==0){ //left child, level up\n\t\t\ts = s/2;\n\t\t}else{ //right child: mark and level up + 1\n\t\t\tarray[s].val = x;\n\t\t\tarray[s].priority = i;\n\t\t\ts = s/2;\n\t\t\ts++;\n\t\t}\n\t\t\n\t\tif(t%2==0){//left child: \n\t\t\tarray[t].val = x;\n\t\t\tarray[t].priority = i;\n\t\t\tt = t/2;\n\t\t\tt--;\n\t\t} else { //right child\n\t\t\tt/= 2; \t\n\t\t}\n\t\tif(s==t) {\n\t\t\tarray[s].val =x;\n\t\t\tarray[s].priority = i;\n\t\t}// works for 1-4,1-3, 1-5\n\t\t//printf(\"inside loop:s%d,t%d,s%d\\n\",s,t,x);\n\t}\n\t\n\t//test for \n\t/*for(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", i);\n\t}printf(\"\\n\");\n\tfor(int i = 1; i<20; i++){\n\t\tprintf(\"%2d \", array[i]);\n\t}*/\n\t\n}\n\nvoid find(int i) {//the index of the tree\n\tint res = array[i].val;\n\tint max = 0; //the priority\n\t//printf(\"%d\\n\", array[i].val);\n\twhile(i>=1){\n\t\tif(array[i].priority>max){\n\t\t\tres=array[i].val;\n\t\t\t//printf(\"array:%d\",res);\n\t\t\tmax = array[i].priority;\t\n\t\t}\n\t\ti = i/2;\n\t}\n\t\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nclass RangeAddorUpdateQuery // 0-index\n{\n    int const intmax = 2147483647;\n    int const intmin = 0;\n    vector<int> segtree;\n    vector<int> lazytree;\n    int n;\n    int k;\n\npublic:\n    RangeAddorUpdateQuery(int n1, int f = -1)\n    {\n        if (f == -1)\n            f = intmax;\n        else if (f == 0)\n            f = intmin;\n        int na = 1;\n        int ka = 0;\n        while (na < n1)\n        {\n            na *= 2;\n            ka++;\n        }\n        for (int i = 0; i < 2 * na; i++)\n        {\n            segtree.push_back(f);\n            lazytree.push_back(f);\n        }\n        n = na;\n        k = ka;\n    }\n\n    void lazyevaluation(int k, int l, int r)\n    {\n        if (lazytree[k] != intmax)\n        {\n            segtree[k] = lazytree[k];\n            if (r - l > 1) //最下段以外は一段下に伝播\n            {\n                lazytree[2 * k + 1] = lazytree[k];\n                lazytree[2 * k] = lazytree[k];\n            }\n            lazytree[k] = intmax;\n        }\n    }\n\n    void rangeupdate(int a, int b, int x, int k = 1, int l = 0, int r = -1) //閉区間 l <= x < r とする\n    {\n        if (r == -1)\n            r = n;\n        lazyevaluation(k, l, r);\n        if (r <= a || b <= l)\n            return;\n        if (a == l && b == r)\n        {\n            lazytree[k] = x;\n            lazyevaluation(k, l, r);\n        }\n        else\n        {\n            rangeupdate(a, min(b, (l + r) / 2), x, 2 * k, l, (l + r) / 2);\n            rangeupdate(max(a, (l + r) / 2), b, x, 2 * k + 1, (l + r) / 2, r);\n        }\n    }\n\n    int getmin(int a, int b, int k = 1, int l = 0, int r = -1) //閉区間 l <= x < r とする\n    {\n        if (r == -1)\n            r = n;\n        lazyevaluation(k, l, r);\n        if (r <= a || b <= l)\n            return intmax;\n        if (a == l && b == r)\n            return segtree[k];\n        else\n            return min(getmin(a, min(b, (l + r) / 2), 2 * k, l, (l + r) / 2), getmin(max(a, (l + r) / 2), b, 2 * k + 1, (l + r) / 2, r));\n    }\n    int getmax(int a, int b, int k = 1, int l = 0, int r = -1) //閉区間 l <= x < r とする\n    {\n        if (r == -1)\n            r = n;\n        lazyevaluation(k, l, r);\n        if (r <= a || b <= l)\n            return intmin;\n        if (a == l && b == r)\n            return segtree[k];\n        else\n            return min(getmax(a, min(b, (l + r) / 2), 2 * k, l, (l + r) / 2), getmax(max(a, (l + r) / 2), b, 2 * k + 1, (l + r) / 2, r));\n    }\n    int getsum(int a, int b, int k = 1, int l = 0, int r = -1) //閉区間 l <= x < r とする\n    {\n        if (r == -1)\n            r = n;\n        lazyevaluation(k, l, r);\n        if (r <= a || b <= l)\n            return intmin;\n        if (a == l && b == r)\n        {\n            return segtree[k];\n        }\n        else\n            return getsum(a, min(b, (l + r) / 2), 2 * k, l, (l + r) / 2) + getsum(max(a, (l + r) / 2), b, 2 * k + 1, (l + r) / 2, r);\n    }\n\n    void printsegtree()\n    {\n        for (int i = 0; i < 2 * n; i++)\n        {\n            cout << segtree[i] << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, q, k, c, s, t, x;\n    cin >> n >> q;\n    RangeAddorUpdateQuery segtree(n);\n\n    for (int i = 0; i < q; i++)\n    {\n        cin >> c;\n        if (c == 0)\n        {\n            cin >> s >> t >> x;\n            segtree.rangeupdate(s, t + 1, x);\n        }\n        else\n        {\n            cin >> x;\n            cout << segtree.getsum(x, x + 1) << endl;\n        }\n    }\n    return 0;\n}\n\n// getline(cin,s);\n// a = strtok(s, \",\");  \",\"で分解\n// for (int i = 0; i < n; i++)\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<math.h>\n#define INF ((1<<30)-1+(1<<30))\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,q;\nint m[210000];\n\nint init(int n)\n{\n\tint k = 1;\n\twhile (k < n) {\n\t\tk *= 2;\n\t}\n\tfor (int i = 0; i < 2 * k; i++) {\n\t\tm[i] = INF;\n\t}\n\treturn k;\n}\n\n//[l,r)???x?????´??°??????.[bottom,top),node??????????????????\nvoid update(int x, int l, int r, int bottom = 0, int top = n, int node = 1)\n{\n\tif (l <= bottom&&top <= r) {\n\t\tm[node] = x;\n\t\treturn;\n\t}\n\t\n\tif (top <= l || r <= bottom)return;\n\n\tint mid = (bottom + top) / 2;\n\n\t//-INF???????????????????????¨?????????????????????????????¨?????¨???\n\tif (m[node] != -INF) {\n\t\tm[2 * node] = m[node];\n\t\tm[2 * node + 1] = m[node];\n\t\tm[node] = -INF;\n\t}\n\tupdate(x, l, r, bottom, mid, 2 * node);\n\tupdate(x, l, r, mid, top, 2 * node + 1);\n}\n\nint find(int i, int bottom = 0,int top=n,int node=1) {\n\tif (i < bottom || top <= i)return -INF;\n\tif (m[node] != -INF)return m[node];\n\t\n\tint mid = (bottom + top) / 2;\n\tint l = find(i, bottom, mid, 2 * node);\n\tint r = find(i, mid, top, 2 * node + 1);\n\treturn max(l, r);\n}\n\nint main()\n{ \n\tcin >> n >> q;\n\n\tn=init(n);\n\n\tint a, s, t, x, k;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a;\n\t\tif (a == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(x, s, t + 1);\n\t\t}\n\t\tif (a == 1) {\n\t\t\tcin >> k;\n\t\t\tcout << find(k) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n \nint bucket[MAX/B][B];\nint data[MAX/B];\nvoid update(int a, int b, int x){\n    int f1 = 1, f2 = 1;\n    while(a <= b && a%B != 0){\n        if(f1 && data[a/B] != -1){\n            for(int i = 0;i < 100;i++)bucket[a/B][i] = data[a/B];\n            f1 = 0;data[a/B] = -1;\n        }\n        bucket[a/B][a%B] = x;\n        a++;\n    }\n    while(a <= b && b%B != 99){\n        if(f2 && data[b/B] != -1){\n            for(int i = 0;i < 100;i++)bucket[b/B][i] = data[b/B];\n            f2 = 0;data[b/B] = -1;\n        }\n        bucket[b/B][b%B] = x;\n        b--;\n    }\n    while(a < b){\n        data[a/B] = x;\n        a += B;\n    }\n}\n \nint find(int x){\n    if(data[x/B] != -1){\n        for(int i = 0;i < 100;i++)bucket[x/B][i] = data[x/B];\n        data[x/B] = -1;\n    }\n    return bucket[x/B][x%B];\n}\n \nint main(){\n    int n, q, c, s, t, x, ans;\n    scanf(\"%d%d\", &n, &q);\n    fill(data, data+MAX/B, -1);\n    fill((int*)bucket, (int*)(bucket+MAX/B), INF);\n    while(q--){\n        scanf(\"%d\", &c);\n        if(!c){\n            scanf(\"%d%d%d\", &s, &t, &x);\n            update(s, t, x);\n        }else{\n            scanf(\"%d\", &x);\n            ans = find(x);\n            printf(\"%d\\n\", ans);\n        }\n    }\n    //rep(i,n)printf(\"%d \", bucket[0][i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nstruct RUQ{\n\tusing T = int;\n\tT operator()(const T &a, const T &b) { return min(a,b); };\n\tstatic constexpr T identity() { return INT_MAX; }\n};\n\ntemplate<class Monoid>\nclass rangeUpdateQuery{\n\tprivate:\n\t\tusing T = typename Monoid::T;\n\t\tMonoid op;\n\t\tconst int n;\n\t\tvector<T> dat, lazy;\n\t\tint query(int a, int b, int k, int l, int r){\n\t\t\tevaluate(k);\n\n\t\t\tif(b <= l || r <= a) return INT_MAX;\n\t\t\telse if(a <= l && r <= b) return dat[k];\n\t\t\telse{\n\t\t\t\tint vl = query(a, b, k * 2, l, (l + r) / 2);\n\t\t\t\tint vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n\t\t\t\treturn min(vl, vr);\n\t\t\t}\n\t\t}\n\t\tinline void evaluate(int k){\n\t\t\tif(lazy[k] == op.identity()) return;\n\t\t\tdat[k] = lazy[k];\n\t\t\tif(k < n){\n\t\t\t\tlazy[2 * k] = lazy[k];\n\t\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = op.identity();\n\t\t}\n\t\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\t\tevaluate(k);\n\t\t\tif(r <= a || b <= l) return;\n\t\t\tif(a <= l && r <= b){\n\t\t\t\tlazy[k] = x;\n\t\t\t}else if(l < b && a < r){\n\t\t\t\tevaluate(k);\n\t\t\t\tupdate(a, b, k * 2, l, (l + r) / 2, x);\n\t\t\t\tupdate(a, b, k * 2 + 1, (l + r) / 2, r, x);\n\t\t\t}\n\t\t}\n\t\tint power(int n){\n\t\t\tint res = 1;\n\t\t\twhile(n >= res) res*=2;\n\t\t\treturn res;\n\t\t}\n\tpublic:\n\t\trangeUpdateQuery(int n) : n(power(n)), dat(4 * n, op.identity()), lazy(4 * n, op.identity()) {}\n\t\trangeUpdateQuery(const vector<T> &v) : n(v.size()), dat(4 * n), lazy(4 * n, op.identity()){\n\t\t\tcopy(begin(v), end(v), begin(dat) + n);\n\t\t\tfor(int i = n - 1; i > 0; i--) dat[i] = op(dat[2 * i], dat[2 * i + 1]);\n\t\t}\n\t\tint query(int a, int b){ return query(a,b,1,0,n); }\n\t\tvoid update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n\t\tint get(int a){ return query(a, a + 1); };\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\n\trangeUpdateQuery<RUQ> seg(n);\n\trep(i,q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(not com){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\t//cout << s << ' ' << t << endl;\n\t\t\tseg.update(s + 1, t + 2, x);\n\t\t}else{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tcout << seg.get(p + 1) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        cout << x[j] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int A[100000];\n    int i, s, t, x, n, q, ask;\n\n    for(i = 0; i < 100000; i++) A[i] = INT_MAX;\n\n    cin >> n >> q;\n\twhile(q){\n        q--;\n        cin >> ask;\n\t\tif(ask){\n            cin >> i;\n            cout << A[i] << endl;\n\t\t}else{\n            cin >> s >> t >> x;\n\t\t\tfor(i = s; i <= t; i++) A[i] = x;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LazySegmentTree{\npublic:\n\tint n = 1;\n\tvector<int> node[3], lazy;\n\tvector<bool> lazyF;\n\tvoid init(int N){\n\t\twhile(n < N)n *= 2;\n\t\trep(i,3)node[i].resize(2*n-1);\n\t\tlazy.resize(2*n-1);lazyF.resize(2*n-1, false);\n\t}\n\tvoid lazy_evaluate(int k){\n\t\tif(lazyF[k] == false)return;\n\t\trep(i,3)node[i][k] = lazy[k];\n\t\tif(k < n-1){\n\t\t\tlazy[2*k+1] = lazy[2*k+2] = lazy[k];\n\t\t\tlazyF[2*k+1] = lazyF[2*k+2] = true;\n\t\t}\n\t\tlazyF[k] = false;\n\t}\n\tvoid update(int a, int b, int x, int k, int l, int r){\n\t\tlazy_evaluate(k);\n\t\tif(r <= a || b <= l)return;\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = x;\n\t\t\tlazyF[k] = true;\n\t\t\tlazy_evaluate(k);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a, b, x, k*2+1, l, (l+r)/2);\n\t\tupdate(a, b, x, k*2+2, (l+r)/2, r);\n\t\tnode[0][k] = max(node[0][k*2+1], node[0][k*2+2]);\n\t\tnode[1][k] = min(node[1][k*2+1], node[1][k*2+2]);\n\t\tnode[2][k] = node[2][k*2+1]+node[2][k*2+2];\n\t}\n\tint calc(int a, int b, int k, int l, int r, int f){\n\t\tlazy_evaluate(k);\n\t\tif(r <= a || b <= l)return !f ? -INF : f==1 ? INF : 0;\n\t\tif(a <= l && r <= b)return node[f][k];\n\t\tint vl = calc(a, b, k*2+1, l, (l+r)/2, f);\n\t\tint vr = calc(a, b, k*2+2, (l+r)/2, r, f);\n\t\treturn !f ? max(vl, vr) : f==1 ? min(vl, vr) : vl+vr;\n\t}\n\tvoid replace(int a, int b, int x){update(a, b, x, 0, 0, n);}\n\tint get_max(int a, int b){return calc(a, b, 0, 0, n, 0);}\n\tint get_min(int a, int b){return calc(a, b, 0, 0, n, 1);}\n\tint get_sum(int a, int b){return calc(a, b, 0, 0, n, 2);}\n};\n\nsigned main(){\n\tint n, q, MAX = (1LL<<31)-1;\n\tscanf(\"%lld%lld\", &n, &q);\n\tLazySegmentTree seg;\n\tseg.init(n+1);\n\trep(i,n)seg.replace(i, i+1, MAX);\n\t\n\trrep(i,q){\n\t\tint c, s, t, x;\n\t\tscanf(\"%lld\",&c);\n\t\tif(c == 0){\n\t\t\tscanf(\"%lld%lld%lld\", &s, &t, &x);\n\t\t\tseg.replace(s, t+1, x);\n\t\t}else{\n\t\t\tscanf(\"%lld\", &x);\n\t\t\tprintf(\"%lld\\n\", seg.get_min(x, x+1));\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvoid Init();\nvoid update(int index, int value, int searchLeft, int searchRight, int left, int right);\nint find(int index, int searchLeft, int searchRight, int left, int right);\nvoid lazy_propagate(int index);\n\nconst int INF = INT_MAX;\n\nvector<int> tree;\nvector<int> lazy;\n\nint n, q;\n\n\nint main() {\n\n\tcin >> n >> q;\n\n\tInit();\n\n\tfor (int i = 0; i < q; i++) {\n\n\t\tint com, a, b, x;\n\t\tcin >> com;\n\n\t\tswitch (com) {\n\t\tcase 0:\n\t\t\tcin >> a >> b >> x;\n\t\t\tupdate(0, x, 0, n, a, b + 1);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tcin >> x;\n\t\t\tcout << find(0, 0, n, x, x + 1) << endl;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nvoid Init() {\n\n\tint _n = 1;\n\twhile (_n < n)\n\t\t_n *= 2;\n\tn = _n;\n\ttree = vector<int>(2 * n - 1, INF);\n\tlazy = vector<int>(2 * n - 1, -1);\n\n}\n\nvoid lazy_propagate(int index) {\n\n\n\tif (lazy[index] == -1)\n\t\treturn;\n\n\ttree[index] = lazy[index];\n\n\tif (index < n - 1) {\n\t\tlazy[index * 2 + 1] = lazy[index];\n\t\tlazy[index * 2 + 2] = lazy[index];\n\t}\n\tlazy[index] = -1;\n\n}\n\nvoid update(int index, int value, int searchLeft, int searchRight, int left, int right) {\n\n\tif (right <= searchLeft || searchRight <= left) {\n\t\tlazy_propagate(index);\n\t}\n\telse if (left <= searchLeft && searchRight <= right) {\n\t\tlazy[index] = value;\n\t\tlazy_propagate(index);\n\t}\n\telse {\n\t\tlazy_propagate(index);\n\n\t\tint mid = (searchLeft + searchRight) / 2;\n\t\tupdate(index * 2 + 1, value, searchLeft, mid, left, right);\n\t\tupdate(index * 2 + 2, value, mid, searchRight, left, right);\n\n\t\ttree[index] = min(tree[index * 2 + 1], tree[index * 2 + 2]);\n\t}\n\t\t\n\n}\n\nint find(int index, int searchLeft, int searchRight, int left, int right) {\n\n\tif (right <= searchLeft || searchRight <= left) {\n\t\treturn INF;\n\t}\n\telse if (left <= searchLeft && searchRight <= right) {\n\t\tlazy_propagate(index);\n\t\treturn tree[index];\n\t}\n\telse {\n\t\tlazy_propagate(index);\n\t\tint mid = (searchLeft + searchRight) / 2;\n\t\tint lValue = find(index * 2 + 1, searchLeft, mid, left, right);\n\t\tint rValue = find(index * 2 + 2, mid, searchRight, left, right);\n\t\treturn min(lValue, rValue);\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint t[(1<<18)];\n\nvoid Set(int a,int b,int x,int k=0,int l=0,int r=(1<<18)){\n  if(b<=l || r<=a)return;\n  if(a<=l && r<=b){\n    t[k]=max(t[k],x);\n    return;\n  }\n  int m=(l+r)/2;\n  Set(a,b,x,k*2+1,l,m);\n  Set(a,b,x,k*2+2,m,r);\n}\n\nint Get(int i){\n  i+=(1<<17)-1;\n  int res=t[i];\n  while(i){\n    i=(i-1)/2;\n    res=max(res,t[i]);\n  }\n  return res;\n}\n\nint n,q;\nint value[100002];\n\nint main(){\n  value[0]=2147483647;\n\n  scanf(\"%d %d\",&n,&q);\n  for(int i=1;i<=q;i++){\n    int type;\n    scanf(\"%d\",&type);\n    if(type==0){\n      int l,r;\n      scanf(\"%d %d %d\",&l,&r,&value[i]);\n      r++;\n      Set(l,r,i);\n    }else{\n      int target;\n      scanf(\"%d\",&target);\n      int ans=Get(target);\n      printf(\"%d\\n\",value[ans]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate<class T, class TUpdater>\nstruct RangeSegTreeT\n{\n\tint size;\n\tvector<T> tree;\n\tvector<pair<bool, T>> lazy;\n\tTUpdater updator;\n\tT initialValue;\n\n\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\t\n\tRangeSegTreeT(int count, TUpdater updator, T initialValue)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, lazy(size * 2)\n\t\t, updator(updator)\n\t\t, initialValue(initialValue)\n\t{\n\t\tlazy[1] = { true, initialValue };\n\t}\n\n\tvoid propagate(int l, int r, int i)\n\t{\n\t\tif (lazy[i].first)\n\t\t{\n\t\t\ttree[i] = updator(tree[i], lazy[i].second * (r - l));\n\t\t\tif (r - l > 1)\n\t\t\t{\n\t\t\t\tlazy[i * 2] = { true, updator(lazy[i * 2].second, lazy[i].second) };\n\t\t\t\tlazy[i * 2 + 1] = { true, updator(lazy[i * 2 + 1].second, lazy[i].second) };\n\t\t\t}\n\t\t\tlazy[i] = { false, 0 };\n\t\t}\n\t}\n\n\tvoid update_range(int begin, int end, T value) { update_range(begin, end, 1, 0, size, value); }\n\tT query(int begin, int end) { return query(begin, end, initialValue); }\n\tT query(int begin, int end, T initialValue) { return query(begin, end, 1, 0, size, initialValue); }\n\nprivate:\n\tvoid update_range(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpropagate(l, r, i);\n\n\t\tif (r <= s || e <= l) { return; }\n\t\tif (s <= l && r <= e) { lazy[i] = { true, updator(lazy[i].second, value) }; return; }\n\t\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { update_range(s, e, i * 2, l, m, value); }\n\t\tif (e > m) { update_range(s, e, i * 2 + 1, m, r, value); }\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tpropagate(l, r, i);\n\t\tif (r <= s || e <= l) { return value; }\n\t\tif (s <= l && r <= e) { return tree[i]; }\n\n\t\tint m = (l + r) / 2;\n\t\tif (s < m) { value = updator(value, query(s, e, i * 2, l, m, value)); }\n\t\tif (e > m) { value = updator(value, query(s, e, i * 2 + 1, m, r, value)); }\n\t\treturn value;\n\t}\n};\n\ntemplate <class T, class TUpdator = const T&(*)(const T&, const T&)>\nRangeSegTreeT<T, TUpdator> RangeSegTree(int n, TUpdator updator = min<T>, int initialValue = INF)\n{\n\treturn RangeSegTreeT<T, TUpdator>(n, updator, initialValue);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTree<int>(n, CONV2(a, b, b), 0);\n\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s, t+1, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, i);\n\t\t\tint v = tree.query(i, i + 1, 0);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n#include<vector>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ll a[n];\n\n  fill(a,a+n,2147483647);\n  REP(i,q){\n    int z;\n    cin >> z;\n    if(z == 0){\n      int s,t,x;\n      cin >> s >> t >> x;\n      if(s == t){\n\ta[s] = x;\n      }\n      else{\n\n\tfill_n(a+s,t-s+1,x);\n      }\n    }\n    else{\n      int x;\n      cin >> x;\n      cout << a[x] << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\nusing namespace std;\n#define MAX make_pair(-1,INT_MAX)\nvector<pair<int,int> > ary;\nint n;\nint right(int k){\n  return 2*k+2;\n}\nint left(int k){\n  return 2*k+1;\n}\nint parent(int k){\n  return (k-1)/2;\n}\nvoid update(int s,int t,int p,pair<int,int> x,int l,int r){\n  if(r<=s||t<=l)return;\n  if(s<=l&&r<=t)ary[p]=x;\n  else{\n    update(s,t,left(p),x,l,(l+r)/2);\n    update(s,t,right(p),x,(l+r)/2,r);\n  }\n}\nint query(int x){\n  x+=n-1;\n  pair<int,int> res=ary[x];\n  while(x>0){\n    x=parent(x);\n    res=(res<ary[x])?ary[x]:res;\n  }\n\n\n  return res.second;\n}\n\nvoid find(int x){\n  cout<<query(x)<<endl;\n}\n\nint main(){\n  int m,q,com,s,t,x,i=0;\n  cin>>n>>q;\n  while(n>pow(2,i))i++;\n  n = pow(2,i);\n  m = n*2-1;\n  ary.resize(m*2);\n  for(int i=0;i<m*2;i++)ary[i] = MAX;\n  for(int i=0;i<q;i++){\n    cin>>com;\n    if(!com){\n      cin>>s>>t>>x;\n      update(s,t+1,0,make_pair(i,x),0,n);\n    }\n    else{\n      cin>>x;\n      find(x);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\ntemplate<class T>\nclass sg_tree : public vector<T>{\nprivate:\n    lli n;\n    T default_value;\n    void _query(lli a,lli b,T x,lli k,lli l,lli r){\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) (*this)[k] = x;\n        else {\n            _query(a,b,x,k*2+1,l,(l+r)/2);\n            _query(a,b,x,k*2+2,(l+r)/2,r);\n            return;\n        }\n    }\npublic:\n    sg_tree():vector<T>(){\n\n    }\n    sg_tree(lli n,T d = -1):vector<T>(n*4,d){\n\t\tthis->n = 1;\n        while(n > this->n) this->n <<= 1;\n        this->default_value = d;\n    }\n    T update(lli i){\n        i += n - 1;\n        T ret = (*this)[i];\n        while(i > 0){\n            i = (i - 1) / 2;\n            ret = max(ret,(*this)[i]);\n        }\n        return ret;\n    }\n    void query(lli a,lli b,lli x){\n        _query(a,b,x,0,0,n);\n    }\n    T func(T a,T b){\n        return min(a,b);\n    }\n};\n\nlli n,q;\nlli c,s,t,x;\nlli k = 0;\nvll b;\n\nsg_tree<lli> sg;\n\nint main(){\n    cin >> n >> q;\n    sg = sg_tree<lli> (n);\n    for(lli i = 0;i < q;i++){\n        cin >> c;\n        if(c){\n            cin >> x;\n            lli t;\n            if((t = sg.update(x)) < 0) cout << INT_MAX << endl;\n            else cout << b[t] << endl;\n        }else{\n            cin >> s >> t >> x;\n            b.push_back(x);\n            sg.query(s,t+1,k);\n            k++;\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B&lang=ja\n#define _DEBUG\n#include \"bits/stdc++.h\"\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,a4,x,...) x\n#define debug_1(x1) cout<<#x1<<\": \"<<x1<<endl\n#define debug_2(x1,x2) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<endl\n#define debug_3(x1,x2,x3) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<endl\n#define debug_4(x1,x2,x3,x4) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<endl\n#define debug_5(x1,x2,x3,x4,x5) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<\", \"#x5<<\": \"<<x5<<endl\n#ifdef _DEBUG\n#define debug(...) CHOOSE((__VA_ARGS__,debug_5,debug_4,debug_3,debug_2,debug_1,~))(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n#define rep(index,num) for(int index=0;index<(int)num;index++)\n#define rep1(index,num) for(int index=1;index<=(int)num;index++)\n#define brep(index,num) for(int index=(int)num-1;index>=0;index--)\n#define brep1(index,num) for(int index=(int)num;index>0;index--)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=(ll)1e+18+1;\nint INF=1e+9+1;\n/* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築\n    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)\n    update(i,x): i 番目の要素を x に更新。O(log(n))\n    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))\n    内部は0-indexed\n*/\ntemplate <typename X, typename M>\nstruct SegTreeLazy {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazy(int n_, FX fx_, FA fa_, FM fm_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n    /* lazy eval */\n    void eval(int k) {\n        if (lazy[k] == em) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {            // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        // 自身を更新\n        dat[k] = fa(dat[k], lazy[k]);\n        lazy[k] = em;\n    }\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = fm(lazy[k], x);\n            eval(k);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return ex;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n};\n\nint main(){\n\tint N,Q;\n\tscan(N>>Q);\n    using X = int;\n    using M = int;\n    auto fx = [](X x1, X x2) -> X { return min(x1, x2); };\n    auto fa = [](X x, M m) -> X { return m; };\n    auto fm = [](M m1, M m2) -> M { return m2; };\n    int ex = numeric_limits<int>::max();\n    int em = numeric_limits<int>::max();\n    SegTreeLazy<X, M> seg(N, fx, fa, fm, ex, em);\n    rep(i,Q){\n        int q;\n        scan(q);\n        if(q==0){\n            int s,t;\n            ll x;\n            scan(s>>t>>x);\n            seg.update(s,t+1,x);\n        }\n        else{\n            int t;\n            scan(t);\n            prin(seg.query(t,t+1));\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nclass lazy_segment_tree{\n    private:\n        static int calc_size(int n){\n            int m = 1;\n            while(m < n){\n                m *= 2;\n            }\n            return m;\n        }\n\n        void eval(int i, int l, int r){\n            if(lazy[i] != 0){\n                node[i] = lazy[i];\n                if(r - l > 1){\n                    lazy[i * 2 + 1] = lazy[i];\n                    lazy[i * 2 + 2] = lazy[i];\n                }\n                lazy[i] = 0;\n            }\n        }\n\n        void add(int s, int t, int x, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return ;\n            }\n\n            if(s <= l && r <= t){\n                lazy[i] = x;\n                eval(i, l, r);\n                return;\n            }\n\n            int m = l + (r - l) / 2;\n            add(s, t, x, 2 * i + 1, l, m);\n            add(s, t, x, 2 * i + 2, m, r);\n            node[i] = node[2 * i + 1] + node[2 * i + 2];\n        }\n\n        T query(int s, int t, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return 0;\n            }\n\n            if(s <= l && r <= t){\n                return node[i];\n            }\n\n            int m = l + (r - l) / 2;\n            T vl = query(s, t, i * 2 + 1, l, m);\n            T vr = query(s, t, i * 2 + 2, m, r);\n            return vl + vr;\n        }\n\n    public:\n        int n;\n        vector<T> node, lazy;\n        T init;\n        function<T(T, T)> f;\n\n        lazy_segment_tree(int n, T init, function<T(T, T)> f)\n            : n(calc_size(n)), node(calc_size(n) * 2, init) , lazy(calc_size(n) * 2, 0), init(init), f(f) {}\n\n        void update(int i, const T& x){\n            node[i + n] = x;\n            for(int j = (i + n) / 2; j > 0; j /= 2){\n                node[j] = node[j * 2] + node[j * 2 + 1];\n            }\n        }\n\n        T query(int s, int t){\n            return query(s, t, 0, 0, n);\n        }\n\n        void add(int s, int t, int x){\n            add(s, t, x, 0, 0, n);\n        }\n};\n\nsigned main(){\n    int n, q;\n    cin >> n >> q;\n\n    lazy_segment_tree<int> lst(n+1, (1LL << 31)-1, [](int a, int b){return a+b;});\n    rep(i, q){\n        int qq;\n        cin >> qq;\n\n        if(qq == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            lst.add(s, t+1, x);\n        }\n\n        if(qq == 1){\n            int i;\n            cin >> i;\n            cout << lst.query(i, i+1) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\nconst ll INF = 1e17;\n\ntemplate<typename T, typename E, typename F, typename G, typename H>\nclass LazySegmentTree {\n  int n, height;\n  F f; G g; H h; const T ti; const E ei;\n  vector<T> dat; vector<E> laz; vector<int> highest;\n\n  void propagate(int k) {\n    if(laz[k] != ei) {\n      laz[2*k] = h(laz[2*k],laz[k]); laz[2*k+1] = h(laz[2*k+1],laz[k]);\n      dat[k] = g(dat[k],laz[k],n/highest[k]);\n      laz[k] = ei;\n    }\n  }\n  inline void recalc(int k) {\n    while(k >>= 1) dat[k] = f(g(dat[2*k],laz[2*k],n/highest[2*k]),g(dat[2*k+1],laz[2*k+1],n/highest[2*k+1]));\n  }\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\npublic:\n  LazySegmentTree(int _n, F f, G g, H h, T ti, E ei): f(f), g(g), h(h), ti(ti), ei(ei) {\n    n = 1; height = 0;\n    while(n < _n) n <<= 1, height++;\n    dat.assign(2*n,ti); laz.assign(2*n,ei); highest.assign(2*n,0);\n    int c = 1;\n    for(int i = 1; i < 2*n; i++) {\n      if(c*2 <= i) c <<= 1;\n      highest[i] = c;\n    }\n  }\n  void set(int k, T x) {\n    dat[k+n] = x;\n  }\n  void build() {\n    for(int i = n-1; i >= 0; i--) {\n      dat[i] = f(dat[2*i],dat[2*i+1]);\n    }\n  }\n  void update(int a, int b, const E x) {\n    thrust(a += n); thrust(b += n-1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) laz[l] = h(laz[l],x), ++l;\n      if(r & 1) --r, laz[r] = h(laz[r],x);\n    }\n    recalc(a); recalc(b);\n  }\n  T query(int a, int b) {\n    thrust(a += n); thrust(b += n-1);\n    T l = ti, r = ti; b++;\n    while(a < b) {\n      if(a & 1) l = f(l,g(dat[a],laz[a],n/highest[a])), a++;\n      if(b & 1) b--, r = f(g(dat[b],laz[b],n/highest[b]),r);\n      a >>= 1; b >>= 1;\n    }\n    return f(l,r);\n  }\n};\n\nint main(){\n  int n, q;\n  cin >> n >> q;\n  auto f = [](ll a, ll b){return a+b;};\n  auto g = [](ll a, ll b, int l){return b == INF ? a : b*l;};\n  auto h = [&](ll a, ll b) {return b;};\n  LazySegmentTree<ll,ll,decltype(f),decltype(g),decltype(h)> lst(n,f,g,h,0,INF);\n  rep(i,n) lst.set(i,((ll)1<<31)-1);\n  lst.build();\n  vector<ll> ans;\n  rep(i,q) {\n    int t;\n    cin >> t;\n    if(t == 0) {\n      int l, r; ll x;\n      cin >> l >> r >> x;\n      lst.update(l,r+1,x);\n    } else {\n      int p;\n      cin >> p;\n      ans.push_back(lst.query(p,p+1));\n    }\n  }\n  for(auto x : ans) cout << x << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto (i) = (a); (i) < (b); (i)++)\n#define rrep(i, a, b) for (auto (i) = (a); (i) > (b); (i)--)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\n\n#ifdef LOCAL_DEFINE\nstruct InitInput{\n  InitInput() {\n    FILE *stream1;\n    stream1=freopen(\"/Users/aim_cpo/CLionProjects/competitive/in.txt\",\"r\",stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n}LOCAL_INPUT;\nstruct LOCAL_OUTPUT{\n  LOCAL_OUTPUT() {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n}/*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showV(v, n) do{\\\nfor(int _i_t_e_=0; _i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(v)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA(a, n) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(a)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA2(a, n, m) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++){\\\nfor(int _i_t_e_2=0;_i_t_e_2<(m);_i_t_e_2++){\\\ncerr<<\"(\"<<_i_t_e_<<\", \"<<_i_t_e_2<<\" = \"<<(a)[_i_t_e_][_i_t_e_2]<<\") \";\\\n}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showV(v, n)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim{\n  InitAim() {\n    ios::sync_with_stdio(false);cin.tie(nullptr);\n    cout.precision(12);cout<<fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n}aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF=0x3f3f3f3f; //1061109567\nconstexpr const ll LL_INF=0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T> bool chmin(T &a, T b){return a>b?(a=b,true):false;}\ntemplate <typename T> bool chmax(T &a, T b){return a<b?(a=b,true):false;}\ntemplate <typename T> void ln(T i, T n){cout<<(i==n-1?\"\\n\":\" \");}\ntemplate<typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1) {\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1) {\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++) {\n    out << vector1[i];\n    if (i == vector1.size() - 1)out << \"]\"; else out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T> T LCM(T a, T b) {return a / GCD(a, b) * b;}\ntemplate <typename T> T EXTGCD(T a, T b, T& x, T& y) {\n  T d = a;\n  if (b != 0) {d=EXTGCD(b,a%b,y,x);y-=(a/b)*x;}\n  else x=1,y=0;\n  return d;\n}\ntemplate <typename T> bool is_prime(T a) {\n  for(int i=2;i*i<=a;i++)if(a%i==0)return true;\n  return false;\n}\ntemplate <typename T, typename S> T Pow(T a, S b) {\n  T res = 1, now = a;\n  while(b){if(b&1)res*=now;b>>=1;now*=now;}return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define add(a, b) ((a % MOD) + (b % MOD)) % MOD\n#define mul(a, b) ((a % MOD) * (b % MOD)) % MOD\n#define sub(a, b) ((a % MOD) + MOD - (b % MOD)) % MOD\ntemplate <typename T, typename S> T ModPow(T a, S b) {\n  T res = 1, now = a;\n  while(b){if(b&1)res=mul(res,now);b>>=1;now=mul(now,now);}return res;\n}\ntemplate <typename T> T mod_inverse(T a, T mod, bool prime){ // if mod is prime, \"prime\" is true.\n  if(prime)return ModPow(a, mod - 2);\n  else{T x,y;EXTGCD(a,mod,x,y);return (mod+x%mod)%mod;}\n}\n#define divide(a, b) ((a % MOD) * (mod_inverse(b, MOD, true))) % MOD\n\n//LLの数値をつかう時は最後にLLをつける癖をつけよう\n///////////////////////////////////////////////////////////////////////////////////\n// VARIABLE\n///////////////////////////////////////////////////////////////////////////////////\n\nint n, q;\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T, typename S = T>\nclass LazyIntervalTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, S, int)>;\n    using H = function<S(S, S)>;\npublic:\n    LazyIntervalTree(int n, const F f, const G g, const H h, const T &init, const S OM)\n    : f(f), g(g), h(h), init(init), OM(OM) {\n      size = 1;\n      while (size < n) size <<= 1;\n      data.assign(2 * size, init);\n      lazy.assign(2 * size, OM);\n    }\n    void set(int k, const T &x) {\n      data[k + size] = x;\n    }\n    void build() {\n      for (int i = size - 1; i > 0; i--) {\n        data[i] = f(data[2 * i], data[2 * i + 1]);\n      }\n    }\n    void propagate(int k, int len) {\n      if (lazy[k] != OM) {\n        if (k < size) {\n          lazy[2 * k] = h(lazy[2 * k], lazy[k]);\n          lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n        }\n        data[k] = g(data[k], lazy[k], len);\n        lazy[k] = OM;\n      }\n    }\n    T update(int a, int b, const S &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if (r <= a || b <= l) {\n        return data[k];\n      } else if (a <= l && r <= b) {\n        lazy[k] = h(lazy[k], x);\n        propagate(k, r - l);\n        return data[k];\n      } else {\n        return data[k] = f(update(a, b, x, 2 * k, l, (l + r) >> 1),\n          update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n    }\n    T update(int a, int b, const S &x) {\n      return update(a, b, x, 1, 0, size);\n    }\n    T query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if (r <= a || b <= l) {\n        return init;\n      } else if (a <= l && r <= b) {\n        return data[k];\n      } else {\n        return f(query(a, b, 2 * k, l, (l + r) >> 1),\n          query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n    }\n    T query(int a, int b) {\n      return query(a, b, 1, 0, size);\n    }\n    T operator[](const int &k) {\n      return query(k, k + 1);\n    }\n    void showLazy() {\n      for (int i = 0; i < (int)lazy.size(); i++) {\n        cout << lazy[i]; ln(i, (int) lazy.size());\n      }\n    }\nprivate:\n    int size;\n    vector <T> data;\n    vector <S> lazy;\n    const F f;\n    const G g;\n    const H h;\n    const T init;\n    const S OM;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n  cin >> n >> q;\n  LazyIntervalTree<ll, ll> seg(n, [](ll a, ll b){return min(a, b);}, [](ll a, ll b, int c){return b;}, [](ll a, ll b){return b;}, (1LL << 31) - 1, (1LL << 31) - 1);\n  rep(i, 0, q) {\n    int a; cin >> a;\n    if (a) {\n      int b; cin >> b;\n      cout << seg[b] << endl;\n    } else {\n      int l, r; ll x;\n      cin >> l >> r >> x;\n      seg.update(l, r + 1, x);\n    }\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<climits>\nusing namespace std;\nstatic const int MAX = 100000;\nint D[MAX];\nint n;\n \nint findMin(int a){\n  assert( 0 <= a && a < n );\n  return D[a];\n}\n \nmain(){\n  assert( INT_MAX == ((1LL<<31) -1) );\n  int q, s, t, x;\n  int ch;\n  cin >> n;\n  for ( int i = 0; i < n ;i++ ) D[i] = INT_MAX;\n  cin >> q;\n \n  for ( int i = 0; i < q; i++ ){\n    cin >> ch >> s;\n    if ( ch == 0 ){\n      cin >> t;\n      cin >> x;\n      for ( int k = s; k <= t; k++ ){\n    D[k] = x;\n      }\n    } else if ( ch == 1 ){\n      cout << findMin(s) << endl;\n    } else {\n      assert(false);\n    }\n  }\n   \n}"
  },
  {
    "language": "C++",
    "code": "/*\n　　　  ∧＿∧　やあ\n　　 （´・ω・｀)　　　　　/　　　　　ようこそ、バーボンハウスへ。\n　　 ／∇y:::::＼　　　 [￣]　　　　　このテキーラはサービスだから、まず飲んで落ち着いて欲しい。\n　　 |:⊃:|:::::|　　　|──|\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　うん、「また」なんだ。済まない。\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|￣　  仏の顔もって言うしね、謝って許してもらおうとも思っていない。\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣／|\n　　　　∇　∇　∇　∇　　　／.／|　　　でも、この提出を見たとき、君は、きっと言葉では言い表せない\n　　　　┴　┴　┴　┴　／ ／　  |　　　「ときめき」みたいなものを感じてくれたと思う。\n￣￣￣￣￣￣￣￣￣￣|／　　  |　　　殺伐としたコンテストの中で、そういう気持ちを忘れないで欲しい\n￣￣￣￣￣￣￣￣￣￣　　　　 |　　　そう思って、この提出を投げたんだ。\n　　　(⊆⊇)　(⊆⊇)　(⊆⊇)　　|\n　    ||　　 ||　　||　　|　　　 じゃあ、判定を聞こうか。\n　　.／|＼　／|＼ ／|＼\n*/\n\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define fst first\n#define snd second\n#define mp make_pair\n#define ALL(obj) (obj).begin(),(obj).end()\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n) \n#define SIZE(x) ((int)(x).size())\n#define debug(x) cerr << #x << \" -> \" << x << \" (line:\" << __LINE__ << \")\" << '\\n';\n#define debugpair(x, y) cerr << \"(\" << #x << \", \" << #y << \") -> (\" << x << \", \" << y << \") (line:\" << __LINE__ << \")\" << '\\n';\ntypedef long long lint;\ntypedef pair<int, int> pint;\ntypedef pair<lint, lint> plint;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> matrix;\ntypedef priority_queue<lint> p_que;\ntypedef priority_queue<lint, vector<lint>, greater<lint>> p_que_rev;\nconst lint INF = INT_MAX;\nconst lint LINF = LLONG_MAX;\nconst lint MOD = 1000000000 + 7;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nconst int di[]{0, -1, 0, 1, -1, -1, 1, 1};\nconst int dj[]{1, 0, -1, 0, 1, -1, -1, 1};\n\n\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<int> bucketLazy;\n  vector<bool> lazyflag;\n  int nil = INF;\n  SqrtDecomposition(int n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, nil);\n    bucketLazy.assign(K, nil);\n    lazyflag.assign(K, false);\n  }\n  void eval(int k){\n    if(lazyflag[k]){\n        lazyflag[k] = false;\n            for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n            data[i] = bucketLazy[k];\n        }\n    }\n  }\n  // [s, t)\n  void lazyupdate(int s, int t, int x) {\n    for (int k = 0; k < K; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l){continue;}\n      if (s <= l && r <= t) {\n        lazyflag[k] = true;\n        bucketLazy[k] = x;\n      } else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n  int get(int i) {\n    int k = i / sqrtN;\n    eval(k);\n    return data[i];\n  }\n};\n\n\nint n, q;\nint com, s, t, x, i;\n\nvoid input(){\n    cin >> n >> q;\n    return;\n}\n\nvoid solve(){\n    SqrtDecomposition koyaya(n);\n    REP(query, q){\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            koyaya.lazyupdate(s, t+1, x);\n        }\n        else {\n            cin >> i;\n            cout << koyaya.get(i) << endl;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][s]);\n            iter++;\n        }\n        \n        //PrintTree();\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        if(n == UNDEF){\n            if(Tree[level][key].value == UNDEF)\n                return UNDEF;\n            else if(level == Tree.size() - 1){\n                DownValue(level, key, before);\n                return UNDEF;\n            }\n            else{\n                DownValue(level, key, before);\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        DownValue(level, key, before);\n        UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        int pivot = (Tree[level][0].high - Tree[level][0].low) / 2;\n        Node now = Tree[level][0];\n        \n        if(Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF)\n            return Tree[level][0].value;\n        \n        if(target <= pivot)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        Node now = Tree[level][key];\n        int pivot = (Tree[level][key].high - Tree[level][key].low) / 2 + Tree[level][key].low;\n        \n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= pivot)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \n    void PrintTree(){\n        static ofstream fout(\"tree.txt\");\n        for(int i = (int)Tree.size() - 1; i >= 0; i--){\n            for(vector<Node>::size_type j = 0; j < Tree[i].size(); j++){\n                fout << \"(\";\n                if(Tree[i][j].value == MAX_VALUE)\n                    fout << \"∞\";\n                else\n                    fout << Tree[i][j].value;\n                fout << \", [\" << Tree[i][j].low << \", \" << Tree[i][j].high << \"])\";\n            }\n            fout << endl;\n        }\n        fout << endl;\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nlong long seg[262149], n, v, a, b, c, d, INF = (1LL << 31) - 1, size_ = 1;\nvoid update(long long p, long long q, long long r, long long s, long long t, long long u, long long v) {\n\tif (s <= p || q <= r) { if (v != INF)seg[u] = v; return; }\n\tif (p <= r && s <= q) { seg[u] = t; return; }\n\tlong long w = seg[u]; seg[u] = INF;\n\tupdate(p, q, r, (r + s) / 2, t, u * 2, w);\n\tupdate(p, q, (r + s) / 2, s, t, u * 2 + 1, w);\n}\nlong long find(long long p, long long q, long long r, long long s, long long u) {\n\tif (s <= p || q <= r)return INF;\n\tif ((r <= p && q <= s) && (seg[u] != INF || s - r == 1)) { return seg[u]; }\n\tlong long a1 = find(p, q, r, (r + s) / 2, u * 2);\n\tlong long a2 = find(p, q, (r + s) / 2, s, u * 2 + 1);\n\treturn min(a1, a2);\n}\nint main() {\n\tcin >> n >> v; while (size_ < n)size_ *= 2;\n\tfor (int i = 1; i <= size_ * 2; i++)seg[i] = INF;\n\tfor (int i = 1; i <= v; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a == 0) { scanf(\"%lld%lld%lld\", &b, &c, &d); c++; update(b, c, 0, size_, d, 1, INF); }\n\t\tif (a == 1) { scanf(\"%lld\", &b); printf(\"%lld\\n\", find(b, b + 1, 0, size_, 1)); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define RS resize\n#define CLR clear\n#define PB push_back\n#define ALL(x) (x).begin(), (x).end()\n#define LLI long long int\nusing namespace std;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename T, typename U> P<T,U> operator+(const P<T,U> &a, const P<T,U> &b){return {a.first + b.first, a.second + b.second};}\ntemplate <typename T, typename U> P<T,U> operator-(const P<T,U> &a, const P<T,U> &b){return {a.first - b.first, a.second - b.second};}\ntemplate <typename T> void cout_join(vector<T> &v,string d=\" \"){REP(i,v.size()){if(i>0)cout<<d;cout<<v[i];}cout<<endl;}\n\ntemplate <typename T = int>\nT minimum_power_2(T n){\n  T i = 1;\n  while(i<n) i = i<<1;\n  return i;\n}\n\ntemplate <typename T> class LazySegmentTree{\nprivate:\n  int size;\n  vector<T> vec;\n  function<T(T,T)> f, upd;\n  T e;\n\n  void propagate(int i){\n    if(i<size/2){\n      vec[i*2+1] = f(vec[i], vec[i*2+1]);\n      vec[i*2+2] = f(vec[i], vec[i*2+2]);\n      vec[i] = e;\n    }\n  }\n  \n  void update_aux(int s, int t, int i, int l, int r, T x){\n    if(r <= s || t <= l) return;\n    else if(s <= l && r <= t) vec[i] = upd(vec[i],x);\n    else{\n      propagate(i);\n      update_aux(s,t,i*2+1,l,(l+r)/2,x);\n      update_aux(s,t,i*2+2,(l+r)/2,r,x);\n    }\n  }\n  void find_aux(int i){if(i>0){find_aux((i-1)/2); propagate(i);}}\n\npublic:\n  LazySegmentTree(int n, T e, function<T(T,T)> f, function<T(T,T)> upd):\n    size(minimum_power_2(n)*2-1), vec(size, e), f(f), e(e), upd(upd){}\n  \n  void update(int s, int t, T x){update_aux(s,t,0,0,size/2+1,x);}\n\n  T find(int i){\n    int j=i+size/2;\n    find_aux((j-1)/2);\n    return vec[j];\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const int inf = INT_MAX;\n\n  int n,q; cin >> n >> q;\n  LazySegmentTree<int> ruq(n, inf, [](int a, int b){return a==inf?b:a;}, [](int a, int b){return b;});\n\n  REP(i,q){\n    int com; cin >> com;\n    switch(com){\n    case 0:\n      int s,t,x; cin >> s >> t >> x;\n      ruq.update(s,t+1,x);\n      break;\n    case 1:\n      int i; cin >> i;\n      cout << ruq.find(i) << endl;\n      break;\n    }\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate <typename M>\nclass LazySegmentTree {\n    using T1 = typename M::t1;\n    using T2 = typename M::t2;\n\nprivate:\n    const int n;\n    vector<T1> data;\n    vector<T2> lazy;\n\nprivate:\n    int size(int n) {\n        int res = 1;\n        while (res < n) res <<= 1;\n        return res;\n    }\n    void push(int node) {\n        if (lazy[node] == M::id2()) return;\n        if (node < n) {\n            lazy[node * 2] = M::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = M::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = M::op2(data[node], lazy[node]);\n        lazy[node] = M::id2();\n    }\n    T1 sub(int l, int r, int node, int lb, int ub) {\n        if (ub <= l || r <= lb) return M::id1();\n        if (l <= lb && ub <= r) return M::op2(data[node], lazy[node]);\n        push(node);\n        int c = (lb + ub) / 2;\n        return M::op1(sub(l, r, node * 2, lb, c), sub(l, r, node * 2 + 1, c, ub));\n    }\n    void suc(int l, int r, int node, int lb, int ub, T2 val) {\n        if (ub <= l || r <= lb) return;\n        if (l <= lb && ub <= r) {\n            lazy[node] = M::op3(lazy[node], val);\n            return;\n        }\n        push(node);\n        int c = (lb + ub) / 2;\n        suc(l, r, node * 2, lb, c, val);\n        suc(l, r, node * 2 + 1, c, ub, val);\n        data[node] = M::op1(M::op2(data[node * 2], lazy[node * 2])\n                        , M::op2(data[node * 2 + 1], lazy[node * 2 + 1]));\n    }\n\npublic:\n    LazySegmentTree(int n_)\n        : n(size(n_)), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {}\n    LazySegmentTree(int n_, T1 v1)\n        : n(size(n_)), data(n * 2, v1), lazy(n * 2, M::id2()) {}\n    LazySegmentTree(const vector<T1>& data_)\n        : n(size(data_.size())), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {\n        init(data_);\n    }\n    void init() {\n        for (int i = n - 1; i >= 1; i--) data[i] = M::op1(data[i * 2], data[i * 2 + 1]);\n    }\n    void init(const vector<T1>& data_) {\n        for (int i = 0; i < (int)data_.size(); i++) data[i + n] = data_[i];\n        init();\n    }\n    T1 find(int l, int r) {\n        return sub(l, r, 1, 0, n);\n    }\n    void update(int l, int r, T2 val) {\n        suc(l, r, 1, 0, n, val);\n    }\n};\n\n// 使い方\n// t1 := データ列の各値の型\n// t2 := 作用させる値の型\n// id1 := t1 の単位元\n// id2 := t2 の単位元\n// op1 := データ列を連結させる演算\n// op2 := t1 に t2 を作用させる演算\n// op3 := t2 同士の演算\n\nclass RU {\npublic:\n    using t1 = int;\n    using t2 = int;\n\n    static t1 id1() {\n        return 0;\n    }\n    static t2 id2() {\n        return -1;\n    }\n    static t1 op1(const t1& l, const t1& r) {\n        return l + r;\n    }\n    static t1 op2(const t1& l, const t2& r) {\n        return r != id2() ? r : l;\n    }\n    static t2 op3(const t2& l, const t2& r) {\n        return r != id2() ? r : l;\n    }\n};\n\nsigned main(){\n    \n\n    int n, q; cin >> n >> q;\n    LazySegmentTree<RU> sg(n, INT_MAX);\n\n    for(int i = 0; i < q; i++){\n        int com; cin >> com;\n        if(com == 0){\n            int s, t, x; cin >> s >> t >> x;\n            sg.update(s, t + 1, x);\n        }else{\n            int i; cin >> i;\n            cout << sg.find(i, i + 1) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Range Update Query\n// ???[s, t) ???????´???? x ??????????????¨???\n// ???i ?????????????´????????????????????????¨???\nconst int INF = (1LL << 31) - 1;\nconst int sqrtN = 512;\nstruct SqrtDecomposition {\n  int N, K;\n  vector<int> data;\n  vector<bool> lazyFlag;\n  vector<int> lazyUpdate;\n  SqrtDecomposition(int n) : N(n) {\n    // ?????±????????°??? N ??? sqrtN ??§?????£???????????????????????? ????????????\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, INF);\n    lazyFlag.assign(K, false);\n    lazyUpdate.assign(K, 0);\n  }\n\n  // ?????§??????????????±????????? lazyUpdate ???????????\\??£???????????´??????\n  // lazyUpdate ?????\\??£?????????????????????????????? (?????¶??????)\n  // ?????±??????????????????????????? update ?????¨?????????????????? find ?????¨???????????????\n  // ????????????????????????????????????\n  void eval(int k) {\n    if (lazyFlag[k]) {\n      lazyFlag[k] = false;\n      for (int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n    }\n  }\n\n  // update [s, t)\n  void update(int s, int t, int x) {\n    for (int k = 0; k < K; ++k) {\n      // ?????±?????????????????¨??????\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      // ?????????\n      if (r <= s || t <= l)\n        continue;\n      // ?????±??????????¢????????????????\n      // ??? ?????±????????¨????????????????????´????????§ lazeUpdate ????????¨??????\n      if (s <= l && r <= t) {\n        lazyFlag[k] = true;\n        lazyUpdate[k] = x;\n      }\n      // ?????±????????????????????§?????? ??? ??????????????´?????? O(\\sqrt N)\n      else {\n        eval(k);\n        for (int i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n      }\n    }\n  }\n\n  // find index i\n  int find(int i) {\n    // k <- ??????????????±????????????????????????\n    int k = i / sqrtN;\n    eval(k);\n    return data[i];\n  }\n};\n\nint main() {\n  int n, q; cin >> n >> q;\n  SqrtDecomposition R(n);\n  for(int i=0; i<q; i++) {\n    int num; cin >> num;\n    if(num == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      R.update(s, t+1, x);\n    }\n    else {\n      int idx; cin >> idx;\n      cout << R.find(idx) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////\n// 双対セグメント木 //\n//////////////////////\n\n// Element_tを列の要素の集合として、要件は以下\n// Transformation_tはElement_t上の変換全体の集合、(Monoid_t, operate_, identity_)はモノイド\n// 準同型写像homoMorphism:Monoid_t->Transformation_tによりMonoid_tとTransformation_tは準同型\n// これらの要件を満たすとき、Transformation_tの要素を区間に作用させた場合の最終的な合成写像を返す\ntemplate <typename Monoid_t, typename Operation_t, typename HomoMorphism_t>\nclass DualSegmentTree {\nprivate:\n\tconst Operation_t operate_;\n\tconst Monoid_t identity_;\n\tconst HomoMorphism_t homoMorphism_;\n\tstd::vector<Monoid_t> container_;\n\n\tvoid build(const unsigned int array_size)\n\t{\n\t\tunsigned int length{1};\n\t\twhile (length < array_size)\n\t\t\tlength <<= 1;\n\t\tcontainer_.resize(2 * length, identity_);\n\t}\n\n\t// 新しい演算ほど左にくるようにする(写像の合成と同じ順番)\n\tvoid updateHelper(const int query_l, const int query_r, const Monoid_t& added, const int node_i, const int node_l, const int node_r)\n\t{\n\t\tif (query_r <= node_l || node_r <= query_l) return;\n\n\t\tMonoid_t& monoid{container_[node_i]};\n\t\tif (query_l <= node_l && node_r <= query_r)\n\t\t{\n\t\t\tmonoid = operate_(added, monoid);\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer_[2 * node_i] = operate_(monoid, container_[2 * node_i]);\n\t\tcontainer_[2 * node_i + 1] = operate_(monoid, container_[2 * node_i + 1]);\n\t\tmonoid = identity_;\n\t\n\t\tconst int node_m{(node_l + node_r) >> 1};\n\t\tupdateHelper(query_l, query_r, added, 2 * node_i, node_l, node_m);\n\t\tupdateHelper(query_l, query_r, added, 2 * node_i + 1, node_m, node_r);\n\t}\n\npublic:\n\t// initial_elementで要素配列を初期化\n\tDualSegmentTree(\n\t\tconst unsigned int array_size,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n\t\t: operate_(operate), identity_(identity), homoMorphism_(homoMorphism)\n\t{\n\t\tbuild(array_size);\n\t}\n\n\t// left,rightは0-indexed、半開区間[left,right)にhomoMorphism(operate)を施す\n\tvoid update(const int left, const int right, const Monoid_t added)\n\t{\n\t\tupdateHelper(left, right, added, 1, 0, container_.size() >> 1);\n\t}\n\n\t// indexは0-indexed、indexの要素を返す\n\tauto get(const int index) const\n\t{\n\t\tMonoid_t monoid{identity_};\n\t\tfor (int monoid_i{((int)container_.size() >> 1) + index}; monoid_i > 0; monoid_i >>= 1)\n\t\t\tmonoid = operate_(container_[monoid_i], monoid);\n\n\t\treturn homoMorphism_(monoid);\n\t}\n};\n\ntemplate <typename Monoid_t, typename Operation_t, typename HomoMorphism_t>\ndecltype(auto) makeDualSegmentTree(\n\t\tconst unsigned int array_size,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n{\n\treturn DualSegmentTree<Monoid_t, Operation_t, HomoMorphism_t>(\n\t\t\tarray_size, operate, identity, homoMorphism\n\t\t);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tauto dst(\n\t\tmakeDualSegmentTree(\n\t\t\tn,\n\t\t\t[](const int64_t left, const int64_t right)\n\t\t\t{\n\t\t\t\treturn left >= 0?left:right;\n\t\t\t},\n\t\t\t-1ll,\n\t\t\t[](const int64_t monoid)\n\t\t\t{\n\t\t\t\treturn [=](const int64_t argument)\n\t\t\t\t{\n\t\t\t\t\treturn monoid >= 0? monoid: argument;\n\t\t\t\t};\n\t\t\t}\n\t\t)\n\t);\n\n\tfor (int q_i{}; q_i < q; q_i++)\n\t{\n\t\tint com;\n\t\tscanf(\"%d\", &com);\n\t\tif (com)\n\t\t{\n\t\t\tint i;\n\t\t\tscanf(\"%d\", &i);\n\t\t\tprintf(\"%lld\\n\", dst.get(i)((1ll << 31) - 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s, t, x;\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tt++;\n\t\t\tdst.update(s, t, x);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define moder (int)(1e9+7)\n#define inf (int)(3e18+7)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define P pair<int,int>\n#define all(v) v.begin(),v.end()\n#define mkp make_pair\n#define mkt make_tuple\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define vecunique(vec) sort(vec.begin(), vec.end());decltype(vec)::iterator result = std::unique(vec.begin(), vec.end());vec.erase(result, vec.end())\nusing namespace std;\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)return false;\n\t}\n\treturn x > 1;\n}\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x * y / gcd(x, y);\n}\nint kai(int x) {\n\tif (x == 0)return 1;\n\treturn kai(x - 1) * x % moder;\n}\nint mod_pow(int x, int y, int mod) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % mod;\n\t\t}\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint comb(int x, int y) {\n\treturn kai(x)* mod_pow(kai(x - y), moder - 2, moder) % moder * mod_pow(kai(y), moder - 2, moder) % moder;\n}\n/*--------Library Zone!--------*/\n\nstruct LazySegtree {\nprivate:\n\tint size_;\n\tstring type;\n\tP dat[1000000];\n\tvoid init_RUQ() {\n\t\tint x = size_; size_ = 1;\n\t\twhile (x > size_)size_ *= 2;\n\t\trep(i, size_ * 2 - 1) {\n\t\t\tdat[i] = { (1 << 31) - 1,inf };\n\t\t}\n\t}\n\tvoid eval_RUQ(int k, int l, int r) {\n\t\tif (dat[k].second != inf) {\n\t\t\tdat[k].first = dat[k].second;\n\t\t\tif (r - l > 1) {\n\t\t\t\tdat[2 * k + 1].second = dat[k].second;\n\t\t\t\tdat[2 * k + 2].second = dat[k].second;\n\t\t\t}\n\t\t\tdat[k].second = inf;\n\t\t}\n\t}\n\tvoid update_RUQ(int a, int b, int x, int k, int l, int r) {\n\t\teval_RUQ(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat[k].second = x;\n\t\t\teval_RUQ(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate_RUQ(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate_RUQ(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t}\n\t}\npublic:\n\tLazySegtree(int x, string s) {\n\t\tsize_ = x; type = s;\n\t\tif (type == \"RUQ\")init_RUQ();\n\t}\n\tvoid update(int l, int r, int x) {\n\t\tif (type == \"RUQ\")update_RUQ(l, r, x, 0, 0, size_);\n\t}\n\tint query_RUQ(int a, int k, int l, int r) {\n\t\teval_RUQ(k, l, r);\n\t\tif (r - l == 1) {\n\t\t\treturn dat[k].first;\n\t\t}\n\t\tif (a < (l + r) / 2)return query_RUQ(a, k * 2 + 1, l, (l + r) / 2);\n\t\telse return query_RUQ(a, k * 2 + 2, (l + r) / 2, r);\n\t}\n\tint query(int x) {\n\t\treturn query_RUQ(x, 0, 0, size_);\n\t}\n};\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tLazySegtree segtree(n, \"RUQ\");\n\trep(i, q) {\n\t\tint a; cin >> a;\n\t\tif (!a) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tsegtree.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint x; cin >> x;\n\t\t\tcout << segtree.query(x) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// Segment tree. Assignment on interval, single element access.\ntemplate<typename T>\nclass SegTree{\n    size_t n;\n    int h;\n    vector<T> data;\n    vector<bool> used;\n    static T combine(T L, T R){\n        return max(L, R);\n    }\n    void apply(size_t i, T v){\n        data[i] = v;\n        used[i] = true;\n    }\n    void push(size_t p){       // propagates the changes from the root to node p.\n        for (int s = h; s > 0; --s){\n            size_t i = p >> s;\n            if (used[i]){\n                apply(i*2, data[i]);\n                apply(i*2+1, data[i]);\n                used[i] = false;\n            }\n        }\n    }\n    int calc_h(size_t nn){\n        int hh = 1;\n        for (; nn > 1; ++hh, nn >>= 1);\n        return hh;\n    }\n\npublic:\n    SegTree(size_t _n): n(_n), h(calc_h(n)), data(vector<T>(2 * n, numeric_limits<int>::max())), used(vector<bool>(2 * n, false)){used[1] = true;}\n    SegTree(const vector<T> &src): n(src.size()), h(calc_h(n)), data(vector<T>(2 * n, 0)), used(vector<bool>(2 * n, false)){init(src);}\n    void init(const vector<T> &src) {for (size_t i = 0; i != n; ++i) apply(n + i, src[i]);}\n    void modify(size_t L, size_t R, T v){  // assign v to range [L, R)\n        L += n;\n        R += n;\n        push(L);\n        push(R - 1);\n        for (; L < R; L >>= 1, R >>= 1){\n            if (L & 1) apply(L++, v);\n            if (R & 1) apply(--R, v);\n        }\n    }\n    T query(size_t i){\n        push(i + n);\n        return data[i + n];\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    SegTree<int> seg(n);\n    while (q--){\n        int c;\n        cin >> c;\n        if (c == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.modify(s, t + 1, x);\n        }\n        else{\n            int i;\n            cin >> i;\n            cout << seg.query(i) << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"dual_segment_tree.test.cpp\"\n\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_D\"\n\n#line 2 \"/Users/kodamankod/Desktop/Programming/Library/container/dual_segment_tree.cpp\"\n\n#line 2 \"/Users/kodamankod/Desktop/Programming/Library/other/bit_operation.cpp\"\n\n#include <cstddef>\n#include <cstdint>\n\nconstexpr size_t bit_ppc(const uint64_t x) {\n  return __builtin_popcountll(x);\n}\n\nconstexpr size_t bit_ctzr(const uint64_t x) {\n  return x == 0 ? 64 : __builtin_ctzll(x);\n}\n\nconstexpr size_t bit_ctzl(const uint64_t x) {\n  return x == 0 ? 64 : __builtin_clzll(x);\n}\n\nconstexpr size_t bit_width(const uint64_t x) { \n  return 64 - bit_ctzl(x);\n}\n\nconstexpr uint64_t bit_msb(const uint64_t x) {\n  return x == 0 ? 0 : uint64_t(1) << (bit_width(x) - 1);\n}\n\nconstexpr uint64_t bit_lsb(const uint64_t x) {\n  return x & (-x);\n}\n\nconstexpr uint64_t bit_cover(const uint64_t x) {\n  return x == 0 ? 0 : bit_msb(2 * x - 1);\n}\n\nconstexpr uint64_t bit_rev(uint64_t x) {\n  x = ((x >> 1) & 0x5555555555555555) | ((x & 0x5555555555555555) << 1);\n  x = ((x >> 2) & 0x3333333333333333) | ((x & 0x3333333333333333) << 2);\n  x = ((x >> 4) & 0x0F0F0F0F0F0F0F0F) | ((x & 0x0F0F0F0F0F0F0F0F) << 4);\n  x = ((x >> 8) & 0x00FF00FF00FF00FF) | ((x & 0x00FF00FF00FF00FF) << 8);\n  x = ((x >> 16) & 0x0000FFFF0000FFFF) | ((x & 0x0000FFFF0000FFFF) << 16);\n  x = (x >> 32) | (x << 32);\n  return x;\n}\n\n/**\n * @title Bit Operations\n */\n#line 1 \"/Users/kodamankod/Desktop/Programming/Library/other/monoid.cpp\"\n\n#include <type_traits>\n#include <utility>\n\ntemplate <class T, class = void>\nclass has_identity: public std::false_type { };\n\ntemplate <class T>\nclass has_identity<T, typename std::conditional<false, decltype(T::identity()), void>::type>: public std::true_type { };\n\ntemplate <class T, bool HasIdentity>\nclass fixed_monoid_impl: public T {\npublic:\n  static constexpr typename T::type convert(const typename T::type &value) { return value; }\n  static constexpr typename T::type revert(const typename T::type &value) { return value; }\n\n};\n\ntemplate <class T>\nclass fixed_monoid_impl<T, false>: private T {\npublic:\n  class type {\n  public:\n    typename T::type value;\n    bool state;\n  \n    explicit constexpr type(): value(typename T::type { }), state(false) { }\n    explicit constexpr type(const typename T::type &value): value(value), state(true) { }\n\n  };\n\n  static constexpr type convert(const typename T::type &value) { return type(value); }\n  static constexpr typename T::type revert(const type &value) { return value.value; }\n\n  static constexpr type identity() { return type(); }\n  static constexpr type operation(const type &v1, const type &v2) {\n    if (!v1.state) return v2;\n    if (!v2.state) return v1;\n    return type(T::operation(v1.value, v2.value));\n  }\n\n};\n\ntemplate <class T>\nusing fixed_monoid = fixed_monoid_impl<T, has_identity<T>::value>;\n\ntemplate <class T, bool HasIdentity>\nclass fixed_combined_monoid_impl {\npublic:\n  using value_structure    = typename T::value_structure;\n  using operator_structure = fixed_monoid<typename T::operator_structure>;\n\n  template <class... Args>\n  static constexpr typename value_structure::type operation(\n    const typename value_structure::type    &val,\n    const typename operator_structure::type &op,\n    Args&&... args) {\n    return T::opration(val, op, std::forward<Args>(args)...);\n  }\n\n};\n\ntemplate <class T>\nclass fixed_combined_monoid_impl<T, false> {\npublic:\n  using value_structure    = typename T::value_structure;\n  using operator_structure = fixed_monoid<typename T::operator_structure>;\n\n  template <class... Args>\n  static constexpr typename value_structure::type operation(\n    const typename value_structure::type    &val,\n    const typename operator_structure::type &op,\n    Args&&... args) {\n    if (!op.state) return val;\n    return T::operation(val, op.value, std::forward<Args>(args)...);\n  }\n\n};\n\ntemplate <class T>\nusing fixed_combined_monoid = fixed_combined_monoid_impl<T, has_identity<typename T::operator_structure>::value>;\n#line 6 \"/Users/kodamankod/Desktop/Programming/Library/container/dual_segment_tree.cpp\"\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\ntemplate <class CombinedMonoid>\nclass dual_segment_tree {\npublic:\n  using structure       = CombinedMonoid;\n  using value_type      = typename CombinedMonoid::value_structure::type;\n  using operator_monoid = typename CombinedMonoid::operator_structure;\n  using operator_type   = typename CombinedMonoid::operator_structure::type;\n  using size_type       = size_t;\n\nprivate:\n  using fixed_structure       = fixed_combined_monoid<structure>;\n  using fixed_operator_monoid = typename fixed_structure::operator_structure;\n  using fixed_operator_type   = typename fixed_operator_monoid::type;\n\n  static void S_apply(fixed_operator_type &op, const fixed_operator_type &add) {\n    op = fixed_operator_monoid::operation(op, add);\n  }\n\n  void M_propagate(const size_type index) {\n    S_apply(M_tree[index << 1 | 0], M_tree[index]);\n    S_apply(M_tree[index << 1 | 1], M_tree[index]);\n    M_tree[index] = fixed_operator_monoid::identity();\n  }\n\n  void M_pushdown(const size_type index) {\n    const size_type lsb = bit_ctzr(index);\n    for (size_type story = bit_width(index); story != lsb; --story) {\n      M_propagate(index >> story);\n    }\n  }\n\n  std::vector<value_type> M_leaves; \n  std::vector<fixed_operator_type> M_tree;\n\npublic:\n  dual_segment_tree() = default;\n  explicit dual_segment_tree(const size_type size) { initialize(size); }\n  template <class InputIterator>\n  explicit dual_segment_tree(InputIterator first, InputIterator last) { construct(first, last); }\n\n  void initialize(const size_type size) {\n    clear();\n    M_leaves.assign(size, value_type{});\n    M_tree.assign(size << 1, fixed_operator_monoid::identity());\n  }\n\n  template <class InputIterator>\n  void construct(InputIterator first, InputIterator last) {\n    clear();\n    const size_type size = std::distance(first, last);\n    M_leaves.reserve(size);\n    std::copy(first, last, std::back_inserter(M_leaves));\n    M_tree.assign(size << 1, fixed_operator_monoid::identity());\n  }\n\n  value_type at(size_type index) const {\n    const size_type index_c = index;\n    index += size();\n    fixed_operator_type op = M_tree[index];\n    while (index != 1) {\n      index >>= 1;\n      S_apply(op, M_tree[index]);\n    }\n    return fixed_structure::operation(M_leaves[index_c], op);\n  }\n\n  void operate(size_type first, size_type last, const operator_type &op_) {\n    const auto op = fixed_operator_monoid::convert(op_);\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    while (first != last) {\n      if (first & 1) {\n        S_apply(M_tree[first], op);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        S_apply(M_tree[last], op);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n  }\n\n  void assign(size_type index, const value_type &val) {\n    const size_type index_c = index;\n    index += size();\n    for (size_type story = bit_width(index); story != 0; --story) {\n      M_propagate(index >> story);\n    }\n    M_tree[index] = fixed_operator_monoid::identity();\n    M_leaves[index_c] = val;\n  }\n\n  void clear() {\n    M_leaves.clear();\n    M_leaves.shrink_to_fit();\n    M_tree.clear();\n    M_tree.shrink_to_fit();\n  }\n\n  size_type size() const { \n    return M_leaves.size();\n  }\n\n};\n\n/**\n * @title Dual Segment Tree\n */\n#line 5 \"dual_segment_tree.test.cpp\"\n\n#line 9 \"dual_segment_tree.test.cpp\"\n#include <iostream>\n\nstruct dst_monoid {\n  struct value_structure {\n    using type = uint32_t;\n  };\n  struct operator_structure {\n    using type = uint32_t;\n    static type operation(const type&, const type &v2) {\n      return v2;\n    }\n  };\n  static typename value_structure::type operation(\n    const typename value_structure::type    &,\n    const typename operator_structure::type &op) {\n    return op;\n  }\n};\n\nint main() {\n  size_t N, Q;\n  std::cin >> N >> Q;\n  dual_segment_tree<dst_monoid> seg;\n  {\n    std::vector<uint32_t> build(N, (uint32_t(1) << 31) - 1);\n    seg.construct(build.begin(), build.end());\n  }\n  while (Q--) {\n    size_t type;\n    std::cin >> type;\n    if (type == 0) {\n      size_t s, t;\n      std::cin >> s >> t;\n      uint32_t x;\n      std::cin >> x;\n      seg.operate(s, t + 1, x);\n    }\n    else {\n      size_t i;\n      std::cin >> i;\n      std::cout << seg.at(i) << '\\n';\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass Segment_Tree {\n\tvector<long long int>v;\n\tvector<long long int>add;\n\tvector<long long int>modi;\n\tvector<int>l;\n\tvector<int>r;\n\tint num;\n\tlong long int ret;\n\tbool is_min;\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tif (is_min) {\n\t\t\tv[place] = min(Update(place * 2), Update(place * 2 + 1));\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = max(Update(place * 2), Update(place * 2 + 1));\n\t\treturn v[place];\n\t}\n\tvoid Modify(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tmodi[place] = num;\n\t\t\tv[place] = num;\n\t\t\tadd[place] = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tModify(a, b, num, place * 2);\n\t\tModify(a, b, num, place * 2 + 1);\n\t\tif(is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\n\tvoid Add(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tadd[place] += num;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tAdd(a, b, num, place * 2);\n\t\tAdd(a, b, num, place * 2 + 1);\n\t\tif (is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\n\tvoid RMQ(int a, int b, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tif (is_min)ret = min(ret, v[place] + add[place]);\n\t\t\telse ret = max(ret, v[place] + add[place]);\n\t\t\treturn;\n\t\t}\n\t\tif (l[place]>b || r[place]<a) return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tRMQ(a, b, place * 2);\n\t\tRMQ(a, b, place * 2 + 1);\n\t\treturn;\n\t}\npublic:\n\tSegment_Tree(int n, bool min) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2) {\n\t\t\tnum *= 2;\n\t\t}\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tis_min = min;\n\t\tif (min) {\n\t\t\tv.resize(num, LLONG_MAX);\n\t\t}\n\t\telse v.resize(num, LLONG_MIN);\n\t\tadd.resize(num, 0);\n\t\tmodi.resize(num, LLONG_MAX);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Insert(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] = num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tif (is_min)v[place] = min(v[place * 2], v[place * 2 + 1]);\n\t\t\telse v[place] = max(v[place * 2], v[place * 2 + 1]);\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid Modify(int a, int b, long long int num) {\n\t\tModify(a, b, num, 1);\n\t}\n\tvoid Add(int a, int b, long long int num) {\n\t\tAdd(a, b, num, 1);\n\t}\n\tvoid Init() {\n\t\tUpdate(1);\n\t}\n\tlong long int RMQ(int a, int b) {\n\t\tif (is_min)ret = LLONG_MAX;\n\t\telse ret = LLONG_MIN;\n\t\tRMQ(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tSegment_Tree sg(N, true);\n\tfor (int i = 0; i < N; i++) {\n\t\tsg.Insert(i, (1LL << 31) - 1,false);\n\t}\n\tsg.Init();\n\tvector<int>ans;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> M;\n\t\tif (M) {\n\t\t\tcin >> L;\n\t\t\tans.push_back(sg.RMQ(L, L));\n\t\t}\n\t\telse {\n\t\t\tcin >> L >> R >> H;\n\t\t\tsg.Modify(L, R, H);\n\t\t\t//for (int j = 0; j < N; j++) {\n\t\t\t//\tfor (int k = j; k < N; k++) {\n\t\t\t//\t\tcout << j << \" \" << k << \" \" << sg.RMQ(j, k) << endl;\n\t\t\t//\t}\n\t\t\t//}\n\t\t}\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n\nnamespace beet{\n  \n  template<typename T>\n  void swap(T &a,T &b){\n    T x=a;\n    a=b;\n    b=x;\n  }\n  \n  template<typename T>\n  struct Vector{\n    int sz,cap;\n    T *data;\n    Vector():sz(0),cap(1){\n      data = new T[cap];\n    }    \n    Vector(int sz):sz(sz),cap(sz<<1){\n      data = new T[cap];\n    }\n    Vector(int sz,T t):sz(sz),cap(sz<<1){\n      data = new T[cap];\n      for(int i=0;i<sz;i++) data[i]=t;\n    }\n    ~Vector(){\n      delete[] data;\n    }\n    void resolve(){\n      T *tmp = new T[cap];\n      for(int i=0;i<sz;i++) tmp[i]=data[i];\n      delete[] data;\n      data=tmp;\n    }\n    void resize(int nsz){\n      cap=nsz<<1;\n      if(sz>cap) sz=cap;\n      resolve();      \n    }\n    void assign(int nsz,T t){\n      resize(nsz);\n      sz=nsz;\n      for(int i=0;i<sz;i++) data[i]=t;\n    }    \n    void push_back(T x){\n      if(sz>=cap){\n        cap<<=1;\n        assert(sz<cap);\n        resolve();\n      }      \n      data[sz++]=x;\n    }\n    void pop_back(){\n      sz--;\n    }\n    int size() const{\n      return sz;\n    }\n    const T operator[](int x) const{\n      return data[x];\n    }\n    T& operator[](int x){\n      assert(0<=x&&x<sz);\n      return data[x];\n    }\n  };\n  \n\n  template <typename T,typename E, typename F, typename G, typename H>\n  struct SegmentTree{\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    Vector<T> dat;\n    Vector<E> laz;\n    SegmentTree(F f,G g,H h,T ti,E ei):\n      f(f),g(g),h(h),ti(ti),ei(ei){}\n  \n    void init(int n_){\n      n=1;height=0;\n      while(n<n_) n<<=1,height++;\n      dat.assign(2*n,ti);\n      laz.assign(2*n,ei);\n    }\n    void build(const Vector<T> &v){\n      int n_=v.size();\n      init(n_);\n      for(int i=0;i<n_;i++) dat[n+i]=v[i];\n      for(int i=n-1;i;i--)\n        dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n      return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n      if(laz[k]==ei) return;\n      laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n      laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n      dat[k]=reflect(k);\n      laz[k]=ei;\n    }\n    inline void thrust(int k){\n      for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){    \n      while(k>>=1)\n        dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n      thrust(a+=n);\n      thrust(b+=n-1);\n      for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n        if(l&1) laz[l]=h(laz[l],x),l++;\n        if(r&1) --r,laz[r]=h(laz[r],x);\n      }\n      recalc(a);\n      recalc(b);\n    }\n    void set_val(int a,T x){\n      thrust(a+=n);\n      dat[a]=x;laz[a]=ei;\n      recalc(a);\n    }\n    T query(int a,int b){\n      thrust(a+=n);\n      thrust(b+=n-1);\n      T vl=ti,vr=ti;\n      for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n        if(l&1) vl=f(vl,reflect(l++));\n        if(r&1) vr=f(reflect(--r),vr);\n      }\n      return f(vl,vr);\n    }\n  };\n}\n\n//INSERT ABOVE HERE\nusing namespace beet;\n\nint main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  int ti=(1LL<<31)-1;\n  int ei=-1;\n  auto f=[](int a,int b){return a<b?a:b;};\n  auto g=[](int a,int b){(void) a;return b;};\n  SegmentTree<int, int, decltype(f), decltype(g), decltype(g)> seg(f,g,g,ti,ei);\n  seg.build(Vector<int>(n,ti));\n\n  for(int i=0;i<q;i++){\n    int c,x;\n    scanf(\"%d %d\",&c,&x);\n    if(c==0){\n      int y,z;\n      scanf(\"%d %d\",&y,&z);\n      seg.update(x,y+1,z);\n    }\n    if(c==1) printf(\"%d\\n\",seg.query(x,x+1));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_INT 2147483647\nusing namespace std;\nint main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int>a(n,MAX_INT);\n  for(int i=0;i<q;i++){\n    int com;cin>>com;\n    if(com){\n      int i;\n      scanf(\"%d\",&i);\n      printf(\"%d\\n\",a[i]);\n    }else{\n      int s,t,l;\n      scanf(\"%d %d %d\",&s,&t,&l);\n      fill(a.begin()+s,a.begin()+t+1,l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//sub-BOF\n#define _AOJ_\n        /*vvv>\n        zzzzzI\n .---.  zzuzuI                 .vgggg&,.\n+++++=  dAC:|I  .WbbWo       JMM9^```?TMB`  ..&gNNg,.   gggggggJ,   qgggggggg] (&&&&&&&&[   c+OA&J,   (&&&&&&+J,   .cJeAA&-.  (&&&&&&&&x   .&AA&=-.\n+++++=  dTqk|I  Xpbpbp      JM#`           (M#^   ?MMp  MM|   +TMN. JMF      ' |yk      ` dVY    7Vk,  Vy     XV  cVf     ?Y!  JM         V$      `\n+++++=  dcf:|I  Xppppp      dMN           .MM+     .MM  MM|     MM] JMMMMMM+   |@tqkoh)  ,y0      (V$  yyyyyyyV7  VV           JMWyZWr    TWVVVVW&,\n++++++  d7qk|0  Xppppp      ^HMN,    _.db  WMm,   .MMF  MM|   ..MM` JMF      . |yk       .WV&.   .XW'  yy   4yn.  jyn      +.  JM                #S\n`++++`  ?ZZZX=  ?WWWW=        -THMMMMH9^    (TMMMMM9!   MMMMMMM\"\"   JMMMMMMMME |UU.        ?TUUUUY=    UU.   (UU-  ^7TUUUV7!   JUUUUUUUU  7TUNKO*/\n\n\n//basic\n#pragma GCC target(\"sse4\")\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long lint;\ntypedef long double ld;\ntypedef string cs;\n#define all(v) v.begin(),v.end()\n#define pb push_back\n\n//rep\n#define _vcppunko4(tuple) _getname4 tuple\n#define _getname4(_1,_2,_3,_4,name,...) name\n#define _getname3(_1,_2,_3,name,...) name\n#define _trep2(tuple) _rep2 tuple\n#define _trep3(tuple) _rep3 tuple\n#define _trep4(tuple) _rep4 tuple\n#define _rep1(n) for(lint i=0;i<n;++i)\n#define _rep2(i,n) for(lint i=0;i<n;++i)\n#define _rep3(i,a,b) for(lint i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(lint i=a;i<b;i+=c)\n#define _trrep2(tuple) _rrep2 tuple\n#define _trrep3(tuple) _rrep3 tuple\n#define _trrep4(tuple) _rrep4 tuple\n#define _rrep1(n) for(lint i=n-1;i>=0;--i)\n#define _rrep2(i,n) for(lint i=n-1;i>=0;--i)\n#define _rrep3(i,a,b) for(lint i=b-1;i>=a;--i)\n#define _rrep4(i,a,b,c) for(lint i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rep(...) _vcppunko4((__VA_ARGS__,_trep4,_trep3,_trep2,_rep1))((__VA_ARGS__))\n#define per(...) _vcppunko4((__VA_ARGS__,_trrep4,_trrep3,_trrep2,_rrep1))((__VA_ARGS__))\n#define each(c) for(auto &e:c)\n\n//io\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator>>(istream& is,array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p);\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec);\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p);\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p){ os<<p.first<<\" \"<<p.second;return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec){ os<<vec[0];rep(i,1,vec.size())os<<' '<<vec[i];return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,deque<T>& deq){ os<<deq[0];rep(i,1,deq.size())os<<' '<<deq[i];return os; }\n\n#ifdef __ENV_TQK__\n#include<Windows.h>\nHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\ninline void in(){ SetConsoleTextAttribute(hConsole,10); }\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){\n\tSetConsoleTextAttribute(hConsole,15);\n\tcin>>head;in(move(tail)...);\n}\n#else\ninline void in(){}\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){ cin>>head;in(move(tail)...); }\n#endif\n\n\n\ninline bool out(){ return(cout<<'\\n',0); }\ntemplate <class T>\ninline bool out(T t){ return(cout<<t<<'\\n',0); }\ntemplate <class Head,class... Tail>\ninline bool out(Head head,Tail... tail){ cout<<head<<' ';out(move(tail)...);return 0; }\ntemplate <class T>\ninline void alloc(T &c,lint s){ rep(c.size())c[i].resize(s); }\n#define alc alloc\n\n//TA\n#define lin(...) lint __VA_ARGS__;in(__VA_ARGS__)\n#define stin(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define vin(type,name,size) vector<type> name(size);in(name)\n#define vvin(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define fi e.first\n#define se e.second\n#define YES(c) cout<<((c)?\"YES\\n\":\"NO\\n\"),0\n#define Yes(c) cout<<((c)?\"Yes\\n\":\"No\\n\"),0\n#define POSSIBLE(c) cout<<((c)?\"POSSIBLE\\n\":\"IMPOSSIBLE\\n\"),0\n#define Possible(c) cout<<((c)?\"Possible\\n\":\"Impossible\\n\"),0\n#define o(p) cout<<p<<endl,0\n#define sp(p) cout<<p<<\" \"\n#define no(p) cout<<p\ninline constexpr lint gcd(lint a,lint b){ if(!a||!b)return 0;while(b){ lint c=b;b=a%b;a=c; }return a; }\ntemplate<typename T>\ninline constexpr bool chmin(T &mn,const T &cnt){ if(mn>cnt){ mn=cnt;return 1; } else return 0; }\ntemplate<typename T>\ninline constexpr bool chmax(T &mx,const T &cnt){ if(mx<cnt){ mx=cnt;return 1; } else return 0; }\n#define ve(type) vector<type>\n#define fn(ty1,ty2,ex) [](ty1 a,ty2 b){ return(ex); }\n#define lfn(ex) [](lint a,lint b){ return(ex); }\n\n//other\n#ifdef __ENV_TQK__\n#define deb(p) cout<<p<<endl,0\n#else\n#define deb(p) 0\n#endif\nstruct Fastio{\n\tFastio(){\n\t\tcin.tie(0),cout.tie(0);\n\t\tios::sync_with_stdio(0);\n\t\tcout<<fixed<<setprecision(10);\n\t}\n} __fastio;\n\n\n//mint\n#define md_tmp template<uint_fast64_t md=1000000007>\nmd_tmp class mint{\n\tusing u64=uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr mint(const u64 x=0) noexcept: a(x%md){}\n\tconstexpr u64 &value() noexcept{ return a; }\n\tconstexpr const u64 &value() const noexcept{ return a; }\n\tconstexpr mint operator+(const mint rhs) const noexcept{\n\t\treturn mint(*this)+=rhs;\n\t}\n\tconstexpr mint operator-(const mint rhs) const noexcept{\n\t\treturn mint(*this)-=rhs;\n\t}\n\tconstexpr mint operator*(const mint rhs) const noexcept{\n\t\treturn mint(*this)*=rhs;\n\t}\n\tconstexpr mint operator^(const lint rhs) const noexcept{\n\t\treturn mint(*this)^=rhs;\n\t}\n\tconstexpr mint operator/(const mint rhs) const noexcept{\n\t\treturn mint(*this)/=rhs;\n\t}\n\tconstexpr mint &operator+=(const mint rhs) noexcept{\n\t\ta+=rhs.a;\n\t\tif(a>=md)a-=md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator-=(const mint rhs) noexcept{\n\t\tif(a<rhs.a)a+=md;\n\t\ta-=rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator*=(const mint rhs) noexcept{\n\t\ta=a*rhs.a%md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator^=(const lint rhs) noexcept{\n\t\tif(!rhs)return *this=1;\n\t\tu64 exp=rhs-1;\n\t\tmint base=this->a;\n\t\twhile(exp){\n\t\t\tif(exp&1)*this*=base;\n\t\t\tbase*=base;\n\t\t\texp>>=1;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator/=(const mint rhs) noexcept{\n\t\ta=(*this*(rhs^(md-2))).a;\n\t\treturn *this;\n\t}\n};\nmd_tmp istream& operator>>(istream& os,mint<md>& m){\n\tos>>m.a,m.a%=md;\n\treturn os;\n}\nmd_tmp ostream& operator<<(ostream& os,const mint<md>& m){\n\treturn os<<m.a;\n}\nmd_tmp mint<md> ncr(lint n,lint r){\n\tif(n<r||n<0||r<0)return mint<md>(0);\n\tmint<md>ncr_res=1,ncr_div=1;\n\trep(r)ncr_res*=(n-i),ncr_div*=(r-i);\n\treturn ncr_res/ncr_div;\n}\n#ifndef _AOJ_\nmint<> operator\"\"m(const unsigned long long n){ return mint<>(n); }\nmint<998244353> operator\"\"m9(const unsigned long long n){ return mint<998244353>(n); }\nmint<1000003> operator\"\"m3(const unsigned long long n){ return mint<1000003>(n); }\n#endif\n\n\n//const\n#define linf 1152921504606846976\n#define inf linf\n#define MAXN 330\n#define md_1e9_7 1000000007\n#define md_998244353 998244353\n#define pi 3.14159265358979323846\n//#define mod md_1e9_7\nconst int d4[5]={0,1,0,-1,0};\n\n//main------\n\nclass P{ public:lint f,s; P(lint a,lint b):f(a),s(b){}; P():f(0),s(0){}; };\nistream& operator>>(istream& os,P& p){ os>>p.f>>p.s;return os; }\nbool operator<(const P& l,const P& r){ return(l.f-r.f?l.f<r.f:l.s<r.s); }\nbool operator>(const P& l,const P& r){ return(l.f-r.f?l.f>r.f:l.s>r.s); }\n\ntemplate < class M_act >\nstruct Lazy{\npublic:\n\tusing Monoid = typename M_act::Monoid;\n\tusing X = typename Monoid::T;\n\tusing M = typename M_act::M;\n\nprivate:\n\tsize_t n;\n\tint h;\n\tvector< X > data;\n\tvector< M > lazy;\n\tvector< size_t > nodeLeft,nodeLength;\n\t// call before use data[i]\n\tvoid eval(size_t i){\n\t\tif(lazy[i] == M_act::identity()) return;\n\t\tdata[i] = M_act::actInto(lazy[i],nodeLeft[i],nodeLength[i],data[i]);\n\t\tif(i < n){\n\t\t\tlazy[i * 2] = M_act::op(lazy[i],lazy[i * 2]);\n\t\t\tlazy[i * 2 + 1] = M_act::op(lazy[i],lazy[i * 2 + 1]);\n\t\t}\n\t\tlazy[i] = M_act::identity();\n\t}\n\t// call before use seg[i] = data[i + n]\n\tvoid evalDown(size_t i){\n\t\ti += n;\n\t\tfor(int j = h - 1; j >= 0; j--) eval(i >> j);\n\t}\n\t// call after touch seg[i] = data[i + n]\n\tvoid propUp(size_t i){\n\t\ti += n;\n\t\twhile(i >>= 1)\n\t\t\teval(i * 2),eval(i * 2 + 1),data[i] = Monoid::op(data[i * 2],data[i * 2 + 1]);\n\t}\n\npublic:\n\tLazy(): n(0){}\n\tLazy(size_t n,X initial = Monoid::identity()): n(n){\n\t\tif(n > 0){\n\t\t\th = 1;\n\t\t\twhile(1u << h < n) h++;\n\t\t\tdata.resize(2 * n,initial);\n\t\t\tlazy.resize(2 * n,M_act::identity());\n\t\t\tnodeLeft.resize(2 * n);\n\t\t\tnodeLength.resize(2 * n,1);\n\t\t\tfor(int i = 0; i < n; i++) nodeLeft[i + n] = i;\n\t\t\tfor(size_t i = n - 1; i > 0; i--) // fill from deep\n\t\t\t\tdata[i] = Monoid::op(data[i * 2],data[i * 2 + 1]),\n\t\t\t\tnodeLeft[i] = min(nodeLeft[i * 2],nodeLeft[i * 2 + 1]),\n\t\t\t\tnodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n\t\t}\n\t}\n\ttemplate < class InputIter,class = typename iterator_traits< InputIter >::value_type >\n\tLazy(InputIter first,InputIter last)\n\t\t: Lazy(distance(first,last)){\n\t\tif(n > 0){\n\t\t\tcopy(first,last,begin(data) + n);\n\t\t\tfor(size_t i = n - 1; i > 0; i--) // fill from deep\n\t\t\t\tdata[i] = Monoid::op(data[i * 2],data[i * 2 + 1]);\n\t\t}\n\t}\n\tLazy(vector< X > v): Lazy(v.begin(),v.end()){}\n\tLazy(initializer_list< X > v): Lazy(v.begin(),v.end()){}\n\tvoid act(int l,int r,const M &m){\n\t\tif(l < 0) l = 0;\n\t\tif(l >= r) return;\n\t\tif(r >(int) n) r = n;\n\t\tevalDown(l);\n\t\tevalDown(r - 1);\n\t\tint tl = l,tr = r;\n\t\tfor(l += n,r += n; l < r; l >>= 1,r >>= 1){\n\t\t\tif(l & 1) eval(l),lazy[l] = m,eval(l),l++;\n\t\t\tif(r & 1) --r,eval(r),lazy[r] = m,eval(r);\n\t\t}\n\t\tpropUp(tl);\n\t\tpropUp(tr - 1);\n\t}\n\tvoid set(size_t i,const X &x){\n\t\tassert(i < n);\n\t\tevalDown(i);\n\t\tdata[i + n] = x;\n\t\tpropUp(i);\n\t}\n\tX get(size_t i){\n\t\tassert(i < n);\n\t\tevalDown(i);\n\t\treturn data[i + n];\n\t}\n\tX fold(int l,int r){\n\t\tif(l < 0) l = 0;\n\t\tif(l >= r) return Monoid::identity();\n\t\tif(r >(int) n) r = n;\n\t\tevalDown(l);\n\t\tevalDown(r - 1);\n\t\tX tmpL = Monoid::identity(),tmpR = Monoid::identity();\n\t\tfor(l += n,r += n; l < r; l >>= 1,r >>= 1){\n\t\t\tif(l & 1) eval(l),tmpL = Monoid::op(tmpL,data[l]),l++;\n\t\t\tif(r & 1) --r,eval(r),tmpR = Monoid::op(data[r],tmpR);\n\t\t}\n\t\treturn Monoid::op(tmpL,tmpR);\n\t}\n\tint size(){ return n; }\n\tinline void dum(int r = -1){\n#ifdef DEBUG\n\t\tif(r < 0) r = n;\n\t\tDEBUG_OUT << \"{\";\n\t\tfor(int i = 0; i < min(r,(int)n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n\t\tDEBUG_OUT << \"}\" << endl;\n#endif\n\t}\n\t\t};\n\nconstexpr long long inf_monoid = 1e18 + 100;\nstruct Nothing{\n\tusing T = char;\n\tusing Monoid = Nothing;\n\tusing M = T;\n\tstatic constexpr T op(const T &,const T &){ return T(); }\n\tstatic constexpr T identity(){ return T(); }\n\ttemplate < class X >\n\tstatic constexpr X actInto(const M &,long long,const X &x){\n\t\treturn x;\n\t}\n};\n\ntemplate < class U = long long >\nstruct RangeMin{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return std::min< T >(a,b); }\n\tstatic constexpr T identity(){ return T(inf_monoid); }\n};\n\ntemplate < class U = P >\nstruct RangeMinP{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return std::min< T >(a,b); }\n\tstatic constexpr T identity(){ return T(inf_monoid,linf); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return std::max< T >(a,b); }\n\tstatic constexpr T identity(){ return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a + b; }\n\tstatic constexpr T identity(){ return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a * b; }\n\tstatic constexpr T identity(){ return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a | b; }\n\tstatic constexpr T identity(){ return T(0); }\n};\n\ntemplate < class U = long long >\nstruct RangeAnd{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a & b; }\n\tstatic constexpr T identity(){ return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > >{\n\tusing T = std::bitset< N >;\n\tstatic T op(const T &a,const T &b){ return a & b; }\n\tstatic constexpr T identity(){ return std::bitset< N >().set(); }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMinAdd{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeMin< U >;\n\tstatic M op(const M &a,const M &b){ return a + b; }\n\tstatic constexpr M identity(){ return 0; }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return m + x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMaxAdd{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeMax< U >;\n\tstatic M op(const M &a,const M &b){ return a + b; }\n\tstatic constexpr M identity(){ return 0; }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return m + x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMinSet{\n\tusing M = U;\n\tusing Monoid = RangeMin< U >;\n\tusing X = typename Monoid::T;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return /*m == identity() ? x : */m; }\n};\n\ntemplate < class U = P,class V = lint >\nstruct RangeMinSetIndex{//jisaku!\n\tusing M = V;\n\tusing Monoid = RangeMinP< U >;\n\tusing X = typename Monoid::T;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long l,long long,const X &x){ return X(m,l); }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMaxSet{\n\tusing M = U;\n\tusing Monoid = RangeMax< U >;\n\tusing X = typename Monoid::T;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeSumAdd{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeSum< U >;\n\tstatic M op(const M &a,const M &b){ return a + b; }\n\tstatic constexpr M identity(){ return 0; }\n\tstatic X actInto(const M &m,long long,long long n,const X &x){ return m * n + x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeSumSet{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeSum< U >;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long,long long n,const X &x){\n\t\treturn m == identity() ? x : m * n;\n\t}\n};\n\ntemplate < class U,class V = U >\nstruct RangeProdMul{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeProd< U >;\n\tstatic M mpow(M a,long long b){\n\t\tX r(1);\n\t\twhile(b){\n\t\t\tif(b & 1) r = r * a;\n\t\t\ta = a * a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\tstatic M op(const M &a,const M &b){ return a * b; }\n\tstatic constexpr M identity(){ return M(1); }\n\tstatic X actInto(const M &m,long long,long long n,const X &x){ return x * mpow(m,n); }\n};\n\ntemplate < class U,class V = U >\nstruct RangeProdSet{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeProd< U >;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return V::unused; }\n\tstatic X actInto(const M &m,long long,long long n,const X &){\n\t\tif(m == identity()) return;\n\t\treturn RangeProdMul< U,V >::mpow(m,n);\n\t}\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeOr2{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeOr< U >;\n\tstatic M op(const M &a,const M &b){ return a | b; }\n\tstatic constexpr M identity(){ return M(0); }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return m | x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeAnd2{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeAnd< U >;\n\tstatic M op(const M &a,const M &b){ return a & b; }\n\tstatic constexpr M identity(){ return M(-1); }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return m & x; }\n};\n\ntemplate < class U,size_t N >\nstruct RangeAnd2< U,std::bitset< N > >{\n\tusing X = U;\n\tusing M = std::bitset< N >;\n\tusing Monoid = RangeAnd< U >;\n\tstatic M op(const M &a,const M &b){ return a & b; }\n\tstatic constexpr M identity(){ return std::bitset< N >().set(); }\n\tstatic X actInto(const M &m,long long,long long,const X &x){ return m & x; }\n};\n\n\nint main(){\n\tlint n,q;in(n,q);\n\tlint com,s,t,x;\n\tLazy<RangeSumSet<>>ki(n,INT_MAX);\n\twhile(q--){\n\t\tin(com);\n\t\tif(com){\n\t\t\tin(x);\n\t\t\tout(ki.get(x));\n\t\t} else{\n\t\t\tin(s,t,x);\n\t\t\tki.act(s,++t,x);\n\t\t}\n\t}\n}\n\n//sub-EOF\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q;\nint const INF = INT_MAX;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<int> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    LazySegmentTree(vector<int> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, INF);\n        lazyFlag.resize(2*n-1, false);\n\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n\n    void lazy_evaluate(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] = lazy[k];\n                lazy[2*k+2] = lazy[k];\n                lazyFlag[2*k+1] = true;\n                lazyFlag[2*k+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n\n    void update(int a, int b, int x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        lazy_evaluate(k, l, r);\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            lazy_evaluate(k, l, r);\n        }\n        else {\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[k*2+1], node[k*2+2]);\n        }\n    }\n\n    int find(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        lazy_evaluate(k, l, r);\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        int vl = find(a, b, 2*k+1, l, (l+r)/2);\n        int vr = find(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint main() {\n    cin >> N >> Q;\n    LazySegmentTree seg( vector<int>(N, INF) );\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }\n        else {\n            int i; cin >> i;\n            cout << seg.find(i, i+1) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\n//const int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    std::vector<bool> lazy_flag;\n    std::function<T (T,T)> op;\n    T unit;\n\npublic:\n    enum Mode {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, Mode mode) : array_size(v.size()) {\n        if (mode == RangeMinimumQuery) {\n            unit = INT_MAX;\n            op = [](T a, T b) { return std::min(a, b); };\n        }\n        else if (mode == RangeMaximumQuery) {\n            unit = -INT_MAX;\n            op = [](T a, T b) { return std::max(a, b); };\n        }\n        else if (mode == RangeSummationQuery) {\n            unit = 0;\n            op = [](T a, T b) { return a + b; };\n        }\n        else {\n            assert(false);\n        }\n\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, 0);\n        lazy_flag.resize(2 * n - 1, false);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    // array[idx]\n    // log(N)\n    T access(const int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] = x\n    // log(N)\n    void update(const int idx, T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) = x\n    // log(N)\n    void update(const int left, const int right, T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(const int left, const int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(const int a, const int b, const LL x, const int k, const int l, const int r) {\n        propagate(k, l, r);\n\n        // 範囲外\n        if (r <= a or b <= l) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = x;\n            lazy_flag[k] = true;\n            propagate(k, l, r);\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T vr = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = op(vl, vr);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(const int a, const int b, const int k, const int l, const int r) {\n        propagate(k, l, r);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return op(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int l, const int r) {\n        if (not lazy_flag[k]) {\n            return;\n        }\n\n        data[k] = lazy[k];\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy_flag[2 * k + 1] = true;\n            lazy[2 * k + 2] = lazy[k];\n            lazy_flag[2 * k + 2] = true;\n        }\n        lazy_flag[k] = false;\n    }\n};\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N, 2147483647);\n\n    LazySegmentTree<LL> lst(v, LazySegmentTree<LL>::Mode::RangeMinimumQuery);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> i;\n            print(lst.access(i));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\n#include<functional>\n#include<deque>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntemplate<typename X,typename M>\n  struct segtree{\n    using FX=function<X(X,X)>;\n    using FA=function<X(X,M)>;\n    using FM=function<M(M,M)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    segtree(int n_,FX fx_,FA fa_,FM fm_,X ex_,M em_)\n      :n(),fx(fx_),fa(fa_),fm(fm_),ex(ex_),em(em_),dat(n_*4,ex),lazy(n_*4,em){\n        int x=1;\n        while(n_>x){\n          x*=2;\n        }\n        n=x;\n      }\n    void set(int i,X x){\n      dat[i+n-1]=x;\n    }\n    void build(){\n      for(int k=n-2;k>=0;k--){\n        dat[k]=fx(dat[2*k+1],dat[2*k+2]);\n      }\n    }\n    void eval(int k){\n      if(lazy[k]==em){\n        return;\n      }\n      if(k<n-1){\n        lazy[k*2+1]=fm(lazy[k*2+1],lazy[k]);\n        lazy[k*2+2]=fm(lazy[k*2+2],lazy[k]);\n      }\n      dat[k]=fa(dat[k],lazy[k]);\n      lazy[k]=em;\n    }\n    void update(int a,int b,M x,int k,int l,int r){\n      eval(k);\n      if(a<=l && r<=b){\n        lazy[k]=fm(lazy[k],x);\n        eval(k);\n      }\n      else if(a<r && l<b){\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n        dat[k]=fx(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    void update(int a,int b,M x){\n      update(a,b,x,0,0,n);\n    }\n    X query_sub(int a,int b,int k,int l,int r){\n      eval(k);\n      if(r<=a  || b<=l){\n        return ex;\n      }\n      else if(a<=l && r<=b){\n        return dat[k];\n      }\n      else{\n        X vl=query_sub(a,b,k*2+1,l,(l+r)/2);\n        X vr=query_sub(a,b,k*2+2,(l+r)/2,r);\n        return fx(vl,vr);\n      }\n    }\n    X query(int a,int b){\n      return query_sub(a,b,0,0,n);\n    }\n  };\nint main(){\n  using X=ll;\n  using M=ll;\n  auto fx=[](X x1,X x2) -> X{return min(x1,x2);};\n  auto fa=[](X x,M m) -> X{return m;};\n  auto fm=[](M m1,M m2) -> M{return m2;};\n  long long ex=2147483647;\n  long long em=2147483647;\n  segtree<X,M> seg(100010,fx,fa,fm,ex,em);\n  int i,n,q,a,b,c;\n  ll d;\n  cin >> n >> q;\n  for(i=0;i<q;i++){\n    cin >> a;\n    if(a==0){\n      cin >> b >> c >> d;\n      seg.update(b,c+1,d);\n    }\n    else{\n      cin >> b;\n      cout << seg.query(b,b+1) << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////\n// 双対セグメント木 //\n//////////////////////\n\n// 要件は以下\n// Transformation_tはElement_t上の変換全体の集合、(Monoid_t, operate_, identity_)はモノイド\n// 準同型写像homoMorphism:Monoid_t->Transformation_tによりMonid_tとTransformation_tは準同型\ntemplate <typename Element_t, typename Monoid_t, typename Operation_t, typename HomoMorphism_t>\nclass DualSegmentTree {\nprivate:\n\tconst Operation_t operate_;\n\tconst Monoid_t identity_;\n\tconst HomoMorphism_t homoMorphism_;\n\tstd::vector<Element_t> element_container_;\n\tstd::vector<Monoid_t> monoid_container_;\n\n\tvoid build(const unsigned int array_size)\n\t{\n\t\tunsigned int length{1};\n\t\twhile (length < array_size)\n\t\t\tlength <<= 1;\n\t\telement_container_.resize(length);\n\t\tmonoid_container_.resize(2 * length, identity_);\n\t}\n\n\t// 新しい演算ほど左にくるようにする(写像の合成と同じ順番)\n\tvoid updateHelper(const int query_l, const int query_r, const Monoid_t& added, const int node_i, const int node_l, const int node_r)\n\t{\n\t\tif (query_r <= node_l || node_r <= query_l) return;\n\n\t\tMonoid_t& monoid{monoid_container_[node_i]};\n\t\tif (query_l <= node_l && node_r <= query_r)\n\t\t{\n\t\t\tmonoid = operate_(added, monoid);\n\t\t\treturn;\n\t\t}\n\n\t\tmonoid_container_[2 * node_i] = operate_(monoid, monoid_container_[2 * node_i]);\n\t\tmonoid_container_[2 * node_i + 1] = operate_(monoid, monoid_container_[2 * node_i + 1]);\n\t\tmonoid = identity_;\n\t\n\t\tconst int node_m{(node_l + node_r) >> 1};\n\t\tupdateHelper(query_l, query_r, added, 2 * node_i, node_l, node_m);\n\t\tupdateHelper(query_l, query_r, added, 2 * node_i + 1, node_m, node_r);\n\t}\n\npublic:\n\t// initial_elementで要素配列を初期化\n\tDualSegmentTree(const unsigned int array_size, const Element_t initial_element,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n\t\t: operate_(operate), identity_(identity), homoMorphism_(homoMorphism)\n\t{\n\t\tbuild(array_size);\n\t\tstd::fill(element_container_.begin(), element_container_.end(), initial_element);\n\t\treturn;\n\t}\n\t// initial_arraydで要素配列を初期化\n\tDualSegmentTree(const std::vector<Element_t> initial_array,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n\t{\n\t\tbuild(initial_array.size());\n\t\tstd::copy(initial_array.begin(), initial_array.end(), element_container_.begin());\n\t}\n\n\t// left,rightは0-indexed、半開区間[left,right)にhomoMorphism(operate)を施す\n\tvoid update(const int left, const int right, const Monoid_t added)\n\t{\n\t\tupdateHelper(left, right, added, 1, 0, element_container_.size());\n\t}\n\n\t// indexは0-indexed、indexの要素を返す\n\tElement_t get(const int index)\n\t{\n\t\tElement_t element{element_container_[index]};\n\t\tfor (int monoid_i{((int)monoid_container_.size() >> 1) + index}; monoid_i > 0; monoid_i >>= 1)\n\t\t\telement = homoMorphism_(monoid_container_[monoid_i])(element);\n\n\t\treturn element;\n\t}\n};\n\n// 引数のlambda式の型はstd::functionを使うと遅くなるため、クラステンプレートで指定したい。\n// しかしlambda式の型は直接取り出せないため型推論によって型を決定しなければならない。\n// しかしC++14にはクラステンプレートには型推論がないため普通の方法で宣言することはできない。\n// そのため関数の型推論を利用してクラスを作成し、戻り値をautoで受けることで実質的なクラステンプレートの型推論を実現している。\ntemplate <typename Element_t, typename Monoid_t, typename Operation_t, typename HomoMorphism_t>\ndecltype(auto) makeDualSegmentTree(const unsigned int array_size, const Element_t initial_element,\n\t\tconst Operation_t operate, const Monoid_t identity,\n\t\tconst HomoMorphism_t homoMorphism\n\t)\n{\n\treturn DualSegmentTree<Element_t, Monoid_t, Operation_t, HomoMorphism_t>\n\t\t\t(array_size, initial_element, operate, identity, homoMorphism);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tauto dst(\n\t\tmakeDualSegmentTree(\n\t\t\tn, (1ll << 31) - 1,\n\t\t\t[](const int64_t left, const int64_t right)\n\t\t\t{\n\t\t\t\treturn left >= 0?left:right;\n\t\t\t},\n\t\t\t-1ll,\n\t\t\t[](const int64_t monoid)\n\t\t\t{\n\t\t\t\treturn [=](const int64_t argument)\n\t\t\t\t{\n\t\t\t\t\treturn monoid >= 0? monoid: argument;\n\t\t\t\t};\n\t\t\t}\n\t\t)\n\t);\n\n\tfor (int q_i{}; q_i < q; q_i++)\n\t{\n\t\tint com;\n\t\tscanf(\"%d\", &com);\n\t\tif (com)\n\t\t{\n\t\t\tint i;\n\t\t\tscanf(\"%d\", &i);\n\t\t\tprintf(\"%lld\\n\", dst.get(i));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s, t, x;\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tt++;\n\t\t\tdst.update(s, t, x);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <cstdlib>\n\n#define DATA_MAX 100000\n#define QUERY_MAX 100000\n#define UNDEF -1\n\nusing namespace std;\n\nclass SegTree{\n    struct Node{\n        int value;\n        int high;\n        int low;\n    };\n    \nprivate:\n    vector<vector<Node> > Tree;\n    const int MAX_VALUE;\n    int DNum, QNum;\n    \n    int min(int d1, int d2){\n        return d1 < d2 ? d1 : d2;\n    }\n    \n    void CreateTree(int level){\n        vector<Node> new_layer;\n        Node tmp;\n        \n        for(vector<Node>::size_type i = 0; i < Tree[level].size(); i += 2){\n            tmp.value = MAX_VALUE;\n            tmp.low = Tree[level][i].low;\n            tmp.high = Tree[level][i + 1].high;\n            new_layer.push_back(tmp);\n            \n            if(i + 2 == Tree[level].size() - 1){\n                tmp = Tree[level][i + 2];\n                new_layer.push_back(tmp);\n                break;\n            }\n        }\n        \n        Tree.push_back(new_layer);\n        \n        if(Tree[level + 1].size() == 1)\n            return;\n        else\n            CreateTree(level + 1);\n    }\n    \n    void UpDate(int s, int t, int n){\n        int iter = s;\n        pair<int, int> section(s, t);\n        \n        while(iter <= t){\n            iter = UpDate(0, iter, n, section, &Tree[0][s]);\n            iter++;\n        }\n        \n        PrintTree();\n    }\n    \n    int UpDate(int level, int key, int n, pair<int, int> section, Node *before){\n        if(n == UNDEF){\n            if(Tree[level][key].value == UNDEF)\n                return UNDEF;\n            else if(level == Tree.size() - 1){\n                DownValue(level, key, before);\n                return UNDEF;\n            }\n            else{\n                DownValue(level, key, before);\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        if(section.first <= Tree[level][key].low && Tree[level][key].high <= section.second){\n            if(level == Tree.size() - 1){\n                Tree[level][key].value = n;\n                return Tree[level][0].high;\n            }\n            else{\n                Tree[level][key].value = n;\n                return UpDate(level + 1, key / 2, n, section, &Tree[level][key]);\n            }\n        }\n        \n        DownValue(level, key, before);\n        UpDate(level + 1, key / 2, UNDEF, section, &Tree[level][key]);\n        \n        return before->high;\n    }\n    \n    void DownValue(int level, int key, Node *before){\n        int tmp = Tree[level][key].value;\n        Tree[level][key].value = UNDEF;\n        \n        if(tmp != UNDEF){\n            if(before != &Tree[level - 1][2 * key])\n                Tree[level - 1][2 * key].value = tmp;\n            else if(2 * key + 1 < Tree[level - 1].size())\n                Tree[level - 1][2 * key + 1].value = tmp;\n        }\n    }\n    \n    int Find(int target){\n        int level = (int)Tree.size() - 1;\n        int pivot = (Tree[level][0].high - Tree[level][0].low) / 2;\n        Node now = Tree[level][0];\n        \n        if(Tree[level][0].low <= target && target <= Tree[level][0].high && Tree[level][0].value != UNDEF)\n            return Tree[level][0].value;\n        \n        if(target <= pivot)\n            return Find(level - 1, 0, target);\n        else\n            return Find(level - 1, 1, target);\n    }\n    \n    int Find(int level, int key, int target){\n        Node now = Tree[level][key];\n        int pivot = (Tree[level][key].high - Tree[level][key].low) / 2 + Tree[level][key].low;\n        \n        if(Tree[level][key].low <= target && target <= Tree[level][key].high && Tree[level][key].value != UNDEF)\n            return Tree[level][key].value;\n        \n        if(target <= pivot)\n            return Find(level - 1, 2 * key, target);\n        else\n            return Find(level - 1, 2 * key + 1, target);\n    }\n    \n    void PrintTree(){\n        static ofstream fout(\"tree.txt\");\n        for(int i = (int)Tree.size() - 1; i >= 0; i--){\n            for(vector<Node>::size_type j = 0; j < Tree[i].size(); j++){\n                fout << \"(\";\n                if(Tree[i][j].value == MAX_VALUE)\n                    fout << \"∞\";\n                else\n                    fout << Tree[i][j].value;\n                fout << \", [\" << Tree[i][j].low << \", \" << Tree[i][j].high << \"])\";\n            }\n            fout << endl;\n        }\n        fout << endl;\n    }\n    \npublic:\n    SegTree() : MAX_VALUE(pow(2, 31) - 1){\n        Tree.resize(1);\n    }\n    \n    void Init(){\n        cin >> DNum >> QNum;\n        if(!(1 <= DNum && DNum <= DATA_MAX) || !(1 <= QNum && QNum <= QUERY_MAX))\n            exit(1);\n        \n        Tree[0].resize(DNum);\n        for(vector<int>::size_type i = 0; i < Tree[0].size(); i++){\n            Tree[0][i].value = MAX_VALUE;\n            Tree[0][i].high = (int)i;\n            Tree[0][i].low = (int)i;\n        }\n        \n        CreateTree(0);\n    }\n    \n    void ReadQuery(){\n        int com, s, t, x;\n        \n        for(int c = 0; c < QNum; c++){\n            cin >> com;\n            if(com == 0){\n                cin >> s >> t >> x;\n                if(!(0 <= s && s < DNum) || !(0 <= t && t < DNum) || (s > t) || !(0 <= x && x < MAX_VALUE))\n                    exit(2);\n                \n                UpDate(s, t, x);\n            }\n            else if(com == 1){\n                cin >> x;\n                if(!(0 <= x && x < DNum))\n                    exit(3);\n                \n                cout << Find(x) << endl;\n            }\n            else\n                exit(4);\n        }\n    }\n};\n\nint main(){\n    SegTree sg;\n    \n    sg.Init();\n    sg.ReadQuery();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100000\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int INF = 2147483647;\n#define B 100\n\nint bucket[MAX/B][B];\nint udata[MAX/B], data[MAX/B];\nvoid update(int a, int b, int x){\n\tint f1 = 1, f2 = 1;\n\twhile(a <= b && a%B != 0){\n\t\tif(f1 && udata[a/B] != -1){\n\t\t\tfor(int i = 0;i < MAX;i++)bucket[a/B][i] = udata[a/B];\n\t\t\tf1 = 0;udata[a/B] = -1;\n\t\t}\n\t\tbucket[a/B][a%B] = x;\n\t\ta++;\n\t}\n\twhile(a <= b && b%B != MAX-1){\n\t\tif(f2 && udata[b/B] != -1){\n\t\t\tfor(int i = 0;i < MAX;i++)bucket[b/B][i] = udata[b/B];\n\t\t\tf2 = 0;udata[b/B] = -1;\n\t\t}\n\t\tbucket[b/B][b%B] = x;\n\t\tb--;\n\t}\n\twhile(a < b){\n\t\tudata[a/B] = x;\n\t\ta += B;\n\t}\n}\n\nint find(int x){\n\tif(udata[x/B] != -1){\n\t\tfor(int i = 0;i < MAX;i++)bucket[x/B][i] = udata[x/B];\n\t\tudata[x/B] = -1;\n\t}\n\treturn bucket[x/B][x%B];\n}\n\nint main(){\n\tint n, q, c, s, t, x, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfill(udata, udata+MAX/B, -1);\n\tfill(data, data+MAX/B, INF);\n\tfill((int*)bucket, (int*)(bucket+MAX/B), INF);\n\twhile(q--){\n\t\tscanf(\"%d\", &c);\n\t\tif(!c){\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tupdate(s, t, x);\n\t\t}else{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tans = find(x);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t//rep(i,n)printf(\"%d \", bucket[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct OwnNode\n{\n\tint num;\n\tint l, r;\n\tint left, right;\n\n\tOwnNode(int l,int r):l(l),r(r),num(2147483647),left(-1),right(-1){}\n};\n\nvector<OwnNode> nodes;\n\nint Build(int l, int r)\n{\n\tint id = nodes.size();\n\tnodes.push_back(OwnNode(l, r));\n\tint m = (l + r) / 2;\n\tif (l + 1 != r)\n\t{\n\t\tnodes[id].left = Build(l, m);\n\t\tnodes[id].right = Build(m, r);\n\t}\n\treturn id;\n}\n\nvoid update(int id, int s, int t, int v)\n{\n\tif (t <= nodes[id].l || nodes[id].r <= s)\n\t{\n\t\treturn;\n\t}\n\tif (s <= nodes[id].l&&nodes[id].r <= t)\n\t{\n\t\tnodes[id].num = v;\n\t\treturn;\n\t}\n\tint m = (nodes[id].l + nodes[id].r) / 2;\n\tif (nodes[id].right != -1)\n\t{\n\t\tif (nodes[id].num >= 0)\n\t\t{\n\t\t\tnodes[nodes[id].right].num = nodes[id].num;\n\t\t}\n\t\tif (m < t)\n\t\t{\n\t\t\tupdate(nodes[id].right, s, t, v);\n\t\t}\n\t}\n\tif (nodes[id].left != -1)\n\t{\n\t\tif (nodes[id].num >= 0)\n\t\t{\n\t\t\tnodes[nodes[id].left].num = nodes[id].num;\n\t\t}\n\t\tif (s < m)\n\t\t{\n\t\t\tupdate(nodes[id].left, s, t, v);\n\t\t}\n\t}\n\tnodes[id].num = -1;\n}\n\nint find(int id,int s, int t)\n{\n\tif (t <= nodes[id].l || nodes[id].r <= s)\n\t{\n\t\treturn 2147483647;\n\t}\n\tif (nodes[id].num >= 0)\n\t{\n\t\treturn nodes[id].num;\n\t}\n\tint mini = 2147483647;\n\tint m = (nodes[id].l + nodes[id].r) / 2;\n\tif (nodes[id].right != -1)\n\t{\n\t\tif (m < t)\n\t\t{\n\t\t\tmini = min(mini, find(nodes[id].right,s, t));\n\t\t}\n\t}\n\tif (nodes[id].left != -1)\n\t{\n\t\tif (s < m)\n\t\t{\n\t\t\tmini = min(mini, find(nodes[id].left, s, t));\n\t\t}\n\t}\n\treturn mini;\n}\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\n\tBuild(0, n);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint c, s, t, v;\n\t\tscanf(\"%d\", &c);\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\tscanf(\"%d %d %d\", &s, &t, &v);\n\t\t\tupdate(0, s, t + 1, v);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscanf(\"%d\", &s);\n\t\t\tcout << find(0, s, s + 1) << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define INF 3e18\n#define rep(i,n) for(int i=0;i<n;i++)\n#define P pair<int,int>\nint n,N;\nP dat[444444];\nvoid init(){\n\tint x=1;\n\twhile(x<n)x*=2;\n\tN=x;\n\trep(i,N*2-1)dat[i]={((int)1<<31)-1,INF};\n}\nvoid eval(int k,int l,int r){\n\tif(dat[k].second!=INF){\n\t\tdat[k].first=dat[k].second;\n\t\tif(r-l>1){\n\t\t\tdat[2*k+1].second=dat[k].second;\n\t\t\tdat[2*k+2].second=dat[k].second;\n\t\t}\n\t\tdat[k].second=INF;\n\t}\n}\nvoid update(int a,int b,int x,int k,int l,int r){\n\teval(k,l,r);\n\tif(b<=l||r<=a)return;\n\tif(a<=l&&r<=b){\n\t\tdat[k].second=x;\n\t\teval(k,l,r);\n\t}\n\telse{\n\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t}\n}\nint query(int a,int k,int l,int r){\n\teval(k,l,r);\n\tif(r-l==1)return dat[k].first;\n\tif(a<(l+r)/2)return query(a,k*2+1,l,(l+r)/2);\n\telse return query(a,k*2+2,(l+r)/2,r);\n}\nsigned main(){\n\tint q;\n\tcin>>n>>q;\n\tinit();\n\trep(i,q){\n\t\tint Q;\n\t\tcin>>Q;\n\t\tif(Q==0){\n\t\t\tint s,t,x;\n\t\t\tcin>>s>>t>>x;\n\t\t\tupdate(s,t+1,x,0,0,N);\n\t\t}\n\t\telse{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tcout<<query(x,0,0,N)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  int n;\n  T ti;\n  E ei;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n\n  LazySegmentTree(int n_, F f, G g, H h, T ti = INT_MAX, E ei = INT_MAX,\n                  P p = [](E a, int b) { return a; })\n      : f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n    init(n_);\n  }\n  void init(int n_) {\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, ti);\n    lazy.assign(n * 2 - 1, ei);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == ei) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = ei;\n  }\n  T update(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return data[k];\n    if (a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      return g(data[k], p(lazy[k], r - l));\n    }\n    T vl = update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    T vr = update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    return data[k] = f(vl, vr);\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return ti;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  const int INF = INT_MAX;\n  LazySegmentTree<int, int>::F f = [&](int a, int b) { return min(a, b); };\n  LazySegmentTree<int, int>::G g = [&](int a, int b) { return (b == INF) ? a : b; };\n  LazySegmentTree<int, int>::H h = [&](int a, int b) { return (b == INF) ? a : b; };\n  LazySegmentTree<int, int>::P p = [&](int a, int b) { return (a == INF) ? a : a * b; };\n\n  LazySegmentTree<int, int> seg(n, f, g, h);\n  for (int i = 0; i < q; ++i) {\n    int com; cin >> com;\n    if (com) {\n      int i; cin >> i;\n      cout << seg.query(i, i + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <climits>\n#include <set>\n#include <unordered_set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <complex>\n#include <regex>\n#include <locale>\n#include <random>\n#include <cassert>\n#include <type_traits>\n\nusing namespace std;\n\n// typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<VPII> VVPII;\ntypedef vector<VPLL> VVPLL;\ntypedef vector<VS> VVS;\ntypedef map<int, int> MII;\ntypedef map<LL, LL> MLL;\ntypedef map<string, int> MSI;\ntypedef map<int, string> MIS;\n\n// container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define EACH(i, arr) for(typeof((arr).begin()) i=(arr).begin(); i!=(arr).end(); ++i)\n#define EXIST(str, e) ((str).find(e)!=(str).end())\n#define COUNT(arr, v) count((arr).begin(), (arr).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define ROTATE_LEFT(arr, c) rotate((arr).begin(), (arr).begin()+(c), (arr).end())\n#define ROTATE_RIGHT(arr, c) rotate((arr).rbegin(), (arr).rbegin() + (c), (arr).rend())\n#define SUMI(arr) accumulate((arr).begin(), (arr).end(), 0)\n#define SUMD(arr) accumulate((arr).begin(), (arr).end(), 0.)\n#define SUMLL(arr) accumulate((arr).begin(), (arr).end(), 0LL)\n#define MULD(arr) accumulate((arr).begin(), (arr).end(), 1., multiplies<double>())\n#define UB(arr, n) upper_bound((arr).begin(), (arr).end(), n)\n#define LB(arr, n) lower_bound((arr).begin(), (arr).end(), n)\n#define PB push_back\n#define MP make_pair\n#define ft first\n#define sd second\n\n\n// input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT() std::ios::sync_with_stdio(false);std::cin.tie(0)\n#define OUT(d) std::cout<<(d)\n#define OUT_L(d) std::cout<<(d)<<endl\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\"\n#define EL() printf(\"\\n\")\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yay() printf(\"Yay!\\n\")\n#define Nnn() printf(\":(\\n\")\n#define CE(x, y) ((x + y - 1) / (y))\n\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &v) {\n    for (auto &x: v)\n        in >> x;\n    return in;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, const std::pair<T1, T2> &p) {\n    out << \"[\" << p.first << \", \" << p.second << \"]\" << \"\\n\";\n    return out;\n}\n\ntemplate<class T1, class T2>\ninline bool chmin(T1 &a, T2 b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T1, class T2>\ninline bool chmax(T1 &a, T2 b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, arr) for(auto &(x) : (arr))\n\n//------------------------------------------\n//------------------------------------------\n\nconstexpr int sqrtN = 512;\nconstexpr int INF = INT_MAX;\n\nstruct SqrtDecomposition {\n\n    int N;\n    int K;\n\n    vector<int> data;\n    vector<int> bucket;\n    vector<bool> lazyFlag;\n\n    SqrtDecomposition(int N) : N(N) {\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(sqrtN * K, INF);\n        bucket.assign(K, INF);\n        lazyFlag.assign(K, false);\n    }\n\n    void eval(int k) {\n        if (lazyFlag[k]) {\n            lazyFlag[k] = false;\n            for (int i = k * sqrtN; i < (k + 1) * sqrtN; i++) {\n                data[i] = bucket[k];\n            }\n        }\n    }\n\n    void update(int a, int b, int x) {\n        for (int k = 0; k < K; k++) {\n            int l = k * sqrtN;\n            int r = (k + 1) * sqrtN;\n            if (b <= l or r <= a) continue;\n            if (a <= l and r <= b) {\n                lazyFlag[k] = true;\n                bucket[k] = x;\n            } else {\n                eval(k);\n                for (int i = max(a, l); i < min(b, r); i++) {\n                    data[i] = x;\n                }\n            }\n        }\n    }\n\n    int find(int p) {\n        int k = p / sqrtN;\n        eval(k);\n        return data[p];\n    }\n\n};\n\nint main() {\n\n    int N, Q;\n    cin >> N >> Q;\n\n    SqrtDecomposition deco(N);\n\n    while (Q--) {\n        int w;\n        cin >> w;\n\n        if (w == 0) {\n            int l, r, x;\n            cin >> l >> r >> x;\n            deco.update(l, r + 1, x);\n        } else {\n            int p;\n            cin >> p;\n            cout << deco.find(p) << endl;\n        }\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 2147483647\n//static const double INF = (1 << 31)-1;\n\nint n,q;\ndouble d[400000],lazy[400000];\ndouble x;\n\nvoid lazy_evaluate(int k,int l,int r){\n\tif(lazy[k] == INF)return;\n\telse{\n\t\td[k] = lazy[k];\n\t\tif(r - l > 1){\n\t\t\tlazy[2*k+1] = lazy[k];\n\t\t\tlazy[2*k+2] = lazy[k];\n\t\t\t/*\n\t\t\tlazy_evaluate(2*k+1);\n\t\t\tlazy_evaluate(2*k+2);\n\t\t\t*/\n\t\t}\n\t\tlazy[k] = INF;\n\t}\n}\n/*\nvoid update(int k,double a){\n\tk += n - 1;\n\td[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1)/2;\n\t\td[k] = min(d[k*2+1], d[k*2+2]);\n\t}\n}\n*/\nvoid query(int a, int b, int k=0, int l=0, int r=-1){\n\tif(r < 0){\n\t\tr = n;\n\t}\n\t//cout << \"haittemasu\" << endl;\n\t\n\tlazy_evaluate(k,l,r);\n\tif(b <= l || r <= a) return;\n\telse if(a <= l && r <= b){\n\t\tlazy[k] = x;\n\t\tlazy_evaluate(k,l,r);\n\t}\n\telse{\n\t\tquery(a,b,2*k+1,l,(l+r)/2);\n\t\tquery(a,b,2*k+2,(l+r)/2,r);\n\t\td[k] = min(d[2*k+1], d[2*k+2]);\n\t}\n}\n\n/*\ndouble query(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn INF;\n\t}\n\telse if(a <= l && r <= b){\n\t\treturn d[k];\n\t}\n\n\tdouble vl = query(a, b, k*2+1, l, (l + r)/2);\n\tdouble vr = query(a, b, k*2+2, (l + r)/2, r);\n\treturn min(vl, vr);\n}\n\ndouble findMin(int a, int b){\n\treturn query(a, b+1, 0, 0, n);\n}\n*/\n\nvoid find(int a, int b, int k=0, int l=0, int r=-1){\n\tif(r < 0){\n\t\tr = n;\n\t}\n\tlazy_evaluate(k,l,r);\n\tif(b <= l || r <= a){\n\t\treturn;\n\t}\n\telse if(a <= l && r <= b){\n\t\treturn;\n\t}\n\n\t//double vl = \n\tfind(a, b, k*2+1, l, (l + r)/2);\n\t//double vr = \n\tfind(a, b, k*2+2, (l + r)/2, r);\n\t//return min(vl, vr);\n\n}\n\nint main(){\n\tint n_;\n\tcin >> n_ >> q;\n\n\tn=1;\n\twhile(n<n_){\n\t\tn*=2;\n\t}\n\tfor(int i = 0;i < n*2-1;i++){\n\t\td[i] = INF;\n\t\tlazy[i] = INF;\n\t}\n\tint a, b;   \n\tdouble s,t;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> s >> t >> x;\n\t\t\tquery(s,t+1);\n\t\t}\n\t\telse{\n\t\t\tcin >> b;\n\t\t\tfind(b,b+1);\n\t\t\tprintf(\"%.0f\\n\",d[b+n-1]);\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0;i < n*2-1;i++){\n\t\tcout << d[i] << endl;\n\t}\n\t*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 100010\n\nint t[5 * maxn], lazy[5 * maxn];\n\nint doit(int a, int b) {\n    return a + b;\n}\n\nvoid build(int start, int end, int index = 1) {\n    if (start == end) {\n        t[index] = INT_MAX;\n        return;\n    }\n\n    int mid = start + end >> 1;\n    build(start, mid, index << 1);\n    build(mid + 1, end, index << 1 | 1);\n\n    t[index] = doit(t[index << 1], t[index << 1 | 1]);\n}\n\nvoid propagate(int start, int end, int index) {\n    t[index] = lazy[index];\n    if (start != end) {\n        lazy[index << 1] = lazy[index];\n        lazy[index << 1 | 1] = lazy[index];\n    }\n    lazy[index] = -1;\n}\n\nint query(int start, int end, int l, int r, int index = 1) {\n    if (lazy[index] != -1)\n        propagate(start, end, index);\n    //Invalid range\n    if (r < start or l > end)\n        return 0;\n\n    //In range\n    if (l <= start and end <= r) {\n        return t[index];\n    }\n\n    int mid = start + end >> 1;\n    return doit(query(start, mid, l, r, index << 1), query(mid + 1, end, l, r, index << 1 | 1));\n}\n\nvoid pUpdate(int start, int end, int point, int val, int index = 1) {\n    if (start == end) {\n        t[index] += val;\n        return;\n    }\n\n    int mid = start + end >> 1;\n    if (point <= mid)\n        pUpdate(start, mid, point, val, index << 1);\n    else\n        pUpdate(mid + 1, end, point, val, index << 1 | 1);\n\n    t[index] = doit(t[index << 1], t[index << 1 | 1]);\n}\n\nvoid rangeUpdate(int start, int end, int l, int r, int val, int index) {\n    if (lazy[index] != -1)\n        propagate(start, end, index);\n    if (l > end or r < start)\n        return;\n\n    if (l <= start and end <= r) {\n        lazy[index] = val;\n        propagate(start, end, index);\n        return;\n    }\n\n    int mid = start + end >> 1;\n    rangeUpdate(start, mid, l, r, val, index << 1);\n    rangeUpdate(mid + 1, end, l, r, val, index << 1 | 1);\n\n    t[index] = doit(t[index << 1], t[index << 1 | 1]);\n}\n\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n\n    build(0, n - 1, 1);\n    memset(lazy, -1, sizeof lazy);\n\n    for (int i = 0; i < q; i++) {\n        int a;\n        cin >> a;\n\n        if (a == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            rangeUpdate(0, n - 1, s, t, x, 1);\n        } else {\n            int t;\n            cin >> t;\n\n            cout << query(0, n - 1, t, t, 1) << endl;\n        }\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dat[400000], lazy[400000], N;\ninline void push(int k) {\n\tif (lazy[k] == -1)return;\n\tdat[k] = lazy[k];\n\tif (k < N - 1) {\n\t\tlazy[2 * k + 1] = lazy[k];\n\t\tlazy[2 * k + 2] = lazy[k];\n\t}\n\tlazy[k] = -1;\n}\ninline void update_node(int k) {\n\tdat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n}\ninline void update(int a, int b, int x, int k, int l, int r) {\n\tpush(k);\n\tif (r <= a || b <= l)return;\n\tif (a <= l&&r <= b) {\n\t\tlazy[k] = x; push(k); return;\n\t}\n\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2); update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\tupdate_node(k);\n}\ninline int query(int a, int b, int k, int l, int r) {\n\tpush(k);\n\tif (r <= a || b <= l)return INT_MAX;\n\tif (a <= l&&r <= b)return dat[k];\n\tint lb = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tint rb = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\tupdate_node(k);\n\treturn min(lb, rb);\n}\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tN = 1; while (N < n)N <<= 1;\n\trep(i, 2 * N - 1)dat[i] = INT_MAX, lazy[i] = -1;\n\trep(i, q) {\n\t\tint t; scanf(\"%d\", &t);\n\t\tif (t == 0) {\n\t\t\tint a, b, x; scanf(\"%d%d%d\", &a, &b, &x);\n\t\t\tupdate(a, b + 1, x, 0, 0, N);\n\t\t}\n\t\telse {\n\t\t\tint a; scanf(\"%d\", &a);\n\t\t\tprintf(\"%d\\n\", query(a, a + 1, 0, 0, N));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n\n#define INF_LL 9000000000000000000\n#define INF 2000000000\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nclass RangeSeg{\n\tint n;\n\tvector<ll> data, lazy;\npublic:\n\tRangeSeg(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n <<= 1;\n\t\tREP(i, n*2-1){\n\t\t\tdata.push_back(-1);\n\t\t\tlazy.push_back(-1);\n\t\t}\n\t}\n\n\tvoid push(int l, int r, int k){\n\t\tif(lazy[k] != -1){\n\t\t\tdata[k] = lazy[k];\n\t\t\tif(r - l > 1){\n\t\t\t\tlazy[k*2+1] = lazy[k];\n\t\t\t\tlazy[k*2+2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int l, int r, int k, int x){\n\t\tpush(k, l, r);\n\t\tif(s <= l && r <= t){\n\t\t\tlazy[k] = x;\n\t\t\tpush(l, r, k);\n\t\t}else if(l < t && s < r){\n\t\t\tupdate(s, t, (l+r)/2, r, k*2+2, x);\n\t\t\tupdate(s, t, l, (l+r)/2, k*2+1, x);\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tupdate(s, t, 0, n, 0, x);\n\t}\n\t\n\tvoid show(){\n\t\tint i = 0;\n\t\tint en = 1;\n\t\twhile(i < n*2-1){\n\t\t\tcout << \"(\" << data[i] << \", \" << lazy[i] << \") \";\n\t\t\tif(i == en*2-2){\n\t\t\t\tcout << endl;\n\t\t\t\ten *= 2;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tll find(int l, int r, int k, int i){\n\t\tpush(l, r, k);\n\t\tif(r-l == 1){\n\t\t\treturn data[k];\n\t\t}\n\t\tif(l <= i && i <= r){\n\t\t\tif((l+r)/2 <= i){\n\t\t\t\treturn find((l+r)/2, r, k*2+2, i);\n\t\t\t}else{\n\t\t\t\treturn find(l, (l+r)/2, k*2+1, i);\n\t\t\t}\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tll find(int i){\n\t\treturn find(0, n, 0, i);\n\t}\t\n};\n\nint main(void){\n\tint n, q;\n\tcin >> n >> q;\n\tRangeSeg rs(n);\n\tREP(i, q){\n\t\tint com;\n\t\tcin >> com;\n\t\tif(com == 0){\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\trs.update(s, t+1, x);\n\t\t}else{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tx = rs.find(x);\n\t\t\tif(x == -1)\n\t\t\t\tcout << ((ll)1 << 31)-1 << endl;\n\t\t\telse\n\t\t\t\tcout << x << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = (1ll << 31) - 1;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T>\nstruct RangeUpdateQuery {\n\tint n;\n\tvector<int>d;\n\tRangeUpdateQuery(int m) {\n\t\tfor (n = 1; n < m; n <<= 1);\n\t\td.assign(2 * n, INF);\n\t}\n\tint find(int i) {\n\t\tupdate(i, i + 1);\n\t\treturn d[n + i];\n\t}\n\tvoid update(int a, int b, int x=-1, int k = 1, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\n\t\tif (r <= a || b <= l)return;\n\t\telse if (a <= l&&r <= b) {\n\t\t\tif (x >= 0)d[k] = x;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (d[k] != INF)d[2 * k] = d[2 * k + 1] = d[k], d[k] = INF;\n\t\t\tupdate(a, b, x, 2 * k, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) / 2, r);\n\t\t}\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tRangeUpdateQuery<int>ruq(n);\n\trep(i, 0, q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint x; cin >> x;\n\t\t\tcout << ruq.find(x) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  math2do\n *    created: 28.02.2020 20:21:13\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int pinf = std::numeric_limits<int>::max();\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    int val = pinf;\n    bool mark = false;\n\n    void apply(int l, int h, int v) {\n      val = v;\n      mark = true;\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    node res;\n    return res;\n  }\n \n  inline void push(int i, int l, int h) {\n    int m = (l + h) >> 1;\n    // push from i into lc and rc\n    if (tree[i].mark) {\n      tree[i << 1].apply(l, m, tree[i].val);\n      tree[(i << 1) + 1].apply(m + 1, h, tree[i].val);\n      tree[i].mark = false;\n    }\n  }\n \n  inline void pull(int i) {\n    tree[i] = unite(tree[i << 1], tree[(i << 1) + 1]);\n  }\n \n  int n;\n  vector<node> tree;\n \n  void build(int i, int l, int h) {\n    if (l == h) {\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m);\n    build((i << 1) + 1, m + 1, h);\n    pull(i);\n  }\n \n  template <typename M>\n  void build(int i, int l, int h, const vector<M> &v) {\n    if (l == h) {\n      tree[i].apply(l, h, v[l]);\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m, v);\n    build((i << 1) + 1, m + 1, h, v);\n    pull(i);\n  }\n \n  node get(int i, int l, int h, int ql, int qh) {\n    if (ql <= l && h <= qh) {\n      return tree[i];\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    node res{};\n    if (qh <= m) {\n      res = get(i << 1, l, m, ql, qh);\n    } else {\n      if (ql > m) {\n        res = get((i << 1) + 1, m + 1, h, ql, qh);\n      } else {\n        res = unite(get(i << 1, l, m, ql, qh), get((i << 1) + 1, m + 1, h, ql, qh));\n      }\n    }\n    pull(i);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int i, int l, int h, int ql, int qh, const M&... v) {\n    if (ql <= l && h <= qh) {\n      tree[i].apply(l, h, v...);\n      return;\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    if (ql <= m) {\n      modify(i << 1, l, m, ql, qh, v...);\n    }\n    if (qh > m) {\n      modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n    }\n    pull(i);\n  }\n \n  int find_first_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[i << 1])) {\n      res = find_first_knowingly(i << 1, l, m, f);\n    } else {\n      res = find_first_knowingly((i << 1) + 1, m + 1, h, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_first(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_first_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (ql <= m) {\n      res = find_first(i << 1, l, m, ql, qh, f);\n    }\n    if (qh > m && res == -1) {\n      res = find_first((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[(i << 1) + 1])) {\n      res = find_last_knowingly((i << 1) + 1, m + 1, h, f);\n    } else {\n      res = find_last_knowingly(i << 1, l, m, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_last_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (qh > m) {\n      res = find_last((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    if (ql <= m && res == -1) {\n      res = find_last(i << 1, l, m, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1, v);\n  }\n \n  node get(int ql, int qh) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return get(1, 0, n - 1, ql, qh);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(1, 0, n - 1, p, p);\n  }\n \n  template <typename... M>\n  void modify(int ql, int qh, const M&... v) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    modify(1, 0, n - 1, ql, qh, v...);\n  }\n \n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n \n  int find_first(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_first(1, 0, n - 1, ql, qh, f);\n  }\n \n  int find_last(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_last(1, 0, n - 1, ql, qh, f);\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  segtree st(n);\n  while (q--) {\n    int t;\n    cin >> t;\n    if (t == 0) {\n      int x, y, v;\n      cin >> x >> y >> v;\n      st.modify(x, y, v);\n    } else {\n      int x;\n      cin >> x;\n      auto ans = st.get(x, x);\n      cout << ans.val << '\\n';\n    } \n  } \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1<<20)\n#define NIL -1\n\nstruct RUQ {\n\tint N;\n\tint a[N_SIZE];\n\tint seg[N_SIZE * 2];\n\tint lazy[N_SIZE * 2];\n\tint gt;\n\tvoid init(int n) {\n\t\tN = n;\n\t\tgt = 1;\n\t\twhile (N > gt)gt *= 2;\n\t\tREP(i, n)a[i] = (1LL << 31) - 1;\n\t\tREP(i, N_SIZE) {\n\t\t\tseg[i] = (1LL << 31) - 1;\n\t\t\tlazy[i] = NIL;\n\t\t}\n\t\tREP(i, n)seg[i + gt - 1] = a[i];\n\t}\n\n\tvoid lazy_evaluate(int k) {\n\t\tseg[k] = lazy[k];\n\t\tif (k < gt) {\n\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\tlazy[2 * k + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = NIL;\n\t}\n\n\tvoid update(int a, int b, int x) {\n\t\tupdate(a, b, 0, 0, gt, x);\n\t}\n\tvoid update(int a, int b, int k, int l, int r, int x) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = x;\n\t\t}\n\t\telse {\n\t\t\tif (lazy[k] != NIL)lazy_evaluate(k);\n\t\t\tupdate(a, b, 2 * k + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, 2 * k + 2, (l + r) / 2, r, x);\n\t\t}\n\t}\n\n\tll query(int a, int b) {\n\t\treturn query(a, b, 0, 0, gt);\n\t}\n\tll query(int a, int b, int k, int l, int r) {\n\t\tll res = NIL;\n\t\tif (r <= a || b <= l)return res;\n\t\tif (a <= l&&r <= b) {\n\t\t\t//cout << k << endl;\n\t\t\tif (lazy[k] != NIL)lazy_evaluate(k);\n\t\t\treturn seg[k];\n\t\t}\n\t\telse {\n\t\t\tif (lazy[k] != NIL) {\n\t\t\t\t//cout << k << endl;\n\t\t\t\tlazy_evaluate(k);\n\t\t\t}\n\t\t\tll num[2] = { query(a, b, 2 * k + 1, l, (l + r) / 2),\n\t\t\t\tquery(a, b, 2 * k + 2, (l + r) / 2, r) };\n\t\t\tREP(i, 2) {\n\t\t\t\tif (num[i] != NIL)res = num[i];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid print() {\n\t\tREP(i, gt * 2) {\n\t\t\tcout << \"!\" << i << \" \" << seg[i] << \" \" << lazy[i] << endl;\n\t\t}\n\t}\n};\n\nRUQ ruq;\n\nint n, q;\n\nint main() {\n\tcin >> n >> q;\n\truq.init(n);\n\tREP(i, q) {\n\t\tint s, t, x;\n\t\tbool f;\n\t\tcin >> f;\n\t\tif (!f) {\n\t\t\tcin >> s >> t >> x;\n\t\t\truq.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tcin >> x;\n\t\t\tcout << ruq.query(x, x + 1) << endl;\n\t\t}\n\t\t//ruq.print();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node,lazy;\n    vector<bool> upd;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1;\n        while (n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1,0);\n        upd.resize(2*n-1,false);\n        for (int i = 0;i < sz;++i) node[i+n-1] = v[i];\n        for (int i = n-2;i >= 0;--i) node[i] = max(node[i*2+1],node[i*2+2]);\n    }\n\n    void eval(int k,int l,int r) {\n        if (upd[k]) {\n            node[k] = lazy[k];\n            if (r-l > 1) {\n                lazy[2*k+1] = lazy[2*k+2] = lazy[k];\n                upd[2*k+1] = upd[2*k+2] = true;\n            }\n            lazy[k] = 0;\n            upd[k] = false;\n        }\n    }\n\n    void update(int a,int b,ll x,int k = 0,int l = 0,int r = -1) {\n        if (r < 0) r = n;\n        eval(k,l,r);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            upd[k] = true;\n            eval(k,l,r);\n        } else {\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k] = max(node[2*k+1],node[2*k+2]);\n        }\n    }\n\n    ll getmax(int a,int b,int k = 0,int l = 0,int r = -1) {\n        if (r < 0) r = n;\n        if (b <= l || r <= a) return 0;\n        eval(k,l,r);\n        if (a <= l && r <= b) return node[k];\n        ll vl = getmax(a,b,k*2+1,l,(l+r)/2);\n        ll vr = getmax(a,b,2*k+2,(l+r)/2,r);\n        return max(vl,vr);\n    }\n};\n\nint main() {\n    int n,q;\n    cin >> n >> q;\n    LazySegmentTree seg(vector<ll>(n,INT_MAX));\n    for (int i = 0;i < q;++i) {\n        int c;\n        cin >> c;\n        if (c) {\n            int a;\n            cin >> a;\n            cout << seg.getmax(a,a+1) << endl;\n        } else {\n            int s,t,x;\n            cin >> s >> t >> x;\n            seg.update(s,t+1,x);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nconst int MAX_N = 1 << 19;\nconst int INIT_VALUE = INT_MAX;\nconst int INIT_LAZY = INT_MAX;\n//?????°???????????¨???????????°??????????????????\nint SIZE, dat[MAX_N], lazy[MAX_N];\n\n//?????????\nvoid init(int n_) {\n\t//?°????????????????????´???°???2???????????????\n\t//n_????¬???????????´???°, SIZE???????????°, 2*SIZE-1??????????´???°\n\tSIZE = 1;\n\twhile (SIZE < n_) {\n\t\tSIZE *= 2;\n\t}\n\t//??????????????????0???\n\tfor (int i = 0; i < 2 * SIZE - 1; i++) {\n\t\tdat[i] = INIT_VALUE;\n\t\tlazy[i] = INIT_LAZY;\n\t}\n}\n\nvoid setLazy(int k, int x){\n\tlazy[k] = x;\n\tdat[k] = x;\n}\n\nvoid lazy_evaluate(int k) {\n\tif(lazy[k]==INIT_LAZY){\n\t\treturn;\n\t}\n\tdat[k] = lazy[k];\n\tsetLazy(k*2+1, lazy[k]);\n\tsetLazy(k*2+2, lazy[k]);\n\tlazy[k] = INIT_LAZY;\n}\n\nvoid fix(int k){\n\tdat[k] = min(dat[k*2+1], dat[k*2+2]);\n}\n\nvoid update(int a, int b, int k, int l, int r, int x){\n\tif(b<=l || r<=a){\n\t\treturn;\n\t}\n\tif(a<=l&&r<=b){\n\t\tsetLazy(k, x);\n\t}else{\n\t\tlazy_evaluate(k);\n\t\tupdate(a, b, k*2+1, l, (l+r)/2, x);\n\t\tupdate(a, b, k*2+2, (l+r)/2, r, x);\n\t\tfix(k);\n\t}\n}\n\nint get(int a, int b, int k, int l, int r){\n\tif(b<=l || r<=a){\n\t\treturn INIT_VALUE;\n\t}\n\tif(a<=l&&r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\tint vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\tint vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\nint N, Q;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/AtCoder/jni/in.txt\");\n\tcin >> N >> Q;\n\tinit(N);\n\trep(q,0,Q)\n\t{\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(s, t+1, 0, 0, SIZE, x);\n\t\t} else {\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << get(i, i+1, 0, 0, SIZE) << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst long long Mx = 0x7FFFFFFF;\nlong long n, q, s, t, x, m = 1;\nlong long a[300000];\n\nvoid upd(long long s, long long t, long long x) {\n\tlong long ks = m - 1 + s, kt = m - 1 + t;\n\n\twhile (ks < kt) {\n\t\tif (ks % 2 == 0)\n\t\t\ta[ks] = x;\n\t\tif (kt % 2 == 1)\n\t\t\ta[kt] = x;\n\n\t\t\tks = ks / 2;\n\t\t\tkt = (kt - 2) / 2;\n\t}\n\tif (ks == kt)\n\t\ta[ks] = x;\n}\n\nlong long fd(long long s) {\n\ts = m - 1 + s;\n\n\twhile (a[s] == Mx && s > 0)\n\t\ts = (s - 1) / 2;\n\n\treturn a[s];\n}\n\nint main()\n{\n\tcin >> n >> q;\n\n\twhile (m <= n)\n\t\tm *= 2;\n\n\tfor (int i = 0; i < m * 2; i++)\n\t\ta[i] = Mx;\n\n\tfor (int j = 0; j < q; j++) {\n\t\tint p;\n\t\tcin >> p;\n\n\t\tif (p == 0) {\n\t\t\tcin >> s >> t >> x;\n\t\t\tupd(s, t, x);\n\t\t}\n\t\telse if (p == 1) {\n\t\t\tcin >> s;\n\t\t\tcout << fd(s) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// ????????´??°, ???????????§\n\n/*\nconst int DATA_NIL = 0;\ntemplate <class T>\nclass SegmentTree {\nprivate:\n    const int n;\n    vector<T> dat;\n    void prop_to(int i) { dat[i] = max(dat[i<<1], dat[i<<1|1]); }\n\npublic:\n    SegmentTree(int _n) : n(_n), dat(2*n, DATA_NIL) {}\n\n    void fill(int l, int r, T x)\n    {\n        l += n, r += n;\n        for (; l<r; l >>= 1, r >>= 1) {\n            if (l & 1) dat[l++] += x;\n            if (r & 1) dat[r-1] += x;\n        }\n    }\n\n    T get(int i)\n    {\n        T res = dat[i += n];\n        while (i >>= 1) { res += dat[i]; }\n        return res;\n    }\n\n    void push()\n    {\n        for (int i=1; i<n; i++) {\n            dat[i<<1] += dat[i];\n            dat[i<<1|1] += dat[i];\n            dat[i] = DATA_NIL;\n        }\n    }\n\n    void dump()\n    {\n        cerr << \"-----------\" << endl;\n        int h = __lg(2*n);\n        for (int i=1; i<=h; i++) {\n            for (int j=0; j<1<<(i-1); j++) cerr << dat[(1<<(i-1)) + j].second << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------\" << endl;\n    }\n};\n*/\n\n// ????????´??°, ???????????§\ntemplate<class Monoid>\nclass SegmentTree {\nprivate:\n    using T = typename Monoid::T;\n    Monoid op;\n    const int n;\n    vector<T> dat;\n    void prop_to(int i) { dat[i] = op(dat[2*i], dat[2*i+1]); }\n\npublic:\n    SegmentTree(int _n) : n(_n), dat(2*_n, op.identity()) {}\n    SegmentTree(const vector<T> &v) : n(v.size()), dat(2*n)\n    {\n        copy(v.begin(), v.end(), dat.begin() + n);\n        for (int i=n-1; i>0; i--) prop_to(i);\n    }\n\n    T get(int i)\n    {\n        T res = dat[i += n];\n        while (i >>= 1) res = op(res, dat[i]);\n        return res;\n    }\n\n    void update(int l, int r, const T &x) // [l, r)\n    {\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) {dat[l] = op(dat[l], x); l++; }\n            if (r & 1) {dat[r-1] = op(x, dat[r]); }\n        }\n    }\n};\n\nstruct RMQ {\n    using T = PII;\n    T operator() (const T &a, const T &b) { return max(a, b); }\n    static constexpr T identity() { return PII(-1, (1LL<<31) - 1); }\n};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n    SegmentTree<RMQ> seg_tree(N);\n\n    rep(q, Q) {\n       int T; cin >> T;\n        if (T == 0) {\n            int A, B, X; \n            cin >> A >> B >> X;\n            seg_tree.update(A, B+1, PII(q, X));\n        } else {\n            int I; cin >> I;\n            cout << seg_tree.get(I).second << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n update(s,t,x): [s,t) をxに変更する。\n find(s,t): [s,t) の最小値を出力する。\n */\n\nconst ll INIT = INT_MAX;\nconst ll NIL = LLONG_MAX;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    \n    SegTree(int _N):init_v(INIT) {\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, NIL);\n    }\n    \n    void lazy_evaluate(int k) {\n        if (lazy[k] == NIL) return;\n        node[k] = lazy[k];\n        if (k < N - 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        lazy[k] = NIL;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    ll update(int a, int b, int x) { return update(a, b, 0, 0, N, x); }\n    ll update(int a, int b, int k, int l, int r, int x) {\n        if (r <= a || b <= l) {\n            lazy_evaluate(k); // nodeの値を見るときは必ず遅延評価を更新する\n            return node[k]; // updateでは全体の中の最小を見つける必要があるため, [l,r)外になっても値を参照\n        }\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            ll vr = update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n            return node[k] = min(vl, vr);\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) {\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n};\n\n\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n,q; cin >> n >> q;\n    SegTree ST(n);\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int s,t,x; cin >> s >> t >> x;\n            ST.update(s,t+1,x);\n        }else{\n            int i; cin >> i;\n            cout << ST.query(i,i+1) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nconst int MAX_N = 1 << 19;\nconst int INIT_VALUE = INT_MAX;\nconst int INIT_LAZY = INT_MAX;\n//?????°???????????¨???????????°??????????????????\nint SIZE, dat[MAX_N], lazy[MAX_N];\n\n//?????????\nvoid init(int n_) {\n\t//?°????????????????????´???°???2???????????????\n\t//n_????¬???????????´???°, SIZE???????????°, 2*SIZE-1??????????´???°\n\tSIZE = 1;\n\twhile (SIZE < n_) {\n\t\tSIZE *= 2;\n\t}\n\t//??????????????????0???\n\tfor (int i = 0; i < 2 * SIZE - 1; i++) {\n\t\tdat[i] = INIT_VALUE;\n\t\tlazy[i] = INIT_LAZY;\n\t}\n}\n\nvoid setLazy(int k, int x){\n\tlazy[k] = x;\n\tdat[k] = x;\n}\n\nvoid lazy_evaluate(int k) {\n\tif(lazy[k]==INIT_LAZY){\n\t\treturn;\n\t}\n\tdat[k] = lazy[k];\n\tsetLazy(k*2+1, lazy[k]);\n\tsetLazy(k*2+2, lazy[k]);\n\tlazy[k] = INIT_LAZY;\n}\n\nvoid fix(int k){\n\tdat[k] = min(dat[k*2+1], dat[k*2+2]);\n}\n\nvoid update(int a, int b, int k, int l, int r, int x){\n\tif(b<=l || r<=a){\n\t\treturn;\n\t}\n\tif(a<=l&&r<=b){\n\t\tsetLazy(k, x);\n\t}else{\n\t\tlazy_evaluate(k);\n\t\tupdate(a, b, k*2+1, l, (l+r)/2, x);\n\t\tupdate(a, b, k*2+2, (l+r)/2, r, x);\n\t\tfix(k);\n\t}\n}\n\nint get(int a, int b, int k, int l, int r){\n\tif(b<=l || r<=a){\n\t\treturn INIT_VALUE;\n\t}\n\tif(a<=l&&r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\tint vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\tint vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint N, Q;\nvoid solve() {\n\tifcin(\"/storage/emulated/0/AppProjects/AtCoder/jni/in.txt\");\n\tcin >> N >> Q;\n\tinit(N);\n\trep(q,0,Q)\n\t{\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(s, t+1, 0, 0, SIZE, x);\n\t\t} else {\n\t\t\tint i;\n\t\t\tcin >> i;\n\t\t\tcout << get(i, i+1, 0, 0, SIZE) << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>    //INT_MAXを使うためのinclude\nusing namespace std;\n\nint main(){\n    int s[10000];\n    int t[10000];\n    int x[10000];\n    int i, j, m, s_min, t_max, n, q, ask; \n\n    cin >> n >> q;\n    s_min = n;\n    t_max = 0;\n    m = 0;\n\twhile(q){\n        q--;\n        cin >> ask;\n        if(ask){\n            cin >> i;\n            if(i < s_min || i > t_max){\n                cout << INT_MAX << endl;\n            }else{\n                for(j = m; j >= 0; j--){\n                    if(s[j] <= i && t[j] >= i){\n                        cout << x[j] << endl;\n                        break;\n                    }\n                }\n            }\n        }else{\n            cin >> s[m] >> t[m] >> x[m];\n\t\t\tif(s[m] < s_min) s_min = s[m];\n\t\t\tif(t[m] > t_max) t_max = t[m];\n            m++;\n\t\t}\n\t};\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\ntemplate <class Monoid, class OperatorMonoid = Monoid> class LazySegmentTree {\n  using F = std::function<Monoid(Monoid, Monoid)>;\n  using G = std::function<Monoid(Monoid, OperatorMonoid, int)>;\n  using H = std::function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  private:\n    int n;\n    std::vector<Monoid> seg;\n    std::vector<OperatorMonoid> lazy;\n\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM1;\n\n    void lazyUpdate(int k, int l, int r) {\n      if(lazy[k] == OM1) return;\n\n      seg[k] = g(seg[k], lazy[k], r - l);\n      if(r - l > 1) {\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n        lazy[2 * k + 2] = h(lazy[2 * l + 2], lazy[k]);\n      }\n      lazy[k] = OM1;\n    }\n\n  public:\n    LazySegmentTree(int sz, const F f, const G g, const H h, const Monoid &M1, const OperatorMonoid &OM1) : f(f), g(g), h(h), M1(M1), OM1(OM1) {\n      n = 1;\n      while(n < sz) n *= 2;\n      seg.resize(2 * n - 1, M1);\n      lazy.resize(2 * n - 1, OM1);\n    }\n\n    void update(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n      if(r < 0) r = n;\n\n      lazyUpdate(k, l, r);\n\n      if(b <= l || r <= a) return;\n\n      if(a <= l && r <= b) {\n        lazy[k] = h(lazy[k], x);\n        lazyUpdate(k, l, r);\n      }\n      else {\n        update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n        update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n        seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n      }\n    }\n\n    Monoid query(int a, int b, int k = 0, int l = 0, int r = -1) {\n      if(r < 0) r = n;\n\n      lazyUpdate(k, l, r);\n\n      if(b <= l || r <= a) return M1;\n      if(a <= l && r <= b) return seg[k];\n      Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n      Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n      return f(vl, vr);\n    }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n  LazySegmentTree<int> seg(n, [](int a, int b){ return min(a, b); },\n                              [](int a, int b, int len){ return b; },\n                              [](int a, int b){ return b; }, INT_MAX, INT_MAX);\n  rep(i, 0, q) {\n    int c;\n    cin >> c;\n    if(c == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n    else {\n      int x;\n      cin >> x;\n      cout << seg.query(x, x + 1) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\n\n#define INF (1<<20)\nconst int MAX_N = 1 << 18;\n\ntypedef pair<int,int> P;\n\nint n;\nP dat[2*MAX_N-1];\n\nvoid init(int _n) {\n\tn = 1;\n\twhile(n < _n) n *= 2;\n\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\tdat[i].first = -1;\n\t\tdat[i].second = INT_MAX;\n\t}\n}\n\nint find(int k) {\n\tk += n-1;\n\tP p = dat[k];\n\n\twhile (k > 0) {\n\t\tk = (k-1)/2;\n\t\tp = max(p, dat[k]);\n\t}\n\n\treturn p.second;\n}\n\nvoid update(int a, int b, int k, P p, int l, int r) {\n\tif (r <= a || b <= l) return;\n\t\n\tif (a <= l && r <= b) {\n\t\tdat[k] = p;\n\t}\n\telse {\n\t\tupdate(a,b,k*2+1,p,l,(l+r)/2);\n\t\tupdate(a,b,k*2+2,p,(l+r)/2,r);\n\t}\n}\n\nint main() {\n\tint _n, q;\n\tcin >> _n >> q;\n\tinit(_n);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint j; cin >> j;\n\t\tif (j) {\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tcout << find(u) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tupdate(s,t+1,0,P(i,x),0,n);\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF INT_MAX\n#define LINF 1LL<<60\n\nstruct SegTree {\n\tint N;\n\tll init_v = INF;\n\tvector<ll> node, lazy;\n\n\tSegTree(int _N) {\n\t\tN = 1;\n\t\twhile (N < _N) N *= 2;\n\t\tnode.resize(2 * N - 1, init_v);\n\t\tlazy.resize(2 * N - 1, -1);\n\t}\n\n\tvoid lazy_evaluate(int k) {\n\t\tif (lazy[k] == -1) return;\n\t\tnode[k] = lazy[k];\n\t\tif (k < N - 1) {\n\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\tlazy[2 * k + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = -1;\n\t}\n\n\t/* [a,b) */\n\tvoid update(int a, int b, int x) { update(a, b, 0, 0, N, x); }\n\tvoid update(int a, int b, int k, int l, int r, int x) {\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tlazy_evaluate(k);\n\t\t}\n\t\telse {\n\t\t\tlazy_evaluate(k);\n\t\t\tupdate(a, b, 2 * k + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, 2 * k + 2, (l + r) / 2, r, x);\n\t\t}\n\t}\n\n\t/* [a,b) */\n\tll query(int a, int b) { return query(a, b, 0, 0, N); }\n\tll query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return init_v;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy_evaluate(k);\n\t\t\treturn node[k];\n\t\t}\n\t\telse {\n\t\t\tlazy_evaluate(k);\n\t\t\tll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\t}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, q; cin >> n >> q;\n\tSegTree ST(n);\n\tfor (int i = 0; i < q; i++) {\n\t\tint com; cin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tST.update(s, t + 1, x);\n\t\t}\n\t\telse {\n\t\t\tint j; cin >> j;\n\t\t\tcout << ST.query(j, j + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<iomanip>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <list>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <cfloat>\n#include <set>\n \nusing namespace std;\n \nint sqrtN = 512;\nstruct SqrtDecomposition{\n    int N, K;\n    vector <long long> data;\n    vector <long long> bucketUpdatedLazy;\n     \n    SqrtDecomposition(int n){\n        N = n;\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(N, ((long long) 1 << 31) - 1);\n        bucketUpdatedLazy.assign(K, -1);\n    }\n \n    void propagateLazy(int k){\n        if(bucketUpdatedLazy[k] < 0){\n            return;\n        }\n        for(int i = 0; i < sqrtN; i++){\n            data[k * sqrtN + i] = bucketUpdatedLazy[k];\n        }\n        bucketUpdatedLazy[k] = -1;\n    }\n\n    long long get(int x){\n        propagateLazy(x / sqrtN);\n        return data[x];\n    }\n \n    void update(int x, int y, int a){\n        if(y - x < sqrtN){\n            propagateLazy(x / sqrtN);\n            propagateLazy((y - 1) / sqrtN);\n            for(int i = x; i < y; i++){\n                data[i] = a;\n            }\n            return;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            bucketUpdatedLazy[i] = a;\n            //if(bucketUpdatedLazy[i] < 0 && bucketUpdatedLazy[i] != -1){\n            //    cerr << \"Warning\" << endl;\n            //}\n        }\n\n        propagateLazy(x / sqrtN);\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            data[i] = a;\n        }\n        propagateLazy((y - 1)/ sqrtN);\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            data[i] = a;\n        }\n    }\n     \n};\n\n \nint main(){\n    int n;\n    int q;\n    cin >> n >> q;\n    SqrtDecomposition sq(n);\n    for(int i = 0; i < q; i++){\n        int com;\n        int s;\n        int t;\n        int x;\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            sq.update(s, t + 1, x);\n        } else {\n            cin >> x;\n            cout << sq.get(x) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Prelude hiding (elem)\nimport Control.Applicative\nimport Control.Monad.State\ndata LazySegTree a =  Leaf a | Elem { eSize :: Int, elem :: a} | Tree { size :: Int\n                                                                      , left :: LazySegTree a\n                                                                      , right :: LazySegTree a\n                                                                      , lazy :: Bool\n                                                                      } deriving (Show)\n\nmain = do\n    [n, q] <- map read.words<$>getLine\n    let init = fromList $ replicate n (2^31 - 1)\n    print (n,q)\n    evalStateT (query q) init\n\nquery :: Int -> StateT (LazySegTree Int) IO ()\nquery 0 = return ()\nquery n  = do\n    getQuery\n    query (n-1)\n\ngetQuery :: StateT (LazySegTree Int) IO ()\ngetQuery = do\n    (x:xs) <- lift $ map read.words<$>getLine\n    tree <- get\n    case x of\n      0 -> traceShow (x:xs) $ let [s,t,x] = xs in modify (\\tr -> updateT tr s t x)\n      1 -> traceShow (x:xs) $ let [i] = xs in get >>= \\tr -> (lift $ print $ findT tr i)\n      3 -> lift (print $ tree)\n\nisElem :: LazySegTree a -> Bool\nisElem (Elem _ _) = True\nisElem _          = False\n\nfromList :: [a] -> LazySegTree a\nfromList xs = fl n xs\n    where n = length xs\n\nfl :: Int -> [a] -> LazySegTree a\nfl n [x] = Leaf x\nfl n xs = Tree n leftT rightT True\n    where n' = n `div` 2\n          (xsL, xsR) = splitAt n' xs\n          leftT = fl n' xsL\n          rightT = fl (n-n') xsR\n\nupdateT :: LazySegTree a -> Int -> Int -> a -> LazySegTree a\nupdateT (Leaf a) _ _ x = Leaf x\nupdateT tr s t x\n  | isElem tr = elemUpdateT tr s t x\n  | n <= s = tr { lazy = False, right = updateT (right tr) (s-n) (t-n) x }\n  | n > t  = tr { lazy = False, left = updateT (left tr) s t x }\n  | t-s+1 == size tr = Elem (size tr) x\n  | otherwise = tr { lazy = False\n                   , left = updateT (left tr) s (n-1) x\n                   , right = updateT (right tr) 0 (t-n) x\n                   }\n    where n = size tr `div` 2\n\nelemUpdateT tr s t x\n  | eSize tr == 1 = Leaf x\n  | n <= s = Tree { size = eSize tr, lazy = False, left = lt, right = elemUpdateT rt (s-n) (t-n) x}\n  | n > t = Tree { size = eSize tr, lazy = False, left = elemUpdateT lt s t x, right = rt }\n  | t - s + 1 == eSize tr = tr { elem = x }\n  | otherwise = Tree { lazy = False\n                     , left = elemUpdateT lt s (n-1) x\n                     , right = elemUpdateT rt 0 (t-n) x\n                     , size = eSize tr\n                     }\n    where n = eSize tr `div` 2\n          lt = Elem n (elem tr)\n          rt = Elem (eSize tr - n) (elem tr)\n\nfindT (Leaf x) 0 = x\nfindT tr i\n  | isElem tr = elem tr\n  | n <= i = findT (right tr) (i-n)\n  | n > i = findT (left tr) i\n    where n = size tr `div` 2\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Prelude hiding (elem)\nimport Control.Applicative\nimport Control.Monad.State\ndata LazySegTree a =  Leaf a | Elem { eSize :: Int, elem :: a} | Tree { size :: Int\n                                                                      , left :: LazySegTree a\n                                                                      , right :: LazySegTree a\n                                                                      , lazy :: Bool\n                                                                      } deriving (Show)\n\nmain = do\n    [n, q] <- map read.words<$>getLine\n    let init = fromList $ replicate n (2^31 - 1)\n    print (n,q)\n    evalStateT (query q) init\n\nquery :: Int -> StateT (LazySegTree Int) IO ()\nquery 0 = return ()\nquery n  = do\n    getQuery\n    query (n-1)\n\ngetQuery :: StateT (LazySegTree Int) IO ()\ngetQuery = do\n    (x:xs) <- lift $ map read.words<$>getLine\n    case x of\n      0 -> let [s,t,x] = xs in modify (\\tr -> updateT tr s t x)\n      1 -> let [i] = xs in get >>= \\tr -> (lift $ print $ findT tr i)\n\nisElem :: LazySegTree a -> Bool\nisElem (Elem _ _) = True\nisElem _          = False\n\nfromList :: [a] -> LazySegTree a\nfromList xs = fl n xs\n    where n = length xs\n\nfl :: Int -> [a] -> LazySegTree a\nfl n [x] = Leaf x\nfl n xs = Tree n leftT rightT True\n    where n' = n `div` 2\n          (xsL, xsR) = splitAt n' xs\n          leftT = fl n' xsL\n          rightT = fl (n-n') xsR\n\nupdateT :: LazySegTree a -> Int -> Int -> a -> LazySegTree a\nupdateT (Leaf a) _ _ x = Leaf x\nupdateT tr s t x\n  | isElem tr = elemUpdateT tr s t x\n  | n <= s = tr { lazy = False, right = updateT (right tr) (s-n) (t-n) x }\n  | n > t  = tr { lazy = False, left = updateT (left tr) s t x }\n  | t-s+1 == size tr = Elem (size tr) x\n  | otherwise = tr { lazy = False\n                   , left = updateT (left tr) s (n-1) x\n                   , right = updateT (right tr) 0 (t-n) x\n                   }\n    where n = size tr `div` 2\n\nelemUpdateT tr s t x\n  | eSize tr == 1 = Leaf x\n  | n <= s = Tree { size = eSize tr, lazy = False, left = lt, right = elemUpdateT rt (s-n) (t-n) x}\n  | n > t = Tree { size = eSize tr, lazy = False, left = elemUpdateT lt s t x, right = rt }\n  | t - s + 1 == eSize tr = tr { elem = x }\n  | otherwise = Tree { lazy = False\n                     , left = elemUpdateT lt s (n-1) x\n                     , right = elemUpdateT rt 0 (t-n) x\n                     , size = eSize tr\n                     }\n    where n = eSize tr `div` 2\n          lt = Elem n (elem tr)\n          rt = Elem (eSize tr - n) (elem tr)\n\nfindT (Leaf x) 0 = x\nfindT tr i\n  | isElem tr = elem tr\n  | n <= i = findT (right tr) (i-n)\n  | n > i = findT (left tr) i\n    where n = size tr `div` 2\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Prelude hiding (elem)\nimport Control.Applicative\nimport Control.Monad.State\ndata LazySegTree a =  Leaf a | Elem { size :: Int, elem :: a} | Tree { size :: Int\n                                                                     , left :: LazySegTree a\n                                                                     , right :: LazySegTree a\n                                                                     , lazy :: Bool\n                                                                     } deriving (Show)\n\nmain = do\n    [n, q] <- map read.words<$>getLine\n    let init = fromList $ replicate n (2^31 - 1)\n    evalStateT (query q) init\n\nquery :: Int -> StateT (LazySegTree Int) IO ()\nquery 0 = return ()\nquery n  = do\n    getQuery\n    query (n-1)\n\ngetQuery :: StateT (LazySegTree Int) IO ()\ngetQuery = do\n    (x:xs) <- lift $ map read.words<$>getLine\n    tree <- get\n    case x of\n      0 -> let [s,t,x] = xs in modify (\\tr -> updateT tr s t x)\n      1 -> let [i] = xs in get >>= \\tr -> (lift $ print $ findT tr i)\n\nisElem :: LazySegTree a -> Bool\nisElem (Elem _ _) = True\nisElem _          = False\n\nfromList :: [a] -> LazySegTree a\nfromList xs = fl n xs\n    where n = length xs\n\nfl :: Int -> [a] -> LazySegTree a\nfl n [x] = Leaf x\nfl n xs = Tree n leftT rightT True\n    where n' = n `div` 2\n          (xsL, xsR) = splitAt n' xs\n          leftT = fl n' xsL\n          rightT = fl (n-n') xsR\n\nupdateT :: LazySegTree a -> Int -> Int -> a -> LazySegTree a\nupdateT (Leaf a) _ _ x = Leaf x\nupdateT tr s t x\n  | isElem tr = elemUpdateT tr s t x\n  | n <= s = tr { lazy = False, right = updateT (right tr) (s-n) (t-n) x }\n  | n > t  = tr { lazy = False, left = updateT (left tr) s t x }\n  | t-s+1 == size tr = Elem (size tr) x\n  | otherwise = tr { lazy = False\n                   , left = updateT (left tr) s (n-1) x\n                   , right = updateT (right tr) 0 (t-n) x\n                   }\n    where n = size tr `div` 2\n\nelemUpdateT _ 0 0 x = Leaf x\nelemUpdateT tr s t x\n  | n <= s = Tree { size = size tr, lazy = False, left = lt, right = elemUpdateT rt (s-n) (t-n) x}\n  | n > t = Tree { size = size tr, lazy = False, left = elemUpdateT lt s t x, right = rt }\n  | t - s + 1 == size tr = tr { elem = x }\n  | otherwise = Tree { lazy = False\n                     , left = elemUpdateT lt s (n-1) x\n                     , right = elemUpdateT rt 0 (t-n) x\n                     , size = size tr\n                     }\n    where n = size tr `div` 2\n          lt = Elem n (elem tr)\n          rt = Elem (size tr - n) (elem tr)\n\nfindT (Leaf x) 0 = x\nfindT tr i\n  | isElem tr = elem tr\n  | n <= i = findT (right tr) (i-n)\n  | n > i = findT (left tr) i\n    where n = size tr `div` 2\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE UnboxedTuples #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE MultiWayIf #-}\n\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Monad.State\nimport Control.Monad.Primitive\nimport Control.Applicative\nimport Control.Arrow\nimport Data.List\nimport Data.Array\nimport Data.Array.IO\nimport Data.Maybe\nimport Data.Bits\nimport Data.Ord\nimport Data.Ratio\nimport Data.Int\nimport Data.Char\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.Set as Set\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.Tuple\nimport Data.Function\nimport Text.Printf\nimport Debug.Trace\nimport Numeric\n\nmodifyArray arr i f = readArray arr i >>= \\x -> writeArray arr i (f x)\n\nlistToTuple2 [a,b] = (a,b)\nlistToTuple3 [a,b,c] = (a,b,c)\nlistToTuple4 [a,b,c,d] = (a,b,c,d)\nlistToTuple5 [a,b,c,d,e] = (a,b,c,d,e)\n\nreadIntBS = fst . fromJust . BS.readInt\n\nfor = flip map\n\ninfixr 1 ?\n(?) :: Bool -> (a,a) -> a\n(?) b t = (if b then fst else snd) t\n\nmain :: IO ()\nmain = do\n  [n,q] <- map read . words <$> getLine :: IO [Int]\n  queries <- replicateM q $ map readIntBS . BS.words <$> BS.getLine :: IO [[Int]]\n\n \n  seg <- newLazySegmentTree n 0 (+) :: IO (IOULazySegmentTree Int)\n\n\n  forM_ queries $ \\query -> do\n    case query of\n      [0,s,t,x] -> modifyLazySegmentTree seg (s-1) t (+x)\n      [1,i] -> print =<< findLazySegmentTree seg (i-1)\n    \n  --mapM_ print =<< stToIO (showLazySegmentTree seg 4)\n  return ()\n  \n\ntype MLazySegmentTree v s a = (v s a, a, (a -> a -> a)) -- (セグメント木, 単位元, 二項演算)\ntype STLazySegmentTree s a = MLazySegmentTree VM.MVector s a\ntype IOLazySegmentTree a = STLazySegmentTree RealWorld a\ntype STULazySegmentTree s a = MLazySegmentTree VUM.MVector s a\ntype IOULazySegmentTree a = STULazySegmentTree RealWorld a\n\n\nnewLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => Int -> a -> (a -> a -> a) -> m (MLazySegmentTree v (PrimState m) a)\nnewLazySegmentTree n e f = return . (,e,f) =<< VGM.replicate m e\n  where m = 2 * (2 ^ (ceiling $ logBase 2 (fromIntegral n))) - 1\n\n\nmodifyLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => MLazySegmentTree v (PrimState m) a -> Int -> Int -> (a -> a) -> m ()\nmodifyLazySegmentTree (tree,e,f) x y g = do\n  aux 0 0 n\n  where\n    n = (VGM.length tree) `div` 2 + 1\n    aux i l r\n      | r <= x || y <= l = return ()\n      | x <= l && r <= y = VGM.read tree i >>= \\a -> VGM.write tree i (g a)\n      | otherwise = propag i >> aux (i*2+1) l ((l+r)`div`2) >> aux (i*2+2) ((l+r)`div`2) r\n\n    propag i = do\n      a <- VGM.read tree i\n      when (i<n-1) $ do\n        VGM.read tree (i*2+1) >>= \\b -> VGM.write tree (i*2+1) (f a b)\n        VGM.read tree (i*2+2) >>= \\b -> VGM.write tree (i*2+2) (f a b)\n        VGM.write tree i e\n\nfindLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => MLazySegmentTree v (PrimState m) a -> Int -> m a\nfindLazySegmentTree (tree,e,f) i = do\n  aux ((j-1)`div`2)\n  VGM.read tree j\n  where\n    n = (VGM.length tree + 1) `div` 2\n    j = i + n - 1\n    aux x = do\n      when (x >= 0) $ do\n        aux ((x-1)`div`2)\n        propag x\n\n    propag i = do\n      a <- VGM.read tree i\n      when (i < n-1) $ do\n        VGM.read tree (i*2+1) >>= \\b -> VGM.write tree (i*2+1) (f a b)\n        VGM.read tree (i*2+2) >>= \\b -> VGM.write tree (i*2+2) (f a b)\n        VGM.write tree i e\n\n\n\nshowLazySegmentTree :: (PrimMonad m, VGM.MVector v a, Show a) => MLazySegmentTree v (PrimState m) a -> Int -> m [String]\nshowLazySegmentTree (tree,_,_) len = do\n  let\n    n = (VGM.length tree) `div` 2 + 1\n    xs = init $ scanl (+) 0 (takeWhile (<=n) (iterate (*2) 1))\n    ys = reverse xs\n\n  forM (zip xs ys) $ \\(s,s') -> do\n    return . concat =<< (forM [s..s*2] $ \\i -> return . (\\str -> \"[\" ++ (take' (len * (n `div` (s+1)) + s'*2) str) ++ \"]\") . show =<< VGM.read tree i)\n\n  where\n    take' n xs = if length t <= n then t ++ (replicate (n - length t) ' ') else t\n      where t = take n xs\n\n\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE UnboxedTuples #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE MultiWayIf #-}\n\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Monad.State\nimport Control.Applicative\nimport Control.Arrow\nimport Control.Monad.Primitive\nimport Data.List\nimport Data.Array\nimport Data.Array.IO\nimport Data.Maybe\nimport Data.Bits\nimport Data.Ord\nimport Data.Ratio\nimport Data.Int\nimport Data.Char\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.Set as Set\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.Tuple\nimport Data.Function\nimport Text.Printf\nimport Debug.Trace\nimport Numeric\n\nmodifyArray arr i f = readArray arr i >>= \\x -> writeArray arr i (f x)\n\nlistToTuple2 [a,b] = (a,b)\nlistToTuple3 [a,b,c] = (a,b,c)\nlistToTuple4 [a,b,c,d] = (a,b,c,d)\nlistToTuple5 [a,b,c,d,e] = (a,b,c,d,e)\n\nreadIntBS = fst . fromJust . BS.readInt\n\nfor = flip map\n\ninfixr 1 ?\n(?) :: Bool -> (a,a) -> a\n(?) b t = (if b then fst else snd) t\n\nmain :: IO ()\nmain = do\n  [n,q] <- map read . words <$> getLine :: IO [Int]\n  queries <- replicateM q $ map read . words <$> getLine :: IO [[Int]]\n  let\n    inf = 2^31-1\n    f x y = if x == inf then y else x\n\n  \n  seg <- newLazySegmentTree n inf f :: IO (IOULazySegmentTree Int)\n\n  forM_ queries $ \\query -> do\n    case query of\n      [0,s,t,x] -> modifyLazySegmentTree seg s (t+1) (const x)\n      [1,i] -> print =<< findLazySegmentTree seg i\n\n    --mapM_ print =<< showLazySegmentTree seg 4\n    --print \"\"\n  \n  \n\n{-- 範囲更新・点取得のセグメント木--}\ntype MLazySegmentTree v s a = (v s a, a, (a -> a -> a)) -- (セグメント木, 単位元, 二項演算)\ntype STLazySegmentTree s a = MLazySegmentTree VM.MVector s a\ntype IOLazySegmentTree a = STLazySegmentTree RealWorld a\ntype STULazySegmentTree s a = MLazySegmentTree VUM.MVector s a\ntype IOULazySegmentTree a = STULazySegmentTree RealWorld a\n\nnewLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => Int -> a -> (a -> a -> a) -> m (MLazySegmentTree v (PrimState m) a)\nnewLazySegmentTree n e f = return . (,e,f) =<< VGM.replicate m e\n  where m = 2 * (2 ^ (ceiling $ logBase 2 (fromIntegral n))) - 1\n\nmodifyLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => MLazySegmentTree v (PrimState m) a -> Int -> Int -> (a -> a) -> m ()\nmodifyLazySegmentTree (tree,e,f) x y g = do\n  aux 0 0 n\n  where\n    n = (VGM.length tree) `div` 2 + 1\n    aux i l r\n      | r <= x || y <= l = return ()\n      | x <= l && r <= y = VGM.read tree i >>= \\a -> VGM.write tree i (g a)\n      | otherwise = propag i >> aux (i*2+1) l ((l+r)`div`2) >> aux (i*2+2) ((l+r)`div`2) r\n    propag i = do\n      a <- VGM.read tree i\n      when (i<n-1) $ do\n        VGM.read tree (i*2+1) >>= \\b -> VGM.write tree (i*2+1) (f a b)\n        VGM.read tree (i*2+2) >>= \\b -> VGM.write tree (i*2+2) (f a b)\n        VGM.write tree i e\n\nfindLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => MLazySegmentTree v (PrimState m) a -> Int -> m a\nfindLazySegmentTree (tree,e,f) i = do\n  aux ((j-1)`div`2)\n  VGM.read tree j\n  where\n    n = (VGM.length tree + 1) `div` 2\n    j = i + n - 1\n    aux x = do\n      when (x >= 0) $ do\n        aux ((x-1)`div`2)\n        propag x\n\n    propag i = do\n      a <- VGM.read tree i\n      when (i < n-1) $ do\n        VGM.read tree (i*2+1) >>= \\b -> VGM.write tree (i*2+1) (f a b)\n        VGM.read tree (i*2+2) >>= \\b -> VGM.write tree (i*2+2) (f a b)\n        VGM.write tree i e\n\nshowLazySegmentTree :: (PrimMonad m, VGM.MVector v a, Show a) => MLazySegmentTree v (PrimState m) a -> Int -> m [String]\nshowLazySegmentTree (tree,_,_) len = do\n  let\n    n = (VGM.length tree) `div` 2 + 1\n    xs = init $ scanl (+) 0 (takeWhile (<=n) (iterate (*2) 1))\n    ys = reverse xs\n\n  forM (zip xs ys) $ \\(s,s') -> do\n    return . concat =<< (forM [s..s*2] $ \\i -> return . (\\str -> \"[\" ++ (take' (len * (n `div` (s+1)) + s'*2) str) ++ \"]\") . show =<< VGM.read tree i)\n\n  where\n    take' n xs = if length t <= n then t ++ (replicate (n - length t) ' ') else t\n      where t = take n xs\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.Array.IO\n\nmain = do\n    [n,q] <- map read.words<$>getLine\n    initArray <- newArray (0,n-1) (2^31-1)\n    query q initArray\n    \nquery 0 _   = return ()\nquery n arr = do\n    q <- getQuery\n    q arr >>= query (n-1)\n\ngetQuery = do\n    (c:xs) <- map read.words<$>getLine\n    case c of\n      0 -> let [s,t,x] = xs in return (updateArr s t x)\n      1 -> let [i] = xs in return (findArr i)\n\nupdateArr :: (Enum i, Ix i) => i -> i -> Int -> IOUArray i Int -> IO (IOUArray i Int)\nupdateArr s t x arr = (forM [s..t] $ \\i -> writeArray arr i x) >> return arr\n\nfindArr :: Ix i => i -> IOUArray i Int -> IO (IOUArray i Int)\nfindArr i arr = readArray arr i >>= \\x -> print x >> return arr\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.Array.IO\n\nmain = do\n    [n,q] <- map read.words<$>getLine\n    initArray <- newArray (0,n-1) (2^31-1)\n    query q initArray\n    \nquery 0 _   = return ()\nquery n arr = do\n    q <- getQuery\n    q arr >>= query (n-1)\n\ngetQuery = do\n    (c:xs) <- map read.words<$>getLine\n    case c of\n      0 -> let [s,t,x] = xs in return (updateArr s t x)\n      1 -> let [i] = xs in return (findArr i)\n\nupdateArr :: (Enum i, Ix i) => i -> i -> Int -> IOUArray i Int -> IO (IOUArray i Int)\nupdateArr s t x arr = (forM [s..t] $ \\i -> writeArray arr i x) >> return arr\n\nfindArr :: Ix i => i -> IOUArray i Int -> IO (IOUArray i Int)\nfindArr i arr = readArray arr i >>= \\x -> print x >> return arr\n"
  },
  {
    "language": "Haskell",
    "code": "import Prelude hiding (elem)\nimport Control.Applicative\nimport Control.Monad.State\ndata LazySegTree a =  Leaf a | Elem { eSize :: Int, elem :: a} | Tree { size :: Int\n                                                                      , left :: LazySegTree a\n                                                                      , right :: LazySegTree a\n                                                                      , lazy :: Bool\n                                                                      } deriving (Show)\n\nmain = do\n    [n, q] <- map read.words<$>getLine\n    let init = fromList $ replicate n (2^31 - 1)\n    evalStateT (query q) init\n\nquery :: Int -> StateT (LazySegTree Int) IO ()\nquery 0 = return ()\nquery n  = do\n    getQuery\n    query (n-1)\n\ngetQuery :: StateT (LazySegTree Int) IO ()\ngetQuery = do\n    (x:xs) <- lift $ map read.words<$>getLine\n    case x of\n      0 -> let [s,t,x] = xs in modify (\\tr -> updateT tr s t x)\n      1 -> let [i] = xs in get >>= \\tr -> (lift $ print $ findT tr i)\n\nisElem :: LazySegTree a -> Bool\nisElem (Elem _ _) = True\nisElem _          = False\n\nfromList :: [a] -> LazySegTree a\nfromList xs = fl n xs\n    where n = length xs\n\nfl :: Int -> [a] -> LazySegTree a\nfl n [x] = Leaf x\nfl n xs = Tree n leftT rightT True\n    where n' = n `div` 2\n          (xsL, xsR) = splitAt n' xs\n          leftT = fl n' xsL\n          rightT = fl (n-n') xsR\n\nupdateT :: LazySegTree a -> Int -> Int -> a -> LazySegTree a\nupdateT (Leaf a) _ _ x = Leaf x\nupdateT tr s t x\n  | isElem tr = elemUpdateT tr s t x\n  | n <= s = tr { lazy = False, right = updateT (right tr) (s-n) (t-n) x }\n  | n > t  = tr { lazy = False, left = updateT (left tr) s t x }\n  | t-s+1 == size tr = Elem (size tr) x\n  | otherwise = tr { lazy = False\n                   , left = updateT (left tr) s (n-1) x\n                   , right = updateT (right tr) 0 (t-n) x\n                   }\n    where n = size tr `div` 2\n\nelemUpdateT tr s t x\n  | eSize tr == 1 = Leaf x\n  | n <= s = Tree { size = eSize tr, lazy = False, left = lt, right = elemUpdateT rt (s-n) (t-n) x}\n  | n > t = Tree { size = eSize tr, lazy = False, left = elemUpdateT lt s t x, right = rt }\n  | t - s + 1 == eSize tr = tr { elem = x }\n  | otherwise = Tree { lazy = False\n                     , left = elemUpdateT lt s (n-1) x\n                     , right = elemUpdateT rt 0 (t-n) x\n                     , size = eSize tr\n                     }\n    where n = eSize tr `div` 2\n          lt = Elem n (elem tr)\n          rt = Elem (eSize tr - n) (elem tr)\n\nfindT (Leaf x) 0 = x\nfindT tr i\n  | isElem tr = elem tr\n  | n <= i = findT (right tr) (i-n)\n  | n > i = findT (left tr) i\n    where n = size tr `div` 2\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE UnboxedTuples #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE MultiWayIf #-}\n\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Monad.State\nimport Control.Applicative\nimport Control.Arrow\nimport Control.Monad.Primitive\nimport Data.List\nimport Data.Array\nimport Data.Array.IO\nimport Data.Maybe\nimport Data.Bits\nimport Data.Ord\nimport Data.Ratio\nimport Data.Int\nimport Data.Char\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.Set as Set\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.Tuple\nimport Data.Function\nimport Text.Printf\nimport Debug.Trace\nimport Numeric\n\nmodifyArray arr i f = readArray arr i >>= \\x -> writeArray arr i (f x)\n\nlistToTuple2 [a,b] = (a,b)\nlistToTuple3 [a,b,c] = (a,b,c)\nlistToTuple4 [a,b,c,d] = (a,b,c,d)\nlistToTuple5 [a,b,c,d,e] = (a,b,c,d,e)\n\nreadIntBS = fst . fromJust . BS.readInt\n\nfor = flip map\n\ninfixr 1 ?\n(?) :: Bool -> (a,a) -> a\n(?) b t = (if b then fst else snd) t\n\nmain :: IO ()\nmain = do\n  [n,q] <- map read . words <$> getLine :: IO [Int]\n  queries <- replicateM q $ map readIntBS . BS.words <$> BS.getLine :: IO [[Int]]\n  let\n    inf = 2^31-1\n    f x y = if x == inf then y else x\n\n  \n  seg <- newLazySegmentTree n inf f :: IO (IOULazySegmentTree Int)\n\n  forM_ queries $ \\query -> do\n    case query of\n      [0,s,t,x] -> modifyLazySegmentTree seg s (t+1) (const x)\n      [1,i] -> print =<< findLazySegmentTree seg i\n\n    --mapM_ print =<< showLazySegmentTree seg 4\n    --print \"\"\n  \n  \n\n{-- 範囲更新・点取得のセグメント木--}\ntype MLazySegmentTree v s a = (v s a, a, (a -> a -> a)) -- (セグメント木, 単位元, 二項演算)\ntype STLazySegmentTree s a = MLazySegmentTree VM.MVector s a\ntype IOLazySegmentTree a = STLazySegmentTree RealWorld a\ntype STULazySegmentTree s a = MLazySegmentTree VUM.MVector s a\ntype IOULazySegmentTree a = STULazySegmentTree RealWorld a\n\nnewLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => Int -> a -> (a -> a -> a) -> m (MLazySegmentTree v (PrimState m) a)\nnewLazySegmentTree n e f = return . (,e,f) =<< VGM.replicate m e\n  where m = 2 * (2 ^ (ceiling $ logBase 2 (fromIntegral n))) - 1\n\nmodifyLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => MLazySegmentTree v (PrimState m) a -> Int -> Int -> (a -> a) -> m ()\nmodifyLazySegmentTree (tree,e,f) x y g = do\n  aux 0 0 n\n  where\n    n = (VGM.length tree) `div` 2 + 1\n    aux i l r\n      | r <= x || y <= l = return ()\n      | x <= l && r <= y = VGM.read tree i >>= \\a -> VGM.write tree i (g a)\n      | otherwise = propag i >> aux (i*2+1) l ((l+r)`div`2) >> aux (i*2+2) ((l+r)`div`2) r\n    propag i = do\n      a <- VGM.read tree i\n      when (i<n-1) $ do\n        VGM.read tree (i*2+1) >>= \\b -> VGM.write tree (i*2+1) (f a b)\n        VGM.read tree (i*2+2) >>= \\b -> VGM.write tree (i*2+2) (f a b)\n        VGM.write tree i e\n\nfindLazySegmentTree :: (PrimMonad m, VGM.MVector v a) => MLazySegmentTree v (PrimState m) a -> Int -> m a\nfindLazySegmentTree (tree,e,f) i = do\n  aux ((j-1)`div`2)\n  VGM.read tree j\n  where\n    n = (VGM.length tree + 1) `div` 2\n    j = i + n - 1\n    aux x = do\n      when (x >= 0) $ do\n        aux ((x-1)`div`2)\n        propag x\n\n    propag i = do\n      a <- VGM.read tree i\n      when (i < n-1) $ do\n        VGM.read tree (i*2+1) >>= \\b -> VGM.write tree (i*2+1) (f a b)\n        VGM.read tree (i*2+2) >>= \\b -> VGM.write tree (i*2+2) (f a b)\n        VGM.write tree i e\n\nshowLazySegmentTree :: (PrimMonad m, VGM.MVector v a, Show a) => MLazySegmentTree v (PrimState m) a -> Int -> m [String]\nshowLazySegmentTree (tree,_,_) len = do\n  let\n    n = (VGM.length tree) `div` 2 + 1\n    xs = init $ scanl (+) 0 (takeWhile (<=n) (iterate (*2) 1))\n    ys = reverse xs\n\n  forM (zip xs ys) $ \\(s,s') -> do\n    return . concat =<< (forM [s..s*2] $ \\i -> return . (\\str -> \"[\" ++ (take' (len * (n `div` (s+1)) + s'*2) str) ++ \"]\") . show =<< VGM.read tree i)\n\n  where\n    take' n xs = if length t <= n then t ++ (replicate (n - length t) ' ') else t\n      where t = take n xs\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t RUQ_val;\n\ntypedef struct range_update_query {\n  RUQ_val *val;\n  int32_t size;\n  int32_t bit;\n  RUQ_val empty;\n} RUQ;\n\nRUQ* new_RUQ (const int32_t n) {\n  int32_t k = 0;\n  while ((1 << k) < n) ++k;\n  RUQ *s = (RUQ *) calloc (1, sizeof (RUQ));\n  s->val = (RUQ_val *) calloc (2 << k, sizeof (RUQ_val));\n  s->size = 1 << k;\n  s->bit = k;\n  s->empty = -1;\n  return s;\n}\n\nstatic inline void propagate (RUQ *s, int32_t k) {\n  if (s->val[k] == s->empty) return;\n  s->val[2 * k] = s->val[2 * k + 1] = s->val[k];\n  s->val[k] = s->empty;\n}\n\nvoid update (RUQ *s, int32_t l, int32_t r, RUQ_val v) {\n  for (int32_t i = s->bit; i > 0; --i) {\n    propagate (s, (l + s->size) >> i);\n    propagate (s, (r - 1 + s->size) >> i);\n  }\n  for (l += s->size, r += s->size; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) s->val[l++] = v;\n    if (r & 1) s->val[--r] = v;\n  }\n}\n\nRUQ_val find (RUQ *s, int32_t x) {\n  x += s->size;\n  for (int32_t i = s->bit; i >= 0; --i) {\n    if (s->val[x >> i] != s->empty) {\n      return s->val[x >> i];\n    }\n  }\n  return s->empty;\n}\n\ntypedef int32_t i32;\n\nvoid run(void){\n  i32 n, q;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &q);\n  RUQ *s = new_RUQ (n);\n  update (s, 0, n, 2147483647);\n  while (q--) {\n    i32 type;\n    scanf (\"%\" SCNi32, &type);\n    if (type == 0) {\n      i32 l, r, x;\n      scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &l, &r, &x);\n      update (s, l, r + 1, x);\n    } else {\n      i32 k;\n      scanf (\"%\" SCNi32, &k);\n      printf (\"%\" PRIi32 \"\\n\", find (s, k));\n    }\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100000\n\n\nint main(){\nint n,i,q,j;\nint A[MAX];\nint com,s,t,x;\n\nscanf(\"%d %d\",&n,&q);\n\nfor(i=0;i<n;i++)A[i]=2147483647;\n\n\nfor(i=0;i<q;i++){\n scanf(\"%d\",&com);\n switch(com){\n  case 0:scanf(\"%d %d %d\",&s,&t,&x);\n         for(j=s;j<=t;j++){A[j]=x;}\n         break;\n\n  case 1:scanf(\"%d\",&x);\n         printf(\"%d\\n\",A[x]);\n         break;\n }\n}\n\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LARGE 100001\n\nint a[LARGE];\nint lazy[LARGE];\nint b,n;\n\nvoid update(int x){\n\n\tfor(int i=x*b;i<=MIN(n-1,(x+1)*b-1);i++){\n\t\ta[i]=lazy[x];\n\t}\n\tlazy[x]=-1;\n\t\n\treturn;\n}\n\nint main(){\n\n\tint q,i,j,com;\n\tint x,y,z;\n\t\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tb=sqrt(n);\n\t\n\tfor(i=0;i<n;i++){\n\t\ta[i]=INT_MAX;\n\t\tlazy[i]=-1;\n\t}\n\t\n\tfor(j=0;j<q;j++){\n\t\n\t\tscanf(\"%d\",&com);\n\t\t\n\t\tif(com==1){/*find*/\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tprintf(\"%d\\n\",a[x]);\n\t\t}\n\t\t\n\t\telse {/*update*/\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tfor(i=x;i<=MIN(y,(x/b+1)*b-1);i++)a[i]=z;\n\t\t\t\n\t\t\tfor(i=x/b+1;i<y/b;i++)lazy[i]=z;\n\t\t\t\n\t\t\tif(lazy[y/b]!=-1)update(y/b);\n\t\t\tfor(i=MAX(x,y/b*b);i<=y;i++)a[i]=z;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n\n\n\n//*\n//遅延セグ木ここから\n//↓ここを変える\ntypedef struct sayouso{ll a,b;}sayouso;\ntypedef struct atai{ll a;}atai;\n//↑ここを変える\n\ntypedef struct node{sayouso T;atai x;}node;\nnode *lsegN,*lseg;\nll lsegNUM,lsegk;\n\n//↓ここから変える\nsayouso sid={1,0};\natai aid={(1LL<<31)-1};\natai xx(atai x,atai y){\n\tatai ret;\n\tret.a=x.a+y.a;\n\treturn ret;\n}\natai Tx(sayouso T,atai x){\n\tatai ret;\n\tret.a=T.a*x.a+T.b;\n\treturn ret;\n}\nsayouso TT(sayouso S,sayouso T){\n\tsayouso ret;\n\tret.a=S.a*T.a;\n\tret.b=S.b+S.a*T.b;\n\treturn ret;\n}\nsayouso fT(sayouso T,ll k){\n\tsayouso ret;\n\tret.a=T.a;\n\tret.b=T.b<<k;\n\treturn ret;\n}\n//↑ここまで変える\n\n//要素数(2ベキ)でこれを呼ぶ\nvoid lseguse(ll n){\n\tlsegN=(node*)calloc(2*n,sizeof(node));\n\tlsegNUM=n;\n\tlseg=lsegN+lsegNUM;\n\tlsegk=0;while(n/=2)lsegk++;\n\trep(i,1,2*lsegNUM){\n\t\tlsegN[i].x=aid;\n\t\tlsegN[i].T=sid;\n\t}\n}\n//lseg[i].xに値を与えてから初期化\nvoid lseginit(){\n\tfor(ll i=lsegNUM-1;i>0;i--)lsegN[i].x=xx(lsegN[2*i].x,lsegN[2*i+1].x);\n}\nvoid lsegupdatesub(ll l,ll r,sayouso T,ll i,ll cl,ll cr,ll ck){\n\tif(l>=r)return;\n\t//disjointなとき\n\tif(cr<=l||r<=cl)return;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r){\n\t\tlsegN[i].T=TT(T,lsegN[i].T);\n\t\treturn;\n\t}\n\t//どちらでもないとき\n\t//遅延伝播\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\t//再帰的に更新\n\tll cm=(cl+cr)/2;\n\tlsegupdatesub(l,r,T,2*i  ,cl,cm,ck-1);\n\tlsegupdatesub(l,r,T,2*i+1,cm,cr,ck-1);\n\t//自身のnodeを更新\n\tlsegN[i].x=xx(Tx(fT(lsegN[2*i].T,ck-1),lsegN[2*i].x),Tx(fT(lsegN[2*i+1].T,ck-1),lsegN[2*i+1].x));\n\tlsegN[i].T=sid;\n}\nvoid lsegupdate(ll l,ll r,sayouso T){lsegupdatesub(l,r,T,1,0,lsegNUM,lsegk);}\natai lsegcalcsub(ll l,ll r,ll i,ll cl,ll cr,ll ck){\n\tif(l>=r)return aid;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r)return Tx(fT(lsegN[i].T,ck),lsegN[i].x);\n\n\tll cm=(cl+cr)/2;\n\t//遅延伝播(変更はないので配るだけで良い)\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\tlsegN[i].x=Tx(fT(lsegN[i].T,ck),lsegN[i].x);\n\tlsegN[i].T=sid;\n\n\t//左側だけ\n\tif(r<=cm)return lsegcalcsub(l,r,2*i  ,cl,cm,ck-1);\n\t//右側だけ\n\tif(cm<=l)return lsegcalcsub(l,r,2*i+1,cm,cr,ck-1);\n\t//両方\n\treturn xx(lsegcalcsub(l,r,2*i,cl,cm,ck-1),lsegcalcsub(l,r,2*i+1,cm,cr,ck-1));\n}\natai lsegcalc(ll l,ll r){return lsegcalcsub(l,r,1,0,lsegNUM,lsegk);}\n//遅延セグ木ここまで\n//*/\n\n\nint main(){\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tlseguse(1<<17);\n\twhile(q--){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tif(t){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%lld\\n\",lsegcalc(x,x+1).a);\n\t\t}\n\t\telse{\n\t\t\tint x,y,b;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&b);\n\t\t\tsayouso T={0,b};\n\t\t\tlsegupdate(x,y+1,T);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX 100000\n\nint a[MAX];\nint lazy[MAX];\nint b,n;\n\nvoid update(int x){\n\n\tfor(int i=x*b;i<MIN(n,(x+1)*b);i++){\n\t\ta[i]=lazy[x];\n\t}\n\tlazy[x]=-1;\n\t\n\treturn;\n}\n\nint main(){\n\n\tint q,i,j,com;\n\tint x,y,z;\n\t\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tb=sqrt(n);\n\t\n\tfor(i=0;i<n;i++){\n\t\ta[i]=INT_MAX;\n\t\tlazy[i]=-1;\n\t}\n\t\n\tfor(j=0;j<q;j++){\n\t\n\t\tscanf(\"%d\",&com);\n\t\t\n\t\tif(com==1){/*find*/\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tprintf(\"%d\\n\",a[x]);\n\t\t}\n\t\t\n\t\telse {/*update*/\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tfor(i=x;i<=MIN(y,(x/b+1)*b-1);i++)a[i]=z;\n\t\t\tfor(i=x/b+1;i<y/b;i++)lazy[i]=z;\n\t\t\tif(lazy[y/b]!=-1)update(y/b);\n\t\t\tfor(i=y/b*y;i<=y;i++)a[i]=z;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n\t\t\t\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <limits.h>\nint n; //the sieze of the target array\nint l; // the real size of tree;\nint q; //number of querys\nint *D; //segment tree, D[i] = min value in range node i\nint s;\nint t;\nint x;\nint com;\nint INF;\nint array2tree(int k){return k+n-1;}\nint parent(int k){return (k-1)/2;}\nint left_child(int k){return 2*k+1;}\nint right_child(int k){return 2*k+2;}\nint MIN(int ki){ if(D[left_child(ki)] > D[right_child(ki)]){return D[right_child(ki)];}else{return D[left_child(ki)];}    }\nint min(int a, int b){if (a > b){return b;}else{return a;} }\n\nvoid initRMQ();\nvoid update_leaf();\nvoid update(int ki, int ks, int kt);\nint find(int ki);\nvoid fetch();\n\nint main(){\n\tscanf(\"%d %d\",&n,&q);\n\tinitRMQ();\n\twhile(q>0){\n\t\tfetch();\n\t\tq--;\n\t}\n}\n\nvoid initRMQ(){\n\tINF = INT_MAX;\n\tint i = 1;\n\twhile( i< n ){\n\t\ti *= 2;\n\t}\n\tif(i>1){\n\tl = 2*i-1-1;\n\t}else {l = 1;};\n\tD = new int[l];\n\tif(!D){printf(\"new a D array falied \\n\");return;}\n\tfor(i = 0; i<l;i++){\n\t\tD[i] = INF;\n\t}\n\n}// end of initRMQ\n\nvoid fetch(){\n\tscanf(\"%d\",&com);\n\tif(com){\n\t\tscanf(\"%d\",&s);\n\t\tprintf(\"%d\\n\",find(s));\n\t}else{\n\t\tscanf(\"%d %d %d\",&s,&t,&x);\n\t\tt++;\n\t\t//update_leaf();\n\t\tupdate(0,0,l);\n\t}\n}\nint find(int ki){\n\t//check range\n\t//if(ks>kt || ks>t || kt<s){return INF;}\n//\n\t//if(ks >= s && kt <= t){\n\t//\treturn D[ki];\n\t//}\n\t// start recursive\n\t//int mid = (ks+kt)/2;\n\t//return min(find(left_child(ki),ks, mid), find(right_child(ki), mid+1, kt));\n\tif(n > 1){\n\treturn D[l - (n - ki)];}\n\telse{\n\t\treturn D[0];\n\t}\n}\nvoid update_leaf(){\n\tint i;\n\tint ks = s+ n -1;\n\tint kt = t + n-1;\n\tfor(i = ks; i <= kt; i++){\n\t\tD[i] = x;\n\t}\n}\nvoid update(int ki, int ks, int kt){\n\tint i;\n\tint mid = (ks+kt)/2;\n\t//check range\n\tif(kt <= s  || t <= ks ){return;}\n\n\t\n\tif(s <= ks && kt <= t){\n\t\tif(ki < l-n){\n\t\t\tupdate(left_child(ki),ks, mid);\n\t\t\tupdate(right_child(ki), mid, kt);\n\t\t}else {\n\t\tif(ks != kt){\n\t\t\tupdate(ki+1,ks+1,kt);\n\t\t}\n\t\t}\n\n\t\tD[ki] = x;\n\t\treturn;\n\t}\n\n\t// start recursive\n\tif(ki < l-n){\n\tupdate(left_child(ki),ks, mid);\n\tupdate(right_child(ki), mid, kt);\n\tD[ki] = MIN(ki);\n\t}else {if(ks != kt){\n\t\tupdate(ki+1, ks+1, kt);\n\t}}\n\n\t\n}// end of update\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n//Global Variable\nint n; // the size of target array\nint q; // the number of querys\nint* D;// the minimum value array.\nint* lazy;\nint x;\nint i; // the variable for for loop. just lazy.\n//End of Global Variable\n\n\n\n// Function prototype Area\nvoid __get_init_value(void);\nint __min(int a, int b);\nvoid initRMQ( int n_);\nvoid update(int a, int b);\nvoid __update(int a, int b, int k, int l, int r);\nint find(int a);\nvoid __find(int k);\nint query(int a , int b, int k, int l, int r);\n\nvoid lazy_evaluate(int k);\n// End of Funtion prototype Area\n\n\nint main(int argc, char* argv[]){\n\n\t__get_init_value();\n\t//printf(\"init n = %d\\n\",n);\n\tinitRMQ(n);\n\t//printf(\"after initRMQ n = %d\\n\",n);\n\n\n\tint com;\n\tint s;\n\tint t;\n\t//int x;\n\tint y;// i in question\n\tint ans;\n\twhile(q>0){\n\t\tscanf(\"%d\",&com);\n\t\tif(com){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tans = find(y);\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&s, &t, &x);\n\t\t\tupdate(s,t);\n\t\t}\t\n\t\tq--;\n\t}\n\n\treturn 0;\n}\n\nint __min(int a, int b){\n\tif(a > b){\n\treturn b;\n\t}else{\n\treturn a;\n\t}\n}\n\nvoid __get_init_value(void){\n\n\tscanf(\"%d %d\", &n, &q);\n\treturn;\n}//end of get init value;\n\nvoid initRMQ(int n_){\n\t// n_ is used to preserved original n;\n\t// after this function, n is not the total item number anymore.\n\n\tn = 1;\n\twhile(n < n_){\n\t\tn *= 2;\n\t}\n\t\n\tD = malloc(sizeof(int)* (2*n-1));\n\tlazy = malloc(sizeof(int)* (2*n-1));\n\tif(D == NULL){\n\t\tprintf(\"Init Array Failed, no memory or size is wrong\\n\");\n\t\treturn;\n\t}\n\n\tfor(i = 0; i< 2*n-1 ; i++){\n\t\tD[i] = INT_MAX;\n\t\tlazy[i] = INT_MAX;\n\t}\n\treturn;\n}// end of initRMQ;\n\n\nvoid update(int a , int b){\n\t__update(a, b+1, 0, 0, n);\n}// end of update;\n\nvoid __update(int a, int b, int k , int l, int r){\n\t//printf(\"qurey a=%d b=%d k=%d l=%d r=%d\\n\",a,b,k,l,r);\n\t//\n\tif(k >= 2*n-1){return;}\n\n\tlazy_evaluate(k);\n\n\tif(r <= a || b <= l){\n\t\treturn;\n\t}\n\tif(a <= l && r <= b){\n\t\tD[k] = x;\n\t\tif (l == r){\n\t\t\treturn;\n\t\t}else{\t\n\t\t\tif(k < n-1){\n\t\t\t\tlazy[k*2+1] = x;\n\t\t\t\tlazy[k*2+2] = x;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t//printf(\"(L+R)/2 = %d\\n\",(l+r)/2);\n\t//printf(\"vl, l=%d\\n\",l);\n\t__update(a, b, k*2+1, l , (l+r)/2);\n\t//printf(\"vr, r=%d\\n\",r);\n\t__update(a, b, k*2+2, (l+r)/2, r);\n\tD[k] =  __min(D[k*2+1],D[k*2+2] );\n\n}\n\n\nint find(int a){\n\t//printf(\"findMin n = %d\\n\",n);\n\ta += n - 1;\n\t__find(a);\n\treturn D[a];\n\t//return query( a, b+1, 0, 0, n);\n}// end of findMin;\n\nvoid __find(int k){\n\tif(k > 0){\n\t\t__find((k-1)/2);\n\t}\n\tlazy_evaluate(k);\n\n}\n\nint query(int a, int b, int k , int l , int r){\n\t//printf(\"qurey a=%d b=%d k=%d l=%d r=%d\\n\",a,b,k,l,r);\n\tif(r <= a || b <= l){\n\t\treturn INT_MAX;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn D[k];\n\t}\n\t//printf(\"(L+R)/2 = %d\\n\",(l+r)/2);\n\t//printf(\"vl, l=%d\\n\",l);\n\tint vl = query(a, b, k*2+1, l , (l+r)/2);\n\t//printf(\"vr, r=%d\\n\",r);\n\tint vr = query(a, b, k*2+2, (l+r)/2, r);\n\treturn __min(vl, vr);\n}//end of query\n\nvoid lazy_evaluate(int k){\n\tif( lazy[k] == INT_MAX){\n\t\treturn;\n\t}\n\tD[k] = lazy[k];\n\tif(k < n-1){\n\t\tlazy[2*k +1] = lazy[k];\n\t\tlazy[2*k +2] = lazy[k];\n\t}\n\tlazy[k] = INT_MAX;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=pow(2,31)-1;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(s>t||d>=n||x>pow(2,23)-1){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n\n\n  \n\n  i=0;\n\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=pow(2,31)-1;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(d>c||c>=n||x>=pow(2,31)-1){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>=n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n\n\n  \n\n  i=0;\n\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define A_MAX 100003\n#define MAX 2147483647\nint a[A_MAX];\nint l[A_MAX];\nint b,n;\n \nint j_min(int, int);\nint j_max(int, int);\nvoid update(int);\n\n\n\n \nint main(){\n \n    int q,i,j,que,x,y,z;\n     \n    scanf(\"%d %d\",&n,&q);\n    b=sqrt(n);\n     \n    for(i=0;i<n;i++)a[i]=MAX;\n    for(i=0;i<n;i++)l[i]=-1;\n     \n    for(j=0;j<q;j++){\n     \n        scanf(\"%d\",&que);\n\n        if(que){\n            scanf(\"%d\",&x);\n            if(l[x/b]!=-1)update(x/b);\n            printf(\"%d\\n\",a[x]);\n        }\n         \n        else {\n            scanf(\"%d %d %d\",&x,&y,&z);\n            if(l[x/b]!=-1)update(x/b);\n            for(i=x;i<=j_min(y,(x/b+1)*b-1);i++)a[i]=z;\n            for(i=x/b+1;i<y/b;i++)l[i]=z;\n            if(l[y/b]!=-1)update(y/b);\n            for(i=j_max(x,y/b*b);i<=y;i++)a[i]=z;\n        }\n         \n    }\n     \n    return 0;\n     \n}\n\nint j_min(int x,int y){\n    if (x > y) return y;\n    return x;   \n}\n\nint j_max(int x , int y){\n    if ( x>y ) return x;\n    return y;   \n}\n\n\nvoid update(int x){\n    for(int i=x*b;i<=j_min(n-1,(x+1)*b-1);i++)a[i]=l[x];\n    l[x]=-1;\n    return;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\n#define MAXA 100003\n#define MAX 2147483647\n\nint a[MAXA], length[MAXA];\n\nint b,n;\n \nint min(int, int);\nint max(int, int);\nvoid update(int);\n\n\n\n \nint main(){\n \n    int i,j,x,y,z;\n    int q, que; \n    \n    scanf(\"%d %d\",&n,&q);\n    \n    b = sqrt(n);\n     \n    for(i = 0;i < n;i ++)a[i]=MAX;\n    for(i = 0;i < n;i ++)length[i]=-1;\n     \n    for(j = 0;j < q;j ++){\n     \n        scanf(\"%d\",&que);\n\n        if(que){\n            scanf(\"%d\",&x);\n            if(length[x/b] != -1)update(x/b);\n            printf(\"%d\\n\",a[x]);\n        }\n         \n        else {\n            scanf(\"%d %d %d\",&x,&y,&z);\n            \n            if(length[x/b] != -1)update(x/b);\n            for(i = x;i <= min(y,(x/b + 1) * b - 1);i ++)a[i] = z;\n            for(i = x/b + 1;i < y/b;i ++)length[i] = z;\n            if(length[y/b] != -1)update(y/b);\n            for(i = max(x,y/b*b);i <= y;i ++)a[i] = z;\n        }\n         \n    }\n     \n    return 0;\n     \n}\n\nint min(int x,int y){\n    if (x > y) return y;\n    return x;   \n}\n\nint max(int x , int y){\n    if (x > y) return x;\n    return y;   \n}\n\n\nvoid update(int x){\n    for(int i = x*b;i <= min(n-1,(x+1)*b-1);i ++)a[i] = length[x];\n    length[x] = -1;\n    return;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#define rad M_PI/3\n#define N 2147483647\n#define Max 100000\n#define NTL -1\n#define min(a,b) ((a>b)?b:a)\n  int a[Max];\nvoid update(int s,int t,int x){\nint j=0;\n    for(int k=s;k<=(s+t)/2;k++){\n        a[k]=x;\n        a[t-j]=x;\nj++;\n    }\n}\nint main(){\n  int n,i,j,q;\n  int ord,s,t,x;\n\n  scanf(\"%d%d\",&n,&q);\n  for(i=0;i<n;i++){\n    a[i]=N;\n  }\n  while(q--){\n    scanf(\"%d\",&ord);\n    if(ord==1){\n      scanf(\"%d\",&x);\n      printf(\"%d\\n\",a[x]);\n    }else{\n      scanf(\"%d%d%d\",&s,&t,&x);\n      update(s,t,x);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=pow(2,31)-1;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(d>n||x>pow(2,23)-1){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n\n\n  \n\n  i=0;\n\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // int64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n\nint get_int(void) {\n  int num;\n  scanf(\"%d\", &num);\n  return num;\n}\n\nint get_int2(int *a1, int *a2) {\n  scanf(\"%d %d\", a1, a2);\n  return 0;\n}\n\nint get_int3(int *a1, int *a2, int *a3) {\n  scanf(\"%d %d %d\", a1, a2, a3);\n  return 0;\n}\n\nenum type {\n    COMMAND_UPDATE,\n    COMMAND_FIND\n};\n\n#define NUM2_MAX (1<<17)\n#define QUERY_MAX 100000\n#include <limits.h>\n\nstruct range {\n    int start;\n    int end;\n};\n\nstruct pair {\n    int val;\n    int time;\n};\n#define ROOT_NODE 1\n\nint is_contain(struct range this, struct range box) {\n    return box.start <= this.start && this.end <= box.end;\n}\n\nint is_overlap(struct range r1, struct range r2) {\n    return r1.end > r2.start && r2.end > r1.start;\n}\n\nvoid update_range(struct pair *seg, struct range r, struct pair val, int node, struct range nr) {\n    if(!is_overlap(r, nr)) return;\n    if(is_contain(nr, r)) {\n        seg[node] = val;\n#ifdef DEBUG\n        printf(\"update: %d -> (%d, %d)\\n\", node, val.val, val.time);\n#endif\n        return;\n    }\n    struct range left = { nr.start, (nr.start + nr.end) / 2 };\n    struct range right = { (nr.start + nr.end) / 2, nr.end };\n    update_range(seg, r, val, node*2, left);\n    update_range(seg, r, val, node*2+1, right);\n    return;\n}\n\nstruct pair find(struct pair *seg, int num2, int idx) {\n    int node = num2 + idx;\n    struct pair ans = seg[node];\n    while((node = node/2)) {\n        struct pair this = seg[node];\n        ans = ans.time > this.time ? ans : this;\n    }\n    return ans;\n}\n\nint main(void) {\n    int num, qs;\n    get_int2(&num, &qs);\n    int i;\n    int num2 = 1;\n    while(num > num2) num2 *= 2;\n    // initialization\n    static struct pair seg[NUM2_MAX*2];\n    for(i = ROOT_NODE; i < num2*2; i++) seg[i] = (struct pair){.val = INT_MAX, .time = -1};\n    struct range whole = {0, num2};\n    static int ans[QUERY_MAX];\n    int aidx = 0;\n    int t;\n    for(t = 0; t < qs; t++) {\n        int type = get_int();\n        switch(type) {\n            case COMMAND_UPDATE:\n                {\n                    int start, end;\n                    int val;\n                    get_int3(&start, &end, &val);\n                    end++;\n                    struct range r = {start, end};\n                    struct pair np = {val, t};\n                    update_range(seg, r, np, ROOT_NODE, whole);\n                }\n                break;\n            case COMMAND_FIND:\n                {\n                    int idx = get_int();\n                    struct pair p = find(seg, num2, idx);\n                    ans[aidx++] = p.val;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    for(i = 0; i < aidx; i++) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define Q_MAX 100000\n#define A_MAX 2147483647\n\nint main() {\n    int n, x, bit, i, q, a[Q_MAX][3];\n    scanf(\"%d%d\", &n, &q);\n    a[0][0] = 0;\n    a[0][1] = n-1;\n    a[0][2] = A_MAX;\n    i = 1;\n    while (~scanf(\"%d\", &bit)) {\n        if (bit) {\n            scanf(\"%d\", &x);\n            for (int j=i-1; j>=0; j--)\n                if (x >= a[j][0] && x <= a[j][1]){\n                    printf(\"%d\\n\", a[j][2]);\n                    break;\n                }\n        } else {\n            int *m = *(a+i);\n            scanf(\"%d%d%d\", m, m+1, m+2);\n            i++;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=pow(2,31)-1;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(d>c||d>=n||x>pow(2,23)-1){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n\n\n  \n\n  i=0;\n\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <limits.h>\nint n; //the sieze of the target array\nint l; // the real size of tree;\nint q; //number of querys\nint *D; //segment tree, D[i] = min value in range node i\nint s;\nint t;\nint x;\nint com;\nint INF;\nint array2tree(int k){return k+n-1;}\nint parent(int k){return (k-1)/2;}\nint left_child(int k){return 2*k+1;}\nint right_child(int k){return 2*k+2;}\nint MIN(int ki){ if(D[left_child(ki)] > D[right_child(ki)]){return D[right_child(ki)];}else{return D[left_child(ki)];}    }\nint min(int a, int b){if (a > b){return b;}else{return a;} }\n\nvoid initRMQ();\nvoid update_leaf();\nvoid update(int ki, int ks, int kt);\nint find(int ki);\nvoid fetch();\n\nint main(){\n\tscanf(\"%d %d\",&n,&q);\n\tinitRMQ();\n\twhile(q>0){\n\t\tfetch();\n\t\tq--;\n\t}\n}\n\nvoid initRMQ(){\n\tINF = INT_MAX;\n\tint i = 1;\n\twhile( i< n ){\n\t\ti *= 2;\n\t}\n\tif(i>1){\n\tl = 2*i-1-1;\n\t}else {l = 1;};\n\tD = new int[l];\n\tif(!D){printf(\"new a D array falied \\n\");return;}\n\tfor(i = 0; i<l;i++){\n\t\tD[i] = INF;\n\t}\n\n}// end of initRMQ\n\nvoid fetch(){\n\tscanf(\"%d\",&com);\n\tif(com){\n\t\tscanf(\"%d\",&s);\n\t\tprintf(\"%d\\n\",find(s));\n\t}else{\n\t\tscanf(\"%d %d %d\",&s,&t,&x);\n\t\tt++;\n\t\t//update_leaf();\n\t\tupdate(0,0,l);\n\t}\n}\nint find(int ki){\n\t//check range\n\t//if(ks>kt || ks>t || kt<s){return INF;}\n//\n\t//if(ks >= s && kt <= t){\n\t//\treturn D[ki];\n\t//}\n\t// start recursive\n\t//int mid = (ks+kt)/2;\n\t//return min(find(left_child(ki),ks, mid), find(right_child(ki), mid+1, kt));\n\tif(n > 1){\n\treturn D[l - (n - ki)];}\n\telse{\n\t\treturn D[0];\n\t}\n}\nvoid update_leaf(){\n\tint i;\n\tint ks = s+ n -1;\n\tint kt = t + n-1;\n\tfor(i = ks; i <= kt; i++){\n\t\tD[i] = x;\n\t}\n}\nvoid update(int ki, int ks, int kt){\n\tint i;\n\tint mid = (ks+kt)/2;\n\t//check range\n\tif(kt <= s  || t <= ks ){return;}\n\n\t\n\tif(s <= ks && kt <= t){\n\t\tif(ki < l-n){\n\t\t\tupdate(left_child(ki),ks, mid);\n\t\t\tupdate(right_child(ki), mid, kt);\n\t\t}else {\n\t\tif(ks != kt){\n\t\t\tupdate(ki+1,ks+1,kt);\n\t\t}\n\t\t}\n\n\t\tD[ki] = x;\n\t\treturn;\n\t}\n\n\t// start recursive\n\tif(ki < l-n){\n\tupdate(left_child(ki),ks, mid);\n\tupdate(right_child(ki), mid, kt);\n\tD[ki] = MIN(ki);\n\t}else {if(ks != kt){\n\t\tupdate(ki+1, ks+1, kt);\n\t}}\n\n\t\n}// end of update\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX 100000\n\nint a[MAX];\nint lazy[MAX];\nint b,n;\n\nvoid update(int x){\n\n\tfor(int i=x*b;i<MIN(n,(x+1)*b);i++){\n\t\ta[i]=lazy[x];\n\t}\n\tlazy[x]=-1;\n\t\n\treturn;\n}\n\nint main(){\n\n\tint q,i,j,com;\n\tint x,y,z;\n\t\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tb=sqrt(n);\n\t\n\tfor(i=0;i<n;i++){\n\t\ta[i]=INT_MAX;\n\t\tlazy[i]=-1;\n\t}\n\t\n\tfor(j=0;j<q;j++){\n\t\n\t\tscanf(\"%d\",&com);\n\t\t\n\t\tif(com==1){/*find*/\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tprintf(\"%d\\n\",a[x]);\n\t\t}\n\t\t\n\t\telse {/*update*/\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tfor(i=x;i<=MIN(y,(x/b+1)*b-1);i++)a[i]=z;\n\t\t\tfor(i=x/b+1;i<y/b;i++)lazy[i]=z;\n\t\t\tfor(i=y/b*y;i<=y;i++)a[i]=z;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n\t\t\t\n"
  },
  {
    "language": "C",
    "code": "// AOJ DSL_2_D Range Update Query (RUQ)\n// 2018.5.18 bal4u\n\n#include <stdio.h>\n\n#define INF 0x7fffffff\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nchar *inf = \"2147483647\";\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse if (n == INF) for (i = 0; i < 10; i++) pc(inf[i]);\n\telse {\n\t\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n\tpc('\\n');\n}\n\n#define MAX_N 100005\n#define INF 0x7fffffff\n\nint node[MAX_N << 2];\n\n\nint find(int t, int l, int r, int x)\n{\n\tint m;\n\n\tif (~node[t]) return node[t];\n\tm = (l + r) >> 1;\n\tif (x <= m) return find( t<<1, l, m, x);\n\telse        return find((t<<1)|1, m + 1, r, x);\n}\n\nvoid update(int t, int l, int r, int x, int y, int k)\n{\n\tint m;\n\n\tif (l == x && r == y) { node[t] = k; return; }\n\tm = (l + r) >> 1;\n\tif (~node[t]) {\n\t\tnode[t<<1] = node[(t<<1)|1] = node[t];\n\t\tnode[t] = -1;\n\t}\n\tif (y <= m)\tupdate(t<<1, l, m, x, y, k);\n\telse if (x > m)\tupdate((t<<1)|1, m+1, r, x, y, k);\n\telse {\n\t\tupdate(t<<1, l, m, x, m, k);\n\t\tupdate((t<<1)|1, m+1, r, m+1, y, k);\n\t}\n}\n\nsigned main(void)\n{\n\tint n, q, sz;\n\tint op, s, t, x;\n\n\tn = in(), q = in();\n\tsz = n << 2;\n\tfor (s = 0; s < sz; s++) node[s] = INF;\n\n\twhile (q--) {\n\t\top = gc() & 1, gc();\n\t\tif (op) out(find(1, 1, n, in()+1));\n\t\telse {\n\t\t\ts = in()+1, t = in()+1, x = in();\n\t\t\tupdate(1, 1, n, s, t, x);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=pow(2,31)-1;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(d>c||d>=n||x>pow(2,23)-1){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>=n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n\n\n  \n\n  i=0;\n\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define INIVAL 2147483647\n\nint *a, *ts, c, s, t, v;\n\nvoid update(int k, int l, int r)\n{\n  if (r<s || t<=l) return;\n  if (s<=l && r<=t) {\n    a[k] = v;\n    ts[k] = c;\n  } else if (l<r-1) {\n    update(((k+1)<<1)-1, l, (l+r)>>1);\n    update((k+1)<<1, (l+r)>>1, r);\n  }\n}\n\nint main()\n{\n  int i, k, n, z, w, latest;\n  char *p,buf[64] = {0};\n  buf[62] = '\\n';\n  fgets(buf, 64, stdin);\n  for (n=0,p=buf; *p>' '; n=n*10+*(p++)-'0');\n  w = n>1 ? pow(2,(int)ceil(log2(n)))-1 : 1;\n  ts = (a = (int*)malloc((w+n)*2*sizeof(int))) + w+n;\n  for (i=0; i<w+n; i++)  ts[i] = -1;\n  a[0] = INIVAL;\n  ts[0] = 0;\n  c = 0;\n  while (fgets(buf, 64, stdin)) {\n    for (s=0,p=buf+2; *p>' '; s=s*10+*(p++)-'0');\n    if (*buf=='0') { // update(s, t, x)\n      for (t=0,p++; *p>' '; t=t*10+*(p++)-'0');\n      for (v=0,p++; *p>' '; v=v*10+*(p++)-'0');\n      t++;\n      update(0, 0, w+1);\n      c++;\n    } else { // find(x) x->s\n      latest = -1;\n      for (k=w+s; ; k=(k-1)>>1) {\n\tif (ts[k]>latest) {\n          latest = ts[k];\n          z = a[k];\n        }\n\tif (k==0) break;\n      }\n      if (z<10) {\n\tputc_unlocked('0'+z, stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n        for (i=62; z>0; buf[--i]='0'+z%10,z/=10);\n        fputs(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX 100000\n\nint a[MAX];\nint lazy[MAX];\nint b,n;\n\nvoid update(int x){\n\n\tfor(int i=x*b;i<=MIN(n-1,(x+1)*b-1);i++){\n\t\ta[i]=lazy[x];\n\t}\n\tlazy[x]=-1;\n\t\n\treturn;\n}\n\nint main(){\n\n\tint q,i,j,com;\n\tint x,y,z;\n\t\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tb=sqrt(n);\n\t\n\tfor(i=0;i<n;i++){\n\t\ta[i]=INT_MAX;\n\t\tlazy[i]=-1;\n\t}\n\t\n\tfor(j=0;j<q;j++){\n\t\n\t\tscanf(\"%d\",&com);\n\t\t\n\t\tif(com==1){/*find*/\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tprintf(\"%d\\n\",a[x]);\n\t\t}\n\t\t\n\t\telse {/*update*/\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tfor(i=x;i<=MIN(y,(x/b+1)*b-1);i++)a[i]=z;\n\t\t\tfor(i=x/b+1;i<y/b;i++)lazy[i]=z;\n\t\t\tif(lazy[y/b]!=-1)update(y/b);\n\t\t\tfor(i=y/b*b;i<=y;i++)a[i]=z;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n\t\t\t\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 0x7fffffff\n#define ST_SIZE ((1 << 18) - 1)\ntypedef long long int LL;\nLL dat[ST_SIZE];\nLL input(void);\nvoid update(LL a, LL b, LL x, LL k, LL l, LL r);\nvoid find(LL x, LL k, LL l, LL r);\nint main (void) {\n  int command, x;\n  LL i, n, q, s, t;\n  n = input();\n  q = input();\n  for (i = 0; i < n; i++) dat[i] = INF;\n  for (i = 0; i < q; i++) {\n    command = input();\n    if (!command) {\n      s = input();\n      t = input();\n      x = input();\n      update(s, t + 1, x, 0, 0, n);\n    } else {\n      t = input();\n      find(t, 0, 0, n);\n    }\n  }\n}\nLL input(void)\n{\n  LL n = 0;\n  int c = getchar_unlocked();\n  if (c == '-') {\n    c = getchar_unlocked();\n    do {\n      n = 10 * n + c - '0';\n      c = getchar_unlocked();\n    } while (c >= '0' && c <= '9');\n    return -n;\n  } else {\n    do {\n      n = 10 * n + c - '0';\n      c = getchar_unlocked();\n    } while (c >= '0' && c <= '9');\n    return n;\n  }\n}\nvoid update(LL a, LL b, LL x, LL k, LL l, LL r)\n{\n  LL m = (l + r) / 2;\n  if (a >= r || b <= l) return;\n  else if (a <= l && b >= r) dat[k] = x;\n  else {\n    if (dat[k] != -1) {\n      dat[k*2+1] = dat[k*2+2] = dat[k];\n      dat[k] = -1;\n    }\n    update(a, b, x, k * 2 + 1, l ,m);\n    update(a, b, x, k * 2 + 2, m, r);\n  }\n}\nvoid find(LL x, LL k, LL l, LL r)\n{\n  LL m = (l + r) / 2;\n  if (dat[k] != -1) printf(\"%lld\\n\", dat[k]);\n  else {\n    if (x < m) find(x, k * 2 + 1, l, m);\n    else find(x, k * 2 + 2, m, r);\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LARGE 100001\n\nint a[LARGE];\nint lazy[LARGE];\nint b,n;\n\nvoid update(int x){\n\n\tfor(int i=x*b;i<=MIN(n-1,(x+1)*b-1);i++){\n\t\ta[i]=lazy[x];\n\t}\n\tlazy[x]=-1;\n\t\n\treturn;\n}\n\nint main(){\n\n\tint q,i,j,com;\n\tint x,y,z;\n\t\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tb=sqrt(n);\n\t\n\tfor(i=0;i<n;i++){\n\t\ta[i]=INT_MAX;\n\t\tlazy[i]=-1;\n\t}\n\t\n\tfor(j=0;j<q;j++){\n\t\n\t\tscanf(\"%d\",&com);\n\t\t\n\t\tif(com==1){/*find*/\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tprintf(\"%d\\n\",a[x]);\n\t\t}\n\t\t\n\t\telse {/*update*/\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tfor(i=x;i<=MIN(y,(x/b+1)*b-1);i++)a[i]=z;\n\t\t\t\n\t\t\tfor(i=x/b+1;i<y/b;i++)lazy[i]=z;\n\t\t\t\n\t\t\tif(lazy[y/b]!=-1)update(y/b);\n\t\t\tfor(i=MAX(x,y/b*b));i<=y;i++)a[i]=z;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=pow(2,31)-1;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(d>c||c>=n||x>=pow(2,23)-1){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>=n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n\n\n  \n\n  i=0;\n\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ DSL_2_D Range Update Query (RUQ)\n// 2018.5.18 bal4u\n\n#include <stdio.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n\t\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n\tpc('\\n');\n}\n\n#define MAX_N 100005\n#define INF 0x7fffffff\n\nint node[MAX_N << 1];\n\n\nint find(int t, int l, int r, int x)\n{\n\tint m;\n\n\tif (~node[t]) return node[t];\n\tm = (l + r) >> 1;\n\tif (x <= m) return find( t<<1, l, m, x);\n\telse        return find((t<<1)|1, m + 1, r, x);\n}\n\nvoid update(int t, int l, int r, int x, int y, int k)\n{\n\tint m;\n\n\tif (l == x && r == y) { node[t] = k; return; }\n\tm = (l + r) >> 1;\n\tif (~node[t]) {\n\t\tnode[t<<1] = node[(t<<1)|1] = node[t];\n\t\tnode[t] = -1;\n\t}\n\tif (y <= m)\tupdate(t<<1, l, m, x, y, k);\n\telse if (x > m)\tupdate((t<<1)|1, m+1, r, x, y, k);\n\telse {\n\t\tupdate(t<<1, l, m, x, m, k);\n\t\tupdate((t<<1)|1, m+1, r, m+1, y, k);\n\t}\n}\n\nsigned main(void)\n{\n\tint n, q, sz;\n\tint op, s, t, x;\n\n\tn = in(), q = in();\n\tsz = n << 1;\n\tfor (s = 0; s < sz; s++) node[s] = INF;\n\n\twhile (q--) {\n\t\top = gc() & 1, gc();\n\t\tif (op) out(find(1, 1, n, in()+1));\n\t\telse {\n\t\t\ts = in()+1, t = in()+1, x = in();\n\t\t\tupdate(1, 1, n, s, t, x);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdlib.h>\n#include<math.h>\n\n#define N pow(2,31)-1\n\nint main(void){\n\n  int a[100000]={};\n  int min[100000]={};\n  int i=0;  \n  int time=0;\n  int b,x,s,t,n,q,d,c;\n\n  scanf(\"%d %d\",&n,&q);\n  if(1>n||n>100000||1>q||q>100000){\n  printf(\"Too Large\\n\");\n  exit(0);\n  }\n\n  while(i<n){\n    a[i]=N;\n    min[i]=a[i];\n    i++;\n  }\n\n  i=0;\n\n\n\n\n  while(i<q){\n    i++;\n   scanf(\"%d\",&b);\n\n   if(b==0){\n   scanf(\"%d\",&d);\n   scanf(\"%d\",&c);\n   scanf(\"%d\",&x);\n   if(d>c||c>=n||x>=N){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   while(d<=c){\n   a[d] = x;\n   d++;\n   }\n\n   }\n \n   else if(b==1){\n     time++;\n   scanf(\"%d\",&s);\n   if(s>=n){\n   printf(\"Too Large\\n\");\n   exit(0);\n   }\n   min[time]=a[s];\n   }\n\n   }\n  i=0;\n  while(i<time){\n    ++i;\n    printf(\"%d\\n\",min[i]);\n\n  }\n  \n\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MAX 100001\n\nint a[MAX];\nint lazy[MAX];\nint b,n;\n\nvoid update(int x){\n\n\tfor(int i=x*b;i<=MIN(n-1,(x+1)*b-1);i++){\n\t\ta[i]=lazy[x];\n\t}\n\tlazy[x]=-1;\n\t\n\treturn;\n}\n\nint main(){\n\n\tint q,i,j,com;\n\tint x,y,z;\n\t\n\tscanf(\"%d %d\",&n,&q);\n\t\n\tb=sqrt(n);\n\t\n\tfor(i=0;i<n;i++){\n\t\ta[i]=INT_MAX;\n\t\tlazy[i]=-1;\n\t}\n\t\n\tfor(j=0;j<q;j++){\n\t\n\t\tscanf(\"%d\",&com);\n\t\t\n\t\tif(com==1){/*find*/\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tprintf(\"%d\\n\",a[x]);\n\t\t}\n\t\t\n\t\telse {/*update*/\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tif(lazy[x/b]!=-1)update(x/b);\n\t\t\tfor(i=x;i<=MIN(y,(x/b+1)*b-1);i++)a[i]=z;\n\t\t\t\n\t\t\tfor(i=x/b+1;i<y/b;i++)lazy[i]=z;\n\t\t\t\n\t\t\tif(lazy[y/b]!=-1)update(y/b);\n\t\t\tfor(i=MAX(x,y/b*b));i<=y;i++)a[i]=z;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 2147483647\n#define Max 100000\n#define NTL -1\n#define min(a,b) ((a>b)?b:a)\n  int a[Max];\nvoid update(int s,int t,int x){\n    for(int k=s;k<=t;k++){\n        a[k]=x;\n    }\n}\nint main(){\n  int n,i,j,q;\n  int ord,s,t,x;\n\n  scanf(\"%d%d\",&n,&q);\n  for(i=0;i<n;i++){\n    a[i]=N;\n  }\n  while(q--){\n    scanf(\"%d\",&ord);\n    if(ord==1){\n      scanf(\"%d\",&x);\n      printf(\"%d\\n\",a[x]);\n    }else{\n      scanf(\"%d%d%d\",&s,&t,&x);\n      update(s,t,x);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static class SegmentTree {\n\t\tint[] tree;\n\t\tpublic SegmentTree(int n) {\n\t\t\tint d = (int)Math.ceil(Math.log((double)n) / Math.log(2.0));\n\t\t\ttree = new int[(int)Math.pow(2, d+1)];\n\t\t\tArrays.fill(tree, -1);\n\t\t\ttree[0] = Integer.MAX_VALUE;\n\t\t}\n\n\t\tpublic int find(int i) {\n\t\t\ti += tree.length/2-1;\n\t\t\tint r = tree[i];\n\t\t\twhile(i > 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tif(tree[i] >= 0) r = tree[i];\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tpublic void update(int i, int x) {\n\t\t\ti += tree.length/2-1;\n\t\t\ttree[i] = x;\n\t\t\twhile(i > 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\ttree[i] = Math.min(tree[i*2+1], tree[i*2+2]);\n\t\t\t}\n\t\t\t// print();\n\t\t}\n\n\t\t// usage\n\t\t// updateRange(a, b, x, 0, 0, seg.tree.length/2)\n\t\tpublic void updateRange(int a, int b, int x, int k, int l, int r) {\n\t\t\tif(r <= a || b < l) return;\n\t\t\tif(a <= l && r-1 <= b) tree[k] = x;\n\t\t\telse {\n\t\t\t\tif(tree[k] >= 0) {\n\t\t\t\t\ttree[k*2+1] = tree[k];\n\t\t\t\t\ttree[k*2+2] = tree[k];\n\t\t\t\t\ttree[k] = -1;\n\t\t\t\t}\n\t\t\t\tupdateRange(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\t\tupdateRange(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\t}\n\t\t}\n\n\t\t// usage\n\t\t// query(a, b, 0, 0, seg.tree.length/2)\n\t\tpublic int query(int a, int b, int k, int l, int r) {\n\t\t\t// System.out.println(a+\" \"+b+\" \"+k+\" \"+l+\" \"+r);\n\t\t\tif(r <= a || b < l) return Integer.MAX_VALUE;\n\t\t\tif(a <= l && r-1 <= b) return tree[k];\n\t\t\telse {\n\t\t\t\tint vl = query(a, b, k*2+1, l, (l+r)/2);\n\t\t\t\tint vr = query(a, b, k*2+2, (l+r)/2, r);\n\t\t\t\treturn Math.min(vl, vr);\n\t\t\t}\n\t\t}\n\n\t\tpublic void print() {\n\t\t\tint d = 2;\n\t\t\tfor(int i=0; i<tree.length-1; i++) {\n\t\t\t\tSystem.out.print(tree[i]+\" \");\n\t\t\t\tif(i == d-2){\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\td *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint n = r.nextInt();\n\t\tint q = r.nextInt();\n\t\tSegmentTree seg = new SegmentTree(n);\n\t\tfor(int k=0; k<q; k++) {\n\t\t\tint c = r.nextInt();\n\t\t\tif(c == 0) {\n\t\t\t\tint s = r.nextInt();\n\t\t\t\tint t = r.nextInt();\n\t\t\t\tint x = r.nextInt();\n\t\t\t\tseg.updateRange(s, t, x, 0, 0, seg.tree.length/2);\n\t\t\t\t// seg.print();\n\t\t\t} else {\n\t\t\t\tint i = r.nextInt();\n\t\t\t\tSystem.out.println(seg.find(i));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int n = in.nextInt(), q = in.nextInt();\n\n        RUpdateQ rUpdateQ = new RUpdateQ(n);\n\n        for (int i = 0; i < q; i++) {\n            int cmd = in.nextInt();\n            if (cmd == 0) {\n                int s = in.nextInt(),\n                        t = in.nextInt(),\n                        x = in.nextInt();\n                rUpdateQ.update(s, t, x);\n            }\n            if (cmd == 1) {\n                int index = in.nextInt();\n                System.out.println(rUpdateQ.find(index));\n            }\n        }\n\n\n    }\n}\n\nclass RUpdateQ{\n    int[] heap;\n    int n;\n\n    static int _heap_size(int n) {\n        int pow2 = 1;\n        while (pow2 < n) {\n            pow2 *= 2;\n        }\n        return pow2 * 2;\n    }\n\n    RUpdateQ(int n) {\n        this.n = n;\n        heap = new int[_heap_size(n)];\n        Arrays.fill(heap, Integer.MAX_VALUE);\n    }\n\n\n    public void update(int s, int t, int x) {\n        update(s, t+1, x, 0, n, 1);\n\n    }\n\n    private void update(int s, int t, int x, int l, int r, int ih) {\n        if (s >= t) {\n            return;\n        }\n        if (s == l && t == r) {\n            heap[ih] = x;\n            return;\n        }\n        // else: [s,t) in [l, r)\n        if (heap[ih] >= 0) {\n            // broadcast to next level\n            heap[ih * 2] = heap[ih];\n            heap[ih * 2 + 1] = heap[ih];\n            // indicate multi val\n            heap[ih] = -1;\n        }\n\n        int mid = (l + r) / 2;\n        update(Math.max(s, l), Math.min(mid, t), x, l, mid, ih * 2);\n        update(Math.max(s, mid), Math.min(t, r), x, mid, r, ih * 2 + 1);\n    }\n\n    public int find(int index) {\n        return find(index, 0, n, 1);\n    }\n\n    private int find(int index, int l, int r, int ih) {\n        if (heap[ih] >= 0) {\n            return heap[ih];\n        }else {\n            int mid = (l + r) / 2;\n            if (index < mid) {\n                return find(index, l, mid, ih * 2);\n            }else {\n                return find(index, mid, r, ih * 2 + 1);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i <= dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <limits.h>\nint n; //the sieze of the target array\nint l; // the real size of tree;\nint q; //number of querys\nint *D; //segment tree, D[i] = min value in range node i\nint s;\nint t;\nint x;\nint com;\nint INF;\nint array2tree(int k){return k+n-1;}\nint parent(int k){return (k-1)/2;}\nint left_child(int k){return 2*k+1;}\nint right_child(int k){return 2*k+2;}\nint MIN(int ki){ if(D[left_child(ki)] > D[right_child(ki)]){return D[right_child(ki)];}else{return D[left_child(ki)];}    }\nint min(int a, int b){if (a > b){return b;}else{return a;} }\n\nvoid initRMQ();\nvoid update_leaf();\nvoid update(int ki, int ks, int kt);\nint find(int ki);\nvoid fetch();\n\nint main(){\n\tscanf(\"%d %d\",&n,&q);\n\tinitRMQ();\n\twhile(q>0){\n\t\tfetch();\n\t\tq--;\n\t}\n}\n\nvoid initRMQ(){\n\tINF = INT_MAX;\n\tint i = 1;\n\twhile( i< n ){\n\t\ti *= 2;\n\t}\n\tif(i>1){\n\tl = 2*i-1-1;\n\t}else {l = 1;};\n\tD = new int[l];\n\tif(!D){printf(\"new a D array falied \\n\");return;}\n\tfor(i = 0; i<l;i++){\n\t\tD[i] = INF;\n\t}\n\n}// end of initRMQ\n\nvoid fetch(){\n\tscanf(\"%d\",&com);\n\tif(com){\n\t\tscanf(\"%d\",&s);\n\t\tprintf(\"%d\\n\",find(s));\n\t}else{\n\t\tscanf(\"%d %d %d\",&s,&t,&x);\n\t\tt++;\n\t\t//update_leaf();\n\t\tupdate(0,0,l);\n\t}\n}\nint find(int ki){\n\t//check range\n\t//if(ks>kt || ks>t || kt<s){return INF;}\n//\n\t//if(ks >= s && kt <= t){\n\t//\treturn D[ki];\n\t//}\n\t// start recursive\n\t//int mid = (ks+kt)/2;\n\t//return min(find(left_child(ki),ks, mid), find(right_child(ki), mid+1, kt));\n\tif(n > 1){\n\treturn D[l - (n - ki)];}\n\telse{\n\t\treturn D[0];\n\t}\n}\nvoid update_leaf(){\n\tint i;\n\tint ks = s+ n -1;\n\tint kt = t + n-1;\n\tfor(i = ks; i <= kt; i++){\n\t\tD[i] = x;\n\t}\n}\nvoid update(int ki, int ks, int kt){\n\tint i;\n\tint mid = (ks+kt)/2;\n\t//check range\n\tif(kt <= s  || t <= ks ){return;}\n\n\t\n\tif(s <= ks && kt <= t){\n\t\tif(ki < l-n){\n\t\t\tupdate(left_child(ki),ks, mid);\n\t\t\tupdate(right_child(ki), mid, kt);\n\t\t}else {\n\t\tif(ks != kt){\n\t\t\tupdate(ki+1,ks+1,kt);\n\t\t}\n\t\t}\n\n\t\tD[ki] = x;\n\t\treturn;\n\t}\n\n\t// start recursive\n\tif(ki < l-n){\n\tupdate(left_child(ki),ks, mid);\n\tupdate(right_child(ki), mid, kt);\n\tD[ki] = MIN(ki);\n\t}else {if(ks != kt){\n\t\tupdate(ki+1, ks+1, kt);\n\t}}\n\n\t\n}// end of update\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class RangeUpdateAizu {\n    static int N = 100005;\n    static int tree[];//start from 0, with all uncertain value\n    //data structure: tree from 0\n    //how to represent the tree node,\n    //node: the segment of the\n    public static void main(String[] args) {\n        int n,m;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        tree = new int[N];\n        for(int i = 0; i<N; i++){\n            tree[i] = 2147483647;\n        }\n        //make entir tree-> get the max n fir ti 2^n\n        int nMax = 1;\n        n = n-1;\n        while(n>0){\n            n = n/2;\n            nMax = nMax<<1;\n        }\n        if(nMax==1) nMax = 2;\n        //start from 0\n        for(int i = 0; i<m; i++){\n            int temp = 0;//decide the type of operation\n            int x,y, val;\n            temp = in.nextInt();\n            if(temp==0){\n                x = in.nextInt();\n                y = in.nextInt();\n                val = in.nextInt();\n                update(x,y,val,0,nMax-1,0);\n                /*for(int j = 0;j <=2*nMax-2;j++){\n                    System.out.println(j+\": \"+tree[j]);\n                }*/\n            } else {\n                x = in.nextInt();\n                int res = find(x,x,0,nMax-1,0);\n                System.out.println(res);\n            }\n\n        }\n    }\n\n    private static int find(int x,int y, int left, int right,int nodeId) {\n        if(left>y || right<x) return -1;\n        else if(left<=x && right>=y && tree[nodeId]>=0){//search range > than,could be -1\n            return tree[nodeId];\n        } else{\n            int num1 = find(x,y,left,(left+right)/2,nodeId*2+1);\n            int num2 = find(x,y,(left+right)/2+1,right,nodeId*2+2);\n            return Math.max(num1,num2);\n        }\n\n    }\n    //update the value\n    //top down\n    private static void update(int x, int y, int val, int left, int right,int nodeId) {\n        //int mid = (left+right)/2;\n        //when to stop: there is only one node\n        //if(mid>right) return;\n        if(x>right||y<left) return;//out of range\n        //when to update\n        //how to view this tree\n        if(x<=left && y>=right){\n            tree[nodeId] = val;\n        }else{//update the tree//go left and right\n            if(tree[nodeId] >=0){\n                tree[nodeId*2+1] = tree[nodeId];\n                tree[nodeId*2+2] = tree[nodeId];\n                tree[nodeId] = -1;\n            }\n            update(x,y,val,left,(left+right)/2,nodeId*2+1);\n            update(x,y,val,(left+right)/2+1,right,nodeId*2+2);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n\tstatic int[] segTree;\n\tstatic int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\n\t\tinitSegTree();\n\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tint type = scanner.nextInt();\n\n\t\t\tif(type == 0) {\n\t\t\t\tint s = scanner.nextInt();\n\t\t\t\tint t = scanner.nextInt();\n\t\t\t\tint x = scanner.nextInt();\n\n\t\t\t\t// Change a[s] ... a[t] to x\n\t\t\t\tupdate(s,t,x);\n\n\t\t\t} else if(type == 1) {\n\t\t\t\t// Find value of a[i]\n\t\t\t\tint result = find(scanner.nextInt());\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void initSegTree() {\n\t\tint _n = 1;\n\t\twhile(_n < n)\n\t\t\t_n *= 2;\n\n\t\tsegTree = new int[2*_n];\n\t\tArrays.fill(segTree, Integer.MAX_VALUE);\n\t}\n\n\tstatic void update(int s, int t, int x) {\n\t\tupdateRange(1, 0, n, s, t+1, x);\n\t}\n\n\t/*\tk: index of current node in segTree\n\t\tl & r: range covered by node k\n\t\ts & t: range of query\n\t\tx: new value to update\n\t*/\n\tstatic void updateRange(int k, int l, int r, int s, int t, int x) {\n\n\t\tif(s >= t) // out of range\n\t\t\treturn;\n\n\t\tif(s == l && t == r) { // (s,t) fully inside (l,r)\n\t\t\tsegTree[k] = x;\n\t\t\treturn;\n\t\t}\n\n\t\tif(segTree[k] >= 0) {\n\t\t\tsegTree[k*2] = segTree[k];\n\t\t\tsegTree[k*2+1] = segTree[k];\n\t\t\tsegTree[k] = -1;\n\t\t}\n\n\t\t// (s,t) and (l,r) intersect\n\t\tint mid = (l+r)/2;\n\t\tupdateRange(k*2, l, mid, Math.max(s,l), Math.min(mid,t), x);\n\t\tupdateRange(k*2+1, mid, r, Math.max(s,mid), Math.min(r,t), x);\n\t}\n\n\tstatic int find(int i) {\n\t\treturn find(i, 0, n, 1);\n\t}\n\n\tstatic int find(int i, int l, int r, int k) {\n\t\tif(segTree[k] >= 0)\n\t\t\treturn segTree[k];\n\t\telse {\n\t\t\tint mid = (l+r)/2;\n\t\t\tif(i < mid)\n\t\t\t\treturn find(i,l,mid,k*2);\n\t\t\telse\n\t\t\t\treturn find(i,mid,r,k*2+1);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint[] data = new int[n];\n\t\tArrays.fill(data, (1 << 31) - 1);\n\t\tRUQ_SqrtDecomposition ruq = new RUQ_SqrtDecomposition(data);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint cmd = sc.nextInt();\n\n\t\t\tif (cmd == 0) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\n\t\t\t\truq.update(s, t, x);\n\t\t\t} else if (cmd == 1) {\n\t\t\t\tint index = sc.nextInt();\n\n\t\t\t\tpr.println(ruq.find(index));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class RUQ_SqrtDecomposition {\n\t\tint[] data;\n\t\tint[] bakets;\n\t\tint n; // data???????´???°\n\t\tint d; // 1??????bakets?????§??????\n\t\tint m; // bakets?????°\n\n\t\t// bakets[] ??????????????????????????´?????????\n\t\t// x>=0????????????-1??????\n\t\tfinal static int NULL = -1;\n\n\t\tpublic RUQ_SqrtDecomposition(int[] data) {\n\t\t\tthis.n = data.length;\n\t\t\tthis.data = data;\n\t\t\tthis.d = (int)Math.sqrt(n);\n\n\t\t\tthis.m = (n + d - 1) / d;\n\t\t\tbakets = new int[m];\n\t\t\tArrays.fill(bakets, NULL);\n\t\t}\n\n\t\t// l,r:0-indexed\n\t\t// [l,r)?????????update\n\t\tvoid update(int l, int r, int x) {\n\t\t\tint bl = l / d;\n\t\t\tint br = r / d;\n\t\t\tfor (int i = bl; i <= br; i++) {\n\t\t\t\tint tmpl = i * d;\n\t\t\t\tint tmpr = i * (d + 1);\n\t\t\t\tif (tmpl >= l && tmpr <= r) {\n\t\t\t\t\tbakets[i] = x;\n\t\t\t\t} else {\n\t\t\t\t\tif (bakets[i] != NULL) {\n\t\t\t\t\t\tfor (int j = tmpl; j < tmpr; j++) {\n\t\t\t\t\t\t\tdata[j] = bakets[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbakets[i] = NULL;\n\n\t\t\t\t\ttmpl = Math.max(tmpl, l);\n\t\t\t\t\ttmpr = Math.min(tmpr, r);\n\t\t\t\t\tfor (int j = tmpl; j < tmpr; j++) {\n\t\t\t\t\t\tdata[j] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// index:0-indexed\n\t\tint find(int index) {\n\t\t\tint bi = index / d;\n\t\t\tif (bakets[bi] != NULL) {\n\t\t\t\treturn bakets[bi];\n\t\t\t} else {\n\t\t\t\treturn data[index];\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created at 23:16 on 2019-07-09\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static PrintStream out = System.out;\n  static PrintWriter pw = new PrintWriter(out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int n = sc.nextInt();\n      int q = sc.nextInt();\n\n      long[] a = new long[n];\n      Arrays.fill(a, (1<<31)-1);\n\n      SegmentTree seg = new SegmentTree(a);\n\n      for (int i=0; i<q; i++) {\n        int com = sc.nextInt();\n        if (com == 0) {\n          seg.put(sc.nextInt(), sc.nextInt()+1, sc.nextLong());\n        } else {\n          int index = sc.nextInt();\n          out.println(seg.query(index, index+1).val);\n        }\n      }\n\n    }\n\n\n    /*\n     * 使うときはf()とinitialValを設定する\n     * 場合によってはNodeにフィールドを追加する必要がある\n     * そのときはupdateなども変更する\n     */\n    public static class SegmentTree {\n\n      static final long INF = Long.MAX_VALUE / 2;\n\n      Node[] tree;\n      int N = 1; //元配列の要素数以上で最小の2の冪乗\n      int size; //木のサイズ\n      Node initialNode;\n\n      /*\n       * operation と prop の演算を書き換えることで応用可能\n       * ex. Math.max(a, b), Math.min(a, b), a + b\n       * 初期値はこの関数を元に決める必要がある\n       * (maxなら-Inf, minならInf, a+bなら0)\n       */\n      public static class Node {\n        static long initialVal = 0;\n        static long initialLazy = 0;\n        long val;\n        long lazy;\n        boolean isLazy;\n\n        public Node() {\n          val = initialVal;\n          lazy = initialLazy;\n        }\n        public Node(long val) {\n          this.val = val;\n          lazy = initialLazy;\n        }\n\n        public Node operation(Node nl, Node nr) {\n          val = nl.val + nr.val;\n          return this;\n        }\n        public void prop(Node par) {\n          if (!par.isLazy) return;\n          lazy = par.lazy/2;\n          isLazy = true;\n        }\n        public void prop(long x, int l, int r) {\n          lazy = x * (r-l);\n          isLazy = true;\n        }\n        public void update() {\n          if (!isLazy) return;\n          val = lazy;\n          lazy = initialLazy;\n          isLazy = false;\n        }\n      }\n\n      public void update(int k, long x) {\n        k += N-1;\n        tree[k] = new Node(x);\n\n        while(k != 0) {\n          k = parent(k);\n          tree[k].operation(tree[childL(k)], tree[childR(k)]);\n        }\n      }\n\n      private void prop(int k) {\n        if (childL(k) < size) { //葉じゃなければ\n          tree[childL(k)].prop(tree[k]);\n          tree[childR(k)].prop(tree[k]);\n        }\n        tree[k].update();\n      }\n\n      public void put(int a, int b, long x) {\n        put(a, b, 0, 0, N, x);\n      }\n\n      private void put(int a, int b, int k, int l, int r, long x) {\n        prop(k);\n\n        if (r <= a || b <= l) return; //区間外\n        if (a <= l && r <= b) { //区間に完全に含まれる\n          tree[k].prop(x, l, r);\n          prop(k);\n        } else { //一部区間外\n          put(a, b, childL(k), l, (l + r) / 2, x);\n          put(a, b, childR(k), (l + r) / 2, r, x);\n          tree[k].operation(tree[childL(k)], tree[childR(k)]);\n        }\n      }\n\n      public SegmentTree(long[] A) {\n        initialNode = new Node();\n\n        //元配列の要素数が2の冪乗でない場合,2の冪乗サイズに拡大して初期値をつめておく\n        while (N < A.length) N *= 2;\n\n        size = N*2-1;\n        tree = new Node[size];\n\n        for (int i=0; i<size; i++) {\n          tree[i] = new Node();\n        }\n\n        for (int i=0; i<A.length; i++) {\n          update(i, A[i]);\n        }\n\n      }\n\n      public Node query(int a, int b) {\n        return query(a, b, 0, 0, N);\n      }\n\n      private Node query(int a, int b, int k, int l, int r) {\n        prop(k);\n\n        if (r <= a || b <= l) return initialNode;\n        if (a <= l && r <= b) return tree[k];\n\n        return new Node().operation(query(a, b, childL(k), l, (l+r)/2), query(a, b, childR(k), (l+r)/2, r));\n      }\n\n      private int parent(int k) {\n        return k % 2 == 0 ? (k-2)/2 : (k-1)/2;\n      }\n\n      private int childL(int k) {\n        return 2*k+1;\n      }\n\n      private int childR(int k) {\n        return 2*k+2;\n      }\n\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "package ????????????;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i <= (dst - 1) / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d + 1; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\n//Unordered Pair\nclass UP<A, B> {\n\tA a;\n\tB b;\n\n\tUP(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic <A, B> UP<A, B> make(A a, B b) {\n\t\treturn new UP<A, B>(a, b);\n\t}\n\n\tpublic UP<A, B> clone() {\n\t\treturn make(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UP))\n\t\t\treturn false;\n\t\tUP<?, ?> p = (UP<?, ?>) o;\n\t\tboolean aok = a == null ? p.a == null : a.equals(p.a);\n\t\tboolean bok = b == null ? p.b == null : b.equals(p.b);\n\t\treturn aok && bok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\n\t}\n}\n\ninterface F1<A> {\n\tA f();\n}\n\ninterface F2<A, B> {\n\tB f(A a);\n}\n\ninterface F3<A, B, C> {\n\tC f(A a, B b);\n}\n\ninterface F4<A, B, C, D> {\n\tD f(A a, B b, C c);\n}\n\n// util\nclass U {\n\tstatic <A> ArrayList<A> make(int n, F2<Integer, A> maker) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres.add(maker.f(i));\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> filter(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (A a : as) {\n\t\t\tif (pred.f(a))\n\t\t\t\tres.add(a);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> map(ArrayList<A> as, F2<A, A> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i)));\n\t}\n\n\tstatic <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {\n\t\treturn make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));\n\t}\n\n\tstatic <A extends Comparable<A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n}\n\n//Lazy Segment Tree\nclass LST<A, Op> {\n\t// 0: unused, 1: root\n\tprivate ArrayList<A> dat;\n\tprivate ArrayList<Op> lazy;\n\tprivate F3<A, A, A> merger;\n\tprivate F3<A, Op, A> applier;\n\tprivate F3<Op, Op, Op> opMerger;\n\tprivate F3<Op, Integer, Op> multiplier;\n\tprivate A e;\n\tprivate Op id;\n\tprivate int h;\n\tprivate int n;\n\n\tLST(int num, F3<A, A, A> merger, F3<A, Op, A> applier, F3<Op, Op, Op> opMerger, A e, Op id) {\n\t\tthis(num, merger, applier, opMerger, null, e, id);\n\t}\n\n\tLST(int num, F3<A, A, A> merger, F3<A, Op, A> applier, F3<Op, Op, Op> opMerger, F3<Op, Integer, Op> multiplier,\n\t\t\tA e, Op id) {\n\t\tthis.merger = merger;\n\t\tthis.applier = applier;\n\t\tthis.opMerger = opMerger;\n\t\tthis.multiplier = multiplier;\n\t\tthis.e = e;\n\t\tthis.id = id;\n\t\th = 0;\n\t\twhile ((1 << h) < num)\n\t\t\th++;\n\t\tn = 1 << h;\n\t\tint size = n << 1;\n\t\tdat = U.make(size, (i) -> e);\n\t\tlazy = U.make(size, (i) -> id);\n\t}\n\n\tvoid init(A[] as) {\n\t\tfor (int i = 0; i < n << 1; i++) {\n\t\t\tlazy.set(i, id);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdat.set(n + i, as[i]);\n\t\t}\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tdat.set(i, merge(dat.get(i << 1), dat.get(i << 1 | 1)));\n\t\t}\n\t}\n\n\tA get(int i) {\n\t\treturn query(i, i + 1);\n\t}\n\n\tvoid set(int i, A a) {\n\t\tquery(i, i + 1);\n\t\ti += n;\n\t\tdat.set(i, a);\n\t\twhile ((i >>= 1) > 0) {\n\t\t\tdat.set(i, merge(dat.get(i << 1), dat.get(i << 1 | 1)));\n\t\t}\n\t}\n\n\tvoid apply(int from, int until, Op o) {\n\t\tapplyImpl(from, until, 1, 0, n, o);\n\t}\n\n\tA query(int from, int until) {\n\t\treturn queryImpl(from, until, 1, 0, n);\n\t}\n\n\tint size() {\n\t\treturn n;\n\t}\n\n\tprivate A merge(A a, A b) {\n\t\treturn a == e ? b : b == e ? a : merger.f(a, b);\n\t}\n\n\tprivate Op mergeOp(Op o, Op p) {\n\t\treturn o == id ? p : p == id ? o : opMerger.f(o, p);\n\t}\n\n\tprivate A apply(A a, Op o) {\n\t\treturn o == id ? a : applier.f(a, o);\n\t}\n\n\tprivate Op multiply(Op o, int num) {\n\t\treturn o == id || multiplier == null || num == 1 ? o : multiplier.f(o, num);\n\t}\n\n\tprivate void eval(int k, int len) {\n\t\tOp o = lazy.get(k);\n\t\tif (o == id)\n\t\t\treturn;\n\t\tif (k < n) {\n\t\t\tlazy.set(k << 1, mergeOp(lazy.get(k << 1), o));\n\t\t\tlazy.set(k << 1 | 1, mergeOp(lazy.get(k << 1 | 1), o));\n\t\t}\n\t\tdat.set(k, apply(dat.get(k), multiply(o, len)));\n\t\tlazy.set(k, id);\n\t}\n\n\tprivate A queryImpl(int a, int b, int k, int l, int r) {\n\t\teval(k, r - l);\n\t\tif (r <= a || b <= l)\n\t\t\treturn e;\n\t\tif (a <= l && r <= b)\n\t\t\treturn dat.get(k);\n\t\tA al = queryImpl(a, b, k << 1, l, l + r >> 1);\n\t\tA ar = queryImpl(a, b, k << 1 | 1, l + r >> 1, r);\n\t\treturn merge(al, ar);\n\t}\n\n\tprivate A applyImpl(int a, int b, int k, int l, int r, Op o) {\n\t\teval(k, r - l);\n\t\tif (r <= a || b <= l)\n\t\t\treturn dat.get(k);\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy.set(k, mergeOp(lazy.get(k), o));\n\t\t\treturn apply(dat.get(k), multiply(lazy.get(k), r - l));\n\t\t}\n\t\tA al = applyImpl(a, b, k << 1, l, l + r >> 1, o);\n\t\tA ar = applyImpl(a, b, k << 1 | 1, l + r >> 1, r, o);\n\t\tA res = merge(al, ar);\n\t\tdat.set(k, res);\n\t\treturn res;\n\t}\n}\n\npublic class Main {\n\n\t// TODO: solve\n\tprivate static void solve() {\n\t\tint n = nei();\n\t\tint q = nei();\n\t\tLST<Integer, Integer> lst = new LST<Integer, Integer>(n, (a, b) -> a + b, (a, f) -> f, (f, g) -> g,\n\t\t\t\tInteger.MAX_VALUE, null);\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (nei() == 0) {\n\t\t\t\tint s = nei();\n\t\t\t\tint t = nei();\n\t\t\t\tint x = nei();\n\t\t\t\tlst.apply(s, t + 1, x);\n\t\t\t} else {\n\t\t\t\tout(lst.get(nei()));\n\t\t\t}\n\t\t}\n\t}\n\n\t// returns (x, y, d) s.t. ax + by = d\n\tstatic long[] exgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn new long[] { x * sa, y * sb, a };\n\t}\n\n\tstatic int[] lis(int[] s) {\n\t\tint n = s.length;\n\t\tint[] dp = new int[n];\n\t\tint[] ids = new int[n];\n\t\tint[] pids = new int[n];\n\t\tdp[0] = s[0];\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint idx = bs(s[i], dp, 0, len);\n\t\t\tdp[idx] = s[i];\n\t\t\tids[idx] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tpids[i] = ids[idx - 1];\n\t\t}\n\t\tint[] lis = new int[len];\n\t\tlis[len - 1] = s[lidx];\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tlis[i] = s[lidx];\n\t\t\tlidx = pids[lidx];\n\t\t}\n\t\treturn lis;\n\t}\n\n\tstatic int bs(int a, int[] as, int from, int num) {\n\t\tint min = from;\n\t\tint max = from + num - 1;\n\t\twhile (min < max) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tif (as[mid] < a)\n\t\t\t\tmin = mid + 1;\n\t\t\telse if (as[mid] > a)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\treturn mid;\n\t\t}\n\t\treturn as[min] < a ? min + 1 : min;\n\t}\n\n\tstatic int gcd(int x, int y) {\n\t\tx = (x ^ x >> 31) - (x >> 31);\n\t\ty = (y ^ y >> 31) - (y >> 31);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tint z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long gcd(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tlong z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long modinv(long a, long mod) {\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\n\tstatic long modpow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif ((b & 1) == 0) {\n\t\t\tlong sqrt = modpow(a, b >> 1, mod);\n\t\t\treturn sqrt * sqrt % mod;\n\t\t}\n\t\treturn a * modpow(a, b - 1, mod) % mod;\n\t}\n\n\tstatic long fact(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modfact(long n, long mod) {\n\t\tif (n <= 1)\n\t\t\treturn 1 % mod;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\t// returns facts([0]) and invfacts([1])\n\tstatic long[][] enumfacts(int n, long mod) {\n\t\tint num = n + 10;\n\t\tlong[][] res = new long[2][num];\n\t\tlong[] facts = res[0];\n\t\tlong[] invfacts = res[1];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (i <= 1) {\n\t\t\t\tfacts[i] = 1;\n\t\t\t\tinvfacts[i] = 1;\n\t\t\t} else {\n\t\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\t\tinvfacts[i] = modinv(facts[i], mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modcomb(long n, long m, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tif (m > n - m) {\n\t\t\tm = n - m;\n\t\t}\n\t\tlong numer = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tnumer = numer * (n - i) % mod;\n\t\t}\n\t\tlong denom = modfact(m, mod);\n\t\treturn numer * modinv(denom, mod) % mod;\n\t}\n\n\tstatic long modcomb(int n, int m, long[] facts, long[] invfacts, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tlong numer = facts[n];\n\t\tlong denom = invfacts[m] * invfacts[n - m] % mod;\n\t\treturn numer * denom % mod;\n\t}\n\n\t// res[i][0]: prime factor, res[i][1]: exponent\n\tstatic int[][] factorize(int n) {\n\t\tint[][] pfs = new int[32][2];\n\t\tint num = 0;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tpfs[num][0] = i;\n\t\t\t\tpfs[num][1] = count;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tpfs[num][0] = n;\n\t\t\tpfs[num][1] = 1;\n\t\t\tnum++;\n\t\t}\n\t\tint[][] res = new int[num][2];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tres[i][0] = pfs[i][0];\n\t\t\tres[i][1] = pfs[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long lcm(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\treturn x / gcd(x, y) * y;\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic double clamp(double a, double min, double max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int N = 200005;\n    static int tree[];//start from 0, with all uncertain value\n    //data structure: tree from 0\n    //how to represent the tree node,\n    //node: the segment of the\n    public static void main(String[] args) {\n        int n,m;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        tree = new int[N];\n        for(int i = 0; i<N; i++){\n            tree[i] = 2147483647;\n        }\n        //make entir tree-> get the max n fir ti 2^n\n        int nMax = 1;\n        n = n-1;\n        while(n>0){\n            n = n/2;\n            nMax = nMax<<1;\n        }\n        if(nMax==1) nMax = 2;\n        //start from 0\n        for(int i = 0; i<m; i++){\n            int temp = 0;//decide the type of operation\n            int x,y, val;\n            temp = in.nextInt();\n            if(temp==0){\n                x = in.nextInt();\n                y = in.nextInt();\n                val = in.nextInt();\n                update(x,y,val,0,nMax-1,0);\n                /*for(int j = 0;j <=2*nMax-2;j++){\n                    System.out.println(j+\": \"+tree[j]);\n                }*/\n            } else {\n                x = in.nextInt();\n                int res = find(x,x,0,nMax-1,0);\n                System.out.println(res);\n            }\n\n        }\n    }\n\n    private static int find(int x,int y, int left, int right,int nodeId) {\n        if(left>y || right<x) return -1;\n        else if(left<=x && right>=y && tree[nodeId]>=0){//search range > than,could be -1\n            return tree[nodeId];\n        } else{\n            int num1 = find(x,y,left,(left+right)/2,nodeId*2+1);\n            int num2 = find(x,y,(left+right)/2+1,right,nodeId*2+2);\n            return Math.max(num1,num2);\n        }\n\n    }\n    //update the value\n    //top down\n    private static void update(int x, int y, int val, int left, int right,int nodeId) {\n        //int mid = (left+right)/2;\n        //when to stop: there is only one node\n        //if(mid>right) return;\n        if(x>right||y<left) return;//out of range\n        //when to update\n        //how to view this tree\n        if(x<=left && y>=right){\n            tree[nodeId] = val;\n        }else{//update the tree//go left and right\n            if(tree[nodeId] >=0){\n                tree[nodeId*2+1] = tree[nodeId];\n                tree[nodeId*2+2] = tree[nodeId];\n                tree[nodeId] = -1;\n            }\n            update(x,y,val,left,(left+right)/2,nodeId*2+1);\n            update(x,y,val,(left+right)/2+1,right,nodeId*2+2);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int N = 100005;\n    static int tree[];//start from 0, with all uncertain value\n    //data structure: tree from 0\n    //how to represent the tree node,\n    //node: the segment of the\n    public static void main(String[] args) {\n        int n,m;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        tree = new int[N];\n        for(int i = 0; i<N; i++){\n            tree[i] = 2147483647;\n        }\n        //make entir tree-> get the max n fir ti 2^n\n        int nMax = 1;\n        n = n-1;\n        while(n>0){\n            n = n/2;\n            nMax = nMax<<1;\n        }\n        if(nMax==1) nMax = 2;\n        //start from 0\n        for(int i = 0; i<m; i++){\n            int temp = 0;//decide the type of operation\n            int x,y, val;\n            temp = in.nextInt();\n            if(temp==0){\n                x = in.nextInt();\n                y = in.nextInt();\n                val = in.nextInt();\n                update(x,y,val,0,nMax-1,0);\n                /*for(int j = 0;j <=2*nMax-2;j++){\n                    System.out.println(j+\": \"+tree[j]);\n                }*/\n            } else {\n                x = in.nextInt();\n                int res = find(x,x,0,nMax-1,0);\n                System.out.println(res);\n            }\n\n        }\n    }\n\n    private static int find(int x,int y, int left, int right,int nodeId) {\n        if(left>y || right<x) return -1;\n        else if(left<=x && right>=y && tree[nodeId]>=0){//search range > than,could be -1\n            return tree[nodeId];\n        } else{\n            int num1 = find(x,y,left,(left+right)/2,nodeId*2+1);\n            int num2 = find(x,y,(left+right)/2+1,right,nodeId*2+2);\n            return Math.max(num1,num2);\n        }\n\n    }\n    //update the value\n    //top down\n    private static void update(int x, int y, int val, int left, int right,int nodeId) {\n        //int mid = (left+right)/2;\n        //when to stop: there is only one node\n        //if(mid>right) return;\n        if(x>right||y<left) return;//out of range\n        //when to update\n        //how to view this tree\n        if(x<=left && y>=right){\n            tree[nodeId] = val;\n        }else{//update the tree//go left and right\n            if(tree[nodeId] >=0){\n                tree[nodeId*2+1] = tree[nodeId];\n                tree[nodeId*2+2] = tree[nodeId];\n                tree[nodeId] = -1;\n            }\n            update(x,y,val,left,(left+right)/2,nodeId*2+1);\n            update(x,y,val,(left+right)/2+1,right,nodeId*2+2);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i <= dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d + 1; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\n\nclass Main {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static RUQ d = new RUQ(100005, (1 << 31) - 1);\n    static int n, q;\n    static int com;\n    static int indx;\n    static int s, t, x;\n    \n    public static void main(String[] args) {\n        n = sc.nextInt();\n        q = sc.nextInt();\n        \n        for (int i = 0; i < q; i++) {\n\n            com = sc.nextInt();\n            if (com == 0) {\n\n                s = sc.nextInt();\n                t = sc.nextInt();\n                x = sc.nextInt();\n                d.update(s, t + 1, x);\n            }\n            else {\n                indx = sc.nextInt();\n                out.println(d.query(indx, indx + 1));\n            }\n        }\n        \n        out.flush();\n    }\n}\n\nclass RUQ extends LazySqrtDecomposition<Integer> {\n\n    public RUQ(int n, int e) {\n        super(n, e);\n    }\n    \n    @Override\n    protected Integer f(Integer x, Integer y) {\n        return y;\n    }\n    \n    @Override\n    protected Integer g(Integer x, Integer y, int t) {\n        return y;\n    }\n    \n    @Override\n    protected Integer h(Integer x, Integer y) {\n        return y;\n    }\n\n}\n\n/**\n * @author ei1710\n * @version 1.00\n */\n\n//package toyama.ei1710.DataStructures;\n/**\n * モノイドを乗せられる平方分割の抽象クラス.<br>\n * operatorメソッドをオーバライドすることで二項演算を定義する<br>\n * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う\n *\n * 更新<br>\n * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>\n * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>\n *\n * クエリ<br>\n * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す\n * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する\n * すると、通常の平方分割と同じになる\n *\n */\nabstract class LazySqrtDecomposition<T> {\n    /** 生データ */\n    protected ArrayList<T> raw_data;\n    /** バケットごとに事前に演算した結果を保持 */\n    protected ArrayList<T> bucket;\n    /** バケット範囲に一様に作用させる値 */\n    protected ArrayList<T> lazy;\n    \n    /** lazyにデータはあるかな？ */\n    protected boolean[] lazy_flag;\n    /** 単位元 */\n    protected T e;\n    /** データ数 */\n    protected int N;\n\n    protected int sqrtN;\n\n    /** バケットの数 */\n    protected int K;\n    \n    /** 要素と要素の合成 */\n    abstract protected T f(T x, T y);\n\n    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */\n    abstract protected T g(T x, T y, int t);\n\n    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/\n    abstract protected T h(T x, T y);\n    \n    /** 単位元eを初期値として要素数nmembの平方分割 */\n    public LazySqrtDecomposition(int nmemb, T e) {\n        this.e = e;\n        N = nmemb;\n        sqrtN = 1;\n        while (sqrtN * sqrtN < N) sqrtN++;\n        \n        K = (N + sqrtN - 1) / sqrtN;\n        \n        raw_data = new ArrayList<T>(N);\n        bucket = new ArrayList<T>(K);\n        lazy = new ArrayList<T>(K);\n        lazy_flag = new boolean[K];\n        \n        build();\n    }\n    \n    private void build() {\n\n        for (int i = 0; i < N; i++) {\n            raw_data.add(e);\n        }\n\n        for (int i = 0; i < K; i++) {\n            bucket.add(e);\n            lazy.add(e);\n            lazy_flag[i] = false;\n        }\n    }\n    \n    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */\n    protected void eval(int k) {\n        \n        T x = e;\n        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {\n            if (lazy_flag[k]) {\n                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));\n            }\n            x = f(x, raw_data.get(i));\n        }\n        \n        lazy_flag[k] = false;\n        bucket.set(k, x);\n    }\n\n    \n    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */\n    public void update(int l, int r, T dat) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n\n        int bucket_l, bucket_r;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            \n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    lazy.set(i, h(lazy.get(i), dat));\n                }\n                else {\n                    lazy.set(i, dat);\n                }\n                lazy_flag[i] = true;\n            }\n            else {\n                eval(i);\n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    raw_data.set(j, g(raw_data.get(j), dat, 1));\n                }\n            }\n        }\n    }\n\n    /** [l, r)の区間クエリに答える O(sqrt(N)) */\n    public T query(int l, int r) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n        int bucket_l, bucket_r;\n        T x = e;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    x = f(x, g(bucket.get(i), lazy.get(i), 1));\n                }\n                else {\n                    x = f(x, bucket.get(i));\n                }\n            }\n            else {\n                eval(i);\n                \n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    x = f(x, raw_data.get(j));\n                }\n            }\n        }\n        return x;\n    }\n    \n    /** デバッグ情報の印字 */\n    public void debugPrint() {\n        \n        System.err.println(\"-lazy-\");\n        for (int i = 0; i < lazy.size(); i++) {\n            if (!lazy_flag[i]) {\n                System.err.print(\" --  \");\n            }\n            else {\n                System.err.print(lazy.get(i));\n                System.err.print(' ');\n            }\n        }\n        System.err.print('\\n');\n        \n        System.err.println(\"-bucket-\");\n        for (T p : bucket) {\n            System.err.print(p);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-raw_data-\");\n        for (T q : raw_data) {\n            System.err.print(q);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-other data-\");\n        System.err.printf(\"N: %d, sqrtN: %d, K: %d\\n\", N, sqrtN, K);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tSqrtDecomposition sq = new SqrtDecomposition(n);\n\t\tsq.update(0, n, Integer.MAX_VALUE);\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint type = sc.nextInt();\n\n\t\t\tif(type == 0){\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\n\t\t\t\tsq.update(s, t + 1, x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint index = sc.nextInt();\n\n\t\t\t\tSystem.out.println(sq.get(index));\n\t\t\t}\n\n//\t\t\tfor(int j = 0; j < n; j++){\n//\t\t\t\tSystem.out.print(sq.get(j)+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}\n\nclass SqrtDecomposition {\n\tint N, K;\n\tlong[] data;\n\tlong[] bucketLazyUpdate;\n\tstatic final int sqrtN = 512;\n\tstatic final int INF = Integer.MIN_VALUE;\n\n\tpublic SqrtDecomposition(int n) {\n\t\tN = n;\n\t\tK = (N + sqrtN - 1) / sqrtN;\n\t\tdata = new long[K * sqrtN];\n\t\tbucketLazyUpdate = new long[K];\n\t\tArrays.fill(bucketLazyUpdate, INF);\n\t}\n\n\tvoid update(int s, int t, int x) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tint l = k * sqrtN, r = (k + 1) * sqrtN;\n\t\t\tif (r <= s || t <= l)\n\t\t\t\tcontinue;\n\t\t\tif (s <= l && r <= t) {\n//\t\t\t\tSystem.out.println(\"all\");\n\t\t\t\tbucketLazyUpdate[k] = x;\n\t\t\t} else {\n//\t\t\t\tSystem.out.println(\"each\");\n\t\t\t\tif(bucketLazyUpdate[k] != INF){\n\t\t\t\t\tfor(int i = l; i < r; i++){\n\t\t\t\t\t\tdata[i] = bucketLazyUpdate[k];\n\n\t\t\t\t\t}\n\t\t\t\t\tbucketLazyUpdate[k] = INF;\n\t\t\t\t}\n\t\t\t\tfor (int i = Math.max(s, l); i < Math.min(t, r); ++i) {\n//\t\t\t\t\tSystem.out.println(\"update index \"+i);\n\t\t\t\t\tdata[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong get(int s) {\n\t\tint k = s / sqrtN;\n//\t\tSystem.out.println(s+\" \"+k);\n\t\tif(bucketLazyUpdate[k] != INF){\n//\t\t\tSystem.out.println(\"all\");\n\t\t\treturn bucketLazyUpdate[k];\n\t\t}\n\t\telse {\n//\t\t\tSystem.out.println(\"direct\");\n\t\t\treturn data[s];\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, (1 << 31) - 1);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, (1 << 31) - 1);\n\t\tArrays.fill(edge, false);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, (1 << 31) - 1);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, (1 << 31) - 1);\n\t\tArrays.fill(edge, false);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package ????????????;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int INF = Integer.MAX_VALUE;\n\tstatic int n = 1;\n\tstatic int[] D;\n\tstatic int[] M;\n\tstatic int[] arr;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n= sc.nextInt();\n\t\tint op_num = sc.nextInt();\n\t\tString[] op = new String[op_num+1];\n\t\tfor(int i= 0;i<op.length;i++)\n\t\t\top[i] = sc.nextLine();\n\t\t//System.out.println(n);\n\t\tinit(n);\n\t\tarr = new int[op_num];\n\t\tfor(int i=1;i<=op_num;i++) {\n\t\t\tString[] Split= op[i].split(\" \");\n\t\t\tint x,y,z;\n\t\t\tif(Integer.parseInt(Split[0]) == 0 ) {\n\t\t\t\tx = Integer.parseInt(Split[1]);\n\t\t\t\ty = Integer.parseInt(Split[2]);\n\t\t\t\tz = Integer.parseInt(Split[3]);\n\t\t\t\t//System.out.println(\"Update:\"+x+\" \"+y+\" \"+z);\n\t\t\t\tupdate(x,y,z,i-1);\n\t\t\t}else {\n\t\t\t\t/*for(int i1=0;i1<D.length;i1++) {\n\t\t\t\t\t//System.out.println(\"D\"+i1+\": \"+ D[i1]);\n\t\t\t\t\tSystem.out.println(\"M\"+i1+\": \"+ M[i1]);\n\t\t\t\t}*/\n\t\t\t\tx = Integer.parseInt(Split[1]);\n\t\t\t\t//System.out.println(\"find:\"+x);\n\t\t\t\tif (find(x)!=-1)\n\t\t\t\t\tSystem.out.println(find(x));\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(INF);\n\t\t\t}\n\t\t}\n\t}\n\tprivate static int find(int x) {\n\t\t// TODO Auto-generated method stub\n\t\tint k = x + n -1;\n\t\tint index = M[k];\n\t\t//System.out.println(M[k]);\n\t\tif(index == -1)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn arr[index];\n\t}\n\tprivate static void update(int from, int to, int z,int mark) {\n\t\t// TODO Auto-generated method stub\n\t\tfor(int i=from;i<=to;i++)\n\t\t{\n\t\t\t//M[i] = mark;\n\t\t\tM_update(from,to,mark);\n\t\t}\n\t\t\n\t\t/*for(int i = from + n -1;i<= to+n-1;i++) {\n\t\t\td_update(i,z);\n\t\t}*/\n\t\t\n\t\tarr[mark] = z;\n\t\t\n\t\t\n\t}\n\tprivate static void M_update(int from, int to, int mark) {\n\t\t// TODO Auto-generated method stub\n\t\tint temp1,temp2;\n\t\tint index1,index2;\n\t\tindex1=(from+n-1);\n\t\tindex2 = (to+n-1);\n\t\ttemp1 = index1 % 2; //判断from是不是某个父节点的左孩子  0-是 1-不是\n\t\ttemp2 = index2 % 2; //判断to是不是某个父节点的右孩子  0-不是 1-是\n\t\tif(temp1==1) {\n\t\t\tM[index1] = mark;\n\t\t\tM[(int)((index1-1)/2)] = mark;//更新父节点\n\t\t\tindex1++;\n\t\t\tif(temp2 ==0){\n\t\t\t\t\tM[index2] = mark;\n\t\t\t\t\tindex2--;\n\t\t\t}\n\t\t\tfor(int i=index1;i<=index2;i++){\n\t\t\t\tM[i] = mark;\n\t\t\t\tM[(int)((index1-1)/2)] = mark;\n\t\t\t}\n\t\t}else {\n\t\t\tif(temp2 ==0){\n\t\t\t\tM[index2] = mark;\n\t\t\t\tindex2--;\n\t\t\t}\n\t\t\tfor(int i=index1;i<=index2;i++){\n\t\t\t\tM[i] = mark;\n\t\t\t\tM[(int)((index1-1)/2)] = mark;\n\t\t\t}\t\n\t\t}\n\t}\n\tprivate static void d_update(int k, int a) {\n\t\n\t\tk =k+n-1;\n\t\tD[k] = a;\n\t\twhile(k>0) {\n\t\t\tk = (k-1)/2;\n\t\t\tD[k] = Math.min(D[k*2+1],D[k*2+2]);\n\t\t}\n\t}\n\t\n\tpublic static void init(int N) {\n\t\tn = 1;\n\t\twhile(n<N)\n\t\t\tn*=2;\n\t\tD = new int[n*2 - 1];\n\t\tM = new int[n*2 - 1];\n\t\tfor(int i=0;i<2*n-1;i++)\n\t\t{\n\t\t\tD[i] = INF;\n\t\t\tM[i] = -1;\n\t\t}\n\t}\n\t\n\t\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    static final int INF = 2147483647;\n    static final int LAZYRANGE = 16;\n    static int[] D;\n    static int[] lazy;\n    static int a_n;\n    static int t_n;\n    static int c = 0;\n\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n\n        a_n = Integer.parseInt(scanner.next());\n        int q = Integer.parseInt(scanner.next());\n\n       initRUQ(a_n);\n\n\n\n        for(int i = 0; i < q; i++){\n            int com = Integer.parseInt(scanner.next());\n\n            if(com == 0){\n                int s = Integer.parseInt(scanner.next());\n                int t = Integer.parseInt(scanner.next());\n                int x = Integer.parseInt(scanner.next());\n\n                update(s, t, x);\n\n\n            }\n\n            if(com == 1){\n                int k = Integer.parseInt(scanner.next());\n                System.out.println(find(k));\n            }\n\n\n        }\n\n\n    }\n\n    public static void initRUQ(int a_n){\n\n        D = new int[a_n];\n        lazy = new int[a_n / LAZYRANGE + 1];\n\n        for (int i = 0; i < a_n; i++){\n            D[i] = INF;\n        }\n\n        for(int i = 0; i < lazy.length; i++){\n            lazy[i] = INF;\n        }\n\n    }\n\n    public static void update(int s, int t, int x){\n\n        while (s <= t){\n\n            if(s == 0 || s % LAZYRANGE != 0){\n                if(lazy[s / LAZYRANGE] != INF){\n                    propagate(s);\n                }\n                D[s] = x;\n                s++;\n            }else if(s % LAZYRANGE == 0){\n                if(s + LAZYRANGE <= t){\n                    lazy[s / LAZYRANGE] = x;\n                    s += LAZYRANGE;\n                }else {\n                    if(lazy[s / LAZYRANGE] != INF){\n                        propagate(s);\n                    }\n                    D[s] = x;\n                    s++;\n                }\n            }\n        }\n\n\n\n\n    }\n\n    public static int find(int k){\n        if(lazy[k / LAZYRANGE] != INF){\n            propagate(k);\n        }\n        return D[k];\n    }\n\n    public static void propagate(int k){\n        for(int i = 0; i < LAZYRANGE; i++){\n            D[k / LAZYRANGE * LAZYRANGE + i] = lazy[k / LAZYRANGE];\n        }\n        lazy[k / LAZYRANGE] = INF;\n    }\n\n    public static int query(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return D[k];\n\n\n        int vl = query(a, b, k * 2 + 1, l, (l + r) / 2 );\n        int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n\n    }\n\n    public static int findMin(int a, int b){\n        return query(a, b + 1, 0, 0, t_n);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n    \tPrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        LazySegmentTree t = new LazySegmentTree(n);\n        \n        for(int i=0;i<q;i++){\n        \tint c = sc.nextInt();\n        \t\n        \tif(c==0){\n            \tint s = sc.nextInt();\n            \tint e = sc.nextInt();\n            \tint x = sc.nextInt();\n        \t\tt.update(s,e+1,new Action(x,i));\n        \t}\n        \telse{\n        \t\tint id = sc.nextInt();\n        \t\tout.println(t.query(id, id+1).value);\n        \t}\n        }\n        \n        out.flush();\n    }\n\n}\n\nclass LazySegmentTree {\n\t\n\tData[] tree;\n\tAction[] lazy;\n\t\n\t//要素数で初期化\n\tpublic LazySegmentTree(int n){\n\t\tint num = 1;\n\t\twhile(num<n){\n\t\t\tnum = num*2;\n\t\t}\n\t\ttree = new Data[num*2-1];\n\t\t\n\t\t//データの初期値\n\t\tData start = new Data(Integer.MAX_VALUE);\n\t\tArrays.fill(tree,start);\n\t\t\n\t\tlazy = new Action[num*2-1];\n\t\tArrays.fill(lazy,id_E);\n\t}\n\t\n\t//配列で初期化\n\tpublic LazySegmentTree(Data[] start){\n\t\tint num = 1;\n\t\twhile(num<start.length){\n\t\t\tnum = num*2;\n\t\t}\n\t\ttree = new Data[num*2-1];\n\t\tArrays.fill(tree,id_T);\n\t\tlazy = new Action[num*2-1];\n\t\tArrays.fill(lazy,id_E);\n\t\t\n\t\tfor(int i=0;i<start.length;i++){\n\t\t\tupdate(i,start[i]);\n\t\t}\n\t}\n\n\t//演算\n\tData ope(Data x, Data y){\n\t\treturn new Data(x.value + y.value);\n\t}\n\t\n\t//単位元\n\tstatic Data id_T = new Data(0);\n\n\t//sbjのobjへの作用\n\tData g(Action sbj, Data obj){\n\t\treturn new Data(sbj.value);\n\t}\n\t\n\t//作用素のマージ\n\tAction h(Action obj, Action sbj){\n\t\tif(obj.priority < sbj.priority){\n\t\t\treturn sbj;\n\t\t}\n\t\telse{\n\t\t\treturn obj;\n\t\t}\n\t}\n\t\n\t//長さlenの区間にxを作用させるときの作用の変化　例：和の加算なら*len、min/maxならそのまま\n\tAction p(Action x, int len){\n\t\treturn new Action(x.value * len, x.priority);\n\t}\n\t\n\t//作用素の単位元\n\tstatic Action id_E = new Action(0,-1);\n\t\n\t//idがkの木の頂点を遅延伝播 lenはkの区間の長さ\n\tvoid eval(int len, int k){\n\t\t\n\t\tif(!lazy[k].equals(id_E)){\n\t\t\ttree[k] = g(p(lazy[k],len),tree[k]);\n\t\t\t\n\t\t\t//子は親の半分の範囲\n\t\t\tif(k*2+1 < inum()*2-1){ //最下段かチェック\n\t\t\t\tlazy[2*k+1] = h(lazy[2*k+1],lazy[k]);\n\t\t\t\tlazy[2*k+2] = h(lazy[2*k+2],lazy[k]);\n\t\t\t}\n\t\t}\n\t\t//伝播終了\n\t\tlazy[k] = id_E;\n\t}\n\t\n\t//インデックス数\n\tint inum(){\n\t\treturn (tree.length+1)/2;\n\t}\n\t\n\t//区間[a,b)に作用素xを入れる\n\tData update(int a, int b, Action x){\n\t\treturn update(a,b,x,0,0,inum());\n\t}\n\t\n\t//再帰全体の更新範囲[a,b) [l,r)を表すkに作用素xを入れる\n\tData update(int a, int b, Action x, int k, int l, int r){\n\t\teval(r-l,k);\t//遅延伝播\n\t\t\n\t\tif(r<=a || b<=l){\n\t\t\treturn tree[k];\n\t\t}\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k] = h(lazy[k],x);\n\t\t\treturn g(p(lazy[k],r-l),tree[k]);\n\t\t}\n\t\treturn tree[k] = ope(update(a,b,x,k*2+1,l,(l+r)/2),update(a,b,x,k*2+2,(l+r)/2,r));\n\t}\n\t\n\t//i番目の値をnに更新\n\tvoid update(int i, Data x){\n\t\ti = inum() + i - 1; //単体のa_iが格納されているindex\n\t\ttree[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2; //1つ上の区間和が格納されているindex\n\t\t\ttree[i] = ope(tree[i * 2 + 1], tree[i * 2 + 2]);\n\t\t}\n\t}\n\t\n\t//O(logN)で[start,end)の区間和\n\tData query(int start, int end) {\n\t\treturn query(start, end, 0, 0, inum());\n\t}\n\n\t//[a,b)の区間和, kは自分のいるセグ木のインデックス、対象範囲は[l,r)\n\tprivate Data query(int a, int b, int k, int l, int r) {\n\t\t\n\t\teval(r-l,k);\n\t\t\n\t\t// 要求区間と対象区間が交わらない -> 適当に返す\n\t\tif(r <= a || b <= l){\n\t\t\treturn id_T;\n\t\t}\n\t\t\t\n\t\t// 要求区間が対象区間を完全に被覆 -> 対象区間を答えの計算に使う\n\t\tif(a<=l && r<=b){\n\t\t\treturn tree[k];\n\t\t}\n\t\telse{\n\t\t\tData lv = query(a, b, 2*k+1, l, (l+r)/2);\n\t\t\tData rb = query(a, b, 2*k+2, (l+r)/2, r);\n\t\t\treturn ope(lv, rb);\n\t\t}\n\t}\n\t\n}\n\n//保持すべき値\nclass Data{\n\tlong value;\n\t\n\t//単位元\n\tstatic Data id_T = new Data(0);\n\t\n\tpublic Data(long value){\n\t\tthis.value = value;\n\t}\n\t\n}\n\n//作用素\t変更クエリならpriorityを導入する\nclass Action{\n\n\t//形を変更したら作り直すべき\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tAction other = (Action) obj;\n\t\tif (priority != other.priority)\n\t\t\treturn false;\n\t\tif (value != other.value)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tlong value;\n\tint priority;\n\t\n\tpublic Action(long value, int priority){\n\t\tthis.value = value;\n\t\tthis.priority = priority;\n\t}\n\t\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int N = 100005;\n    static int tree[];//start from 0, with all uncertain value\n    //data structure: tree from 0\n    //how to represent the tree node,\n    //node: the segment of the\n    public static void main(String[] args) {\n        int n,m;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        tree = new int[N];\n        for(int i = 0; i<N; i++){\n            tree[i] = -1;\n        }\n        //make entir tree-> get the max n fir ti 2^n\n        int nMax = 1;\n        n = n-1;\n        while(n>0){\n            n = n/2;\n            nMax = nMax<<1;\n        }\n        if(nMax==1) nMax = 2;\n        //start from 0\n        for(int i = 0; i<m; i++){\n            int temp = 0;//decide the type of operation\n            int x,y, val;\n            temp = in.nextInt();\n            if(temp==0){\n                x = in.nextInt();\n                y = in.nextInt();\n                val = in.nextInt();\n                update(x,y,val,0,nMax-1,0);\n                /*for(int j = 0;j <=2*nMax-2;j++){\n                    System.out.println(j+\": \"+tree[j]);\n                }*/\n            } else {\n                x = in.nextInt();\n                int res = find(x,x,0,nMax-1,0);\n                System.out.println(res);\n            }\n\n        }\n    }\n\n    private static int find(int x,int y, int left, int right,int nodeId) {\n        if(left>y || right<x) return -1;\n        else if(left<=x && right>=y && tree[nodeId]>=0){//search range > than,could be -1\n            return tree[nodeId];\n        } else{\n            int num1 = find(x,y,left,(left+right)/2,nodeId*2+1);\n            int num2 = find(x,y,(left+right)/2+1,right,nodeId*2+2);\n            return Math.max(num1,num2);\n        }\n\n    }\n    //update the value\n    //top down\n    private static void update(int x, int y, int val, int left, int right,int nodeId) {\n        //int mid = (left+right)/2;\n        //when to stop: there is only one node\n        //if(mid>right) return;\n        if(x>right||y<left) return;//out of range\n        //when to update\n        //how to view this tree\n        if(x<=left && y>=right){\n            tree[nodeId] = val;\n        }else{//update the tree//go left and right\n            if(tree[nodeId] >=0){\n                tree[nodeId*2+1] = tree[nodeId];\n                tree[nodeId*2+2] = tree[nodeId];\n                tree[nodeId] = -1;\n            }\n            update(x,y,val,left,(left+right)/2,nodeId*2+1);\n            update(x,y,val,(left+right)/2+1,right,nodeId*2+2);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tint[] arr;\n\tint[] rep;\n\tboolean[] edge;\n\tint d;\n\n\tint get(int i) {\n\t\tif (!edge[i / d]) {\n\t\t\treturn rep[i / d];\n\t\t} else {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\n\tvoid modify(int src, int dst, int x) {\n\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\tedge[i / d] = true;\n\t\t\tarr[i] = x;\n\t\t}\n\t\tfor (int i = src / d + 1; i <= (dst - 1) / d; ++i) {\n\t\t\tedge[i] = false;\n\t\t\trep[i] = x;\n\t\t}\n\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\tedge[i / d] = true;\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\td = (int) Math.sqrt(n);\n\t\tarr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tedge = new boolean[n / d + 1];\n\t\trep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tSystem.out.println(get(sc.nextInt()));\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tmodify(src, dst, x);\n//\t\t\t\tfor (int i = src; i <= dst; ++i) {\n//\t\t\t\t\tif (x != get(i)) {\n//\t\t\t\t\t\tthrow new AssertionError();\n//\t\t\t\t\t}\n//\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i <= dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d + 1; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package ????????????;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tint[] arr;\n\tint[] rep;\n\tboolean[] edge;\n\tint d;\n\n\tint get(int i) {\n\t\tif (!edge[i / d]) {\n\t\t\treturn rep[i / d];\n\t\t} else {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\n\tvoid modify(int src, int dst, int x) {\n\t\tfor (int i = src / d + 1; i <= dst / d - 1; ++i) {\n\t\t\tedge[i] = false;\n\t\t\trep[i] = x;\n\t\t}\n\t\tif (!edge[src / d]) {\n\t\t\tfor (int i = src / d * d; i < (src / d + 1) * d; ++i) {\n\t\t\t\tarr[i] = rep[src / d];\n\t\t\t}\n\t\t}\n\t\tif (!edge[dst / d]) {\n\t\t\tfor (int i = dst / d * d; i < (dst / d + 1) * d; ++i) {\n\t\t\t\tarr[i] = rep[dst / d];\n\t\t\t}\n\t\t}\n\t\tedge[src / d] = true;\n\t\tedge[dst / d] = true;\n\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\tarr[i] = x;\n\t\t}\n\t\tfor (int i = Math.max(src, dst / d * d); i <= dst; ++i) {\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\td = (int) Math.sqrt(n);\n\t\tarr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tedge = new boolean[n / d + 1];\n\t\trep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tSystem.out.println(get(sc.nextInt()));\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tmodify(src, dst, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint[] data = new int[n];\n\t\tArrays.fill(data, (1 << 31) - 1);\n\t\tRUQ_SqrtDecomposition ruq = new RUQ_SqrtDecomposition(data);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint cmd = sc.nextInt();\n\n\t\t\tif (cmd == 0) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\n\t\t\t\truq.update(s, t + 1, x);\n\t\t\t} else if (cmd == 1) {\n\t\t\t\tint index = sc.nextInt();\n\n\t\t\t\tpr.println(ruq.find(index));\n\t\t\t\tpr.flush();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class RUQ_SqrtDecomposition {\n\t\tint[] data;\n\t\tint[] bakets;\n\t\tint n; // data???????´???°\n\t\tint d; // 1??????bakets?????§??????\n\t\tint m; // bakets?????°\n\n\t\t// bakets[] ??????????????????????????´?????????\n\t\t// x>=0????????????-1??????\n\t\tfinal static int NULL = -1;\n\n\t\tpublic RUQ_SqrtDecomposition(int[] data) {\n\t\t\tthis.n = data.length;\n\t\t\tthis.data = data;\n\t\t\tthis.d = (int)Math.sqrt(n);\n\n\t\t\tthis.m = (n + d - 1) / d;\n\t\t\tbakets = new int[m];\n\t\t\tArrays.fill(bakets, NULL);\n\t\t}\n\n\t\t// l,r:0-indexed\n\t\t// [l,r)?????????update\n\t\tvoid update(int l, int r, int x) {\n\t\t\tint bl = l / d;\n\t\t\tint br = Math.min(r / d, m - 1);\n\t\t\tfor (int i = bl; i <= br; i++) {\n\t\t\t\tint tmpl = i * d;\n\t\t\t\tint tmpr = Math.min((i + 1) * d, n);\n\t\t\t\tif (tmpl >= l && tmpr <= r) {\n\t\t\t\t\tbakets[i] = x;\n\t\t\t\t} else {\n\t\t\t\t\tif (bakets[i] != NULL) {\n\t\t\t\t\t\tfor (int j = tmpl; j < tmpr; j++) {\n\t\t\t\t\t\t\tdata[j] = bakets[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbakets[i] = NULL;\n\n\t\t\t\t\ttmpl = Math.max(tmpl, l);\n\t\t\t\t\ttmpr = Math.min(tmpr, r);\n\t\t\t\t\tfor (int j = tmpl; j < tmpr; j++) {\n\t\t\t\t\t\tdata[j] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// index:0-indexed\n\t\tint find(int index) {\n\t\t\tint bi = index / d;\n\t\t\tif (bakets[bi] != NULL) {\n\t\t\t\treturn bakets[bi];\n\t\t\t} else {\n\t\t\t\treturn data[index];\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tnint();\n\t\tint q = nint();\n\t\tTreeMap<Integer,Integer> map = new TreeMap<>();\n\t\tmap.put(-1, Integer.MAX_VALUE);\n\t\twhile (q-- > 0) {\n\t\t\tint command = nint();\n\t\t\tif (command == 0) {\n\t\t\t\tint s = nint();\n\t\t\t\tint t = nint();\n\t\t\t\tint x = nint();\n\t\t\t\tint rightValue = map.floorEntry(t+1).getValue();\n\t\t\t\tmap.subMap(s, t+1).clear();\n\t\t\t\tmap.put(s,x);\n\t\t\t\tmap.put(t+1,rightValue); \n\t\t\t} else {\n\t\t\t\tint i = nint();\n\t\t\t\tSystem.out.println(map.floorEntry(i).getValue());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int nint(){\n\t\treturn Integer.parseInt(sc.next());\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int N = 300005;\n    static int tree[];//start from 0, with all uncertain value\n    //data structure: tree from 0\n    //how to represent the tree node,\n    //node: the segment of the\n    public static void main(String[] args) {\n        int n,m;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        tree = new int[N];\n        for(int i = 0; i<N; i++){\n            tree[i] = 2147483647;\n        }\n        //make entir tree-> get the max n fir ti 2^n\n        int nMax = 1;\n        n = n-1;\n        while(n>0){\n            n = n/2;\n            nMax = nMax<<1;\n        }\n        if(nMax==1) nMax = 2;\n        //start from 0\n        for(int i = 0; i<m; i++){\n            int temp = 0;//decide the type of operation\n            int x,y, val;\n            temp = in.nextInt();\n            if(temp==0){\n                x = in.nextInt();\n                y = in.nextInt();\n                val = in.nextInt();\n                update(x,y,val,0,nMax-1,0);\n                /*for(int j = 0;j <=2*nMax-2;j++){\n                    System.out.println(j+\": \"+tree[j]);\n                }*/\n            } else {\n                x = in.nextInt();\n                int res = find(x,x,0,nMax-1,0);\n                System.out.println(res);\n            }\n\n        }\n    }\n\n    private static int find(int x,int y, int left, int right,int nodeId) {\n        if(left>y || right<x) return -1;\n        else if(left<=x && right>=y && tree[nodeId]>=0){//search range > than,could be -1\n            return tree[nodeId];\n        } else{\n            int num1 = find(x,y,left,(left+right)/2,nodeId*2+1);\n            int num2 = find(x,y,(left+right)/2+1,right,nodeId*2+2);\n            return Math.max(num1,num2);\n        }\n\n    }\n    //update the value\n    //top down\n    private static void update(int x, int y, int val, int left, int right,int nodeId) {\n        //int mid = (left+right)/2;\n        //when to stop: there is only one node\n        //if(mid>right) return;\n        if(x>right||y<left) return;//out of range\n        //when to update\n        //how to view this tree\n        if(x<=left && y>=right){\n            tree[nodeId] = val;\n        }else{//update the tree//go left and right\n            if(tree[nodeId] >=0){\n                tree[nodeId*2+1] = tree[nodeId];\n                tree[nodeId*2+2] = tree[nodeId];\n                tree[nodeId] = -1;\n            }\n            update(x,y,val,left,(left+right)/2,nodeId*2+1);\n            update(x,y,val,(left+right)/2+1,right,nodeId*2+2);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\n\nclass Main {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static RUQ d = new RUQ(100005, (1 << 31) - 1);\n    static int n, q;\n    static int com;\n    static int indx;\n    static int s, t, x;\n    \n    public static void main(String[] args) {\n        n = sc.nextInt();\n        q = sc.nextInt();\n        \n        for (int i = 0; i < q; i++) {\n\n            com = sc.nextInt();\n            if (com == 0) {\n\n                s = sc.nextInt();\n                t = sc.nextInt();\n                x = sc.nextInt();\n                d.update(s, t + 1, x);\n            }\n            else {\n                indx = sc.nextInt();\n                out.println(d.query(indx, indx + 1));\n            }\n        }\n        \n        out.flush();\n    }\n}\n\nclass RUQ extends LazySqrtDecomposition<Integer> {\n\n    public RUQ(int n, int e) {\n        super(n, e);\n    }\n    \n    @Override\n    protected Integer f(Integer x, Integer y) {\n        return y;\n    }\n    \n    @Override\n    protected Integer g(Integer x, Integer y, int t) {\n        return y;\n    }\n    \n    @Override\n    protected Integer h(Integer x, Integer y) {\n        return y;\n    }\n\n}\n\n/**\n * @author ei1710\n * @version 1.00\n */\n\n//package toyama.ei1710.DataStructures;\n/**\n * モノイドを乗せられる平方分割の抽象クラス.<br>\n * operatorメソッドをオーバライドすることで二項演算を定義する<br>\n * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う\n *\n * 更新<br>\n * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>\n * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>\n *\n * クエリ<br>\n * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す\n * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する\n * すると、通常の平方分割と同じになる\n *\n */\nabstract class LazySqrtDecomposition<T> {\n    /** 生データ */\n    protected ArrayList<T> raw_data;\n    /** バケットごとに事前に演算した結果を保持 */\n    protected ArrayList<T> bucket;\n    /** バケット範囲に一様に作用させる値 */\n    protected ArrayList<T> lazy;\n    \n    /** lazyにデータはあるかな？ */\n    protected boolean[] lazy_flag;\n    /** 単位元 */\n    protected T e;\n    /** データ数 */\n    protected int N;\n\n    protected int sqrtN;\n\n    /** バケットの数 */\n    protected int K;\n    \n    /** 要素と要素の合成 */\n    abstract protected T f(T x, T y);\n\n    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */\n    abstract protected T g(T x, T y, int t);\n\n    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/\n    abstract protected T h(T x, T y);\n    \n    /** 単位元eを初期値として要素数nmembの平方分割 */\n    public LazySqrtDecomposition(int nmemb, T e) {\n        this.e = e;\n        N = nmemb;\n        sqrtN = 1;\n        while (sqrtN * sqrtN < N) sqrtN++;\n        \n        K = (N + sqrtN - 1) / sqrtN;\n        \n        raw_data = new ArrayList<T>(N);\n        bucket = new ArrayList<T>(K);\n        lazy = new ArrayList<T>(K);\n        lazy_flag = new boolean[K];\n        \n        build();\n    }\n    \n    private void build() {\n\n        for (int i = 0; i < N; i++) {\n            raw_data.add(e);\n        }\n\n        for (int i = 0; i < K; i++) {\n            bucket.add(e);\n            lazy.add(e);\n            lazy_flag[i] = false;\n        }\n    }\n    \n    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */\n    protected void eval(int k) {\n        \n        T x = e;\n        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {\n            if (lazy_flag[k]) {\n                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));\n            }\n            x = f(x, raw_data.get(i));\n        }\n        \n        lazy_flag[k] = false;\n        bucket.set(k, x);\n    }\n\n    \n    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */\n    public void update(int l, int r, T dat) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n\n        int bucket_l, bucket_r;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            \n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    lazy.set(i, h(lazy.get(i), dat));\n                }\n                else {\n                    lazy.set(i, dat);\n                }\n                lazy_flag[i] = true;\n            }\n            else {\n                eval(i);\n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    raw_data.set(j, g(raw_data.get(j), dat, 1));\n                }\n            }\n        }\n    }\n\n    /** [l, r)の区間クエリに答える O(sqrt(N)) */\n    public T query(int l, int r) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n        int bucket_l, bucket_r;\n        T x = e;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    x = f(x, g(bucket.get(i), lazy.get(i), 1));\n                }\n                else {\n                    x = f(x, bucket.get(i));\n                }\n            }\n            else {\n                eval(i);\n                \n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    x = f(x, raw_data.get(j));\n                }\n            }\n        }\n        return x;\n    }\n    \n    /** デバッグ情報の印字 */\n    public void debugPrint() {\n        \n        System.err.println(\"-lazy-\");\n        for (int i = 0; i < lazy.size(); i++) {\n            if (!lazy_flag[i]) {\n                System.err.print(\" --  \");\n            }\n            else {\n                System.err.print(lazy.get(i));\n                System.err.print(' ');\n            }\n        }\n        System.err.print('\\n');\n        \n        System.err.println(\"-bucket-\");\n        for (T p : bucket) {\n            System.err.print(p);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-raw_data-\");\n        for (T q : raw_data) {\n            System.err.print(q);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-other data-\");\n        System.err.printf(\"N: %d, sqrtN: %d, K: %d\\n\", N, sqrtN, K);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n/**\n * @author Chen Qiu, email:m5222104@u-aizu.ac.jp\n *@version : 2019/April\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint n;\n\t\tint[] D;\n\t\tint q;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tq=in.nextInt();\n        n = (int)Math.ceil(Math.log(n) / Math.log(2));\n        n=1<<n;\n\t\tD=new int[n];\n\t\tint INF=Integer.MAX_VALUE;\n\t\tfor (int i= 0; i < 2*n-1; i++ ){\n\t\t\tD[i]=INF;\n\t\t}\n\t\tint a,b,c,d;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta=in.nextInt();\n\t\t\tb=in.nextInt();\n\t\t\tif (a==0) {\n\t\t\t\tc=in.nextInt();\n\t\t\t\td=in.nextInt();\n\t\t\t\tfor (int j=b+n-1;j < c+n ;j++) {\n\t\t\t\t\tD[j]=d;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tSystem.out.println(D[b+n-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int n = in.nextInt(), q = in.nextInt();\n\n        RUpdateQ rUpdateQ = new RUpdateQ(n);\n\n        for (int i = 0; i < q; i++) {\n            int cmd = in.nextInt();\n            if (cmd == 0) {\n                int s = in.nextInt(),\n                        t = in.nextInt(),\n                        x = in.nextInt();\n                rUpdateQ.update(s, t, x);\n            }\n            if (cmd == 1) {\n                int index = in.nextInt();\n                System.out.println(rUpdateQ.find(index));\n            }\n        }\n\n\n    }\n}\n\nclass RUpdateQ{\n    int[] heap;\n    int n;\n\n    static int _heap_size(int n) {\n        int pow2 = 1;\n        while (pow2 < n) {\n            pow2 *= 2;\n        }\n        return pow2 * 2;\n    }\n\n    RUpdateQ(int n) {\n        this.n = n;\n        heap = new int[_heap_size(n)];\n        Arrays.fill(heap, Integer.MAX_VALUE);\n    }\n\n\n    public void update(int s, int t, int x) {\n        update(s, t+1, x, 0, n, 1);\n\n    }\n\n    private void update(int s, int t, int x, int l, int r, int ih) {\n        if (s >= t) {\n            return;\n        }\n        if (s == l && t == r) {\n            heap[ih] = x;\n            return;\n        }\n        // else: [s,t) in [l, r)\n        if (heap[ih] > 0) {\n            // broadcast to next level\n            heap[ih * 2] = heap[ih];\n            heap[ih * 2 + 1] = heap[ih];\n            // indicate multi val\n            heap[ih] = -1;\n        }\n\n        int mid = (l + r) / 2;\n        update(Math.max(s, l), Math.min(mid, t), x, l, mid, ih * 2);\n        update(Math.max(s, mid), Math.min(t, r), x, mid, r, ih * 2 + 1);\n    }\n\n    public int find(int index) {\n        return find(index, 0, n, 1);\n    }\n\n    private int find(int index, int l, int r, int ih) {\n        if (heap[ih] >= 0) {\n            return heap[ih];\n        }else {\n            int mid = (l + r) / 2;\n            if (index < mid) {\n                return find(index, l, mid, ih * 2);\n            }else {\n                return find(index, mid, r, ih * 2 + 1);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static class SegmentTree {\n\t\tint[] tree;\n\t\tpublic SegmentTree(int n) {\n\t\t\tint d = (int)Math.ceil(Math.log((double)n) / Math.log(2.0));\n\t\t\ttree = new int[(int)Math.pow(2, d+1)];\n\t\t\tArrays.fill(tree, -1);\n\t\t\ttree[0] = Integer.MAX_VALUE;\n\t\t}\n\n\t\tpublic int find(int i) {\n\t\t\ti += tree.length/2-1;\n\t\t\tint r = tree[i];\n\t\t\twhile(i > 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tr = Math.max(r, tree[i]);\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tpublic void update(int i, int x) {\n\t\t\ti += tree.length/2-1;\n\t\t\ttree[i] = x;\n\t\t\twhile(i > 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\ttree[i] = Math.min(tree[i*2+1], tree[i*2+2]);\n\t\t\t}\n\t\t\t// print();\n\t\t}\n\n\t\t// usage\n\t\t// updateRange(a, b, x, 0, 0, seg.tree.length/2)\n\t\tpublic void updateRange(int a, int b, int x, int k, int l, int r) {\n\t\t\tif(r <= a || b < l) return;\n\t\t\tif(a <= l && r-1 <= b) tree[k] = x;\n\t\t\telse {\n\t\t\t\tif(tree[k] >= 0) {\n\t\t\t\t\ttree[k*2+1] = tree[k];\n\t\t\t\t\ttree[k*2+2] = tree[k];\n\t\t\t\t\ttree[k] = -1;\n\t\t\t\t}\n\t\t\t\tupdateRange(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\t\tupdateRange(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\t}\n\t\t}\n\n\t\t// usage\n\t\t// query(a, b, 0, 0, seg.tree.length/2)\n\t\tpublic int query(int a, int b, int k, int l, int r) {\n\t\t\t// System.out.println(a+\" \"+b+\" \"+k+\" \"+l+\" \"+r);\n\t\t\tif(r <= a || b < l) return Integer.MAX_VALUE;\n\t\t\tif(a <= l && r-1 <= b) return tree[k];\n\t\t\telse {\n\t\t\t\tint vl = query(a, b, k*2+1, l, (l+r)/2);\n\t\t\t\tint vr = query(a, b, k*2+2, (l+r)/2, r);\n\t\t\t\treturn Math.min(vl, vr);\n\t\t\t}\n\t\t}\n\n\t\tpublic void print() {\n\t\t\tfor(int i=0; i<tree.length-1; i++) {\n\t\t\t\tSystem.out.print(tree[i]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint n = r.nextInt();\n\t\tint q = r.nextInt();\n\t\tSegmentTree seg = new SegmentTree(n);\n\t\tfor(int k=0; k<q; k++) {\n\t\t\tint c = r.nextInt();\n\t\t\tif(c == 0) {\n\t\t\t\tint s = r.nextInt();\n\t\t\t\tint t = r.nextInt();\n\t\t\t\tint x = r.nextInt();\n\t\t\t\tseg.updateRange(s, t, x, 0, 0, seg.tree.length/2);\n\t\t\t} else {\n\t\t\t\tint i = r.nextInt();\n\t\t\t\tSystem.out.println(seg.find(i));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.logging.Logger;\n\nimport javax.sound.midi.MidiMessage;\n \npublic class Main {\n\t  static int MAX = 510000;\n\t\tstatic long[] fac=new long[MAX];\n\t\tstatic long[] finv=new long[MAX];\n\t\tstatic long[] inv=new long[MAX];\n\t\tstatic long MOD=(long) (Math.pow(10, 9)+7);\n\t\tstatic boolean[] visited;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\tint N=sc.nextInt();\n\t\tint q=sc.nextInt();\n\t\tLazysegTreemin lazysegTreesum=new LazysegTreemin(N);\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c=sc.nextInt();\n\t\t\tif (c==0) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt()+1;\n\t\t\t\tlong x=sc.nextLong();\n\t\t\t\tlazysegTreesum.update(s, t, x, 0, 0, lazysegTreesum.size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=s+1;\n\t\t\t\tout.println(lazysegTreesum.getmin(s, t, 0, 0, lazysegTreesum.size));\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic class LazysegTreemin{\n\t\tint size;\n\t\tlong[] dat;\n\t\tlong[] lazy;\n\t\tlong INF=Integer.MAX_VALUE;\n\t\tpublic LazysegTreemin(int n) {\n\t\t\tint n_=1;\n\t\t\twhile (n_<n) {\n\t\t\t\tn_*=2;\n\t\t\t}\n\t\t\tsize=n_;\n\t\t\tdat=new long[2*n_-1];\n\t\t\tlazy=new long[2*n_-1];\n\t\t\tArrays.fill(dat, INF);\n\t\t\tArrays.fill(lazy, INF);\n\t\t}\n\t\tvoid propagate(int k,int l,int r) {\n\t\t\tif (lazy[k]!=INF) {\n\t\t\t\tdat[k] = lazy[k];\n\t\t\t\tif(r - l > 1) {\n\t\t            lazy[2*k+1] = lazy[k];\n\t\t            lazy[2*k+2] = lazy[k];\n\t\t        }\n\t\t        lazy[k] = INF;\n\t\t\t}\n\t\t}\n\t\tvoid update(int a,int b,long x,int k,int l,int r) {//a<=x<b加算　add(...,0,0,seg.size)で呼ぶ\n\t\t\tthis.propagate(k,l,r);\n\t\t\tif (a<=l&&r<=b) {\n\t\t\t\tlazy[k]=x;\n\t\t\t\tthis.propagate(k,l,r);\n\t\t\t}\n\t\t\telse if (l<b&&a<r) {//交わっている場合\n\t\t\t\tthis.update(a, b, x, k*2+1,l,(l+r)/2);\n\t\t\t\tthis.update(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\t\tdat[k] = Math.min(dat[2*k+1],dat[2*k+2]);\n\t\t\t}\n\t\t}\n\t\tlong getmin(int a,int b,int k,int l,int r) {//kが節点番号,l rがその節点番号の範囲\n\t\t\tif (r<=a||b<=l) {\n\t\t\t\treturn INF;\n\t\t\t}\n\t\t\tthis.propagate(k, l, r);\n\t\t\tif (a<=l&&r<=b) {\n\t\t\t\treturn dat[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong vl=this.getmin(a, b, k*2+1,l,(l+r)/2);\n\t\t\t\tlong vr=this.getmin(a, b, k*2+2, (l+r)/2, r);\n\t\t\t\treturn (Math.min(vl, vr));\n\t\t\t}\n\t\t}//getsum(x, y, 0, 0, size)で呼ぶ\n\t}\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\n\nclass Main {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static RUQ d = new RUQ(100005, (1 << 31) - 1);\n    static int n, q;\n    static int com;\n    static int indx;\n    static int s, t, x;\n    \n    public static void main(String[] args) {\n        n = sc.nextInt();\n        q = sc.nextInt();\n        \n        for (int i = 0; i < q; i++) {\n\n            com = sc.nextInt();\n            if (com == 0) {\n\n                s = sc.nextInt();\n                t = sc.nextInt();\n                x = sc.nextInt();\n                d.update(s, t + 1, x);\n            }\n            else {\n                indx = sc.nextInt();\n                out.println(d.query(indx, indx + 1));\n            }\n        }\n        \n        out.flush();\n    }\n}\n\nclass RUQ extends LazySqrtDecomposition<Integer> {\n\n    public RUQ(int n, int e) {\n        super(n, e);\n    }\n    \n    @Override\n    protected Integer f(Integer x, Integer y) {\n        return y;\n    }\n    \n    @Override\n    protected Integer g(Integer x, Integer y, int t) {\n        return y;\n    }\n    \n    @Override\n    protected Integer h(Integer x, Integer y) {\n        return y;\n    }\n\n}\n\n/**\n * @author ei1710\n * @version 1.00\n */\n\n//package toyama.ei1710.DataStructures;\n/**\n * モノイドを乗せられる平方分割の抽象クラス.<br>\n * operatorメソッドをオーバライドすることで二項演算を定義する<br>\n * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う\n *\n * 更新<br>\n * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>\n * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>\n *\n * クエリ<br>\n * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す\n * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する\n * すると、通常の平方分割と同じになる\n *\n */\nabstract class LazySqrtDecomposition<T> {\n    /** 生データ */\n    protected ArrayList<T> raw_data;\n    /** バケットごとに事前に演算した結果を保持 */\n    protected ArrayList<T> bucket;\n    /** バケット範囲に一様に作用させる値 */\n    protected ArrayList<T> lazy;\n    \n    /** lazyにデータはあるかな？ */\n    protected boolean[] lazy_flag;\n    /** 単位元 */\n    protected T e;\n    /** データ数 */\n    protected int N;\n\n    protected int sqrtN;\n\n    /** バケットの数 */\n    protected int K;\n    \n    /** 要素と要素の合成 */\n    abstract protected T f(T x, T y);\n\n    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */\n    abstract protected T g(T x, T y, int t);\n\n    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/\n    abstract protected T h(T x, T y);\n    \n    /** 単位元eを初期値として要素数nmembの平方分割 */\n    public LazySqrtDecomposition(int nmemb, T e) {\n        this.e = e;\n        N = nmemb;\n        sqrtN = 1;\n        while (sqrtN * sqrtN < N) sqrtN++;\n        \n        K = (N + sqrtN - 1) / sqrtN;\n        \n        raw_data = new ArrayList<T>(N);\n        bucket = new ArrayList<T>(K);\n        lazy = new ArrayList<T>(K);\n        lazy_flag = new boolean[K];\n        \n        build();\n    }\n    \n    private void build() {\n\n        for (int i = 0; i < N; i++) {\n            raw_data.add(e);\n        }\n\n        for (int i = 0; i < K; i++) {\n            bucket.add(e);\n            lazy.add(e);\n            lazy_flag[i] = false;\n        }\n    }\n    \n    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */\n    protected void eval(int k) {\n        \n        T x = e;\n        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {\n            if (lazy_flag[k]) {\n                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));\n            }\n            x = f(x, raw_data.get(i));\n        }\n        \n        lazy_flag[k] = false;\n        bucket.set(k, x);\n    }\n\n    \n    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */\n    public void update(int l, int r, T dat) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n\n        int bucket_l, bucket_r;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            \n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    lazy.set(i, h(lazy.get(i), dat));\n                }\n                else {\n                    lazy.set(i, dat);\n                }\n                lazy_flag[i] = true;\n            }\n            else {\n                eval(i);\n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    raw_data.set(j, g(raw_data.get(j), dat, 1));\n                }\n            }\n        }\n    }\n\n    /** [l, r)の区間クエリに答える O(sqrt(N)) */\n    public T query(int l, int r) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n        int bucket_l, bucket_r;\n        T x = e;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    x = f(x, g(bucket.get(i), lazy.get(i), 1));\n                }\n                else {\n                    x = f(x, bucket.get(i));\n                }\n            }\n            else {\n                eval(i);\n                \n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    x = f(x, raw_data.get(j));\n                }\n            }\n        }\n        return x;\n    }\n    \n    /** デバッグ情報の印字 */\n    public void debugPrint() {\n        \n        System.err.println(\"-lazy-\");\n        for (int i = 0; i < lazy.size(); i++) {\n            if (!lazy_flag[i]) {\n                System.err.print(\" --  \");\n            }\n            else {\n                System.err.print(lazy.get(i));\n                System.err.print(' ');\n            }\n        }\n        System.err.print('\\n');\n        \n        System.err.println(\"-bucket-\");\n        for (T p : bucket) {\n            System.err.print(p);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-raw_data-\");\n        for (T q : raw_data) {\n            System.err.print(q);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-other data-\");\n        System.err.printf(\"N: %d, sqrtN: %d, K: %d\\n\", N, sqrtN, K);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int INF = Integer.MAX_VALUE;\n\tstatic int n = 1;\n\tstatic int[] D;\n\tstatic int[] M;\n\tstatic int[] arr;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n= sc.nextInt();\n\t\tint op_num = sc.nextInt();\n\t\tString[] op = new String[op_num+1];\n\t\tfor(int i= 0;i<op.length;i++)\n\t\t\top[i] = sc.nextLine();\n\t\t//System.out.println(n);\n\t\tinit(n);\n\t\tarr = new int[op_num];\n\t\tfor(int i=1;i<=op_num;i++) {\n\t\t\tString[] Split= op[i].split(\" \");\n\t\t\tint x,y,z;\n\t\t\tif(Integer.parseInt(Split[0]) == 0 ) {\n\t\t\t\tx = Integer.parseInt(Split[1]);\n\t\t\t\ty = Integer.parseInt(Split[2]);\n\t\t\t\tz = Integer.parseInt(Split[3]);\n\t\t\t\t//System.out.println(\"Update:\"+x+\" \"+y+\" \"+z);\n\t\t\t\tupdate(x,y,z,i-1);\n\t\t\t}else {\n\t\t\t\t/*for(int i1=0;i1<D.length;i1++) {\n\t\t\t\t\t//System.out.println(\"D\"+i1+\": \"+ D[i1]);\n\t\t\t\t\tSystem.out.println(\"M\"+i1+\": \"+ M[i1]);\n\t\t\t\t}*/\n\t\t\t\tx = Integer.parseInt(Split[1]);\n\t\t\t\t//System.out.println(\"find:\"+x);\n\t\t\t\tif (find(x)!=-1)\n\t\t\t\t\tSystem.out.println(find(x));\n\t\t\t}\n\t\t}\n\t}\n\tprivate static int find(int x) {\n\t\t// TODO Auto-generated method stub\n\t\tint k = x + n -1;\n\t\tint index = M[k];\n\t\t//System.out.println(M[k]);\n\t\tif(index == -1)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn arr[index];\n\t}\n\tprivate static void update(int from, int to, int z,int mark) {\n\t\t// TODO Auto-generated method stub\n\t\tfor(int i=from;i<=to;i++)\n\t\t{\n\t\t\t//M[i] = mark;\n\t\t\tM_update(from,to,mark);\n\t\t}\n\t\t\n\t\t/*for(int i = from + n -1;i<= to+n-1;i++) {\n\t\t\td_update(i,z);\n\t\t}*/\n\t\t\n\t\tarr[mark] = z;\n\t\t\n\t\t\n\t}\n\tprivate static void M_update(int from, int to, int mark) {\n\t\t// TODO Auto-generated method stub\n\t\tint temp1,temp2;\n\t\tint index1,index2;\n\t\tindex1=(from+n-1);\n\t\tindex2 = (to+n-1);\n\t\ttemp1 = index1 % 2; //判断from是不是某个父节点的左孩子  0-是 1-不是\n\t\ttemp2 = index2 % 2; //判断to是不是某个父节点的右孩子  0-不是 1-是\n\t\tif(temp1==1) {\n\t\t\tM[index1] = mark;\n\t\t\tM[(int)((index1-1)/2)] = mark;//更新父节点\n\t\t\tindex1++;\n\t\t\tif(temp2 ==0){\n\t\t\t\t\tM[index2] = mark;\n\t\t\t\t\tindex2--;\n\t\t\t}\n\t\t\tfor(int i=index1;i<=index2;i++){\n\t\t\t\tM[i] = mark;\n\t\t\t\tM[(int)((index1-1)/2)] = mark;\n\t\t\t}\n\t\t}else {\n\t\t\tif(temp2 ==0){\n\t\t\t\tM[index2] = mark;\n\t\t\t\tindex2--;\n\t\t\t}\n\t\t\tfor(int i=index1;i<=index2;i++){\n\t\t\t\tM[i] = mark;\n\t\t\t\tM[(int)((index1-1)/2)] = mark;\n\t\t\t}\t\n\t\t}\n\t}\n\tprivate static void d_update(int k, int a) {\n\t\n\t\tk =k+n-1;\n\t\tD[k] = a;\n\t\twhile(k>0) {\n\t\t\tk = (k-1)/2;\n\t\t\tD[k] = Math.min(D[k*2+1],D[k*2+2]);\n\t\t}\n\t}\n\t\n\tpublic static void init(int N) {\n\t\tn = 1;\n\t\twhile(n<N)\n\t\t\tn*=2;\n\t\tD = new int[n*2 - 1];\n\t\tM = new int[n*2 - 1];\n\t\tfor(int i=0;i<2*n-1;i++)\n\t\t{\n\t\t\tD[i] = INF;\n\t\t\tM[i] = -1;\n\t\t}\n\t}\n\t\n\t\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.function.LongBinaryOperator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.security.AccessControlException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.regex.Pattern;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DSL_2_D solver = new DSL_2_D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DSL_2_D {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            Debug.autoEnable();\n            int n = in.ints(), queries = in.ints();\n            long[] a = new long[n];\n            Arrays.fill(a, Integer.MAX_VALUE);\n            IntLazySegmentTree st = new IntLazySegmentTree(a, Math::max, 0L,\n                    (x, q) -> q, (q1, q2) -> q2, -1);\n            for (int i = 0; i < queries; i++) {\n                int com = in.ints();\n                if (com == 0) {\n                    int s = in.ints(), t = in.ints(), x = in.ints();\n                    st.update(s, t + 1, x);\n                } else {\n                    int s = in.ints();\n                    out.ans(st.query(s, s + 1)).ln();\n                }\n            }\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class Debug {\n        private static final String DEBUG_PROPERTY = \"debug\";\n        private static final String DEBUG_CALL_PATTERN = \"^.+\\\\.debug\\\\((.+)\\\\);.*$\";\n        private static Pattern debugRegex;\n        private static boolean enabled = false;\n        private static String src;\n\n        public static void enable(String s) {\n            enabled = true;\n            src = s;\n            if (debugRegex == null) {\n                debugRegex = Pattern.compile(DEBUG_CALL_PATTERN);\n            }\n        }\n\n        public static boolean autoEnable() {\n            try {\n                String s = System.getProperty(DEBUG_PROPERTY);\n                if (s != null) {\n                    enable(s);\n                    return true;\n                }\n            } catch (AccessControlException ex) {\n                src = null;\n            }\n            return false;\n        }\n\n    }\n\n    static class IntLazySegmentTree {\n        private final int n;\n        private final int m;\n        private final long[] tree;\n        private final long[] lazy;\n        private final LongBinaryOperator op;\n        private final long zero;\n        private final LongBinaryOperator up;\n        private final LongBinaryOperator merge;\n        private final long nop;\n        private final LongIntToLongFunction mul;\n\n        public IntLazySegmentTree(long[] array, LongBinaryOperator op, long zero, LongBinaryOperator up,\n                                  LongBinaryOperator merge, long nop,\n                                  LongIntToLongFunction mul) {\n            this.n = array.length;\n            int msb = BitMath.extractMsb(n);\n            this.m = n == msb ? msb : (msb << 1);\n            this.op = op;\n            this.zero = zero;\n            this.up = up;\n            this.merge = merge;\n            this.nop = nop;\n            this.mul = mul;\n            this.tree = new long[m * 2 - 1];\n            Arrays.fill(tree, zero);\n            System.arraycopy(array, 0, this.tree, m - 1, array.length);\n            this.lazy = new long[m * 2 - 1];\n            Arrays.fill(lazy, nop);\n            for (int i = m - 2; i >= 0; i--) {\n                tree[i] = op.applyAsLong(tree[2 * i + 1], tree[2 * i + 2]);\n            }\n        }\n\n        public IntLazySegmentTree(long[] array, LongBinaryOperator op, long zero, LongBinaryOperator up,\n                                  LongBinaryOperator merge, long nop) {\n            this(array, op, zero, up, merge, nop, (q, n) -> q);\n        }\n\n        private void eval(int len, int k) {\n            if (lazy[k] == nop) {\n                return;\n            } else if (k * 2 + 1 < m * 2 - 1) {\n                lazy[k * 2 + 1] = merge.applyAsLong(lazy[k * 2 + 1], lazy[k]);\n                lazy[k * 2 + 2] = merge.applyAsLong(lazy[k * 2 + 2], lazy[k]);\n            }\n            tree[k] = up.applyAsLong(tree[k], mul.applyAsLong(lazy[k], len));\n            lazy[k] = nop;\n        }\n\n        private void update(int l, int r, long q, int k, int sl, int sr) {\n            if (r <= sl || sr <= l) {\n                return;\n            }\n            eval(r - l, k); // TODO これ要る?w\n            if (l <= sl && sr <= r) {\n                lazy[k] = merge.applyAsLong(lazy[k], q);\n            } else {\n                update(l, r, q, k * 2 + 1, sl, (sl + sr) / 2);\n                update(l, r, q, k * 2 + 2, (sl + sr) / 2, sr);\n            }\n        }\n\n        public void update(int l, int r, long q) {\n            update(l, r, q, 0, 0, m);\n        }\n\n        private long query(int l, int r, int k, int sl, int sr) {\n            if (r <= sl || sr <= l) {\n                return zero;\n            }\n            eval(r - l, k);\n            if (l <= sl && sr <= r) {\n                return tree[k];\n            } else {\n                long left = query(l, r, 2 * k + 1, sl, (sl + sr) / 2);\n                long right = query(l, r, 2 * k + 2, (sl + sr) / 2, sr);\n                return op.applyAsLong(left, right);\n            }\n        }\n\n        public long query(int l, int r) {\n            return query(l, r, 0, 0, m);\n        }\n\n    }\n\n    static interface LongIntToLongFunction<T, R> {\n        long applyAsLong(long x, int y);\n\n    }\n\n    static final class BitMath {\n        private BitMath() {\n        }\n\n        public static int extractMsb(int v) {\n            v = (v & 0xFFFF0000) > 0 ? v & 0xFFFF0000 : v;\n            v = (v & 0xFF00FF00) > 0 ? v & 0xFF00FF00 : v;\n            v = (v & 0xF0F0F0F0) > 0 ? v & 0xF0F0F0F0 : v;\n            v = (v & 0xCCCCCCCC) > 0 ? v & 0xCCCCCCCC : v;\n            v = (v & 0xAAAAAAAA) > 0 ? v & 0xAAAAAAAA : v;\n            return v;\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\n\npublic class Dsl_2_d {\n\tpublic static class SegmentTree {\n\t\tint[] tree;\n\t\tpublic SegmentTree(int n) {\n\t\t\tint d = (int)Math.ceil(Math.log((double)n) / Math.log(2.0));\n\t\t\ttree = new int[(int)Math.pow(2, d+1)];\n\t\t\tArrays.fill(tree, -1);\n\t\t\ttree[0] = Integer.MAX_VALUE;\n\t\t}\n\n\t\tpublic int find(int i) {\n\t\t\ti += tree.length/2-1;\n\t\t\tint r = tree[i];\n\t\t\twhile(i > 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tif(tree[i] >= 0) r = tree[i];\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tpublic void update(int i, int x) {\n\t\t\ti += tree.length/2-1;\n\t\t\ttree[i] = x;\n\t\t\twhile(i > 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\ttree[i] = Math.min(tree[i*2+1], tree[i*2+2]);\n\t\t\t}\n\t\t\t// print();\n\t\t}\n\n\t\t// usage\n\t\t// updateRange(a, b, x, 0, 0, seg.tree.length/2)\n\t\tpublic void updateRange(int a, int b, int x, int k, int l, int r) {\n\t\t\tif(r <= a || b < l) return;\n\t\t\tif(a <= l && r-1 <= b) tree[k] = x;\n\t\t\telse {\n\t\t\t\tif(tree[k] >= 0) {\n\t\t\t\t\ttree[k*2+1] = tree[k];\n\t\t\t\t\ttree[k*2+2] = tree[k];\n\t\t\t\t\ttree[k] = -1;\n\t\t\t\t}\n\t\t\t\tupdateRange(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\t\tupdateRange(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\t}\n\t\t}\n\n\t\t// usage\n\t\t// query(a, b, 0, 0, seg.tree.length/2)\n\t\tpublic int query(int a, int b, int k, int l, int r) {\n\t\t\t// System.out.println(a+\" \"+b+\" \"+k+\" \"+l+\" \"+r);\n\t\t\tif(r <= a || b < l) return Integer.MAX_VALUE;\n\t\t\tif(a <= l && r-1 <= b) return tree[k];\n\t\t\telse {\n\t\t\t\tint vl = query(a, b, k*2+1, l, (l+r)/2);\n\t\t\t\tint vr = query(a, b, k*2+2, (l+r)/2, r);\n\t\t\t\treturn Math.min(vl, vr);\n\t\t\t}\n\t\t}\n\n\t\tpublic void print() {\n\t\t\tint d = 2;\n\t\t\tfor(int i=0; i<tree.length-1; i++) {\n\t\t\t\tSystem.out.print(tree[i]+\" \");\n\t\t\t\tif(i == d-2){\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\td *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint n = r.nextInt();\n\t\tint q = r.nextInt();\n\t\tSegmentTree seg = new SegmentTree(n);\n\t\tfor(int k=0; k<q; k++) {\n\t\t\tint c = r.nextInt();\n\t\t\tif(c == 0) {\n\t\t\t\tint s = r.nextInt();\n\t\t\t\tint t = r.nextInt();\n\t\t\t\tint x = r.nextInt();\n\t\t\t\tseg.updateRange(s, t, x, 0, 0, seg.tree.length/2);\n\t\t\t\t// seg.print();\n\t\t\t} else {\n\t\t\t\tint i = r.nextInt();\n\t\t\t\tSystem.out.println(seg.find(i));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package ????????????;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, false);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.function.IntBinaryOperator;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder out = new StringBuilder();\n        PrintWriter pw = new PrintWriter(System.out);\n        final int N = nextInt(sc);\n        final int Q = nextInt(sc);\n        // Integer[] a = new Integer[N];\n        // Arrays.fill(a, Integer.MAX_VALUE);\n        IntDualSegmentTree t = new IntDualSegmentTree(N, Integer.MAX_VALUE, -1, (u, v) -> v, (u, v) -> v);\n        for (int j = 0; j < Q; j++) {\n            int q = nextInt(sc);\n            switch (q) {\n                case 0:\n                    int l = nextInt(sc);\n                    int r = nextInt(sc) + 1;\n                    int x = nextInt(sc);\n                    t.apply(l, r, x);\n                    break;\n                case 1:\n                    int i = nextInt(sc);\n                    out.append(t.get(i)).append('\\n');\n                    break;\n                default:\n                    break;\n            }\n        }\n        sc.close();\n        pw.write(out.toString());\n        pw.flush();\n        pw.close();\n    }\n\n    public static int nextInt(Scanner sc) {\n        return Integer.parseInt(sc.next());\n    }\n    public static long nextLong(Scanner sc) {\n        return Long.parseLong(sc.next());\n    }\n}\n\n/**\n * 双対セグ木．長さ N の列に対して区間作用と一点取得がそれぞれ O(log N) で可能．\n * 遅延セグ木から不必要な処理を除いて簡略化したものなので，定数倍はこっちの方が軽い．\n * \n * verified:\n *  - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n *  - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_E\n */\nclass IntDualSegmentTree {\n    \n    /**\n     * データを格納する配列．一点取得のみなので，葉部分しか持たなくてよい．\n     */\n    final int[] Dat;\n\n    /**\n     * 遅延配列\n     */\n    final int[] Laz;\n\n    /**\n     * 葉の個数\n     */\n    final int N;\n\n    /**\n     * 元々の列のサイズ．配列外参照を検知するために用いる．\n     */\n    final int L;\n\n    /**\n     * 作用素をマージする二項演算 H の単位元\n     */\n    final int E1;\n\n    /**\n     * 作用関数\n     */\n    final IntBinaryOperator G;\n\n    /**\n     * 作用素をマージする二項演算\n     */\n    final IntBinaryOperator H;\n\n    /**\n     * ボトムアップに区間を列挙する際にこのスタックに区間を積み，\n     * トップダウンに遅延配列から伝播する際にこのスタックから区間を pop していく．\n     */\n    final int[] Stack = new int[64];\n    \n    /**\n     * 配列を用いない初期化．O(N)\n     * @param n 列の長さ\n     * @param initialValue 列の初期値\n     * @param e1 作用素をマージする二項演算の単位元\n     * @param g 作用\n     * @param h 作用素をマージする二項演算\n     */\n    public IntDualSegmentTree(int n, int initialValue, int e1, IntBinaryOperator g, IntBinaryOperator h) {\n        this.E1 = e1;\n        this.G = g;\n        this.H = h;\n        int k = 1;\n        while (k < n) k <<= 1;\n        this.N = k;\n        this.L = n;\n        this.Dat = new int[k];\n        this.Laz = new int[k << 1];\n        Arrays.fill(Dat, initialValue);\n        Arrays.fill(Laz, e1);\n    }\n\n    /**\n     * 配列を用いて初期化．O(N)\n     * @param src 列 (初期データ)\n     * @param e1 作用素をマージする二項演算の単位元\n     * @param g 作用\n     * @param h 作用素をマージする二項演算\n     */\n    public IntDualSegmentTree(int[] src, int e1, IntBinaryOperator g, IntBinaryOperator h) {\n        this.E1 = e1;\n        this.G = g;\n        this.H = h;\n        int n = src.length;\n        int k = 1;\n        while (k < n) k <<= 1;\n        this.N = k;\n        this.L = n;\n        this.Dat = new int[k];\n        this.Laz = new int[k << 1];\n        System.arraycopy(src, 0, Dat, 0, src.length);\n        Arrays.fill(Laz, e1);\n    }\n\n    /**\n     * 半開区間 [l, r) に作用素 v を作用させる．O(log N)\n     * @param l 半開区間の左端 (含まれる)\n     * @param r 半開区間の右端 (含まれない)\n     * @param v 作用素\n     */\n    public void apply(int l, int r, int v) {\n        if (l < 0 || l > L || r < 0 || r > L) {\n            throw new IndexOutOfBoundsException(\n                String.format(\"Segment [%d, %d) is not in [%d, %d)\", l, r, 0, L)\n            );\n        }\n        if (l >= r) return;\n        updown(l, r);\n        l += N; r += N;\n        for (; l < r; l >>= 1, r >>= 1) {\n            if ((l & 1) != 0) {Laz[l] = H.applyAsInt(Laz[l], v); l++;}\n            if ((r & 1) != 0) {r--; Laz[r] = H.applyAsInt(Laz[r], v);}\n        }\n    }\n\n    /**\n     * 一点取得．O(log N)\n     * @param i index (0-indexed)\n     * @return i 番目の値\n     */\n    public int get(int i) {\n        if (i < 0 || i >= L) {\n            throw new IndexOutOfBoundsException(\n                String.format(\"Index %d is not in [%d, %d)\", i, 0, L)\n            );\n        }\n        int k = 1;\n        int l = 0, r = N;\n        while (k < N) {\n            propagate(k);\n            int kl = k << 1 | 0;\n            int kr = k << 1 | 1;\n            int m = (l + r) >> 1;\n            if (m > i) {r = m; k = kl;} \n            else {l = m; k = kr;}\n        }\n        propagate(k);\n        return Dat[k - N];\n    }\n\n    /**\n     * [l, r) と共通部分を持つ区間をボトムアップに列挙 (up) してから，\n     * トップダウンに列挙区間の遅延値を伝播する (down)\n     * @param l 半開区間の左端 (含まれる)\n     * @param r 半開区間の右端 (含まれない)\n     * @return 列挙した区間の数\n     */\n    void updown(int l, int r) {\n        int i = 0;\n        int kl = l + N, kr = r + N;\n        for (int x = kl / (kl & -kl) >> 1, y = kr / (kr & -kr) >> 1; 0 < kl && kl < kr; kl >>= 1, kr >>= 1) {\n            if (kl <= x) Stack[i++] = kl;\n            if (kr <= y) Stack[i++] = kr;\n        }\n        for (; kl > 0; kl >>= 1) Stack[i++] = kl;\n        while (i > 0) propagate(Stack[--i]);\n    }\n\n    /**\n     * 遅延値を子に伝播する\n     * @param k 木上の index (1-indexed)\n     */\n    void propagate(int k) {\n        int lz = Laz[k];\n        if (lz != E1) {\n            if (k < N) {\n                int l = k << 1 | 0, r = k << 1 | 1;\n                Laz[l] = H.applyAsInt(Laz[l], lz);\n                Laz[r] = H.applyAsInt(Laz[r], lz);\n            } else {\n                Dat[k - N] = G.applyAsInt(Dat[k - N], lz);\n            }\n            Laz[k] = E1;\n        }\n    }\n\n    /***************************** DEBUG *********************************/\n\n    // @Override\n    // public String toString() {\n    //     return toString(1, 0);\n    // }\n\n    // String toString(int k, int space) {\n    //     String s = \"\";\n    //     if (k < N) s += toString(k << 1 | 1, space + 6) + \"\\n\";\n    //     if (k < N) {\n    //         s += \" \".repeat(space) + Laz[k];\n    //     } else {\n    //         s += \" \".repeat(space) + Dat[k - N] + \"/\" + Laz[k];\n    //     }\n    //     if (k < N) s += \"\\n\" + toString(k << 1 | 0, space + 6);\n    //     return s;\n    // }\n\n    /******* Usage *******/\n    \n    public static void main(String[] args) {\n        int[] a = {0, 1, 2, 3, 4, 5};\n        IntDualSegmentTree t1 = new IntDualSegmentTree(a, 0, (u, v) -> u + v, (u, v) -> u + v); // 区間加算クエリ\n        System.out.println(t1);\n        t1.apply(0, 3, 10);\n        System.out.println(t1);\n        System.out.printf(\"\\na[2] = %d \\n\\n\", t1.get(2));\n        t1.apply(2, 4, 10);\n        System.out.println(t1);\n        System.out.printf(\"\\na[2] = %d \\n\\n\", t1.get(2));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, false);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic NodeSegmentTree[] V;\n\tstatic int N;\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tN = 1;\n\t\twhile(N < n) {\n\t\t\tN *= 2;\n\t\t}\n\t\tN = N * 2 - 1;\n\t\tif(N == 1) {\n\t\t\tN = 3;\n\t\t}\n\n\t\tV = new NodeSegmentTree[N];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tV[i] = new NodeSegmentTree(i);\n\t\t}\n\n\t\tfor(int i=N/2 - 1; i>=0; i--) {\n\t\t\tV[i].setSegment();\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tint cmd = sc.nextInt();\n\n\t\t\tif(cmd == 0) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tV[0].updateRangeValue(x, s, t);\n\t\t\t} else {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tsb.append(V[0].find(x));\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.print(sb);\n\n\t}\n\n\tstatic class NodeSegmentTree {\n\t\tint seg_left;\n\t\tint seg_right;\n\t\tint id;\n\t\tint value = Integer.MAX_VALUE;\n\t\tint lazy = Integer.MAX_VALUE;\n\t\t//left = 2 * id + 1\n\t\t//right = 2 * id + 2\n\t\t//parent = (id - 1) / 2\n\t\t//array[i] -> V[N/2 + i]\n\n\t\tNodeSegmentTree(int id) {\n\t\t\tthis.id = id;\n\t\t\tthis.seg_left = id - N/2;\n\t\t\tthis.seg_right = id - N/2;\n\t\t}\n\n\t\tvoid setSegment() {\n\t\t\tseg_left = V[2 * id + 1].seg_left;\n\t\t\tseg_right = V[2 * id + 2].seg_right;\n\t\t}\n\n\t\tvoid updateRangeValue(int value, int l, int r) {\n\t\t\tif(l <= seg_left && r >= seg_right) {\n\t\t\t\tlazy = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(l > seg_right || r < seg_left) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(lazy != -1) {\n\t\t\t\tV[2 * id + 1].lazy = lazy;\n\t\t\t\tV[2 * id + 2].lazy = lazy;\n\t\t\t\tlazy = -1;\n\t\t\t}\n\t\t\tV[2 * id + 1].updateRangeValue(value, l, r);\n\t\t\tV[2 * id + 2].updateRangeValue(value, l, r);\n\t\t}\n\n\t\tpublic int find(int idx) {\n\t\t\tif(id >= N/2) {\n\t\t\t\tif(lazy != -1) {\n\t\t\t\t\tvalue = lazy;\n\t\t\t\t\tlazy = -1;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\tif(lazy != -1) {\n\t\t\t\t\tV[2 * id + 1].lazy = lazy;\n\t\t\t\t\tV[2 * id + 2].lazy = lazy;\n\t\t\t\t\tlazy = -1;\n\t\t\t\t}\n\t\t\t\tif(idx <= (seg_left + seg_right) / 2) {\n\t\t\t\t\treturn V[2 * id + 1].find(idx);\n\t\t\t\t} else {\n\t\t\t\t\treturn V[2 * id + 2].find(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\n//Unordered Pair\nclass UP<A, B> {\n\tA a;\n\tB b;\n\n\tUP(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic <A, B> UP<A, B> make(A a, B b) {\n\t\treturn new UP<A, B>(a, b);\n\t}\n\n\tpublic UP<A, B> clone() {\n\t\treturn make(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UP))\n\t\t\treturn false;\n\t\tUP<?, ?> p = (UP<?, ?>) o;\n\t\tboolean aok = a == null ? p.a == null : a.equals(p.a);\n\t\tboolean bok = b == null ? p.b == null : b.equals(p.b);\n\t\treturn aok && bok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\n\t}\n}\n\ninterface F1<A> {\n\tA f();\n}\n\ninterface F2<A, B> {\n\tB f(A a);\n}\n\ninterface F3<A, B, C> {\n\tC f(A a, B b);\n}\n\ninterface F4<A, B, C, D> {\n\tD f(A a, B b, C c);\n}\n\n// util\nclass U {\n\tstatic <A> ArrayList<A> make(int n, F2<Integer, A> maker) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres.add(maker.f(i));\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> filter(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (A a : as) {\n\t\t\tif (pred.f(a))\n\t\t\t\tres.add(a);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> map(ArrayList<A> as, F2<A, A> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i)));\n\t}\n\n\tstatic <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {\n\t\treturn make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));\n\t}\n\n\tstatic <A extends Comparable<A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n}\n\n//Lazy Segment Tree\nclass LST<A, Op> {\n\t// 0: unused, 1: root\n\tprivate ArrayList<A> dat;\n\tprivate ArrayList<Op> lazy;\n\tprivate F3<A, A, A> merger;\n\tprivate F3<A, Op, A> applier;\n\tprivate F3<Op, Op, Op> opMerger;\n\tprivate F3<Op, Integer, Op> multiplier;\n\tprivate A e;\n\tprivate Op id;\n\tprivate int h;\n\tprivate int n;\n\n\tLST(int num, F3<A, A, A> merger, F3<A, Op, A> applier, F3<Op, Op, Op> opMerger, A e, Op id) {\n\t\tthis(num, merger, applier, opMerger, (a, n) -> a, e, id);\n\t}\n\n\tLST(int num, F3<A, A, A> merger, F3<A, Op, A> applier, F3<Op, Op, Op> opMerger, F3<Op, Integer, Op> multiplier,\n\t\t\tA e, Op id) {\n\t\tthis.merger = merger;\n\t\tthis.applier = applier;\n\t\tthis.opMerger = opMerger;\n\t\tthis.multiplier = multiplier;\n\t\tthis.e = e;\n\t\tthis.id = id;\n\t\th = 0;\n\t\twhile ((1 << h) < num)\n\t\t\th++;\n\t\tn = 1 << h;\n\t\tint size = n << 1;\n\t\tdat = U.make(size, (i) -> e);\n\t\tlazy = U.make(size, (i) -> id);\n\t}\n\n\tvoid init(A[] as) {\n\t\tfor (int i = 0; i < n << 1; i++) {\n\t\t\tlazy.set(i, id);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdat.set(n + i, as[i]);\n\t\t}\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tdat.set(i, merger.f(dat.get(i << 1), dat.get(i << 1 | 1)));\n\t\t}\n\t}\n\n\tA get(int i) {\n\t\treturn query(i, i + 1);\n\t}\n\n\tvoid set(int i, A a) {\n\t\tquery(i, i + 1);\n\t\ti += n;\n\t\tdat.set(i, a);\n\t\twhile ((i >>= 1) > 0) {\n\t\t\tdat.set(i, merger.f(dat.get(i << 1), dat.get(i << 1 | 1)));\n\t\t}\n\t}\n\n\tvoid apply(int from, int until, Op o) {\n\t\tapplyImpl(from, until, 1, 0, n, o);\n\t}\n\n\tA query(int from, int until) {\n\t\treturn queryImpl(from, until, 1, 0, n);\n\t}\n\n\tint size() {\n\t\treturn n;\n\t}\n\n\tprivate void eval(int k, int len) {\n\t\tif (k < n) {\n\t\t\tlazy.set(k << 1, opMerger.f(lazy.get(k << 1), lazy.get(k)));\n\t\t\tlazy.set(k << 1 | 1, opMerger.f(lazy.get(k << 1 | 1), lazy.get(k)));\n\t\t}\n\t\tdat.set(k, applier.f(dat.get(k), multiplier.f(lazy.get(k), len)));\n\t\tlazy.set(k, id);\n\t}\n\n\tprivate A queryImpl(int a, int b, int k, int l, int r) {\n\t\teval(k, r - l);\n\t\tif (r <= a || b <= l)\n\t\t\treturn e;\n\t\tif (a <= l && r <= b)\n\t\t\treturn dat.get(k);\n\t\tA al = queryImpl(a, b, k << 1, l, l + r >> 1);\n\t\tA ar = queryImpl(a, b, k << 1 | 1, l + r >> 1, r);\n\t\treturn merger.f(al, ar);\n\t}\n\n\tprivate void applyImpl(int a, int b, int k, int l, int r, Op o) {\n\t\tif (r <= a || b <= l)\n\t\t\treturn;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy.set(k, opMerger.f(lazy.get(k), o));\n\t\t\teval(k, r - l);\n\t\t\treturn;\n\t\t}\n\t\tapplyImpl(a, b, k << 1, l, l + r >> 1, o);\n\t\tapplyImpl(a, b, k << 1 | 1, l + r >> 1, r, o);\n\t\tdat.set(k, merger.f(dat.get(k << 1), dat.get(k << 1 | 1)));\n\t}\n}\n\npublic class Main {\n\n\tprivate static void solve() {\n\t\tint n = nei();\n\t\tint q = nei();\n\t\tLST<Integer, Integer> lst = new LST<Integer, Integer>(n, (a, b) -> U.min(a, b), (a, f) -> f == null ? a : f, (\n\t\t\t\tf, g) -> g == null ? f : g, Integer.MAX_VALUE, null);\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (nei() == 0) {\n\t\t\t\tint s = nei();\n\t\t\t\tint t = nei();\n\t\t\t\tint x = nei();\n\t\t\t\tlst.apply(s, t + 1, x);\n\t\t\t} else {\n\t\t\t\tout(lst.get(nei()));\n\t\t\t}\n\t\t}\n\t}\n\n\t// returns (x, y, d) s.t. ax + by = d\n\tstatic long[] exgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn new long[] { x * sa, y * sb, a };\n\t}\n\n\tstatic int[] lis(int[] s) {\n\t\tint n = s.length;\n\t\tint[] dp = new int[n];\n\t\tint[] ids = new int[n];\n\t\tint[] pids = new int[n];\n\t\tdp[0] = s[0];\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint idx = bs(s[i], dp, 0, len);\n\t\t\tdp[idx] = s[i];\n\t\t\tids[idx] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tpids[i] = ids[idx - 1];\n\t\t}\n\t\tint[] lis = new int[len];\n\t\tlis[len - 1] = s[lidx];\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tlis[i] = s[lidx];\n\t\t\tlidx = pids[lidx];\n\t\t}\n\t\treturn lis;\n\t}\n\n\tstatic int bs(int a, int[] as, int from, int num) {\n\t\tint min = from;\n\t\tint max = from + num - 1;\n\t\twhile (min < max) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tif (as[mid] < a)\n\t\t\t\tmin = mid + 1;\n\t\t\telse if (as[mid] > a)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\treturn mid;\n\t\t}\n\t\treturn as[min] < a ? min + 1 : min;\n\t}\n\n\tstatic int gcd(int x, int y) {\n\t\tx = (x ^ x >> 31) - (x >> 31);\n\t\ty = (y ^ y >> 31) - (y >> 31);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tint z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long gcd(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tlong z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long modinv(long a, long mod) {\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\n\tstatic long modpow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif ((b & 1) == 0) {\n\t\t\tlong sqrt = modpow(a, b >> 1, mod);\n\t\t\treturn sqrt * sqrt % mod;\n\t\t}\n\t\treturn a * modpow(a, b - 1, mod) % mod;\n\t}\n\n\tstatic long fact(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modfact(long n, long mod) {\n\t\tif (n <= 1)\n\t\t\treturn 1 % mod;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\t// returns facts([0]) and invfacts([1])\n\tstatic long[][] enumfacts(int n, long mod) {\n\t\tint num = n + 10;\n\t\tlong[][] res = new long[2][num];\n\t\tlong[] facts = res[0];\n\t\tlong[] invfacts = res[1];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (i <= 1) {\n\t\t\t\tfacts[i] = 1;\n\t\t\t\tinvfacts[i] = 1;\n\t\t\t} else {\n\t\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\t\tinvfacts[i] = modinv(facts[i], mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modcomb(long n, long m, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tif (m > n - m) {\n\t\t\tm = n - m;\n\t\t}\n\t\tlong numer = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tnumer = numer * (n - i) % mod;\n\t\t}\n\t\tlong denom = modfact(m, mod);\n\t\treturn numer * modinv(denom, mod) % mod;\n\t}\n\n\tstatic long modcomb(int n, int m, long[] facts, long[] invfacts, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tlong numer = facts[n];\n\t\tlong denom = invfacts[m] * invfacts[n - m] % mod;\n\t\treturn numer * denom % mod;\n\t}\n\n\t// res[i][0]: prime factor, res[i][1]: exponent\n\tstatic int[][] factorize(int n) {\n\t\tint[][] pfs = new int[32][2];\n\t\tint num = 0;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tpfs[num][0] = i;\n\t\t\t\tpfs[num][1] = count;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tpfs[num][0] = n;\n\t\t\tpfs[num][1] = 1;\n\t\t\tnum++;\n\t\t}\n\t\tint[][] res = new int[num][2];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tres[i][0] = pfs[i][0];\n\t\t\tres[i][1] = pfs[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long lcm(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\treturn x / gcd(x, y) * y;\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic double clamp(double a, double min, double max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tint[] arr;\n\tint[] rep;\n\tboolean[] edge;\n\tint d;\n\n\tint get(int i) {\n\t\tif (!edge[i / d]) {\n\t\t\treturn rep[i / d];\n\t\t} else {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\n\tvoid modify(int src, int dst, int x) {\n\t\tfor (int i = src / d + 1; i <= dst / d - 1; ++i) {\n\t\t\tedge[i] = false;\n\t\t\trep[i] = x;\n\t\t}\n\t\tif (!edge[src / d]) {\n\t\t\tfor (int i = src / d * d; i < (src / d + 1) * d; ++i) {\n\t\t\t\tarr[i] = rep[src / d];\n\t\t\t}\n\t\t}\n\t\tif (!edge[dst / d]) {\n\t\t\tfor (int i = dst / d * d; i < (dst / d + 1) * d; ++i) {\n\t\t\t\tarr[i] = rep[dst / d];\n\t\t\t}\n\t\t}\n\t\tedge[src / d] = true;\n\t\tedge[dst / d] = true;\n\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\tarr[i] = x;\n\t\t}\n\t\tfor (int i = Math.max(src, dst / d * d); i <= dst; ++i) {\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\td = (int) Math.sqrt(n);\n\t\tarr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tedge = new boolean[n / d + 1];\n\t\trep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tSystem.out.println(get(sc.nextInt()));\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tmodify(src, dst, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i <= (dst - 1) / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package ????????????;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, (1 << 31) - 1);\n\t\tboolean[] edge = new boolean[(n + d - 1) / d];\n\t\tint[] rep = new int[(n + d - 1) / d];\n\t\tArrays.fill(rep, (1 << 31) - 1);\n\t\tArrays.fill(edge, false);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 1; i < dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint d = (int) Math.sqrt(n);\n\t\tint[] arr = new int[n];\n\t\tArrays.fill(arr, Integer.MAX_VALUE);\n\t\tboolean[] edge = new boolean[n / d + 1];\n\t\tint[] rep = new int[n / d + 1];\n\t\tArrays.fill(rep, Integer.MAX_VALUE);\n\t\tArrays.fill(edge, true);\n\t\twhile (q-- > 0) {\n\t\t\tint t = sc.nextInt();\n\t\t\tif (t == 1) {\n\t\t\t\tint i = sc.nextInt();\n\t\t\t\tif (!edge[i / d]) {\n\t\t\t\t\tSystem.out.println(rep[i / d]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint src = sc.nextInt();\n\t\t\t\tint dst = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tfor (int i = src; i <= Math.min((src / d + 1) * d - 1, dst); ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = src / d + 2; i <= dst / d; ++i) {\n\t\t\t\t\tedge[i] = false;\n\t\t\t\t\trep[i] = x;\n\t\t\t\t}\n\t\t\t\tfor (int i = dst / d * d + 1; i <= dst; ++i) {\n\t\t\t\t\tedge[i / d] = true;\n\t\t\t\t\tarr[i] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int INF = Integer.MAX_VALUE;\n\tstatic int n = 1;\n\tstatic int[] D;\n\tstatic int[] M;\n\tstatic int[] arr;\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n_num = sc.nextInt();\n\t\tint op_num = sc.nextInt();\n\t\tinit(n_num,op_num);\n\t\t\n\t\tint i = 0;\n\t\tStreamTokenizer in = new StreamTokenizer(new BufferedReader (\n\t\t\t\tnew InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tint mark =0;\n\t\twhile(in.nextToken() != StreamTokenizer.TT_EOF && i <=op_num) {\n\t\t\tint token = (int)in.nval;\n\t\t\tin.nextToken();\n\t\t\tif(token ==0) {\n\t\t\t\tint x = (int)in.nval;\n\t\t\t\tin.nextToken();\n\t\t\t\tint y = (int)in.nval;\n\t\t\t\tin.nextToken();\n\t\t\t\tint z = (int)in.nval;\n\t\t\t\t//System.out.println(x+y+z);\n\t\t\t\tarr[i]= z;\n\t\t\t\tupdate(x,y+1,0,0,n,mark);\n\t\t\t}else {\n\t\t\t\tint k = (int)in.nval;\n\t\t\t\t//System.out.println(k);\n\t\t\t\tint result = find(k+n-1,n,M,arr);\n\t\t\t\tout.println(result);\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t\ti++;\n\t\t\tmark++;\n\t\t}\n\t\t\n\t\t\n\t}\n\tprivate static int find(int n1, int n2, int[] m2, int[] arr2) {\n\t\t// TODO Auto-generated method stub\n\t\tint max = n1;\n\t\tfor(int i=0;n1>0;i++) {\n\t\t\tn1 = (n1 - 1)/2;\n\t\t\tif(M[max]<M[n1])\n\t\t\t\tmax = n1;\n\t\t}\n\t\tint temp;\n\t\tif(M[max] == -1)\n\t\t\ttemp = INF;\n\t\telse \n\t\t\ttemp = arr[M[max]];\n\t\t\n\t\treturn temp;\n\t}\n\tprivate static void update(int a, int b, int k, int l, int r, int mark) {\n\t\t// TODO Auto-generated method stub\n\t\tif(r<=a || b<=l)\n\t\t\treturn;\n\t\tif(a<=l && r<=b) {\n\t\t\tM[k] = mark;\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,2*k+1,l,(l+r)/2,mark);\n\t\tupdate(a,b,k*2+2,(l+r)/2,r,mark);\n\t}\n\tpublic static void init(int N,int op) {\n\t\tn = 1;\n\t\twhile(n<N)\n\t\t\tn*=2;\n\t\tD = new int[n*2 - 1];\n\t\tM = new int[n*2 - 1];\n\t\tarr = new int[op];\n\t\tfor(int i=0;i<2*n-1;i++)\n\t\t{\n\t\t\tD[i] = INF;\n\t\t\tM[i] = -1;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeMap;\n\n// Java8\npublic class Main\n{\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\n\t\tnew Main().run();\n\t}\n\n\tvoid run()\n\t{\n\t\tnint();\n\t\tint q = nint();\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\tmap.put(-1, Integer.MAX_VALUE);\n\t\twhile(q-- > 0)\n\t\t{\n\t\t\tint cmd = nint();\n\t\t\tif(cmd == 0)\n\t\t\t{\n\t\t\t\tint s = nint();\n\t\t\t\tint t = nint();\n\t\t\t\tint x = nint();\n\t\t\t\tInteger rightValue = map.floorEntry(t+1).getValue();\n\t\t\t\tmap.subMap(s, t+1).clear();\n\t\t\t\tmap.put(s, x);\n\t\t\t\tmap.put(t+1, rightValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint i = nint();\n\t\t\t\tSystem.out.println(map.floorEntry(i).getValue());\n\t\t\t}\n\t\t}\n\t}\n\n\tint nint()\n\t{\n\t\treturn Integer.parseInt(sc.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int INF = Integer.MAX_VALUE;\n\tstatic int n = 1;\n\tstatic int[] D;\n\tstatic int[] M;\n\tstatic int[] arr;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n1 = sc.nextInt();\n\t\tint op_num = sc.nextInt();\n\t\tString[] op = new String[op_num+1];\n\t\tfor(int i=0;i<op.length;i++)\n\t\t\top[i]=sc.nextLine();\n\t\t\n\t\tinit(n1);\n\t\tarr = new int[op_num];\n\t\t\n\t\tfor(int i=1,mark=0,i1=0;i<=op_num;i++) {\n\t\t\tString[] Split = op[i].split(\" \");\n\t\t\tint x,y,z;\n\t\t\tif(Integer.parseInt(Split[0]) == 0) {\n\t\t\t\tx = Integer.parseInt(Split[1]);\n\t\t\t\ty = Integer.parseInt(Split[2]);\n\t\t\t\tz = Integer.parseInt(Split[3]);\n\t\t\t\tarr[i1] = z;\n\t\t\t\tupdate(x,y+1,0,0,n,mark);\n\t\t\t}else {\n\t\t\t\tx = Integer.parseInt(Split[1]);\n\t\t\t\tint result = find(x+n-1,n);\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t\ti1++;\n\t\t\tmark++;\n\t\t}\n\t\t\n\t\t\n\t\t/*System.out.println(\"M[]:\");\n\t\tfor(int i=0;i<M.length;i++)\n\t\t\tSystem.out.print(M[i]+\" \");\n\t\tSystem.out.println(n);\n\t\tSystem.out.println(\"arr[]:\");\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");*/\n\t\t\n\t\t\n\t}\n\n\tprivate static int find(int n1, int n2) {\n\t\t// TODO Auto-generated method stub\n\t\tint max = n1;\n\t\tfor(int i=0;n1>0;i++) {\n\t\t\tn1 = (n1-1)/2;\n\t\t\tif(M[max]<M[n1])\n\t\t\t\tmax = n1;\n\t\t}\n\t\tint temp;\n\t\tif(M[max] == -1)\n\t\t\ttemp = INF;\n\t\telse\n\t\t\ttemp = arr[M[max]];\n\t\t\n\t\treturn temp;\n\t}\n\n\tpublic static void update(int a, int b, int k, int l, int r, int mark) {\n\t\t// TODO Auto-generated method stub\n\t\t/*if(r<=a||b<=l)\n\t\t\treturn;\n\t\tif(a<=l && r<=b) {\n\t\t\tM[k] = mark;\n\t\t\treturn;\n\t\t}*/\n\t\tif(r<=a || b<=l)\n\t\t\treturn;\n\t\tif(a<=l && r<=b) {\n\t\t\tM[k] = mark;\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,2*k+1,l,(l+r)/2,mark);\n\t\tupdate(a,b,2*k+2,(l+r)/2,r,mark);\n\t}\n\n\tpublic static void init(int N) {\n\t\t// TODO Auto-generated method stub\n\t\tn = 1;\n\t\twhile(n<N)\n\t\t\tn*=2;\n\t\tD = new int[n*2-1];\n\t\tM = new int[n*2-1];\n\t\tfor(int i=0;i<n*2-1;i++) {\n\t\t\tD[i] = INF;\n\t\t\tM[i] = -1;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\n\nclass Main {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static RUQ d = new RUQ(100005, (1 << 31) - 1);\n    static int n, q;\n    static int com;\n    static int indx;\n    static int s, t, x;\n    \n    public static void main(String[] args) {\n        n = sc.nextInt();\n        q = sc.nextInt();\n        \n        for (int i = 0; i < q; i++) {\n\n            com = sc.nextInt();\n            if (com == 0) {\n\n                s = sc.nextInt();\n                t = sc.nextInt();\n                x = sc.nextInt();\n                d.update(s, t + 1, x);\n            }\n            else {\n                indx = sc.nextInt();\n                out.println(d.query(indx, indx + 1));\n            }\n        }\n        \n        out.flush();\n    }\n}\n\nclass RUQ extends LazySqrtDecomposition<Integer> {\n\n    public RUQ(int n, int e) {\n        super(n, e);\n    }\n    \n    @Override\n    protected Integer f(Integer x, Integer y) {\n        return y;\n    }\n    \n    @Override\n    protected Integer g(Integer x, Integer y, int t) {\n        return y;\n    }\n    \n    @Override\n    protected Integer h(Integer x, Integer y) {\n        return y;\n    }\n\n}\n\n/**\n * @author ei1710\n * @version 1.00\n */\n\n//package toyama.ei1710.DataStructures;\n/**\n * モノイドを乗せられる平方分割の抽象クラス.<br>\n * operatorメソッドをオーバライドすることで二項演算を定義する<br>\n * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う\n *\n * 更新<br>\n * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>\n * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>\n *\n * クエリ<br>\n * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す\n * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する\n * すると、通常の平方分割と同じになる\n *\n */\nabstract class LazySqrtDecomposition<T> {\n    /** 生データ */\n    protected ArrayList<T> raw_data;\n    /** バケットごとに事前に演算した結果を保持 */\n    protected ArrayList<T> bucket;\n    /** バケット範囲に一様に作用させる値 */\n    protected ArrayList<T> lazy;\n    \n    /** lazyにデータはあるかな？ */\n    protected boolean[] lazy_flag;\n    /** 単位元 */\n    protected T e;\n    /** データ数 */\n    protected int N;\n\n    protected int sqrtN;\n\n    /** バケットの数 */\n    protected int K;\n    \n    /** 要素と要素の合成 */\n    abstract protected T f(T x, T y);\n\n    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */\n    abstract protected T g(T x, T y, int t);\n\n    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/\n    abstract protected T h(T x, T y);\n    \n    /** 単位元eを初期値として要素数nmembの平方分割 */\n    public LazySqrtDecomposition(int nmemb, T e) {\n        this.e = e;\n        N = nmemb;\n        sqrtN = 1;\n        while (sqrtN * sqrtN < N) sqrtN++;\n        \n        K = (N + sqrtN - 1) / sqrtN;\n        \n        raw_data = new ArrayList<T>(N);\n        bucket = new ArrayList<T>(K);\n        lazy = new ArrayList<T>(K);\n        lazy_flag = new boolean[K];\n        \n        build();\n    }\n    \n    private void build() {\n\n        for (int i = 0; i < N; i++) {\n            raw_data.add(e);\n        }\n\n        for (int i = 0; i < K; i++) {\n            bucket.add(e);\n            lazy.add(e);\n            lazy_flag[i] = false;\n        }\n    }\n    \n    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */\n    protected void eval(int k) {\n        \n        T x = e;\n        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {\n            if (lazy_flag[k]) {\n                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));\n            }\n            x = f(x, raw_data.get(i));\n        }\n        \n        lazy_flag[k] = false;\n        bucket.set(k, x);\n    }\n\n    \n    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */\n    public void update(int l, int r, T dat) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n\n        int bucket_l, bucket_r;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            \n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    lazy.set(i, h(lazy.get(i), dat));\n                }\n                else {\n                    lazy.set(i, dat);\n                }\n                lazy_flag[i] = true;\n            }\n            else {\n                eval(i);\n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    raw_data.set(j, g(raw_data.get(j), dat, 1));\n                }\n            }\n        }\n    }\n\n    /** [l, r)の区間クエリに答える O(sqrt(N)) */\n    public T query(int l, int r) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n        int bucket_l, bucket_r;\n        T x = e;\n        \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    x = f(x, g(bucket.get(i), lazy.get(i), 1));\n                }\n                else {\n                    x = f(x, bucket.get(i));\n                }\n            }\n            else {\n                eval(i);\n                \n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    x = f(x, raw_data.get(j));\n                }\n            }\n        }\n        return x;\n    }\n    \n    /** デバッグ情報の印字 */\n    public void debugPrint() {\n        \n        System.err.println(\"-lazy-\");\n        for (int i = 0; i < lazy.size(); i++) {\n            if (!lazy_flag[i]) {\n                System.err.print(\" --  \");\n            }\n            else {\n                System.err.print(lazy.get(i));\n                System.err.print(' ');\n            }\n        }\n        System.err.print('\\n');\n        \n        System.err.println(\"-bucket-\");\n        for (T p : bucket) {\n            System.err.print(p);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-raw_data-\");\n        for (T q : raw_data) {\n            System.err.print(q);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n\n        System.err.println(\"-other data-\");\n        System.err.printf(\"N: %d, sqrtN: %d, K: %d\\n\", N, sqrtN, K);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int N = 100005;\n    static int tree[];//start from 0, with all uncertain value\n    //data structure: tree from 0\n    //how to represent the tree node,\n    //node: the segment of the\n    public static void main(String[] args) {\n        int n,m;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        tree = new int[N];\n        for(int i = 0; i<N; i++){\n            tree[i] = -1;\n        }\n        //make entir tree-> get the max n fir ti 2^n\n        int nMax = 1;\n        n = n-1;\n        while(n>0){\n            n = n/2;\n            nMax = nMax<<1;\n        }\n        if(nMax==1) nMax = 2;\n        //start from 0\n        for(int i = 0; i<m; i++){\n            int temp = 0;//decide the type of operation\n            int x,y, val;\n            temp = in.nextInt();\n            if(temp==0){\n                x = in.nextInt();\n                y = in.nextInt();\n                val = in.nextInt();\n                update(x,y,val,0,nMax-1,0);\n                /*for(int j = 0;j <=2*nMax-2;j++){\n                    System.out.println(j+\": \"+tree[j]);\n                }*/\n            } else {\n                x = in.nextInt();\n                int res = find(x,x,0,nMax-1,0);\n                System.out.println(res);\n            }\n\n        }\n    }\n\n    private static int find(int x,int y, int left, int right,int nodeId) {\n        if(left>y || right<x) return -1;\n        else if(left<=x && right>=y && tree[nodeId]>=0){//search range > than,could be -1\n            return tree[nodeId];\n        } else{\n            int num1 = find(x,y,left,(left+right)/2,nodeId*2+1);\n            int num2 = find(x,y,(left+right)/2+1,right,nodeId*2+2);\n            return Math.max(num1,num2);\n        }\n\n    }\n    //update the value\n    //top down\n    private static void update(int x, int y, int val, int left, int right,int nodeId) {\n        //int mid = (left+right)/2;\n        //when to stop: there is only one node\n        //if(mid>right) return;\n        if(x>right||y<left) return;//out of range\n        //when to update\n        //how to view this tree\n        if(x<=left && y>=right){\n            tree[nodeId] = val;\n        }else{//update the tree//go left and right\n            if(tree[nodeId] >=0){\n                tree[nodeId*2+1] = tree[nodeId];\n                tree[nodeId*2+2] = tree[nodeId];\n                tree[nodeId] = -1;\n            }\n            update(x,y,val,left,(left+right)/2,nodeId*2+1);\n            update(x,y,val,(left+right)/2+1,right,nodeId*2+2);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Threading.Tasks;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new RangeUpdateSegTree<pair>(N, (x, y) => x.CompareTo(y) < 0 ? y : x, new pair(-1, int.MaxValue));\n        for (int i = 0; i < Q; i++)\n        {\n            if (cin.nextint == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, new pair(i, cin.nextint));\n            }\n            else\n            {\n                WriteLine(S[(cin.nextint)].s);\n            }\n        }\n    }\n\n}\n\n\nclass RangeUpdateSegTree<T>\n{\n    readonly int n;\n    int s, t;\n    T[] tr;\n    readonly Func<T, T, T> f;\n    readonly T exnum;\n\n    /// <summary>\n    ///  区間更新セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"f\">マージ関数</param>\n    /// <param name=\"ex\">単位元</param>\n    public RangeUpdateSegTree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f; exnum = ex; n = 1;\n        while (n < m) n <<= 1;\n        tr = new T[(n << 1) - 1];\n        for (int i = 0; i < tr.Length; i++) tr[i] = ex;\n    }\n    public T Look(int j) => tr[j + n - 1];\n    public T Peek() => tr[0];\n\n    /// <summary>\n    ///  j に対するクエリ\n    /// </summary>\n    /// <param name=\"j\"></param>\n    /// <returns></returns>\n    public T this[int j]\n    {\n        get\n        {\n            int i = j + n - 1;\n            var ret = tr[i];\n            while (i > 0) { i = i - 1 >> 1; ret = f(ret, tr[i]); }\n            return ret;\n        }\n    }\n    /// <summary>\n    /// [s, t] に対する更新\n    /// </summary>\n    /// <returns></returns>\n    public void Update(int s, int t, T x) { t++; this.s = s; this.t = t; update(0, 0, n, x); }\n    void update(int k, int l, int r, T x)\n    {\n        if (r <= s || t <= l) return;\n        if (s <= l && r <= t) tr[k] = f(tr[k], x);\n        else\n        {\n            update(k << 1 | 1, l, l + r >> 1, x);\n            update(k + 1 << 1, l + r >> 1, r, x);\n        }\n    }\n\n    public T[] Items\n    {\n        get\n        {\n            var ret = new T[n];\n            for (int i = 0; i < ret.Length; i++)\n            {\n                ret[i] = Look(i);\n            }\n            return ret;\n        }\n    }\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nclass Program\n{\n\t/*\n\n・概要\n\t遅延評価を行い、必要なタイミングで一気に値を更新するLazySegmentTree。\n\n\tcf. セグメントツリーとは\n\t「完全二分木（全ての葉の深さが等しい木）によって実装された、区間を扱うのに適したデータ構造\n\t区間に対する操作を対数時間 O(log N) で行える」\n\n・使用法\n\t1. 問題に合わせ、コンストラクタの引数を設定（ラムダ式を使えば良い）\n\t「更新クエリと回答クエリの組み合わせ」によって引数が全く変わってくるので注意。\n\n\t（cf.「RAQ（更新）+ RMQ（回答）」などの基本的組み合わせについては、最下部にテンプレートを用意\n\t　→コピペして使ってね）\n\n\t（e.g.「RAQ（更新）+ RMQ（回答）」の場合\n\t\tFunc<long, long, long> fx = (x1,x2) => x1 + x2;\n\t\tFunc<long, long, long> fa = (x,m) => x + m;\n\t\tFunc<long, long, long> fm = (m1,m2) => m1 + m2;\n\t\tFunc<long, long, long> fp = (m,n) => m * n;\n\t\tlong init = 0;\n\t\tlong lazyInit = 0;）\n\n\t2. LazySegmentTreeクラスのオブジェクトを作成\n\t（e.g. LazySegmentTree st = new LazySegmentTree(N);）\n\n\t2. セグメントツリーの初期化（元の配列を渡す）\n\t（e.g. st.Initialize(arr);）\n\n\t--- 以下は、どの問題でもやることは同じ（更新 or 回答） ---\n\n\t3. 適宜、更新クエリに応答（閉区間[s,t]について、更新クエリに答える）\n\t（e.g. st.Update(s,t,x);）\n\n\t4. 適宜、回答クエリに応答（閉区間[s,t]について、回答クエリに答える）\n\t（e.g. long ans = st.GetAnswer(s,t);）\n\n\t*/\n\n\t//Main\n\tstatic void Main(string[] args)\n\t{\n\t\t//出力準備（AutoFlushを切る）\n\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()){AutoFlush = false};\n\t\tConsole.SetOut(sw);\n\t\t//解答\n\t\tSolve();\n\t\t//出力終了\n\t\tConsole.Out.Flush();\n\t}\n\n\tstatic void Solve()\n\t{\n\t\t//読み込む\n\t\tstring[] S = Console.ReadLine().Split(' ');\n\t\t//要素数\n\t\tint N = int.Parse(S[0]);\n\t\t//クエリ数\n\t\tint Q = int.Parse(S[1]);\n\n\t\t//1. 問題に合わせ、コンストラクタの引数を設定（ラムダ式を使えば良い）\n\t\tFunc<long, long, long> fx = (x1,x2) => Math.Min(x1,x2);\n\t\tFunc<long, long, long> fa = (x,m) => m;\n\t\tFunc<long, long, long> fm = (m1,m2) => m2;\n\t\tFunc<long, long, long> fp = (m,n) => m;\n\t\tlong init = long.MaxValue;\n\t\tlong lazyInit = long.MaxValue;\n\n\t\t//2. LazySegmentTreeクラスのオブジェクトを作成（RAQ + RSQの場合の例）\n\t\t/*\n\t\t引数は順に、\n\t\t元の配列の要素数、関数4つ、二分木の初期値、遅延評価配列の初期値\n\t\t*/\n\t\tLazySegmentTree st = new LazySegmentTree(N,fx,fa,fm,fp,init,lazyInit);\n\n\t\t//初期状態の配列を作成\n\t\tlong[] arr = new long[N];\n\t\tfor(int i=0; i<N; i++){\n\t\t\tarr[i] = 2147483647;\n\t\t}\n\n\t\t//3. 配列の初期化（元の配列を渡す）\n\t\tst.Initialize(arr);\n\n\t\t//4.入力に応じて、更新 or 回答を行う\n\t\tfor(int i=0; i<Q; i++){\n\t\t\t//読み込む\n\t\t\tstring[] S1 = Console.ReadLine().Split(' ');\n\t\t\t//クエリの種類\n\t\t\tint com = int.Parse(S1[0]);\n\n\t\t\t//更新クエリの場合\n\t\t\tif(com == 0){\n\t\t\t\t//値の取得\n\t\t\t\tint s = int.Parse(S1[1]);\n\t\t\t\tint t = int.Parse(S1[2]);\n\t\t\t\tint x = int.Parse(S1[3]);\n\n\t\t\t\t//閉区間[s,t]について、更新クエリに答える\n\t\t\t\tst.Update(s,t,x);\n\t\t\t}\n\t\t\t//回答クエリの場合\n\t\t\telse{\n\t\t\t\t//値の取得\n\t\t\t\tint s = int.Parse(S1[1]);\n\n\t\t\t\t//閉区間[s,s]について、回答クエリに答える\n\t\t\t\tlong ans = st.GetAnswer(s,s);\n\t\t\t\t//出力\n\t\t\t\tConsole.WriteLine(ans);\n\t\t\t}\n\n\t\t\t/*cf. debug用の、完全二分木出力メソッド\n\t\t\tst.DebugWrite();\n\t\t\t*/\n\t\t}\n\t}\n}\n\n\n//セグメントツリーのクラス\n/*\n配列の中身はlong確としておく。\n*/\nclass LazySegmentTree\n{\n\t/*\n\tメンバー変数\n\t*/\n\t//更新や取得で使用するメソッド（long引数2つで、long戻り値）\n\tprivate Func<long, long, long> fx;\n\tprivate Func<long, long, long> fa;\n\tprivate Func<long, long, long> fm;\n\tprivate Func<long, long, long> fp;\n\t//完全二分木の初期値（単位元）\n\tprivate long INIT;\n\t//遅延評価配列の初期値（単位元）\n\tprivate long lazyINIT;\n\t//葉の数（※「葉」とは、末端（最下部）のノードのこと。元の配列の各値 or 初期値を保持）\n\tprivate int leaf;\n\t//完全二分木の配列\n\tprivate long[] tree;\n\t//遅延評価用の配列（一時的に値を保存）\n\tprivate long[] lazy;\n\n\t/*\n\t（１）初期化\n\t*/\n\n\t//コンストラクタ\n\t/*\n\t引数は要素数、関数4つ、二分木の初期値、遅延評価配列の初期値\n\t*/\n\tpublic LazySegmentTree(int len, Func<long, long, long> f1, Func<long, long, long> f2,\n\tFunc<long, long, long> f3, Func<long, long, long> f4, long ex, long em){\n\t\t//完全二分木の要素数はn^2である必要\n\t\t/*\n\t\tn^2 >= lenとなるような最小のn^2（=x）を求める\n\t\t*/\n\t\tint x = 1;\n\t\twhile(len > x){\n\t\t\tx *= 2;\n\t\t}\n\t\tthis.leaf = x;\n\n\t\t//関数の設定\n\t\tthis.fx = f1;\n\t\tthis.fa = f2;\n\t\tthis.fm = f3;\n\t\tthis.fp = f4;\n\n\t\t//初期値の設定\n\t\tthis.INIT = ex;\n\t\tthis.lazyINIT = em;\n\n\t\t//treeの初期化\n\t\t//treeの要素数は、葉の数 * 2 - 1となる\n\t\tthis.tree = new long[2*x-1];\n\t\tfor(int i=0; i<2*x-1; i++){\n\t\t\tthis.tree[i] = this.INIT;\n\t\t}\n\n\t\t//lazyの初期化\n\t\tthis.lazy = new long[2*x-1];\n\t\tfor(int i=0; i<2*x-1; i++){\n\t\t\tthis.lazy[i] = this.lazyINIT;\n\t\t}\n\t}\n\n\t//元の配列に合わせ、完全二分木を初期化するメソッド\n\t/*\n\t計算量はO(N)だが、この段階ではまだ回答クエリに応答できないので注意。\n\t*/\n\tpublic void Initialize(long[] arr){\n\t\t//元の配列の値をSet\n\t\tfor(int i=0; i<arr.Length; i++){\n\t\t\tthis.tree[i + this.leaf - 1] = arr[i];\n\t\t}\n\n\t\t//その上で、木構造をBuild\n\t\tfor(int k=this.leaf-2; k>=0; k--){\n\t\t\tthis.tree[k] = this.fx(this.tree[2*k+1],this.tree[2*k+2]);\n\t\t}\n\t}\n\n\t/*\n\t（２）値の更新と、遅延評価（更新クエリへの応答）\n\t*/\n\n\t//更新に使う遅延評価メソッド\n\t/*\n\t引数は、現在の対象要素currentと、問題となる区間の長さlen\n\t*/\n\tvoid Eval(int current, int len){\n\t\t//初期値の場合、更新は不要\n\t\tif(this.lazy[current] == this.lazyINIT){\n\t\t\treturn;\n\t\t}\n\n\t\t//葉でない場合には、子に伝播\n\t\tif(current < this.leaf - 1){\n\t\t\tthis.lazy[current*2+1] = this.fm(this.lazy[current*2+1],this.lazy[current]);\n\t\t\tthis.lazy[current*2+2] = this.fm(this.lazy[current*2+2],this.lazy[current]);\n\t\t}\n\n\t\t//自身を更新\n\t\t//cf. fp関数を使うのはここだけ\n\t\tthis.tree[current] = this.fa(this.tree[current],this.fp(this.lazy[current],len));\n\n\t\t//初期状態に戻す\n\t\tthis.lazy[current] = this.lazyINIT;\n\t}\n\n\n\t//値の追加用のメソッド\n\t/*\n\t引数は、対象たる閉区間[left, right]\n\t*/\n\tpublic void Update(int left, int right, long val){\n\t\t//実装の都合上、半開区間[left, right)に直す\n\t\tright ++;\n\n\t\t//更新を行う\n\t\tUpdateSub(left, right, val, 0, 0, this.leaf);\n\t}\n\n\t//値の追加用のサブメソッド\n\t/*\n\tleft, rightは、元々のクエリの対象区間\n\t（※葉の番号（元の配列のインデックス）であって、treeのインデックスではない）\n\tcurrentは、現在見ているノードのインデックス（現在回答しているノードくん）\n\ttL, tRは、currentノードくんが対象としている最小値区間（半開区間）の範囲\n\t（※tLとtRも葉の番号（treeのインデックスではない））\n\t*/\n\tvoid UpdateSub(int left, int right, long val, int current, int tL, int tR){\n\t\t//現在のノードを評価\n\t\tthis.Eval(current, tR-tL);\n\n\t\t//1. クエリが対象範囲外の場合、何もしない\n\t\tif(tR <= left || right <= tL){\n\t\t\treturn;\n\t\t}\n\t\t//2. 完全に範囲内に含んでいる場合、遅延配列に値を入れた後に評価\n\t\tif(left <= tL && tR <= right){\n\t\t\tthis.lazy[current] = this.fm(this.lazy[current],val);\n\t\t\tEval(current, tR-tL);\n\t\t}\n\t\t//3. 一部区間だけがカブっている場合（左右どちらかがはみ出ている）\n\t\telse{\n\t\t\t//左側の子の更新\n\t\t\tUpdateSub(left, right, val, current*2+1, tL, (tL+tR)/2);\n\t\t\t//右側の子の更新\n\t\t\tUpdateSub(left, right, val, current*2+2, (tL+tR)/2, tR);\n\t\t\t//現在のノードを更新\n\t\t\tthis.tree[current] = this.fx(this.tree[current*2+1],this.tree[current*2+2]);\n\t\t}\n\t}\n\n\t/*\n\t（３）値の取得（回答クエリへの応答）\n\t*/\n\n\t//閉区間[left, right]に於ける答えを返す\n\tpublic long GetAnswer(int left, int right){\n\t\t//実装の都合上、半開区間に直す\n\t\tright ++;\n\n\t\t//実装の都合上、サブタスクに分ける\n\t\t/*\n\t\tまずは根ノード（インデックス0）に問い合わせる。\n\t\t根ノードの対象範囲は、全ての葉（葉番号0 ~ leaf-1まで）\n\t\t*/\n\t\treturn GetAnswerSub(left, right, 0, 0, this.leaf);\n\t}\n\n\t//サブタスク（cf. 引数は、UpdateSubと同じ）\n\tlong GetAnswerSub(int left, int right, int current, int tL, int tR){\n\t\t//まず更新を行う\n\t\tthis.Eval(current, tR-1);\n\n\t\t//1. クエリが対象範囲外の場合、初期値を返す\n\t\tif(tR <= left || right <= tL){\n\t\t\treturn INIT;\n\t\t}\n\t\t//2. 完全に範囲内に含んでいる場合、自身の値を返す\n\t\telse if(left <= tL && tR <= right){\n\t\t\treturn this.tree[current];\n\t\t}\n\t\t//3. 一部区間だけがカブっている場合（左右どちらかがはみ出ている）\n\t\telse{\n\t\t\t//左側の子の回答\n\t\t\tlong valL = GetAnswerSub(left, right, current*2+1, tL, (tL+tR)/2);\n\t\t\t//右側の子の回答\n\t\t\tlong valR =\tGetAnswerSub(left, right, current*2+2, (tL+tR)/2, tR);\n\t\t\t//両者の回答から自身の回答を決定\n\t\t\treturn this.fx(valL, valR);\n\t\t}\n\t}\n\n\n\t/*\n\t--- ---\n\t*/\n\n\t//debug用の、完全二分木出力メソッド\n\tpublic void DebugWrite(){\n\t\tfor(int i=0; i<this.tree.Length; i++){\n\t\t\tConsole.Write(\"t[{0}]={1}\",i,this.tree[i]);\n\t\t\t//葉に該当する場合、葉の番号iを出力\n\t\t\tif(i >= leaf-1){\n\t\t\t\tConsole.Write(\"(i={0}),\", i-this.leaf+1);\n\t\t\t}\n\t\t\t//それ以外\n\t\t\telse{\n\t\t\t\tConsole.Write(\",\");\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n}\n\n/*\n--- おまけ ---\n\nよくある問題に対する、コンストラクタの引数のセット\n（引数は上からそれぞれ、\n元の配列の要素数、関数4つ、二分木の初期値、遅延評価配列の初期値）\n\ncf. 区間の長さが関係ない問題の場合、fp関数は実質的には無意味\n　→2つ目の引数が長さであるので、それを無効化すれば良い\n　（Func<long, long, long> fp = (m,n) => m;）\n\n（１）RAQ（更新） + RSQ（回答）の場合\n（Range Add Query と Range Sum Query：区間「加算」と区間「和」）\n\n\tFunc<long, long, long> fx = (x1,x2) => x1 + x2;\n\tFunc<long, long, long> fa = (x,m) => x + m;\n\tFunc<long, long, long> fm = (m1,m2) => m1 + m2;\n\tFunc<long, long, long> fp = (m,n) => m * n;\n\tlong init = 0;\n\tlong lazyInit = 0;\n\n（２）RAQ（更新） + RMQ（回答）の場合\n（Range Add Query と Range Minimum Query：区間「加算」と区間「最小値」）\n\n\tFunc<long, long, long> fx = (x1,x2) => Math.Min(x1,x2);\n\tFunc<long, long, long> fa = (x,m) => x + m;\n\tFunc<long, long, long> fm = (m1,m2) => m1 + m2;\n\tFunc<long, long, long> fp = (m,n) => m;\n\tlong init = long.MaxValue;\n\tlong lazyInit = 0;\n\n（３）RUQ（更新） + RMQ（回答）の場合\n（Range Update Query と Range Minimum Query：区間「上書き」と区間「最小値」）\n\n\tFunc<long, long, long> fx = (x1,x2) => Math.Min(x1,x2);\n\tFunc<long, long, long> fa = (x,m) => m;\n\tFunc<long, long, long> fm = (m1,m2) => m2;\n\tFunc<long, long, long> fp = (m,n) => m;\n\tlong init = long.MaxValue;\n\tlong lazyInit = long.MaxValue;\n\n*/\n\n"
  },
  {
    "language": "C#",
    "code": "// optional\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Text;\n\nclass Main {\n    struct Node {\n        public int t { get; set; }\n        public int v { get; set; }\n\n        public void UpdateV(int x, int t) {\n            this.t = t;\n            this.v = x;\n        }\n    }\n\n    class SegTree {\n        Node[] nodes;\n        int n = 1;\n\n        public SegTree(int n) {\n            while (this.n < n) {\n                this.n *= 2;\n            }\n\n            nodes = new Node[2 * this.n - 1];\n            for (int i = 0; i < nodes.Length; i++) {\n                nodes[i] = new Node() { t = 0, v = int.MaxValue };\n            }\n        }\n\n        public void Update(int l, int r, int x, int t) {\n            Update(l, r, x, t, 0, 0, n);\n        }\n\n        private void Update(int l, int r, int x, int t, int nowP, int nowL, int nowR) {\n            if (r <= nowL || nowR <= l) {\n                return;\n            }\n\n            if (l <= nowL && nowR <= r) {\n                nodes[nowP].UpdateV(x, t);\n                return;\n            }\n\n            Update(l, r, x, t, 2 * nowP + 1, nowL, (nowL + nowR) / 2);\n            Update(l, r, x, t, 2 * nowP + 2, (nowL + nowR) / 2, nowR);\n        }\n\n        public int Find(int i) {\n            var cur = n + i - 1;\n            var t = nodes[cur].t;\n\n            var v = nodes[cur].v;\n            while (cur > 0) {\n                cur = (cur - 1) / 2;\n                if (nodes[cur].t > t) {\n                    t = nodes[cur].t;\n                    v = nodes[cur].v;\n                }\n            }\n\n            return v;\n        }\n    }\n\n\n    public void Run() {\n        var nq = ReadLib.ReadAsIntArray();\n        var tree = new SegTree(nq[0]);\n        var t = 1;\n        var sb = new StringBuilder();\n        for (int i = 0; i < nq[1]; i++) {\n            var cxy = ReadLib.ReadAsIntArray();\n            if (cxy[0] == 0) {\n                tree.Update(cxy[1], cxy[2] + 1, cxy[3], t);\n                t++;\n            }\n\n            if (cxy[0] == 1) {\n                sb.AppendLine(tree.Find(cxy[1]).ToString());\n            }\n        }\n        Console.Write(sb.ToString());\n    }\n}\n\n\n\nstatic class ReadLib {\n    public static long ReadAsLong() {\n        return long.Parse(Console.ReadLine());\n    }\n\n    public static int ReadAsInt() {\n        return int.Parse(Console.ReadLine());\n    }\n\n    public static int[] ReadAsIntArray() {\n        return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n    }\n\n    public static long[] ReadAsLongArray() {\n        return Array.ConvertAll(Console.ReadLine().Split(' '), long.Parse);\n    }\n\n    public static ulong[] ReadAsULongArray() {\n        return Console.ReadLine().Split(' ').Select(s => ulong.Parse(s)).ToArray();\n    }\n\n    public static string[] ReadAsStringArray() {\n        return Console.ReadLine().Split(' ');\n    }\n\n    public static int[] ReadNTimesAsInt(int n) {\n        return Enumerable.Range(1, n).Select(s => int.Parse(Console.ReadLine())).ToArray();\n    }\n\n    public static char[][] ReadNTimesAsCharArray(int n) {\n        return Enumerable.Range(1, n).Select(i => Console.ReadLine().ToArray()).ToArray();\n    }\n\n    public static long[] ReadNTimesAsLong(int n) {\n        return Enumerable.Range(1, n).Select(s => long.Parse(Console.ReadLine())).ToArray();\n    }\n\n    public static int[][] ReadNTimesAsIntArray(int n) {\n        return Enumerable.Range(1, n).Select(s => ReadAsIntArray()).ToArray();\n    }\n\n    public static string[] ReadNTimesAsString(int n) {\n        return Enumerable.Range(1, n).Select(s => Console.ReadLine()).ToArray();\n    }\n\n    public static char[,] ReadMapAsChar(int hSize, int wSize) {\n        var map = new char[hSize, wSize];\n        for (int h = 0; h < hSize; h++) {\n            var a = Console.ReadLine();\n            for (int w = 0; w < wSize; w++) {\n                map[h, w] = a[w];\n            }\n        }\n        return map;\n    }\n}\n/// <summary>優先度付きキュー</summary>\nclass PriorityQueue<T> : IEnumerable<T>, IReadOnlyCollection<T> where T : IComparable<T> {\n    public List<T> HeapArray { get; }\n    public T NIL { get; }\n    public bool IsMax { get; }\n\n    public int Count => HeapArray.Count;\n\n    /// <param name=\"heapArray\">ヒープ</param>\n    /// <param name=\"NIL\">NILの値</param>\n    /// <param name=\"IsMax\">True時：大きい方から取り出す、False時：小さい方から取り出す</param>\n    public PriorityQueue(T NIL, IEnumerable<T> heapArray = null, bool IsMax = true) {\n        this.HeapArray = heapArray == null ? new List<T>() : heapArray.ToList();\n        this.NIL = NIL;\n        this.IsMax = IsMax;\n        Update();\n    }\n\n    /// <summary>KeyのValueを取得</summary>\n    public T this[int id] {\n        get {\n            if (id <= 0 || id > HeapArray.Count) {\n                return NIL;\n            }\n\n            return HeapArray[id - 1];\n        }\n    }\n\n    class Node {\n        public int Key { get; }\n        public T Value => outer[Key];\n        readonly PriorityQueue<T> outer;\n\n        public Node(int key, PriorityQueue<T> outer) {\n            Key = key;\n            this.outer = outer;\n        }\n\n        public Node Left {\n            get {\n                var leftKey = 2 * Key;\n                return new Node(leftKey, outer);\n            }\n        }\n\n        public Node Right {\n            get {\n                var rightkey = 2 * Key + 1;\n                return new Node(rightkey, outer);\n            }\n        }\n\n        public Node Parent {\n            get {\n                var parentKey = Key / 2;\n                return new Node(parentKey, outer);\n            }\n        }\n    }\n\n    private Node GetNode(int key) {\n        return new Node(key, this);\n    }\n\n    /// <summary>max Heap木とする O(N)</summary>\n    public void Update() {\n        var n = HeapArray.Count() / 2;\n        /// <summary>葉から順に処理を行う</summary>\n        for (int i = n; i >= 1; i--) {\n            Heapify(i);\n        }\n    }\n\n    /// <summary>idを根とする部分木について、Heap木を維持したまま、idを下降させる</summary>\n    private void Heapify(int key) {\n        var current = GetNode(key);\n\n        var left = current.Left;\n        var right = current.Right;\n\n        var largest = current;\n        var sign = IsMax ? 1 : -1;\n        if (left.Value.CompareTo(NIL) != 0 && left.Value.CompareTo(current.Value) * sign > 0) {\n            largest = left;\n        }\n\n        if (right.Value.CompareTo(NIL) != 0 && right.Value.CompareTo(largest.Value) * sign > 0) {\n            largest = right;\n        }\n\n        if (largest.Key != key) {\n            HeapArray.Swap(key - 1, largest.Key - 1);   // 元と異なるときはSwapする\n            Heapify(largest.Key); // largest.Key は元のkeyの場所。葉で更にMaxHeaptyを行う。\n        }\n    }\n\n    /// <summary>keyの値を挿入する</summary>\n    public void Enqueue(T value) {\n        HeapArray.Add(value);\n\n        var inserted = GetNode(HeapArray.Count);    // 末尾に挿入\n        var parent = inserted.Parent;\n        var sign = IsMax ? 1 : -1;\n\n        // 挿入Nodeが根になる or 親 > 子になるまで親とNodeを交換\n        while (inserted.Key > 1 && value.CompareTo(parent.Value) * sign > 0) {\n            HeapArray.Swap(inserted.Key - 1, parent.Key - 1);\n            inserted = parent;\n            parent = inserted.Parent;\n        }\n    }\n\n    public T Dequeue() {\n        if (HeapArray.Count == 0) {\n            return NIL;\n        }\n\n        var popVal = HeapArray.First();\n        var newRootVal = HeapArray.Last();  // 新しい根となる。\n\n        HeapArray.RemoveAt(HeapArray.Count - 1);    // del last\n\n        if (HeapArray.Count > 0) {\n            HeapArray[0] = newRootVal;\n            Heapify(1);\n        }\n\n        return popVal;\n    }\n\n    public T Peek() {\n        return HeapArray.First();\n    }\n\n    public IEnumerator<T> GetEnumerator() {\n        while (HeapArray.Count > 0) {\n            yield return Dequeue();\n        }\n    }\n\n    IEnumerator IEnumerable.GetEnumerator() {\n        return GetEnumerator();\n    }\n\n    public void Clear() {\n        HeapArray.Clear();\n    }\n\n    public bool Contains(T val) {\n        return HeapArray.Contains(val);\n    }\n\n    public PriorityQueue<T> Clone() {\n        return new PriorityQueue<T>(NIL, HeapArray.DeepCopy());\n    }\n}\n/// <summary>1次元NDTree</summary>\nclass OneDTree<T> where T : IComparable<T> {\n    private T[] p;\n\n    public OneDTree(T[] p) {\n        this.p = p;\n        this.nodes = new Node[p.Length];\n        for (int i = 0; i < p.Length; i++) {\n            nodes[i] = new Node();\n        }\n\n        MakeTree(0, p.Length);\n    }\n\n    static readonly int NIL = -1;\n\n    // l以上、r未満の範囲で二分探索木を構成する\n    class Node {\n        public int Location { get; set; }\n        public int Left { get; set; }\n        public int Right { get; set; }\n\n        public Node() {\n            Location = NIL;\n            Left = NIL;\n            Right = NIL;\n        }\n    }\n\n    Node[] nodes;\n    int nodesP = 0; // TODO : スコープが広いので、C#のver upしたら関数内関数にする。\n    private int MakeTree(int l, int r) {\n        if (l >= r) {\n            return NIL;\n        }\n\n        Array.Sort(p, l, r - l);\n        var mid = (l + r) / 2;\n        var cP = nodesP++;\n\n        // mid以外の探索木を構成\n        nodes[cP].Location = mid;\n        nodes[cP].Left = MakeTree(l, mid);\n        nodes[cP].Right = MakeTree(mid + 1, r);\n\n        return cP;\n    }\n    /// <summary>\n    /// 二分探索木からlower以上Higher以下の値を返す\n    /// </summary>\n    public IEnumerable<T> Find(T lower, T higher) {\n        if (higher.CompareTo(lower) < 0) {\n            throw new ArgumentException(\"higher < lower\");\n        }\n\n        return Find(0, lower, higher);\n    }\n\n    /// <summary>\n    /// 二分探索木からlower以上Higher以下の値を返す\n    /// </summary>\n    /// <param name=\"v\">訪問中のnode番号</param>\n    private IEnumerable<T> Find(int v, T lower, T higher) {\n        var current = p[nodes[v].Location];\n\n        if (current.CompareTo(lower) >= 0 && current.CompareTo(higher) <= 0) {\n            yield return p[nodes[v].Location];\n        }\n\n        if (nodes[v].Left != NIL && current.CompareTo(lower) >= 0) {\n            foreach (var item in Find(nodes[v].Left, lower, higher)) {\n                yield return item;\n            }\n        }\n\n        if (nodes[v].Right != NIL && current.CompareTo(higher) <= 0) {\n            foreach (var item in Find(nodes[v].Right, lower, higher)) {\n                yield return item;\n            }\n        }\n\n    }\n}\n/// <summary>2DimentionTree</summary>\nclass TwoDTree {\n    const int NIL = -1;\n    struct Node {\n        public int Left { get; set; }\n        public int Right { get; set; }\n        public int Location { get; set; }\n        public Node(int location, int left, int right) {\n            Location = location;\n            Left = left;\n            Right = right;\n        }\n    }\n\n    [Serializable]\n    public struct Point {\n        public int Id { get; set; }\n        public int X { get; set; }\n        public int Y { get; set; }\n\n        public Point(int id, int x, int y) {\n            Id = id;\n            X = x;\n            Y = y;\n        }\n    }\n\n    public static Point CreatePoint(int id, int x, int y) {\n        return new Point(id, x, y);\n    }\n\n    readonly Node[] nodes;\n    readonly Point[] points;\n    public TwoDTree(Point[] points) {\n        this.points = points;\n        this.nodes = new Node[points.Length];\n        for (int i = 0; i < points.Length; i++) {\n            nodes[i] = new Node(NIL, NIL, NIL);\n        }\n\n        MakeTree(0, points.Length, 0);\n    }\n\n    class CompX : IComparer<Point> {\n        public int Compare(Point p1, Point p2) {\n            return p1.X.CompareTo(p2.X);\n        }\n    }\n\n    class CompY : IComparer<Point> {\n        public int Compare(Point p1, Point p2) {\n            return p1.Y.CompareTo(p2.Y);\n        }\n    }\n\n    readonly CompX compX = new CompX();\n    readonly CompY compY = new CompY();\n    int cp = 0;\n\n    private int MakeTree(int left, int right, int depth) {\n        if (left >= right) {\n            return NIL;\n        }\n\n        if (depth % 2 == 0) {\n            Array.Sort(points, left, right - left, compX);\n        } else {\n            Array.Sort(points, left, right - left, compY);\n        }\n\n        var mid = (left + right) / 2;\n        var cpp = cp++;\n        nodes[cpp].Location = mid;\n        nodes[cpp].Left = MakeTree(left, mid, depth + 1);\n        nodes[cpp].Right = MakeTree(mid + 1, right, depth + 1);\n\n        return cpp;\n    }\n\n    /// <summary>minXとmaxX、minYとmaxYの間の点をResultに格納する。</summary>\n    public void Find(int minX, int maxX, int minY, int maxY) {\n        Find(0, minX, maxX, minY, maxY, 0);\n    }\n\n    public void ClearResult() {\n        result.Clear();\n    }\n\n    /// <summary>Findの結果を得る</summary>\n    public List<Point> GetFindResult() {\n        return result;\n    }\n\n    List<Point> result = new List<Point>();\n    private void Find(int nodeP, int minX, int maxX, int minY, int maxY, int depth) {\n        var node = nodes[nodeP];\n        var p = points[node.Location];\n\n        if (p.X >= minX && p.Y >= minY && p.X <= maxX && p.Y <= maxY) {\n            result.Add(p);\n        }\n\n        if (depth % 2 == 0) {\n            if (node.Left != NIL && p.X >= minX) {\n                Find(node.Left, minX, maxX, minY, maxY, depth + 1);\n            }\n\n            if (node.Right != NIL && p.X <= maxX) {\n                Find(node.Right, minX, maxX, minY, maxY, depth + 1);\n            }\n        } else {\n            if (node.Left != NIL && p.Y >= minY) {\n                Find(node.Left, minX, maxX, minY, maxY, depth + 1);\n            }\n\n            if (node.Right != NIL && p.Y <= maxY) {\n                Find(node.Right, minX, maxX, minY, maxY, depth + 1);\n            }\n        }\n    }\n}\n/// <summary>拡張メソッドs</summary>\nstatic class MyExtesntion {\n    /// <summary>iとjを入れ替える</summary>\n    public static void Swap<T>(this T[] arr, int i, int j) {\n        var buf = arr[i];\n        arr[i] = arr[j];\n        arr[j] = buf;\n    }\n\n    public static void Swap<T>(this List<T> list, int i, int j) {\n        var buf = list[i];\n        list[i] = list[j];\n        list[j] = buf;\n    }\n\n    /// <summary>\n    /// partition。末尾sArr[r]を基準として、左に基準より小さい数、右に基準より大きい数が存在するように配列を並び替える。\n    /// </summary>\n    /// <param name=\"sArr\"></param>\n    /// <param name=\"p\">partitionの先頭の添字</param>\n    /// <param name=\"r\">partitionの末尾の添字</param>\n    /// <returns>partitionの基準が存在する添字</returns>\n    public static int Partition(this int[] sArr, int p, int r) {\n        var x = sArr[r];\n        var i = p - 1;\n        for (int j = p; j < r; j++) {\n            if (sArr[j] <= x) {\n                i++;\n                sArr.Swap(i, j);\n            }\n        }\n        sArr.Swap(i + 1, r);\n        return i + 1;\n    }\n\n    /// <summary>深いコピーをする</summary>\n    public static T DeepCopy<T>(this T obj) {\n        T result;\n        var b = new BinaryFormatter();\n        using (var mem = new MemoryStream()) {\n            b.Serialize(mem, obj); //  binaryFormatterによりobjをmemにserial化して書き出す\n            mem.Position = 0; // memのpotisionを先頭に戻す\n            result = (T)b.Deserialize(mem); // memの内容を読み取る。\n        }\n        return result;\n    }\n\n    public static string Left(this string str, int length) {\n        return str.Substring(0, length);\n    }\n\n    public static string Right(this string str, int length) {\n        return str.Substring(str.Length - length, length);\n    }\n\n    public static int Find<T>(this T[] array, T obj) {\n        return Array.IndexOf(array, obj);\n    }\n\n    public static int LastFind<T>(this T[] array, T obj) {\n        return Array.LastIndexOf(array, obj);\n    }\n\n    /// <summary>同一の値で埋める</summary>\n    public static void Initialize<T>(this T[,] array, T value) {\n        for (int i = 0; i < array.GetLength(0); i++) {\n            for (int j = 0; j < array.GetLength(1); j++) {\n                array[i, j] = value;\n            }\n        }\n    }\n\n    /// <summary>数え上げて、key, 出現回数に変換</summary>\n    public static Dictionary<T, int> CountUp<T>(this IEnumerable<T> str) {\n        return\n            str\n            .GroupBy(c => c)\n            .Select(g => new KeyValuePair<T, int>(g.Key, g.Count()))\n            .ToDictionary(e => e.Key, e => e.Value);\n    }\n\n    /// <summary>ある要素を持つindexをすべて返す</summary>\n    public static int[] InducesOfValue<T>(this T[] arr, T searchValue) {\n        return arr\n            .Select((v, i) => new { v, i })\n            .Where(o => searchValue.Equals(o.v))\n            .Select(o => o.i)\n            .ToArray();\n    }\n\n    /// <summary>ある要素を持つindexをすべて返す</summary>\n    public static int[] Induces<T>(this IEnumerable<T> arr, T searchValue) {\n        return arr.ToArray().InducesOfValue(searchValue);\n    }\n}\n\nstatic class MyMath {\n    /// <summary>階乗</summary>\n    public static long Factorial(int n) {\n        if (n == 0) {\n            return 1;\n        }\n\n        return Permutation(n, 0);\n    }\n\n    public static long Permutation(int n, int k) {\n        return Enumerable.Range(0, n - k).Select(i => n - i).Aggregate(1, (b, i) => b * i);\n    }\n\n    #region FullPower\n    /// <summary>総乗、π</summary>\n    public static long FullPower(IEnumerable<long> vs) {\n        return vs.Aggregate(1L, (a, b) => a * b);\n    }\n\n    public static long FullPower(IEnumerable<int> vs) {\n        return vs.Aggregate(1L, (a, b) => a * b);\n    }\n    #endregion\n\n    /// <summary>最大公約数</summary>\n    public static long Gcd(long item1, long item2) {\n        var a = Math.Max(item1, item2);\n        var b = Math.Min(item1, item2);\n\n        while (true) {\n            long mod;\n            Math.DivRem(a, b, out mod);\n            if (mod == 0) {\n                break;\n            }\n\n            a = b;\n            b = mod;\n        }\n        return b;\n    }\n\n    /// <summary>約分。最大公約数で割ったものを返す。</summary>\n    public static Tuple<long, long> DeviedByGcd(long item1, long item2) {\n        var gcd = Gcd(item1, item2);\n        return new Tuple<long, long>(item1 / gcd, item2 / gcd);\n    }\n\n    public static long Lcm(int item1, int item2) {\n        return Math.BigMul(item1, item2) / Gcd(item1, item2);\n    }\n\n    public static ModCombination ModCombination(int maxN, int mod = 1000000007) {\n        return new ModCombination(maxN, mod);\n    }\n\n    /// <summary>a^n mod</summary>\n    public static int ModPow(long a, long n, int mod = 1000000007) {\n        long res = 1;\n        long pow = a;\n\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                res = (pow * res) % mod;    // resにaをかける\n            }\n\n            pow = (pow * pow) % mod;    // 次のaはa^2\n            n >>= 1;\n        }\n\n        return (int)res;\n    }\n\n    /// <summary>約数を列挙</summary>\n    public static long[] Divisors(long n) {\n        var ret = new List<long>();\n        var sqrt = Math.Ceiling(Math.Sqrt(n));\n        for (long i = 1; i <= sqrt; i++) {\n            if (i * i > n) {\n                continue;\n            }\n\n            if (n % i != 0) {\n                continue;\n            }\n\n            ret.Add(i);\n\n            if (n / i == i) {\n                continue;\n            }\n\n            ret.Add(n / i);\n        }\n\n        return ret.ToArray();\n    }\n\n    /// <summary>Combination。nCk。O(nk)</summary>\n    /// <see cref=\"http://caprest.hatenablog.com/entry/2016/05/29/181102\"/>\n    public static long Combination(int n, int k) {\n        if (n < k) {\n            return 0;\n        }\n\n        var dp = new long[n + 1][];   // nCkのdp\n        for (int i = 0; i <= n; i++) {\n            dp[i] = new long[n + 1];\n        }\n\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n            dp[i][i] = 1;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                // nCk = n-1Ck-1 + n-1Ck\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }\n        }\n\n        return dp[n][k];\n    }\n}\n\n/// <summary>組み合わせ</summary>\n///  * Combination, nCk mod p を求める\n/// https://ja.wikipedia.org/wiki/%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%A9%E9%80%86%E6%95%B0\n/// http://drken1215.hatenablog.com/entry/2018/06/08/210000\nclass ModCombination {\n    private int mod;\n    private int[] fac;\n    private int[] finv;\n    /// <summary>\n    /// \n    /// </summary>\n    /// <param name=\"nMax\"></param>\n    /// <param name=\"mod\"></param>\n    public ModCombination(int nMax, int mod = 1000000007) {\n        this.mod = mod;\n        fac = new int[nMax]; // modが法のn!の列\n        fac[0] = 1; fac[1] = 1;\n\n        finv = new int[nMax]; // modを法とした、invの累積の累積\n        finv[0] = 1; finv[1] = 1;\n\n        var inv = new int[nMax]; // indexの逆元（モジュラ逆数）の列\n        inv[1] = 1;\n\n        for (int i = 2; i < nMax; i++) {\n            fac[i] = (int)(Math.BigMul(fac[i - 1], i) % mod);  // factorを求める\n            // mod % i < i\n            // modの倍数を加えても逆元である\n            var s = Math.BigMul(inv[mod % i], mod / i) % mod;\n            inv[i] = (int)(mod - s);　 // iに対する逆元を求める\n            finv[i] = (int)(Math.BigMul(finv[i - 1], inv[i]) % mod);\n        }\n    }\n\n    /// <summary>nCk</summary>\n    public int Calculation(int n, int k) {\n        if (n < k) return 0;\n        if (n < 0 || k < 0) return 0;\n\n        return (int)(Math.BigMul(fac[n], (int)(Math.BigMul(finv[k], finv[n - k]) % mod)) % mod);\n    }\n}\n\n/// <summary>あまりを計算するためのintのラッパー</summary>\nstruct ModInt {\n    int Value { get; }\n    int Mod { get; }\n\n    public override string ToString() {\n        return Value.ToString();\n    }\n\n    public static explicit operator ModInt(long value) {\n        return new ModInt(value);\n    }\n\n    public ModInt(long value, int mod = 1000000007) {\n        this.Value = (int)(value % mod);\n        this.Mod = mod;\n    }\n\n    public static explicit operator int(ModInt modInt) {\n        return modInt.Value;\n    }\n\n    private static void CheckNotEqualMod(ModInt item1, ModInt item2) {\n        if (item1.Mod != item2.Mod) {\n            throw new Exception(\"mod not equal\");\n        }\n    }\n\n    public static ModInt operator +(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = item1.Value + item2.Value;\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator *(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = Math.BigMul(item1.Value, item2.Value);\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator -(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = item1.Value - item2.Value;\n        if (value < 0) {\n            value += item1.Mod;\n        }\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator +(ModInt item1, int item2) {\n        return item1 + new ModInt(item2, item1.Mod);\n    }\n\n    public static ModInt operator *(ModInt item1, int item2) {\n        return item1 * new ModInt(item2, item1.Mod);\n    }\n\n    public static ModInt operator -(ModInt item1, int item2) {\n        return item1 - new ModInt(item2, item1.Mod);\n    }\n\n\n    public override int GetHashCode() {\n        return this.Value;\n    }\n\n    public override bool Equals(object obj) {\n        if (obj == null || this.GetType() != obj.GetType()) {\n            return false;\n        }\n\n        var modIntObj = (ModInt)obj;\n        return modIntObj.Value == this.Value;\n    }\n\n    public static bool operator ==(ModInt item1, ModInt item2) {\n        return item1.Value == item2.Value;\n    }\n\n    public static bool operator !=(ModInt item1, ModInt item2) {\n        return !(item1 == item2);\n    }\n\n    public static bool operator ==(ModInt item1, int item2) {\n        return item1.Value == item2;\n    }\n\n    public static bool operator !=(ModInt item1, int item2) {\n        return !(item1.Value == item2);\n    }\n\n    public static bool operator >=(ModInt item1, ModInt item2) {\n        return item1.Value >= item2.Value;\n    }\n\n    public static bool operator <=(ModInt item1, ModInt item2) {\n        return item1.Value <= item2.Value;\n    }\n\n    public static bool operator >=(ModInt item1, int item2) {\n        return item1.Value >= item2;\n    }\n\n    public static bool operator <=(ModInt item1, int item2) {\n        return item1.Value <= item2;\n    }\n\n    public static bool operator >(ModInt item1, ModInt item2) {\n        return item1.Value > item2.Value;\n    }\n\n    public static bool operator <(ModInt item1, ModInt item2) {\n        return item1.Value < item2.Value;\n    }\n\n    public static bool operator >(ModInt item1, int item2) {\n        return item1.Value >= item2;\n    }\n\n    public static bool operator <(ModInt item1, int item2) {\n        return item1.Value <= item2;\n    }\n}\n\npublic static class Program {\n    public static void Main() {\n        #region SetAutoFlushIsFalse\n#if !DEBUG\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n#endif\n        #endregion\n        try {\n            var main = new Main();\n            main.Run();\n        } finally {\n            #region Flush\n#if !DEBUG\n        Console.Out.Flush();\n        sw.Close();\n#endif\n            #endregion\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        var N = FastIO.Int();\n        var Q = FastIO.Int();\n        var d = new Dual<int>(N, (l, r) => r == int.MaxValue ? l : r, int.MaxValue);\n        for (int i = 0; i < Q; i++)\n        {\n            if (FastIO.Int() == 0)\n            {\n                var s = FastIO.Int();\n                var t = FastIO.Int() + 1;\n                var x = FastIO.Int();\n                d.Update(s, t, x);\n            }\n            else\n            {\n                var t = FastIO.Int();\n                WriteLine(d.Query(t));\n            }\n        }\n        Out.Flush();\n    }\n}\n\npublic class Dual<E>\n    {\n        E[] lazy;\n        Func<E, E, E> H;\n        E EI;\n        int N;\n        public int Length => N;\n        int height;\n\n        public Dual(int length, Func<E, E, E> h, E ei)\n        {\n            N = length;\n            height = 1;//!log2\n            while (1 << height < length) height++;\n\n            lazy = new E[N * 2];\n            for (int i = 0; i < lazy.Length; i++) lazy[i] = ei;//i=1でもいいけど伝播でlazy[0]にアクセスしない保証がいる\n\n            EI = ei;\n            H = h;\n        }\n\n        void Propagate(int k)\n        {\n            //if (lazy[k] == EI) return;//定数倍高速化（書けない）\n            lazy[k * 2 + 0] = H(lazy[k * 2 + 0], lazy[k]);\n            lazy[k * 2 + 1] = H(lazy[k * 2 + 1], lazy[k]);\n            lazy[k] = EI;\n        }\n\n        void Thrust(int k)\n        {\n            for (int i = height; i > 0; i--) Propagate(k >> i);\n        }\n\n        public void Update(int l, int r, E v)\n        {\n            l += N;\n            r += N;\n            Thrust(l);\n            Thrust(r - 1);\n            while (l < r)\n            {\n                if ((l & 1) == 1)\n                {\n                    lazy[l] = H(lazy[l], v);\n                    l++;\n                }\n                if ((r & 1) == 1)\n                {\n                    --r;\n                    lazy[r] = H(lazy[r], v);\n                }\n                l >>= 1;\n                r >>= 1;\n            }\n        }\n        //配列初期化は？Update(k, v)とか書く？インデクサは欲しいか　双対でにぶたんは意味ない？\n        public E Query(int i)\n        {\n            i += N;\n            Thrust(i);\n            return lazy[i];\n        }\n    }\npublic static class FastIO\n{\n    static System.IO.Stream str = System.Console.OpenStandardInput();\n    const int size = 1024;\n    static byte[] buffer = new byte[size];\n    static int ptr;\n    static int len;\n\n    static byte Read()\n    {\n        if (ptr == len)\n        {\n            len = str.Read(buffer, 0, size);\n            if (len == 0) return 0;\n            ptr = 0;\n        }\n        return buffer[ptr++];\n    }\n\n    public static int Int()\n    {\n        var c = Read();\n        while (c < 0x21)\n        {\n            c = Read();\n        }\n        var n = false;\n        if (c == '-')\n        {\n            n = true;\n            c = Read();\n        }\n        var ret = 0;\n        while (c > 0x20)\n        {\n            ret = ret * 10 + c - '0';\n            c = Read();\n        }\n        return n ? -ret : ret;\n    }\n\n    public static long Long()\n    {\n        var c = Read();\n        while (c < 0x21)\n        {\n            c = Read();\n        }\n        var n = false;\n        if (c == '-')\n        {\n            n = true;\n            c = Read();\n        }\n        var ret = 0L;\n        while (c > 0x20)\n        {\n            ret = ret * 10 + c - '0';\n            c = Read();\n        }\n        return n ? -ret : ret;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new LazySegtree<int, int>(N, (x, y) => x + y, (x, y, len) => y * len, (x, y) => y, 0);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, cin.nextint);\n            }\n            else if (com == 1)\n            {\n                var A = new int[6];\n                for (int j = 0; j < 6; j++)\n                {\n                    A[j] = S[j, j];\n                }\n                A.join();\n                WriteLine(S[cin.nextint, cin.nextint]);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass LazySegtree<T, U>\n{\n    readonly int n;\n    T[] data;\n    U[] lazy;\n    readonly bool[] is_lazy;\n    readonly Func<T, T, T> calc;\n    readonly Func<T, U, int, T> apply;\n    readonly Func<U, U, U> merge;\n    readonly T ex_data;\n\n    /// <summary>\n    /// 遅延セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"calc\">要素のマージ</param>\n    /// <param name=\"apply\">要素に作用素を作用</param>\n    /// <param name=\"merge\">作用素のマージ</param>\n    /// <param name=\"ex_data\">単位元</param>\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data)\n    {\n        this.calc = calc;\n        this.apply = apply;\n        this.merge = merge;\n        this.ex_data = ex_data;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[n * 2 - 1];\n        lazy = new U[n * 2 - 1];\n        is_lazy = new bool[n * 2 - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = ex_data;\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, T ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini;\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, IList<T> ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini[i];\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    void assign_lazy(int k, U x)\n    {\n        if (k >= lazy.Length) return;\n        if (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n        else\n        {\n            is_lazy[k] = true;\n            lazy[k] = x;\n        }\n    }\n    void eval(int k, int len)\n    {\n        if (!is_lazy[k]) return;\n        assign_lazy(k * 2 + 1, lazy[k]);\n        assign_lazy(k * 2 + 2, lazy[k]);\n        data[k] = apply(data[k], lazy[k], len);\n        is_lazy[k] = false;\n    }\n    T update(int s, int t, U x, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return data[k];\n        if (s <= l && r <= t)\n        {\n            assign_lazy(k, x);\n            return apply(data[k], lazy[k], r - l);\n        }\n        return data[k] = calc(update(s, t, x, k * 2 + 1, l, (l + r) / 2),\n                              update(s, t, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T run(int s, int t, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return ex_data;\n        if (s <= l && r <= t) return data[k];\n        return calc(run(s, t, k * 2 + 1, l, (l + r) / 2),\n                    run(s, t, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    /// <summary>update [s, t]</summary>\n    public void Update(int s, int t, U x) { t++; update(s, t, x, 0, 0, n); }\n    /// <summary>return node[s, t]</summary>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; return run(s, t, 0, 0, n); }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using static System.Globalization.CultureInfo;\nusing System.Text;\nclass Program\n{\n    private static void chmin<T>(ref T num, T val) where T : IComparable<T>\n        => num = num.CompareTo(val) == 1 ? val : num;\n    private static void chmax<T>(ref T num, T val) where T : IComparable<T>\n        => num = num.CompareTo(val) == -1 ? val : num;\n    private static void swap<T>(ref T v1,ref T v2)\n    { var t = v2;v2 = v1;v1 = t; }\n    static void Main(string[] args)\n    {\n        var pr = new Program();\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        pr.Solve();\n        Console.Out.Flush();\n    }\n    void Solve()\n    {\n        int num, q;\n        Input.Make(out num, out q);\n        var seg = new SegmentTree<Pair<int,int>>(num, new Pair<int, int>(int.MaxValue,-1),(a,b)=>a.v2>b.v2?a:b );\n        var ct = 0;\n        while (q-- > 0)\n        {\n            var inp = Input.ar;\n            if (inp[0] == 0)\n                seg.Update(inp[1], inp[2] + 1, new Pair<int, int>(inp[3], ct++));\n            else WriteLine(seg.Query(inp[1]).v1);\n        }\n\n\n    }\n}\n\npublic class SegmentTree<T>\n{\n    protected readonly T[] item;\n    protected readonly int _num;\n    protected readonly Func<T, T, T> _func;\n    protected readonly Func<T, T, T> updateFunc;\n    protected readonly T _init;\n\n    protected int Parent(int index)\n        => (index - 1) >> 1;\n    protected int Left(int index)\n        => (index << 1) + 1;\n    protected int Right(int index)\n        => (index + 1) << 1;\n    public T this[int i]\n    {\n        get { return item[i + _num - 1]; }\n        set { item[i + _num - 1] = value; }\n    }\n\n    public SegmentTree(int num, T init, Func<T, T, T> func, Func<T, T, T> updateFunc = null)\n    {\n        _func = func;\n        _num = 1;\n        _init = init;\n        this.updateFunc = updateFunc ?? ((T val1, T val2) => val2);\n        while (_num <= num)\n            _num *= 2;\n        item = new T[2 * _num - 1];\n        for (var i = 0; i < 2 * _num - 1; i++)\n            item[i] = init;\n    }\n    public void Update(int index, T value)\n    {\n        index += _num - 1;\n        item[index] = updateFunc(item[index], value);\n        while (index > 0)\n        {\n            index = Parent(index);\n            item[index] = _func(item[Left(index)], item[Right(index)]);\n        }\n    }\n    public virtual void Update(int left, int right, T value)\n        => Update(left, right, 0, 0, _num, value);\n    protected virtual void Update(int left, int right, int k, int l, int r, T value)\n    {\n        if (r <= left || right <= l) return;\n        if (left <= l && r <= right) item[k] = updateFunc(item[k], value);\n        else\n        {\n            Update(left, right, Left(k), l, (l + r) >> 1, value);\n            Update(left, right, Right(k), (l + r) >> 1, r, value);\n        }\n    }\n    public void All_Update()\n    {\n        for (int i = _num - 2; i >= 0; i--)\n            item[i] = _func(item[Left(i)], item[Right(i)]);\n    }\n    public T Query(int index)\n    {\n        index += _num - 1;\n        var value = _func(_init, item[index]);\n        while (index > 0)\n        {\n            index = Parent(index);\n            value = _func(value, item[index]);\n        }\n        return value;\n    }\n    //[left,right)\n    public virtual T Query(int left, int right)\n        => Query(left, right, 0, 0, _num);\n    protected virtual T Query(int left, int right, int k, int l, int r)\n    {\n        if (r <= left || right <= l) return _init;\n        if (left <= l && r <= right) return item[k];\n        else\n            return _func(Query(left, right, Left(k), l, (l + r) >> 1), Query(left, right, Right(k), (l + r) >> 1, r));\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => ToInt64(read);\n    public static T[] create<T>(int n, Func<int, T> f)\n        => Enumerable.Repeat(0, n).Select(f).ToArray();\n    public static char[][] grid(int h)\n        => create(h, _ => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => create(n, _ => num);\n    public static long[] arL1D(int n)\n        => create(n, _ => numL);\n    public static string[] strs(int n)\n        => create(n, _ => read);\n    public static int[][] ar2D(int n)\n        => create(n, _ => ar);\n    public static long[][] arL2D(int n)\n        => create(n, _ => arL);\n    public static List<T>[] edge<T>(int n)\n        => create(n, _ => new List<T>());\n    public static T GetValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(char))\n            return (T)(object)char.Parse(g);\n        if (t == typeof(double))\n            return (T)(object)double.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        return default(T);\n    }\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    private static Queue<string> sc;\n    public static T Next<T>(){ sc = sc ?? new Queue<string>(); if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item);return GetValue<T>(sc.Dequeue()); }\n    public static void Next<T>(ref T val) => val = Next<T>(); \n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public const string Alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1 { get; set; }\n    public T2 v2 { get; set; }\n    public Pair() { v1 = Input.Next<T1>(); v2 = Input.Next<T2>(); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n    public override bool Equals(object obj)\n        => this == (Pair<T1, T2>)obj;\n    public override int GetHashCode()\n        => v1.GetHashCode() ^ v2.GetHashCode();\n    public static bool operator ==(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 0;\n    public static bool operator !=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 0;\n    public static bool operator >(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 1;\n    public static bool operator >=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != -1;\n    public static bool operator <(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == -1;\n    public static bool operator <=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 1;\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3 { get; set; }\n    public Pair() : base() { v3 = Input.Next<T3>(); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, Q;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadIntArray();\n                N = line[0];\n                Q = line[1];\n            }\n\n            var S = new SegTree(N);\n\n            for(int i = 0; i < Q; i++)\n            {\n                var line = Input.ReadIntArray();\n                int C = line[0];\n                if (C == 0)\n                {\n                    int s = line[1];\n                    int t = line[2];\n                    int x = line[3];\n                    if (C == 0) S.Update(s, t+1, x);\n                }\n                else\n                {\n                    int id = line[1];\n                    Console.WriteLine(S.Query(id));\n                }\n            }\n\n        }\n    }\n\n    // libs ----------\n    internal class SegTree\n    {\n        public int N;\n        public int NCells;\n        public int H;\n        public int[] Data;\n        public int[] KL; // 範囲のbegin\n        public int[] KR; // 範囲のend（そのセルは含まない）\n        public const int Dummy = -1; \n\n        public SegTree(int _n)\n        {\n            Init(_n);\n        }\n\n        private int GetN(int _n)\n        {\n            int n = 1;\n            H = 1;\n            while (n < _n)\n            {\n                n *= 2;\n                H++;\n            }\n            return n;\n        }\n\n        private void Init(int _n, int initialValue = Dummy)\n        {\n            N = GetN(_n);\n            NCells = 2 * N - 1;\n\n            Data = new int[NCells];\n            KL = new int[NCells];\n            KR = new int[NCells];\n\n            // KL, KRの初期化\n            for (int k = 0; k < NCells; k++)\n            {\n                if (IsRoot(k))\n                {\n                    KL[k] = 0;\n                    KR[k] = N;\n                }\n                else\n                {\n                    if (IsChildL(k))\n                    {\n                        KL[k] = KL[Parent(k)];\n                        KR[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                    }\n                    else\n                    {\n                        KL[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                        KR[k] = KR[Parent(k)];\n                    }\n                }\n            }\n\n            // 値の初期化\n            for (int k = 0; k < NCells; k++) Data[k] = initialValue;\n\n            // 全体に初期値をセット\n            Update(0, N, 2147483647);\n        }\n\n        // i番目のみの値を保持するセル\n        public int Pos(int i) { return i + N - 1; }\n\n        // 親セル・子セル\n        public int Parent(int k) { return (k - 1) / 2; }\n        public int ChildL(int k) { return k * 2 + 1; }\n        public int ChildR(int k) { return k * 2 + 2; }\n\n        // 根かどうか\n        public bool IsRoot(int k) { return k == 0; }\n\n        // 左側の子かどうか\n        public bool IsChildL(int k)\n        {\n            if (IsRoot(k)) return false;\n            return ChildL(Parent(k)) == k;\n        }\n        \n        // Update - top down\n        public void Update(int il, int ir, int a)\n        {\n            update(il, ir, 0, a);\n\n            /*\n            Console.WriteLine(\"--------------\");\n            int c = 2;\n            for (int i = 0; i < NCells; i++)\n            {\n                if (i == c - 1)\n                {\n                    Console.WriteLine();\n                    c *= 2;\n                }\n                Console.Write(Data[i] + \" \");\n            }\n            Console.WriteLine();\n            Console.WriteLine(\"--------------\");\n            */\n        }\n\n        private void update(int il, int ir, int k, int a)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return;\n\n            // 完全に重複している場合にその値をセット\n            if (il <= kl && kr <= ir)\n                Data[k] = a;\n            else\n            {\n                // そうでない場合、上の値を分配\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                // 子の処理を行う\n                update(il, ir, ChildL(k), a);\n                update(il, ir, ChildR(k), a);\n            }\n        }\n\n        // Query - bottom up\n        public int Query(int i)\n        {\n            return query(i, i + 1, 0);\n        }\n\n        private int query(int il, int ir, int k)\n        {\n            int d = Data[k];\n            if (d != Dummy) return d;\n\n            int l = query(il, ir, ChildL(k));\n            int r = query(il, ir, ChildR(k));\n            if (l != Dummy) return l;\n            if (r != Dummy) return r;\n            throw new Exception();\n        }\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new SegTree<pair>(N, (x, y) => x.CompareTo(y) < 0 ? y : x, new pair(-1, int.MaxValue));\n        for (int i = 0; i < Q; i++)\n        {\n            if (cin.nextint == 0)\n            {\n                S.SegmentUpdate(cin.nextint, cin.nextint, new pair(i, cin.nextint));\n            }\n            else\n            {\n                WriteLine(S.PointQuery(cin.nextint).s);\n            }\n        }\n    }\n\n}\n \n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass SegTree<T>\n{\n    readonly int n;\n    int s, t;\n    T[] tr;\n    readonly Func<T, T, T> f;\n    readonly T exnum;\n\n    /// <summary>\n    ///  セグメントツリーの構築1\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"f\">マージ関数</param>\n    /// <param name=\"ex\">単位元</param>\n    public SegTree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f; exnum = ex; n = 1;\n        while (n < m) n <<= 1;\n        tr = new T[(n << 1) - 1];\n        for (int i = 0; i < tr.Length; i++) tr[i] = ex;\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, T ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini);\n        All_Update();\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, IList<T> ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini[i]);\n        All_Update();\n    }\n    public T Look(int j) => tr[j + n - 1];\n    public T Peek() => tr[0];\n\n\n    /// <summary>\n    /// 最下層に値の代入\n    /// </summary>\n    /// <param name=\"j\">代入するインデックス</param>\n    /// <param name=\"x\">代入する値</param>\n    public void Assign(int j, T x) => tr[j + n - 1] = x;\n    public void Update(int j, T x)\n    {\n        Assign(j, x);\n        Update(j);\n    }\n    public void Update(int j)\n    {\n        int i = j + n - 1;\n        while (i > 0) { i = i - 1 >> 1; tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    }\n    public void All_Update() { for (int i = n - 2; i >= 0; i--) tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    /// <summary>\n    /// return node[s, t] 区間クエリ\n    /// </summary>\n    /// <param name=\"s\">左端 0-indexed</param>\n    /// <param name=\"t\">右端 0-indexed</param>\n    /// <returns>node[s, t]</returns>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; this.s = s; this.t = t; return Query(0, 0, n); }\n    T Query(int k, int l, int r) => r <= s || t <= l ? exnum : s <= l && r <= t ? tr[k]\n                              : f(Query(k << 1 | 1, l, l + r >> 1), Query(k + 1 << 1, l + r >> 1, r));\n\n    /// <summary>\n    ///  j に対する点クエリ\n    /// </summary>\n    /// <param name=\"j\"></param>\n    /// <returns></returns>\n    public T PointQuery(int j)\n    {\n        int i = j + n - 1;\n        var ret = tr[i];\n        while (i > 0) { i = i - 1 >> 1; ret = f(ret, tr[i]); }\n        return ret;\n    }\n    /// <summary>\n    /// [s, t] に対する区間クエリ\n    /// </summary>\n    /// <returns></returns>\n    public void SegmentUpdate(int s, int t, T x) { t++; this.s = s; this.t = t; SegmentUpdate(0, 0, n, x); }\n    void SegmentUpdate(int k, int l, int r, T x)\n    {\n        if (r <= s || t <= l) return;\n        if (s <= l && r <= t) tr[k] = f(tr[k], x);\n        else\n        {\n            SegmentUpdate(k << 1 | 1, l, l + r >> 1, x);\n            SegmentUpdate(k + 1 << 1, l + r >> 1, r, x);\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');\nstatic long n = long.Parse(input[0]);\nstatic long q = long.Parse(input[1]);\nstatic long[] nums = new long[600*600];\nstatic long[] numSets = new long[600];//600*600に分割\nstatic long[] numSetsSub = new long[600];\n\n\tstatic void Main()\n\t{\n    //AreaChangeMinGetReady();\n      //区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める初期値前処理。\n    AreaChangePointGetReady();\n      //区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める初期値前処理。\n      \n    for(long question = 0; question < q; question++)\n    {\n      string[] inputq = Console.ReadLine().Split(' ');\n      long howNum = long.Parse(inputq[0]);\n      \n      if(howNum == 0)//書き換え\n      {\n        int leftNum = int.Parse(inputq[1]);\n        int rightNum = int.Parse(inputq[2]);\n        long changeNum = long.Parse(inputq[3]);\n        AreaChangePointGet(leftNum,rightNum,changeNum);//変更処理の選択\n      }\n      if(howNum == 1)//最小値を求める\n      {\n        int pointNum = int.Parse(inputq[1]);\n        Console.WriteLine(AreaChangePointGet(pointNum));//取得（出力）処理の選択\n      }\n    }\n\t}\n\n  static void AreaChangeMinGetReady()\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める初期値前処理。\n    for(int i = 0; i < 600*600; i++)\n    {\n      nums[i] = 2147483647;\n    }\n    for(int i = 0; i < 600; i++)\n    {\n      numSets[i] = 2147483647;\n      numSetsSub[i] = long.MinValue;\n    } \n  }\n\n  static void AreaChangePointGetReady()\n  {//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める初期値前処理。\n    AreaChangeMinGetReady();\n  }\n\n  static void AreaChangeMinGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める。入力側\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    NumberApply(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)//左右が同じ分類のとき\n    {\n      for(long i = leftNum; i <= rightNum; i++)\n      {\n        nums[i] = changeNum;\n      }\n      long minMemo = long.MaxValue;\n      for(long i = 0; i < 600; i++)//区間内全てを見る\n      {\n        minMemo = Math.Min(minMemo, nums[leftPosition*600+i]);\n      }\n      numSets[leftPosition] = minMemo;\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        nums[i] = changeNum;\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        nums[i] = changeNum;\n      }\n      long minMemoL = long.MaxValue;\n      long minMemoR = long.MaxValue;\n      for(long i = 0; i < 600; i++)//区間内全てを見る\n      {\n        minMemoL = Math.Min(minMemoL, nums[leftPosition*600+i]);\n        minMemoR = Math.Min(minMemoR, nums[rightPosition*600+i]);\n      }\n      numSets[leftPosition] = minMemoL;\n      numSets[rightPosition] = minMemoR;\n      \n      for(int i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        numSetsSub[i] = changeNum;\n        numSets[i] = changeNum;\n      }\n    }\n  }\n\n  static void AreaChangePointGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n    AreaChangeMinGet(leftNum, rightNum, changeNum);\n  }\n\n  static long AreaChangeMinGet(int leftNum, int rightNum)\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める。出力側\n    long minMemo = long.MaxValue;\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    NumberApply(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)\n    {\n      for(long i = leftNum; i <= rightNum; i++)//左右が同じ分類のとき\n      {\n        minMemo = Math.Min(minMemo, nums[i]);\n      }\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        minMemo = Math.Min(minMemo, nums[i]);\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        minMemo = Math.Min(minMemo, nums[i]);\n      }\n      for(long i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        minMemo = Math.Min(minMemo, numSets[i]);\n      }\n    }\n    return minMemo;\n  }\n\n  static long AreaChangePointGet(int pointNum)\n  {//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側\n    int numPosition = WherePosition(pointNum);\n\n    NumberApply(pointNum);\n\n    return nums[pointNum];\n  }\n\n  static void NumberApply(int pointNum)\n  {//控え中の数を個々に割り当てる\n    int numPosition = WherePosition(pointNum);\n\n    if(numSetsSub[numPosition] != long.MinValue)\n    {\n      for(int i = 0; i < 600; i++)//区間内全てを見る\n      {\n        nums[numPosition*600+i] = numSetsSub[numPosition];\n      }\n      numSetsSub[numPosition] = long.MinValue;\n    }\n  }\n\n  static void NumberApply(int leftNum, int rightNum)\n  {\n    NumberApply(leftNum);\n    NumberApply(rightNum);\n  }\n\n  static int WherePosition(int num)//左から何番目の分類に属するか\n  {\n    return num / 600;\n  }\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic int[] segttt = new int[(1<<18)];\nstatic int segkkk = 0;\nstatic int seglll = 0;\nstatic int segrrr = (1<<17);\n//static int[] segValue = new int[900005];\n\nstatic void Main()\n{    \n  string[] input = Console.ReadLine().Split(' ');\n\tint n = int.Parse(input[0]);\n\tint q = int.Parse(input[1]);\n  int aa = 0;\n  //segValue[0] = 2147483647;//初期化\n  for(int i = 1; i <= q; i++)\n  {\n    int[] inputa = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n    if(inputa[0] == 0)\n    {\n      aa = 1;\n      AreaChangePointGetSeg(inputa[1], inputa[2], inputa[3]);\n    }else\n    {\n      int answer = AreaChangePointGetSegAnswer(inputa[1]);\n      Console.WriteLine((answer != 0)?answer:2147483647);\n    }\n  }\n}\n\nstatic void AreaChangePointGetSeg(int a, int b, int x)\n{\n  AreaChangePointGetSegSub(a,b+1,x,segkkk,seglll,segrrr);\n}\n  \nstatic void AreaChangePointGetSegSub(int a, int b, int x, int segkkk, int seglll, int segrrr)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n  if(b <= seglll || segrrr <= a)\n  {\n    b = b;\n  }\n  else if(a <= seglll && segrrr <= b)\n  {\n    segttt[segkkk] = Math.Max(segttt[segkkk],x);\n  }else\n  {\n    int m = (seglll+segrrr)/2;\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+1, seglll, m);\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+2, m, segrrr);\n  }\n}\n  \nstatic int AreaChangePointGetSegAnswer(int i)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側。\n  i += (1<<17)-1;\n  int res = segttt[i];\n  while(i != 0)\n  {\n    i = (i-1)/2;\n    res = Math.Max(res,segttt[i]);\n  }\n  return res;\n}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic int[] segttt = new int[(1<<18)];\nstatic int segkkk = 0;\nstatic int seglll = 0;\nstatic int segrrr = (1<<17);\nstatic int[] segValue = new int[100005];\n\nstatic void Main()\n{    \n  string[] input = Console.ReadLine().Split(' ');\n\tint n = int.Parse(input[0]);\n\tint q = int.Parse(input[1]);\n  segValue[0] = 2147483647;//初期化\n  for(int i = 1; i <= q; i++)\n  {\n    int[] inputa = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n    if(inputa[0] == 0)\n    {\n      segValue[i] = inputa[3];\n      AreaChangePointGetSeg(inputa[1], inputa[2], i);\n    }else\n    {\n      int answer = AreaChangePointGetSegAnswer(inputa[1]);\n      Console.WriteLine(segValue[answer]);\n    }\n  }\n}\n\nstatic void AreaChangePointGetSeg(int a, int b, int x)\n{\n  AreaChangePointGetSegSub(a,b+1,x,segkkk,seglll,segrrr);\n}\n  \nstatic void AreaChangePointGetSegSub(int a, int b, int x, int segkkk, int seglll, int segrrr)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n  if(b <= seglll || segrrr <= a)\n  {\n    b = b;\n  }\n  else if(a <= seglll && segrrr <= b)\n  {\n    segttt[segkkk] = Math.Max(segttt[segkkk],x);\n  }else\n  {\n    int m = (seglll+segrrr)/2;\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+1, seglll, m);\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+2, m, segrrr);\n  }\n}\n  \nstatic int AreaChangePointGetSegAnswer(int i)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側。\n  i += (1<<17)-1;\n  int res = segttt[i];\n  while(i != 0)\n  {\n    i = (i-1)/2;\n    res = Math.Max(res,segttt[i]);\n  }\n  return res;\n}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n\n\n    void Solve()\n    {\n        int n_ = cin.Nextint;\n        int q = cin.Nextint;\n\n        int n = 1;\n        while (n < n_) n <<= 1;\n\n        var S = new RUQ(n, int.MaxValue);\n        var T = new RUQ(n, -1);\n\n        for (int i = 0; i < q; i++)\n        {\n            if (cin.Nextint == 0)\n            {\n                int a = cin.Nextint, b = cin.Nextint, x = cin.Nextint;\n                S.Update(a, b + 1, x, 0, 0, n);\n                T.Update(a, b + 1, i, 0, 0, n);\n            }\n            else\n            {\n                int k = T.Find(cin.Nextint);\n                Console.WriteLine(S.Get(k));\n            }\n        }\n\n    }\n\n}\n\nclass RUQ\n{\n    int n;\n    int[] dat;\n\n    public RUQ(int t, int s)\n    {\n        n = t;\n        dat = Enumerable.Repeat(s, 2 * n - 1).ToArray();\n    }\n\n    //[a, b) update\n    public void Update(int a, int b, int x, int k, int l, int r) // ue-kara\n    {\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) dat[k] = x;\n        else\n        {\n            Update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n            Update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n        }\n\n    }\n    public int Get(int k)\n    {\n        return dat[k];\n    }\n    \n    public int Find(int k) // shita-kara\n    {\n        k += n - 1;\n        int max = dat[k];\n        int res = k;\n        while (k > 0)\n        {\n            k = (k - 1) / 2;\n            if (max < dat[k])\n            {\n                max = dat[k];\n                res = k;\n            }\n        }\n        return res;\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new SegTree<pair>(N, (x, y) => x.CompareTo(y) < 0 ? y : x, new pair(-1, int.MaxValue));\n        for (int i = 0; i < Q; i++)\n        {\n            if (cin.nextint == 0)\n            {\n                S.SegmentUpdate(cin.nextint, cin.nextint, new pair(i, cin.nextint));\n            }\n            else\n            {\n                WriteLine(S.PointQuery(cin.nextint).s);\n            }\n        }\n    }\n\n}\n \n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass SegTree<T>\n{\n    readonly int n;\n    int s, t;\n    T[] tr;\n    readonly Func<T, T, T> f;\n    readonly T exnum;\n\n    /// <summary>\n    ///  セグメントツリーの構築1\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"f\">マージ関数</param>\n    /// <param name=\"ex\">単位元</param>\n    public SegTree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f; exnum = ex; n = 1;\n        while (n < m) n <<= 1;\n        tr = new T[(n << 1) - 1];\n        for (int i = 0; i < tr.Length; i++) tr[i] = ex;\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, T ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini);\n        All_Update();\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, IList<T> ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini[i]);\n        All_Update();\n    }\n    public T Look(int j) => tr[j + n - 1];\n    public T Peek() => tr[0];\n\n\n    /// <summary>\n    /// 最下層に値の代入\n    /// </summary>\n    /// <param name=\"j\">代入するインデックス</param>\n    /// <param name=\"x\">代入する値</param>\n    public void Assign(int j, T x) => tr[j + n - 1] = x;\n    public void Update(int j, T x)\n    {\n        Assign(j, x);\n        Update(j);\n    }\n    public void Update(int j)\n    {\n        int i = j + n - 1;\n        while (i > 0) { i = i - 1 >> 1; tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    }\n    public void All_Update() { for (int i = n - 2; i >= 0; i--) tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    /// <summary>\n    /// return node[s, t] 区間クエリ\n    /// </summary>\n    /// <param name=\"s\">左端 0-indexed</param>\n    /// <param name=\"t\">右端 0-indexed</param>\n    /// <returns>node[s, t]</returns>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; this.s = s; this.t = t; return Query(0, 0, n); }\n    T Query(int k, int l, int r) => r <= s || t <= l ? exnum : s <= l && r <= t ? tr[k]\n                              : f(Query(k << 1 | 1, l, l + r >> 1), Query(k + 1 << 1, l + r >> 1, r));\n\n    /// <summary>\n    ///  j に対する点クエリ\n    /// </summary>\n    /// <param name=\"j\"></param>\n    /// <returns></returns>\n    public T PointQuery(int j)\n    {\n        int i = j + n - 1;\n        var ret = tr[i];\n        while (i > 0) { i = i - 1 >> 1; ret = f(ret, tr[i]); }\n        return ret;\n    }\n    /// <summary>\n    /// [s, t] に対する区間クエリ\n    /// </summary>\n    /// <returns></returns>\n    public void SegmentUpdate(int s, int t, T x) { t++; this.s = s; this.t = t; SegmentUpdate(0, 0, n, x); }\n    void SegmentUpdate(int k, int l, int r, T x)\n    {\n        if (r <= s || t <= l) return;\n        if (s <= l && r <= t) tr[k] = f(tr[k], x);\n        else\n        {\n            SegmentUpdate(k << 1 | 1, l, l + r >> 1, x);\n            SegmentUpdate(k + 1 << 1, l + r >> 1, r, x);\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic int[] segttt = new int[(1<<18)];\nstatic int segkkk = 0;\nstatic int seglll = 0;\nstatic int segrrr = (1<<17);\n\nstatic void Main()\n{    \n  string[] input = Console.ReadLine().Split(' ');\n\tint n = int.Parse(input[0]);\n\tint q = int.Parse(input[1]);\n  for(int i = 1; i <= q; i++)\n  {\n    int[] inputa = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n    if(inputa[0] == 0)\n    {\n      AreaChangePointGetSeg(inputa[1], inputa[2], inputa[3]);\n    }else\n    {\n      Console.WriteLine(AreaChangePointGetSegAnswer(inputa[1]));\n    }\n  }\n}\n\nstatic void AreaChangePointGetSeg(int a, int b, int x)\n{\n  AreaChangePointGetSegSub(a,b+1,x,segkkk,seglll,segrrr);\n}\n  \nstatic void AreaChangePointGetSegSub(int a, int b, int x, int segkkk, int seglll, int segrrr)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n  if(b <= seglll || segrrr <= a)\n  {\n    b = b;\n  }\n  else if(a <= seglll && segrrr <= b)\n  {\n    segttt[segkkk] = Math.Max(segttt[segkkk],x);\n  }else\n  {\n    int m = (seglll+segrrr)/2;\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+1, seglll, m);\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+2, m, segrrr);\n  }\n}\n  \nstatic int AreaChangePointGetSegAnswer(int i)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側。\n  i += (1<<17)-1;\n  int res = segttt[i];\n  while(i != 0)\n  {\n    i = (i-1)/2;\n    res = Math.Max(res,segttt[i]);\n  }\n  return res;\n}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new SegTree<pair>(N, (x, y) => x.CompareTo(y) < 0 ? y : x, new pair(-1, int.MaxValue));\n        for (int i = 0; i < Q; i++)\n        {\n            if (cin.nextint == 0)\n            {\n                S.SegmentUpdate(cin.nextint, cin.nextint, new pair(i, cin.nextint));\n            }\n            else\n            {\n                WriteLine(S.PointQuery(cin.nextint).s);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass SegTree<T>\n{\n    readonly int n;\n    int s, t;\n    T[] tr;\n    readonly Func<T, T, T> f;\n    readonly T exnum;\n\n    /// <summary>\n    ///  セグメントツリーの構築1\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"f\">マージ関数</param>\n    /// <param name=\"ex\">単位元</param>\n    public SegTree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f; exnum = ex; n = 1;\n        while (n < m) n <<= 1;\n        tr = new T[(n << 1) - 1];\n        for (int i = 0; i < tr.Length; i++) tr[i] = ex;\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, T ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini);\n        All_Update();\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, IList<T> ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini[i]);\n        All_Update();\n    }\n    /// <summary>\n    /// 最下層に値の代入\n    /// </summary>\n    /// <param name=\"j\">代入するインデックス</param>\n    /// <param name=\"x\">代入する値</param>\n    public void Assign(int j, T x) => tr[j + n - 1] = x;\n    public void Update(int j, T x)\n    {\n        Assign(j, x);\n        Update(j);\n    }\n    public void Update(int j)\n    {\n        int i = j + n - 1;\n        while (i > 0) { i = i - 1 >> 1; tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    }\n    public void All_Update() { for (int i = n - 2; i >= 0; i--) tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    public T Look(int j) => tr[j + n - 1];\n    public T Peek() => tr[0];\n\n    /// <summary>\n    /// return node[s, t] 区間クエリ\n    /// </summary>\n    /// <param name=\"s\">左端 0-indexed</param>\n    /// <param name=\"t\">右端 0-indexed</param>\n    /// <returns>node[s, t]</returns>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; this.s = s; this.t = t; return Query(0, 0, n); }\n    T Query(int k, int l, int r) => r <= s || t <= l ? exnum : s <= l && r <= t ? tr[k]\n                              : f(Query(k << 1 | 1, l, l + r >> 1), Query(k + 1 << 1, l + r >> 1, r));\n\n    /// <summary>\n    ///  j に対する点クエリ\n    /// </summary>\n    /// <param name=\"j\"></param>\n    /// <returns></returns>\n    public T PointQuery(int j)\n    {\n        int i = j + n - 1;\n        var ret = tr[i];\n        while (i > 0) { i = i - 1 >> 1; ret = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n        return ret;\n    }\n    /// <summary>\n    /// [s, t] に対する区間クエリ\n    /// </summary>\n    /// <returns></returns>\n    public void SegmentUpdate(int s, int t, T x) { t++; this.s = s; this.t = t; SegmentUpdate(0, 0, n, x); }\n    T SegmentUpdate(int k, int l, int r, T x) => r <= s || t <= l ? tr[k] : s <= l && r <= t ? tr[k] = x\n                              : tr[k] = f(SegmentUpdate(k << 1 | 1, l, l + r >> 1, x), SegmentUpdate(k + 1 << 1, l + r >> 1, r, x));\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Debug = System.Diagnostics.Debug;\nusing static System.Math;\nusing static Reader;\nusing System.Runtime.CompilerServices;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\nstatic class P\n{\n    const int inf = int.MaxValue;\n    static void Main()\n    {\n        SegmentTree<int> segTree = new SegmentTree<int>(NextInt, inf, (x, y) => y == inf ? x : y);\n        int q = NextInt;\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < q; i++)\n        {\n            if (NextInt == 0)\n                segTree.Operate(NextInt, NextInt, NextInt);\n            else\n                builder.AppendLine(segTree[NextInt].ToString());\n        }\n        Console.Write(builder.ToString());\n    }\n}\n\nstatic class Reader\n{\n    const int BUF_SIZE = 1 << 12;\n    static Stream Stream = Console.OpenStandardInput();\n    static byte[] Buffer = new byte[BUF_SIZE];\n    static int ptr = 0;\n    static void Move() { if (++ptr >= Buffer.Length) { Stream.Read(Buffer, 0, BUF_SIZE); ptr = 0; } }\n    public static int NextInt\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get\n        {\n            int res = 0; while (Buffer[ptr] < 48) Move();\n            do { res = res * 10 + (Buffer[ptr] ^ 48); Move(); } while (48 <= Buffer[ptr]);\n            return res;\n        }\n    }\n    public static uint NextUInt\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get\n        {\n            uint res = 0; while (Buffer[ptr] < 48) Move();\n            do { res = res * 10 + (uint)(Buffer[ptr] ^ 48); Move(); } while (48 <= Buffer[ptr]);\n            return res;\n        }\n    }\n}\n\n\nclass SegmentTree<T>\n{\n    public readonly int Size;\n    T Identity;\n    Func<T, T, T> Merge;\n    int LeafCount;\n    int Height;\n    T[] Operators;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public SegmentTree(int size, T identity, Func<T, T, T> merge)\n    {\n        Size = size;\n        Identity = identity;\n        Merge = merge;\n        Height = 1;\n        LeafCount = 1;\n        while (LeafCount < size) { Height++; LeafCount <<= 1; }\n        Operators = new T[LeafCount << 1];\n        for (int i = 0; i < Operators.Length; i++) Operators[i] = identity;\n    }\n\n    public T this[int index]\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get { return Query(index); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        set { Propagate(index += LeafCount); Operators[index] = value; }\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Operate(int l, int r, T x)\n    {\n        l += LeafCount;\n        r += LeafCount;\n        Propagate(l, r);\n        while (l <= r)\n        {\n            if ((l & 1) == 1) Operators[l] = Merge(Operators[l], x);\n            if ((r & 1) == 0) Operators[r] = Merge(Operators[r], x);\n            l = (l + 1) >> 1;\n            r = (r - 1) >> 1;\n        }\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Query(int index)\n    {\n        index += LeafCount;\n        Propagate(index);\n        return Operators[index];\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Propagate(int sectionIndex)\n    {\n        for (int i = Height - 1; i >= 1; i--)\n        {\n            var section = sectionIndex >> i;\n            var leftChild = sectionIndex >> (i - 1);\n            var rightChild = leftChild ^ 1;\n            Operators[leftChild] = Merge(Operators[leftChild], Operators[section]);\n            Operators[rightChild] = Merge(Operators[rightChild], Operators[section]);\n            Operators[section] = Identity;\n        }\n    }\n\n    private void Propagate(int l, int r)\n    {\n        if (l == r) { Propagate(l); return; }\n        int xor = l ^ r, i = Height - 1;\n        for (; (xor >> i) == 0; i--)\n        {\n            var section = l >> i;\n            var leftChild = l >> (i - 1);\n            var rightChild = leftChild ^ 1;\n            Operators[leftChild] = Merge(Operators[leftChild], Operators[section]);\n            Operators[rightChild] = Merge(Operators[rightChild], Operators[section]);\n            Operators[section] = Identity;\n        }\n        for (; i >= 1; i--) \n        {\n            var section = l >> i;\n            var leftChild = l >> (i - 1);\n            var rightChild = leftChild ^ 1;\n            Operators[leftChild] = Merge(Operators[leftChild], Operators[section]);\n            Operators[rightChild] = Merge(Operators[rightChild], Operators[section]);\n            Operators[section] = Identity;\n\n            section = r >> i;\n            leftChild = r >> (i - 1);\n            rightChild = leftChild ^ 1;\n            Operators[leftChild] = Merge(Operators[leftChild], Operators[section]);\n            Operators[rightChild] = Merge(Operators[rightChild], Operators[section]);\n            Operators[section] = Identity;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new SegTree<pair>(N, (x, y) => x.CompareTo(y) < 0 ? y : x, new pair(-1, int.MaxValue));\n        for (int i = 0; i < Q; i++)\n        {\n            if (cin.nextint == 0)\n            {\n                S.SegmentUpdate(cin.nextint, cin.nextint, new pair(i, cin.nextint));\n            }\n            else\n            {\n                WriteLine(S.PointQuery(cin.nextint).s);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass SegTree<T>\n{\n    readonly int n;\n    int s, t;\n    T[] tr;\n    readonly Func<T, T, T> f;\n    readonly T exnum;\n\n    /// <summary>\n    ///  セグメントツリーの構築1\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"f\">マージ関数</param>\n    /// <param name=\"ex\">単位元</param>\n    public SegTree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f; exnum = ex; n = 1;\n        while (n < m) n <<= 1;\n        tr = new T[(n << 1) - 1];\n        for (int i = 0; i < tr.Length; i++) tr[i] = ex;\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, T ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini);\n        All_Update();\n    }\n    public SegTree(int m, Func<T, T, T> f, T ex, IList<T> ini) : this(m, f, ex)\n    {\n        for (int i = 0; i < m; i++) Assign(i, ini[i]);\n        All_Update();\n    }\n\n    /// <summary>\n    /// 最下層に値の代入\n    /// </summary>\n    /// <param name=\"j\">代入するインデックス</param>\n    /// <param name=\"x\">代入する値</param>\n    public void Assign(int j, T x) => tr[j + n - 1] = x;\n    public void Update(int j, T x)\n    {\n        Assign(j, x);\n        Update(j);\n    }\n    public void Update(int j)\n    {\n        int i = j + n - 1;\n        while (i > 0) { i = i - 1 >> 1; tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    }\n    public void All_Update() { for (int i = n - 2; i >= 0; i--) tr[i] = f(tr[i << 1 | 1], tr[i + 1 << 1]); }\n    public T Look(int j) => tr[j + n - 1];\n    public T Peek() => tr[0];\n\n    /// <summary>\n    /// return node[s, t] 区間クエリ\n    /// </summary>\n    /// <param name=\"s\">左端 0-indexed</param>\n    /// <param name=\"t\">右端 0-indexed</param>\n    /// <returns>node[s, t]</returns>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; this.s = s; this.t = t; return Query(0, 0, n); }\n    T Query(int k, int l, int r) => r <= s || t <= l ? exnum : s <= l && r <= t ? tr[k]\n                              : f(Query(k << 1 | 1, l, l + r >> 1), Query(k + 1 << 1, l + r >> 1, r));\n\n    /// <summary>\n    ///  j に対する点クエリ\n    /// </summary>\n    /// <param name=\"j\"></param>\n    /// <returns></returns>\n    public T PointQuery(int j)\n    {\n        int i = j + n - 1;\n        var ret = tr[i];\n        while (i > 0) { i = i - 1 >> 1; ret = f(ret, tr[i]); }\n        return ret;\n    }\n    /// <summary>\n    /// [s, t] に対する区間クエリ\n    /// </summary>\n    /// <returns></returns>\n    public void SegmentUpdate(int s, int t, T x) { t++; this.s = s; this.t = t; SegmentUpdate(0, 0, n, x); }\n    void SegmentUpdate(int k, int l, int r, T x)\n    {\n        if (r <= s || t <= l) return;\n        if (s <= l && r <= t) tr[k] = x;\n        else\n        {\n            SegmentUpdate(k << 1 | 1, l, l + r >> 1, x);\n            SegmentUpdate(k + 1 << 1, l + r >> 1, r, x);\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, Q;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadIntArray();\n                N = line[0];\n                Q = line[1];\n            }\n\n            var S = new SegTree(N);\n\n            for(int i = 0; i < Q; i++)\n            {\n                var line = Input.ReadIntArray();\n                int C = line[0];\n                if (C == 0)\n                {\n                    int s = line[1];\n                    int t = line[2];\n                    int x = line[3];\n                    if (C == 0) S.Update(s, t+1, x);\n                }\n                else\n                {\n                    int id = line[1];\n                    Console.WriteLine(S.Query(id));\n                }\n            }\n\n        }\n    }\n\n    // libs ----------\n    internal class SegTree\n    {\n        public int N;\n        public int NCells;\n        public int[] Data;\n        public int[] KL; // 範囲のbegin\n        public int[] KR; // 範囲のend（そのセルは含まない）\n        public const int Dummy = -1; \n\n        public SegTree(int _n)\n        {\n            Init(_n);\n        }\n\n        private int GetN(int _n)\n        {\n            int n = 1;\n            while (n < _n) n *= 2;\n            return n;\n        }\n\n        private void Init(int _n, int initialValue = Dummy)\n        {\n            N = GetN(_n);\n            NCells = 2 * N - 1;\n\n            Data = new int[NCells];\n            KL = new int[NCells];\n            KR = new int[NCells];\n\n            // KL, KRの初期化\n            for (int k = 0; k < NCells; k++)\n            {\n                if (IsRoot(k))\n                {\n                    KL[k] = 0;\n                    KR[k] = N;\n                }\n                else\n                {\n                    if (IsChildL(k))\n                    {\n                        KL[k] = KL[Parent(k)];\n                        KR[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                    }\n                    else\n                    {\n                        KL[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                        KR[k] = KR[Parent(k)];\n                    }\n                }\n            }\n\n            // 値の初期化\n            for (int k = 0; k < NCells; k++) Data[k] = initialValue;\n\n            // 全体に初期値をセット\n            Update(0, N, 2147483647);\n        }\n\n        // i番目のみの値を保持するセル\n        public int Pos(int i) { return i + N - 1; }\n\n        // 親セル・子セル\n        public int Parent(int k) { return (k - 1) / 2; }\n        public int ChildL(int k) { return k * 2 + 1; }\n        public int ChildR(int k) { return k * 2 + 2; }\n\n        // 根かどうか\n        public bool IsRoot(int k) { return k == 0; }\n\n        // 左側の子かどうか\n        public bool IsChildL(int k)\n        {\n            if (IsRoot(k)) return false;\n            return ChildL(Parent(k)) == k;\n        }\n        \n        // Update - top down\n        public void Update(int il, int ir, int a)\n        {\n            update(il, ir, 0, a);\n\n            /*\n            Console.WriteLine(\"--------------\");\n            for (int i = 0; i < NCells; i++)\n            {\n                Console.Write(Data[i] + \" \");\n            }\n            Console.WriteLine();\n            Console.WriteLine(\"--------------\");\n            */\n        }\n\n        private void update(int il, int ir, int k, int a)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return;\n\n            // 完全に重複している場合にその値をセット\n            if (il <= kl && kr <= ir) Data[k] = a;\n            else\n            {\n                // そうでない場合、上の値を分配\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                // 子の処理を行う\n                update(il, ir, ChildL(k), a);\n                update(il, ir, ChildR(k), a);\n            }\n        }\n\n        // Query - bottom up\n        public int Query(int i)\n        {\n            // 一番上層にある有効な値をセットする\n            int ret = -1;\n            int k = Pos(i);\n\n            while (true)\n            {\n                if (Data[k] != Dummy) ret = Data[k];\n                if (IsRoot(k)) break;\n                k = Parent(k);\n            }\n\n            return ret;\n        }\n\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new LazySegtree<int, int>(N, (x, y) => (x == int.MaxValue ? y : x), \n            (x, y, len) => y, (x, y) => y, int.MaxValue);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, cin.nextint);\n            }\n            else if (com == 1)\n            {\n                int x = cin.nextint;\n                WriteLine(S.Run(x, x));\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass LazySegtree<T, U>\n{\n    readonly int n;\n    T[] data;\n    U[] lazy;\n    readonly bool[] is_lazy;\n    readonly Func<T, T, T> calc;\n    readonly Func<T, U, int, T> apply;\n    readonly Func<U, U, U> merge;\n    readonly T ex_data;\n\n    /// <summary>\n    /// 遅延セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"calc\">要素のマージ</param>\n    /// <param name=\"apply\">要素に作用素を作用</param>\n    /// <param name=\"merge\">作用素のマージ</param>\n    /// <param name=\"ex_data\">単位元</param>\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data)\n    {\n        this.calc = calc;\n        this.apply = apply;\n        this.merge = merge;\n        this.ex_data = ex_data;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[n * 2 - 1];\n        lazy = new U[n * 2 - 1];\n        is_lazy = new bool[n * 2 - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = ex_data;\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, T ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini;\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, IList<T> ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini[i];\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    void assign_lazy(int k, U x)\n    {\n        if (k >= lazy.Length) return;\n        if (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n        else\n        {\n            is_lazy[k] = true;\n            lazy[k] = x;\n        }\n    }\n    void eval(int k, int len)\n    {\n        if (!is_lazy[k]) return;\n        assign_lazy(k * 2 + 1, lazy[k]);\n        assign_lazy(k * 2 + 2, lazy[k]);\n        data[k] = apply(data[k], lazy[k], len);\n        is_lazy[k] = false;\n    }\n    T update(int s, int t, U x, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return data[k];\n        if (s <= l && r <= t)\n        {\n            assign_lazy(k, x);\n            return apply(data[k], lazy[k], r - l);\n        }\n        return data[k] = calc(update(s, t, x, k * 2 + 1, l, (l + r) / 2),\n                              update(s, t, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T run(int s, int t, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return ex_data;\n        if (s <= l && r <= t) return data[k];\n        return calc(run(s, t, k * 2 + 1, l, (l + r) / 2),\n                    run(s, t, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    /// <summary>update [s, t]</summary>\n    public void Update(int s, int t, U x) { t++; update(s, t, x, 0, 0, n); }\n    /// <summary>return node[s, t]</summary>\n    public T Run(int s, int t) { t++; return run(s, t, 0, 0, n); }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new LazySegtree<int, int>(N, Min, (x, y, len) => y, (x, y) => y, int.MaxValue);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, cin.nextint);\n            }\n            else if (com == 1)\n            {\n                int x = cin.nextint;\n                WriteLine(S[x, x]);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass LazySegtree<T, U>\n{\n    readonly int n;\n    T[] data;\n    U[] lazy;\n    readonly bool[] is_lazy;\n    readonly Func<T, T, T> calc;\n    readonly Func<T, U, int, T> apply;\n    readonly Func<U, U, U> merge;\n    readonly T ex_data;\n\n    /// <summary>\n    /// 遅延セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"calc\">要素のマージ</param>\n    /// <param name=\"apply\">要素に作用素を作用</param>\n    /// <param name=\"merge\">作用素のマージ</param>\n    /// <param name=\"ex_data\">単位元</param>\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data)\n    {\n        this.calc = calc;\n        this.apply = apply;\n        this.merge = merge;\n        this.ex_data = ex_data;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[n * 2 - 1];\n        lazy = new U[n * 2 - 1];\n        is_lazy = new bool[n * 2 - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = ex_data;\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, T ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini;\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, IList<T> ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini[i];\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    void assign_lazy(int k, U x)\n    {\n        if (k >= lazy.Length) return;\n        if (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n        else\n        {\n            is_lazy[k] = true;\n            lazy[k] = x;\n        }\n    }\n    void eval(int k, int len)\n    {\n        if (!is_lazy[k]) return;\n        assign_lazy(k * 2 + 1, lazy[k]);\n        assign_lazy(k * 2 + 2, lazy[k]);\n        data[k] = apply(data[k], lazy[k], len);\n        is_lazy[k] = false;\n    }\n    T update(int s, int t, U x, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return data[k];\n        if (s <= l && r <= t)\n        {\n            assign_lazy(k, x);\n            return apply(data[k], lazy[k], r - l);\n        }\n        return data[k] = calc(update(s, t, x, k * 2 + 1, l, (l + r) / 2),\n                              update(s, t, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T run(int s, int t, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return ex_data;\n        if (s <= l && r <= t) return data[k];\n        return calc(run(s, t, k * 2 + 1, l, (l + r) / 2),\n                    run(s, t, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    /// <summary>update [s, t]</summary>\n    public void Update(int s, int t, U x) { t++; update(s, t, x, 0, 0, n); }\n    /// <summary>return node[s, t]</summary>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; return run(s, t, 0, 0, n); }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, Q;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadIntArray();\n                N = line[0];\n                Q = line[1];\n            }\n\n            var S = new SegTree(N);\n\n            for(int i = 0; i < Q; i++)\n            {\n                var line = Input.ReadIntArray();\n                int C = line[0];\n                if (C == 0)\n                {\n                    int s = line[1];\n                    int t = line[2];\n                    int x = line[3];\n                    if (C == 0) S.Update(s, t+1, x);\n                }\n                else\n                {\n                    int id = line[1];\n                    Console.WriteLine(S.Query(id));\n                }\n            }\n\n        }\n    }\n\n    // libs ----------\n    internal class SegTree\n    {\n        public static bool DEBUG = false;\n\n        public int N;\n        public int NCells;\n        public int H;\n        public int[] Data;\n        public int[] KL; // 範囲のbegin\n        public int[] KR; // 範囲のend（そのセルは含まない）\n        public const int Dummy = -1; \n\n        public SegTree(int _n)\n        {\n            Init(_n);\n        }\n\n        private int GetN(int _n)\n        {\n            int n = 1;\n            H = 1;\n            while (n < _n)\n            {\n                n *= 2;\n                H++;\n            }\n            return n;\n        }\n\n        private void Init(int _n, int initialValue = Dummy)\n        {\n            N = GetN(_n);\n            NCells = 2 * N - 1;\n\n            Data = new int[NCells];\n            KL = new int[NCells];\n            KR = new int[NCells];\n\n            // KL, KRの初期化\n            for (int k = 0; k < NCells; k++)\n            {\n                if (IsRoot(k))\n                {\n                    KL[k] = 0;\n                    KR[k] = N;\n                }\n                else\n                {\n                    if (IsChildL(k))\n                    {\n                        KL[k] = KL[Parent(k)];\n                        KR[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                    }\n                    else\n                    {\n                        KL[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                        KR[k] = KR[Parent(k)];\n                    }\n                }\n            }\n\n            // 値の初期化\n            for (int k = 0; k < NCells; k++) Data[k] = initialValue;\n\n            // 全体に初期値をセット\n            Update(0, N, 2147483647);\n        }\n\n        // i番目のみの値を保持するセル\n        public int Pos(int i) { return i + N - 1; }\n\n        // 親セル・子セル\n        public int Parent(int k) { return (k - 1) / 2; }\n        public int ChildL(int k) { return k * 2 + 1; }\n        public int ChildR(int k) { return k * 2 + 2; }\n\n        // 根かどうか\n        public bool IsRoot(int k) { return k == 0; }\n\n        // 左側の子かどうか\n        public bool IsChildL(int k)\n        {\n            if (IsRoot(k)) return false;\n            return ChildL(Parent(k)) == k;\n        }\n        \n        // Update - top down\n        public void Update(int il, int ir, int a)\n        {\n            update(il, ir, 0, a);\n\n            if (DEBUG)\n            {\n                Console.WriteLine(\"--------------\");\n                int c = 2;\n                for (int i = 0; i < NCells; i++)\n                {\n                    if (i == c - 1)\n                    {\n                        Console.WriteLine();\n                        c *= 2;\n                    }\n                    Console.Write(Data[i] + \" \");\n                }\n                Console.WriteLine();\n                Console.WriteLine(\"--------------\");\n            }\n        }\n\n        private void update(int il, int ir, int k, int a)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return;\n\n            // 完全に重複している場合にその値をセット\n            if (il <= kl && kr <= ir)\n                Data[k] = a;\n            else\n            {\n                // そうでない場合、上の値を分配\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                // 子の処理を行う\n                update(il, ir, ChildL(k), a);\n                update(il, ir, ChildR(k), a);\n            }\n        }\n\n        // Query - bottom up\n        public int Query(int i)\n        {\n            return query(i, i + 1, 0);\n        }\n\n        private int query(int il, int ir, int k)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n            if (kr <= il || ir <= kl) return Dummy;\n\n            int d = Data[k];\n            if (d != Dummy) return d;\n            \n            int l = query(il, ir, ChildL(k));\n            int r = query(il, ir, ChildR(k));\n            if (l != Dummy) return l;\n            if (r != Dummy) return r;\n            throw new Exception();\n        }\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic int[] segttt = new int[(1<<18)];\nstatic int segkkk = 0;\nstatic int seglll = 0;\nstatic int segrrr = (1<<17);\n//static int[] segValue = new int[900005];\n\nstatic void Main()\n{    \n  string[] input = Console.ReadLine().Split(' ');\n\tint n = int.Parse(input[0]);\n\tint q = int.Parse(input[1]);\n  int aa = 0;\n  //segValue[0] = 2147483647;//初期化\n  for(int i = 1; i <= q; i++)\n  {\n    int[] inputa = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n    if(inputa[0] == 0)\n    {\n      aa = 1;\n      AreaChangePointGetSeg(inputa[1], inputa[2], inputa[3]);\n    }else\n    {\n      Console.WriteLine((aa != 0)?AreaChangePointGetSegAnswer(inputa[1]):2147483647);\n    }\n  }\n}\n\nstatic void AreaChangePointGetSeg(int a, int b, int x)\n{\n  AreaChangePointGetSegSub(a,b+1,x,segkkk,seglll,segrrr);\n}\n  \nstatic void AreaChangePointGetSegSub(int a, int b, int x, int segkkk, int seglll, int segrrr)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n  if(b <= seglll || segrrr <= a)\n  {\n    b = b;\n  }\n  else if(a <= seglll && segrrr <= b)\n  {\n    segttt[segkkk] = Math.Max(segttt[segkkk],x);\n  }else\n  {\n    int m = (seglll+segrrr)/2;\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+1, seglll, m);\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+2, m, segrrr);\n  }\n}\n  \nstatic int AreaChangePointGetSegAnswer(int i)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側。\n  i += (1<<17)-1;\n  int res = segttt[i];\n  while(i != 0)\n  {\n    i = (i-1)/2;\n    res = Math.Max(res,segttt[i]);\n  }\n  return res;\n}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using Debug;\n//using static System.Globalization.CultureInfo;\nusing System.Text;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solve();\n        //WriteLine(Solve());\n    }\n    static void Solve()\n    {\n        var nq = Input.ar;\n        var time = 0;\n        Func<Pair<int, int>, Pair<int, int>, Pair<int, int>>\n            func = (Pair<int, int> p1, Pair<int, int> p2) => p1.v2 > p2.v2 ? p1 : p2;\n        var seg = new SegmentTree<Pair<int, int>>(nq[0], new Pair<int, int>(int.MaxValue, 0), func);\n        while (nq[1]-- > 0)\n        {\n            var q = Input.ar;\n            if (q[0] == 0)\n            {\n                seg.Update(q[1], q[2]+1, new Pair<int, int>(q[3], ++time));\n            }\n            else WriteLine(seg.Query(q[1]).v1);\n        }\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine();\n    public  static int[] ar => Array.ConvertAll(read.Split(' '), int.Parse);\n    public  static int num => ToInt32(read);\n    public static long[] arL => Array.ConvertAll(read.Split(' '), long.Parse);\n    public  static long numL => ToInt64(read);\n    public static char[][] gred(int h) \n        => Enumerable.Repeat(0, h).Select(v => read.ToCharArray()).ToArray();\n    public static int[][] ar2D(int num)\n        => Enumerable.Repeat(0, num).Select(v => ar).ToArray();\n    public static long[][] arL2D(int num)\n        => Enumerable.Repeat(0, num).Select(v => arL).ToArray();\n    public static T getValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        return default(T);\n    }\n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public  const string Alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public  const int MOD = 1000000007;\n}\npublic class SegmentTree<T>\n{\n    private readonly List<T> item;\n    private readonly int _num;\n    private readonly Func<T, T, T> _func;\n    private readonly Func<T, T, T> updateFunc;\n    private readonly T _init;\n\n    private int Parent(int index)\n        => (index - 1) / 2;\n    private int Left(int index)\n        => 2 * index + 1;\n    private int Right(int index)\n        => 2 * (index + 1);\n\n    public SegmentTree(int num, T init, Func<T, T, T> func, Func<T, T, T> updateFunc = null)\n    {\n        _func = func;\n        _num = 1;\n        _init = init;\n        this.updateFunc = updateFunc ?? ((T val1, T val2) => val2);\n        while (_num < num)\n            _num *= 2;\n        item = new List<T>(2 * _num - 1);\n        for (var i = 0; i < 2 * _num - 1; i++)\n            item.Add(init);\n    }\n    public void Update(int index, T value)\n    {\n        index += _num - 1;\n        item[index] = updateFunc(item[index], value);\n        while (index > 0)\n        {\n            index = Parent(index);\n            item[index] = _func(item[Left(index)], item[Right(index)]);\n        }\n    }\n    public void Update(int left, int right, T value)\n        => Update(left, right, 0, 0, _num, value);\n    private void Update(int left, int right, int k, int l, int r, T value)\n    {\n        if (r <= left || right <= l) return;\n        if (left <= l && r <= right) item[k] = updateFunc(item[k], value);\n        else\n        {\n            Update(left, right, Left(k), l, (l + r) / 2, value);\n            Update(left, right, Right(k), (l + r) / 2, r, value);\n        }\n    }\n    public T Query(int index)\n    {\n        index += _num - 1;\n        var value = _func(_init, item[index]);\n        while (index > 0)\n        {\n            index = Parent(index);\n            value = _func(value, item[index]);\n        }\n        return value;\n    }\n    public T Query(int left, int right)\n        => Query(left, right, 0, 0, _num);\n    private T Query(int left, int right, int k, int l, int r)\n    {\n        if (r <= left || right <= l) return _init;\n        if (left <= l && r <= right) return item[k];\n        else\n            return _func(Query(left, right, Left(k), l, (l + r) / 2), Query(left, right, Right(k), (l + r) / 2, r));\n    }\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() : this(default(T1), default(T2)) { }\n    public Pair(T1 v1,T2 v2)\n    {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public static Pair<T1, T2> makePair()\n    {\n        var r = ReadLine().Split(' ');\n        return new Pair<T1, T2>(Input.getValue<T1>(r[0]), Input.getValue<T2>(r[1]));\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new LazySegtree<int, int>(N, Min, (x, y, len) => y, (x, y) => y, int.MaxValue);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, cin.nextint);\n            }\n            else if (com == 1)\n            {\n                WriteLine(S[cin.nextint, cin.nextint]);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass LazySegtree<T, U>\n{\n    readonly int n;\n    T[] data;\n    U[] lazy;\n    readonly bool[] is_lazy;\n    readonly Func<T, T, T> calc;\n    readonly Func<T, U, int, T> apply;\n    readonly Func<U, U, U> merge;\n    readonly T ex_data;\n\n    /// <summary>\n    /// 遅延セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"calc\">要素のマージ</param>\n    /// <param name=\"apply\">要素に作用素を作用</param>\n    /// <param name=\"merge\">作用素のマージ</param>\n    /// <param name=\"ex_data\">単位元</param>\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data)\n    {\n        this.calc = calc;\n        this.apply = apply;\n        this.merge = merge;\n        this.ex_data = ex_data;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[n * 2 - 1];\n        lazy = new U[n * 2 - 1];\n        is_lazy = new bool[n * 2 - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = ex_data;\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, T ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini;\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, IList<T> ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini[i];\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    void assign_lazy(int k, U x)\n    {\n        if (k >= lazy.Length) return;\n        if (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n        else\n        {\n            is_lazy[k] = true;\n            lazy[k] = x;\n        }\n    }\n    void eval(int k, int len)\n    {\n        if (!is_lazy[k]) return;\n        assign_lazy(k * 2 + 1, lazy[k]);\n        assign_lazy(k * 2 + 2, lazy[k]);\n        data[k] = apply(data[k], lazy[k], len);\n        is_lazy[k] = false;\n    }\n    T update(int s, int t, U x, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return data[k];\n        if (s <= l && r <= t)\n        {\n            assign_lazy(k, x);\n            return apply(data[k], lazy[k], r - l);\n        }\n        return data[k] = calc(update(s, t, x, k * 2 + 1, l, (l + r) / 2),\n                              update(s, t, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T run(int s, int t, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return ex_data;\n        if (s <= l && r <= t) return data[k];\n        return calc(run(s, t, k * 2 + 1, l, (l + r) / 2),\n                    run(s, t, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    /// <summary>update [s, t]</summary>\n    public void Update(int s, int t, U x) { t++; update(s, t, x, 0, 0, n); }\n    /// <summary>return node[s, t]</summary>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; return run(s, t, 0, 0, n); }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, Q;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadIntArray();\n                N = line[0];\n                Q = line[1];\n            }\n\n            var S = new SegTree(N);\n\n            for(int i = 0; i < Q; i++)\n            {\n                var line = Input.ReadIntArray();\n                int C = line[0];\n                if (C == 0)\n                {\n                    int s = line[1];\n                    int t = line[2];\n                    int x = line[3];\n                    if (C == 0) S.Update(s, t+1, x);\n                }\n                else\n                {\n                    int id = line[1];\n                    Console.WriteLine(S.Query(id));\n                }\n            }\n\n        }\n    }\n\n    // libs ----------\n    internal class SegTree\n    {\n        public int N;\n        public int NCells;\n        public int[] Data;\n        public int[] KL; // 範囲のbegin\n        public int[] KR; // 範囲のend（そのセルは含まない）\n        public const int Dummy = -1; \n\n        public SegTree(int _n)\n        {\n            Init(_n);\n        }\n\n        private int GetN(int _n)\n        {\n            int n = 1;\n            while (n < _n) n *= 2;\n            return n;\n        }\n\n        private void Init(int _n, int initialValue = Dummy)\n        {\n            N = GetN(_n);\n            NCells = 2 * N - 1;\n\n            Data = new int[NCells];\n            KL = new int[NCells];\n            KR = new int[NCells];\n\n            // KL, KRの初期化\n            for (int k = 0; k < NCells; k++)\n            {\n                if (IsRoot(k))\n                {\n                    KL[k] = 0;\n                    KR[k] = N;\n                }\n                else\n                {\n                    if (IsChildL(k))\n                    {\n                        KL[k] = KL[Parent(k)];\n                        KR[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                    }\n                    else\n                    {\n                        KL[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                        KR[k] = KR[Parent(k)];\n                    }\n                }\n            }\n\n            // 値の初期化\n            for (int k = 0; k < NCells; k++) Data[k] = initialValue;\n\n            // 全体に初期値をセット\n            Update(0, N, 2147483647);\n        }\n\n        // i番目のみの値を保持するセル\n        public int Pos(int i) { return i + N - 1; }\n\n        // 親セル・子セル\n        public int Parent(int k) { return (k - 1) / 2; }\n        public int ChildL(int k) { return k * 2 + 1; }\n        public int ChildR(int k) { return k * 2 + 2; }\n\n        // 根かどうか\n        public bool IsRoot(int k) { return k == 0; }\n\n        // 左側の子かどうか\n        public bool IsChildL(int k)\n        {\n            if (IsRoot(k)) return false;\n            return ChildL(Parent(k)) == k;\n        }\n        \n        // Update - top down\n        public void Update(int il, int ir, int a)\n        {\n            update(il, ir, 0, a);\n\n            /*\n            Console.WriteLine(\"--------------\");\n            for (int i = 0; i < NCells; i++)\n            {\n                Console.Write(Data[i] + \" \");\n            }\n            Console.WriteLine();\n            Console.WriteLine(\"--------------\");\n            */\n        }\n\n        private void update(int il, int ir, int k, int a)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return;\n\n            // 完全に重複している場合にその値をセット\n            if (il <= kl && kr <= ir)\n                Data[k] = a;\n            else\n            {\n                // そうでない場合、上の値を分配\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                // 子の処理を行う\n                update(il, ir, ChildL(k), a);\n                update(il, ir, ChildR(k), a);\n            }\n        }\n\n        // Query - bottom up\n        public int Query(int i)\n        {\n            return query(i, i + 1, 0);\n        }\n\n        private int query(int il, int ir, int k)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return Dummy;\n\n            if (il <= kl && kr <= ir)\n                return Data[k];\n            else\n            {\n                // 子の処理を行う\n                int l = query(il, ir, ChildL(k));\n                int r = query(il, ir, ChildR(k));\n                if (l != Dummy) return l;\n                if (r != Dummy) return r;\n                throw new Exception();\n            }\n        }\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, Q;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadIntArray();\n                N = line[0];\n                Q = line[1];\n            }\n\n            var S = new SegTree(N);\n\n            for(int i = 0; i < Q; i++)\n            {\n                var line = Input.ReadIntArray();\n                int C = line[0];\n                if (C == 0)\n                {\n                    int s = line[1];\n                    int t = line[2];\n                    int x = line[3];\n                    if (C == 0) S.Update(s, t+1, x);\n                }\n                else\n                {\n                    int id = line[1];\n                    Console.WriteLine(S.Query(id));\n                }\n            }\n\n        }\n    }\n\n    // libs ----------\n    internal class SegTree\n    {\n        public static bool DEBUG = false;\n\n        public int N;\n        public int NCells;\n        public int H;\n        public int[] Data;\n        public int[] KL; // 範囲のbegin\n        public int[] KR; // 範囲のend（そのセルは含まない）\n        public const int Dummy = -1; \n\n        public SegTree(int _n)\n        {\n            Init(_n);\n        }\n\n        private int GetN(int _n)\n        {\n            int n = 1;\n            H = 1;\n            while (n < _n)\n            {\n                n *= 2;\n                H++;\n            }\n            return n;\n        }\n\n        private void Init(int _n, int initialValue = Dummy)\n        {\n            N = GetN(_n);\n            NCells = 2 * N - 1;\n\n            Data = new int[NCells];\n            KL = new int[NCells];\n            KR = new int[NCells];\n\n            // KL, KRの初期化\n            for (int k = 0; k < NCells; k++)\n            {\n                if (IsRoot(k))\n                {\n                    KL[k] = 0;\n                    KR[k] = N;\n                }\n                else\n                {\n                    if (IsChildL(k))\n                    {\n                        KL[k] = KL[Parent(k)];\n                        KR[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                    }\n                    else\n                    {\n                        KL[k] = (KL[Parent(k)] + KR[Parent(k)]) / 2;\n                        KR[k] = KR[Parent(k)];\n                    }\n                }\n            }\n\n            // 値の初期化\n            for (int k = 0; k < NCells; k++) Data[k] = initialValue;\n\n            // 全体に初期値をセット\n            Update(0, N, 2147483647);\n        }\n\n        // i番目のみの値を保持するセル\n        public int Pos(int i) { return i + N - 1; }\n\n        // 親セル・子セル\n        public int Parent(int k) { return (k - 1) / 2; }\n        public int ChildL(int k) { return k * 2 + 1; }\n        public int ChildR(int k) { return k * 2 + 2; }\n\n        // 根かどうか\n        public bool IsRoot(int k) { return k == 0; }\n\n        // 左側の子かどうか\n        public bool IsChildL(int k)\n        {\n            if (IsRoot(k)) return false;\n            return ChildL(Parent(k)) == k;\n        }\n        \n        // Update - top down\n        public void Update(int il, int ir, int a)\n        {\n            update(il, ir, 0, a);\n\n            if (DEBUG)\n            {\n                Console.WriteLine(\"--------------\");\n                int c = 2;\n                for (int i = 0; i < NCells; i++)\n                {\n                    if (i == c - 1)\n                    {\n                        Console.WriteLine();\n                        c *= 2;\n                    }\n                    Console.Write(Data[i] + \" \");\n                }\n                Console.WriteLine();\n                Console.WriteLine(\"--------------\");\n            }\n        }\n\n        private void update(int il, int ir, int k, int a)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n\n            if (kr <= il || ir <= kl) return;\n\n            // 完全に重複している場合にその値をセット\n            if (il <= kl && kr <= ir)\n                Data[k] = a;\n            else\n            {\n                // そうでない場合、上の値を分配\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                // 子の処理を行う\n                update(il, ir, ChildL(k), a);\n                update(il, ir, ChildR(k), a);\n            }\n        }\n\n        // Query - bottom up\n        public int Query(int i)\n        {\n            query(i, i + 1, 0);\n            return Data[Pos(i)];\n        }\n\n        private void query(int il, int ir, int k)\n        {\n            int kl = KL[k];\n            int kr = KR[k];\n            if (kr <= il || ir <= kl)\n                return;\n\n            if (il <= kl && kr <= ir)\n                return;\n            else\n            {\n                if (Data[k] != Dummy)\n                {\n                    Data[ChildL(k)] = Data[k];\n                    Data[ChildR(k)] = Data[k];\n                    Data[k] = Dummy;\n                }\n\n                query(il, ir, ChildL(k));\n                query(il, ir, ChildR(k));\n                return;\n            }\n\n        }\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic int[] segttt = new int[(1<<21)];\nstatic int segkkk = 0;\nstatic int seglll = 0;\nstatic int segrrr = (1<<20);\nstatic int[] segValue = new int[800005];\n\nstatic void Main()\n{    \n  string[] input = Console.ReadLine().Split(' ');\n\tint n = int.Parse(input[0]);\n\tint q = int.Parse(input[1]);\n  segValue[0] = 2147483647;//初期化\n  for(int i = 1; i <= q; i++)\n  {\n    int[] inputa = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n    if(inputa[0] == 0)\n    {\n      segValue[i] = inputa[3];\n      AreaChangePointGetSeg(inputa[1], inputa[2], i);\n    }else\n    {\n      int answer = AreaChangePointGetSegAnswer(inputa[1]);\n      Console.WriteLine(segValue[answer]);\n    }\n  }\n}\n\nstatic void AreaChangePointGetSeg(int a, int b, int x)\n{\n  AreaChangePointGetSegSub(a,b+1,x,segkkk,seglll,segrrr);\n}\n  \nstatic void AreaChangePointGetSegSub(int a, int b, int x, int segkkk, int seglll, int segrrr)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n  if(b <= seglll || segrrr <= a)\n  {\n    b = b;\n  }\n  else if(a <= seglll && segrrr <= b)\n  {\n    segttt[segkkk] = Math.Max(segttt[segkkk],x);\n  }else\n  {\n    int m = (seglll+segrrr)/2;\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+1, seglll, m);\n    AreaChangePointGetSegSub(a, b, x, segkkk*2+2, m, segrrr);\n  }\n}\n  \nstatic int AreaChangePointGetSegAnswer(int i)\n{//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側。\n  i += (1<<20)-1;\n  int res = segttt[i];\n  while(i != 0)\n  {\n    i = (i-1)/2;\n    res = Math.Max(res,segttt[i]);\n  }\n  return res;\n}\n\n}\n"
  },
  {
    "language": "Ruby",
    "code": "def update(s, t, x, l, r, k)\n  if s == l && t == r then\n    $d[k] = x\n  else\n    if $d[k] > 0 then\n      $d[2*k+1] = $d[2*k+2] = $d[k]\n      $d[k] = -1\n    end\n    m = (l + r)/2\n    if t <= m then\n      update(s, t, x, l, m, 2*k+1)\n    elsif m <= s then\n      update(s, t, x, m, r, 2*k+2)\n    else\n      update(s, m, x, l, m, 2*k+1)\n      update(m, t, x, m, r, 2*k+2)\n    end\n  end\nend\n\ndef find(i, l, r, k)\n  return $d[k] if $d[k] > 0\n  m = (l+r)/2\n  if i < m then\n    return find(i, l, m, 2*k+1)\n  else\n    return find(i, m, r, 2*k+2)\n  end\nend\n\nMAX = 2**31-1\nn, q = gets.split.map(&:to_i)\n\nm = 1\nwhile m < n\n  m *= 2\nend\n\n$d = Array.new(2*m-1){MAX}\n\nq.times{\n  com, s, t, x = gets.split.map(&:to_i)\n  case com\n  when 0\n    update(s, t+1, x, 0, m, 0)\n  when 1\n    p find(s, 0, m, 0)\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\nas = Array.new(n,2**31-1)\nq.times{|i|\n  com, s, t, x = gets.split.map(&:to_i)\n  com == 0 ? as[s..t] = x : (puts as[s])\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def update(s, t, x, l, r, k)\n  if s == l && t == r then\n    $d[k] = x\n  else\n    if $d[k] > 0 then\n      $d[2*k+1] = $d[2*k+2] = $d[k]\n      $d[k] = -1\n    end\n    m = (l + r)/2\n    if t <= m then\n      update(s, t, x, l, m, 2*k+1)\n    elsif m <= s then\n      update(s, t, x, m, r, 2*k+2)\n    else\n      update(s, m, x, l, m, 2*k+1)\n      update(m, t, x, m, r, 2*k+2)\n    end\n  end\nend\n\ndef find(i, l, r, k)\n  return $d[k] if $d[k] > 0\n  m = (l+r)/2\n  if i < m then\n    return find(i, l, m, 2*k+1)\n  else\n    return find(i, m, r, 2*k+2)\n  end\nend\n\nMAX = 2**31-1\nn, q = gets.split.map(&:to_i)\n\nm = 1\nwhile m < n\n  m *= 2\nend\n\n$d = Array.new(4*m){MAX}\n\nq.times{\n  com, s, t, x = gets.split.map(&:to_i)\n  case com\n  when 0\n    update(s, t+1, x, 0, m, 0)\n  when 1\n    p find(s, 0, m, 0)\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "def get_i() #空白区切の入力を数値(整数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_i)\nend\ndef get_f() #空白区切の入力を数値(実数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_f)\nend\ndef get() #空白区切の入力を文字列の配列で返す\n  return gets.chomp.split(\" \")\nend\ndef get_nsp() #入力されたものを一文字ずつに区切った文字列の配列で返す\n  return gets.chomp.split(\"\")\nend\ndef yn_judge(bool,y=\"Yes\",n=\"No\") #boolに真偽を投げることで、trueならy、falseならnの値を出力する\n  return bool ? y : n \nend\ndef array(size,n=1,init=nil) #nに配列の次元数、sizeに配列の大きさ、initに初期値を投げることでその配列を返す\n  if n==1\n    return Array.new(size){init}\n  else\n    return Array.new(n).map{Array.new(size){init}}\n  end\nend\n\ndef max(a,b)\n  return a>b ? a : b\nend\ndef min(a,b)\n  return a>b ? b : a\nend\nclass SD\n  attr_accessor:data,:n,:n_sqrt,:lazy,:lazyF\n  def initialize(n)\n    @n_sqrt=(n**0.5).to_i\n    @n=(n+@n_sqrt-1)/@n_sqrt\n    @data=array(@n*@n_sqrt,1,2**31-1)\n    @lazy=array(@n,1,0)\n    @lazyF=array(@n,1,false) \n  end\n\n  def lazy_eval(i)\n    if @lazyF[i]\n      @lazyF[i]=false\n      @n_sqrt.times do|k|\n        @data[i*@n_sqrt+k]=@lazy[i]\n      end\n    end\n  end\n  def update(s,t,x)\n    @n.times do|i|\n      l=i*@n_sqrt\n      r=l+@n_sqrt\n      next if r<=s or t<=l\n      if s<=l and r<=t\n        @lazy[i]=x\n        @lazyF[i]=true\n      else\n        lazy_eval(i)\n        for j in max(s,l)..min(t,r)-1\n          @data[j]=x\n        end\n      end\n    end\n  end\n\n  def find(i)\n    lazy_eval(i/@n_sqrt)\n    return @data[i] \n  end\nend\nn,q=get_i\nsd=SD.new(n)\nq.times do\n  que=get_i\n  case que[0]\n  when 0 then\n    s=que[1]\n    t=que[2]\n    x=que[3]\n    sd.update(s,t+1,x)\n  when 1 then\n    puts sd.find(que[1])\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class RangeUpdateQuery\n  attr_reader :n, :dat, :lazy\n\n  # @param [Integer] len 区間の長さ\n  def initialize(len, init: -1)\n    @n = 1\n\n    @n *= 2 while @n < len\n    @dat = Array.new(2 * @n - 1, init)\n    @lazy = Array.new(2 * @n - 1)\n  end\n\n  # @param [Integer] l 更新範囲の左端\n  # @param [Integer] r 更新範囲の右端\n  # @param [Integer] x 更新する値\n  def update(l, r, x)\n    fill(l, r, x, 0, 0, n - 1)\n  end\n\n  # @param [Integer] idx 取得したい値の箇所\n  def find(idx)\n    sum(idx, idx, 0, 0, n - 1)\n  end\n\n  private\n\n  # @param [Integer] a 探索範囲の左端\n  # @param [Integer] b 探索範囲の右端\n  # @param [Integer] x 更新する値\n  # @param [Integer] idx 現在位置\n  # @param [Integer] l 現在の探索範囲の左端\n  # @param [Integer] r 現在の探索範囲の右端\n  def fill(a, b, x, idx, l, r)\n    return if r < a || b < l\n\n    evaluate(idx, l, r)\n\n    if a <= l && r <= b\n      @lazy[idx] = x\n    else\n      fill(a, b, x, idx * 2 + 1, l, (l + r) / 2)\n      fill(a, b, x, idx * 2 + 2, (l + r) / 2 + 1, r)\n    end\n  end\n\n  def evaluate(idx, l, r)\n    return if lazy[idx].nil?\n\n    @dat[idx] = lazy[idx]\n\n    if r - l > 0\n      @lazy[2 * idx + 1] = lazy[idx]\n      @lazy[2 * idx + 2] = lazy[idx]\n    end\n\n    @lazy[idx] = nil\n  end\n\n  def sum(a, b, idx, l, r)\n    return 0 if r < a || b < l\n\n    evaluate(idx, l, r)\n\n    if a <= l && r <= b\n      dat[idx]\n    else\n      vl = sum(a, b, idx * 2 + 1, l, (l + r) / 2)\n      vr = sum(a, b, idx * 2 + 2, (l + r) / 2 + 1, r)\n\n      vl + vr\n    end\n  end\nend\n\nN, Q = gets.split.map(&:to_i)\nruq = RangeUpdateQuery.new(N, init: 2 ** 31 - 1)\n\nQ.times do\n  query = gets.split.map(&:to_i)\n\n  if query.first == 0\n    _, s, t, n = *query\n    ruq.update(s, t, n)\n  else\n    _, i = *query\n    puts ruq.find(i)\n  end\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\nas = Array.new(n,2**31-1)\nq.times{|i|\n  com, s, t, x = gets.split.map(&:to_i)\n  com == 0 ? (t-s+1).times{|i| as[i+s] = x }: (puts as[s])\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\nas = Array.new(n,2**31-1)\nq.times{|i|\n  com, s, t, x = gets.split.map(&:to_i)\n  com == 0 ? (t-s).times{|i| as[i+s] = x }: (puts as[s])\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "$D = []\n$inf = 2147483647\ndef init(n_)\n  n=1\n  while(n<n_) do n*=2 end\n  0.upto(2*n-1){\n    $D<<$inf\n  }\nend\ndef update(a,b,k,l,r,x)\n  if(r<=a||b<=l)\n    return\n  end\n  if(a<=l&&r<=b)\n    $D[k]=x\n  else\n    if($D[k]!=$inf)\n      $D[k*2+1]=$D[k]\n      $D[k*2+2]=$D[k]\n      $D[k]=$inf\n    end\n    update(a,b,k*2+1,l,(l+r)/2,x)\n    update(a,b,k*2+2,(l+r)/2,r,x)\n  end\nend\ndef find(a,b,k,l,r)\n  if(r<=a||b<=l)\n    return $inf\n  end\n  if(a<=l&&r<=b)\n    return $D[k]\n  else\n    if($D[k]!=$inf)\n      $D[k*2+1]=$D[k]\n      $D[k*2+2]=$D[k]\n      $D[k]=$inf\n    end\n    return [find(a,b,k*2+1,l,(l+r)/2),find(a,b,k*2+2,(l+r)/2,r)].min\n  end\nend\n\nn, q = gets.split.map(&:to_i)\ninit(n)\nq.times{\n  u,s,t,x = gets.split.map(&:to_i)\n  if(u == 0)\n    update(s,t+1,0,0,n,x)\n  else\n    puts find(s,s+1,0,0,n) if n!=1\n    puts $D[0] if n==1\n  end\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def update(s, t, x, l, r, k)\n  if s == l && t == r then\n    $d[k] = x\n  else\n    if $d[k] > -1 then\n      $d[2*k+1] = $d[2*k+2] = $d[k]\n      $d[k] = -1\n    end\n    m = (l + r)/2\n    if t <= m then\n      update(s, t, x, l, m, 2*k+1)\n    elsif m <= s then\n      update(s, t, x, m, r, 2*k+2)\n    else\n      update(s, m, x, l, m, 2*k+1)\n      update(m, t, x, m, r, 2*k+2)\n    end\n  end\nend\n\ndef find(i, l, r, k)\n  return $d[k] if $d[k] > -1\n  m = (l+r)/2\n  if i < m then\n    return find(i, l, m, 2*k+1)\n  else\n    return find(i, m, r, 2*k+2)\n  end\nend\n\nMAX = 2**31-1\nn, q = gets.split.map(&:to_i)\n\nm = 1\nwhile m < n\n  m *= 2\nend\n\n$d = Array.new(2*m-1){MAX}\n\nq.times{\n  com, s, t, x = gets.split.map(&:to_i)\n  case com\n  when 0\n    update(s, t+1, x, 0, m, 0)\n  when 1\n    p find(s, 0, m, 0)\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTreeBase\n  def initialize(arr, l = 0, r = arr.size - 1)\n    @l, @r = l, r\n    @lazy = nil\n    if l == r\n      @agg = arr[l]\n    else\n      c = (l + r) / 2\n      @left_child = self.class.new(arr, l, c)\n      @right_child = self.class.new(arr, c + 1, r)\n      @agg = aggregation_of(@left_child.agg, @right_child.agg)\n    end\n  end\n\n  attr_reader :agg, :l, :r\n\n  def update(l, r, x)\n    if l == @l && r == @r\n      defer(x)\n    else\n      force\n      if r <= @left_child.r\n        @left_child.update(l, r, x)\n      elsif @right_child.l <= l\n        @right_child.update(l, r, x)\n      else\n        @left_child.update(l, @left_child.r, x)\n        @right_child.update(@right_child.l, r, x)\n      end\n      @left_child.force\n      @right_child.force\n      @agg = aggregation_of(@left_child.agg, @right_child.agg)\n    end\n  end\n\n  def force\n    return if !@lazy\n    x = @lazy\n    @lazy = nil\n    whole_update(x)\n    @left_child.update(@left_child.l, @left_child.r, x) if @left_child\n    @right_child.update(@right_child.l, @right_child.r, x) if @right_child\n  end\n\n  def query(l, r)\n    force\n    return @agg if l == @l && r == @r\n    if r <= @left_child.r\n      return @left_child.query(l, r)\n    elsif @right_child.l <= l\n      return @right_child.query(l, r)\n    else\n      agg_left = @left_child.query(l, @left_child.r)\n      agg_right = @right_child.query(@right_child.l, r)\n      return aggregation_of(agg_left, agg_right)\n    end\n  end\nend\n\nclass LazySegmentTree < LazySegmentTreeBase\n  def defer(x)\n    @lazy = x\n  end\n\n  def whole_update(x)\n    @agg = x if @l == @r\n  end\n\n  def aggregation_of(x, y)\n    nil\n  end\nend\n\nn, q = gets.split.map(&:to_i)\nseg = LazySegmentTree.new(Array.new(n, 2 ** 31 - 1))\nq.times do\n  c, x, y, z = gets.split.map(&:to_i)\n  if c == 0\n    seg.update(x, y, z)\n  else\n    puts seg.query(x, x)\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class RangeUpdateQuery\n  def initialize(n, inf = Float::INFINITY)\n    @n = n\n    @l = 1\n    while @l < n\n      @l *= 2\n    end\n    @data = Array.new(2 * @l - 1) { inf }\n  end\n\n  def _update(s, t, x, l, r, k)\n    if s == l && t == r\n      @data[k] = x\n    else\n      if @data[k] > -1\n        @data[2 * k + 1] = @data[2 * k + 2] = @data[k]\n        @data[k] = -1\n      end\n      m = (l + r) / 2\n      if t <= m\n        _update(s, t, x, l, m, 2 * k + 1)\n      elsif m <= s\n        _update(s, t, x, m, r, 2 * k + 2)\n      else\n        _update(s, m, x, l, m, 2 * k + 1)\n        _update(m, t, x, m, r, 2 * k + 2)\n      end\n    end\n  end\n\n  def update(s, t, x)\n    # add [s, t+1]\n    _update(s, t + 1, x, 0, @l, 0)\n  end\n\n  def _find(i, l, r, k)\n    return @data[k] if @data[k] > -1\n    m = (l + r) / 2\n    if i < m\n      return _find(i, l, m, 2 * k + 1)\n    else\n      return _find(i, m, r, 2 * k + 2)\n    end\n  end\n\n  def find(s, t)\n    _find(s, t, @l, 0)\n  end\nend\n\n\n\nn, q = gets.split.map(&:to_i)\nruq = RangeUpdateQuery.new(n)\nans = []\nq.times do\n  com, s, t, x = gets.split.map(&:to_i)\n  case com\n  when 0\n    ruq.update(s, t, x)\n  when 1\n    ans << ruq.find(s, 0)\n  end\nend\nputs ans.map { |x| x == Float::INFINITY ? 2147483647 : x }\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=8\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nvar dg sync.WaitGroup\nfunc main(){\n\tp:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tout := bufio.NewWriter(os.Stdout)\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tdg.Add(1)\n\t\t\tgo update(b,c+n,d)\n\t\t}else {\n\t\t\tdg.Wait()\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,D[b])\n\t\t\tout.Flush()\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n\tdg.Done()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar n,q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tinitRMQ(n)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(find(b))\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc initRMQ(lenarr int){\n\n\tn=int(math.Ceil(math.Log2(float64(lenarr))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n}\nfunc update(a,b,v int){\n\tfor i:=a+n-1;i < b+n-1 ;i++ {\n\t\tD[i]=v\n\t}\n}\nfunc find(b int)int {\n\treturn D[b+n-1]\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar lazy []int\nvar n int\nfunc main(){\n\tvar out=bufio.NewWriter(os.Stdout)\n\tvar in=bufio.NewReader(os.Stdin)\n\tvar q int\n\tfmt.Fscanf(in,\"%d %d\\n\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr:=make([]int,q)\n\tInitA()\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Fscanf(in,\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Fscanf(in,\"%d %d %d\\n\",&b,&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+1,0,0,n,i)\n\t\t}else {\n\t\t\tfmt.Fscanf(in,\"%d\\n\",&b)\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,find(b+n-1,n,lazy,arr))\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(a,b,k,l,r,v int){\n\tif r <= a || b <= l {\n\t\treturn\n\t}\n\tif a <= l && r <= b {\n\t\tlazy[k]=v\n\t\treturn\n\t}\n\tupdate(a,b,2*k+1,l,(l+r)/2,v)\n\tupdate(a,b,2*k+2,(l+r)/2,r,v)\n}\nfunc find(b,n int,lazy []int,arr []int) int{\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\treturn temp\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar n,q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(D[b+n-1])\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc update(a,b,v int){\n\tfor i:=a+n-1;i < b+n-1 ;i++ {\n\t\tD[i]=v\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tfor i:=b+n-1;i < c+n ;i++ {\n\t\t\t\tD[i]=d\n\t\t\t}\n\t\t}else {\n\t\t\tfmt.Println(D[b+n-1])\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n\truntime.GOMAXPROCS(5)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(10)\n\tfor i := 0; i < 5; i++ {\n\t\tgo InitA(i*(2*n-1)/10,(i+1)*(2*n-1)/10)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar lazy []int\nvar n int\nfunc main(){\n\tvar out=bufio.NewWriter(os.Stdout)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr:=make([]int,q)\n\tInitA(n,lazy)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+1,0,0,n,i)\n\t\t}else {\n\t\t\tb=b+n-1\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,find(b,lazy,arr))\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(n int,lazy []int){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tlazy[i]=-1\n\t}\n\n}\nfunc  update(a,b,k,l,r,v int){\n\tif r <= a || b <= l {\n\t\treturn\n\t}\n\tif a <= l && r <= b {\n\t\tlazy[k]=v\n\t\treturn\n\t}\n\tupdate(a,b,2*k+1,l,(l+r)/2,v)\n\tupdate(a,b,2*k+2,(l+r)/2,r,v)\n}\nfunc find(b int,lazy []int,arr []int) int{\n\n\tvar temp int\n\tif lazy[b] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[b]]\n\t}\n\treturn temp\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n\tInitA()\n\tvar a,b,c,d int\n\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n}\nfunc InitA(){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tD[i]=INF\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ; b >0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tfmt.Println(temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar n int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nvar out=bufio.NewWriter(os.Stdout)\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n\tInitA()\n\tvar a,b,c,d int\n\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ; b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tout.Flush()\n\tfmt.Fprintln(out,temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar lenarr,q int\n\tfmt.Scanf(\"%d %d\",&lenarr,&q)\n\tn=int(math.Ceil(math.Log2(float64(lenarr))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tvar finds []int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tfor i:=b+n-1;i < c+n ;i++ {\n\t\t\t\tD[i]=d\n\t\t\t}\n\t\t}else {\n\t\t\tfinds=append(finds,b)\n\t\t}\n\t}\n\tfor _,v :=range finds {\n\t\tfmt.Println(D[v+n-1])\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=5\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < 5; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar n,q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tinitRMQ(n)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(find(b))\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc initRMQ(lenarr int){\n\n\tn=int(math.Ceil(math.Log2(float64(lenarr))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n}\nfunc update(a,b,v int){\n\tfor i:=a+n-1;i < b+n-1 ;i++ {\n\t\tD[i]=v\n\t}\n}\nfunc find(b int)int {\n\treturn D[b+n-1]\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n\tInitA()\n\tvar a,b,c,d int\n\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n}\nfunc InitA(){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tD[i]=INF\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 == 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 == 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ; b >0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tfmt.Println(temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nfunc main(){\n\tvar n int\n\tvar D []int\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tfor i:=b+n-1;i < c+n ;i++ {\n\t\t\t\tD[i]=d\n\t\t\t}\n\t\t}else {\n\t\t\tfmt.Println(D[b+n-1])\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n\truntime.GOMAXPROCS(10)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo InitA(i*(2*n-1)/10,(i+1)*(2*n-1)/10)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nvar out=bufio.NewWriter(os.Stdout)\nvar wg sync.WaitGroup\nfunc main(){\n\tpro:=3\n\truntime.GOMAXPROCS(pro)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n\twg.Add(pro)\n\tfor i := 0; i < pro; i++ {\n\t\tgo InitA(i*(2*n-1)/pro,(i+1)*(2*n-1)/pro)\n\t}\n\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tlazy[i]=-1\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tout.Flush()\n\tfmt.Fprintln(out,temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar lenarr,q int\n\tfmt.Scanf(\"%d %d\",&lenarr,&q)\n\tn=int(math.Ceil(math.Log2(float64(lenarr))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(D[b+n-1])\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc update(a,b,v int){\n\tfor i:=a+n-1;i < b+n-1 ;i++ {\n\t\tD[i]=v\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < 5; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar n,q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(lenarr))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(D[b+n-1])\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc update(a,b,v int){\n\tfor i:=a+n-1;i < b+n-1 ;i++ {\n\t\tD[i]=v\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc init() {\n\tReadString = newReadString(os.Stdin)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc newReadString(ior io.Reader) func() string {\n\tr := bufio.NewScanner(ior)\n\tr.Buffer(make([]byte, 1024), int(1e+11))\n\t// Split sets the split function for the Scanner. The default split function is ScanLines.\n\t// Split panics if it is called after scanning has started.\n\tr.Split(bufio.ScanWords)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n/*********** DP sub-functions ***********/\n\n// ChMin accepts a pointer of integer and a target value.\n// If target value is SMALLER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMin(updatedValue *int, target int) bool {\n\tif *updatedValue > target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// ChMax accepts a pointer of integer and a target value.\n// If target value is LARGER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMax(updatedValue *int, target int) bool {\n\tif *updatedValue < target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// NthBit returns nth bit value of an argument.\n// n starts from 0.\nfunc NthBit(num, nth int) int {\n\treturn num >> uint(nth) & 1\n}\n\n// OnBit returns the integer that has nth ON bit.\n// If an argument has nth ON bit, OnBit returns the argument.\nfunc OnBit(num, nth int) int {\n\treturn num | (1 << uint(nth))\n}\n\n// OffBit returns the integer that has nth OFF bit.\n// If an argument has nth OFF bit, OffBit returns the argument.\nfunc OffBit(num, nth int) int {\n\treturn num & ^(1 << uint(nth))\n}\n\n// PopCount returns the number of ON bit of an argument.\nfunc PopCount(num int) int {\n\tres := 0\n\n\tfor i := 0; i < 70; i++ {\n\t\tif ((num >> uint(i)) & 1) == 1 {\n\t\t\tres++\n\t\t}\n\t}\n\n\treturn res\n}\n\n/*********** Arithmetic ***********/\n\n// Max returns the max integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Max(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m < integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Min returns the min integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Min(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m > integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// DigitSum returns digit sum of a decimal number.\n// DigitSum only accept a positive integer.\nfunc DigitSum(n int) int {\n\tif n < 0 {\n\t\treturn -1\n\t}\n\n\tres := 0\n\n\tfor n > 0 {\n\t\tres += n % 10\n\t\tn /= 10\n\t}\n\n\treturn res\n}\n\n// Sum returns multiple integers sum.\nfunc Sum(integers ...int) int {\n\ts := 0\n\n\tfor _, i := range integers {\n\t\ts += i\n\t}\n\n\treturn s\n}\n\n// Kiriage returns Ceil(a/b)\n// a >= 0, b > 0\nfunc Kiriage(a, b int) int {\n\treturn (a + (b - 1)) / b\n}\n\n// PowInt is integer version of math.Pow\n// PowInt calculate a power by Binary Power (二分累乗法(O(log e))).\nfunc PowInt(a, e int) int {\n\tif a < 0 || e < 0 {\n\t\tpanic(errors.New(\"[argument error]: PowInt does not accept negative integers\"))\n\t}\n\n\tif e == 0 {\n\t\treturn 1\n\t}\n\n\tif e%2 == 0 {\n\t\thalfE := e / 2\n\t\thalf := PowInt(a, halfE)\n\t\treturn half * half\n\t}\n\n\treturn a * PowInt(a, e-1)\n}\n\n// AbsInt is integer version of math.Abs\nfunc AbsInt(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// Gcd returns the Greatest Common Divisor of two natural numbers.\n// Gcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Gcd uses the Euclidean Algorithm.\nfunc Gcd(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\tif a < b {\n\t\ta, b = b, a\n\t}\n\n\t// Euclidean Algorithm\n\tfor b > 0 {\n\t\tdiv := a % b\n\t\ta, b = b, div\n\t}\n\n\treturn a\n}\n\n// Lcm returns the Least Common Multiple of two natural numbers.\n// Lcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Lcd uses the Euclidean Algorithm indirectly.\nfunc Lcm(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\n\t// a = a'*gcd, b = b'*gcd, a*b = a'*b'*gcd^2\n\t// a' and b' are relatively prime numbers\n\t// gcd consists of prime numbers, that are included in a and b\n\tgcd := Gcd(a, b)\n\n\t// not (a * b / gcd), because of reducing a probability of overflow\n\treturn (a / gcd) * b\n}\n\n// Strtoi is a wrapper of `strconv.Atoi()`.\n// If `strconv.Atoi()` returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst MOD = 1000000000 + 7\nconst ALPHABET_NUM = 26\nconst INF_INT64 = math.MaxInt64\nconst INF_BIT60 = 1 << 60\n\n// [x]: https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_D\n\nconst sqrtN = 512\n\ntype SqrtDecompositionRUQ struct {\n\tn, k             int\n\tdata, lazyUpdate []int\n\tlazyFlag         []bool\n}\n\nfunc NewSqrtDecompositionRUQ(A []int) *SqrtDecompositionRUQ {\n\tsd := new(SqrtDecompositionRUQ)\n\tsd.n = len(A)\n\tsd.k = (sd.n + sqrtN - 1) / sqrtN\n\n\tsd.data = make([]int, sd.k*sqrtN)\n\tfor i := 0; i < sd.n; i++ {\n\t\tsd.data[i] = A[i]\n\t}\n\n\tsd.lazyUpdate = make([]int, sd.k)\n\tsd.lazyFlag = make([]bool, sd.k)\n\n\treturn sd\n}\n\nfunc (sd *SqrtDecompositionRUQ) eval(k int) {\n\tif sd.lazyFlag[k] {\n\t\tsd.lazyFlag[k] = false\n\t\tfor i := k * sqrtN; i < (k+1)*sqrtN; i++ {\n\t\t\tsd.data[i] = sd.lazyUpdate[k]\n\t\t}\n\t}\n}\n\n// [s, t)\nfunc (sd *SqrtDecompositionRUQ) Update(s, t, x int) {\n\tfor k := 0; k < sd.k; k++ {\n\t\tl, r := k*sqrtN, (k+1)*sqrtN\n\n\t\tif s >= r || t <= l {\n\t\t\tcontinue\n\t\t}\n\n\t\tif s <= l && r <= t {\n\t\t\tsd.lazyFlag[k], sd.lazyUpdate[k] = true, x\n\t\t} else {\n\t\t\tsd.eval(k)\n\t\t\ta := int(math.Max(float64(s), float64(l)))\n\t\t\tb := int(math.Min(float64(t), float64(r)))\n\t\t\tfor i := a; i < b; i++ {\n\t\t\t\tsd.data[i] = x\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (sd *SqrtDecompositionRUQ) Find(i int) int {\n\tk := i / sqrtN\n\tsd.eval(k)\n\treturn sd.data[i]\n}\n\nvar n, q int\n\nfunc main() {\n\tn, q = ReadInt2()\n\n\tA := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tA[i] = (1 << 31) - 1\n\t}\n\tsd := NewSqrtDecompositionRUQ(A)\n\tfor i := 0; i < q; i++ {\n\t\tc := ReadInt()\n\n\t\tif c == 0 {\n\t\t\ts, t, x := ReadInt3()\n\t\t\tsd.Update(s, t+1, x)\n\t\t} else {\n\t\t\ti := ReadInt()\n\t\t\tfmt.Println(sd.Find(i))\n\t\t}\n\t}\n}\n\n// MODはとったか？\n// 遷移だけじゃなくて最後の最後でちゃんと取れよ？\n\n/*******************************************************************/\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nvar dg sync.WaitGroup\nfunc main(){\n\tp:=1\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tdg.Add(1)\n\t\t\tupdate(b,c,d)\n\t\t}else {\n\t\t\tdg.Wait()\n\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tc+=n\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n\tdg.Done()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar n int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nvar out=bufio.NewWriter(os.Stdout)\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n\tInitA()\n\tvar a,b,c,d int\n\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n}\nfunc InitA(){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ; b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tout.Flush()\n\tfmt.Fprintln(out,temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\n\nfunc main(){\n\tvar n int\n\tvar out=bufio.NewWriter(os.Stdout)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy:=make([]int,2*n-1)\n\tarr:=make([]int,q)\n\t\tfor i := 0;i < 2*n-1;i++  {\n\t\tlazy[i]=-1\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i,lazy)\n\t\t}else {\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,find(b,n,lazy,arr))\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc  update(l,r,v int,lazy []int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v,lazy)\n\t}\n}\nfunc find(b,n int,lazy []int,arr []int) int{\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\treturn temp\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=5\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < 5; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n\tp:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tout := bufio.NewWriter(os.Stdout)\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tupdate(b,c+n,d)\n\t\t}else {\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,D[b])\n\t\t\tout.Flush()\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nvar INF=int(math.Pow(2,31))-1\nfunc main(){\n\tvar n,q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tinitRMQ(n)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(find(b))\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc initRMQ(lenarr int){\n\tn = 1\n\tfor ;n < lenarr;  {\n\t\tn *= 2\n\t}\n\tD=make([]int,2*n-1)\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n}\nfunc update(a,b,v int){\n\ta += n - 1\n\tb += n - 1\n\tfor i:=a;i < b ;i++ {\n\t\tD[i]=v\n\t}\n}\nfunc find(b int)int {\n\tb+=n-1\n\treturn D[b]\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nvar out=bufio.NewWriter(os.Stdout)\nvar wg sync.WaitGroup\nfunc main(){\n\tpro:=2\n\truntime.GOMAXPROCS(pro)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n\twg.Add(pro)\n\tfor i := 0; i < pro; i++ {\n\t\tgo InitA(i*(2*n-1)/pro,(i+1)*(2*n-1)/pro)\n\t}\n\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tlazy[i]=-1\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tout.Flush()\n\tfmt.Fprintln(out,temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nvar dg sync.WaitGroup\nfunc main(){\n\tp:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tdg.Add(1)\n\t\t\tupdate(b,c,d)\n\t\t}else {\n\t\t\tdg.Wait()\n\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tc+=n\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n\tdg.Done()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nfunc main(){\n\tvar n int\n\tvar D []int\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tb+=n-1\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\ttemp:=D[b+n-1]\n\t\t\tif temp==0 {\n\t\t\t\tfmt.Println(INF)\n\t\t\t}else{\n\t\t\t\tfmt.Println(temp)\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nvar dg sync.WaitGroup\nfunc main(){\n\tp:=3\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tdg.Add(1)\n\t\t\tupdate(b,c,d)\n\t\t}else {\n\t\t\tdg.Wait()\n\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tc+=n\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n\tdg.Done()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n\truntime.GOMAXPROCS(4)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(4)\n\tgo InitA(0,(2*n-1)/4)\n\tgo InitB((2*n-1)/4,(2*n-1)/2)\n\tgo InitC((2*n-1)/2,3*(2*n-1)/4)\n\tgo InitD(3*(2*n-1)/4,(2*n-1))\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\nfunc InitB(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\nfunc InitC(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\nfunc InitD(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t\truntime.Gosched()\n\t}\n\twg.Done()\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\nvar n int\nvar D []int\nvar INF=int(math.Pow(2,31))-1\n\n//////////////////////bufio/////////////////////\nvar err error\nvar inputReader= bufio.NewReader(os.Stdin)\nvar outputWriter=bufio.NewWriter(os.Stdout)\nfunc main(){\n\tvar n,q int\n\ts:=reading()\n\tn,err=strconv.Atoi(s[0])\n\tq,err=strconv.Atoi(s[1])\n\tinitRMQ(n)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\ts=reading()\n\t\ta,err=strconv.Atoi(s[0])\n\t\tif a==0 {\n\t\t\tb,err=strconv.Atoi(s[1])\n\t\t\tc,err=strconv.Atoi(s[2])\n\t\t\td,err=strconv.Atoi(s[3])\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tb,err=strconv.Atoi(s[1])\n\t\t\ttemp:=strconv.Itoa(find(b))\n\t\t\toutputWriter.WriteString(temp+\"\\n\")\n\t\t\toutputWriter.Flush()\n\t\t}\n\t}\n}\nfunc reading()[]string{\n\tvar input string\n\tinput, err = inputReader.ReadString('\\n')\n\tinput = strings.Replace(input, \"\\n\", \"\", -1)\n\ts:=strings.Split(input,\" \")\n\treturn s\n}\n\n////////////////////////Range Query////////////////////////////////\nfunc initRMQ(lenarr int){\n\tn = 1\n\tfor ;n < lenarr;  {\n\t\tn *= 2\n\t}\n\tD=make([]int,2*n-1)\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n}\nfunc update(a,b,v int){\n\ta += n - 1\n\tb += n - 1\n\tfor i:=a;i < b ;i++ {\n\t\tD[i]=v\n\t}\n}\nfunc find(b int)int {\n\tb+=n-1\n\treturn D[b]\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=20\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nvar dg sync.WaitGroup\nfunc main(){\n\tp:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tdg.Add(1)\n\t\t\tgo update(b,c,d)\n\t\t}else {\n\t\t\tdg.Wait()\n\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tc+=n\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n\tdg.Done()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n//  長い入力を読む\nfunc ReadLongLines(times int) ([]string, error) {\n\tresult := make([]string, times)\n\treader := bufio.NewReader(os.Stdin)\n\tbuffer := bytes.NewBuffer(make([]byte, 0))\n\treadBytes := int64(2)\n\tfor i := 0; i < times; i++ {\n\t\tfor {\n\t\t\treadBuf, isPrefix, err := reader.ReadLine()\n\t\t\t// fmt.Printf(\"Reader.Read: %d\\n\", len(readBuf))\n\t\t\treadBytes += int64(len(readBuf) + 1)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tfmt.Println(\"EOF\")\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\treturn result, err\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = buffer.Write(readBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn result, err\n\t\t\t}\n\t\t\t// end of line\n\t\t\tif !isPrefix {\n\t\t\t\tresult[i] = buffer.String()\n\t\t\t\tbuffer.Reset()\n\t\t\t\t// reader = bufio.NewReader(os.Stdin)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// 先読みしてしまうようなので、戻しておく\n\tos.Stdin.Seek(-int64(reader.Buffered()), os.SEEK_CUR)\n\treturn result, nil\n}\n\n// 出力 for 競プロ\ntype Console struct {\n\twriter *bufio.Writer\n}\n\nfunc NewConsole() Console {\n\treturn Console{bufio.NewWriter(os.Stdout)}\n}\nfunc (this *Console) Printf(format string, a ...interface{}) {\n\tfmt.Fprintf(this.writer, format, a...)\n}\nfunc (this *Console) Println(s string) {\n\tfmt.Fprintln(this.writer, s)\n}\nfunc (this *Console) Close() {\n\tthis.Flush()\n}\nfunc (this Console) Flush() {\n\tthis.writer.Flush()\n}\n\nfunc PrintList(list []int) {\n\tcon := NewConsole()\n\tdefer con.Flush()\n\tfor i := range list {\n\t\tif i == 0 {\n\t\t\tcon.Printf(\"%d\", list[i])\n\t\t} else {\n\t\t\tcon.Printf(\" %d\", list[i])\n\t\t}\n\t}\n\tcon.Println(\"\")\n}\n\nfunc Max(lhs int, rhs int) int {\n\tif lhs < rhs {\n\t\treturn rhs\n\t} else {\n\t\treturn lhs\n\t}\n}\nfunc Min(lhs int, rhs int) int {\n\tif lhs < rhs {\n\t\treturn lhs\n\t} else {\n\t\treturn rhs\n\t}\n}\n\nconst DEF_VAL = 1<<31 - 1\n\ntype Node struct {\n\tbegin int\n\tend   int\n\tvalue int\n\t// left  *Node\n\t// Right *Node\n}\ntype Graph struct {\n\t// root *Node\n\tlist []Node\n}\n\nfunc NewGraph(n int) Graph {\n\t// root := Node{0, n - 1, DEF_VAL, nil, nil}\n\t// return Graph{&root}\n\tlist := make([]Node, 1)\n\tlist[0] = Node{0, n - 1, DEF_VAL}\n\treturn Graph{list}\n}\nfunc (this *Graph) Update(begin int, end int, value int) {\n\tthis.list = append(this.list, Node{begin, end, value})\n}\n\nfunc (this *Graph) Find(index int) int {\n\tfor i := len(this.list) - 1; 0 <= i; i-- {\n\t\tif this.list[i].begin <= index && index <= this.list[i].end {\n\t\t\treturn this.list[i].value\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tcon := NewConsole()\n\tdefer con.Close()\n\n\tvar n, q int\n\tfmt.Scanf(\"%d %d\", &n, &q)\n\tlines, _ := ReadLongLines(q)\n\n\tlist := NewGraph(n)\n\n\tfor i := 0; i < q; i++ {\n\t\targs := strings.Split(lines[i], \" \")\n\t\tcommand := args[0]\n\t\tswitch command {\n\t\tcase \"0\":\n\t\t\ts, _ := strconv.Atoi(args[1])\n\t\t\tt, _ := strconv.Atoi(args[2])\n\t\t\tx, _ := strconv.Atoi(args[3])\n\t\t\tlist.Update(s, t, x)\n\t\tcase \"1\":\n\t\t\ti, _ := strconv.Atoi(args[1])\n\t\t\tx := list.Find(i)\n\t\t\t// con.Printf(\"Find(%d, %d) \", s, t)\n\t\t\tcon.Printf(\"%d\\n\", x)\n\t\t}\n\t}\n\t// fmt.Println(list)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tdefer writer.Flush()\n\tn, q := ReadInt(), ReadInt()\n\tt := NewSegTree(n)\n\tfor ; q > 0; q-- {\n\t\tif ReadInt() == 0 {\n\t\t\tt.Update(ReadInt(), ReadInt()+1, ReadInt())\n\t\t} else {\n\t\t\tPrintln(t.Find(ReadInt()))\n\t\t}\n\t}\n}\n\n// Segment Tree for Range Update Query (RUQ)\ntype SegTree struct {\n\tnodes    []int\n\tversions []int\n\tversion  int\n}\n\nconst Inf = 1<<31 - 1\n\nfunc NewSegTree(n_ int) *SegTree {\n\tn := 1\n\tfor n < n_ {\n\t\tn <<= 1\n\t}\n\tt := &SegTree{\n\t\tnodes:    make([]int, n*2),\n\t\tversions: make([]int, n*2),\n\t}\n\tfor i := 1; i < len(t.nodes); i++ {\n\t\tt.nodes[i] = Inf\n\t}\n\treturn t\n}\n\nfunc (t *SegTree) Update(a, b, x int) {\n\tt.version++\n\tt.UpdateRecur(a, b, x, 1, 0, len(t.nodes)>>1)\n}\n\nfunc (t *SegTree) UpdateRecur(a, b, x, k, l, r int) {\n\tif b <= l || r <= a {\n\t\treturn\n\t}\n\tif a <= l && r <= b {\n\t\tt.nodes[k] = x\n\t\tt.versions[k] = t.version\n\t\treturn\n\t}\n\tt.UpdateRecur(a, b, x, k*2, l, (l+r)>>1)\n\tt.UpdateRecur(a, b, x, k*2+1, (l+r)>>1, r)\n}\n\nfunc (t *SegTree) Find(i int) int {\n\ti += len(t.nodes) >> 1\n\tk := i\n\tfor i > 0 {\n\t\tif t.versions[i] > t.versions[k] {\n\t\t\tk = i\n\t\t}\n\t\ti >>= 1\n\t}\n\treturn t.nodes[k]\n}\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc init() {\n\tscanner.Buffer(make([]byte, 256), 1e9)\n\tscanner.Split(bufio.ScanWords)\n}\nfunc ReadString() string { scanner.Scan(); return scanner.Text() }\nfunc ReadInt() int {\n\ta, err := strconv.Atoi(ReadString())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn a\n}\n\nvar writer = bufio.NewWriter(os.Stdout)\n\nfunc Println(a ...interface{}) { fmt.Fprintln(writer, a...) }\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\tfor i := (2*n-1)/2; i < 2*-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tvar ans string\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\tans+=strconv.Itoa(D[b])+\"\\n\"\n\t\t}\n\t}\n\tfmt.Print(ans)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nfunc main(){\n\tvar n int\n\tvar D []int\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tfor j:=b+n-1;j < c+n ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\tfmt.Println(D[b+n-1])\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "import java.util.Scanner;\n/**\n * @author Chen Qiu, email:m5222104@u-aizu.ac.jp\n *@version : 2019/April\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint n;\n\t\tint[] D;\n\t\tint q;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tq=in.nextInt();\n        n = (int)Math.ceil(Math.log(n) / Math.log(2));\n        n=1<<n;\n\t\tD=new int[n];\n\t\tint INF=Integer.MAX_VALUE;\n\t\tfor (int i= 0; i < 2*n-1; i++ ){\n\t\t\tD[i]=INF;\n\t\t}\n\t\tint a,b,c,d;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta=in.nextInt();\n\t\t\tb=in.nextInt();\n\t\t\tif (a==0) {\n\t\t\t\tc=in.nextInt();\n\t\t\t\td=in.nextInt();\n\t\t\t\tfor (int j=b+n-1;j < c+n ;j++) {\n\t\t\t\t\tD[j]=d;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tSystem.out.println(D[b+n-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=3\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar n int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nvar out=bufio.NewWriter(os.Stdout)\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n    InitA()\n\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(){\n\tfor i := 0;i < n;i++  {\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tout.Flush()\n\tfmt.Fprintln(out,temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\tq := getNextInt(scanner)\n\tseg := newSegment(n)\n\tv := 1\n\tseg.update(0, n, math.MaxInt32, v)\n\tfor i := 0; i < q; i++ {\n\t\tswitch getNextInt(scanner) {\n\t\tcase 0:\n\t\t\ts := getNextInt(scanner)\n\t\t\tt := getNextInt(scanner)\n\t\t\tx := getNextInt(scanner)\n\t\t\tv++\n\t\t\tseg.update(s, t+1, x, v)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Fprintln(writer, seg.get(getNextInt(scanner)))\n\t}\n}\n\ntype version struct {\n\tupdated, x int\n}\n\ntype segment [][]version\n\nfunc newSegment(n int) segment {\n\tseg := make(segment, 0)\n\tfor n > 1 {\n\t\tseg = append(seg, make([]version, n))\n\t\tn = (n + 1) >> 1\n\t}\n\tseg = append(seg, make([]version, 1))\n\treturn seg\n}\nfunc (seg segment) get(i int) int {\n\tvar x version = seg[0][i]\n\tfor h := 0; h < len(seg); h++ {\n\t\tif seg[h][i].updated >= x.updated {\n\t\t\tx = seg[h][i]\n\t\t}\n\t\ti >>= 1\n\t}\n\treturn x.x\n}\nfunc (seg segment) update(l, r, x, updated int) {\n\tfor h := 0; h < len(seg) && l < r; h++ {\n\t\tif l%2 == 1 {\n\t\t\tseg[h][l].updated = updated\n\t\t\tseg[h][l].x = x\n\t\t\tl++\n\t\t}\n\t\tl >>= 1\n\t\tif r%2 == 1 {\n\t\t\tseg[h][r-1].updated = updated\n\t\t\tseg[h][r-1].x = x\n\t\t}\n\t\tr >>= 1\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nvar dg sync.WaitGroup\nfunc main(){\n\tp:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tout := bufio.NewWriter(os.Stdout)\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tdg.Add(1)\n\t\t\tupdate(b,c+n,d)\n\t\t}else {\n\t\t\tdg.Wait()\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,D[b])\n\t\t\tout.Flush()\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\nfunc  update(b,c,d int){\n\tfor j:=b;j < c ;j++ {\n\t\tD[j]=d\n\t}\n\tdg.Done()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\nvar n int\nvar D []int\nfunc main(){\n\tvar n,q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tinitRMQ(n)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d\",&a)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d %d\",&b,&c,&d)\n\t\t\tupdate(b,c+1,d)\n\t\t}else {\n\t\t\tfmt.Scanf(\"%d\",&b)\n\t\t\tfmt.Println(find(b))\n\t\t}\n\t}\n}\n////////////////////////Range Query////////////////////////////////\nfunc initRMQ(lenarr int){\n\n\tn=int(math.Ceil(math.Log2(float64(lenarr))))\n\tn=int(math.Pow(2,float64(n)))\n\tD=make([]int,2*n-1)\n\tINF:=math.MaxInt32\n\tfor i := 0; i < 2*n-1; i++ {\n\t\tD[i]=INF\n\t}\n}\nfunc update(a,b,v int){\n\tfor i:=a+n-1;i < b+n-1 ;i++ {\n\t\tD[i]=v\n\t}\n}\nfunc find(b int)int {\n\treturn D[b+n-1]\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\nvar n int\nvar D []int\nvar INF=math.MaxInt32\nvar wg sync.WaitGroup\nfunc main(){\n    p:=2\n\truntime.GOMAXPROCS(p)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tn=1<<uint(n)\n\tD=make([]int,2*n-1)\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo InitA(i*(2*n-1)/p,(i+1)*(2*n-1)/p)\n\t}\n\tvar a,b,c,d int\n\twg.Wait()\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb+=n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tc+=n\n\t\t\tfor j:=b;j < c ;j++ {\n\t\t\t\tD[j]=d\n\t\t\t}\n\t\t}else {\n\t\t\t\tfmt.Println(D[b])\n\t\t}\n\t}\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tD[i]=INF\n\t}\n\twg.Done()\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "import java.util.Scanner;\n/**\n * @author Chen Qiu, email:m5222104@u-aizu.ac.jp\n *@version : 2019/April\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint n;\n\t\tint[] D;\n\t\tint q;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tq=in.nextInt();\n        n = (int)Math.ceil(Math.log(n) / Math.log(2));\n        n=1<<n;\n\t\tD=new int[n];\n\t\tint INF=Integer.MAX_VALUE;\n\t\tfor (int i= 0; i < 2*n-1; i++ ){\n\t\t\tD[i]=INF;\n\t\t}\n\t\tint a,b,c,d;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta=in.nextInt();\n\t\t\tb=in.nextInt();\n\t\t\tif (a==0) {\n\t\t\t\tc=in.nextInt();\n\t\t\t\td=in.nextInt();\n\t\t\t\tfor (int j=b+n-1;j < c+n ;j++) {\n\t\t\t\t\tD[j]=d;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tSystem.out.println(D[b+n-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "/**\n * @author Chen Qiu, email:m5222104@u-aizu.ac.jp\n *@version : 2019/April\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint n;\n\t\tint[] D;\n\t\tint q;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tq=in.nextInt();\n        n = (int)Math.ceil(Math.log(n) / Math.log(2));\n        n=1<<n;\n\t\tD=new int[n];\n\t\tint INF=Integer.MAX_VALUE;\n\t\tfor (int i= 0; i < 2*n-1; i++ ){\n\t\t\tD[i]=INF;\n\t\t}\n\t\tint a,b,c,d;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta=in.nextInt();\n\t\t\tb=in.nextInt();\n\t\t\tif (a==0) {\n\t\t\t\tc=in.nextInt();\n\t\t\t\td=in.nextInt();\n\t\t\t\tfor (int j=b+n-1;j < c+n ;j++) {\n\t\t\t\t\tD[j]=d;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tSystem.out.println(D[b+n-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar lazy []int\nvar n int\nfunc main(){\n\tvar out=bufio.NewWriter(os.Stdout)\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr:=make([]int,q)\n\tInitA(n,lazy)\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+1,0,0,n,i)\n\t\t}else {\n\t\t\tb=b+n-1\n\t\t\tout.Flush()\n\t\t\tfmt.Fprintln(out,find(b,n,lazy,arr))\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(n int,lazy []int){\n\tfor i := 0;i < 2*n-1;i++  {\n\t\tlazy[i]=-1\n\t}\n\n}\nfunc  update(a,b,k,l,r,v int){\n\tif r <= a || b <= l {\n\t\treturn\n\t}\n\tif a <= l && r <= b {\n\t\tlazy[k]=v\n\t\treturn\n\t}\n\tupdate(a,b,2*k+1,l,(l+r)/2,v)\n\tupdate(a,b,2*k+2,(l+r)/2,r,v)\n}\nfunc find(b,n int,lazy []int,arr []int) int{\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\treturn temp\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\nvar n int\nvar lazy []int\nvar arr []int\nvar INF=math.MaxInt32\nvar out=bufio.NewWriter(os.Stdout)\nfunc main(){\n\tvar q int\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tn=int(math.Ceil(math.Log2(float64(n))))\n\tif n==0 {\n\t\tn++\n\t}\n\tn=1<<uint(n)\n\tlazy=make([]int,2*n-1)\n\tarr=make([]int,q)\n    InitA(i*(2*n-1)/pro,(i+1)*(2*n-1)/pro)\n\n\tvar a,b,c,d int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d\",&a,&b)\n\t\tb=b+n-1\n\t\tif a==0 {\n\t\t\tfmt.Scanf(\"%d %d\",&c,&d)\n\t\t\tarr[i]=d\n\t\t\tupdate(b,c+n-1,i)\n\t\t}else {\n\t\t\tfind(b)\n\t\t}\n\t}\n\tout.Flush()\n}\nfunc InitA(a,b int){\n\tfor i := a;i < b;i++  {\n\t\tlazy[i]=-1\n\t}\n}\nfunc  update(l,r,v int){\n\tif l+1==r || l==r{\n\t\tlazy[l]=v\n\t\tlazy[r]=v\n\t}else{\n\t\tif l%2 != 1 {\n\t\t\tlazy[l] = v\n\t\t\tl++\n\t\t}\n\t\tif r%2 != 0 {\n\t\t\tlazy[r] = v\n\t\t\tr--\n\t\t}\n\t\tupdate((l-1)/2,(r-1)/2,v)\n\t}\n}\nfunc find(b int){\n\tmax:=b\n\tfor ;b>0;{\n\t\tb=(b-1)/2\n\t\tif lazy[max]<lazy[b]{\n\t\t\tmax=b\n\t\t}\n\t}\n\tvar temp int\n\tif lazy[max] == -1 {\n\t\ttemp=math.MaxInt32\n\t}else {\n\t\ttemp=arr[lazy[max]]\n\t}\n\tout.Flush()\n\tfmt.Fprintln(out,temp)\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "import java.util.Scanner;\n/**\n * @author Chen Qiu, email:m5222104@u-aizu.ac.jp\n *@version : 2019/April\n */\npublic class main{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint n;\n\t\tint[] D;\n\t\tint q;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tq=in.nextInt();\n        n = (int)Math.ceil(Math.log(n) / Math.log(2));\n        n=1<<n;\n\t\tD=new int[n];\n\t\tint INF=Integer.MAX_VALUE;\n\t\tfor (int i= 0; i < 2*n-1; i++ ){\n\t\t\tD[i]=INF;\n\t\t}\n\t\tint a,b,c,d;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta=in.nextInt();\n\t\t\tb=in.nextInt();\n\t\t\tif (a==0) {\n\t\t\t\tc=in.nextInt();\n\t\t\t\td=in.nextInt();\n\t\t\t\tfor (int j=b+n-1;j < c+n ;j++) {\n\t\t\t\t\tD[j]=d;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tSystem.out.println(D[b+n-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "open Printf\nopen Scanf\n\nlet () =\n  let n, q = scanf \"%d %d \" (fun x y -> (x, y)) in\n  let bl = 300 in\n  let ar = Array.make n 2147483647 in\n  let blk = Array.make (n / bl + 1) None in\n  let wb i = match blk.(i) with\n      None -> ()\n    | Some v -> let rec iter j =\n                  let m = i * bl + j in\n                  if j = bl || m = n then blk.(i) <- None\n                  else begin\n                      ar.(m) <- v;\n                      iter (j+1)\n                    end in\n                iter 0 in\n  let find i = match blk.(i / bl) with\n      None -> ar.(i)\n    | Some v -> v\n  in\n  let update s t x =\n    let rec iter i =\n      if i >= t then ()\n      else begin\n          if i mod bl = 0 && i + bl <= t then begin\n              blk.(i / bl) <- Some x;\n              iter (i+bl)\n            end\n          else begin\n              begin\n                match blk.(i / bl) with\n                  None -> ()\n                | Some v -> wb (i / bl)\n              end;\n              ar.(i) <- x;\n              iter (i+1)\n            end\n        end in\n    iter s in\n  let rec loop i =\n    if i = 0 then ()\n    else begin\n        let com = scanf \"%d \" (fun x -> x) in\n        begin\n          if com = 0 then\n            let s, t, x = scanf \"%d %d %d \" (fun x y z -> (x, y+1, z)) in\n            update s t x\n          else\n            let j = scanf \"%d \" (fun x -> x) in\n            find j |> printf \"%d\\n\"\n        end;\n        loop (i-1)\n      end in\n  loop q"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    _lazy[] = NIL;\n    _maxi[] = int.max;\n\n    auto nq = readints();\n    int n = nq[0], q = nq[1];\n    for (int i = 0; i < q; i++) {\n        auto xs = readints();\n\n        if (xs[0] == 0) {\n            int s = xs[1];\n            int t = xs[2];\n            int x = xs[3];\n            fill(s, t + 1, x);\n        }\n        else {\n            int s = xs[1];\n            int v = maximum(s, s + 1);\n            writeln(v);\n        }\n    }\n}\n\n///////////////////////////////////////\n\nconst int N = 100_010; // ???????????°\nconst int NIL = int.max;\n\nint[N * 2] _maxi; // ?????????k?????????????????????????????§???\nint[N * 2] _lazy; // lazy[k]????????????k???????????¨??????lazy[k]??§???????????¶?????¨?????????????????¨??????lazy[k]=NIL?????¨???????????????????????¨?´??????????\n\nvoid setLazy(int k, int v) {\n    _lazy[k] = v;\n\n    // ??????????????????????????¨?????? v ??§???????????¶????????????????????????????????¶????????????k????????§??????v??§??????\n    _maxi[k] = v;\n}\n\nvoid push(int k) {\n    // ?????¶?????????????????????????????°???????????????\n    if (_lazy[k] == NIL) {\n        return;\n    }\n    setLazy(k * 2 + 0, _lazy[k]);\n    setLazy(k * 2 + 1, _lazy[k]);\n\n    // ????????????????????¬??????????????§????????????????????????\n    _lazy[k] = NIL;\n}\n\nvoid fix(int k) {\n    // ?????????k?????????????????????????????§?????????????????????????????§????????¨????????????????????§??????????????§???\n    _maxi[k] = max(_maxi[k * 2], _maxi[k * 2 + 1]);\n}\n\n// ??????[queryL,queryR)???val??§???????????¶???\nvoid fill(int queryL, int queryR, int val, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨????????????????????????????????????????????????????????\\?????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return;\n    }\n    // ???????????????????????¨?????????????????¨??????????????????????????¶????????????????????????????????£?????¨??°???\n    if (queryL <= nodeL && nodeR <= queryR) {\n        setLazy(k, val);\n        return;\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    fill(queryL, queryR, val, k * 2 + 0, nodeL, nodeM);\n    fill(queryL, queryR, val, k * 2 + 1, nodeM, nodeR);\n\n    // ???????????????????????¨??????????????±???fix??????\n    fix(k);\n}\n\n// ??????[queryL, queryR)????????§???????±???????\nint maximum(int queryL, int queryR, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨???????????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return int.min;\n    }\n    // ???????????????????????¨?????????????????¨???????????????\n    if (queryL <= nodeL && nodeR <= queryR) {\n        return _maxi[k];\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    int vl = maximum(queryL, queryR, k * 2 + 0, nodeL, nodeM);\n    int vr = maximum(queryL, queryR, k * 2 + 1, nodeM, nodeR);\n    return max(vl, vr);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array, std.math;\n\n\nvoid main() {\n    int n, q;\n    scan(n, q);\n\n    auto sd = SqrtDecomp(n);\n\n    foreach (_ ; 0 .. q) {\n        auto line = readln.split.to!(int[]);\n        if (line[0] == 0) {\n            sd.update(line[1], line[2] + 1, line[3]);\n        }\n        else {\n            writeln(sd.get(line[1]));\n        }\n    }\n}\n\nstruct SqrtDecomp {\n    private {\n        enum rt = 512;\n        int N, K;\n        int[] bucket;\n        int[] data;\n    }\n\n    this(int n) {\n        N = n;\n        K = (N + rt - 1) / rt;\n        bucket = new int[](K);\n        data = new int[](K * rt);\n        bucket[] = -1;\n        data[] = int.max;\n    }\n\n    void update(int l, int r, int x) {\n        foreach (k ; 0 .. K) {\n            int bl = k * rt, br = (k + 1) * rt;\n            if (r <= bl || br <= l) continue;\n            if (l <= bl && br <= r) {\n                bucket[k] = x;\n            }\n            else {\n                foreach (i ; max(l, bl) .. min(r, br)) {\n                    data[i] = x;\n                }\n            }\n        }\n    }\n\n    int get(int idx) {\n        int k = idx / rt;\n\n        if (bucket[k] == -1) {\n            return data[idx];\n        }\n\n        foreach (i ; k * rt .. (k + 1) * rt) {\n            data[i] = bucket[k];\n        }\n        bucket[k] = -1;\n\n        return data[idx];\n    }\n}\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    _lazy[] = NIL;\n    _maxi[] = int.max;\n\n    auto nq = readints();\n    int n = nq[0], q = nq[1];\n    for (int i = 0; i < q; i++) {\n        auto xs = readints();\n\n        if (xs[0] == 0) {\n            int s = xs[1];\n            int t = xs[2];\n            int x = xs[3];\n            fill(s, t + 1, x);\n        }\n        else {\n            int s = xs[1];\n            int v = maximum(s, s + 1);\n            writeln(v);\n        }\n    }\n}\n\n///////////////////////////////////////\n\nconst int N = 1 << 18; // ???????????°\nconst int NIL = int.max;\n\nint[N * 2] _maxi; // ?????????k?????????????????????????????§???\nint[N * 2] _lazy; // lazy[k]????????????k???????????¨??????lazy[k]??§???????????¶?????¨?????????????????¨??????lazy[k]=NIL?????¨???????????????????????¨?´??????????\n\nvoid setLazy(int k, int v) {\n    _lazy[k] = v;\n\n    // ??????????????????????????¨?????? v ??§???????????¶????????????????????????????????¶????????????k????????§??????v??§??????\n    _maxi[k] = v;\n}\n\nvoid push(int k) {\n    // ?????¶?????????????????????????????°???????????????\n    if (_lazy[k] == NIL) {\n        return;\n    }\n    setLazy(k * 2 + 0, _lazy[k]);\n    setLazy(k * 2 + 1, _lazy[k]);\n\n    // ????????????????????¬??????????????§????????????????????????\n    _lazy[k] = NIL;\n}\n\nvoid fix(int k) {\n    // ?????????k?????????????????????????????§?????????????????????????????§????????¨????????????????????§??????????????§???\n    _maxi[k] = max(_maxi[k * 2], _maxi[k * 2 + 1]);\n}\n\n// ??????[queryL,queryR)???val??§???????????¶???\nvoid fill(int queryL, int queryR, int val, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨????????????????????????????????????????????????????????\\?????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return;\n    }\n    // ???????????????????????¨?????????????????¨??????????????????????????¶????????????????????????????????£?????¨??°???\n    if (queryL <= nodeL && nodeR <= queryR) {\n        setLazy(k, val);\n        return;\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    fill(queryL, queryR, val, k * 2 + 0, nodeL, nodeM);\n    fill(queryL, queryR, val, k * 2 + 1, nodeM, nodeR);\n\n    // ???????????????????????¨??????????????±???fix??????\n    fix(k);\n}\n\n// ??????[queryL, queryR)????????§???????±???????\nint maximum(int queryL, int queryR, int k = 1, int nodeL = 0, int nodeR = N) {\n    // ?????¨???????????¨???????????????????????????????????????\n    if (nodeR <= queryL || queryR <= nodeL) {\n        return int.min;\n    }\n    // ???????????????????????¨?????????????????¨???????????????\n    if (queryL <= nodeL && nodeR <= queryR) {\n        return _maxi[k];\n    }\n    // ???????????????????????¨??????????????????push??????\n    push(k);\n    int nodeM = (nodeL + nodeR) / 2;\n    int vl = maximum(queryL, queryR, k * 2 + 0, nodeL, nodeM);\n    int vr = maximum(queryL, queryR, k * 2 + 1, nodeM, nodeR);\n    return max(vl, vr);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array, std.math;\n\n\nvoid main() {\n    int n, q;\n    scan(n, q);\n\n    auto sd = SqrtDecomp(n);\n\n    foreach (time ; 0 .. q) {\n        auto line = readln.split.to!(int[]);\n        if (line[0] == 0) {\n            sd.update(line[1], line[2] + 1, line[3], time);\n        }\n        else {\n            writeln(sd.get(line[1]));\n        }\n    }\n}\n\nstruct SqrtDecomp {\n    private {\n        enum rt = 512;\n        int N, K;\n        int[] bucket;\n        int[] data;\n        int[] bt;\n        int[] dt;\n    }\n\n    this(int n) {\n        N = n;\n        K = (N + rt - 1) / rt;\n        bucket = new int[](K);\n        data = new int[](K * rt);\n        bucket[] = -1;\n        data[] = int.max;\n\n        bt = new int[](K);\n        dt = new int[](K * rt);\n        bt[] = -1;\n        dt[] = -1;\n    }\n\n    void update(int l, int r, int x, int time) {\n        foreach (k ; 0 .. K) {\n            int bl = k * rt, br = (k + 1) * rt;\n            if (r <= bl || br <= l) continue;\n            if (l <= bl && br <= r) {\n                bucket[k] = x;\n                bt[k] = time;\n            }\n            else {\n                foreach (i ; max(l, bl) .. min(r, br)) {\n                    data[i] = x;\n                    dt[i] = time;\n                }\n            }\n        }\n    }\n\n    int get(int idx) {\n        int k = idx / rt;\n\n        foreach (i ; k * rt .. (k + 1) * rt) {\n            if (bt[k] > dt[i]) data[i] = bucket[k];\n        }\n\n        return data[idx];\n    }\n}\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.array, std.range, std.algorithm, std.container;\nimport std.math, std.random, std.bigint, std.datetime, std.format;\nvoid main(string[] args){ if(args.length > 1) if(args[1] == \"-debug\") DEBUG = 1; solve(); }\nvoid log()(){ writeln(\"\"); } void log(T, A ...)(T t, lazy A a){ if(DEBUG) write(t, \" \"), log(a); } bool DEBUG = 0; \nstring rstring(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\nT rtype(T)(){ return rstring.to!T; } alias rint = rtype!int, rlong = rtype!long, rreal = rtype!real;\nT[] rtypes(T)(int n){ return n.iota.map!(i => rtype!T()).array; } alias rint = rtypes!int, rlong = rtypes!long, rreal = rtypes!real;\nT[][] rtypess(T)(int n, int m){ return n.iota.map!(i => rtypes!T(m)).array; } alias rint = rtypess!int, rlong = rtypess!long, rreal = rtypess!real;\nT chmin(T)(ref T x, T y){ if(x > y) x = y; return x; } T chmax(T)(ref T x, T y){ if(x < y) x = y; return x; }\n\n// ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- //\n\nvoid solve(){\n\tint n = rint, q = rint;\n\tauto seg = new SegTree!long(0, n, (x, y) => y, 0);\n\tseg.setValue(0, n, (1L<<31) - 1);\n\tlog(\"seg:\", seg);\n\tforeach(_; 0 .. q){\n\t\tint c = rint;\n\t\tif(c == 0){\n\t\t\tint l = rint, r = rint + 1;\n\t\t\tlong x = rlong;\n\t\t\tseg.setValue(l, r, x);\n\t\t\tlog(\"l:\", l, \"r:\", r, \"x:\", x);\n\t\t\tlog(\"seg:\", seg);\n\t\t}\n\t\telse{\n\t\t\tint i = rint;\n\t\t\tlog(\"i:\", i);\n\t\t\tseg.getValue(i).writeln;\n\t\t}\n\t}\n}\n\nclass SegTree(T){\n\tT delegate(T, T) apply;\n\tT initial;\n\tint a, b; // a <= x < b を担当する\n\tbool hasValue;\n\tSegTree left, right; // 左の子(a <= x < c)、右の子(c <= x < b)\n\tT value;\n\tthis(int a, int b, T delegate(T, T) apply, T initial = T.init){\n\t\tthis.a = a, this.b = b;\n\t\tthis.apply = apply;\n\t\tthis.initial = initial;\n\t\tthis.value = initial;\n\t\tif(b - a == 1){\n\t\t\tthis.hasValue = 1;\n\t\t}\n\t\telse{\n\t\t\tint c = (a + b) / 2;\n\t\t\tthis.left = new SegTree(a, c, apply, initial);\n\t\t\tthis.right = new SegTree(c, b, apply, initial);\n\t\t}\n\t}\n\t\n\t// [a, b) に値を設定する ※[a, b) はこのノードの担当区間とかぶっていなくてもよい\n\tvoid setValue(int a, int b, T value){\n\t\tif(b <= this.a || this.b <= a) return;\n\t\tif(a <= this.a && this.b <= b){\n\t\t\tthis.hasValue = true;\n\t\t\tthis.value = apply(this.value, value);\n\t\t}\n\t\telse{\n\t\t\tif(this.hasValue){\n\t\t\t\tleft.setValue(left.a, left.b, this.value);\n\t\t\t\tright.setValue(right.a, right.b, this.value);\n\t\t\t\tthis.hasValue = false;\n\t\t\t}\n\t\t\tleft.setValue(a, b, value);\n\t\t\tright.setValue(a, b, value);\n\t\t}\n\t}\n\t\n\t// iにおける値 ※iは必ずこのノードの担当区間内である前提\n\tT getValue(int i){\n\t\tassert(a <= i && i < b);\n\t\tif(this.hasValue) return this.value;\n\t\telse if(i < left.b) return left.getValue(i);\n\t\telse return right.getValue(i);\n\t}\n\t\n\t// 配列に変換したもの（デバッグ用）\n\tT[] array(){\n\t\tT[] res;\n\t\tforeach(i; a .. b) res ~= this.value;\n\t\treturn res;\n\t}\n\t\n\t// 文字列に変換したもの（デバッグ用）\n\toverride string toString(){\n\t\tif(this.hasValue) return this.array.to!string;\n\t\telse return left.toString ~ right.toString;\n\t}\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.algorithm, std.array, std.range, std.conv,\n    std.typecons, std.math, std.container, std.format, std.numeric;\n\nalias T = Tuple!(long, \"value\", long, \"time\");\n\nclass Segtree\n{\nprivate:\n    long size;\n    T[] xs;\npublic:\n    this(long size)\n    {\n        long i = 1;\n        while (i <= size)\n        {\n            i *= 2;\n        }\n        this.size = size;\n        this.xs = new T[](i * 2);\n    }\n\n    this(long size, T value)\n    {\n        this(size);\n        this.xs.fill(value);\n    }\n\n    void update(long l, long r, T x)\n    {\n        l += this.size;\n        r += this.size;\n        while (l < r)\n        {\n            if (l % 2 == 1)\n            {\n                this.xs[l] = x;\n                l++;\n            }\n            l /= 2;\n            if (r % 2 == 1)\n            {\n                this.xs[r - 1] = x;\n                r--;\n            }\n            r /= 2;\n        }\n    }\n\n    T find(long i)\n    {\n        i += this.size;\n        T ans = this.xs[i];\n        while (true)\n        {\n            i /= 2;\n            if (i == 0)\n            {\n                break;\n            }\n            if (ans.time < this.xs[i].time)\n            {\n                ans = this.xs[i];\n            }\n        }\n        return ans;\n    }\n}\n\nvoid main(string[] args)\n{\n    long n, q;\n    readf(\"%d %d\\n\", &n, &q);\n    auto seg = new Segtree(n, T((1 << 31) - 1, -1));\n    foreach (i; 0 .. q)\n    {\n        long cmd, s, t, x;\n        readf(\"%d \", &cmd);\n        if (cmd == 0)\n        {\n            readf(\"%d %d %d\\n\", &s, &t, &x);\n            seg.update(s, t + 1, T(x, i));\n        }\n        else\n        {\n            readf(\"%d\\n\", &x);\n            auto val = seg.find(x);\n            writeln(val.value);\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\n# 区間更新一点取得\nclass RangeUpdateQuery:\n    def __init__(self, n, initial=2 ** 31 - 1):\n        self.n = 1 << (n - 1).bit_length()\n        self.INT = (-1, initial)\n        # 更新時刻, 値\n        self.segtree = [self.INT] * (2 * self.n)\n\n    # 区間[l, r)をv(時刻, 値)で更新\n    def update(self, l, r, v):\n        L, R = l + self.n, r + self.n\n        while L < R:\n            if L & 1:\n                self.segtree[L] = v\n                L += 1\n\n            if R & 1:\n                self.segtree[R - 1] = v\n                R -= 1\n\n            L >>= 1\n            R >>= 1\n\n    # i番目の値を取得\n    def query(self, i):\n        i += self.n\n        s = self.INT\n        while i > 0:\n            s = max(s, self.segtree[i])\n            i = i // 2\n        return s[1]\n\n\nN, Q = map(int, input().split())\nRUQ = RangeUpdateQuery(N)\nfor q in range(Q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 0:\n        s, t, x = query[1:]\n        RUQ.update(s, t + 1, (q, x))\n\n    if query[0] == 1:\n        i = query[1]\n        print(RUQ.query(i))\n\n"
  },
  {
    "language": "Python",
    "code": "n, q = map(int, input().split())\na = [2 ** 31 - 1] * n\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '0':\n        s, t, x = map(int, query[1:])\n        a[s:t + 1] = [x] * (t - s + 1)\n    else:\n        print(a[int(query[1])])"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\ndef update(Set,x,y,z):\n    for i in range(x,y+1):\n        Set[i] = z\n\ndef lazy_update(Set,i,x):\n    Set[i] = x\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    sqrtN = 1\n    while True:\n        if(N >= _N):\n            break\n        sqrtN += 1\n        N = sqrtN**2\n    A = [2**31 - 1]*N\n    lazy_A = [None]*sqrtN\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            for i in range(0,sqrtN):\n                if((i+1)*sqrtN <= query[1] or query[2] <= i*sqrtN):\n                    pass\n                if(query[1] <= i*sqrtN and (i+1)*sqrtN <= query[2]):\n                    if not (lazy_A[i] == query[3]):\n                        lazy_update(lazy_A,i,query[3])\n                else:\n                    if(lazy_A[i] is not None):\n                        A[i*sqrtN:(i+1)*sqrtN] = [lazy_A[i]]*sqrtN\n                        lazy_A[i] = None\n                    n = max(query[1],i*sqrtN)\n                    m = min(query[2],(i+1)*sqrtN)\n                    #print(\"max from {0} {1}\".format(query[1],i*sqrtN))\n                    #print(\"min from {0} {1}\".format(query[2],(i+1)*sqrtN))\n                    #print(n,m)\n                    update(A,n,m,query[3])\n                    #update(A,(i+1)*sqrtN+1,query[2],query[3])\n            #print(A)\n        # find\n        if(query[0]==1):\n            if(lazy_A[int(query[1]/sqrtN)] is not None):\n                A[int(query[1]/sqrtN)*sqrtN:int(query[1]/sqrtN)*sqrtN+sqrtN] = [lazy_A[int(query[1]/sqrtN)]]*sqrtN\n                lazy_A[int(query[1]/sqrtN)] = None\n                #print(\"A update from lazy\")\n                #print(A)\n            print(A[query[1]])\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "#! -*- coding:utf-8 -*-\nn,q = map(int,input().split())\nquery = [0] * q\nfor i in range(q):\n    query[i] = input()\narr = [2**31 - 1] * n\n\nfor i in range(q):\n    if len(query[i]) == 7:\n        tmp = list(query[i].split())\n        s = int(tmp[1])\n        t = int(tmp[2])\n        for i in range(s,t+1):\n            arr[i] = tmp[3]\n    else:\n        tmp = list(query[i].split())\n        print(arr[int(tmp[1])])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 2 ** 31 - 1\nMOD = 10 ** 9 + 7\n\nclass SegTreeLazy:\n    \"\"\" 遅延評価セグメント木(区間更新・区間最小値取得) \"\"\"\n\n    def __init__(self, N, func, intv):\n        self.intv = intv\n        self.func = func\n        LV = (N-1).bit_length()\n        self.N0 = 2**LV\n        self.data = [intv]*(2*self.N0)\n        self.lazy = [None]*(2*self.N0)\n\n    # 伝搬される区間のインデックス(1-indexed)を全て列挙するgenerator\n    def gindex(self, l, r):\n        L = l + self.N0; R = r + self.N0\n        lm = (L // (L & -L)) >> 1\n        rm = (R // (R & -R)) >> 1\n        while L < R:\n            if R <= rm:\n                yield R\n            if L <= lm:\n                yield L\n            L >>= 1; R >>= 1\n        while L:\n            yield L\n            L >>= 1\n\n    # 遅延評価の伝搬処理\n    def propagates(self, *ids):\n        # 1-indexedで単調増加のインデックスリスト\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.data[2*i-1] = self.lazy[2*i] = self.data[2*i] = v\n            self.lazy[i-1] = None\n\n    def update(self, l, r, x):\n        \"\"\" 区間[l,r)の値をxに更新 \"\"\"\n\n        *ids, = self.gindex(l, r)\n        # 1. トップダウンにlazyの値を伝搬\n        self.propagates(*ids)\n        # 2. 区間[l,r)のdata, lazyの値を更新\n        L = self.N0 + l; R = self.N0 + r\n        while L < R:\n            if R & 1:\n                R -= 1\n                self.lazy[R-1] = self.data[R-1] = x\n            if L & 1:\n                self.lazy[L-1] = self.data[L-1] = x\n                L += 1\n            L >>= 1; R >>= 1\n        # 3. 伝搬させた区間について、ボトムアップにdataの値を伝搬する\n        for i in ids:\n            self.data[i-1] = self.func(self.data[2*i-1], self.data[2*i])\n\n    def query(self, l, r):\n        \"\"\" 区間[l,r)の最小値を取得 \"\"\"\n\n        # 1. トップダウンにlazyの値を伝搬\n        self.propagates(*self.gindex(l, r))\n        L = self.N0 + l; R = self.N0 + r\n\n        # 2. 区間[l, r)の最小値を求める\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.func(s, self.data[R-1])\n            if L & 1:\n                s = self.func(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\nN, Q = MAP()\nstl = SegTreeLazy(N+1, min, INF)\n\nans = []\nfor i in range(Q):\n    cmd, *arg = MAP()\n    if cmd == 0:\n        s, t, x = arg\n        stl.update(s, t+1, x)\n    else:\n        i, = arg\n        ans.append(str(stl.query(i, i+1)))\nprint('\\n'.join(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\nINT_MAX = 2**31 - 1\nlazy_init = (None,-1)\n\ndef update(tree,x,y,z,N):\n    left = x + N #- 1\n    right = y + N #- 1\n    while True:\n        if(left >= right):\n            break\n        if(right > 0):\n            tree[right - 1] = z\n        if(left > 0):\n            tree[left - 1] = z\n\n        left = math.floor((left + 1)/2)\n        right = math.floor((right - 1)/2)\n\ndef find(tree,x,N):\n    x += N - 1\n    s = (INT_MAX, -1)\n    while True:\n        if(x <= 0):\n            break\n        if(tree[x][1] > s[1]):\n            s = tree[x]\n        x = math.floor((x - 1)/2)\n    return s[0]\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    while True:\n        if(N >= _N):\n            break\n        N <<= 1\n    if not (N == 1):\n        A = [(INT_MAX,-1)]*(2*N - 1)\n        lazy_A = [lazy_init]*(2*N - 1)\n    else:\n        A = [(INT_MAX,-1)]*(2*N)\n        lazy_A = [lazy_init]*(2*N)\n\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            update(A,query[1],query[2],(query[3],i),N)\n            #print(A,lazy_A)\n        # find\n        if(query[0]==1):\n            #z = find(A,lazy_A,query[1],query[1]+1,0,0,N,N)\n            z = find(A,query[1],N)\n            print(z)\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "#! -*- coding:utf-8 -*-\nn,q = map(int,input().split())\nquery = [0] * q\nfor i in range(q):\n    query[i] = input()\narr = [2**31 - 1] * n\n\nfor i in range(q):\n    tmp = list(query[i].split())    \n    if len(tmp) == 4:\n\n        s = int(tmp[1])\n        t = int(tmp[2])\n        for i in range(s,t+1):\n            arr[i] = tmp[3]\n    else:\n        print(arr[int(tmp[1])])"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),min(n-1,(x+1)*b)):a[int(i)]=l[x]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nN, Q = map(int, readline().split())\n\nN0 = 2**(N-1).bit_length()\ndata = [None]*(2*N0)\nINF = (-1, 2**31-1)\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            data[R-1] = v\n\n        if L & 1:\n            data[L-1] = v\n            L += 1\n        L >>= 1; R >>= 1\ndef _query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        if data[k]:\n            s = max(s, data[k])\n        k = (k - 1) // 2\n    return s\ndef query(k):\n    return _query(k)[1]\n\n\nans = []\nfor q in range(Q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        ans.append(str(query(cmd[0])))\n    else:\n        s, t, x = cmd\n        update(s, t+1, (q, x))\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "class SegmentTree():\n    \"\"\"区間更新、一点取得クエリをそれぞれO(logN)で答えるデータ構造を構築する\n    update: 区間[begin, end)をvalに変更する\n    get_val: i番目の値を求める\n    \"\"\"\n    def __init__(self, n):\n        self.update_cnt = 0\n        self.n = n\n        self.size = 1\n        INF = 2**31 - 1\n        while self.size < n:\n            self.size *= 2\n        self.node = [[self.update_cnt, INF] for i in range(2*self.size - 1)]\n\n    def update(self, begin, end, val):\n        self.update_cnt += 1\n        begin += (self.size - 1)\n        end += (self.size - 1)\n        while begin < end:\n            if (end - 1) & 1:\n                end -= 1\n                self.node[end] = [self.update_cnt, val]\n            if (begin - 1) & 1:\n                self.node[begin] = [self.update_cnt, val]\n                begin += 1\n            begin = (begin - 1) // 2\n            end = (end - 1) // 2\n\n    def get_val(self, i):\n        i += (self.size - 1)\n        val = self.node[i]\n        while i > 0:\n            i = (i - 1) // 2\n            val = max(val, self.node[i])\n        return val[1]\n\n\nn, q = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(q)]\n\nst = SegmentTree(n)\nfor i in range(q):\n    if info[i][0] == 0:\n        s, t, val = info[i][1], info[i][2], info[i][3]\n        st.update(s, t + 1, val)\n    else:\n        s = info[i][1]\n        print(st.get_val(info[i][1]))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),min(n-1,(x+1)*b)):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "class TemplateTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = (-1, v)\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = a\n    return self.value[x]\n\n  def update(self, x, val, order, left, right):\n    #print(x)\n    x_left, x_right = self.range[x]\n    if left <= x_left and x_right <= right:\n      self.value[x] = (order, val)\n    elif right < x_left or x_right < left:\n      pass\n    else:\n      self.update(x * 2 + 1, val, order, left, right)\n      self.update(x * 2 + 2, val, order, left, right)\n      \n  def query(self, x, order, value):\n    if x < 0:\n      return value\n    x_order, x_val = self.value[x]\n    if order < x_order:\n      return self.query((x - 1) // 2, x_order, x_val)\n    else:\n      return self.query((x - 1) // 2, order, value)\n\n  def print_tree(self):\n    print(self.value)\n    print(self.range)\n\nn, q = map(int, input().split())\nINF = 2 ** 31 - 1\ntree = TemplateTree([INF] * n)\n\nfor j in range(q):\n  lst = list(map(int, input().split()))\n  if lst[0] == 0:\n    s, t, x = lst[1:]\n    tree.update(0, x, j, s, t)\n  else:\n    i = lst[1]\n    print(tree.query(tree.iter_size - 1 + i, -2, 0))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef lazy_update(s, e, value):\n    a = [(1, l+s, l+e, 1)]\n    while a:\n        k, s, e, depth = a.pop()\n        l_end, r_end = k << (rank-depth), (k+1) << (rank-depth)\n        mid = (l_end + r_end) // 2\n        if s == l_end and e == r_end:\n            lazy[k] = value\n        else:\n            if lazy[k] is not None:\n                lazy[k<<1] = lazy[k]\n                lazy[(k<<1)+1] = lazy[k]\n                lazy[k] = None\n            if s < mid:\n                a.append((k<<1, s, min(mid, e), depth+1))\n            if e > mid:\n                a.append(((k<<1)+1, max(mid, s), e, depth+1))\n\ndef get_value(i):\n    i += l\n    for j in range(rank, -1, -1):\n        n = lazy[i>>j]\n        if n is not None:\n            return n\n    return tree[i]\n\nn, q = map(int,input().split())\nl = 1 << math.ceil(math.log2(n))\ntree = [2**31-1]*(2*l)\nlazy = [None]*(2*l)\nrank = int(math.log2(len(tree)))\nans = []\nap = ans.append\n\nfor _ in [None]*q:\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        lazy_update(query[1], query[2]+1, query[3])\n    else:\n        ap(get_value(query[1]))\n\nprint(\"\\n\".join((str(n) for n in ans)))"
  },
  {
    "language": "Python",
    "code": "class SegmentTree:\n    n=0\n    node=[]\n\n    def __init__(self, sz):\n        self.n=1\n        while self.n<sz: self.n *= 2\n        self.node = [INF] * (2*self.n-1)\n\n    def update(self, a, b, x=-1, k=0, l=0, r=-1):\n        if r<0: r = self.n\n        if r<=a or  b<=l: return\n        if a<=l and r<=b: \n            if x>=0: self.node[k] = x\n            return\n        if self.node[k]!=INF:\n            self.node[k*2+1] = self.node[k*2+2] = self.node[k]\n        self.node[k] = INF\n        self.update(a, b, x, 2*k+1, l, (l+r)//2)\n        self.update(a, b, x, 2*k+2, (l+r)//2, r)\n\n    \nINF = 2**31-1\nsz, q = map(int, input().split())\nruq = SegmentTree(sz)\nfor _ in range(q):\n    c, *l = map(int, input().split())\n    if c:\n        ruq.update(l[0], l[0]+1)\n        print(ruq.node[l[0]+ruq.n-1])\n    else:\n        s, t, x = l\n        ruq.update(s, t+1, x)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\n\ndef lazy_tree_merge(lazy,tree,i,N):\n    if(lazy[i][0] is not None):\n        tree[i] = lazy[i]\n        if(i < N-1):\n            lazy[i*2+1] = lazy[i]\n            lazy[i*2+2] = lazy[i]\n        lazy[i] = (None,-1)\n\ndef update(tree,lazy,x,y,k,l,r,i,z,N):\n    if (r <= x or y <= l):\n        lazy_tree_merge(lazy,tree,k,N)\n        return True\n    if ( x <= l and r <= y):\n        lazy[k] = (z,i)\n        lazy_tree_merge(lazy,tree,k,N)\n        return True\n\n    lazy_tree_merge(lazy,tree,k,N)\n    update(tree, lazy, x, y, k*2 + 1, l, int((l+r)/2), i, z, N)\n    #update(tree, lazy, x, y, k*2 + 2, l, int((l+r)/2), i, z, N)\n    update(tree, lazy, x, y, k*2 + 2, int((l+r)/2), r, i, z, N)\n    if(tree[k*2+1][1] < tree[k*2+2][1]):\n        tree[k] = tree[k*2+2]\n    else:\n        tree[k] = tree[k*2+1]\n    #tree[k] = min(tree[k*2+1], tree[k*2+2])\n\ndef find(tree,lazy,x,y,k,l,r,N):\n\n    if (r <= x or y <= l):\n        return 2**31 - 1\n    if ( x <= l and r <= y):\n        lazy_tree_merge(lazy,tree,k,N)\n        return tree[k][0]\n\n    lazy_tree_merge(lazy,tree,k,N)\n    v_left = find(tree, lazy_A, x, y, k*2 + 1, l, int((l+r)/2), N)\n    v_right = find(tree, lazy_A, x, y, k*2 + 2, int((l+r)/2), r, N)\n    #print(v_left)\n    #print(v_right)\n    return min(v_left, v_right)\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    INT_MAX = 2**31 - 1\n    N = 1\n    while True:\n        if(N >= _N):\n            break\n        N *= 2\n    if not (N == 1):\n        A = [(INT_MAX,-1)]*(2*N - 1)\n        lazy_A = [(None,-1)]*(2*N - 1)\n    else:\n        A = [(INT_MAX,-1)]*(2*N)\n        lazy_A = [(None,-1)]*(2*N)\n\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            update(A,lazy_A,query[1],query[2]+1,0,0,N,i,query[3],N)\n            #print(A,lazy_A)\n        # find\n        if(query[0]==1):\n            z = find(A,lazy_A,query[1],query[1]+1,0,0,N,N)\n            print(z)\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),int(min(n-1,(x+1)*b))):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nN, Q = map(int, readline().split())\n \nN0 = 2**(N-1).bit_length()\ndata = [None]*(2*N0)\nINF = (-1, 2**31-1)\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            data[R-1] = v\n \n        if L & 1:\n            data[L-1] = v\n            L += 1\n        L >>= 1; R >>= 1\ndef _query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        if data[k]:\n            s = max(s, data[k])\n        k = (k - 1) // 2\n    return s\ndef query(k):\n    return _query(k)[1]\n \n \nans = []\nfor q in range(Q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        ans.append(str(query(cmd[0])))\n    else:\n        s, t, x = cmd\n        update(s, t+1, (q, x))\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nsys.setrecursionlimit(20000)\nINT_MAX = 2**31 - 1\nlazy_init = (None,-1)\ndef lazy_tree_merge(lazy,tree,i,N):\n    if(lazy[i][0] is not None):\n        tree[i] = lazy[i]\n        if(i < N-1):\n            lazy[i*2+1] = lazy[i]\n            lazy[i*2+2] = lazy[i]\n        lazy[i] = lazy_init\n\ndef update(tree,lazy,x,y,k,l,r,i,z,N):\n    if (r <= x or y <= l):\n        lazy_tree_merge(lazy,tree,k,N)\n        return True\n    if ( x <= l and r <= y):\n        lazy[k] = (z,i)\n        lazy_tree_merge(lazy,tree,k,N)\n        return True\n\n    lazy_tree_merge(lazy,tree,k,N)\n    center = int((l+r)/2)\n    update(tree, lazy, x, y, k*2 + 1, l, center, i, z, N)\n    #update(tree, lazy, x, y, k*2 + 2, l, int((l+r)/2), i, z, N)\n    update(tree, lazy, x, y, k*2 + 2, center, r, i, z, N)\n    if(tree[k*2+1][1] < tree[k*2+2][1]):\n        tree[k] = tree[k*2+2]\n    else:\n        tree[k] = tree[k*2+1]\n\ndef find(tree,lazy,x,y,k,l,r,N):\n\n    if (r <= x or y <= l):\n        return INT_MAX\n    if ( x <= l and r <= y):\n        lazy_tree_merge(lazy,tree,k,N)\n        return tree[k][0]\n\n    lazy_tree_merge(lazy,tree,k,N)\n    v_left = find(tree, lazy_A, x, y, k*2 + 1, l, int((l+r)/2), N)\n    v_right = find(tree, lazy_A, x, y, k*2 + 2, int((l+r)/2), r, N)\n    return min(v_left, v_right)\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    while True:\n        if(N >= _N):\n            break\n        N <<= 1\n    if not (N == 1):\n        A = [(INT_MAX,-1)]*(2*N - 1)\n        lazy_A = [lazy_init]*(2*N - 1)\n    else:\n        A = [(INT_MAX,-1)]*(2*N)\n        lazy_A = [lazy_init]*(2*N)\n\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            update(A,lazy_A,query[1],query[2]+1,0,0,N,i,query[3],N)\n            #print(A,lazy_A)\n        # find\n        if(query[0]==1):\n            z = find(A,lazy_A,query[1],query[1]+1,0,0,N,N)\n            print(z)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\n\ndef judge_max(x,y):\n    \n    if x > y :return x\n    else:return y \n\ndef judge_min(x,y):\n    if x > y :return y\n    else :return x\n\n\n\ndef update(x):\n \n    for i in range(int(x*b),int(judge_min(n-1,(x+1)*b))):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(judge_min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(judge_max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nn, q = map(int, readline().split())\n \nN0 = 2**(n-1).bit_length()\ndata = [None]*(2*N0)\nINF = (-1, 2**31-1)\n\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            data[R-1] = v\n \n        if L & 1:\n            data[L-1] = v\n            L += 1\n        L >>= 1; R >>= 1\n        \ndef _query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        if data[k]:\n            s = max(s, data[k])\n        k = (k - 1) // 2\n    return s\ndef query(k):\n    return _query(k)[1]\n \n \nans = []\nfor i in range(q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        ans.append(str(query(cmd[0])))\n    else:\n        s, t, x = cmd\n        update(s, t+1, (i, x))\n        \nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nn,q=(int(x) for x in input().split())\nb= int(math.sqrt(n))\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),min(n-1,int((x+1)*b-1))+1):a[i]=l[x]\n    l[x]=-1\n    return\n \n\nif __name__=='__main__':\n        \n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n    for j in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,int((x/b+1)*b-1))+1):a[i]=z\n            for i in range(int(x/b+1),int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(max(x,int(y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\na = []\n\ndef update(s,t,x):\n\tfor i in range(s,t+1):\n\t\ta[i] = x\n\ndef find(i):\n\tprint(a[i])\n\nn,q = map(int,input().split())\n\nfor i in range(n):\n\ta.append(2 ** 31 - 1)\n\nfor i in range(q):\n\tnum = list(map(int,input().split()))\n\tif num[0] == 0:\n\t\tupdate(num[1],num[2],num[3])\n\tif num[0] == 1:\n\t\tfind(num[1])"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\ndef update(Set,x,y,z):\n    for i in range(x,y+1):\n        Set[i] = z\n\ndef lazy_update(Set,i,x):\n    Set[i] = x\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    sqrtN = 1\n    while True:\n        if(N >= _N):\n            break\n        sqrtN += 1\n        N = sqrtN**2\n    A = [2**31 - 1]*N\n    lazy_A = [None]*sqrtN\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            for i in range(0,sqrtN):\n                if(i*sqrtN <= query[1] or query[2] <= (i+1)*sqrtN):\n                    continue\n                if(query[1] <= i*sqrtN and (i+1)*sqrtN <= query[2]):\n                    if not (lazy_A[i] == query[3]):\n                        lazy_update(lazy_A,i,query[3])\n                else:\n                    if(lazy_A[i] is not None):\n                        A[i*sqrtN:(i+1)*sqrtN] = [lazy_A[i]]*sqrtN\n                        lazy_A[i] = None\n                    update(A,query[1],i*sqrtN-1,query[3])\n                    update(A,(i+1)*sqrtN+1,query[2],query[3])\n        # find\n        if(query[0]==1):\n            if(lazy_A[int(query[1]/sqrtN)] is not None):\n                A[int(query[1]/sqrtN)*sqrtN:int(query[1]/sqrtN)*sqrtN+sqrtN] = [lazy_A[int(query[1]/sqrtN)]]*sqrtN\n                lazy_A[int(query[1]/sqrtN)] = None\n                #print(\"A update from lazy\")\n                #print(A)\n            print(A[query[1]])\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "n,q=map(int,input().split())\nQ=[list(map(int,input().split())) for i in range(q)]\n\n\nfor i in range(30):#要素数以上の2のベキを見つける\n    if n<=1<<i:\n        seg_el=1<<i#Segment treeの台の要素数\n        break\n\nSEG=[None for i in range(2*seg_el-1)]#Segment tree（遅延伝搬を用いるが、一本のセグ木でOK）\n\ndef lazy_update(k,x):#一つ下の子へ伝搬\n    if 0<=k<seg_el-1:\n        lazy_item,SEG[k]=SEG[k],None\n        SEG[k*2+1]=SEG[k*2+2]=lazy_item\n\n\ndef update(a,b,x,k,l,r):\n    if SEG[k]!=None:#アクセスした箇所にデータが入っていたときは,評価を伝搬させる\n        lazy_update(k,x)\n        \n    if r<=a or b<=l:#区間[a,b)が対象区間の外にあれば終了\n        return \n    if a<=l and r<=b:#区間[a,b)が対象区間の中にあればSEG[k]を更新.後にアクセスされたときに遅延評価する.\n        SEG[k]=x#\n        return \n    update(a,b,x,k*2+1,l,(l+r)//2)#それ以外のときは,SEG[k*2+1]とSEG[k*2+2]で場合分け\n    update(a,b,x,k*2+2,(l+r)//2,r)\n\ndef getvalue(n):#値を得る\n    i=n+seg_el-1\n    ANS=SEG[i]\n    i=(i-1)//2\n\n    while i>=0:\n        if SEG[i]!=None:\n            ANS=SEG[i]#できるだけ親に近いノードから値を得るようにする.（そこが最後に更新されたものなので）\n        i=(i-1)//2\n    return ANS\n\nfor i in range(n):\n    SEG[i+seg_el-1]=(1<<31)-1\n\nfor query in Q:\n    if query[0]==0:\n        update(query[1],query[2]+1,query[3],0,0,seg_el)\n    else:\n        print(getvalue(query[1]))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# DSL_2_D: Range Update Query\n\n\nclass SegmentTree:\n    INITIAL_VALUE = 2**31 - 1\n    DIVIDED = -1\n\n    def __init__(self, n):\n        size = 1\n        while size < n:\n            size *= 2\n        self.size = 2*size - 1\n        self.data = [-1] * self.size\n        self.data[0] = self.INITIAL_VALUE\n\n    def set_range(self, lo, hi, v):\n        def _set_range(r, i, j, vv):\n            if j < lo or i > hi:\n                if vv != self.DIVIDED:\n                    self.data[r] = vv\n            elif lo <= i and j <= hi:\n                self.data[r] = v\n            else:\n                if self.data[r] != self.DIVIDED:\n                    if vv == self.DIVIDED:\n                        vv = self.data[r]\n                    self.data[r] = self.DIVIDED\n                mid = i + (j - i)//2\n                _set_range(r*2 + 1, i, mid, vv)\n                _set_range(r*2 + 2, mid+1, j, vv)\n\n        _set_range(0, 0, self.size//2, self.DIVIDED)\n\n    def get(self, i):\n        def _get(r, lo, hi):\n            if self.data[r] != self.DIVIDED:\n                return self.data[r]\n            mid = lo + (hi - lo)//2\n            if i <= mid:\n                return _get(r*2 + 1, lo, mid)\n            else:\n                return _get(r*2 + 2, mid+1, hi)\n\n        return _get(0, 0, self.size//2)\n\n\ndef run():\n    n, q = [int(x) for x in input().split()]\n    t = SegmentTree(n)\n\n    for _ in range(q):\n        com, *args = [x for x in input().split()]\n        if com == '0':\n            i, j, v = [int(x) for x in args]\n            t.set_range(i, j, v)\n        elif com == '1':\n            i = int(args[0])\n            print(t.get(i))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ DSL_2_D\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D\n\nINF = (-1, 2**31 - 1)\nline = input()\nn, q = list(map(int, line.split()))\nN = 1\nwhile N < n + 1:\n    N *= 2\na = [INF for _ in range(0, 2 * N - 1)]\n\ndef find(i, k, l, r):\n    z = a[0]\n    while True:\n        m = (l + r) // 2\n        if i < m:\n            k = k * 2 + 1\n            r = m\n        else:\n            k = k * 2 + 2\n            l = m\n        z = max(z, a[k])\n        if k >= N - 1:\n            break\n    return z[1]\n\ndef update(s, t, x, k, l, r):\n    if r <= s or t <= l:\n        return\n    elif s <= l and r <= t:\n        a[k] = x\n        return\n    m = (l + r) // 2\n    update(s, t, x, k * 2 + 1, l, m)\n    update(s, t, x, k * 2 + 2, m, r)\n    return\n\nfor t in range(0, q):\n    line = input()\n    qu = list(map(int, line.split()))\n    if qu[0] == 0:\n        update(qu[1], qu[2]+1, (t, qu[3]), 0, 0, N)\n    elif qu[0] == 1:\n        ans = find(qu[1], 0, 0, N)\n        print(ans)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\nINT_MAX = 2**31 - 1\n\ndef update(tree,x,y,z,N):\n    left = x + N #- 1\n    right = y + N #- 1\n    while True:\n        if(left > right):\n            break\n        if(right > 0):\n            tree[right - 1] = z\n        if(left > 0):\n            tree[left - 1] = z\n\n        left = math.floor((left + 1)/2)\n        right = math.floor((right - 1)/2)\n\ndef find(tree,x,N):\n    x += N - 1\n    s = (INT_MAX, -1)\n    while True:\n        if(x <= 0):\n            break\n        if(tree[x][1] > s[1]):\n            s = tree[x]\n        x = math.floor((x - 1)/2)\n    return s[0]\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    while True:\n        if(N >= _N):\n            break\n        N <<= 1\n    if not (N == 1):\n        A = [(INT_MAX,-1)]*(2*N - 1)\n    else:\n        A = [(INT_MAX,-1)]*(2*N)\n\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            update(A,query[1],query[2],(query[3],i),N)\n            #print(A)\n        # find\n        if(query[0]==1):\n            #z = find(A,lazy_A,query[1],query[1]+1,0,0,N,N)\n            z = find(A,query[1],N)\n            print(z)\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\nINT_MAX = 2**31 - 1\n\ndef update(tree,x,y,z,N):\n    left = x + N #- 1\n    right = y + N#- 1\n\n    while True:\n        if(left >= right):\n            break\n        if(right % 2 == 1):\n            right -= 1\n            tree[right - 1] = z\n        if(left % 2 == 1):\n            tree[left - 1] = z\n            left += 1\n\n        #left += 1#math.floor((left + 1)/2)\n        #right -= 1#math.floor((right - 1)/2)\n        left >>= 1\n        right >>= 1\n\ndef find(tree,x,N):\n    x += N - 1\n    s = (INT_MAX, -1)\n    while True:\n        if(x < 0):\n            break\n        if(tree[x][0] is not None and (tree[x][1] > s[1])):\n            s = tree[x]\n        x = math.floor((x - 1)/2)\n    return s[0]\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    while True:\n        if(N >= _N):\n            break\n        N *= 2\n    A = [(None,-1)]*(2*N - 1)\n\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            update(A,query[1],query[2]+1,(query[3],i),N)\n            #print(A)\n        # find\n        if(query[0]==1):\n            #z = find(A,lazy_A,query[1],query[1]+1,0,0,N,N)\n            z = find(A,query[1],N)\n            print(z)\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "#3158554 By JAKENU0X5E　参照\nn,q = map(int,input().split( ))\ns = 1\nwhile s < n:\n    s*=2\n\nA = [(-1,2**31-1)]*(2*s-1)\n#print(A)\ndef update(l,r,i,v):#A[l,r)および対応する親ノードをiターン目にvに書き換える\n    while l<r:\n        if r&1:\n            r -= 1###-1\n            A[r-1] = (i,v)###-1\n        if l&1:\n            A[l-1]=(i,v)###-1\n            l+=1###+1\n        l//=2\n        r//=2\n\n\nfor i in range(q):\n    c = list(map(int, input().split( )))\n    if not c[0]:\n        x = c[1]\n        y = c[2]\n        u = c[3]\n        x += s ###\n        y += s\n        #x -=1###\n        update(x,y+1,i,u)\n        #print(A)\n            \n    else:\n        res = (-1,0)\n        x = c[1] + s-1\n        while x>=0:\n            #print(res,A[x])\n            if A[x] > res:\n                res = A[x]\n            x -=1\n            x//=2\n        print(res[1])\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),min(n-1,(x+1)*b)):a[i]=lazy[x]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),int(min(n-1,(x+1)*b))):a[i]=l[x]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nINF = 2**31 - 1\n\n\nclass RUQ:\n\n    def __init__(self, n):\n        tmp = 1\n        while tmp < n:\n            tmp *= 2\n        self.n = tmp * 2\n        self.A = [INF] * (2 * self.n - 1)\n\n    def update(self, a, b, x=-1, k=0, l=0, r=0):\n        if r <= a or b <= l:\n            return\n        if a <= l and r <= b:\n            if x >= 0:\n                self.A[k] = x\n            return\n        if self.A[k] != INF:\n            self.A[k*2+1] = self.A[k*2+2] = self.A[k]\n        self.A[k] = INF\n        self.update(a, b, x, k*2+1, l, (l+r)/2)\n        self.update(a, b, x, k*2+2, (l+r)/2, r)\n\n\nline = sys.stdin.readline()\nn, q = map(int, line.split())\nruq = RUQ(n)\nfor i in range(q):\n    line = sys.stdin.readline()\n    if line[0] == \"0\":\n        com, s, t, x = map(int, line.split())\n        ruq.update(s, t+1, x, 0, 0, ruq.n)\n    else:\n        com, i = map(int, line.split())\n        ruq.update(i, i+1, -1, 0, 0, ruq.n)\n        print(ruq.A[i+ruq.n-1])\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef func(x,y):\n    return x if x < y else y\n\nclass LazySegmentTree():\n    def __init__(self, n):\n        n_ = 1\n        c_ = 0\n        while n_ < n:\n            n_ *= 2\n            c_ +=1\n\n        self.lv = c_\n        self.n = n_\n        self.arr = [2**31-1] * (2*self.n-1)\n        self.lazy = [None] * (2*self.n-1)\n\n    #伝播区間\n    def getidx(self, l, r):\n        L = (l + self.n) >> 1\n        R = (r + self.n) >> 1\n        lc = 0 if l & 1 else (L & -L).bit_length()\n        rc = 0 if r & 1 else (R & -R).bit_length()\n        for i in range(self.lv):\n            if rc <= i:\n                yield R\n            if L < R and lc <= i:\n                yield L\n            L >>= 1; R >>=1\n\n    #伝播\n    def propagate(self,*ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.arr[2*i-1] = self.lazy[2*i] = self.arr[2*i] = v\n            self.lazy[i-1] = None\n\n    #[l, r] をxで更新\n    def update(self,l,r,x):\n        #[l, r)に変更\n        r+=1\n        *ids, = self.getidx(l,r)\n        self.propagate(*ids)\n\n        L = self.n + l; R = self.n + r\n        while L < R:\n            if R & 1:\n                R -=1\n                self.lazy[R-1] = self.arr[R-1] = x\n            if L & 1:\n                self.lazy[L-1] = self.arr[L-1] = x\n                L += 1\n            L >>= 1; R >>= 1\n\n        for i in ids:\n            self.arr[i-1] = func(self.arr[2*i-1], self.arr[2*i])\n\n    #[l, r]のクエリに答える\n    def query(self,l,r):\n        #[l, r)に変更\n        r+=1\n        self.propagate(*self.getidx(l,r))\n        L = self.n + l; R = self.n + r\n\n        s = 2**31-1\n        while L < R:\n            if R & 1:\n                R -=1\n                s = func(s, self.arr[R-1])\n            if L & 1:\n                s = func(s, self.arr[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\n#0-indexed なので1-からのときは−１する\nimport sys\ninput=sys.stdin.readline\nn,q=map(int,input().split())\nsg=LazySegmentTree(n)\nfor _ in range(q):\n    l=list(map(int,input().split()))\n    if l[0]==0:\n        c,s,t,x=l\n        sg.update(s,t,x)\n    else:\n        c,i=l\n        print(sg.query(i,i))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nn, q = map(int, input().split())\n\nsize = 2**((n-1).bit_length())\ntree = [None]*(size*2)\nINF = (-1, 2**31-1)\n\ndef _find(i):\n    ind = size+i\n    s = INF\n    while ind:\n        if tree[ind]:\n            s = max(s, tree[ind])\n        ind = ind//2\n    return s\ndef find(i):\n    return _find(i)[1]\n\ndef update(s, t, v):\n    L = s+size;R = t+size\n    while L<R:\n        if L&1:\n            tree[L]=v\n            L+=1\n        if R&1:\n            R-=1\n            tree[R]=v\n\n        L>>=1;R>>=1\n\nres = []\nfor i in range(q):\n    a, *b = map(int, input().split())\n    if a:res.append(find(b[0]))\n    else:update(b[0],b[1]+1,(i,b[2]))\nprint('\\n'.join(map(str,res)))\n"
  },
  {
    "language": "Python",
    "code": "\nclass LazySegTree:\n    inf = 2147483647\n    INF = [-1,2147483647]\n    def __init__(self,n_):\n        self.n_ = n_\n        self.n = 1\n        while self.n < n_: self.n*=2\n        self.st = [self.INF]*(2*self.n-1)\n        self.lazy = [self.INF]*(2*self.n-1)\n\n    def propagate(self,k):\n        if self.lazy[k]==self.INF:return\n        self.st[k] = self.lazy[k][1]\n        if k<self.n_-1:\n            self.lazy[k*2+1] = self.lazy[k]\n            self.lazy[k*2+2] = self.lazy[k]\n        self.lazy[k] = self.INF\n    \n    def update(self,a,b,k,x,l,r):\n        #self.propagate(k)\n        if r<=a or b<=l :return\n        if a<=l and r<=b:\n            self.st[k] = x\n            self.lazy[k] = x\n            return\n        self.update(a,b,k*2+1,x,l,(l+r)//2)\n        self.update(a,b,k*2+2,x,(l+r)//2,r)\n\n    def Update(self,a,b,x):\n        return self.update(a,b,0,x,0,self.n)\n\n    def search(self,k,l,r):\n        #self.propagate(k)\n        k += self.n-1\n        res = self.INF\n        while 0<=k:\n            res = max(res,self.lazy[k])\n            k = (k-1)//2\n        return res[1]\n\n    def Search(self,k):\n        return self.search(k,0,self.n)\n\ndef main():\n    n,m = map(int,input().split())\n    lst = LazySegTree(n)\n    for i in range(m):\n        q = list(map(int,input().split()))\n        if q[0] == 0:\n            lst.Update(q[1],q[2]+1,[i,q[3]])\n        else        :print(lst.Search(q[1]))\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\na = [INT_MAX for i in range(n)]\nl = [-1 for i in range(n)]\n\n\ndef judge_max(x,y):\n    \n    if x > y :return x\n    else:return y \n\ndef judge_min(x,y):\n    if x > y :return y\n    else :return x\n\n\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),min(n-1,int((x+1)*b-1))+1):a[i]=l[x]\n    l[x]=-1\n    return\n \n\nif __name__=='__main__':\n        \n   \n    for j in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,int((x/b+1)*b-1))+1):a[i]=z\n            for i in range(int(x/b+1),int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(max(x,int(y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nclass LazyPropSegmentTree:\n    def __init__(self, lst, op, apply, comp, e, identity):\n        self.n = len(lst)\n        self.depth = (self.n - 1).bit_length()\n        self.N = 1 << self.depth\n        self.op = op # binary operation of elements\n        self.apply = apply # function to apply to an element\n        self.comp = comp # composition of functions\n        self.e = e # identity element w.r.t. op\n        self.identity = identity # identity element w.r.t. comp\n        self.v = self._build(lst) # self.v is set to be 1-indexed for simplicity\n        self.lazy = [self.identity] * (2 * self.N)\n    \n    def __getitem__(self, i):\n        return self.fold(i, i+1)\n    \n    def _build(self, lst):\n        # construction of a tree\n        # total 2 * self.N elements (tree[0] is not used)\n        tree = [self.e] * (self.N) + lst + [self.e] * (self.N - self.n)\n        for i in range(self.N - 1, 0, -1): tree[i] = self.op(tree[i << 1], tree[(i << 1)|1])\n        return tree\n    \n    def _indices(self, l, r):\n        left = l + self.N; right = r + self.N\n        left //= (left & (-left)); right //= (right & (-right))\n        left >>= 1; right >>= 1\n        while left != right:\n            if left > right: yield left; left >>= 1\n            else: yield right; right >>= 1\n        while left > 0: yield left; left >>= 1\n    \n    # propagate self.lazy and self.v in a top-down manner\n    def _propagate_topdown(self, *indices):\n        identity, v, lazy, apply, comp = self.identity, self.v, self.lazy, self.apply, self.comp\n        for k in reversed(indices):\n            x = lazy[k]\n            if x == identity: continue\n            lazy[k << 1] = comp(lazy[k << 1], x)\n            lazy[(k << 1)|1] = comp(lazy[(k << 1)|1], x)\n            v[k << 1] = apply(v[k << 1], x)\n            v[(k << 1)|1] = apply(v[(k << 1)|1], x)\n            lazy[k] = identity # propagated\n\n    # propagate self.v in a bottom-up manner\n    def _propagate_bottomup(self, indices):\n        v, op = self.v, self.op\n        for k in indices: v[k] = op(v[k << 1], v[(k << 1)|1])\n\n    # update for the query interval [l, r) with function x\n    def update(self, l, r, x):\n        *indices, = self._indices(l, r)\n        self._propagate_topdown(*indices)\n        \n        N, v, lazy, apply, comp = self.N, self.v, self.lazy, self.apply, self.comp\n        \n        # update self.v and self.lazy for the query interval [l, r)\n        left = l + N; right = r + N\n        if left & 1: v[left] = apply(v[left], x); left += 1\n        if right & 1: right -= 1; v[right] = apply(v[right], x)\n        left >>= 1; right >>= 1\n        while left < right:\n            if left & 1:\n                lazy[left] = comp(lazy[left], x)\n                v[left] = apply(v[left], x)\n                left += 1\n            if right & 1:\n                right -= 1\n                lazy[right] = comp(lazy[right], x)\n                v[right] = apply(v[right], x)\n            left >>= 1; right >>= 1\n        self._propagate_bottomup(indices)\n    \n    # returns answer for the query interval [l, r)\n    def fold(self, l, r):\n        self._propagate_topdown(*self._indices(l, r))\n        \n        e, N, v, op = self.e, self.N, self.v, self.op\n        \n        # calculate the answer for the query interval [l, r)\n        left = l + N; right = r + N\n        L = R = e\n        while left < right:\n            if left & 1: # self.v[left] is the right child\n                L = op(L, v[left])\n                left += 1\n            if right & 1: # self.v[right-1] is the left child\n                right -= 1\n                R = op(v[right], R)\n            left >>= 1; right >>= 1\n        return op(L, R)\n    \nN, Q = map(int, input().split())\nop = min\napply = lambda x, f: f\ncomp = lambda f, g: g\ne = 2**31 - 1\nidentity = None\nA = [e] * N\nlpsg = LazyPropSegmentTree(A, op, apply, comp, e, identity)\nans = []\nfor _ in range(Q):\n    t, *arg, = map(int, input().split())\n    if t == 0:\n        s, t, x = arg\n        lpsg.update(s, t+1, x)\n    else:\n        ans.append(lpsg[arg[0]])\nprint('\\n'.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q= l = map(int, raw_input().split())\nb= int(math.sqrt(n))\n\n\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),min(n-1,int((x+1)*b-1))+1):a[i]=l[x]\n    l[x]=-1\n    return\n \n\nif __name__=='__main__':\n        \n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n    for j in range(q):\n        t = map(int, raw_input().split())\n        if t[0] : \n            x = t[1]\n            if l[int(x/b)] != -1:update(x/b)\n            print a[x]\n        else:\n            t0,x,y,z=t\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,int((x/b+1)*b-1))+1):a[i]=z\n            for i in range(int(x/b+1),int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(max(x,int(y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\nsys.setrecursionlimit(20000)\ndef update(Set,x,y,z):\n    for i in range(x,y+1):\n        Set[i] = z\n\ndef lazy_update(Set,x,y,z):\n    left = int(x/4)\n    if((x%4)!=0):\n        left = left + 1\n    right = int(y/4)\n    for i in range(left,right):\n        Set[i] = z\n    return left*4,right*4\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    A = [2**31 - 1]*_N\n    N = 1\n    while True:\n        if(N*4 >= _N):\n            break\n        N += 1\n    lazy_A = [None]*N\n    #start = time.time()\n    #print(A,lazy_A)\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            if(lazy_A[int(query[1]/4)] is not None or lazy_A[int(query[2]/4)] is not None):\n                for i in range(int(query[1]/4),int(query[2]/4)+1):\n                    if(lazy_A[i] is None):\n                        continue\n                    A[i*4:i*4+4] = [lazy_A[i]]*4\n                    lazy_A[i] = None\n                #print(\"A update from lazy\")\n                #print(A)\n                #print(lazy_A)\n                update(A,query[1],query[2],query[3])\n                #print(\"update A\")\n                #print(A)\n            elif(lazy_A[int(query[1]/4)] is None or lazy_A[int(query[2]/4)] is None):\n                if(query[2] - query[1] < 4):\n                    update(A,query[1],query[2],query[3])\n                    #print(\"A update\")\n                    #print(A)\n                else:\n                    right, left = lazy_update(lazy_A,query[1],query[2],query[3])\n                    #print(\"lazy update\")\n                    #print(lazy_A)\n                    if(right > 0):\n                        #print(\"A left update\")\n                        update(A,query[1],right-1,query[3])\n                        #print(A)\n                    if(left > 0):\n                        #print(\"A right update\")\n                        update(A,left,query[2],query[3])\n                        #print(A)\n        # find\n        if(query[0]==1):\n            if(lazy_A[int(query[1]/4)] is not None):\n                A[int(query[1]/4)*4:int(query[1]/4)*4+4] = [lazy_A[int(query[1]/4)]]*4\n                lazy_A[int(query[1]/4)] = None\n                #print(\"A update from lazy\")\n                #print(A)\n            print(A[query[1]])\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "from math import log2, ceil\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        tn = 2 ** ceil(log2(n))\n        self.a = [2 ** 31 - 1] * (tn * 2)\n\n    def find(self, c, l, r, i):\n        if self.a[c] != -1:\n            return self.a[c]\n        mid = (l + r) // 2\n        if i <= mid:\n            return self.find(c * 2, l, mid, i)\n        else:\n            return self.find(c * 2 + 1, mid + 1, r, i)\n\n    def update(self, c, l, r, s, t, x):\n        if l == s and r == t:\n            self.a[c] = x\n            return\n        cv = self.a[c]\n        if cv != -1:\n            self.a[c * 2] = self.a[c * 2 + 1] = cv\n            self.a[c] = -1\n        mid = (l + r) // 2\n        if t <= mid:\n            self.update(c * 2, l, mid, s, t, x)\n        elif s > mid:\n            self.update(c * 2 + 1, mid + 1, r, s, t, x)\n        else:\n            self.update(c * 2, l, mid, s, mid, x)\n            self.update(c * 2 + 1, mid + 1, r, mid + 1, t, x)\n\n\nn, q = map(int, input().split())\nst = SegmentTree(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '0':\n        s, t, x = map(int, query[1:])\n        st.update(1, 0, n - 1, s, t, x)\n    else:\n        print(st.find(1, 0, n - 1, int(query[1])))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#INF = 2**31 -1\n#n, q = list(map(int, input().split()))\n#\n#lis = [INF for i in range(n)]\n#\n#for i in range(q):\n#  data = list(map(int, input().split()))\n#  if len(data) == 4:\n#    a, s, t, x = data\n#    for j in range(s, t+1):\n#      lis[j] = x\n#  else: \n#    b, k = data\n#    print(lis[k])\n\n\n\nINF = 2**31 - 1\nn, q = list(map(int, input().split()))\nlazy = [None for i in range(4*n)]\nfor i in range(n):\n  lazy[i] = INF\n\ndef updata(a, b, x, k, l, r):\n  m = (l+r)//2\n  if a >= r or b <= l:\n    return 0\n  elif a <= l and b >= r:\n    lazy[k] = x\n  else:\n    if lazy[k] != None:\n      lazy[k*2+1] = lazy[k]\n      lazy[k*2+2] = lazy[k]\n      lazy[k] = None\n    updata(a, b, x, k*2+1, l, m)\n    updata(a, b, x, k*2+2, m, r)\n\ndef find(x, k, l, r):\n  m = (l+r)//2\n  if lazy[k] != None:\n    print(lazy[k])\n  else:\n    if x < (l+r)//2:\n      find(x, k*2+1, l, m)\n    else:\n      find(x, k*2+2, m, r)\n      \nfor i in range(q):\n  data = list(map(int, input().split()))\n  if len(data) == 4:\n    f, a, b, x = data\n    updata(a, b+1, x, 0, 0, n)\n  else:\n    f, i = data\n    find(i, 0, 0, n)\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\n\ndef judge_max(x,y):\n    \n    if x > y :return x\n    else:return y \n\ndef judge_min(x,y):\n    if x > y :return y\n    else :return x\n\n\n\ndef update(x):\n \n    for i in range(int(x*b),int(judge_min(n-1,(x+1)*b))):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(judge_min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(judge_max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nn,q=(int(x) for x in input().split())\nb= int(math.sqrt(n))\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),min(n-1,int((x+1)*b-1))+1):a[i]=l[x]\n    l[x]=-1\n    return\n \n\nif __name__=='__main__':\n        \n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n    for j in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,int((x/b+1)*b-1))+1):a[i]=z\n            for i in range(int(x/b+1),int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(max(x,int(y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "class SegmentTreeDual():\n    def __init__(self,arr,op=lambda x,y:y if y != -1 else x,ie=-1):\n        self.h = (len(arr)-1).bit_length()\n        self.n = 2**self.h\n        self.ie = ie\n        self.op = op\n        self.val = [ie for _ in range(len(arr))]\n        self.laz = [ie for _ in range(2*self.n)]\n        for i in range(len(arr)):\n            self.val[i] = arr[i]\n    def propagate(self,k):\n        if self.laz[k] == self.ie:\n            return\n        if self.n <= k:\n            self.val[k-self.n] = self.op(self.val[k-self.n],self.laz[k])\n            self.laz[k] = self.ie\n        else:\n            self.laz[(k<<1)] = self.op(self.laz[(k<<1)],self.laz[k])\n            self.laz[(k<<1)+1] = self.op(self.laz[(k<<1)+1],self.laz[k])\n            self.laz[k] = self.ie\n    def update(self,left,right,f):\n        left += self.n\n        right += self.n\n        for i in reversed(range(self.h+1)):\n            self.propagate(left>>i)\n        for i in reversed(range(self.h+1)):\n            self.propagate((right-1)>>i)\n        while right - left > 0:\n            if right & 1:\n                right -= 1\n                self.laz[right] = self.op(self.laz[right],f)\n            if left & 1:\n                self.laz[left] = self.op(self.laz[left],f)\n                left += 1\n            left >>= 1\n            right >>= 1\n    def get(self,index):\n        res = self.val[index]\n        index += self.n\n        while index:\n            res = self.op(res,self.laz[index])\n            index //= 2\n        return res\n\nINF = 2**31-1\nN,Q = map(int,input().split())\nA = [INF for _ in range(N)]\nsg = SegmentTreeDual(A)\nans = []\n\nfor _ in range(Q):\n    q = list(map(int,input().split()))\n    if q[0] == 0:\n        s,t,x = q[1:]\n        sg.update(s,t+1,x)\n    else:\n        i = q[1]\n        ans.append(sg.get(i))\n\nprint('\\n'.join(map(str,ans)))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nINF = 2**31 - 1\n\n\nclass RUQ:\n\n    def __init__(self, n):\n        tmp = 1\n        while tmp < n:\n            tmp *= 2\n        self.n = tmp * 2\n        self.A = [INF] * (2 * self.n - 1)\n\n    def update(self, a, b, x=-1, k=0, l=0, r=0):\n        if r <= a or b <= l:\n            return\n        if a <= l and r <= b:\n            if x >= 0:\n                self.A[k] = x\n            return\n        if self.A[k] != INF:\n            self.A[k*2+1] = self.A[k*2+2] = self.A[k]\n        self.A[k] = INF\n        self.update(a, b, x, k*2+1, l, (l+r)/2)\n        self.update(a, b, x, k*2+2, (l+r)/2, r)\n\n\nline = sys.stdin.readline()\nn, q = map(int, line.split())\nruq = RUQ(n)\nfor i in range(q):\n    line = sys.stdin.readline()\n    if line[0] == \"0\":\n        com, s, t, x = map(int, line.split())\n        ruq.update(s, t+1, x, 0, 0, ruq.n)\n    else:\n        com, i = map(int, line.split())\n        ruq.update(i, i+1, -1, 0, 0, ruq.n)\n        print(ruq.A[i+ruq.n-1])\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),(min(n-1,(x+1)*b)):a[i]=l[x]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "class RUQ(object):\n    INF = 2 ** 31 - 1\n\n    def __init__(self, num) -> None:\n        n = 1\n        while n <= num:\n            n = n * 2\n        self.n = n\n        self.val = [self.INF] * (2 * n - 1)\n\n    def update(self, beg: int, end: int, k: int, l: int, r: int, x: int) -> None:\n        if (l == beg and r == end):\n            self.val[k] = x\n            return\n        cv = self.val[k]\n        if (cv != -1):\n            self.val[k * 2] = self.val[k * 2 + 1] = cv\n            self.val[k] = -1\n        mid = (l + r) // 2\n        if (end <= mid):\n            self.update(beg, end, k * 2, l, mid, x)\n        elif (beg > mid):\n            self.update(beg, end, k * 2 + 1, mid + 1, r, x)\n        else:\n            self.update(beg, mid, k * 2, l, mid, x)\n            self.update(mid + 1, end, k * 2 + 1, mid + 1, r, x)\n\n    def find(self, k: int, l: int, r: int, idx: int) -> int:\n        if self.val[k] != -1:\n            return self.val[k]\n        mid = (l + r) // 2\n        if (idx <= mid):\n            return self.find(k * 2, l, mid, idx)\n        else:\n            return self.find(k * 2 + 1, mid + 1, r, idx)\n\n\nif __name__ == \"__main__\":\n    n, q = map(lambda x: int(x), input().split())\n    ruq = RUQ(n)\n\n    for _ in range(q):\n        com, *v = map(lambda x: int(x), input().split())\n        if (0 == com):\n            ruq.update(v[0], v[1], 1, 0, n - 1, v[2])\n        else:\n            print(f\"{ruq.find(1, 0, n - 1, v[0])}\")\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),min(n-1,(x+1)*b)):a[i]=l[x]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),min(n-1,(x+1)*b)):a[i]=l[int(x)]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(20000)\ndef update(Set,x,y,z):\n    for i in range(x,y+1):\n        Set[i] = z\n\ndef lazy_update(Set,x,y,z):\n    left = int(x/4)\n    if((x%4)!=0):\n        left = left + 1\n    right = int(y/4)\n    for i in range(left,right):\n        Set[i] = z\n    return left*4,right*4\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    A = [2**31 - 1]*_N\n    N = 1\n    while True:\n        if(N*4 >= _N):\n            break\n        N += 1\n    lazy_A = [None]*N\n    #print(A,lazy_A)\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            if(lazy_A[int(query[1]/4)] is not None or lazy_A[int(query[2]/4)] is not None):\n                for i in range(int(query[1]/4),int(query[2]/4)+1):\n                    if(lazy_A[i] is None):\n                        continue\n                    A[i*4:i*4+4] = [lazy_A[i]]*4\n                    lazy_A[i] = None\n                #print(\"A update from lazy\")\n                #print(A)\n                #print(lazy_A)\n                update(A,query[1],query[2],query[3])\n                #print(\"update A\")\n                #print(A)\n            if(lazy_A[int(query[1]/4)] is None or lazy_A[int(query[2]/4)] is None):\n                if(query[2] - query[1] < 4):\n                    update(A,query[1],query[2],query[3])\n                    #print(\"A update\")\n                    #print(A)\n                else:\n                    right, left = lazy_update(lazy_A,query[1],query[2],query[3])\n                    #print(\"lazy update\")\n                    #print(lazy_A)\n                    if(right > 0):\n                        #print(\"A left update\")\n                        update(A,query[1],right-1,query[3])\n                        #print(A)\n                    if(left > 0):\n                        #print(\"A right update\")\n                        update(A,left,query[2],query[3])\n                        #print(A)\n        # find\n        if(query[0]==1):\n            if(lazy_A[int(query[1]/4)] is not None):\n                A[int(query[1]/4)*4:int(query[1]/4)*4+4] = [lazy_A[int(query[1]/4)]]*4\n                lazy_A[int(query[1]/4)] = None\n                #print(\"A update from lazy\")\n                #print(A)\n            print(A[query[1]])\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef lazy_update(s, e, value):\n    a = [(1, l+s, l+e, 1)]\n    ap = a.append\n    while a:\n        k, s, e, depth = a.pop()\n        l_end, r_end = k << (rank-depth), (k+1) << (rank-depth)\n        mid = (l_end + r_end) // 2\n\n        if s == l_end and e == r_end:\n            lazy[k] = value\n        else:\n            child = k<<1\n            if lazy[k] is not None:\n                lazy[child] = lazy[k]\n                lazy[child+1] = lazy[k]\n                lazy[k] = None\n            if s < mid:\n                ap((child, s, (mid, e)[e<mid], depth+1))\n            if e > mid:\n                ap((child+1, (mid, s)[s>mid], e, depth+1))\n\ndef get_value(i):\n    i += l\n    for j in range(rank, -1, -1):\n        n = lazy[i>>j]\n        if n is not None:\n            return n\n    return tree[i]\n\nn, q = map(int,input().split())\nl = 1 << math.ceil(math.log2(n))\ntree = [2**31-1]*(2*l)\nlazy = [None]*(2*l)\nrank = int(math.log2(len(tree)))\nans = []\nap = ans.append\n\nfor _ in [None]*q:\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        lazy_update(query[1], query[2]+1, query[3])\n    else:\n        ap(get_value(query[1]))\n\nprint(\"\\n\".join((str(n) for n in ans)))"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nn,q= l = map(int, raw_input().split())\nb= int(math.sqrt(n))\n\n\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),min(n-1,int((x+1)*b-1))+1):a[i]=l[x]\n    l[x]=-1\n    return\n \n\nif __name__=='__main__':\n        \n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n    for j in range(q):\n        t = map(int, raw_input().split())\n        if t[0] : \n            x = t[1]\n            if l[int(x/b)] != -1:update(x/b)\n            print a[x]\n        else:\n            t0,x,y,z=t\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,int((x/b+1)*b-1))+1):a[i]=z\n            for i in range(int(x/b+1),int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(max(x,int(y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# DSL_2_D: Range Update Query\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        size = 1\n        while size < n:\n            size *= 2\n        self.size = 2*size - 1\n        self.data = [-1] * self.size\n        self.data[0] = 2**31 - 1\n\n    def set_range(self, lo, hi, v):\n        def _set_range(r, i, j, vv):\n            if j < lo or i > hi:\n                if vv != -1:\n                    self.data[r] = vv\n            elif lo <= i and j <= hi:\n                self.data[r] = v\n            else:\n                if self.data[r] != -1:\n                    vv = self.data[r]\n                    self.data[r] = -1\n                mid = i + (j - i)//2\n                _set_range(r*2 + 1, i, mid, vv)\n                _set_range(r*2 + 2, mid+1, j, vv)\n\n        _set_range(0, 0, self.size//2, -1)\n\n    def get(self, i):\n        def _get(r, lo, hi):\n            if self.data[r] != -1:\n                return self.data[r]\n            mid = lo + (hi - lo)//2\n            if i <= mid:\n                return _get(r*2 + 1, lo, mid)\n            else:\n                return _get(r*2 + 2, mid+1, hi)\n\n        return _get(0, 0, self.size//2)\n\n\ndef run():\n    n, q = [int(x) for x in input().split()]\n    t = SegmentTree(n)\n\n    for _ in range(q):\n        com, *args = [x for x in input().split()]\n        if com == '0':\n            i, j, v = [int(x) for x in args]\n            t.set_range(i, j, v)\n        elif com == '1':\n            i = int(args[0])\n            print(t.get(i))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport time\nsys.setrecursionlimit(20000)\ndef update(Set,x,y,z):\n    for i in range(x,y+1):\n        Set[i] = z\n\ndef lazy_update(Set,i,x):\n    Set[i] = x\n\nif __name__ == '__main__':\n    _N,query_num = map(int, input().split())\n    N = 1\n    sqrtN = 1\n    while True:\n        if(N >= _N):\n            break\n        sqrtN += 1\n        N = sqrtN**2\n    A = [2**31 - 1]*N\n    lazy_A = [None]*sqrtN\n    #start = time.time()\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        # update\n        if(query[0]==0):\n            for i in range(0,sqrtN):\n                if((i+1)*sqrtN <= query[1] or query[2] <= i*sqrtN):\n                    continue\n                if(query[1] <= i*sqrtN and (i+1)*sqrtN <= query[2]):\n                    if not (lazy_A[i] == query[3]):\n                        lazy_update(lazy_A,i,query[3])\n                else:\n                    if(lazy_A[i] is not None):\n                        A[i*sqrtN:(i+1)*sqrtN] = [lazy_A[i]]*sqrtN\n                        lazy_A[i] = None\n                    n = max(query[1],i*sqrtN)\n                    m = min(query[2],(i+1)*sqrtN)\n                    #print(\"max from {0} {1}\".format(query[1],i*sqrtN))\n                    #print(\"min from {0} {1}\".format(query[2],(i+1)*sqrtN))\n                    #print(n,m)\n                    update(A,n,m,query[3])\n                    #update(A,(i+1)*sqrtN+1,query[2],query[3])\n            #print(A)\n        # find\n        if(query[0]==1):\n            if(lazy_A[int(query[1]/sqrtN)] is not None):\n                A[int(query[1]/sqrtN)*sqrtN:int(query[1]/sqrtN)*sqrtN+sqrtN] = [lazy_A[int(query[1]/sqrtN)]]*sqrtN\n                lazy_A[int(query[1]/sqrtN)] = None\n                #print(\"A update from lazy\")\n                #print(A)\n            print(A[query[1]])\n    #elapsed_time = time.time() - start\n    #print (\"elapsed_time:{0}\".format(elapsed_time) + \"[sec]\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n_input = sys.stdin.readlines()\nn,q = map(int, _input[0].split())\nqlist = map(lambda x:x.split(), _input[1:])\nMAX = pow(2, 31) - 1\n\nA = [MAX] * n\nfor q in qlist:\n    cmd = int(q[0])\n    if cmd == 0:\n        s = int(q[1])\n        t = int(q[2])+1\n        add = [int(q[3])] * (t - s)\n        A = A[:s] + add + A[t:]\n    elif cmd == 1:\n        print(A[int(q[1])])"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\ndef update(x):\n \n    for i in range(int(x*b),min(n-1,(x+1)*b)):a[i]=lazy[x]\n    l[x]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,(x/b+1)*b)):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\n\ndef judge_max(x,y):\n    \n    if x > y :return x\n    else:return y \n\ndef judge_min(x,y):\n    if x > y :return y\n    else return x\n\n\n\ndef update(x):\n \n    for i in range(int(x*b),int(judge_min(n-1,(x+1)*b))):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(judge_min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(judge_max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\n\ndef judge_max(x,y):\n    \n    if x > y :return x\n    else:return y \n\ndef judge_min(x,y):\n    if x > y :return y\n    else :return x\n\n\n\ndef update(x):\n \n    for i in range(int(x*b),int(judge_min(n-1,(x+1)*b))):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(judge_min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(judge_max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= math.sqrt(n)\n\n\ndef judge_max(x,y):\n    \n    if x > y :return x\n    else:return y \n\ndef judge_min(x,y):\n    if x > y :return y\n    else :return x\n\n\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),int(judge_min(n-1,(x+1)*b))):a[i]=l[int(x)]\n    l[int(x)]=-1;\n    return;\n \n\nif __name__=='__main__':\n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n   \n    for i in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,int(judge_min(y,(x/b+1)*b))):a[i]=z\n            for i in range(int(x/b)+1,int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(int(judge_max(x,y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nn, q = map(int, input().split())\n\nsize = 2**((n-1).bit_length())\ntree = [None]*(size*2)\nINF = (-1, 2**31-1)\n\ndef _find(i):\n    ind = size+i\n    s = INF\n    while ind:\n        if tree[ind]:\n            s = max(s, tree[ind])\n        ind = ind//2\n    return s\ndef find(i):\n    return _find(i)[1]\n\ndef update(s, t, v):\n    L = s+size;R = t+size\n    while L<R:\n        if R&1:\n            R-=1\n            tree[R]=v\n        if L&1:\n            tree[L]=v\n            L+=1\n        L>>=1;R>>=1\n\nans = []\nfor i in range(q):\n    a, *b = map(int, input().split())\n    if a:ans.append(find(b[0]))\n    else:update(b[0],b[1]+1,(i,b[2]))\nprint('\\n'.join(map(str,ans)))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nINT_MAX = 2147483647\nMAX = 100003\nn,q=(int(x) for x in input().split())\nb= int(math.sqrt(n))\n\n\n\ndef update(x_f):\n    \n    x = int(x_f)\n    for i in range(int(x*b),min(n-1,int((x+1)*b-1))+1):a[i]=l[x]\n    l[x]=-1\n    return\n \n\nif __name__=='__main__':\n        \n    a = [INT_MAX for i in range(n)]\n    l = [-1 for i in range(n)]\n    \n    for j in range(q):\n        t, *com = (int(x) for x in input().split())\n        if t : \n            x = com[0]\n            if l[int(x/b)] != -1:update(x/b)\n            print(a[x])\n        else:\n            x,y,z = com\n            if l[int(x/b)] != -1:update(x/b)\n            for i in range(x,min(y,int((x/b+1)*b-1))+1):a[i]=z\n            for i in range(int(x/b+1),int(y/b)):l[i]=z\n            if l[int(y/b)] != -1:update(y/b)\n            for i in range(max(x,int(y/b**2)),y+1):a[i]=z\n\n            \n\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nSegment-Tree\n    maxval:入力されるデータ以上の値\n    offset:根と枝の数(n=1のときは根1つ葉2つの木)\n    init_array(array):配列で初期化\n    update(k,x):k番目をxに変更\n    sum_query(p,q):[p,q)の範囲の合計\n\"\"\"\nclass SegmentTree():\n    maxval=(1<<31)-1\n\n    def __init__(self,n):\n        self.offset=self.setOffset(n)\n        self.segTree=[(0,self.maxval) for i in range(2*self.offset+1)]\n        self.time=0\n\n    def setOffset(self,n):\n        if n==1:\n            return 1\n        else:\n            return 2**(n-1).bit_length()-1\n\n    def find(self,k):\n        k+=self.offset\n        data=self.segTree[k]\n        while k:\n            k=(k-1)//2\n            data=max(data,self.segTree[k])\n        return data\n\n    def update_query(self,p,q,x):\n        if p>=q:\n            return\n\n        self.time+=1\n        p+=self.offset\n        q+=self.offset-1\n        v=(self.time,x)\n\n        while q-p>1:\n            #p%2==0\n            if not p&1:\n                self.segTree[p]=v\n            #q%2==1\n            if q&1:\n                self.segTree[q]=v\n                q-=1\n            p=p//2\n            q=(q-1)//2\n\n        if p==q:\n            self.segTree[p]=v\n        else:\n            self.segTree[p]=v\n            self.segTree[q]=v\n\n    def show(self):\n        print(self.segTree)\n\nn,q=map(int,input().split())\nST=SegmentTree(n)\nfor i in range(q):\n    qry=list(map(int,input().split()))\n    if qry[0]==0:\n        ST.update_query(qry[1],qry[2]+1,qry[3])\n    else:\n        print(ST.find(qry[1])[1])\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n#from collections import defaultdict\n#from heapq import heappush, heappop\n#import numpy as np\nimport sys\n\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.buffer.readline\nINF = 2 ** 31 - 1  # sys.maxsize # float(\"inf\")\nMOD = 10 ** 9 + 7\n\ndebug_indent = 0\n\n\ndef debug(*x):\n    global debug_indent\n    x = list(x)\n    indent = 0\n    if x[0].startswith(\"enter\") or x[0][0] == \">\":\n        indent = 1\n    if x[0].startswith(\"leave\") or x[0][0] == \"<\":\n        debug_indent -= 1\n    x[0] = \"  \" * debug_indent + x[0]\n    print(*x, file=sys.stderr)\n    debug_indent += indent\n\n\ndef set_depth(depth):\n    global N, SEGTREE_SIZE, NONLEAF_SIZE\n    N = depth\n    SEGTREE_SIZE = 1 << N\n    NONLEAF_SIZE = 1 << (N - 1)\n\n\ndef range_update(table, left, right, action):\n    left += SEGTREE_SIZE // 2\n    right += SEGTREE_SIZE // 2\n    while left < right:\n        if left & 1:\n            table[left] = action(table[left])\n            left += 1\n        if right & 1:\n            right -= 1\n            table[right] = action(table[right])\n        left //= 2\n        right //= 2\n\n\ndef down_propagate_to_leaf(table, pos, binop, unity):\n    pos += NONLEAF_SIZE\n    down_propagate(table, pos, binop, unity)\n    return table[pos]\n\n\ndef down_propagate(table, pos, binop, unity):\n    for max_level in range(N):\n        if 2 ** max_level > pos:\n            max_level -= 1\n            break\n    for level in range(max_level):\n        i = pos >> (max_level - level)\n\n        table[i * 2] = binop(table[i], table[i * 2])\n        table[i * 2 + 1] = binop(table[i], table[i * 2 + 1])\n        table[i] = unity\n\n\ndef set_items(table, xs):\n    for i, x in enumerate(xs, NONLEAF_SIZE):\n        table[i] = x\n\n\ndef debugprint(xs, minsize=0, maxsize=None):\n    strs = [str(x) for x in xs]\n    if maxsize != None:\n        for i in range(NONLEAF_SIZE, SEGTREE_SIZE):\n            strs[i] = strs[i][:maxsize]\n    s = max(len(s) for s in strs[NONLEAF_SIZE:])\n    if s > minsize:\n        minsize = s\n\n    result = [\"|\"] * N\n    level = 0\n    next_level = 2\n    for i in range(1, SEGTREE_SIZE):\n        if i == next_level:\n            level += 1\n            next_level *= 2\n        width = ((minsize + 1) << (N - 1 - level)) - 1\n        result[level] += strs[i].center(width) + \"|\"\n    print(*result, sep=\"\\n\")\n\n\ndef main():\n    from operator import add\n    N, Q = map(int, input().split())\n    depth = N.bit_length() + 1\n    set_depth(depth)\n    action_unity = (-1, INF)\n    table = [action_unity] * SEGTREE_SIZE\n\n    for time in range(Q):\n        q, *args = map(int, input().split())\n        if q == 0:\n            # update\n            s, t, new_value = args\n            range_update(table, s, t + 1, lambda x: (time, new_value))\n\n        else:\n            # find\n            print(down_propagate_to_leaf(\n                table, args[0], max, action_unity)[1])\n\n\n# tests\nT1 = \"\"\"\n3 5\n0 0 1 1\n0 1 2 3\n0 2 2 2\n1 0\n1 1\n\"\"\"\n\n\ndef test_T1():\n    \"\"\"\n    >>> as_input(T1)\n    >>> main()\n    1\n    3\n    \"\"\"\n# add tests above\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\n\ndef as_input(s):\n    \"use in test, use given string as input file\"\n    import io\n    global read, input\n    f = io.StringIO(s.strip())\n\n    def input():\n        return bytes(f.readline(), \"ascii\")\n\n    def read():\n        return bytes(f.read(), \"ascii\")\n\n\nUSE_NUMBA = False\nif (USE_NUMBA and sys.argv[-1] == 'ONLINE_JUDGE') or sys.argv[-1] == '-c':\n    print(\"compiling\")\n    from numba.pycc import CC\n    cc = CC('my_module')\n    cc.export('solve', solve.__doc__.strip().split()[0])(solve)\n    cc.compile()\n    exit()\nelse:\n    input = sys.stdin.buffer.readline\n    read = sys.stdin.buffer.read\n\n    if (USE_NUMBA and sys.argv[-1] != '-p') or sys.argv[-1] == \"--numba\":\n        # -p: pure python mode\n        # if not -p, import compiled module\n        from my_module import solve  # pylint: disable=all\n    elif sys.argv[-1] == \"-t\":\n        print(\"testing\")\n        _test()\n        sys.exit()\n    elif sys.argv[-1] != '-p' and len(sys.argv) == 2:\n        # input given as file\n        input_as_file = open(sys.argv[1])\n        input = input_as_file.buffer.readline\n        read = input_as_file.buffer.read\n\n    main()\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ( $x:ident [ $i:expr ] ) => {\n        if cfg!(debug_assertions) {\n            println!(\"{}[{}] = {:?}\", stringify!($x), $i, $x[$i]);\n        }\n    };\n    ( $x:ident [ $i:expr ][ $j:expr ] ) => {\n        if cfg!(debug_assertions) {\n            println!(\"{}[{}][{}] = {:?}\", stringify!($x), $i, $j, $x[$i][$j]);\n        }\n    };\n    ( $x:expr ) => {\n        if cfg!(debug_assertions) {\n            println!(\"{}:{} {} = {:?}\", line!(), column!(), stringify!($x), $x);\n        }\n    };\n}\n\n/// Return the smallest power of 2 such that<br>\n/// it is greater than or equal to <code>x</code>.\n/// # Panics\n/// <code>x == 0</code> will cause underflow.\npub fn clp(mut x: usize) -> usize {\n    x -= 1;\n    x = x | (x >>  1);\n    x = x | (x >>  2);\n    x = x | (x >>  4);\n    x = x | (x >>  8);\n    x = x | (x >> 16);\n    x = x | (x >> 32);\n    x + 1\n}\n\nstruct RangeUpdateQuery<T, F> where\n    T: Copy,\n    F: Fn(T, T) -> T\n{\n    n: usize,\n    f: F,\n    unit: T,\n    a: Vec<Option<T>>,\n}\n\nimpl<T, F> RangeUpdateQuery<T, F> where\n    T: Copy + std::fmt::Debug,\n    F: Fn(T, T) -> T\n{\n    pub fn new(m: usize, f: F, unit: T) -> RangeUpdateQuery<T, F> {\n        let n = clp(m);\n        Self {\n            n: n,\n            f: f,\n            unit: unit,\n            a: vec![Some(unit); 2 * n - 1]\n        }\n    }\n\n    fn _update(&mut self, update_first: usize, update_last: usize, new_value: T, node: usize, node_first: usize, node_last: usize) {\n        //println!(\"update_first = {}, update_last = {}, node = {}, node_first = {}, node_last = {}\",\n    //        update_first, update_last, node, node_first, node_last);\n        if node_last <= update_first || update_last <= node_first {\n         //   println!(\"nothing to do\");\n            return;\n        } else if update_first <= node_first && node_last <= update_last {\n          //  println!(\"change all elements\");\n            self.a[node] = Some(new_value);\n        } else {\n           // println!(\"split\");\n            if self.a[node].is_some() {\n                self.a[2 * node + 1] = self.a[node];\n                self.a[2 * node + 2] = self.a[node];\n                self.a[node] = None;\n            }\n            let node_mid: usize = node_first + (node_last - node_first) / 2;\n            self._update(update_first, update_last, new_value, 2 * node + 1, node_first, node_mid);\n            self._update(update_first, update_last, new_value, 2 * node + 2, node_mid, node_last);\n        }\n    }\n\n    pub fn update(&mut self, update_first: usize, update_last: usize, new_value: T) {\n        let n = self.n;\n        self._update(update_first, update_last, new_value, 0, 0, n);\n    }\n\n    fn _query(&self, query_first: usize, query_last: usize, node: usize, node_first: usize, node_last: usize) -> T {\n        //println!(\"query_first = {}, query_last = {}, node = {}, node_first = {}, node_last = {}\",\n     //       query_first, query_last, node, node_first, node_last);\n        if node_last <= query_first || query_last <= node_first {\n         //   println!(\"out of search scope, return unit\");\n            self.unit\n        } else if query_first <= node_first && node_last <= query_last && self.a[node].is_some() {\n          //  println!(\"already calculated, return {:?}\", self.a[node].unwrap());\n            self.a[node].unwrap()\n        } else {\n            if self.a[node].is_some() {\n           //     println!(\"already calculated case2, return {:?}\", self.a[node].unwrap());\n                return self.a[node].unwrap();\n            }\n            //println!(\"new calculation start\");\n            let node_mid: usize = node_first + (node_last - node_first) / 2;\n            let left: T = self._query(query_first, query_last, node * 2 + 1, node_first, node_mid);\n            let right: T = self._query(query_first, query_last, node * 2 + 2, node_mid, node_last);\n            //println!(\"new calculation end. return {:?}\", (self.f)(left, right));\n            (self.f)(left, right)\n        }\n    }\n\n    pub fn query(&self, first: usize, last: usize) -> T {\n        self._query(first, last, 0, 0, self.n)\n    }\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut stdin = my::io::InputReader::new(stdin.lock());\n\n    let n: usize = stdin.read();\n    let q: usize = stdin.read();\n    let mut ruq = RangeUpdateQuery::new(n, |x, y| std::cmp::max(x, y), std::i32::MIN);\n    for _ in 0..q {\n        let query_type: i32 = stdin.read();\n        if query_type == 0 {\n            let first: usize = stdin.read();\n            let last: usize = stdin.read::<usize>() + 1;\n            let x: i32 = stdin.read();\n            //println!(\"update query [{}, {}) <- {}\", first, last, x);\n            ruq.update(first, last, x);\n        } else if query_type == 1 {\n            let i: usize = stdin.read();\n            //println!(\"search query [{}, {})\", i, i + 1);\n            let result = ruq.query(i, i + 1);\n            println!(\"{}\", if result == std::i32::MIN { std::i32::MAX } else { result });\n        }\n        //println!(\"\");\n    }\n}\n\n#[allow(unused_must_use)]\nmod my {\n    pub mod io {\n        use std::io::{BufRead, ErrorKind, Result};\n        use std::str::{FromStr, from_utf8};\n        use std::fmt::Debug;\n\n        pub fn read_word<R: BufRead>(r: &mut R, buf: &mut Vec<u8>)\n                                              -> Result<usize> {\n            let mut read = 0;\n            loop {\n                let (done, used) = {\n                    let available = match r.fill_buf() {\n                        Ok(n) => n,\n                        Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                        Err(e) => return Err(e)\n                    };\n                    match available.iter().position(|&x| x == b'\\n' || x == b' ') {\n                        Some(i) => {\n                            buf.extend_from_slice(&available[..i]);\n                            (true, i + 1)\n                        }\n                        None => {\n                            buf.extend_from_slice(available);\n                            (false, available.len())\n                        }\n                    }\n                };\n                r.consume(used);\n                read += used;\n                if done || used == 0 {\n                    return Ok(read);\n                }\n            }\n        }\n\n        pub struct InputReader<R: BufRead> {\n            reader: R,\n            buf: Vec<u8>,\n        }\n\n        impl<R: BufRead> InputReader<R> {\n            pub fn new(reader: R) -> InputReader<R> {\n                InputReader {\n                    reader: reader,\n                    buf: Vec::<u8>::new(),\n                }\n            }\n\n            pub fn read_word(&mut self) {\n                read_word(&mut self.reader, &mut self.buf);\n            }\n            \n            pub fn read<T>(&mut self) -> T\n                where T: FromStr,\n                      T::Err: Debug\n            {\n                self.buf.clear();\n                self.read_word();\n                from_utf8(&self.buf).unwrap().trim().parse().unwrap()\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::*;\nuse std::collections::*;\nuse std::fmt::Debug;\nuse std::io::BufRead;\nuse std::io::{stdin, Read};\nuse std::ops::{Add, Sub};\nuse std::str::FromStr;\n\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nmacro_rules! read {\n    (($($t:tt),*)) => {\n        ( $(read!($t)),* )\n    };\n    ([[$t:tt; $len1:expr]; $len2:expr]) => {\n        (0..$len2).map(|_| read!([$t; $len1])).collect::<Vec<_>>()\n    };\n\n    ([$t:tt; $len:expr]) => {\n        (0..$len).map(|_| read!($t)).collect::<Vec<_>>()\n    };\n\n    (chars) => {\n        read!(String).chars().collect::<Vec<char>>()\n    };\n\n    (usize1) => {\n        read!(usize) - 1\n    };\n\n    ($t:ty) => {{\n        let stdin = stdin();\n        let stdin = stdin.lock();\n        let token: String = stdin\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect();\n\n        token.parse::<$t>().unwrap()\n    }};\n}\n\nmacro_rules! input {\n    (mut $name:ident: $t:tt, $($r:tt)*) => {\n        let mut $name = read!($t);\n        $(println!(\"{}\", stringify!($r));)*\n        input!($($r)*);\n    };\n\n    (mut $name:ident: $t:tt) => {\n        let mut $name = read!($t);\n    };\n\n    ($name:ident: $t:tt, $($r:tt)*) => {\n        let $name = read!($t);\n        input!($($r)*);\n    };\n\n    ($name:ident: $t:tt) => {\n        let $name = read!($t);\n    };\n}\n\ntrait VecExt {\n    fn cumulation(&self) -> Vec<i64>;\n    fn cumulation_query(&self, a: usize, b: usize) -> i64;\n}\n\nimpl VecExt for Vec<i64> {\n    fn cumulation(&self) -> Vec<i64> {\n        let mut vec = vec![0; self.len() + 1];\n        for i in 0..self.len() {\n            vec[i + 1] = self[i] + vec[i];\n        }\n        return vec;\n    }\n\n    fn cumulation_query(&self, left: usize, right: usize) -> i64 {\n        return self[right] - self[left];\n    }\n}\n\npub trait Monoid {\n    type T: Copy + Clone + std::fmt::Debug + PartialOrd + std::fmt::Display;\n    fn op(lhs: &Self::T, rhs: &Self::T) -> Self::T;\n    fn identity() -> Self::T;\n}\n\npub trait OperatorMonoid {\n    type T;\n    type U: Copy + Clone + std::fmt::Debug + PartialOrd;\n    fn op1(lhs: &Self::U, rhs: &Self::U) -> Self::U;\n    fn op2(lhs: &Self::T, rhs: &Self::U, len: &usize) -> Self::T;\n    fn identity() -> Self::U;\n}\n\n#[derive(Clone)]\nstruct Min {}\n\nimpl Monoid for Min {\n    type T = i64;\n\n    fn identity() -> Self::T {\n        return (1 << 31) - 1 \n    }\n\n    fn op(lhs: &Self::T, rhs: &Self::T) -> Self::T {\n        return std::cmp::min(*lhs, *rhs);\n    }\n}\n\n#[derive(Clone)]\nstruct OperatorMin {}\n\nimpl OperatorMonoid for OperatorMin {\n    type T = i64;\n    type U = Option<i64>;\n\n    fn identity() -> Self::U {\n        return None;\n    }\n\n    fn op1(lhs: &Self::U, rhs: &Self::U) -> Self::U {\n        return *rhs\n    }\n\n    fn op2(lhs: &Self::T, rhs: &Self::U, _: &usize) -> Self::T {\n        if rhs.is_some() {\n            (*rhs).unwrap()\n        } else {\n            *lhs\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct LazySegmentTree<M: Monoid, O: OperatorMonoid<T = M::T>> {\n    n: usize,\n    size: usize,\n    data: Vec<M::T>,\n    lazy: Vec<O::U>,\n}\n\nimpl<M: Monoid, O: OperatorMonoid<T = M::T>> LazySegmentTree<M, O> {\n    pub fn new(n: usize) -> LazySegmentTree<M, O> {\n        let mut size = 1;\n        while size < n {\n            size *= 2;\n        }\n\n        LazySegmentTree {\n            n: n,\n            size: size,\n            data: vec![M::identity(); size * 2],\n            lazy: vec![O::identity(); size * 2],\n        }\n    }\n\n    pub fn set(&mut self, k: usize, v: M::T) {\n        self.data[k + self.size] = v;\n    }\n\n    pub fn build(&mut self) {\n        for k in (1..self.size - 1).rev() {\n            self.data[k] = M::op(&self.data[k * 2], &self.data[k * 2 + 1]);\n        }\n    }\n\n    pub fn propagate(&mut self, k: usize, len: usize) {\n        if self.lazy[k] != O::identity() {\n            if k < self.size {\n                self.lazy[2 * k + 0] = O::op1(&self.lazy[2 * k + 0], &self.lazy[k]);\n                self.lazy[2 * k + 1] = O::op1(&self.lazy[2 * k + 1], &self.lazy[k]);\n            }\n            self.data[k] = O::op2(&self.data[k], &self.lazy[k], &len);\n            self.lazy[k] = O::identity();\n        }\n    }\n\n    pub fn _update(&mut self, a: usize, b: usize, x: O::U, k: usize, l: usize, r: usize) {\n        self.propagate(k, r - l);\n        if r <= a || b <= l {\n            return;\n        } else if a <= l && r <= b {\n            self.lazy[k] = O::op1(&self.lazy[k], &x);\n            self.propagate(k, r - l);\n        } else {\n            self._update(a, b, x, 2 * k + 0, l, (l + r) >> 1);\n            self._update(a, b, x, 2 * k + 1, (l + r) >> 1, r);\n            self.data[k] = M::op(&self.data[2 * k + 0], &self.data[2 * k + 1]);\n        }\n    }\n\n    pub fn update(&mut self, a: usize, b: usize, x: O::U) {\n        let sz = self.size;\n        self._update(a, b, x, 1, 0, sz);\n    }\n\n    fn _query(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> M::T {\n        self.propagate(k, r - l);\n        if r <= a || b <= l {\n            return M::identity();\n        } else if a <= l && r <= b {\n            return self.data[k];\n        } else {\n            return M::op(\n                &self._query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                &self._query(a, b, 2 * k + 1, (l + r) >> 1, r),\n            );\n        }\n    }\n\n    pub fn query(&mut self, a: usize, b: usize) -> M::T {\n        let sz = self.size;\n        return self._query(a, b, 1, 0, sz);\n    }\n\n    pub fn debug(&self) {\n        for i in 0..self.n {\n            print!(\"{} \", self.data[i + self.size]);\n        }\n        println!();\n    }\n}\n\nfn main() {\n    input!(n: usize, q: usize);\n    let mut seg: LazySegmentTree<Min, OperatorMin> = LazySegmentTree::new(n);\n    for _ in 0..q {\n        input!(com: usize);\n        if com == 0 {\n            input!(s: usize, t: usize, x: i64);\n            seg.update(s, t + 1, Some(x));\n        } else {\n            input!(i: usize);\n            println!(\"{}\", seg.query(i, i + 1));\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::*;\nuse std::collections::*;\nuse std::io::*;\nuse std::str::*;\nuse std::string::*;\nuse std::f64::consts::PI;\n\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nmacro_rules! read {\n    (($($t:tt),*)) => {\n        ( $(read!($t)),* )\n    };\n    ([[$t:tt; $len1:expr]; $len2:expr]) => {\n        (0..$len2).map(|_| read!([$t; $len1])).collect::<Vec<_>>()\n    };\n\n    ([$t:tt; $len:expr]) => {\n        (0..$len).map(|_| read!($t)).collect::<Vec<_>>()\n    };\n\n    (chars) => {\n        read!(String).chars().collect::<Vec<char>>()\n    };\n\n    (usize1) => {\n        read!(usize) - 1\n    };\n\n    ($t:ty) => {{\n        let stdin = stdin();\n        let stdin = stdin.lock();\n        let token: String = stdin\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect();\n\n        token.parse::<$t>().unwrap()\n    }};\n}\n\nmacro_rules! input {\n    (mut $name:ident: $t:tt, $($r:tt)*) => {\n        let mut $name = read!($t);\n        input!($($r)*);\n    };\n\n    (mut $name:ident: $t:tt) => {\n        let mut $name = read!($t);\n    };\n\n    ($name:ident: $t:tt, $($r:tt)*) => {\n        let $name = read!($t);\n        input!($($r)*);\n    };\n\n    ($name:ident: $t:tt) => {\n        let $name = read!($t);\n    };\n}\n\nfn prime_factorization(n: i64) -> HashMap<i64, i64> {\n    let mut n = n;\n    let mut res = HashMap::new();\n    let mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n            n /= i;\n            let count = res.entry(i).or_insert(0);\n            *count += 1;\n        }\n        i += 1;\n    }\n\n    if n > 1 {\n        res.insert(n, 1);\n    }\n\n    return res;\n}\n\n\nstruct Combination {\n    MOD: i64,\n    fac: Vec<i64>,\n    fac_inv: Vec<i64>,\n}\n\nimpl Combination {\n    pub fn new(n: i64) -> Self {\n        let MOD: i64 = 1_000_000_007;\n        let mut fac: Vec<i64> = vec![0; n as usize + 1];\n        let mut fac_inv: Vec<i64> = vec![0; n as usize + 1];\n\n        let get_inverse = |mut n: i64| -> i64 {\n            let (mut res, mut p) = (1, MOD - 2);\n\n            while p != 0 {\n                if p & 1 == 1 {\n                    res = (res * n) % MOD;\n                }\n                n = (n * n) % MOD;\n                p >>= 1;\n            }\n\n            return res;\n        };\n\n        fac[0] = 1;\n\n        for i in 1..n + 1 {\n            fac[i as usize] = (fac[i as usize - 1] * i) % MOD;\n        }\n\n        for i in 0..n + 1 {\n            fac_inv[i as usize] = get_inverse(fac[i as usize]);\n        }\n\n        Combination {\n            MOD: MOD,\n            fac: fac,\n            fac_inv: fac_inv,\n        }\n    }\n\n    fn nCr(&self, n: i64, r: i64) -> i64 {\n        if n < r {\n            return 0;\n        }\n\n        let a: i64 = self.fac[n as usize];\n        let b: i64 = self.fac_inv[(n - r) as usize];\n        let c: i64 = self.fac_inv[r as usize];\n        let bc: i64 = (b * c) % self.MOD;\n\n        return (a * bc) % self.MOD;\n    }\n\n    fn nPr(&self, n: i64, r: i64) -> i64 {\n        if n < r {\n            return 0;\n        }\n\n        let a: i64 = self.fac[n as usize];\n        let b: i64 = self.fac_inv[(n - r) as usize];\n\n        return (a * b) % self.MOD;\n    }\n\n    fn nHr(&self, n: i64, r: i64) -> i64 {\n        if n == 0 && r == 0 {\n            return 1;\n        }\n\n        return self.nCr(n + r - 1, r);\n    }\n}\n\npub trait SliceExt<T>: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Edge {\n    to: usize,\n    cost: i64,\n}\n\nfn dijkstra(graph: &Vec<Vec<Edge>>, s: &usize) -> Vec<i64> {\n    use std::collections::BinaryHeap;\n    let mut dist = vec![1e18 as i64; graph.len()];\n    let mut heap = BinaryHeap::new();\n    dist[*s] = 0;\n    heap.push(Rev((0, *s)));\n    while let Some(Rev((cost, v))) = heap.pop() {\n        if dist[v] < cost {\n            continue;\n        }\n\n        for e in &graph[v] {\n            if dist[e.to] <= dist[v] + e.cost {\n                continue;\n            }\n            dist[e.to] = dist[v] + e.cost;\n            heap.push(Rev((dist[e.to], e.to)));\n        }\n    }\n    return dist;\n}\n\nstruct LCA {\n    par: Vec<Vec<Option<usize>>>,\n    dist: Vec<i64>,\n}\n\nimpl LCA {\n    pub fn new(graph: &Vec<Vec<usize>>, root: &usize) -> LCA {\n        let V = graph.len();\n        let mut K = 1;\n\n        while (1 << K) < V {\n            K += 1;\n        }\n\n        let mut par = vec![vec![None; V]; K];\n        let mut dist = vec![-1; V];\n        let graph = graph.to_vec();\n\n        fn dfs(\n            v: usize,\n            p: Option<usize>,\n            d: i64,\n            graph: &Vec<Vec<usize>>,\n            par: &mut Vec<Vec<Option<usize>>>,\n            dist: &mut Vec<i64>,\n        ) {\n            par[0][v] = p;\n            dist[v] = d;\n            for &to in &graph[v] {\n                match p {\n                    Some(p) => {\n                        if to != p {\n                            dfs(to, Some(v), d + 1, graph, par, dist)\n                        }\n                    }\n                    None => dfs(to, Some(v), d + 1, graph, par, dist),\n                }\n            }\n        }\n\n        dfs(*root, None, 0, &graph, &mut par, &mut dist);\n\n        for k in 0..K - 1 {\n            for v in 0..V {\n                match par[k][v] {\n                    Some(x) => par[k + 1][v] = par[k][x],\n                    None => (),\n                }\n            }\n        }\n\n        LCA {\n            par: par,\n            dist: dist,\n        }\n    }\n\n    pub fn query(&self, u: usize, v: usize) -> usize {\n        let mut u = u;\n        let mut v = v;\n        if self.dist[u] < self.dist[v] {\n            return self.query(v, u);\n        }\n\n        let K = self.par.len();\n        for k in 0..K {\n            if ((self.dist[u] - self.dist[v]) >> k & 1) == 1 {\n                u = self.par[k][u].unwrap();\n            }\n        }\n\n        if u == v {\n            return u;\n        }\n\n        for k in (0..K - 1).rev() {\n            if self.par[k][u] != self.par[k][v] {\n                u = self.par[k][u].unwrap();\n                v = self.par[k][v].unwrap();\n            }\n        }\n\n        return self.par[0][u].unwrap();\n    }\n}\n\nstruct Doubling {\n    N: usize,\n    LOG: usize,\n    next: Vec<Vec<Option<usize>>>,\n}\n\nimpl Doubling {\n    pub fn new(vec: &Vec<usize>, lim: &usize) -> Doubling {\n        let N = vec.len();\n        let lim = *lim;\n        let mut LOG = 1;\n        while (1 << LOG) < 2 * lim {\n            LOG += 1;\n        }\n\n        let mut next = vec![vec![None; N]; LOG];\n\n        for i in 0..N {\n            next[0][i] = Some(vec[i]);\n        }\n\n        for k in 0..LOG - 1 {\n            for i in 0..N {\n                match next[k][i] {\n                    Some(x) => next[k + 1][i] = next[k][x],\n                    None => (),\n                }\n            }\n        }\n\n        Doubling {\n            N: N,\n            LOG: LOG,\n            next: next,\n        }\n    }\n\n    pub fn query(&self, i: usize, n: usize) -> usize {\n        let mut i = i;\n        for k in (0..self.LOG).rev() {\n            if (n >> k) & 1 == 1 {\n                i = self.next[k][i].unwrap();\n            }\n        }\n        return i;\n    }\n}\n\nmacro_rules! min {\n    ($a:expr $(,)*) => {{\n        $a\n    }};\n    ($a:expr, $b:expr $(,)*) => {{\n        std::cmp::min($a, $b)\n    }};\n    ($a:expr, $($rest:expr),+ $(,)*) => {{\n        std::cmp::min($a, min!($($rest),+))\n    }};\n}\n\nmacro_rules! chmin {\n    ($base:expr, $($cmps:expr),+ $(,)*) => {{\n        let cmp_min = min!($($cmps),+);\n        if $base > cmp_min {\n            $base = cmp_min;\n            true\n        } else {\n            false\n        }\n    }};\n}\n\nmacro_rules! max {\n    ($a:expr $(,)*) => {{\n        $a\n    }};\n    ($a:expr, $b:expr $(,)*) => {{\n        std::cmp::max($a, $b)\n    }};\n    ($a:expr, $($rest:expr),+ $(,)*) => {{\n        std::cmp::max($a, max!($($rest),+))\n    }};\n}\n\nmacro_rules! chmax {\n    ($base:expr, $($cmps:expr),+ $(,)*) => {{\n        let cmp_max = max!($($cmps),+);\n        if $base < cmp_max {\n            $base = cmp_max;\n            true\n        } else {\n            false\n        }\n    }};\n}\n\nstruct UnionFind {\n    par: Vec<i32>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            par: vec![-1; n],\n        }\n    }\n\n    pub fn root(&mut self, x: usize) -> usize {\n        if self.par[x] < 0 {\n            return x;\n        } else {\n            let a = self.par[x] as usize;\n            self.par[x] = self.root(a) as i32;\n            return self.par[x] as usize;\n        }\n    }\n\n    pub fn is_same(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n\n    pub fn merge(&mut self, x: usize, y: usize) -> bool {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y {\n            return false;\n        } else {\n            if self.par[x] > self.par[y] {\n                std::mem::swap(&mut x, &mut y);\n            }\n            self.par[x] += self.par[y];\n            self.par[y] = x as i32;\n            return true;\n        }\n    }\n\n    pub fn size(&mut self, x: usize) -> i64 {\n        let a = self.root(x);\n        return -self.par[a] as i64;\n    }\n}\n\ntrait Monoid {\n    fn id() -> Self;\n    fn op(&self, rhs: &Self) -> Self;\n}\n\n#[derive(Clone, Debug)]\nstruct Min(i64);\n\n#[derive(Clone, Debug)]\nstruct RangeUpdate(i64);\n\n#[derive(Clone, Debug)]\nstruct RangeAdd(i64);\n\n#[derive(Clone, Debug)]\nstruct Sum(i64);\n\nimpl Monoid for Sum {\n    fn id() -> Self {\n        Sum(0)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        Sum(self.0 + rhs.0)\n    }\n}\n\nimpl Monoid for Min {\n    fn id() -> Self {\n        Min(std::i32::MAX as i64)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        Min(std::cmp::min(self.0, (*rhs).0))\n    }\n}\n\ntrait Operator {\n    type T;\n    fn id() -> Self;\n    fn op(&self, rhs: &Self) -> Self;\n    fn act(&self, tar: &Self::T, x: usize) -> Self::T;\n}\n\nimpl Operator for RangeUpdate {\n    type T = Min;\n    fn id() -> Self {\n        RangeUpdate(0)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        (*rhs).clone()\n    }\n\n    fn act(&self, tar: &Self::T, x: usize) -> Self::T {\n        Min(self.0)\n    }\n}\n\nimpl Operator for RangeAdd {\n    type T = Sum;\n    fn id() -> Self {\n        RangeAdd(0)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        RangeAdd(self.0 + rhs.0)\n    }\n\n    fn act(&self, tar: &Self::T, x: usize) -> Self::T {\n        Sum(tar.0 + self.0 * x as i64)\n    }\n}\n\nstruct LazySegTree<M: Monoid, O: Operator<T=M>> {\n    dat: Vec<M>,\n    lzy: Vec<O>,\n    need_update: Vec<bool>,\n    size: usize,\n}\n\nimpl<M: Monoid + Clone, O: Operator<T=M> + Clone> LazySegTree<M, O> {\n    pub fn new(vec: Vec<M>) -> LazySegTree<M, O> {\n        let n = vec.len();\n        let mut sz = 1;\n        while sz < n {\n            sz <<= 1;\n        }\n        let mut dat = vec![M::id(); sz << 1];\n        for i in 0..n {\n            dat[i + sz] = vec[i].clone();\n        }\n        for k in (1..sz).rev() {\n            dat[k] = dat[k << 1].op(&dat[(k << 1) + 1]);\n        }\n\n        return LazySegTree {\n            dat: dat,\n            lzy: vec![O::id(); sz << 1],\n            need_update: vec![false; sz << 1],\n            size: sz,\n        };\n    }\n\n    pub fn eval(&mut self, l: usize, r: usize, k: usize) {\n        if !self.need_update[k] {\n            return;\n        }\n        self.dat[k] = self.lzy[k].act(&self.dat[k], r - l);\n        if (k << 1) < self.dat.len() {\n            self.lzy[k << 1] = self.lzy[k << 1].op(&self.lzy[k]);\n            self.lzy[(k << 1) + 1] = self.lzy[(k << 1) + 1].op(&self.lzy[k]);\n            self.need_update[k << 1] = true;\n            self.need_update[(k << 1) + 1] = true;\n        }\n        self.lzy[k] = O::id();\n        self.need_update[k] = false;\n    }\n\n    pub fn update(&mut self, a: usize, b: usize, x: O) {\n        let sz = self.size;\n        self._update(a, b, &x, 0, sz, 1);\n    }\n\n    pub fn _update(&mut self, a: usize, b: usize, x: &O, l: usize, r: usize, k: usize) {\n        self.eval(l, r, k);\n        if b <= l || r <= a {\n            return;\n        } else if a <= l && r <= b {\n            self.lzy[k] = self.lzy[k].op(x);\n            self.need_update[k] = true;\n            self.eval(l, r, k);\n        } else {\n            let mid = (l + r) >> 1;\n            self._update(a, b, x, l, mid, k << 1);\n            self._update(a, b, x, mid, r, (k << 1) + 1);\n            self.dat[k] = self.dat[k << 1].op(&self.dat[(k << 1) + 1]);\n        }\n    }\n\n    pub fn query(&mut self, a: usize, b: usize) -> M {\n        let sz = self.size;\n        return self._query(a, b, 0, sz, 1);\n    }\n\n    pub fn _query(&mut self, a: usize, b: usize, l: usize, r: usize, k: usize) -> M {\n        self.eval(l, r, k);\n        if b <= l || r <= a {\n            return M::id();\n        } else if a <= l && r <= b {\n            return self.dat[k].clone();\n        } else {\n            let mid = (l + r) >> 1;\n            let vl = self._query(a, b, l, mid, k << 1);\n            let vr = self._query(a, b, mid, r, (k << 1) + 1);\n            return vl.op(&vr);\n        }\n    }\n}\n\nstruct SegTree<M: Monoid> {\n    dat: Vec<M>,\n    size: usize,\n}\n\nimpl<M: Monoid + Clone> SegTree<M> {\n    pub fn new(n: usize) -> SegTree<M> {\n        let mut sz = 1;\n        while sz < n {\n            sz <<= 1;\n        }\n\n        SegTree::<M> {\n            dat: vec![M::id(); sz * 2],\n            size: sz,\n        }\n    }\n\n    pub fn update(&mut self, k: usize, val: M) {\n        let mut k = k + self.size;\n        self.dat[k] = val;\n        while k > 0 {\n            k = k >> 1;\n            self.dat[k] = self.dat[k << 1].op(&self.dat[(k << 1) + 1]);\n        }\n    }\n\n    pub fn query(&self, a: usize, b: usize) -> M {\n        let mut lx = M::id();\n        let mut rx = M::id();\n        let mut l = a + self.size;\n        let mut r = b + self.size;\n        while l < r {\n            if (l & 1) == 1 {\n                lx = lx.op(&self.dat[l]);\n                l += 1;\n            }\n\n            if (r & 1) == 1 {\n                r -= 1;\n                rx = self.dat[r].op(&rx);\n            }\n\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return lx.op(&rx);\n    }\n}\n\nfn main() {\n    input!(n: usize, q: usize);\n    let mut seg = LazySegTree::new(vec![Min(std::i32::MAX as i64); n]);\n    for _ in 0..q {\n        input!(c: usize);\n        if c == 0 {\n            input!(s: usize, t: usize, y: i64);\n            seg.update(s, t + 1, RangeUpdate(y));\n        } else {\n            input!(i: usize);\n            println!(\"{}\", seg.query(i, i + 1).0);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::prelude::*;\nuse std::iter::{once, repeat};\n\nstruct SegTree {\n    n: usize,\n    nodes: Vec<Option<i32>>,\n}\n\nimpl SegTree {\n    fn init(n: usize) -> SegTree {\n        let n = 1 << f64::log2(n as f64).ceil() as usize;\n        SegTree {\n            n,\n            nodes: once(Some(std::i32::MAX)).chain(repeat(None)).take(2 * n - 1).collect(),\n        }\n    }\n\n    fn update(&mut self, s: usize, t: usize, x: i32, ni: usize, l: usize, r: usize) {\n        if r <= s || t <= l {\n            return;\n        }\n        if s <= l && r <= t {\n            self.nodes[ni] = Some(x);\n            return;\n        }\n        let m = (l + r) / 2;\n        if let Some(y) = self.nodes[ni] {\n            self.nodes[2*ni+1] = Some(y);\n            self.nodes[2*ni+2] = Some(y);\n            self.nodes[ni] = None;\n        }\n        self.update(s, t, x, 2 * ni + 1, l, m);\n        self.update(s, t, x, 2 * ni + 2, m, r);\n    }\n\n    fn find(&self, i: usize, ni: usize, l: usize, r: usize) -> i32 {\n        self.nodes[ni].unwrap_or_else(||{\n            let m = (l + r) / 2;\n            if i < m {\n                self.find(i, 2 * ni + 1, l, m)\n            } else {\n                self.find(i, 2 * ni + 2, m, r)\n            }\n        })\n    }\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    let line0 = lines.next().unwrap().unwrap();\n    let n = line0.split_whitespace().next().unwrap().parse().unwrap();\n\n    let mut mst = SegTree::init(n);\n\n    for l in lines.map(Result::unwrap) {\n        let mut words = l.split_whitespace();\n        let com = words.next().unwrap().parse().unwrap();\n        match com {\n            0 => {\n                let s: usize = words.next().unwrap().parse().unwrap();\n                let t: usize = words.next().unwrap().parse().unwrap();\n                let x = words.next().unwrap().parse().unwrap();\n                let n = mst.n;\n                mst.update(s, t + 1, x, 0, 0, n);\n            }\n            1 => {\n                let i = words.next().unwrap().parse().unwrap();\n                println!(\"{}\", mst.find(i, 0, 0, mst.n));\n            }\n            _ => (),\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\nstruct SEG<T: SEGimpl> {\n    n: usize,\n    buf: Vec<T::Elem>,\n    phantom: std::marker::PhantomData<T>,\n}\nimpl<T: SEGimpl> SEG<T> {\n    #[allow(dead_code)]\n    fn new(n: usize, init: T::Elem) -> SEG<T> {\n        let n = (1..).map(|i| 1 << i).find(|&x| x >= n).unwrap();\n        SEG {\n            n: n,\n            buf: vec![init; 2 * n],\n            phantom: std::marker::PhantomData,\n        }\n    }\n    #[allow(dead_code)]\n    fn eval(&mut self, k: usize, l: usize, r: usize) {\n        if r - l > 1 {\n            let (l, r) = self.buf.split_at_mut(2 * k + 1);\n            let (c1, c2) = r.split_at_mut(1);\n            T::eval(&mut l[k], Some((&mut c1[0], &mut c2[0])));\n        } else {\n            T::eval(&mut self.buf[k], None);\n        }\n    }\n    #[allow(dead_code)]\n    fn r(&mut self, x: &T::A, a: usize, b: usize, k: usize, l: usize, r: usize) {\n        self.eval(k, l, r);\n        if r <= a || b <= l {\n            return;\n        }\n        if a <= l && r <= b {\n            T::range(x, &mut self.buf[k], l, r);\n            self.eval(k, l, r);\n            return;\n        }\n        self.r(x, a, b, 2 * k + 1, l, (l + r) / 2);\n        self.r(x, a, b, 2 * k + 2, (l + r) / 2, r);\n        let (l, r) = self.buf.split_at_mut(2 * k + 1);\n        let (c1, c2) = r.split_at_mut(1);\n        T::reduce(&mut l[k], &c1[0], &c2[0]);\n    }\n    #[allow(dead_code)]\n    fn range_add(&mut self, x: &T::A, a: usize, b: usize) {\n        let n = self.n;\n        self.r(x, a, b, 0, 0, n);\n    }\n    #[allow(dead_code)]\n    fn q(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> Option<T::R> {\n        self.eval(k, l, r);\n        if r <= a || b <= l {\n            return None;\n        }\n        if a <= l && r <= b {\n            Some(T::result(&self.buf[k]))\n        } else {\n            let vl = self.q(a, b, k * 2 + 1, l, (l + r) / 2);\n            let vr = self.q(a, b, k * 2 + 2, (l + r) / 2, r);\n            match (vl, vr) {\n                (Some(l), Some(r)) => Some(T::reduce_result(l, r)),\n                (Some(l), None) => Some(l),\n                (None, Some(r)) => Some(r),\n                _ => None,\n            }\n        }\n    }\n    #[allow(dead_code)]\n    fn query(&mut self, a: usize, b: usize) -> Option<T::R> {\n        let n = self.n;\n        self.q(a, b, 0, 0, n)\n    }\n}\ntrait SEGimpl {\n    type Elem: Clone;\n    type A;\n    type R;\n    fn eval(parent: &mut Self::Elem, children: Option<(&mut Self::Elem, &mut Self::Elem)>);\n    fn range(x: &Self::A, elem: &mut Self::Elem, l: usize, r: usize);\n    fn reduce(parent: &mut Self::Elem, c1: &Self::Elem, c2: &Self::Elem);\n    fn result(elem: &Self::Elem) -> Self::R;\n    fn reduce_result(a: Self::R, b: Self::R) -> Self::R;\n}\n\nstruct FindOverwrite;\n\nimpl SEGimpl for FindOverwrite {\n    type Elem = Option<u64>;\n    type A = u64;\n    type R = Option<u64>;\n    fn eval(parent: &mut Self::Elem, children: Option<(&mut Self::Elem, &mut Self::Elem)>) {\n        if let Some((c1, c2)) = children {\n            if let Some(x) = parent.take() {\n                *c1 = Some(x);\n                *c2 = Some(x);\n            }\n        }\n    }\n    #[allow(unused_variables)]\n    fn range(x: &Self::A, elem: &mut Self::Elem, l: usize, r: usize) {\n        *elem = Some(*x);\n    }\n    #[allow(unused_variables)]\n    fn reduce(parent: &mut Self::Elem, c1: &Self::Elem, c2: &Self::Elem) {}\n    fn result(elem: &Self::Elem) -> Self::R {\n        *elem\n    }\n    fn reduce_result(a: Self::R, b: Self::R) -> Self::R {\n        a.or(b)\n    }\n}\n\nfn main() {\n    let (n, q) = get!(usize, usize);\n\n    let mut seg: SEG<FindOverwrite> = SEG::new(n, None);\n    seg.range_add(&((1 << 31) - 1), 0, n);\n\n    for _ in 0..q {\n        let v = util::gets::<usize>();\n        if v[0] == 0 {\n            seg.range_add(&(v[3] as u64), v[1], v[2] + 1);\n        } else {\n            println!(\"{}\", seg.query(v[1], v[1] + 1).unwrap().unwrap());\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\ntrait SEGImpl {\n    type Elem: Clone;\n    fn id() -> Self::Elem;\n    // node value 0, node value 1 -> node value\n    fn op(x: &Self::Elem, y: &Self::Elem) -> Self::Elem;\n    // propagate lazy value upward\n    fn up(l: usize, r: usize, e: Self::Elem) -> Self::Elem;\n    /// current value, lazy value -> new value, child's lazy value\n    fn down(cur: Self::Elem, lazy_val: Self::Elem) -> (Self::Elem, Self::Elem);\n    // current lazy value, propagated lazy value -> new lazy value\n    fn lazy_op(cur: &Self::Elem, propagated: &Self::Elem) -> Self::Elem;\n}\nstruct SEG<T: SEGImpl> {\n    n: usize,\n    node: Vec<T::Elem>,\n    lazy: Vec<Option<T::Elem>>,\n}\n\nimpl <T: SEGImpl> SEG<T> {\n    fn new(n: usize) -> SEG<T> {\n        let mut m = 1;\n        while m < n { m *= 2; }\n        SEG {\n            n: m,\n            node: vec![T::id(); m*2-1],\n            lazy: vec![None; m*2-1],\n        }\n    }\n    fn eval(&mut self, k: usize, l: usize, r: usize) {\n        if let Some(lzv) = self.lazy[k].clone() {\n            let cur_val = self.node[k].clone();\n            let (new_val, child_lzv) = T::down(cur_val, lzv);\n            self.node[k] = new_val;\n            // propagate the lazy value to its children\n            if r - l > 1 {\n                self.lazy[k*2+1] = match self.lazy[k*2+1].clone() {\n                    Some(x) => Some(T::lazy_op(&x, &child_lzv)),\n                    None => Some(child_lzv.clone()),\n                };\n                self.lazy[k*2+2] = match self.lazy[k*2+2].clone() {\n                    Some(x) => Some(T::lazy_op(&x, &child_lzv)),\n                    None => Some(child_lzv.clone()),\n                };\n            }\n            self.lazy[k] = None;\n        }\n    }\n    fn do_update(&mut self, a: usize, b: usize, x: T::Elem, k: usize, l: usize, r: usize) {\n        self.eval(k,l,r);\n\n        if b <= l || r <= a {\n            return;\n        }\n\n        if a <= l && r <= b {\n            self.lazy[k] = match self.lazy[k].clone() {\n                Some(a) => Some(T::lazy_op(&a, &T::up(l,r,x))),\n                None => Some(T::up(l,r,x)),\n            };\n            self.eval(k,l,r);\n        }\n\n        else {\n            self.do_update(a,b,x.clone(),2*k+1,l,(l+r)/2);\n            self.do_update(a,b,x.clone(),2*k+2,(l+r)/2,r);\n            self.node[k] = T::op(&self.node[2*k+1],&self.node[2*k+2]);\n        }\n    }\n    fn update(&mut self, a: usize, b: usize, x: T::Elem) {\n        let n = self.n;\n        self.do_update(a,b,x,0,0,n)\n    }\n    fn do_query(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> T::Elem {\n        if r <= a || b <= l {\n            return T::id();\n        }\n\n        self.eval(k,l,r);\n\n        if a <= l && r <= b {\n            return self.node[k].clone();\n        } else {\n            let vl = self.do_query(a,b,k*2+1,l,(l+r)/2);\n            let vr = self.do_query(a,b,k*2+2,(l+r)/2,r);\n            return T::op(&vl,&vr);\n        }\n    }\n    fn query(&mut self, a: usize, b: usize) -> T::Elem {\n        let n = self.n;\n        self.do_query(a,b,0,0,n)\n    }\n}\nstruct Impl;\nimpl SEGImpl for Impl {\n    type Elem = i64;\n    fn id() -> Self::Elem {\n        (1<<31)-1\n    }\n    fn op(x: &Self::Elem, y: &Self::Elem) -> Self::Elem {\n        std::cmp::min(x.clone(), y.clone())\n    }\n    fn up(l: usize, r: usize, e: Self::Elem) -> Self::Elem {\n        e\n    }\n    fn down(cur: Self::Elem, lazy_val: Self::Elem) -> (Self::Elem, Self::Elem) {\n        (lazy_val, lazy_val)\n    }\n    fn lazy_op(x: &Self::Elem, y: &Self::Elem) -> Self::Elem {\n        y.clone()\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        n: usize, q: usize,\n    }\n\n    let mut seg: SEG<Impl> = SEG::new(n);\n\n    for _ in 0..q {\n        input! {\n            parser = parser,\n            com: usize,\n        }\n        if com == 0 {\n            input! {\n                parser = parser,\n                s: usize, t: usize, x: i64,\n            }\n            seg.update(s,t+1,x);\n        } else {\n            input! {\n                parser = parser,\n                i: usize,\n            }\n            println!(\"{}\", seg.query(i,i+1));\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nstruct SEG {\n    buf: Vec<Option<u64>>,\n    n: usize,\n}\n\nimpl SEG {\n    fn new(size: usize) -> SEG {\n        let n = (1..).map(|i| 1 << i).find(|&x| x >= size).unwrap();\n\n        let mut buf = vec![None; 2 * n];\n        for x in &mut buf[n - 1..] {\n            *x = Some((1 << 31) - 1);\n        }\n\n        SEG { buf: buf, n: n }\n    }\n\n    fn eval(&mut self, k: usize, l: usize, r: usize) {\n        if r - l > 1 {\n            if let Some(x) = self.buf[k].take() {\n                self.buf[2 * k + 1] = Some(x);\n                self.buf[2 * k + 2] = Some(x);\n            }\n        }\n    }\n\n    fn update(&mut self, x: u64, s: usize, t: usize, k: usize, l: usize, r: usize) {\n        self.eval(k, l, r);\n        if t <= l || s >= r {\n            return;\n        }\n\n        if s <= l && r <= t {\n            self.buf[k] = Some(x);\n            self.eval(k, l, r);\n            return;\n        }\n\n        self.update(x, s, t, 2 * k + 1, l, (l + r) / 2);\n        self.update(x, s, t, 2 * k + 2, (l + r) / 2, r);\n    }\n\n    fn find(&mut self, i: usize, k: usize, l: usize, r: usize) -> Option<u64> {\n        self.eval(k, l, r);\n        if l == i && r == i + 1 {\n            return self.buf[k];\n        }\n\n        if l > i || r <= i {\n            return None;\n        }\n\n        let vl = self.find(i, 2 * k + 1, l, (l + r) / 2);\n        let vr = self.find(i, 2 * k + 2, (l + r) / 2, r);\n\n        vl.or(vr)\n    }\n}\n\nfn main() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    let (n, q) = get!(usize, usize);\n\n    let mut seg = SEG::new(n);\n    let n = seg.n;\n    for _ in 0..q {\n        let v = util::gets::<usize>();\n        if v[0] == 0 {\n            seg.update(v[3] as u64, v[1], v[2] + 1, 0, 0, n);\n        } else {\n            writeln!(out, \"{}\", seg.find(v[1], 0, 0, n).unwrap()).unwrap();\n        }\n    }\n}\n\n"
  }
]