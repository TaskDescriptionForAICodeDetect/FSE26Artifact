[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\nlong long seg_tree[4 * MAX_N];\nlong long lazy[4 * MAX_N];\n\nvoid build_tree(int node, int start, int end) {\n    if (start == end) {\n        seg_tree[node] = (1L << 31) - 1;\n        return;\n    }\n    int mid = (start + end) / 2;\n    build_tree(2 * node, start, mid);\n    build_tree(2 * node + 1, mid + 1, end);\n}\n\nvoid propagate(int node, int start, int end) {\n    if (lazy[node] != 0) {\n        seg_tree[node] = lazy[node];\n        if (start != end) {\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n        }\n        lazy[node] = 0;\n    }\n}\n\nvoid update_tree(int node, int start, int end, int l, int r, long long val) {\n    propagate(node, start, end);\n    \n    if (start > end || start > r || end < l)\n        return;\n    \n    if (l <= start && end <= r) {\n        lazy[node] = val;\n        propagate(node, start, end);\n        return;\n    }\n    \n    int mid = (start + end) / 2;\n    update_tree(2 * node, start, mid, l, r, val);\n    update_tree(2 * node + 1, mid + 1, end, l, r, val);\n}\n\nlong long query_tree(int node, int start, int end, int idx) {\n    propagate(node, start, end);\n    \n    if (start == end)\n        return seg_tree[node];\n    \n    int mid = (start + end) / 2;\n    \n    if (idx <= mid)\n        return query_tree(2 * node, start, mid, idx);\n    else\n        return query_tree(2 * node + 1, mid + 1, end, idx);\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    build_tree(1, 0, n-1);\n    \n    while (q--) {\n        int type;\n        scanf(\"%d\", &type);\n        \n        if (type == 1) {\n            int s, t, x;\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update_tree(1, 0, n-1, s-1, t-1, x);\n        } else {\n            int i;\n            scanf(\"%d\", &i);\n            printf(\"%lld\\n\", query_tree(1, 0, n-1, i-1));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int s, t, x;\n} Update;\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        A[i] = INT_MAX;\n    }\n    \n    Update *updates = (Update *)malloc(q * sizeof(Update));\n    int update_count = 0;\n    \n    for (int i = 0; i < q; i++) {\n        int op;\n        scanf(\"%d\", &op);\n        if (op == 0) {\n            int s, t, x;\n            scanf(\"%d %d %d\", &s, &t, &x);\n            updates[update_count].s = s;\n            updates[update_count].t = t;\n            updates[update_count].x = x;\n            update_count++;\n        } else {\n            int idx;\n            scanf(\"%d\", &idx);\n            int res = A[idx];\n            for (int j = update_count - 1; j >= 0; j--) {\n                if (updates[j].s <= idx && idx <= updates[j].t) {\n                    res = updates[j].x;\n                    break;\n                }\n            }\n            printf(\"%d\\n\", res);\n        }\n    }\n    \n    free(A);\n    free(updates);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> lazy;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = INT_MAX;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void push(int node, int start, int end) {\n        if (lazy[node] != -1) {\n            tree[node] = lazy[node];\n            if (start != end) {\n                lazy[2 * node + 1] = lazy[node];\n                lazy[2 * node + 2] = lazy[node];\n            }\n            lazy[node] = -1;\n        }\n    }\n\n    void updateRange(int node, int start, int end, int l, int r, int val) {\n        push(node, start, end);\n        if (start > end || start > r || end < l) {\n            return;\n        }\n        if (start >= l && end <= r) {\n            lazy[node] = val;\n            push(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        updateRange(2 * node + 1, start, mid, l, r, val);\n        updateRange(2 * node + 2, mid + 1, end, l, r, val);\n        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    int query(int node, int start, int end, int idx) {\n        push(node, start, end);\n        if (start == end) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            return query(2 * node + 1, start, mid, idx);\n        } else {\n            return query(2 * node + 2, mid + 1, end, idx);\n        }\n    }\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n);\n        lazy.resize(4 * n, -1);\n        build(0, 0, n - 1);\n    }\n\n    void update(int s, int t, int x) {\n        updateRange(0, 0, n - 1, s, t, x);\n    }\n\n    int find(int i) {\n        return query(0, 0, n - 1, i);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n\n    while (q--) {\n        int op;\n        cin >> op;\n        if (op == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.find(i) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n    static class SegmentTree {\n        int[] tree;\n        int[] lazy;\n        int size;\n        static final int INF = Integer.MAX_VALUE;\n\n        SegmentTree(int n) {\n            size = 1;\n            while (size < n) size <<= 1;\n            tree = new int[2 * size];\n            lazy = new int[2 * size];\n            for (int i = 0; i < 2 * size; i++) {\n                tree[i] = INF;\n                lazy[i] = INF;\n            }\n        }\n\n        void push(int node, int nodeLeft, int nodeRight) {\n            if (lazy[node] != INF) {\n                tree[node] = lazy[node];\n                if (nodeLeft != nodeRight) {\n                    lazy[2 * node] = lazy[node];\n                    lazy[2 * node + 1] = lazy[node];\n                }\n                lazy[node] = INF;\n            }\n        }\n\n        void updateRange(int l, int r, int val, int node, int nodeLeft, int nodeRight) {\n            push(node, nodeLeft, nodeRight);\n            if (r < nodeLeft || l > nodeRight) return;\n            if (l <= nodeLeft && nodeRight <= r) {\n                lazy[node] = val;\n                push(node, nodeLeft, nodeRight);\n                return;\n            }\n            int mid = (nodeLeft + nodeRight) / 2;\n            updateRange(l, r, val, 2 * node, nodeLeft, mid);\n            updateRange(l, r, val, 2 * node + 1, mid + 1, nodeRight);\n        }\n\n        int query(int idx, int node, int nodeLeft, int nodeRight) {\n            push(node, nodeLeft, nodeRight);\n            if (nodeLeft == nodeRight) return tree[node];\n            int mid = (nodeLeft + nodeRight) / 2;\n            if (idx <= mid) return query(idx, 2 * node, nodeLeft, mid);\n            else return query(idx, 2 * node + 1, mid + 1, nodeRight);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] input = br.readLine().split(\" \");\n        int n = Integer.parseInt(input[0]);\n        int q = Integer.parseInt(input[1]);\n\n        SegmentTree st = new SegmentTree(n);\n\n        for (int i = 0; i < q; i++) {\n            String[] query = br.readLine().split(\" \");\n            if (query[0].equals(\"0\")) {\n                int s = Integer.parseInt(query[1]);\n                int t = Integer.parseInt(query[2]);\n                int x = Integer.parseInt(query[3]);\n                st.updateRange(s, t, x, 1, 0, st.size - 1);\n            } else {\n                int idx = Integer.parseInt(query[1]);\n                bw.write(st.query(idx, 1, 0, st.size - 1) + \"\\n\");\n            }\n        }\n        bw.flush();\n        bw.close();\n    }\n}",
    "timestamp": "2025-08-05 22:20:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SequenceManipulation {\n    static long[] arr;\n    static int n;\n\n    public static void update(int s, int t, long x) {\n        for (int i = s; i <= t; i++) {\n            arr[i] = x;\n        }\n    }\n\n    public static long find(int i) {\n        return arr[i];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        n = scanner.nextInt();\n        arr = new long[n];\n        \n        // Initialize array with 2^31 - 1\n        for (int i = 0; i < n; i++) {\n            arr[i] = (1L << 31) - 1;\n        }\n        \n        int q = scanner.nextInt();\n        \n        for (int j = 0; j < q; j++) {\n            String op = scanner.next();\n            \n            if (op.equals(\"update\")) {\n                int s = scanner.nextInt();\n                int t = scanner.nextInt();\n                long x = scanner.nextLong();\n                update(s, t, x);\n            } else if (op.equals(\"find\")) {\n                int i = scanner.nextInt();\n                System.out.println(find(i));\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:20:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = INT_MAX / 2;\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = tree[2 * node];\n    }\n\n    void update(int node, int start, int end, int l, int r, int val) {\n        if (start > end || start > r || end < l) return;\n        \n        if (l <= start && end <= r) {\n            tree[node] = val;\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        update(2 * node, start, mid, l, r, val);\n        update(2 * node + 1, mid + 1, end, l, r, val);\n    }\n\n    int query(int node, int start, int end, int index) {\n        if (start == end) return tree[node];\n        \n        int mid = (start + end) / 2;\n        if (index <= mid)\n            return query(2 * node, start, mid, index);\n        else\n            return query(2 * node + 1, mid + 1, end, index);\n    }\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n);\n        build(1, 0, n - 1);\n    }\n\n    void updateRange(int l, int r, int val) {\n        update(1, 0, n - 1, l, r, val);\n    }\n\n    int findValue(int index) {\n        return query(1, 0, n - 1, index);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree st(n);\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.updateRange(s, t, x);\n        } else {\n            int i;\n            cin >> i;\n            cout << st.findValue(i) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SequenceManipulator:\n    def __init__(self, n):\n        self.n = n\n        self.A = [231 - 1] * n\n\n    def update(self, s, t, x):\n        for i in range(s, t + 1):\n            self.A[i] = x\n\n    def find(self, i):\n        return self.A[i]\n\n# Example usage:\nif __name__ == \"__main__\":\n    manipulator = SequenceManipulator(10)\n    manipulator.update(2, 5, 42)\n    print(manipulator.find(3))  # Output should be 42\n    print(manipulator.find(1))  # Output should be 230",
    "timestamp": "2025-08-13 10:00:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SequenceManipulation {\n\n    static class Node {\n        int start, end;\n        int value;\n        boolean pendingUpdate;\n\n        Node left, right;\n\n        Node(int start, int end) {\n            this.start = start;\n            this.end = end;\n            this.value = Integer.MAX_VALUE;\n            this.pendingUpdate = false;\n        }\n    }\n\n    static class SegmentTree {\n        Node root;\n\n        SegmentTree(int n) {\n            root = buildTree(0, n - 1);\n        }\n\n        private Node buildTree(int start, int end) {\n            Node node = new Node(start, end);\n            if (start != end) {\n                int mid = (start + end) / 2;\n                node.left = buildTree(start, mid);\n                node.right = buildTree(mid + 1, end);\n            }\n            return node;\n        }\n\n        public void update(int start, int end, int value) {\n            update(root, start, end, value);\n        }\n\n        private void update(Node node, int start, int end, int value) {\n            if (node.start == start && node.end == end) {\n                node.value = value;\n                node.pendingUpdate = true;\n                return;\n            }\n            pushDown(node);\n            int mid = (node.start + node.end) / 2;\n            if (end <= mid) {\n                update(node.left, start, end, value);\n            } else if (start > mid) {\n                update(node.right, start, end, value);\n            } else {\n                update(node.left, start, mid, value);\n                update(node.right, mid + 1, end, value);\n            }\n        }\n\n        public int find(int index) {\n            return find(root, index);\n        }\n\n        private int find(Node node, int index) {\n            if (node.start == node.end) {\n                return node.value;\n            }\n            pushDown(node);\n            int mid = (node.start + node.end) / 2;\n            if (index <= mid) {\n                return find(node.left, index);\n            } else {\n                return find(node.right, index);\n            }\n        }\n\n        private void pushDown(Node node) {\n            if (node.pendingUpdate) {\n                node.left.value = node.right.value = node.value;\n                node.left.pendingUpdate = node.right.pendingUpdate = true;\n                node.pendingUpdate = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int initialValue = Integer.MAX_VALUE;\n\n        SegmentTree segmentTree = new SegmentTree(n);\n\n        int q = scanner.nextInt();\n        for (int query = 0; query < q; query++) {\n            String operation = scanner.next();\n            if (operation.equals(\"update\")) {\n                int s = scanner.nextInt();\n                int t = scanner.nextInt();\n                int x = scanner.nextInt();\n                segmentTree.update(s, t, x);\n            } else if (operation.equals(\"find\")) {\n                int i = scanner.nextInt();\n                System.out.println(segmentTree.find(i));\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 10:00:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    int* A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; ++i) {\n        A[i] = 231 - 1; // Initialize all values to 231-1\n    }\n    \n    for (int i = 0; i < q; ++i) {\n        char operation[6];\n        int s, t, x, idx;\n        scanf(\"%s\", operation);\n        \n        if (operation[0] == 'u') { // \"update\"\n            scanf(\"%d %d %d\", &s, &t, &x);\n            for (int j = s; j <= t; ++j) {\n                A[j] = x;\n            }\n        } else if (operation[0] == 'f') { // \"find\"\n            scanf(\"%d\", &idx);\n            printf(\"%d\\n\", A[idx]);\n        }\n    }\n    \n    free(A);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:00:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [2**31 - 1] * (4 * n)\n    \n    def update(self, node, start, end, l, r, val):\n        if start > end or start > r or end < l:\n            return\n        \n        if l <= start and end <= r:\n            self.tree[node] = val\n            return\n        \n        mid = (start + end) // 2\n        self.update(2*node, start, mid, l, r, val)\n        self.update(2*node+1, mid+1, end, l, r, val)\n    \n    def query(self, node, start, end, i):\n        if start == end:\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        if i <= mid:\n            return self.query(2*node, start, mid, i)\n        else:\n            return self.query(2*node+1, mid+1, end, i)\n\ndef main():\n    n, q = map(int, input().split())\n    st = SegmentTree(n)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        \n        if query[0] == 1:\n            # update\n            st.update(1, 0, n-1, query[1]-1, query[2]-1, query[3])\n        else:\n            # find\n            print(st.query(1, 0, n-1, query[1]-1))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:00:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nclass SegmentTreeNode:\n    __slots__ = ['l', 'r', 'left', 'right', 'value', 'lazy']\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.left = None\n        self.right = None\n        self.value = (1 << 31) - 1\n        self.lazy = None\n\n    def apply(self, x):\n        self.value = x\n        if self.l != self.r:\n            self.lazy = x\n\n    def push(self):\n        if self.l < self.r and self.lazy is not None:\n            self.left.apply(self.lazy)\n            self.right.apply(self.lazy)\n            self.lazy = None\n\nclass SegmentTree:\n    def __init__(self, l, r):\n        self.root = self.build(l, r)\n\n    def build(self, l, r):\n        node = SegmentTreeNode(l, r)\n        if l == r:\n            return node\n        mid = (l + r) // 2\n        node.left = self.build(l, mid)\n        node.right = self.build(mid + 1, r)\n        return node\n\n    def update_range(self, node, l, r, x):\n        if node.r < l or node.l > r:\n            return\n        if l <= node.l and node.r <= r:\n            node.apply(x)\n            return\n        node.push()\n        self.update_range(node.left, l, r, x)\n        self.update_range(node.right, l, r, x)\n\n    def query(self, node, i):\n        if node.l == node.r:\n            return node.value\n        node.push()\n        if i <= node.left.r:\n            return self.query(node.left, i)\n        else:\n            return self.query(node.right, i)\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    q = int(input[ptr])\n    ptr += 1\n    st = SegmentTree(0, n - 1)\n    for _ in range(q):\n        cmd = input[ptr]\n        ptr += 1\n        if cmd == 'update':\n            s = int(input[ptr])\n            ptr += 1\n            t = int(input[ptr])\n            ptr += 1\n            x = int(input[ptr])\n            ptr += 1\n            st.update_range(st.root, s, t, x)\n        elif cmd == 'find':\n            i = int(input[ptr])\n            ptr += 1\n            print(st.query(st.root, i))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:01:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass SequenceManipulator {\nprivate:\n    vector<int> sequence;\n    vector<int> lazy;\n    int n;\n    \npublic:\n    SequenceManipulator(int size) : n(size) {\n        sequence.assign(n, (1 << 31) - 1);\n        lazy.assign(n, -1);\n    }\n    \n    void update(int s, int t, int x, int l, int r, int node){\n        if (l >= s && r <= t) {\n            lazy[node] = x;\n        } else {\n            if (lazy[node] != -1) {\n                propagate(l, r, node);\n            }\n            int mid = (l + r) / 2;\n            if (mid >= s) update(s, t, x, l, mid, 2 * node);\n            if (mid + 1 <= t) update(s, t, x, mid + 1, r, 2 * node + 1);\n        }\n    }\n    \n    int find(int i, int l, int r, int node){\n        if (l == r) {\n            if (lazy[node] != -1) {\n                sequence[l] = lazy[node];\n            }\n            lazy[node] = -1;\n            return sequence[i];\n        } else {\n            if (lazy[node] != -1) {\n                propagate(l, r, node);\n            }\n            int mid = (l + r) / 2;\n            if (i <= mid) return find(i, l, mid, 2 * node);\n            else return find(i, mid + 1, r, 2 * node + 1);\n        }\n    }\n  \nprivate:\n    void propagate(int l, int r, int node) {\n        if (lazy[node] != -1) {\n            int mid = (l + r) / 2;\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n            lazy[node] = -1;\n        }\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SequenceManipulator manipulator(n);\n    \n    while (q--) {\n        string op;\n        cin >> op;\n        if (op == \"update\") {\n            int s, t, x;\n            cin >> s >> t >> x;\n            manipulator.update(s, t, x, 0, n - 1, 1);\n        } else if (op == \"find\") {\n            int i;\n            cin >> i;\n            cout << manipulator.find(i, 0, n - 1, 1) << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:56:38"
  }
]