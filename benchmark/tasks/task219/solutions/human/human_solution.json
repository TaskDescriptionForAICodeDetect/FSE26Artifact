[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n  solve()\n  @tailrec def solve(): Unit = {\n    val Array(w, h) = readLine.trim.split(' ').map(_.toInt)\n    if (w == 0 && h == 0) return\n    val field = new Field(Array.tabulate(h) { _ ⇒ readLine.trim.split(' ').map(_.toInt) })\n    val costs = readLine.trim.split(' ').map(_.toInt)\n    val operations = Array(Straight, Right, Back, Left)\n    val memo = Array.fill(h) {Array.fill(w) {Array.fill(4) {Int.MaxValue}}}\n    val queue = mutable.PriorityQueue()(Ordering.by[(Int, Robot), Int](_._1).reverse)\n    memo(0)(0)(1) = 0\n    queue.enqueue((0, InOperation(East, Coordinate(0, 0))))\n    while (queue.nonEmpty) {\n      val (cost, robot) = queue.dequeue()\n      if (memo(robot.position.y)(robot.position.x)(robot.direction.toInt) == cost) {\n        for (op ← operations.indices) {\n          val c = if (operations(op) == field(robot.position)) 0 else costs(op)\n          val next = robot.execute(operations(op))\n          if (next.isInOperation && field.contains(next.position) && memo(next.position.y)(next.position.x)(next.direction.toInt) > cost + c) {\n            memo(next.position.y)(next.position.x)(next.direction.toInt) = cost + c\n            queue.enqueue((cost + c, next))\n          }\n        }\n      }\n    }\n    println(memo.last.last.min)\n    solve()\n  }\n  class Field(state: Array[Array[Int]]) {\n    private val field = state.map{_.map{\n      case 0 ⇒ Straight\n      case 1 ⇒ Right\n      case 2 ⇒ Back\n      case 3 ⇒ Left\n      case 4 ⇒ Halt\n      case _ ⇒ ???\n    }}\n    def contains(coordinate: Coordinate): Boolean = field.indices.contains(coordinate.y) && field.head.indices.contains(coordinate.x)\n    def apply(coordinate: Coordinate): Operation = field(coordinate.y)(coordinate.x)\n    def isGoal(coordinate: Coordinate): Boolean = field.length == coordinate.y && field.head.length - 1 == coordinate.x\n  }\n  sealed trait Robot {\n    val direction: Direction\n    val position: Coordinate\n    def execute(operation: Operation): Robot\n    def isInOperation: Boolean\n  }\n  case class InOperation(direction: Direction, position: Coordinate) extends Robot {\n    override def execute(operation: Operation): Robot = {\n      operation match {\n        case Halt ⇒ Stopped(direction, position)\n        case _ ⇒ changeDirection(operation).moveForward\n      }\n    }\n    private def moveForward: InOperation = InOperation(direction, position.move(direction))\n    private[this] def changeDirection(operation: Operation): InOperation = {\n      operation match {\n        case Left ⇒ InOperation(direction.turnLeft, position)\n        case Right ⇒ InOperation(direction.turnRight, position)\n        case Back ⇒ InOperation(direction.turnBack, position)\n        case _ ⇒ this\n      }\n    }\n    override def isInOperation: Boolean = true\n  }\n  case class Stopped(direction: Direction, position: Coordinate) extends Robot {\n    override def execute(operation: Operation): Robot = this\n    override def isInOperation: Boolean = false\n  }\n  sealed trait Direction {\n    def turnRight: Direction = Direction.fromInt(Direction.toInt(this) + 1)\n    def turnLeft: Direction = Direction.fromInt(Direction.toInt(this) + 3)\n    def turnBack: Direction = Direction.fromInt(Direction.toInt(this) + 2)\n    def toInt: Int = Direction.toInt(this)\n  }\n  object Direction{\n    private def fromInt(value: Int): Direction = {\n      (value % 4 + 4) % 4 match {\n        case 0 ⇒ North\n        case 1 ⇒ East\n        case 2 ⇒ South\n        case 3 ⇒ West\n        case _ ⇒ ???\n      }\n    }\n    private def toInt(direction: Direction): Int = {\n      direction match {\n        case North ⇒ 0\n        case East ⇒ 1\n        case South ⇒ 2\n        case West ⇒ 3\n      }\n    }\n  }\n  object North extends Direction\n  object East extends Direction\n  object South extends Direction\n  object West extends Direction\n  case class Coordinate(x: Int, y: Int) {\n    def move(direction: Direction): Coordinate = {\n      direction match {\n        case North ⇒ Coordinate(x, y - 1)\n        case East ⇒ Coordinate(x + 1, y)\n        case South ⇒ Coordinate(x, y + 1)\n        case West ⇒ Coordinate(x - 1, y)\n      }\n    }\n  }\n  sealed trait Operation\n  object Straight extends Operation\n  object Right extends Operation\n  object Back extends Operation\n  object Left extends Operation\n  object Halt extends Operation\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nint f[33][33];\nint d[4][33][33];\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint w,h;\n\twhile(cin >> w >> h,w){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\t\tint cost[4];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tcin >> cost[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\td[k][i][j]=1e9;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[0][0][0]=0;\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int>>> q;\n\t\tq.push(make_pair(make_pair(0,0),make_pair(0,0)));\n\t\twhile(q.size()){\n\t\t\tauto p=q.top(); q.pop();\n\t\t\tif(d[p.first.second][p.second.first][p.second.second]!=-p.first.first)continue;\n\t\t\tint x=p.second.first,y=p.second.second;\n\t\t\tint ho=p.first.second;\n\t\t\tif(f[x][y]!=4){\n\t\t\t\tint nho=(ho+f[x][y])%4;\n\t\t\t\tint nx=x+dx[nho] , ny=y+dy[nho];\n\t\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w&&d[nho][nx][ny]>d[ho][x][y]){\n\t\t\t\t\td[nho][nx][ny]=d[ho][x][y];\n\t\t\t\t\tq.push(make_pair(make_pair(-d[nho][nx][ny],nho),make_pair(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nho=(ho+i)%4;\n\t\t\t\tint nx=x+dx[nho] , ny=y+dy[nho];\n\t\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w&&d[nho][nx][ny]>d[ho][x][y]+cost[i]){\n\t\t\t\t\td[nho][nx][ny]=d[ho][x][y]+cost[i];\n\t\t\t\t\tq.push(make_pair(make_pair(-d[nho][nx][ny],nho),make_pair(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",min({d[0][h-1][w-1],d[1][h-1][w-1],d[2][h-1][w-1],d[3][h-1][w-1]}));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** ?????????????????????????????? ***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF 1<<20\n\nint dx[4]={1, 0, -1, 0};\nint dy[4]={0, 1, 0, -1};\nint board[31][31];\nint cost[4];\nint hist[4][31][31];\nint w, h;\n\nvoid dfs(int x, int y, int ccost, int dir){\n\tif(!(x>=0&&x<w) || !(y>=0&&y<h)) return;\n\tif(hist[dir][y][x] <= ccost) return;\n\thist[dir][y][x]=ccost;\n\t\n\tif(board[y][x]!=4){\n\t\tint ddir=(dir+board[y][x])%4;\n\t\tdfs(x+dx[ddir], y+dy[ddir], ccost, ddir);\n\t}\n\tREP(k, 0, 4){\n\t\tif(k!=board[y][x]){\n\t\t\tint ddir=(dir+k)%4;\n\t\t\tdfs(x+dx[ddir], y + dy[ddir], ccost+cost[k], ddir);\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint main(){\n\t\n\twhile(cin>>w>>h, w||h){\n\t\tboard[31][31]={};\n\t\tcost[4]={};\n\t\t\n\t\tREP(i, 0, h){\n\t\t\tREP(j, 0, w){\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 0, 4) cin >> cost[i];\n\t\tREP(k, 0, 4){\n\t\t\tREP(i, 0, h){\n\t\t\t\tREP(j, 0, w){\n\t\t\t\t\thist[k][i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(0, 0, 0, 0);\n\t\t\n\t\tint ans=INF;\n\t\tREP(k, 0, 4) ans=min(ans, hist[k][h-1][w-1]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nstruct pos {\n    int dir;\n    int y, x;\n    bool operator<(pos const& p) const {\n        return dir < p.dir;\n    }\n};\n\nusing P = pair<int, pos>;\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        vector<vector<vector<int>>> d(4, vector<vector<int>>(h, vector<int>(w, INF)));\n        vector<vector<int>> s(h, vector<int>(w));\n        int c[4] = {};\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                cin >> s[i][j];\n            }\n        }\n        for(int i=0; i<4; ++i) {\n            cin >> c[i];\n        }\n        d[0][0][0] = 0; // 0 -> east, 1 -> south, 2 -> west, 3 -> north \n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(P{0, pos{0, 0, 0}});\n        int dx[4] = {1, 0, -1, 0},\n            dy[4] = {0, 1, 0, -1};\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            pos pp = p.second;\n            if(d[pp.dir][pp.y][pp.x] < p.first) {\n                continue;\n            }\n            // 0 -> straight, 1 -> right, 2 -> turn, 3 -> left\n            for(int op=0; op<4; ++op) {\n                int ndir = (pp.dir+op)%4;\n                int ny = pp.y + dy[ndir], nx = pp.x + dx[ndir];\n                if(ny < 0 || h <= ny || nx < 0 || w <= nx) {\n                    continue;\n                }\n                if(s[pp.y][pp.x] == op) {\n                    if(d[ndir][ny][nx] > p.first) {\n                        d[ndir][ny][nx] = p.first;\n                        que.push(P{p.first, pos{ndir, ny, nx}});\n                    }\n                } else {\n                    if(d[ndir][ny][nx] > p.first + c[op]) {\n                        d[ndir][ny][nx] = p.first + c[op];\n                        que.push(P{p.first + c[op], pos{ndir, ny, nx}});\n                    }\n                }\n            }\n        }\n        int res = INF;\n        for(int i=0; i<4; ++i) {\n            res = min(res, d[i][h-1][w-1]);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\n\nint w, h;\nstruct P\n{\n\tint x, y;\n\tint cost;\n\tint i;\n\tbool move()\n\t{\n\t\tx += dx[i];\n\t\ty += dy[i];\n\t\tif (x<=0||y<=0||w<x||h<y)return false;\n\t\treturn true;\n\t}\n\tvoid turn_right()\n\t{\n\t\ti+=1;\n\t\ti %= 4;\n\t}\n\tvoid turn_left()\n\t{\n\t\ti+=3;\n\t\ti %= 4;\n\t}\n\tvoid turn_back()\n\t{\n\t\ti += 2;\n\t\ti %= 4;\n\t}\n\tbool operator<(const P &right)const \n\t{\n\t\treturn cost < right.cost;\n\t}\n\tbool operator>(const P &right)const\n\t{\n\t\treturn cost > right.cost;\n\t}\n};\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tvector<vi> a(35, vi(35, 4));\n\t\tvi cost(4, 0);\n\t\tint flag[35][35][4];\n\n\t\tcin >> w >> h; if (!w)break;\n\t\tFORI(i, 1, h + 1)FORI(j, 1, w + 1)\n\t\t\tcin >> a[i][j];\n\t\tFOR(i, 4)\n\t\t\tcin >> cost[i];\n\t\tFOR(i, 35)FOR(j, 35)FOR(k, 4)flag[i][j][k] = INT_MAX;\n\n\n\t\tP start{ 1,1,0,1 };\n\t\tpriority_queue< P, vector<P>, greater<P> > que;\n\t\tque.push(start);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif (now.x == w&&now.y == h)\n\t\t\t{\n\t\t\t\tcout << now.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFOR(i, 4)\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tif (a[now.y][now.x] == i)continue;\n\t\t\t\tnext.cost += cost[i];\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tnext.turn_right();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tnext.turn_back();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tnext.turn_left();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (next.move()&&flag[next.y][next.x][next.i]>next.cost)\n\t\t\t\t{\n\t\t\t\t\tflag[next.y][next.x][next.i] = next.cost;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tswitch (a[now.y][now.x])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tnow.turn_right();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnow.turn_back();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnow.turn_left();\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!ok)continue;\n\t\t\tif (now.move()&&flag[now.y][now.x][now.i]>now.cost)\n\t\t\t{\n\t\t\t\tflag[now.y][now.x][now.i] = now.cost;\n\t\t\t\tque.push(now);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 123456789;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint id(int x, int y, int d){\n  return (x * 32 + y) * 4 + d;\n}\n\nint cmdpos(int x, int y, int c, int d){\n  return id(x+dx[(d+c)%4], y+dy[(d+c)%4], (c+d)%4);\n}\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\n\ntypedef vector< vector<Edge> > Graph;\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int W, H;\n  while(cin >> W >> H, W){\n\tint bd[32][32], cost[4];\n  \n\tREP(y,H) REP(x,W)\n\t  cin >> bd[y+1][x+1];\n\t\n\tREP(i,4) cin >> cost[i];\n\t\n\tGraph G(4100);\n\tVI dist(4100);\n\tFOR(y,1,H+1) FOR(x,1,W+1){\n\t  if(bd[y][x] == 4) continue;\n\t  REP(d,4)\n\t\tG[id(x,y,d)].PB(Edge(cmdpos(x,y,bd[y][x],d), 0));\n\t}\n\t\n\tFOR(y,1,H+1) FOR(x,1,W+1) REP(d,4) REP(c,4){\n\t  if(c == bd[y][x]) continue;\n\t  G[id(x,y,d)].PB(Edge(cmdpos(x,y,c,d), cost[c]));\n\t}\n\n\tDijkstra(G, dist, id(1,1,0));\n\tint ans = INF;\n\tREP(d,4)\n\t  ans = min(ans, dist[id(W,H,d)]);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n \n#define REP(i,b,n) for(int i=b;i<n;++i)\n#define REPR(i,b,n) for(int i=n-1;i>=b;--i)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n\nusing namespace std;\n\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> stt;\ntypedef long long ll;\n\nenum{RIGHT, UP, LEFT, DOWN};\n\nint h, w;\nint field[32][32];\nint vtx[32][32][4];\nint cost[4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nint rev[] = {0, -1, 2, 1};\n\nbool border(int lw, int mid, int hg){\n\treturn lw <= mid && mid <= hg;\n}\n\nint solve(){\n\n\tqueue<stt> qu;\n\tqu.push(make_pair( make_pair(1,1), (int)(RIGHT)));\n\tvtx[1][1][RIGHT] = 0;\n\t\n\tstt now;\n\tint x, y, dir, nx, ny, ndir, pay;\n\t\n\twhile(!qu.empty()){\n\t\t\n\t\tnow = qu.front();\n\t\tx = now.first.first, y = now.first.second, dir = now.second;\n\t\tqu.pop();\n\t\t\n\t\tswitch(field[y][x] == 4)\n\t\t\tcontinue;\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tif(i==field[y][x])\n\t\t\t\tpay = 0;\n\t\t\telse\n\t\t\t\tpay = cost[i];\n\t\t\t\n\t\t\tndir = (4+dir+rev[i])%4;\n\t\t\tnx = x+dx[ndir];\n\t\t\tny = y+dy[ndir];\n\t\t\t\n\t\t\tif(border(1,nx,w) && border(1,ny,h) && vtx[ny][nx][ndir] > vtx[y][x][dir] + pay){\n\t\t\t\tvtx[ny][nx][ndir] = vtx[y][x][dir] + pay;\n\t\t\t\tqu.push(make_pair( make_pair(nx,ny), ndir));\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tint res = INT_MAX;\n\t\n\tfor(int i=0; i<4; ++i){\n\t\t\n\t\tres = min(res, vtx[h][w][i]);\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> w >> h, (w||h)){\n\t\t\n\t\tfor(int y=1; y<=h; ++y){\n\t\t\tfor(int x=1; x<=w; ++x){\n\t\t\t\n\t\t\t\tcin >> field[y][x];\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tvtx[y][x][k] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\tcin>> cost[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w,h;\n\nint table[35][35];\nint c[4];\nint dist[35][35][4];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nstruct state{\n\tint x,y,d,costs;\n\tbool operator<(const state &arg)const{\n\t\treturn costs > arg.costs;\n\t}\n};\n\nvoid dijkstra(){\n\trep(i,h)rep(j,w)rep(k,4)dist[i][j][k]=inf;\n\tdist[0][0][1]=0;\n\tstate s;\n\ts.x=0,s.y=0,s.d=1,s.costs=0;\n\tpriority_queue<state>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint x,y,d,costs;\n\t\tx=cur.x,y=cur.y,d=cur.d,costs=cur.costs;\n\t\tif(dist[y][x][d]<costs)\n\t\t\tcontinue;\n\t\trep(i,4){\n\t\t\tint nx=x,ny=y,nd=d,ncosts=costs;\n\t\t\tnd=(nd+i)%4;\n\t\t\tnx+=dx[nd],ny+=dy[nd];\n\t\t\tif(table[y][x]!=i)\n\t\t\t\tncosts+=c[i];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\tif(dist[ny][nx][nd]>ncosts){\n\t\t\t\t\tdist[ny][nx][nd]=ncosts;\n\t\t\t\t\tstate nexts;\n\t\t\t\t\tnexts.x=nx,nexts.y=ny,nexts.d=nd,nexts.costs=ncosts;\n\t\t\t\t\tq.push(nexts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0)\n\t\t\tbreak;\n\t\trep(i,h)rep(j,w) scanf(\"%d\",&table[i][j]);\n\t\trep(i,4) scanf(\"%d\",&c[i]);\n\t\tdijkstra();\n\t\tint ans=inf;\n\t\trep(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define MAX_H 30\n#define MAX_W 30\n#define INF (1<<29)\n\nstruct State{\n  int cost,x,y,dir;\n  State(int cost,int x,int y,int dir) :\n    cost(cost),x(x),y(y),dir(dir) {}\n\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint H,W,c[4];\nint s[MAX_H][MAX_W];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint dijkstra(){\n  int d[MAX_H][MAX_W][4];\n  fill(d[0][0],d[0][0]+MAX_H*MAX_W*4,INF);\n  d[0][0][2] = 0;\n  priority_queue<State> Q;\n  Q.push(State(0,0,0,2));\n  while(!Q.empty()){\n    State cur = Q.top(); Q.pop();\n    int x = cur.x,y = cur.y,dir = cur.dir;\n    if(d[y][x][dir] < cur.cost) continue;\n    if(x == W-1 && y == H-1) return d[y][x][dir];\n    for(int i = 0 ; i < 4 ; i++){\n      int ndir = (dir+i)%4;\n      int nx = x + dx[ndir];\n      int ny = y + dy[ndir];\n      if(!inField(nx,ny)) continue;\n      if(s[y][x] == i){\n\tif(d[y][x][dir] < d[ny][nx][ndir]){\n\t  d[ny][nx][ndir] = d[y][x][dir];\n\t  Q.push(State(d[ny][nx][ndir],nx,ny,ndir));\n\t}\n      }else{\n\tif(d[y][x][dir] + c[i] < d[ny][nx][ndir]){\n\t  d[ny][nx][ndir] = d[y][x][dir] + c[i];\n\t  Q.push(State(d[ny][nx][ndir],nx,ny,ndir));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> s[i][j];\n      }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n      cin >> c[i];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\ntypedef pair < int , pair<pair<int , int> , int> > P;\n\n//0 ??????1?????????2?????????3??????\n\nint dx[] = { 1 , 0 , -1 , 0 };\nint dy[] = { 0 , 1 , 0 , -1 };\n\nint main ()\n{\n\tint W , H;\n\twhile( cin >> W >> H , W || H )\n\t{\n\t\tvector<vector<int>>data;\n\t\tvector<vector<vector<int>>>M;\n\t\tdata.resize ( H );\n\t\tM.resize ( H );\n\t\tfor( size_t i = 0; i < H; i++ )\n\t\t{\n\t\t\tM[i].resize ( W );\n\t\t\tdata[i].resize ( W );\n\t\t\tfor( size_t j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tM[i][j].resize ( 4 );\n\t\t\t\tfor( size_t k = 0; k < 4; k++ )\n\t\t\t\t{\n\n\t\t\t\tM[i][j][k] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint C[4] = {};\n\t\tfor( size_t i = 0; i < 4; i++ )\n\t\t{\n\t\t\tcin >> C[i];\n\t\t}\n\t\tpriority_queue<P , vector<P> , greater<P>>que;\n\t\tlong long int ans = -1;\n\t\tque.push ( P{ 0 , pair < pair<int , int> , int > {pair < int , int > {0 , 0} , 0} } );\n\t\tM[0][0][0] = 0;\n\t\twhile( !que.empty () )\n\t\t{\n\t\t\tP now = que.top (); que.pop ();\n\t\t\tint nowcost = now.first;\n\t\t\tint nowx = now.second.first.second;\n\t\t\tint nowy = now.second.first.first;\n\t\t\tint nowd = now.second.second;\n\n\t\t\t//cout << nowx << \" \" << nowy << \" \" << nowcost << endl;\n\n\t\t\t/*if( nowy == H - 1 && nowx == W - 1 )\n\t\t\t{\n\t\t\t\tans = nowcost;\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t\t//if( data[nowy][nowx] == 4 )continue;\n\t\t\tfor( size_t i = 0; i < 4; i++ )\n\t\t\t{\n\t\t\t\tint nextd = ( i + nowd ) % 4;\n\t\t\t\tint nextx = nowx + dx[nextd];\n\t\t\t\tint nexty = nowy + dy[nextd];\n\t\t\t\tif( nextx < 0 || nextx >= W || nexty < 0 || nexty >= H )continue;\n\t\t\t\tif( i == data[nowy][nowx] )\n\t\t\t\t{\n\t\t\t\t\tif( M[nexty][nextx][nextd]>nowcost )\n\t\t\t\t\t{\n\t\t\t\t\t\tM[nexty][nextx][nextd] = nowcost;\n\t\t\t\t\t\tque.push ( P{ nowcost , pair < pair<int , int> , int > {pair < int , int > {nexty , nextx} , nextd} } );\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif( M[nexty][nextx][nextd] > nowcost + C[i] )\n\t\t\t\t\t{\n\t\t\t\t\t\tM[nexty][nextx][nextd] = nowcost + C[i];\n\t\t\t\t\t\tque.push ( P{ nowcost + C[i] , pair < pair<int , int> , int > {pair < int , int > {nexty , nextx} , nextd} } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tint ans2 = INT_MAX;\n\t\tfor( size_t i = 0; i < 4; i++ )\n\t\t{\n\t\t\tans2 = min ( ans2 , M[H - 1][W - 1][i] );\n\t\t}\n\t\tcout << ans2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define min(a,b) ((a)>(b)?(b):(a))\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main() {\n\tint map[M+4][M+4], c[4], w, h;\n\tstatic int dp[M+4][M+4][M*M+10][8], ans;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\tfor(int i=1; i<=h; ++i) {\n\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tfor(int t=0; t<=w*h; ++t) {\n\t\t\t\t\tfor(int k=0; k<4; ++k) dp[i][j][t][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\tdp[1][1][0][0] = 0; ans = INF;\n\t\tfor(int t=1; t<=w*h; ++t) {\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tif(i==h&&j==w) continue;\n\t\t\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\t\t\tfor(int l=0; l<4; ++l) {\n\t\t\t\t\t\t\tint d = (k+l)%4;\n\t\t\t\t\t\t\tif(map[i][j]==l) {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]+c[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j+dx[d]==w&&i+dy[d]==h&&d<2) {\n\t\t\t\t\t\t\t\tans = min(ans, dp[i+dy[d]][j+dx[d]][t][d%4]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct Data\n{\n\tint y, x, d, cost;\n\tData(int y, int x, int d, int cost) : y(y), x(x), d(d), cost(cost) {}\n\n\tbool operator< (const Data& d)const\n\t{\n\t\treturn cost > d.cost;\n\t}\n};\n\nint main()\n{\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tvvi field(h, vi(w));\n\t\trep(i, h) rep(j, w)\n\t\t\tscanf(\"%d\", &field[i][j]);\n\n\t\tint c[4];\n\t\trep(i, 4) scanf(\"%d\", &c[i]);\n\n\t\tvector<vvi> done(h, vvi(w, vi(4, 0)));\n\n\t\tint ans;\n\t\tpriority_queue<Data> Q;\n\t\tData start(0, 0, 0, 0);\n\t\tQ.push(start);\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(done[d.y][d.x][d.d])\n\t\t\t\tcontinue;\n\n\t\t\tdone[d.y][d.x][d.d] = 1;\n\t\t\tif(d.y == h-1 && d.x == w-1){\n\t\t\t\tans = d.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst int dx[] = {1, 0, -1, 0, 1, 0, -1};\n\t\t\tconst int dy[] = {0, 1, 0, -1, 0, 1, 0};\n\t\t\trep(i, 4){\n\t\t\t\tint py = d.y + dy[i+d.d];\n\t\t\t\tint px = d.x + dx[i+d.d];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(done[py][px][(i+d.d)%4])\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint pc = d.cost + (i==field[d.y][d.x] ? 0 : c[i]);\n\t\t\t\tQ.push(Data(py, px, (i+d.d)%4, pc));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 重み0の辺とコストがかかる辺のグラフ経路問題かな？\n// ただ、ロボットの向きもあるので頂点の数はグリッドの数×4方向になる\n// このプログラムでは、\n/*\n    →x\n↓y  * * * * * * \n    * * * * * *\n    * * * * * *\n*/\n// になっているよ。\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dy[] = {0, 1, 0, -1};\nconst int dx[] = {1, 0, -1, 0};\nint s[40][40];\nint G[40][40][4];\nint c[4];\n\nusing ptupl = pair<int, tuple<int, int, int>>;\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w || h) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> s[i][j];\n            }\n        }\n        cin >> c[0] >> c[1] >> c[2] >> c[3];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                memset(G[i][j], -1, sizeof(G[i][j]));\n            }\n        }\n        priority_queue<ptupl, vector<ptupl>, greater<ptupl>> que;\n        que.emplace(0, make_tuple(0, 0, 0));\n        while (!que.empty()) {\n            auto p = que.top();\n            que.pop();\n            int d = p.first,\n                x = get<0>(p.second),\n                y = get<1>(p.second),\n                dir = get<2>(p.second);\n            if (G[y][x][dir] != -1) continue;\n            G[y][x][dir] = d;\n            // 命令せずに進ませる場合\n            if (s[y][x] != 4) {\n                int ndir = (dir + s[y][x] + 4) % 4;\n                int nx = x + dx[ndir];\n                int ny = y + dy[ndir];\n                if (!(nx < 0 || nx >= w || ny < 0 || ny >= h))\n                    if (G[ny][nx][ndir] == -1) que.emplace(d, make_tuple(nx, ny, ndir));\n            }\n            // 直進、または右折左折命令をさせる場合\n            for (int i = 0; i < 4; ++i) {\n                int ndir = (dir + i + 4) % 4;\n                int nx = x + dx[ndir];\n                int ny = y + dy[ndir];\n                if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n                if (G[ny][nx][ndir] == -1) que.emplace(d + c[i], make_tuple(nx, ny, ndir));\n            }\n        }\n\n        int res = 1000000000;\n        for (int i = 0; i < 4; ++i) {\n            if (G[h - 1][w - 1][i] == -1) continue;\n            res = min(res, G[h - 1][w - 1][i]);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define Y second.first\n#define X second.second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint w, h;\nint s[32][32], dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1}, c[4], used[32][32][4];\n\nint main(){\n  while(scanf(\"%d%d\", &w, &h) && w+h){\n    rep(i, h) rep(j, w) scanf(\"%d\", &s[i][j]);\n    rep(i, 4) scanf(\"%d\", c+i);\n\n    memset(used, 0, sizeof(used));\n    priority_queue<pipi, vector<pipi>, greater<pipi> >q; // cost, nesw, y, x\n    q.push(MP(MP(0, 1), MP(0, 0)));\n    while(!q.empty()){\n      pipi now = q.top(); q.pop();\n      if(used[now.Y][now.X][now.F.S]++) continue;\n      //      printf(\"%d %d %d %d\\n\", now.F.F, now.F.S, now.Y, now.X);\n      if(now.Y == h-1 && now.X == w- 1){\n\tprintf(\"%d\\n\", now.F.F);\n\tbreak;\n      }\n      rep(i, 4){\n\tpipi next = now;\n\tif(i != s[now.Y][now.X]) next.F.F += c[i];\n\tnext.F.S = (next.F.S+i)%4;\n\tnext.Y += dy[next.F.S]; next.X += dx[next.F.S];\n\tif(next.Y < 0 || next.X < 0 || next.Y >= h || next.X >= w) continue;\n\tq.push(next);\n      }\n    }\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint dy[4] = {-1,0,1,0};\nint dx[4] = {0,-1,0,1};\nint w,h;\nint a[31][31];\nint c[4];\nint dis[31][31][4];\n\nint new_dir(int com, int dir) {\n  if (com == 0) return dir;\n  if (com == 1) return (dir+3)%4;\n  if (com == 2) return (dir+2)%4;\n  if (com == 3) return (dir+1)%4;\n  return -1;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> w >> h, w) {\n    REP(i,h) REP(j,w) cin >> a[i][j];\n    REP(i,4) cin >> c[i];\n    MINF(dis);\n    dis[0][0][3] = 0;\n    using P = tuple<int,int,int,int>;\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.emplace(0,0,0,3);\n    while (!que.empty()) {\n      int dd,y,x,dir;\n      tie(dd,y,x,dir) = que.top(); que.pop();\n      if (dis[y][x][dir] < dd) continue;\n      int ndir = new_dir(a[y][x],dir);\n      if (ndir >= 0) {\n        int ny = y+dy[ndir];\n        int nx = x+dx[ndir];\n        if (IN(ny,0,h-1) && IN(nx,0,w-1)) {\n          if (CHMIN(dis[ny][nx][ndir],dis[y][x][dir])) {\n            que.emplace(dis[ny][nx][ndir],ny,nx,ndir);\n          }\n        }\n      } else {\n        if (y == h-1 && x == w-1) break;\n      }\n      for (int i = 0; i < 4; i++) if (i != a[y][x]) {\n        int ndir = new_dir(i,dir);\n        int ny = y+dy[ndir];\n        int nx = x+dx[ndir];\n        if (IN(ny,0,h-1) && IN(nx,0,w-1)) {\n          if (CHMIN(dis[ny][nx][ndir],dis[y][x][dir]+c[i])) {\n            que.emplace(dis[ny][nx][ndir],ny,nx,ndir);\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i,4) CHMIN(ans,dis[h-1][w-1][i]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint w, h;\nint s[32][32];\nint cost[4];\n\n// dir\n// 0 : right\n// 1 : up\n// 2 : left\n// 3 : down\nconst int dr[4] = {0, -1, 0, 1};\nconst int dc[4] = {1, 0, -1, 0};\nconst int dd[4] = {0, 3, 2, 1};\n\ntypedef std::pair<int, int> Pii;\n\nclass Node {\npublic:\n  Node() {}\n  Node(int r_, int c_, int dir_) : r(r_), c(c_), dir(dir_) {}\n  int r, c, dir;\n};\n\nclass Data {\npublic:\n  Data() {}\n  Data(Node s_, Node t_, int cost_) : s(s_), t(t_), cost(cost_) {}\n  Node s, t;\n  int cost;\n};\n\ninline bool operator < (const Data& a, const Data& b) {\n  return a.cost > b.cost;\n}\n\nint dist[32][32][8];\nint dijkstra() {\n  std::priority_queue<Data> q;\n  int r = 0;\n  int c = 0;\n  int dir = 0;\n  dist[r][c][dir] = 0;\n  for(int k = 0; k < 4; ++k) {\n    int nd = (dir + dd[k]) % 4;\n    int nr = r + dr[nd];\n    int nc = c + dc[nd];\n    if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n    q.push(Data(Node(r, c, dir), Node(nr, nc, nd), k == s[r][c] ? 0 : cost[k]));\n  }\n  while( not q.empty() ) {\n    Data t = q.top(); q.pop();\n    int r = t.t.r, c = t.t.c, dir = t.t.dir;\n    if( dist[r][c][dir] <= dist[t.s.r][t.s.c][t.s.dir] + t.cost ) {\n      continue;\n    }\n    dist[r][c][dir] = std::min(dist[r][c][dir], dist[t.s.r][t.s.c][t.s.dir] + t.cost);\n    if( r == h - 1 and c == w - 1 ) continue;\n    for(int k = 0; k < 4; ++k) {\n      int nd = (dir + dd[k]) % 4;\n      int nr = r + dr[nd];\n      int nc = c + dc[nd];\n      if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n      q.push(Data(Node(r, c, dir), Node(nr, nc, nd), k == s[r][c] ? 0 : cost[k]));\n    }\n  }\n  int res = (1 << 30);\n  for(int i = 0; i < 4; ++i) {\n    res = std::min(res, dist[h-1][w-1][i]);\n  }\n  return res;\n}\n\nvoid Init() {\n  for(int i = 0; i < 32; ++i) {\n    for(int j = 0; j < 32; ++j) {\n      for(int k = 0; k < 8; ++k) {\n        dist[i][j][k] = (1 << 29);\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    Init();\n    scanf(\"%d %d\", &w, &h);\n    if( w == 0 and h == 0 ) break;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\"%d\", &s[i][j]);\n      }\n    }\n    for(int i = 0; i < 4; ++i) {\n      scanf(\"%d\", &cost[i]);\n    }\n    int res = dijkstra();\n    printf(\"%d\\n\", res);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<array>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nstruct Entry\n{\n    int x, y;\n    int direction;\n};\n\nint main()\n{\n    int w, h;\n\n    while(cin >> w >> h, (w | h) )\n    {\n\n        //map[h][w]\n        array< array<int, 30>, 30> map{};\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cin >> map[i][j];\n            }\n        }\n        \n        //command[0]?????´???\n        //command[1]?????????\n        //command[2]????????¢\n        //command[3]?????????\n        array<int, 4> command;\n        for(int i = 0; i < 4; i++)\n        {\n            cin >> command[i];\n        }\n\n       \n        //??????????????\\?????????????????¨?????????\n        array< array< array< int, 4>, 30>, 30> cost;\n\n        //cost[0][][]??????\n        //cost[1][][]??????\n        //cost[2][][]??????\n        //cost[3][][]??????\n\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cost[0][i][j] = INF;\n                cost[1][i][j] = INF;\n                cost[2][i][j] = INF;\n                cost[3][i][j] = INF;\n            }\n        }\n\n        const int dx[4] = {1, 0, -1, 0};\n        const int dy[4] = {0, 1, 0, -1};\n\n\n        //start\n        queue<Entry> que;\n\n        que.push(Entry{0, 0, 0});\n        cost[0][0][0] = 0;\n\n        while(!que.empty())\n        {\n            Entry now = que.front();\n            que.pop();\n            //cout << que.size() << \" : (\" << now.x << \", \" << now.y  << \") \" << now.direction << \" : \" << cost[now.direction][now.y][now.x] << endl;\n\n            //????????????????????£?????????????????????\n            int followedDirection = now.direction + map[now.y][now.x];\n            followedDirection %= 4;\n\n            //halt\n            if(map[now.y][now.x] == 4)followedDirection = INF;\n\n            //(now.direction + i) % 4????¬??????????\n            //i????????¢???????§????\n            for(int i = 0; i < 4; i++)\n            {\n                int nextDirection = (now.direction + i) % 4;\n                int tmp_cost = cost[now.direction][now.y][now.x] + (nextDirection != followedDirection) * command[i];\n\n                int nextX = now.x + dx[nextDirection];\n                int nextY = now.y + dy[nextDirection];\n\n                //???????????????????????????\n                if( !(nextX < 0 || nextX >= w || nextY < 0 || nextY >= h) ) \n                {\n                    //?????????????°???????????????°?§????\n                    if(tmp_cost < cost[nextDirection][nextY][nextX])\n                    {\n                        cost[nextDirection][nextY][nextX] = tmp_cost;\n                        que.push( Entry{ nextX, nextY, nextDirection } );\n                    }\n                }                \n            }\n        }\n\n        int ans = INF;\n        for(int i = 0; i < 4; i++)\n        {\n            if(cost[i][h - 1][w - 1] < ans)ans = cost[i][h - 1][w - 1];\n            //cout << cost[i][h - 1][w - 1] << endl;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\n#define FOR(a,b,c) for ( int a = b; a < (int)c; a++ )\n#define REP(a,b) FOR(a,0,b)\n#define DEBUG 0\n\nclass Pos {\npublic:\n    int r, c;\n    bool operator == ( const Pos& p ) const {\n        return r == p.r && c == p.c;\n    }\n    bool operator < ( const Pos& p ) const {\n        return r == p.r ? c < p.c : r < p.r;\n    }\n    Pos() { r=0, c=0; }\n    Pos( int r_, int c_ ): r(r_), c(c_) {}\n\n#if DEBUG\n    string toStr()\n    {\n        ostringstream os;\n        os << \"(\" << r << \",\" << c << \")\";\n        return os.str();\n    }\n#endif\n};\n\nclass Node {\npublic:\n    int cost;\n    int a;\n    Pos p;\n    Node() { cost = 0, a = 0, p = Pos(0,0); }\n    Node( int cost_, int a_, int r, int c ) { cost = cost_, a = a_, p = Pos( r, c ); }\n    bool operator == ( const Node& node ) const {\n        return cost == node.cost;\n    }\n    bool operator < ( const Node& node ) const {\n        return cost < node.cost;\n    }\n    bool operator > ( const Node& node ) const {\n        return cost > node.cost;\n    }\n\n#if DEBUG\n    string toStr() {\n        ostringstream os;\n        os << \"Node: \" << cost << \", \" << a << \", \" << p.toStr();\n        return os.str();\n    }\n#endif\n};\n\ntypedef priority_queue <Node, vector<Node>, greater<Node> > QUEUE;\n\n// global var\nconst int size = 31;\nint w, h;\nint s[size][size];\nint c[4];\nint D[4][size][size]; // min cost\n\nbool isValid( Pos p ) \n{\n    return p.r >= 0 && p.r < h && p.c >= 0 && p.c < w;\n}\n\n// a%b\nint getRem( int a, int b )\n{\n    int rem = a % b;\n    if ( rem < 0 ) rem = b + rem;\n    return rem;\n}\n\nint main( void )\n{\n    while ( cin >> w >> h && w && h ) {\n        // init\n        REP(i,size) REP(j,size) s[i][j]=0;\n        REP(i,size) REP(j,size) REP(k,4) D[k][i][j]=1<<24;\n        REP(i,4) c[i] = 0;\n\n        // input\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                cin >> s[i][j];\n            }\n        }\n        for ( int i = 0; i < 4; i++ ) {\n            cin >> c[i];\n        }\n\n        // proc\n        int answer = 1<<24;\n        QUEUE Q;\n        Node start;\n        Pos goal( h-1, w-1 );\n        Q.push( start );\n        D[0][start.p.r][start.p.c] = 0;\n\n        while ( !Q.empty() ) {\n            Node node = Q.top();\n            Q.pop();\n\n            if ( node.p == goal ) {\n                answer = min( answer, D[node.a][node.p.r][node.p.c] );\n                continue;\n            }\n#if DEBUG\n            // cout << Q.size() << endl;\n            // cout << node.toStr() << endl;\n#endif\n            // proc\n            for ( int i = 0; i < 4; i++ ) {\n                int cost = node.cost;\n                int a = node.a;\n                Pos p = node.p;\n                Node next_node = node;\n\n                // cost\n                if ( i != s[p.r][p.c] ) {\n                    cost += c[i];\n                }\n\n                // operation\n                if ( i == 1 ) {\n                    a = getRem( a+1, 4 );\n                } else if ( i == 2 ) {\n                    a = getRem( a+2, 4 );\n                } else if ( i == 3 ) {\n                    a = getRem( a-1, 4 );\n                }\n\n                // move\n                if ( a == 0 ) {\n                    p.c++;\n                } else if ( a == 1 ) {\n                    p.r++;\n                } else if ( a == 2 ) {\n                    p.c--;\n                } else if ( a == 3 ) {\n                    p.r--;\n                }\n\n                if ( !isValid( p ) ) {\n                    continue;\n                }\n\n                if ( cost >= D[a][p.r][p.c] ) continue;\n                D[a][p.r][p.c] = cost;\n                next_node.cost = cost;\n                next_node.a = a;\n                next_node.p = p;\n                Q.push( next_node );\n#if DEBUG\n                if ( w == 2 && h == 8 ) cout << node.toStr() << \" | \" << next_node.toStr() << endl;\n#endif\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCà\\I2008 D. ¿åë¿åë{bg\n\n#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint x, y, d, cost;\n\tNode(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nchar dx[] = {0, 1, 0, -1};\nchar dy[] = {1, 0, -1, 0};\n\nint main(){\n\tint w, h;\n\tint op[4];\n\tint b[30][30];\n\tint c[30][30][4];\n\twhile(cin >> w >> h, w){\n\t\tmemset(c, -1, sizeof(c));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++) cin >> b[i][j];\n\t\t}\n\t\tfor(int i=0;i<4;i++) cin >> op[i];\n\t\tpriority_queue<Node> qu;\n\t\tqu.push(Node(0,0,0,0));\n\t\tint ans = 9999999;\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint x = nd.x, y = nd.y, d = nd.d, cost = nd.cost;\n\t\t\tif(c[x][y][d]!=-1) continue;\n\t\t\tif(x==h-1&&y==w-1) { ans = cost; break; }\n\t\t\tc[x][y][d] = cost;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(nx<0||nx>=h||ny<0||ny>=w) continue;\n\t\t\t\tif(b[x][y]!=4&&(b[x][y]+d)%4==i)\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost));\n\t\t\t\telse\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost+op[(4+i-d)%4]));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing VI = vector<int>;\nusing PII = pair<int,int>;\n#define MP make_pair\n#define FF first\n#define SS second\n\nint dist[30][30][4];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint main(){\n  int W, H;\n  while(cin>>W>>H,W){\n    vector<VI> xs(H, VI(W));\n    for(int y=0;y<H;++y)\n      for(int x=0;x<W;++x)\n\tcin >> xs[y][x];\n    VI cs(4);\n    for(int i=0;i<4;++i)\n      cin >> cs[i];\n\n    fill((int*)dist, (int*)dist+30*30*4, 1e9);\n    // dist, dir, y, x\n    using P = pair<int,pair<int,PII>>;\n    priority_queue<P,vector<P>,greater<P>> pq;\n    // y, x, dir\n    dist[0][0][0] = 0;\n    pq.push(MP(0,MP(0,MP(0,0))));\n    while(!pq.empty()){\n      P p = pq.top();\n      pq.pop();\n      int cost = p.FF;\n      int dir = p.SS.FF;\n      int y = p.SS.SS.FF;\n      int x = p.SS.SS.SS;\n      if(dist[y][x][dir] < cost) continue;\n      for(int i=0;i<4;++i){\n\tint tdir = (dir + i) % 4;\n\tint tx = x + dx[tdir], ty = y + dy[tdir];\n\tint nc = cost + cs[i];\n\tif(0 <= ty && ty < H && 0 <= tx && tx < W\n\t   && dist[ty][tx][tdir] > nc){\n\t  pq.push(MP(nc, MP(tdir, MP(ty,tx))));\n\t  dist[ty][tx][tdir] = nc;\n\t}\n      }\n\n      if(xs[y][x] == 4) continue;\n      if(xs[y][x] == 1) (++dir) %= 4;\n      else if(xs[y][x] == 2) (dir+=2)%=4;\n      else if(xs[y][x] == 3) (dir+=3)%=4;\n      int tx = x + dx[dir], ty = y + dy[dir];\n      if(0 <= ty && ty < H && 0 <= tx && tx < W\n\t && dist[ty][tx][dir] > cost){\n\tpq.push(MP(cost, MP(dir, MP(ty,tx))));\n\tdist[ty][tx][dir] = cost;\n      }\n    }\n    \n    int ans = 1e9;\n    for(int i=0;i<4;++i)\n      ans = min(ans, dist[H-1][W-1][i]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint main() {\n\n  while( true ) {\n\n    long long int h, w;\n    cin >> w >> h;\n    if ( h == 0 ) break;\n\n    vector< vector< long long int > > v;\n\n    for ( long long int i = 0; i < h; i++ ) {\n\n      vector< long long int > vv;\n\n      for ( long long int j = 0; j < w; j++ ) {\n\n\tlong long int in;\n\tcin >> in;\n\tvv.push_back( in );\n\n      }\n\n      v.push_back( vv );\n\n    }\n\n    long long int c[4];\n    for ( long long int i = 0; i < 4; i++ ) {\n      cin >> c[i];\n    }\n\n    priority_queue< pair< long long int, pair< pair< long long int, long long int >, long long int > > > q;\n\n    long long int dp[31][31][4] = {};\n    for ( long long int i = 0; i < w; i++ ) {\n      for ( long long int j = 0; j < h; j++ ) {\n\tfor ( long long int k = 0; k < 4; k++ ) {\n\t  dp[j][i][k] = 1000000000000000;\n\t}\n      }\n    }\n\n    q.push( make_pair( 0, make_pair( make_pair( 0, 0 ), 1 ) ) );\n\n    while( true ) {\n\n      long long int p = q.top().first;\n      long long int y = q.top().second.first.first;\n      long long int x = q.top().second.first.second;\n      long long int d = q.top().second.second;\n\n      q.pop();\n\n      if ( dp[y][x][d] <= p ) continue;\n      dp[y][x][d] = p;\n\n      if ( y == h - 1 && x == w - 1 ) {\n\tcout << -p << endl;\n\tbreak;\n      }\n\n      long long int dx[4] = {  0,  1,  0, -1 };\n      long long int dy[4] = { -1,  0,  1,  0 };\n      long long int k = v[y][x];\n      long long int dd = ( d + k ) % 4;\n      long long int mx = x + dx[dd];\n      long long int my = y + dy[dd];\n      if ( 0 <= mx && mx < w && 0 <= my && my < h && k != 4 ) {\n\tq.push( make_pair( p, make_pair( make_pair( my, mx ), dd ) ) );\n      }\n      for ( long long int i = 0; i < 4; i++ ) {\n\tdd = ( d + i ) % 4;\n\tmx = x + dx[dd];\n\tmy = y + dy[dd];\n\tif ( 0 <= mx && mx < w && 0 <= my && my < h ) {\n\t  q.push( make_pair( p - c[i], make_pair( make_pair( my, mx ), dd ) ) );\n\t}\n      }\n\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef pair<int,T> State;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint w,h;\nint s[33][33];\nint c[10];\nint dist[33][33][5];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\npriority_queue<State,vector<State>,greater<State> > q;\nint solve(){\n\tscanf(\"%d %d\",&w,&h);\n\tif(w+h==0)return 1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&s[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)scanf(\"%d\",&c[i]);\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\tdist[i][j][d]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdist[0][0][0]=0;\n\tq.push(State(0,T(P(0,0),0)));\n\twhile(!q.empty()){\n\t\tState a = q.top();\n\t\tq.pop();\n\t\tint x,y,dir,v;\n\t\tx = a.sec.fi.fi;\n\t\ty = a.sec.fi.sec;\n\t\tdir = a.sec.sec;\n\t\tv = a.fi;\n\t\tif(dist[x][y][dir]<v)continue;\n\t\tfor(int d=0;d<4;d++){\n\t\t\tint nx,ny,nd,cost;\n\t\t\tnd = (dir+d)%4;\n\t\t\tcost = c[d];\n\t\t\tif(s[x][y]==d)cost=0;\n\t\t\tnx = x+dx[nd];\n\t\t\tny = y+dy[nd];\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)continue;\n\t\t\tif(dist[nx][ny][nd]>v+cost){\n\t\t\t\tdist[nx][ny][nd]=v+cost;\n\t\t\t\tq.push(State(v+cost,T(P(nx,ny),nd)));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int d=0;d<4;d++)ans = min(ans,dist[h-1][w-1][d]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstlib>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pip;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint w, h;\nint area[31][31];\nint min_cost[31][31][4];\nint c[4];\n\nvoid bfs(){\n\tqueue<pip> qp;\n\tqp.push(make_pair(0, make_pair(1, 1)));\n\twhile(!qp.empty()){\n\t\tpip p = qp.front(); qp.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint d = p.first;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint y2 = y+dy[(d+i)%4];\n\t\t\tint x2 = x+dx[(d+i)%4];\n\t\t\tif(y2 < 1 || y2 > h || x2 < 1 || x2 > w) continue;\n\t\t\tint cost = 0;\n\t\t\tint d2 = (d+i)%4;\n\t\t\tif(area[y][x] != i) cost = c[i];\n\t\t\tif(min_cost[y2][x2][d2] < 0 || min_cost[y][x][d] + cost < min_cost[y2][x2][d2]){\n\t\t\t\tmin_cost[y2][x2][d2] = min_cost[y][x][d] + cost;\n\t\t\t\tqp.push(make_pair(d2, make_pair(y2, x2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(min_cost, -1, sizeof(min_cost));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tmin_cost[1][1][0] = 0;\n\t\tbfs();\n\t\tint cost = 10000;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(min_cost[h][w][i] > 0) cost = min(cost, min_cost[h][w][i]);\n\t\t}\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pip;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint w, h;\nint area[31][31];\nint min_cost[31][31][4];\nint c[4];\n\nvoid bfs(){\n\tqueue<pip> qp;\n\tqp.push(make_pair(0, make_pair(1, 1)));\n\twhile(!qp.empty()){\n\t\tpip p = qp.front(); qp.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint d = p.first;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint y2 = y+dy[(d+i)%4];\n\t\t\tint x2 = x+dx[(d+i)%4];\n\t\t\tif(y2 < 1 || y2 > h || x2 < 1 || x2 > w) continue;\n\t\t\tint cost = 0;\n\t\t\tint d2 = (d+i)%4;\n\t\t\tif(area[y][x] != i) cost = c[i];\n\t\t\tif(min_cost[y2][x2][d2] < 0 || min_cost[y][x][d] + cost < min_cost[y2][x2][d2]){\n\t\t\t\tmin_cost[y2][x2][d2] = min_cost[y][x][d] + cost;\n\t\t\t\tqp.push(make_pair(d2, make_pair(y2, x2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(min_cost, -1, sizeof(min_cost));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tmin_cost[1][1][0] = 0;\n\t\tbfs();\n\t\tint cost = 10000;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(min_cost[h][w][i] > 0) cost = min(cost, min_cost[h][w][i]);\n\t\t}\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,-1,0,1 };\n\nstruct state { int dist,dir,x,y; };\nbool operator>(state const& a, state const& b) {\n    return a.dist > b.dist;\n}\n\nint32_t main() {\n    while (true) {\n        int w,h; cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        auto s = make_v<int,2>(h,w); cin >> s;\n        vector<int> c(4); cin >> c;\n        auto valid = [&](int i, int j) {\n            return (0 <= i && i < h &&\n                    0 <= j && j < w);\n        };\n\n        auto dist = make_v<int,3>(4,h,w,INF);\n        dist[3][0][0] = 0;\n        pque_min<state> pq;\n        pq.push({0,3,0,0});\n        auto push = [&](int ndist, int ndir, int nx, int ny) {\n            if (chmin(dist[ndir][nx][ny], ndist)) {\n                pq.push({ndist,ndir,nx,ny});\n            }\n        };\n        while (pq.size()) {\n            auto a = pq.top(); pq.pop();\n            if (dist[a.dir][a.x][a.y] < a.dist) continue;\n\n            if (s[a.x][a.y] < 4) {\n                int ndir = (a.dir+s[a.x][a.y])%4;\n                int nx = a.x+dx[ndir], ny = a.y+dy[ndir];\n                if (valid(nx,ny)) push(a.dist,ndir,nx,ny);\n            }\n            rep (com,4) {\n                int ndir = (a.dir+com)%4;\n                int nx = a.x+dx[ndir], ny = a.y+dy[ndir];\n                if (valid(nx,ny)) push(a.dist + c[com],ndir,nx,ny);\n            }\n        }\n        debug {\n            rep (dir,4) {\n                dump(dir,as_mat(dist[dir]));\n            }\n        }\n\n        int mi = INF;\n        rep (dir,4) chmin(mi,dist[dir][h-1][w-1]);\n        cout << mi << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<map>\n#define INF 1000000000\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nint w,h;\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nbool inf(int y,int x){\n\tif(x>=0&&x<w&&y>=0&&y<h)\n\t\treturn true;\n\treturn false;\n}\nint dij(vector<vector<int> > f, vector<int> op){\n\tpriority_queue<PPP,vector<PPP> , greater<PPP> > que;\n\tint d[40][40][5];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++)\n\td[i][j][k]=INF;\n\tque.push(PPP(0,PP(1,P(0,0))));\n\td[0][0][1]=0;\n\twhile(!que.empty()){\n\t\tPPP p=que.top();\n\t\tint dit=p.second.first;\n\t\tP now=p.second.second;\n\t\tint nc=p.first;\n\t\tque.pop();\n\t\tif(d[now.first][now.second][dit]<nc){\n\t\t\tcontinue;\n\t\t}\n\t\tif(now.first==h-1&&now.second==w-1){\n\t\t\treturn nc;\n\t\t}\n\t\td[now.first][now.second][dit]=nc;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=dx[(i+dit)%4]+now.second,ny=dy[(i+dit)%4]+now.first;\n\t\t\tif(!inf(ny,nx))\n\t\t\t\tcontinue;\n\t\t\tif(f[now.first][now.second]==i&&nc<d[ny][nx][(i+dit)%4]){\n\t\t\t\tque.push(PPP(nc,PP((i+dit)%4,P(ny,nx))));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nc+op[i]<d[ny][nx][(i+dit)%4]){\n\t\t\t\tque.push(PPP(nc+op[i],PP((i+dit)%4,P(ny,nx))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t//return d[h-1][w-1][(i+dit)%4];\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tvector<vector<int> > f(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>f[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<int> op(4);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tcin>>op[i];\n\t\tcout<<dij(f,op)<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 31;\n\nstruct edge{\n    int to;\n    int cost;\n};\n\nint a[MAX_N][MAX_N];\nvector<edge> G[4*MAX_N*MAX_N];\nint c[5];\nint w,h;\nint d[4*MAX_N*MAX_N];\n\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w == 0 && h == 0){\n            break;\n        }\n        rep(i,4*w*h){\n            G[i].clear();\n            d[i] = INF;\n        }\n    \trep(i,h){\n    \t\trep(j,w){\n                scanf(\"%d\",&a[i][j]);\n            }\n    \t}\n        rep(i,4){\n            scanf(\"%d\",&c[i]);\n        }\n        rep(i,h){\n            rep(j,w){\n                if(a[i][j] == 0 || a[i][j] == 4){\n                    if(a[i][j] == 4){\n                        if(i < h-1){\n                            G[4*(w*i + j)].push_back((edge){4*(w*(i+1) + j),c[0]});\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*(i+1) + j),c[1]});\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*(i+1) + j),c[2]});\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*(i+1) + j),c[3]});\n                        }\n                        if(j < w-1){\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*i + j+1)+1,c[0]});\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*i + j+1)+1,c[1]});\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*i + j+1)+1,c[2]});\n                            G[4*(w*i + j)].push_back((edge){4*(w*i + j+1)+1,c[3]});\n                        }\n                        if(0 < j){\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*i + j-1)+2,c[0]});\n                            G[4*(w*i + j)].push_back((edge){4*(w*i + j-1)+2,c[1]});\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*i + j-1)+2,c[2]});\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*i + j-1)+2,c[3]});\n                        }\n                        if(0 < i){\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*(i-1) + j)+3,c[0]});\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*(i-1) + j)+3,c[1]});\n                            G[4*(w*i + j)].push_back((edge){4*(w*(i-1) + j)+3,c[2]});\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*(i-1) + j)+3,c[3]});\n                        }\n                    }else{\n                        if(i < h-1){\n                            G[4*(w*i + j)].push_back((edge){4*(w*(i+1) + j),0});\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*(i+1) + j),c[1]});\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*(i+1) + j),c[2]});\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*(i+1) + j),c[3]});\n                        }\n                        if(j < w-1){\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*i + j+1)+1,0});\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*i + j+1)+1,c[1]});\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*i + j+1)+1,c[2]});\n                            G[4*(w*i + j)].push_back((edge){4*(w*i + j+1)+1,c[3]});\n                        }\n                        if(0 < j){\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*i + j-1)+2,0});\n                            G[4*(w*i + j)].push_back((edge){4*(w*i + j-1)+2,c[1]});\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*i + j-1)+2,c[2]});\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*i + j-1)+2,c[3]});\n                        }\n                        if(0 < i){\n                            G[4*(w*i + j)+3].push_back((edge){4*(w*(i-1) + j)+3,0});\n                            G[4*(w*i + j)+2].push_back((edge){4*(w*(i-1) + j)+3,c[1]});\n                            G[4*(w*i + j)].push_back((edge){4*(w*(i-1) + j)+3,c[2]});\n                            G[4*(w*i + j)+1].push_back((edge){4*(w*(i-1) + j)+3,c[3]});\n                        }\n                    }\n                }else if(a[i][j] == 1){\n                    if(0 < j){\n                        G[4*(w*i + j)].push_back((edge){4*(w*i + j-1)+2,0});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*i + j-1)+2,c[0]});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*i + j-1)+2,c[2]});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*i + j-1)+2,c[3]});\n                    }\n                    if(i < h-1){\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*(i+1) + j),0});\n                        G[4*(w*i + j)].push_back((edge){4*(w*(i+1) + j),c[0]});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*(i+1) + j),c[2]});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*(i+1) + j),c[3]});\n                    }\n                    if(0 < i){\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*(i-1) + j)+3,0});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*(i-1) + j)+3,c[0]});\n                        G[4*(w*i + j)].push_back((edge){4*(w*(i-1) + j)+3,c[2]});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*(i-1) + j)+3,c[3]});\n                    }\n                    if(j < w-1){\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*i + j+1)+1,0});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*i + j+1)+1,c[0]});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*i + j+1)+1,c[2]});\n                        G[4*(w*i + j)].push_back((edge){4*(w*i + j+1)+1,c[3]});\n                    }\n                }else if(a[i][j] == 2){\n                    if(0 < i){\n                        G[4*(w*i + j)].push_back((edge){4*(w*(i-1) + j)+3,0});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*(i-1) + j)+3,c[0]});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*(i-1) + j)+3,c[1]});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*(i-1) + j)+3,c[3]});\n                    }\n                    if(0 < j){\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*i + j-1)+2,0});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*i + j-1)+2,c[0]});\n                        G[4*(w*i + j)].push_back((edge){4*(w*i + j-1)+2,c[1]});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*i + j-1)+2,c[3]});\n                    }\n                    if(j < w-1){\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*i + j+1)+1,0});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*i + j+1)+1,c[0]});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*i + j+1)+1,c[1]});\n                        G[4*(w*i + j)].push_back((edge){4*(w*i + j+1)+1,c[3]});\n                    }\n                    if(i < h-1){\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*(i+1) + j),0});\n                        G[4*(w*i + j)].push_back((edge){4*(w*(i+1) + j),c[0]});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*(i+1) + j),c[1]});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*(i+1) + j),c[3]});\n                    }\n                }else if(a[i][j] == 3){\n                    if(j < w-1){\n                        G[4*(w*i + j)].push_back((edge){4*(w*i + j+1)+1,0});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*i + j+1)+1,c[0]});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*i + j+1)+1,c[1]});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*i + j+1)+1,c[2]});\n                    }\n                    if(0 < i){\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*(i-1) + j)+3,0});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*(i-1) + j)+3,c[0]});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*(i-1) + j)+3,c[1]});\n                        G[4*(w*i + j)].push_back((edge){4*(w*(i-1) + j)+3,c[2]});\n                    }\n                    if(i < h-1){\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*(i+1) + j),0});\n                        G[4*(w*i + j)].push_back((edge){4*(w*(i+1) + j),c[0]});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*(i+1) + j),c[1]});\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*(i+1) + j),c[2]});\n                    }\n                    if(0 < j){\n                        G[4*(w*i + j)+3].push_back((edge){4*(w*i + j-1)+2,0});\n                        G[4*(w*i + j)+2].push_back((edge){4*(w*i + j-1)+2,c[0]});\n                        G[4*(w*i + j)].push_back((edge){4*(w*i + j-1)+2,c[1]});\n                        G[4*(w*i + j)+1].push_back((edge){4*(w*i + j-1)+2,c[2]});\n                    }\n                }\n            }\n        }\n        int res = INF;\n        dijkstra(1);\n        rep(i,4){\n            res = min(res,d[4*(w*(h-1) + w-1)+i]);\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct State {\n\tint x, y, dir, cost, cnt;\n\tState (int _x, int _y, int _d, int _c, int _cn) : x(_x), y(_y), dir(_d), cost(_c), cnt(_cn) {}\n};\n// dir 0:テ・ツ渉ウ 1:テ、ツクツ?2:テ・ツキツヲ 3:テ、ツクツ?\nbool operator > (const State& s1, const State& s2) {\n\tif (s1.cost > s2.cost) return true;\n\treturn false;\n}\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nint w, h;\nint map[50][50];\n\nint c[4];\nint cost[50][50][100][4];\nint INF = 1000;\n\nvoid solve() {\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int k = 0; k < 100; k++) {\n\t\t\t\tfill(cost[i][j][k], cost[i][j][k] + 4, INF);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpriority_queue<State, vector<State>, greater<State> > que;\n\tque.push(State(0, 0, 0, 0, 0));\n\tcost[0][0][0][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tint x = s.x, y = s.y;\n\t\tint d = s.dir;\n\t\tint cnt = s.cnt;\n\t\t\n\t\tif (cnt > 80) continue;\n\t\t\n\t\tint nd, nx, ny;\n\t\t\n\t\tif (map[y][x] != 4) {\t\t\n\t\t\tnd = (d + map[y][x]) % 4;\t\t\n\t\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\t\n\t\t\tif (0<=nx && nx<w && 0<=ny && ny<h) {\n\t\t\t\tif (cost[ny][nx][cnt][nd] > s.cost) {\n\t\t\t\t\tcost[ny][nx][cnt][nd] = s.cost;\n\t\t\t\t\tque.push(State(nx, ny, nd, s.cost, cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tnd = (d + i) % 4;\n\t\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\t\t\n\t\t\tif (0<=nx && nx<w && 0<=ny && ny<h) {\n\t\t\t\tif (cost[ny][nx][cnt + 1][nd] > s.cost + c[i]) {\n\t\t\t\t\tcost[ny][nx][cnt + 1][nd] = s.cost + c[i];\n\t\t\t\t\tque.push(State(nx, ny, nd, s.cost + c[i], cnt + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (int i = 0; i < 100; i++) {\n\t\tfor (int d = 0; d < 4; d++) {\n\t\t\tans = min(ans, cost[h - 1][w - 1][i][d]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> w >> h; if (w==0 && h==0) break;\n\t\t\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 4; i++) cin >> c[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n \nint G[SIZE][SIZE], C[4];\nint H, W;\n \nstruct State {\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost>s.cost;\n  }\n};\n \nint dijkstra() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State> pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n     && 0 <= t.y && t.y < H \n     && cost[t.d][t.y][t.x] > t.cost) {\n    pq.push(t);\n    cost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n   \n  return INF;\n}\n \nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n    cin >> G[i][j];\n    for(int i=0; i<4; i++) cin >> C[i];\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint dh[] = { 0,1,0,-1 };\nint dw[] = { 1,0,-1,0 };\nint cnv(int cur, int state) {\n    if (state == 0) return cur;\n    if (state == 1) return (cur + 1) % 4;\n    if (state == 2) return (cur + 2) % 4;\n    if (state == 3) return ((cur - 1) % 4 + 4) % 4;\n    if (state == 4) return 4;\n}\n\nint cost_idx(int cur, int next) {\n    if (cur == next) return 0;\n    else if ((cur + 1) % 4 == next) return 1;\n    else if ((cur + 2) % 4 == next) return 2;\n    else return 3;\n}\nvoid solve() {\n    int W, H; scanf(\"%d %d\", &W, &H); if (W == 0 and H == 0) exit(0);\n    vector<vector<int>> a(H, vector<int>(W));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]);\n    int cost[4]; for (int i = 0; i < 4; i++) scanf(\"%d\", &cost[i]);\n    //現在の状態:: 0→右，1→下，2→左，3→上，4→停止\n    using T = tuple<int, int, int, int>;\n    priority_queue<T, vector<T>, greater<T>> pq;\n    vector<vector<vector<int>>> d(H, vector<vector<int>>(W, vector<int>(4, inf)));\n    d[0][0][0] = 0;\n    pq.emplace(0, 0, 0, 0);\n    while (!pq.empty()) {\n        int c, h, w, cur; tie(c, h, w, cur) = pq.top();\n        pq.pop();\n        if (d[h][w][cur] < c) continue;\n        int next = cnv(cur, a[h][w]);\n        for (int i = 0; i < 4; i++) {\n            int nh = h + dh[i];\n            int nw = w + dw[i];\n            if (nh < 0 or nh >= H or nw < 0 or nw >= W) continue;\n            if (next == i) {\n                if(chmin(d[nh][nw][i], d[h][w][cur])) pq.emplace(d[nh][nw][i], nh, nw, i);\n            }\n            else {\n                if(chmin(d[nh][nw][i], d[h][w][cur] + cost[cost_idx(cur, i)])) pq.emplace(d[nh][nw][i], nh, nw, i);\n            }\n        }\n    }\n    int res = inf; for (int i = 0; i < 4; i++) chmin(res, d[H - 1][W - 1][i]);\n    printf(\"%d\\n\", res);\n}\n\nint main()\n{\n    /*\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    */\n\n    int kkt = 89;\n    while (kkt) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost>right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4];\n      int ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(d[ny][nx][ndir]>cost+c[i]){\n\td[ny][nx][ndir]=cost+c[i];\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n      if(data[y][x]!=i) continue;\n      if(d[ny][nx][ndir]>cost){\n\td[ny][nx][ndir]=cost;\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n    }\n  }\n  int mincost=INF;\n  for(int i=0;i<4;i++)\n    mincost=min(mincost,d[h-1][w-1][i]);\n  cout<<mincost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\nusing namespace std;\n#define MAXH 31\n#define MAXW MAXH\n#define MAXC 4\n#define INF (1<<20)\ntypedef enum {STRA=0,RIGHT=1,BACK=2,LEFT=3,STOP=4} TYPE;\nint W,H;\nint F[MAXH][MAXW];\nint cost[MAXC+1]; // cost[STOP]=0;\nint D[MAXH][MAXW][4];\nbool visited[MAXH][MAXW][4];\n\nclass State {\npublic:\n  int i,j,d,c; // i,j,direction,cost\n  State (int i, int j, int d, int c) : i(i),j(j),d(d),c(c) {}\n  bool operator < (const State &s) const {\n    return c > s.c;\n  }\n};\n\nbool ok(int i, int j) {\n  return 1 <= i && i <= H && 1 <= j && j <= W;\n}\n\nint solve() {\n  priority_queue<State> PQ;\n  for(int i=1;i<=H;i++) {\n    for(int j=1;j<=W;j++) {\n      for(int k=0;k<MAXC;k++) {\n\tD[i][j][k]=INF;\n      }\n    }\n  }\n  memset(visited,0,sizeof(visited));\n  PQ.push(State(1,1,RIGHT,0));\n  D[1][1][RIGHT]=0;\n  // x=>l, y=>k\n  int di[][4]={ {-1, 0, 1, 0},\n\t\t{ 0, 1, 0,-1},\n\t\t{ 1, 0,-1, 0},\n\t\t{ 0,-1, 0, 1}};\n  int dj[][4]={ { 0, 1, 0,-1},\n\t\t{ 1, 0,-1, 0},\n\t\t{ 0,-1, 0, 1},\n\t\t{-1, 0, 1, 0}};\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int i = u.i, j=u.j, d=u.d, c=u.c;\n    if(i==H&&j==W) {\n      return D[i][j][d];\n    }\n    visited[i][j][d]=true;\n    \n    for(int k=0;k<4;k++) {\n      int ui = i + di[d][k];\n      int uj = j + dj[d][k];\n      if(!ok(ui,uj)) continue;\n      if(k == F[i][j]) { // no cost\n\tint _cost = D[i][j][d] + 0;\n\tif(_cost < D[ui][uj][(d+k)%4]) {\n\t  D[ui][uj][(d+k)%4] = _cost;\n\t  PQ.push(State(ui,uj,(d+k)%4,_cost));\n\t}\n      } else { // have to pay cost\n\tint _cost = D[i][j][d] + cost[k];\n\tif(_cost < D[ui][uj][(d+k)%4]) {\n\t  D[ui][uj][(d+k)%4] = _cost;\n\t  PQ.push(State(ui,uj,(d+k)%4,_cost));\n\t}\n      }\n    } // for4\n    \n  }\n}\n\nmain() {\n  while(cin>>W>>H,W) {\n    for(int i=1;i<=H;i++) {\n      for(int j=1;j<=W;j++) {\n\tcin>>F[i][j];\n      }\n    }\n    for(int i=0;i<MAXC;i++) \n      cin>>cost[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint graph[50][50][4]; // x, y, d\nint map[50][50]; // x, y\nint c[4];\ntypedef struct{int x,y;} pos;\ntypedef struct{pos p; int d;} vec;\ntypedef struct{vec vs,vd; int c;} edge;\n\n#define _N 0\n#define _E 1\n#define _W 2\n#define _S 3\n\nint main(void) {\n    while(true) {\n        int w,h;\n        scanf(\"%d%d\",&w,&h);\n        if(!w) break;\n\n        vector<edge> edges;\n\n        for(int i=0; i<h; i++)\n            for(int j=0; j<w; j++)\n                scanf(\"%d\", &map[j][i]);\n        for(int i=0; i<4; i++)\n            scanf(\"%d\", &c[i]);\n\n        for(int i=0; i<w; i++)\n            for(int j=0; j<h; j++) {\n                switch(map[i][j]) { // add edges whose cost is zero\n                    case 0: // straight\n                        if(j-1>=0) edges.push_back({{{i,j},_N}, {{i,j-1},_N}, 0});\n                        if(i+1<w)  edges.push_back({{{i,j},_E}, {{i+1,j},_E}, 0});\n                        if(i-1>=0) edges.push_back({{{i,j},_W}, {{i-1,j},_W}, 0});\n                        if(j+1<h)  edges.push_back({{{i,j},_S}, {{i,j+1},_S}, 0});\n                        break;\n                    case 1: // right\n                        if(i+1<w)  edges.push_back({{{i,j},_N}, {{i+1,j},_E}, 0});\n                        if(j+1<h)  edges.push_back({{{i,j},_E}, {{i,j+1},_S}, 0});\n                        if(j-1>=0) edges.push_back({{{i,j},_W}, {{i,j-1},_N}, 0});\n                        if(i-1>=0) edges.push_back({{{i,j},_S}, {{i-1,j},_W}, 0});\n                        break;\n                    case 2: // reverse\n                        if(j+1<h)  edges.push_back({{{i,j},_N}, {{i,j+1},_S}, 0});\n                        if(i-1>=0) edges.push_back({{{i,j},_E}, {{i-1,j},_W}, 0});\n                        if(i+1<w)  edges.push_back({{{i,j},_W}, {{i+1,j},_E}, 0});\n                        if(j-1>=0) edges.push_back({{{i,j},_S}, {{i,j-1},_N}, 0});\n                        break;\n                    case 3: // left\n                        if(i-1>=0) edges.push_back({{{i,j},_N}, {{i-1,j},_W}, 0});\n                        if(j-1>=0) edges.push_back({{{i,j},_E}, {{i,j-1},_N}, 0});\n                        if(j+1<h)  edges.push_back({{{i,j},_W}, {{i,j+1},_S}, 0});\n                        if(i+1<w)  edges.push_back({{{i,j},_S}, {{i+1,j},_E}, 0});\n                        break;\n                    case 4: // halt\n                        break;\n                }\n\n                // add edges when player orders\n                if(j-1>=0) edges.push_back({{{i,j},_N}, {{i,j-1},_N}, c[0]});\n                if(i+1<w)  edges.push_back({{{i,j},_E}, {{i+1,j},_E}, c[0]});\n                if(i-1>=0) edges.push_back({{{i,j},_W}, {{i-1,j},_W}, c[0]});\n                if(j+1<h)  edges.push_back({{{i,j},_S}, {{i,j+1},_S}, c[0]});\n\n                if(i+1<w)  edges.push_back({{{i,j},_N}, {{i+1,j},_E}, c[1]});\n                if(j+1<h)  edges.push_back({{{i,j},_E}, {{i,j+1},_S}, c[1]});\n                if(j-1>=0) edges.push_back({{{i,j},_W}, {{i,j-1},_N}, c[1]});\n                if(i-1>=0) edges.push_back({{{i,j},_S}, {{i-1,j},_W}, c[1]});\n\n                if(j+1<h)  edges.push_back({{{i,j},_N}, {{i,j+1},_S}, c[2]});\n                if(i-1>=0) edges.push_back({{{i,j},_E}, {{i-1,j},_W}, c[2]});\n                if(i+1<w)  edges.push_back({{{i,j},_W}, {{i+1,j},_E}, c[2]});\n                if(j-1>=0) edges.push_back({{{i,j},_S}, {{i,j-1},_N}, c[2]});\n\n                if(i-1>=0) edges.push_back({{{i,j},_N}, {{i-1,j},_W}, c[3]});\n                if(j-1>=0) edges.push_back({{{i,j},_E}, {{i,j-1},_N}, c[3]});\n                if(j+1<h)  edges.push_back({{{i,j},_W}, {{i,j+1},_S}, c[3]});\n                if(i+1<w)  edges.push_back({{{i,j},_S}, {{i+1,j},_E}, c[3]});\n            }\n\n        for(int i=0; i<w; i++) // init graph\n            for(int j=0; j<h; j++)\n                for(int d=0; d<4; d++)\n                    graph[i][j][d] = 0xFFFFFF;\n\n        graph[0][0][_E] = 0; // init source\n\n//        printf(\":%d:\\n\", edges.size());\n        bool updated=true; // bellman-ford\n        for(int i=0; i<w*h*4 && updated; i++) {\n            updated = false;\n            for(vector<edge>::iterator it=edges.begin(); it!=edges.end(); it++) {\n                if(graph[it->vs.p.x][it->vs.p.y][it->vs.d] + it->c < graph[it->vd.p.x][it->vd.p.y][it->vd.d]) {\n                    graph[it->vd.p.x][it->vd.p.y][it->vd.d] = graph[it->vs.p.x][it->vs.p.y][it->vs.d] + it->c;\n                    updated = true;\n                }\n            }\n        }\n\n/*        for(int i=0; i<w; i++) { \n            for(int j=0; j<h; j++) {\n                printf(\"[\");\n                for(int d=0; d<4; d++) {\n                    printf(\"%d:\", graph[i][j][d]);\n                }\n                printf(\"] \");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n        */\n\n\n        int res=0xFFFFFF;\n        for(int d=0; d<4; d++)\n            res = min(graph[w-1][h-1][d], res);\n        printf(\"%d\\n\",res);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Node {\n  int x;\n  int y;\n  int dir;\n  int cost;\n  Node(int x, int y, int d, int c) : x(x), y(y), dir(d), cost(c) {;}\n  bool operator<(const Node &rhs) const { return cost > rhs.cost; }\n};\n\nint w, h;\nint field[40][40];\nint dirc[4];\nbool visit[4][40][40];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(visit, 0);\n    REP(y, h) REP(x, w) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(i, 4) {\n      scanf(\"%d\", &dirc[i]); \n    }\n    priority_queue<Node> que;\n    que.push(Node(0, 0, 0, 0));\n    while (!que.empty()) {\n      Node node = que.top();\n      que.pop();\n      if (visit[node.dir][node.y][node.x]) { continue; }\n      visit[node.dir][node.y][node.x] = true;\n      if (node.x == w - 1 && node.y == h - 1) {\n        printf(\"%d\\n\", node.cost);\n        break;\n      }\n      FOR(i, 0, 4) {\n        int nd = (node.dir + i) % 4;\n        int nc = node.cost;\n        if (field[node.y][node.x] != i) {\n          nc += dirc[i];\n        }\n        int nx = node.x + dx[nd];\n        int ny = node.y + dy[nd];\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h || visit[nd][ny][nx]) { continue; }\n        que.push(Node(nx, ny, nd, nc));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h;\nint c[4];\nint s[31][31];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nstruct S{\n    int y, x, st, dis;\n    bool operator>(const S &s) const{\n        return dis > s.dis;\n    }\n};\n\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nconst int INF = 1e9;\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        rep(i, 0, h) rep(j, 0, w) cin >> s[i][j];\n        rep(i, 0, 4) cin >> c[i];\n        int d[31][31][4];\n        rep(i, 0, h) rep(j, 0, w) rep(k, 0, 4) d[i][j][k] = INF;\n        queue<S> q;\n        q.push((S){0, 0, 1, 0});\n        d[0][0][1] = 0;\n        while(!q.empty()){\n            S p = q.front(); q.pop();\n            rep(i, 0, 4){\n                int dir = (p.st + i) % 4;\n                int ny = p.y + dy[dir];\n                int nx = p.x + dx[dir];\n                int ndis = p.dis;\n                if(!contain(ny, nx)) continue;\n                if(s[p.y][p.x] != i){\n                    ndis += c[i];\n                }\n                if(ndis < d[ny][nx][dir]){\n                    d[ny][nx][dir] = ndis;\n                    q.push((S){ny, nx, dir, ndis});\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, 4) ans = min(ans, d[h - 1][w - 1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef tuple<int, int, pair<int, int> > tup;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nint w, h;\nint s[32][32];\nint c[6];\n//dist[t][y][x] :=????????¨?????§?¨????(x, y)??§??\\????????????t????????????????????????\nint dist[32][32][6];\n\nvoid dijkstra(void){\n    rep(i, 32)rep(j, 32)rep(k, 6){\n    \tdist[i][j][k] = INF;\n    }\n\n    priority_queue<tup, vector<tup>, greater<tup> >  q;//????????????????????????????????\\?????? ?????¨?????§?¨?\n    if(s[0][0] == 0){\n        q.push(make_tuple(0, 1, make_pair(0, 1)));\n    }else if(s[0][0] == 1){\n        q.push(make_tuple(0, 2, make_pair(1, 0)));\n    }else if(s[0][0] == 2 || s[0][0] == 3 || s[0][0] == 4){\n        q.push(make_tuple(c[0], 1, make_pair(0, 1)));\n        q.push(make_tuple(c[1], 2, make_pair(1, 0)));\n    }\n\n    while(!q.empty()){\n        int cost, v;\n        pair<int, int> p;\n        tie(cost, v, p) = q.top(); q.pop();\n        int y = p.first, x = p.second;\n        if(dist[v][y][x] < cost) continue;\n        // printf(\"v %d y %d x %d\\n\", v, y, x);\n        for (int i = v, j = 0; i < v + 4; ++i, ++j){//??´?????????180????????????????????????\n            //?????????????????????????????????\n            int nextv = i % 4;\n            int ny = y + dy[nextv], nx = x + dx[nextv];\n            if(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n            if(j == s[y][x]){//????????????\n                if(cost < dist[nextv][ny][nx]){\n                    q.push(make_tuple(cost, nextv, make_pair(ny, nx)));\n                    dist[nextv][ny][nx] = cost;\n                    // printf(\"1 dist[%d][%d][%d] = %d\\n\", nextv, ny, nx, dist[nextv][ny][nx]);\n                }\n            }else{\n                if(cost + c[j] < dist[nextv][ny][nx]){\n                    q.push(make_tuple(cost + c[j], nextv, make_pair(ny, nx)));\n                    dist[nextv][ny][nx] = cost + c[j];\n                    // printf(\"2 dist[%d][%d][%d] = %d\\n\", nextv, ny, nx, dist[nextv][ny][nx]);\n                }\n            }\n        }\n    }\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n        rep(i, h)rep(j, w) cin >> s[i][j];\n        rep(i, 4){\n            cin >> c[i];\n        }\n\n\t\tdijkstra();\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tans = min(ans, dist[i][h - 1][w - 1]);\n\t\t}\n        printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\nint w,h;\nint s[35][35];\nint cost[4];\nint vx[4][4]={{1,0,-1,0},{0,1,0,-1},{-1,0,1,0},{0,-1,0,1}};\nint vy[4][4]={{0,1,0,-1},{-1,0,1,0},{0,-1,0,1},{1,0,-1,0}};\nint vv[4][4]={{0,3,2,1},{1,0,3,2},{2,1,0,3},{3,2,1,0}};\n\nstruct S{\n\tS(int ix,int iy,int iv,int ic){\n\t\tx=ix;y=iy;v=iv;c=ic;\n\t}\n\tint x,y,v,c;\n};\n\nbool operator<(S a,S b){\n\treturn a.c>b.c;\n}\n\n\nS next(S a,int o){\n\tint c;\n\t//cout<<(s[a.y][a.x]==o)<<endl;\n\tif(o!=s[a.y][a.x]){\n\t\tc=a.c+cost[o];\n\t}else{\n\t\tc=a.c;\n\t}\n\tint x=a.x+vx[a.v][o];\n\tint y=a.y+vy[a.v][o];\n\tint v=vv[a.v][o];\n\tif(x<0||y<0||x>=w||y>=h)c=-1;\n\treturn S(x,y,v,c);\n}\n\n\nint solve(){\n\tpriority_queue<S> q;\n\tint use[35][35][4];\n\tfor(int i=0;i<35;i++){\n\t\tfor(int j=0;j<35;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tuse[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(S(0,0,0,0));\n\twhile(!q.empty()){\n\t\tS now=q.top();q.pop();\n\t\t\n\t\tif(use[now.x][now.y][now.v])continue;\n\t\tuse[now.x][now.y][now.v]=true;\n\t\t\n\t\tif(now.x==w-1&&now.y==h-1){\n\t\t\treturn now.c;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tS npos= next(now,i);\n\t\t\tif(npos.c!=-1){\n\t\t\t\t//cout<<npos.x<<\" \"<<npos.y<<\" \"<<npos.c<<endl;\n\t\t\t\tq.push(npos);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\nbool input(){\n\tcin>>w>>h;\n\tif(!(w||h))return 0;\n\t\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tcin>>cost[i];\n\t}\n\treturn 1;\n}\n\n\n\nint main(){\n\twhile(input()){\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ndouble EPS=1e-10;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\ntypedef pair<pii,pii> ppii;\n\nint W,H;\nint field[101][101];\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\nint cc[101];\nint d[101][101][4];\nconst int INF=1000000000;\n\nint dijkstra(){\n\tfor(int i=0;i<101;i++)\n\t\tfor(int j=0;j<101;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\td[i][j][k]=INF;\n\tpriority_queue<ppii,vector<ppii>,greater<ppii> > pq;\n\tpq.push(make_pair(pii(0,1),pii(0,0)));\n\td[0][0][1]=0;\n\twhile(pq.size()){\n\t\tppii p=pq.top();pq.pop();\n\t\tint cy=p.second.first;\n\t\tint cx=p.second.second;\n\t\tint cang=p.first.second;\n\t\tint ccost=p.first.first;\n\t\tif(d[cy][cx][cang]<ccost)continue;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nadd=cc[i];\n\t\t\tif(i==field[cy][cx])nadd=0;\n\t\t\tif(i==0){\n\t\t\t\tint nang=cang;\n\t\t\t\tint ny=cy+dy[cang];\n\t\t\t\tint nx=cx+dx[cang];\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W){\n\t\t\t\t\tint ncost=d[cy][cx][cang]+nadd;\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&d[ny][nx][nang]>ncost){\n\t\t\t\t\t\td[ny][nx][nang]=ncost;\n\t\t\t\t\t\tpq.push(make_pair(pii(ncost,nang),pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i==1){\n\t\t\t\tint nang=(cang+1)%4;\n\t\t\t\tint ny=cy+dy[nang];\n\t\t\t\tint nx=cx+dx[nang];\n\t\t\t\tint ncost=d[cy][cx][cang]+nadd;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W){\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&d[ny][nx][nang]>ncost){\n\t\t\t\t\t\td[ny][nx][nang]=ncost;\n\t\t\t\t\t\tpq.push(make_pair(pii(ncost,nang),pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i==2){\n\t\t\t\tint nang=(cang+2)%4;\n\t\t\t\tint ny=cy+dy[nang];\n\t\t\t\tint nx=cx+dx[nang];\n\t\t\t\tint ncost=d[cy][cx][cang]+nadd;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W){\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&d[ny][nx][nang]>ncost){\n\t\t\t\t\t\td[ny][nx][nang]=ncost;\n\t\t\t\t\t\tpq.push(make_pair(pii(ncost,nang),pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i==3){\n\t\t\t\tint nang=(cang+3)%4;\n\t\t\t\tint ny=cy+dy[nang];\n\t\t\t\tint nx=cx+dx[nang];\n\t\t\t\tint ncost=d[cy][cx][cang]+nadd;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W){\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&d[ny][nx][nang]>ncost){\n\t\t\t\t\t\td[ny][nx][nang]=ncost;\n\t\t\t\t\t\tpq.push(make_pair(pii(ncost,nang),pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=0;i<4;i++)\n\t\tres=min(res,d[H-1][W-1][i]);\n\treturn res;\n}\n\nvoid solve(){\n\twhile(cin>>W>>H&&(W|H)){\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tcin>>field[i][j];\n\t\tfor(int i=0;i<4;i++)\n\t\t\tcin>>cc[i];\n\t\tcout<<dijkstra()<<endl;\n\t}\n}\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstruct node {\n    int cst;\n    int x, y;\n    int dir;\n    bool operator<(const node &o) const {\n        return cst > o.cst;\n    }\n};\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint w, h;\nint f[32][32];\nbool inrange(int x, int y) {\n    return x >= 0 and y >= 0 and x < w and y < h;\n}\nint main()\n{\n    while(cin >> w >> h, w||h) {\n        rep(i, h) rep(j, w) cin >> f[j][i];\n        vector<int> c(4);\n        rep(i, 4) cin >> c[i];\n\n        bool done[32][32][4] = {0};        \n        priority_queue<node> pq;\n        pq.push((node){0, 0, 0, 1});\n        while(pq.size()) {\n            int cst = pq.top().cst;\n            int x = pq.top().x;\n            int y = pq.top().y;\n            int dir = pq.top().dir; pq.pop();\n            if(done[x][y][dir]) continue;\n            done[x][y][dir] = true;\n\n            if(x == w-1 and y == h-1) {\n                cout << cst << endl;\n                break;\n            }\n            rep(i, 4) {\n                int df = c[i];\n                int ndir = (dir + i) % 4;\n                if(f[x][y] == i) df = 0;\n                int nx = x + dx[ndir];\n                int ny = y + dy[ndir];\n                if(inrange(nx, ny))\n                    pq.push((node){cst+df, nx, ny, ndir});\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n// container util\n#define all(x) (x).begin(), (x).end()\n\n// debug\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x)                                         \\\n  cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" \\\n       << \" \" << __FILE__ << endl;\n\n// typedef\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef complex<long double> Complex;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n// constant\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\n// conversion\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\n\n//\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n//\n\nint w, h;\nint s[33][33], c[6], dp[33][33][5];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  while (cin >> w >> h && h != 0) {\n    rep(y, h) rep(x, w) cin >> s[y][x];\n    rep(i, 4) cin >> c[i];\n\n    rep(y, h) rep(x, w) rep(k, 4) dp[y][x][k] = INF;\n    dp[0][0][1] = 0;\n    queue<TP> que;\n    que.push(make_tuple(0, 0, 1));\n\n    while (!que.empty()) {\n      int x, y, dir;\n      tie(x, y, dir) = que.front();\n      que.pop();\n\n      if (x == w - 1 && y == h - 1) continue;\n      rep(i, 4) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\n        if (s[y][x] == 0) {  //もし床が直進で\n          if (dir == i) {  //向いている向きと同じ方向に進みたいなら\n            if (dp[ny][nx][i] <= dp[y][x][dir]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir]);\n            que.push(make_tuple(nx, ny, i));\n          } else {\n            if (dir == (1 + i) % 4) {  //右折\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[1]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[1]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (2 + i) % 4) {  //反転\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[2]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[2]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (3 + i) % 4) {  //左折\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[3]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[3]);\n              que.push(make_tuple(nx, ny, i));\n            }\n          }\n        } else if (s[y][x] == 1) {   //もし床が右折で\n          if (dir == (1 + i) % 4) {  //同じ方向に進みたいなら\n            if (dp[ny][nx][i] <= dp[y][x][dir]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir]);\n            que.push(make_tuple(nx, ny, i));\n          } else {\n            if (dir == i) {  //直進\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[0]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[0]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (2 + i) % 4) {  //反転\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[2]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[2]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (3 + i) % 4) {  //左折\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[3]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[3]);\n              que.push(make_tuple(nx, ny, i));\n            }\n          }\n\n        } else if (s[y][x] == 2) {   //反転\n          if (dir == (2 + i) % 4) {  //同じ方向に進みたいなら\n            if (dp[ny][nx][i] <= dp[y][x][dir]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir]);\n            que.push(make_tuple(nx, ny, i));\n          } else {\n            if (dir == i) {  //直進\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[0]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[0]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (1 + i) % 4) {  //右折\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[1]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[1]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (3 + i) % 4) {  //左折\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[3]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[3]);\n              que.push(make_tuple(nx, ny, i));\n            }\n          }\n\n        } else if (s[y][x] == 3) {   //左折\n          if (dir == (3 + i) % 4) {  //同じ方向に進みたいなら\n            if (dp[ny][nx][i] <= dp[y][x][dir]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir]);\n            que.push(make_tuple(nx, ny, i));\n          } else {\n            if (dir == i) {  //直進\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[0]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[0]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (1 + i) % 4) {  //右折\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[1]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[1]);\n              que.push(make_tuple(nx, ny, i));\n            } else if (dir == (2 + i) % 4) {  //反転\n              if (dp[ny][nx][i] <= dp[y][x][dir] + c[2]) continue;\n              chmin(dp[ny][nx][i], dp[y][x][dir] + c[2]);\n              que.push(make_tuple(nx, ny, i));\n            }\n          }\n        } else if (s[y][x] == 4) {\n          if (dir == i) {  //直進\n            if (dp[ny][nx][i] <= dp[y][x][dir] + c[0]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir] + c[0]);\n            que.push(make_tuple(nx, ny, i));\n          } else if (dir == (1 + i) % 4) {  //右折\n            if (dp[ny][nx][i] <= dp[y][x][dir] + c[1]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir] + c[1]);\n            que.push(make_tuple(nx, ny, i));\n          } else if (dir == (2 + i) % 4) {  //反転\n            if (dp[ny][nx][i] <= dp[y][x][dir] + c[2]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir] + c[2]);\n            que.push(make_tuple(nx, ny, i));\n          } else if (dir == (3 + i) % 4) {  //左折\n            if (dp[ny][nx][i] <= dp[y][x][dir] + c[3]) continue;\n            chmin(dp[ny][nx][i], dp[y][x][dir] + c[3]);\n            que.push(make_tuple(nx, ny, i));\n          }\n        }\n\n      }  // rep\n    }\n\n    int ans = INF;\n    rep(i, 4) ans = min(ans, dp[h - 1][w - 1][i]);\n    cout << ans << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint w,h;\nint in[40][40];\nbool vis[40][40][4];\n\nvoid solve(){\n  rep(i,h)rep(j,w) cin >> in[i][j];\n  int c[4];\n  rep(i,4) cin >> c[i];\n\n  priority_queue<pair<PI,PI> > q;\n  q.push(mp(mp(0,0),mp(0,0)));\n  CLR(vis);\n  \n  while(!q.empty()){\n    int cc=-q.top().F.F;\n    int cd=q.top().F.S;\n    int cx=q.top().S.F;\n    int cy=q.top().S.S;    \n    q.pop();\n    if(cx==h-1 && cy==w-1){\n      cout << cc << endl;\n      return;\n    }\n    if(vis[cx][cy][cd]) continue;\n    vis[cx][cy][cd]=true;\n    rep(i,4){\n      int nd=(cd+i)&3;\n      int nx=cx+dx[nd];\n      int ny=cy+dy[nd];\n      if(min(nx,ny)<0 || nx>=h || ny>=w) continue;\n      int nc=cc;\n      if(i!=in[cx][cy]) nc += c[i];\n      q.push(mp(mp(-nc,nd),mp(nx,ny)));\n    }\n  }\n}\n\nint main(){\n  while(cin >> w >> h && w && h) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct Point{int x,y,a,d;};\nint w,h;\nbool in(Point a){\n  if(a.x<0||a.x>=w||a.y<0||a.y>=h) return false;\n  return true;\n}\nint main(){\n  cin >> w >> h;\n  while(w!=0){\n    int i,j,k;\n    int st[30][30]={{}};\n    int wfs[31][31][4]={{{}}};\n    int c[4]={};\n    int inf = 1 << 30;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin >> st[j][i];  \n      }\n    }\n    fill(wfs[0][0],wfs[30][30],inf);\n    //memset(wfs,inf,sizeof(wfs));\n    for(i=0;i<4;i++)\n      cin >> c[i];\n    \n    queue<Point> q;\n    Point p,b;\n    p.x=0;p.y=0;p.a=0;p.d=0;\n    \n    q.push(p);\n    int ax[]={1,0,-1,0},ay[]={0,1,0,-1};\n    while(!q.empty()){\n      p=q.front();q.pop();\n      \n      if(wfs[p.x][p.y][p.a]>p.d) wfs[p.x][p.y][p.a]=p.d;\n      else continue;\n      //cout << p.x << \":\" << p.y << \":\" << p.d << endl;\n      if(st[p.x][p.y]==4) {\n\tfor(i=0;i<4;i++){\n\t  b.x=p.x+ax[i];b.y=p.y+ay[i];b.a=i;b.d=p.d+c[(4-p.a+i)%4];\n\t  if(in(b)) q.push(b);\n\t}\n      }else{\n\tfor(i=0;i<4;i++){\n\t  b.x=p.x+ax[i];b.y=p.y+ay[i];b.a=i;b.d=p.d;\n\t  if((p.a+st[p.x][p.y])%4!=i) b.d+=c[(4-p.a+i)%4];\n\t  if(in(b)) q.push(b);\n\t}\n      }\n    }\n    \n    int o=inf;\n    \n    for(i=0;i<4;i++)\n      o=min(o,wfs[w-1][h-1][i]);\n    \n    cout << o << endl;\n    cin >> w >> h;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nconst int INF = 1<<29;\n\nint fld[30][30];\nint dp[30][30][4];//(x,y)からゴールに行くための最小のコスト\nint h,w;\nint c[4];\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tREP(i,h)REP(j,w)cin>>fld[i][j];\n\t\tREP(i,4)cin>>c[i];\n\t\tREP(i,h)REP(j,w)REP(k,4)dp[i][j][k]=INF;\n\t\tdp[0][0][1]=0;\n\t\tbool f=true;\n\t\twhile(f){\n\t\t\tf=false;\n\t\t\tREP(x,w)REP(y,h){\n\t\t\t\tREP(k,4){\n\t\t\t\t\tint cost=(k==fld[y][x]?0:c[k]);\n\t\t\t\t\tREP(i,4){\n\t\t\t\t\t\tint tx=x+dx[(k+i)%4],ty=y+dy[(k+i)%4];\n\t\t\t\t\t\tif(tx<0||tx>=w||ty<0||ty>=h)continue;\n\t\t\t\t\t\tif(dp[ty][tx][(k+i)%4]>dp[y][x][i]+cost){\n\t\t\t\t\t\t\tdp[ty][tx][(k+i)%4]=dp[y][x][i]+cost;\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tREP(i,4)ans=min(ans,dp[h-1][w-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int a[32][32];\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++)\n\tcin>>a[j][i];\n    int b[4];\n    for(i=0;i<4;i++)\n      cin>>b[i];\n    int c[32][32][4];\n    memset(c,-1,sizeof(c));\n    priority_queue<pair<pair<int,int>,pair<int,int> >,vector<pair<pair<int,int>,pair<int,int> > >,greater<pair<pair<int,int>,pair<int,int> > > > d;\n    d.push(make_pair(make_pair(0,0),make_pair(1,1)));\n    while(d.empty()==0){\n      int x,y,z,s;\n      x=d.top().second.first;\n      y=d.top().second.second;\n      z=d.top().first.first;\n      s=d.top().first.second;\n      d.pop();\n      if(x==w&&y==h)\n\tbreak;\n      if(a[x][y]!=-1&&c[x][y][s]){\n\tc[x][y][s]=0;\n\tif(0){\n\t}else if(s==0){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),0),make_pair(x+1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),1),make_pair(x,y+1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),2),make_pair(x-1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),3),make_pair(x,y-1)));\n\t}else if(s==1){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),1),make_pair(x,y+1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),2),make_pair(x-1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),3),make_pair(x,y-1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),0),make_pair(x+1,y)));\n\t}else if(s==2){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),2),make_pair(x-1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),3),make_pair(x,y-1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),0),make_pair(x+1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),1),make_pair(x,y+1)));\n\t}else if(s==3){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),3),make_pair(x,y-1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),0),make_pair(x+1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),1),make_pair(x,y+1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),2),make_pair(x-1,y)));\n\t}\n      }\n    }\n    cout<<d.top().first.first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define all(X) X.begin(),X.end()\n#define X first\n#define Y second\n#define eb emplace_back\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<vector<pii>> Graph;\n\nint h,w;\nint mp[33][33];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\ninline int fun(int y,int x,int dir){\n  if(y<0 || y>=h || x<0 || x>=w) return h*w*4;\n     return h*w*dir+w*y+x;\n}\nconst int INF=1e9;\n\nvoid dij(const Graph &g,int s,vector<int> &d){\n  typedef pii Que;\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int n=g.size();\n  d.resize(n);\n  fill(all(d),INF);\n  d[s]=0;\n  que.emplace(0,s);\n  while(que.size()){\n    Que p=que.top(); que.pop();\n    if(d[p.Y]<p.X) continue;\n    for(pii e:g[p.Y]) if(d[e.X]>d[p.Y]+e.Y){\n        d[e.X]=d[p.Y]+e.Y;\n        que.emplace(d[e.X],e.X);\n      }\n  }\n}\n\nint main() {\n  while(cin>>w>>h,h||w){\n    rep(i,h)rep(j,w) cin>>mp[i][j];\n    vector<int> cost(4);\n    rep(i,4) cin>>cost[i];\n    Graph g(h*w*4+1);\n    rep(y,h)rep(x,w)rep(d,4)rep(c,4){\n      int e=(d+c)%4;\n      g[fun(y,x,d)].eb(fun(y+dy[e],x+dx[e],e),cost[c]*(mp[y][x]!=c));\n    }\n    //for(pii p:g[fun(0,0,0)])cout<<\"(\"<<p.X<<\",\"<<p.Y<<\"),\";cout<<endl;\n    int re=INF;\n    vector<int> d;\n    dij(g,fun(0,0,0),d);\n    //for(int x:d)cout<<x<<\",\";cout<<endl;\n    rep(i,4) re=min(re,d[fun(h-1,w-1,i)]);\n\n    // rep(di,4){\n    //   rep(i,h){rep(j,w)cout<<d[fun(i,j,di)]<<\",\";cout<<endl;}\n    //   cout<<endl;\n    // }\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint m[33][33];\nmap<char,vector<vector<int>>> c;\nbool used[33][33];\n\n/*\n0: ?????´????????????\n1: ??????????????????\n2: ????????¢?????????\n3: ??????????????????\n4: ????????¢?????????\n*/\n\nstruct Point{ int x, y; };\nint dy[5] = {-1,0,1,0,-100}, dx[5] = {0,1,0,-1,-100};\nchar ch[5] = \"nwse\";\nint mc[4];\nint h, w;\n\nint direction(int com, char dis){\n    if(dis == 'n') return com;\n    else if(dis == 'w') return (com + 1) % 4;\n    else if(dis == 's') return (com + 2) % 4;\n    else if(dis == 'e') return (com + 3) % 4;\n    else return 4;\n}\n\nvoid dfs(int y, int x, char dis, int cost, int k){\n    //cout << y << ' ' << x << endl;\n    //show(m[y][x])\n    //    show(dis)\n    if(used[y][x]) return;\n    if(k > w * h) return;\n\n    rep(i,4){\n        int p = direction(i,dis);\n        int ny = y + dy[p];\n        int nx = x + dx[p];\n        int next_cost = cost + (i == m[y][x] ? 0 : mc[i]);\n\n        if(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n        if(c[ch[p]][ny][nx] < next_cost) continue;\n        c[ch[p]][ny][nx] = next_cost;\n        dfs(ny,nx,ch[p], next_cost, k + 1);\n    }\n}\n\nint main(){\n    while(cin >> w >> h,h){\n        rep(k,4) c[ ch[k] ] = vector<vector<int>>(33,vector<int>(33));\n        rep(k,4) rep(i,h) rep(j,w) c[ch[k]][i][j] = INF;\n        c['w'][0][0] = 0;\n        memset(used, 0, sizeof(used));\n\n        rep(i,h) rep(j,w) cin >> m[i][j];\n        rep(i,4) cin >> mc[i];\n\n        dfs(0, 0, 'w', 0, 0);\n\n        //rep(i,h){ rep(j,w){ cout << c['w'][i][j] << ' '; } cout << endl; }\n\n        int mini = INF;\n        rep(i,4) mini = min(mini, c[ch[i]][h - 1][w - 1]);\n        cout << mini << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nstruct edge {\n    int to, cost;\n    edge(int to, int cost) : to(to), cost(cost){};\n};\n\nint main() {\n\n    int w, h;\n    while(cin >> w >> h, w){\n        vector<vector<edge>> G(h*w*4);\n        array<int, 4> di{0, 1, 0, -1}, dj{1, 0, -1, 0};\n        vector<vector<int>> v(h+2, vector<int>(w+2, -1));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> v[i+1][j+1];\n            }\n        }\n        array<int, 4> costs{};\n        for (auto &&k : costs) cin >> k;\n        for (int i = 1; i <= h; ++i) {\n            for (int j = 1; j <= w; ++j) {\n                for (int k = 0; k < 4; ++k) {\n                    for (int un = 0; un < 4; ++un) {\n                        int l = (k+un)%4;\n                        if(!(~v[i+di[l]][j+dj[l]])) continue;\n                        int c = (v[i][j] == un ? 0 : costs[un]);\n                        i--; j--;\n                        G[(i*w+j)*4+k].emplace_back(((i+di[l])*w+j+dj[l])*4+l, c);\n                        i++; j++;\n                    }\n                }\n            }\n        }\n        using P = pair<int, int>;\n        vector<int> dist(G.size(), INF<int>);\n        priority_queue<P, vector<P>, greater<>> Q;\n        dist[0] = 0;\n        Q.emplace(0, 0);\n        while(!Q.empty()){\n            int cost, i; tie(cost, i) = Q.top(); Q.pop();\n            if(dist[i] < cost) continue;\n            for (auto &&e : G[i]) {\n                if(dist[e.to] <= cost + e.cost) continue;\n                dist[e.to] = cost + e.cost;\n                Q.emplace(dist[e.to], e.to);\n            }\n        }\n        int ans = INF<int>;\n        for (int i = 0; i < 4; ++i) {\n            ans = min(ans, dist[(h*w-1)*4+i]);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <limits.h>\n#include <bitset>\n\n#include <tuple>\n#include <unordered_map>\n\n#define mp       make_pair\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint w,h;\nint board[40][40];\nint cost[5];\nint dir;\nint gy,gx;\nint cboard[40][40][4];\nint main(){\n\twhile(cin >> w >> h){\n\t\tdir = 0;\n\t\tgy = h, gx = w;\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 0; i < 40; i++){\n\t\t\tfor (int j = 0; j < 40; j++){\n\t\t\t\tboard[i][j] = -1;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tcboard[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcboard[1][1][0] = 0;\n\t\tif (w == 0 || h == 0)break;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tcin >> cost[i];\n\t\t}\n\t\tint cnt = 0;\n\t\twhile(cnt <= 3000){\n\t\tfor (int i = 1; i <= h; i++){//y\n\t\t\tfor (int j = 1; j <= w; j++){//x\n\t\t\t\tfor (int k = 0; k < 4; k++){//dir\n\t\t\t\t\tif (i == h && j == w){\n\t\t\t\t\t\tans = min(ans, cboard[i][j][k]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//no\n\t\t\t\t\t\tif (board[i][j] == 0){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 1){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 2){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 3){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//straight\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][0] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][1] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][2] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][3] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//right\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][0] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][1] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][2] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][3] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//back\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][0] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][1] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][2] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][3] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//left\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][0] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][1] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][2] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][3] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\t// for (int k = 0; k < 4; k++){\n\t\t\t// \tans = min(ans, cboard[h][w][k]);\n\t\t\t// }\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nclass State{\npublic:\n  int x,y,d,cost;\n  State(){}\n  State(int _x,int _y,int _d,int _cost){\n    x = _x;\n    y = _y;\n    d = _d;\n    cost = _cost;\n  }\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint w,h;\nint t[32][32];\nint change[4];\n\nvoid solve(){\n  priority_queue<State> open;\n  bool closed[32][32][4];\n  memset(closed,0,sizeof(closed));\n  open.push(State(0,0,1,0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n    if(closed[st.x][st.y][st.d]) continue;\n    closed[st.x][st.y][st.d] = true;\n\n    if(st.x == w-1 && st.y == h-1){\n      cout<<st.cost<<endl;\n      return;\n    }\n\n    rep(i,4){\n      int nd = (st.d + i) % 4;\n      int nx = st.x + dx[nd];\n      int ny = st.y + dy[nd];\n\n      if(nx>=0 && w>nx && ny>=0 && h>ny){\n        if(i == t[st.y][st.x]){\n          open.push(State(nx,ny,nd,st.cost));\n        }\n        else{\n          open.push(State(nx,ny,nd,st.cost+change[i]));\n        }\n      }\n    }\n  }\n\n}\n\nint main(){\n  while(cin>>w>>h,w||h){\n    rep(i,h){\n      rep(j,w){\n        cin>>t[i][j];\n      }\n    }\n\n    rep(i,4){\n      cin>>change[i];\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tuple>\nusing namespace std;\ntypedef vector<int> vi;\nconst int INF=1e9;\nint w,h;\ntypedef tuple<int,int,pair<int,int> > tup;//コスト,どの向きから来た?,pair(Y座標,X座標)\nint d[35][35][4];//[Y座標][X座標][どの向きから来た?]　0:右,1:下,2:左,3:上\nint board[35][35];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint c[4];\nint ans;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n  std::fill( (T*)array,(T*)(array+N),val );\n}\n\nconst int MAX_V=1e5+5;\nvoid dijkstra()\n{\n  for(int i=1;i<=h;i++)\n    {\n      for(int j=1;j<=w;j++)\n\t{\n\t  for(int k=0;k<4;k++)\n\t    {\n\t      d[i][j][k]=INF;\n\t    }\n\t}\n    }\n  priority_queue<tup,vector<tup>,greater<tup> > que;\n  d[1][1][0]=0;\n  que.push(make_tuple(0,0,make_pair(1,1)));\n  while(!que.empty())\n    {\n      int cost,dir;\n      pair<int,int> p;\n      tie(cost,dir,p)=que.top();que.pop();\n      int y=p.first;\n      int x=p.second;\n      if(d[y][x][dir]<cost) continue;\n      for(int i=0;i<4;i++)\n\t{\n\t  int ndir=(dir+i)%4;\n\t  int ny=y+dy[ndir];\n\t  int nx=x+dx[ndir];\n\t  if(ny<=0 || ny>h || nx<=0 || nx>w) continue;\n\t  if(i==board[y][x])\n\t    {\n\t      if(cost<d[ny][nx][ndir])\n\t\t{\n\t\t  d[ny][nx][ndir]=cost;\n\t\t  que.push(make_tuple(d[ny][nx][ndir],ndir,make_pair(ny,nx)));\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if(cost+c[i]<d[ny][nx][ndir])\n\t\t{\n\t\t  d[ny][nx][ndir]=cost+c[i];\n\t\t  que.push(make_tuple(d[ny][nx][ndir],ndir,make_pair(ny,nx)));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nint main(void)\n{\n  while(cin >> w >> h && w)\n    {\n      for (int i = 1; i <= h; ++i)\n\t{\n\t  for (int j = 1; j<= w; ++j)\n\t    {\n\t      cin >> board[i][j];\n\t    }\n\t}\n      for (int i = 0; i < 4; ++i)\n\t{\n\t  cin >> c[i];\n\t}\n      ans=INF;\n      dijkstra();\n      for(int i=0;i<4;i++)\n\t{\n\t  ans=min(ans,d[h][w][i]);\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n#define inf 101010\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> pp;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nint w, h;\nint g[31][31];\nint dp[31][31][4];\nint c[4];\n\nbool r(int y, int x) {\n    if (y >= 0 && y < h && x >= 0 && x < w) return true;\n    else return false;\n}\n\nint main(void){\n    while (cin>>w>>h && w) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> g[i][j];\n                for (int k = 0; k < 4; k++) dp[i][j][k] = inf;\n            }\n        }\n        for (int i = 0; i < 4; i++) cin >> c[i];\n        \n        dp[0][0][1] = 0;\n        priority_queue<pp, vector<pp>, greater<pp> > que;\n        que.push(mp(mp(0,1), mp(0,0)));\n        \n        int ans;\n        while (!que.empty()) {\n            pp p = que.top(); que.pop();\n            int ty = p.second.first, tx = p.second.second;\n            int tc = p.first.first, td = p.first.second;\n            if (tc > dp[ty][tx][td]) continue;\n            if (ty == h-1 && tx == w-1) {\n                ans = tc;\n                break;\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                int nd = (td+i)%4;\n                int ny = ty + dy[nd], nx = tx + dx[nd];\n                if (!r(ny,nx)) continue;\n                \n                int cost = c[i];\n                if (g[ty][tx] == i) cost = 0;\n                \n                if (dp[ny][nx][nd] > dp[ty][tx][td]+cost) {\n                    dp[ny][nx][nd] = dp[ty][tx][td]+cost;\n                    que.push(mp(mp(dp[ny][nx][nd],nd), mp(ny,nx)));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\ntypedef pair< Pi, Pi > Pii;\n\nint w, h, c[4], s[30][30];\n\nint main()\n{\n\twhile(cin >> w >> h, w) {\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tcin >> c[i];\n\t\t}\n\t\t\n\t\tpriority_queue< Pii, vector< Pii >, greater< Pii > > que;\n\t\tint Cost[30][30][5];\n\t\tfill_n(**Cost, 30 * 30 * 5, 1 << 30);\n\t\t\n\t\t// 直進, 右折, 反転, 左折\n\t\tint dy[4][4] = {\n\t\t\t{0, 1, 0, -1},  // →\n\t\t\t{1, 0, -1, 0},   // ↓\n\t\t\t{0, -1, 0, 1},   // ←\n\t\t\t{-1, 0, 1, 0}    // ↑\n\t\t};\n\t\tint dx[4][4] = {\n\t\t\t{1, 0, -1, 0},\n\t\t\t{0, -1, 0, 1},\n\t\t\t{-1, 0, 1, 0},\n\t\t\t{0, 1, 0, -1}\n\t\t};\n\t\tint Dir[4][4] = {\n\t\t\t{0, 1, 2, 3},\n\t\t\t{1, 2, 3, 0},\n\t\t\t{2, 3, 0, 1},\n\t\t\t{3, 0, 1, 2}\n\t\t};\n\t\tque.push(Pii(Pi(0, 0), Pi(0, 0)));\n\t\tCost[0][0][0] = 0;\n\t\t\n\t\twhile(!que.empty()) {\n\t\t\tPii p = que.top(); que.pop();\n\t\t\t\n\t\t\tPi point = p.second;\n\t\t\tint dir = p.first.second;\n\t\t\tint cost = p.first.first;\n\t\t\tif(point.second == h - 1 && point.first == w - 1) {\n\t\t\t\tcout << cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(Cost[point.second][point.first][dir] < cost) continue;\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint ny = point.second + dy[dir][i], nx = point.first + dx[dir][i];\n\t\t\t\tint nextdir = Dir[dir][i];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(Cost[nx][ny][nextdir] <= p.first.first + c[i]) continue;\n\t\t\t\tCost[nx][ny][nextdir] = p.first.first + c[i];\n\t\t\t\tque.push(Pii(Pi(p.first.first + c[i], nextdir), Pi(nx, ny)));\n\t\t\t}\n\t\t\t\n\t\t\tif(s[point.second][point.first] == 4) continue;\n\t\t\tint ny = point.second + dy[dir][s[point.second][point.first]];\n\t\t\tint nx = point.first  + dx[dir][s[point.second][point.first]];\n\t\t\tint nextdir = Dir[dir][s[point.second][point.first]];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif(Cost[nx][ny][nextdir] <= p.first.first) continue;\n\t\t\tCost[nx][ny][nextdir] = p.first.first;\n\t\t\tque.push(Pii(Pi(p.first.first, nextdir), Pi(nx, ny)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\td[0][0][1] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <tuple>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef tuple<int, int, int, int> T;\n\nint INF = 11451419;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nint w, h;\nint s[30][30];\nint c[4];\nint dp[30][30][4];\n\nint main() {\n\tint i, j, k;\n\t\n\twhile (cin >> w >> h) {\n\t\tif (!w) break;\n\t\trep(i, h) rep(j, w) cin >> s[i][j];\n\t\trep(i, 4) cin >> c[i];\n\t\t\n\t\trep(i, h) rep(j, w) rep(k, 4) dp[i][j][k] = INF;\n\t\tpriority_queue<T, vector<T>, greater<T>> que;\n\t\tdp[0][0][1] = 0;\n\t\tque.push(T(0, 0, 0, 1));\n\t\twhile (!que.empty()) {\n\t\t\tT now = que.top(); que.pop();\n\t\t\tint cst = get<0>(now);\n\t\t\tint y = get<1>(now);\n\t\t\tint x = get<2>(now);\n\t\t\tint dir = get<3>(now);\n\t\t\t\n\t\t\trep(i, 4) {\n\t\t\t\tint ndir = (dir + i) % 4;\n\t\t\t\tint ny = y + dy[ndir];\n\t\t\t\tint nx = x + dx[ndir];\n\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tint ncst = (s[y][x] != i) * c[i] + cst;\n\t\t\t\tif (dp[ny][nx][ndir] > ncst) {\n\t\t\t\t\tdp[ny][nx][ndir] = ncst;\n\t\t\t\t\tque.push(T(ncst, ny, nx, ndir));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(i, 4) ans = min(ans, dp[h-1][w-1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n\nint G[SIZE][SIZE], C[4];\nint H, W;\n\nstruct State {\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n};\nbool operator<(const State &s1, const State &s2) {\n  return s1.cost<s2.cost;\n}\n\nint solve() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State, vector<State>, greater<State> > pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n\t && 0 <= t.y && t.y < H \n\t && cost[t.d][t.y][t.x] > t.cost) {\n\tpq.push(t);\n\tcost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n  \n  return INF;\n}\n\nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n\tcin >> G[i][j];\n    \n    for(int i=0; i<4; i++) cin >> C[i];\n    \n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n \nint G[SIZE][SIZE], C[4];\nint H, W;\n \nclass State {\npublic:\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost>s.cost;\n  }\n};\n \nint solve() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State> pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W\n     && 0 <= t.y && t.y < H\n     && cost[t.d][t.y][t.x] > t.cost) {\n    pq.push(t);\n    cost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n   \n  return INF;\n}\n \nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n    cin >> G[i][j];\n     \n    for(int i=0; i<4; i++) cin >> C[i];\n     \n    cout << solve() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <functional>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nconst int INF = (int)1e9;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n\nint cost[30][30][4][4];\n\n#define next(i) ((i+1)%4)\n#define prev(i) ((i-1+4)%4)\n\nint d[30][30][4];\n\nstruct Node {\n    int y, x, cost, dir;\n    Node(int y, int x, int c, int d) : y(y), x(x), cost(c), dir(d) { }\n    bool operator <(const Node& n) const {\n        return cost > n.cost;\n    }\n};\n\nint main() {\n    for(int W, H; cin >> W >> H, W; ) {\n        vector<vector<int> > comm(H, vector<int>(W));\n        REP(i,H) REP(j,W) cin >> comm[i][j];\n        vector<int> cs(4);\n        REP(i,4) cin >> cs[i];\n\n        REP(i,H) REP(j,W) REP(k,4) {\n            if(comm[i][j] == 0) {\n                cost[i][j][k][k] = 0;\n            }\n            else {\n                cost[i][j][k][k] = cs[0];\n            }\n\n            if(comm[i][j] == 1) {\n                cost[i][j][k][next(k)] = 0;\n            }\n            else {\n                cost[i][j][k][next(k)] = cs[1];\n            }\n\n\n            if(comm[i][j] == 2) {\n                cost[i][j][k][next(next(k))] = 0;\n            }\n            else {\n                cost[i][j][k][next(next(k))] = cs[2];\n            }\n\n            if(comm[i][j] == 3) {\n                cost[i][j][k][prev(k)] = 0;\n            }\n            else {\n                cost[i][j][k][prev(k)] = cs[3];\n            }\n\n            d[i][j][k] = INF;\n        }\n        d[0][0][0] = 0;\n        priority_queue<Node> Q;\n        Q.push(Node(0, 0, 0, 0));\n        while(!Q.empty()) {\n            Node p = Q.top(); Q.pop();\n            // DEBUG(p.y); DEBUG(p.x); DEBUG(p.dir); DEBUG(p.cost);\n            if(p.y == H - 1 && p.x == W - 1) break;\n            if(p.cost > d[p.y][p.x][p.dir]) continue;\n            for(int i = 0; i < 4; i++) {\n                const int dy[4] = { 0, 1, 0, -1 };\n                const int dx[4] = { 1, 0, -1, 0 };\n                int nx = p.x + dx[i];\n                int ny = p.y + dy[i];\n                if(0 <= ny && ny < H && 0 <= nx && nx < W && d[ny][nx][i] > p.cost + cost[p.y][p.x][p.dir][i]) {\n                    d[ny][nx][i] = p.cost + cost[p.y][p.x][p.dir][i];\n                    Q.push(Node(ny, nx, d[ny][nx][i], i));\n                }\n            }\n        }\n        int res = INF;\n        for(int i = 0; i < 4; i++) {\n            res = min(res, d[H - 1][W - 1][i]);\n        }\n        cout << res << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max()/2;\n\nstruct State{\n    int x,y,dir,d;\n    State(int x, int y, int dir, int d): x(x),y(y),dir(dir),d(d){}\n};\n\nbool operator < (const State &e, const State &f){\n    return e.d > f.d;\n}\n\nint dis[40][40][4];\nint dx[4] = {0,1,0,-1},dy[4]={1,0,-1,0};\nvector<vector<int>> inst(40,vector<int>(40));\nvector<int> c(4);\nint w,h;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(cin>>w>>h,w||h){\n        for(int i=0;i<h;i++) for(int j=0;j<w;j++) for(int k=0;k<4;k++) dis[i][j][k]=INF;\n        for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>inst[i][j];\n        for(int i=0;i<4;i++) cin>>c[i];\n        priority_queue<State> q;\n        q.push(State(0,0,0,0));\n        dis[0][0][0]=0;\n        while(!q.empty()){\n            State s = q.top();q.pop();\n            int x=s.x, y=s.y,dir=s.dir,dist=s.d;\n            if(dis[x][y][dir]<dist) continue;\n            //cout<<x<<\" \"<<y<<\" \"<<dir<<endl;\n            for(int i=0;i<4;i++){\n                int nx=x+dx[i],ny=y+dy[i];\n                if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n                int cost;\n                if(inst[x][y]!=4 && (dir+inst[x][y])%4==i) cost=0;\n                else cost = c[(4+i-dir)%4];\n\n                if(dis[nx][ny][i]<=dist+cost) continue;\n                dis[nx][ny][i]=dist + cost;\n                q.push(State(nx,ny,i,dis[nx][ny][i]));\n                //cout<<nx<<\" \"<<ny<<\" \"<<i<<\" \"<<dis[nx][ny][i]<<endl;\n            }\n        }\n        int res=INF;\n        for(int i=0;i<4;i++) res=min(res,dis[h-1][w-1][i]);\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// type {{{\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvll = vector<vector<ll>>;\n// }}}\n\n\n// macro {{{\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define RREP(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i,a,n) for (int i=(a); i<(n); ++i)\n#define RFOR(i,a,n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n// }}}\n\n\n// debug {{{\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    REP (i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n// }}}\n\n\n// chmax, chmin {{{\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// }}}\n\n\n// constants {{{\n#define inf(T) (numeric_limits<T>::max() / 2)\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n// }}}\n\n\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\n\ntemplate<typename T>\nvector<T> dijkstra(const vector<vector<edge<T>>> &g, int s) {\n    const T INF = numeric_limits<T>::max();\n    vector<T> d(g.size(), INF);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    d[s] = 0;\n    que.emplace(d[s], s);\n    while (!que.empty()) {\n        T cost;\n        int v;\n        tie(cost, v) = que.top();\n        que.pop();\n        if (d[v] < cost) continue;\n        for (auto &e : g[v]) {\n            T nxt = cost + e.cost;\n            if (d[e.to] > nxt) {\n                d[e.to] = nxt;\n                que.emplace(nxt, e.to);\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    const int STRAIGHT = 0,\n              RIGHT = 1,\n              BACK = 2,\n              LEFT = 3,\n              HALT = 4;\n\n    const int dy[] = {0, 1, 0, -1},\n              dx[] = {1, 0, -1, 0};\n\n    for (;;) {\n        int W, H; cin >> W >> H;\n        if (W == 0) break;\n\n        vvi S(H, vi(W));\n        REP(i, H) REP(j, W) cin >> S[i][j];\n        vi C(4);\n        REP(i, 4) cin >> C[i];\n\n        vector<vector<edge<int>>> G(H*W*4);\n\n        REP(d, 4) REP(i, H) REP(j, W) {\n            for (int op : {STRAIGHT, RIGHT, BACK, LEFT}) {\n                int nd = (d + op) % 4;\n                int ni = i + dy[nd],\n                    nj = j + dx[nd];\n                if (ni < 0 or nj < 0 or ni >= H or nj >= W) continue;\n                G[i*(W*4) + j*4 + d].emplace_back(\n                        ni*(W*4) + nj*4 + nd, C[op]);\n            }\n            if (S[i][j] != HALT) {\n                int nd = (d + S[i][j]) % 4;\n                int ni = i + dy[nd],\n                    nj = j + dx[nd];\n                if (ni < 0 or nj < 0 or ni >= H or nj >= W) continue;\n                G[i*(W*4) + j*4 + d].emplace_back(\n                        ni*(W*4) + nj*4 + nd, 0);\n            }\n        }\n\n        auto dist = dijkstra(G, 0);\n\n        int ans = inf(int);\n\n        REP(d, 4) chmin(ans, dist[(H-1)*(W*4) + (W-1)*4 + d]);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n\nint G[SIZE][SIZE], C[4];\nint H, W;\n\nstruct State {\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n};\nbool operator>(const State &s1, const State &s2) {\n  return s1.cost>s2.cost;\n}\n\nint dijkstra() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State, vector<State>, greater<State> > pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n\t && 0 <= t.y && t.y < H \n\t && cost[t.d][t.y][t.x] > t.cost) {\n\tpq.push(t);\n\tcost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n  \n  return INF;\n}\n\nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n\tcin >> G[i][j];\n    \n    for(int i=0; i<4; i++) cin >> C[i];\n    \n    cout << dijkstra() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define MAX_W 31\n#define MAX_H 31\n#define INF 1 << 28\n\nusing namespace std;\n\nint w, h;\nint g[MAX_H][MAX_W], c[4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state{\n  int x, y, dir, cost;\n  bool operator < (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nint bfs(void){\n  \n  priority_queue<state> Q;\n  int cost[MAX_H][MAX_W][4];\n  \n  Q.push((state){0,0,0,0});\n  fill(cost[0][0], cost[MAX_H][0], INF);\n  cost[0][0][0] = 0;\n  \n  while(!Q.empty()){\n\n    const state s = Q.top();\n    Q.pop();\n    \n    if(cost[s.y][s.x][s.dir] < s.cost) continue;\n    if(s.y == h - 1 && s.x == w - 1) return s.cost;\n\n    for(int i = 0 ; i < 4 ; i++){\n\n      state t = s;\n      t.cost += (g[s.y][s.x] == i ? 0 : c[i]);\n      t.dir = (t.dir + i) % 4;\n      t.y += dy[t.dir];\n      t.x += dx[t.dir];\n\n      if(t.x < 0 || t.x >= w) continue;\n      if(t.y < 0 || t.y >= h) continue;\n      if(cost[t.y][t.x][t.dir] > t.cost){\n\tQ.push(t);\n\tcost[t.y][t.x][t.dir] = t.cost;\n      }\n    }\n  }\n  return INF;  \n}\n\nint main(void){\n  \n  while(cin >> w >> h, w + h){\n    \n    for(int i = 0 ; i < h ; i++)\n      for(int j = 0 ; j < w ; j++)\n\tcin >> g[i][j];\n    \n    for(int i = 0 ; i < 4 ; i++) cin >> c[i];\n    \n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint main(){\n    int h,w,g[50][50], c[4];\n    int dist[50][50][4];\n    while(scanf(\"%d%d\",&w,&h), w){\n        rep(i,h)rep(j,w) scanf(\"%d\",&g[i][j]);\n        rep(i,4) scanf(\"%d\", &c[i]);\n        // d, y, x, dir\n        typedef tuple<int,int,int,int> State;\n        rep(i,50)rep(j,50)rep(k,4) dist[i][j][k] = 1e9;\n        dist[0][0][0] = 0;\n        priority_queue<State> q;\n        int dx[] = {1,0,-1,0};\n        int dy[] = {0,1,0,-1};\n        q.emplace(0,0,0,0);\n        int ans = -1;\n        while(q.size()){\n            int d,y,x,dir;\n            tie(d,y,x,dir) = q.top();\n            q.pop();\n            d = -d;\n            //printf(\" %d %d %d %d\\n\", d,y,x,dir);\n            if(dist[y][x][dir] < d) continue;\n            if(y==h-1 && x==w-1){\n                ans = d;\n                break;\n            }\n            rep(op,4){\n                int nx, ny, nd, ndir;\n                int cost = op == g[y][x] ? 0 : c[op];\n                nd = d + cost;\n                ndir = (dir+op)%4;\n                nx = x+dx[ndir], ny = y+dy[ndir];\n                if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n                if(dist[ny][nx][ndir] <= nd) continue;\n                dist[ny][nx][ndir] = nd;\n                q.emplace(-nd,ny,nx,ndir);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int w, h;\n  while(cin >> w >> h, w || h){\n    int s[33][33], c[4];\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    for(int i = 0; i < 4; i++) cin >> c[i];\n    const int inf = (1 << 25);\n    int a[4][33][33];\n    int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n    fill(a[0][0], a[4][0], inf);\n    typedef pair<int, int> P;\n    typedef pair<P, P> PP;\n    priority_queue<PP, vector<PP>, greater<PP> > que;\n    que.push(PP(P(0, 0), P(0, 0)));\n    a[0][0][0] = 0;\n    while(!que.empty()){\n      PP p = que.top(); que.pop();\n      int l = p.first.first, d = p.first.second;\n      int x = p.second.first, y = p.second.second;\n      if(x == w-1 && y == h-1){\n\tcout << l << endl;\n\tbreak;\n      }\n      for(int i = 0; i < 4; i++){\n\tint nd = (d+i) % 4, nx = x + dx[nd], ny = y + dy[nd], nl = l + (i == s[y][x] ? 0 : c[i]);\n\tif(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\tif(nl < a[nd][ny][nx]){\n\t  que.push(PP(P(nl, nd), P(nx, ny)));\n\t  a[nd][ny][nx] = nl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-9;\n\nlong long int N, M, K, H, W, L, R;\n\nstruct node {\n\tint y, x, dir;\n\tbool operator < (const node& n)const {\n\t\treturn y < n.y;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> W >> H;\n\tint dir[] = { 0,1,0,-1,0 };\n\tvector<int>ans;\n\twhile (H) {\n\t\tvector<vector<int>>v(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<int>cost(4);\n\t\tfor (int i = 0; i < 4; i++)cin >> cost[i];\n\t\tvector<vector<vector<int>>>dp(H, vector<vector<int>>(W, vector<int>(4, MOD)));\n\t\tdp[0][0][0] = 0;\n\t\tpriority_queue<pair<int, node>, vector<pair<int, node>>, greater<pair<int, node>>>PQ;\n\t\tPQ.push({ 0,{0,0,0} });\n\t\twhile (!PQ.empty()) {\n\t\t\tint c = PQ.top().first;\n\t\t\tnode n = PQ.top().second;\n\t\t\tPQ.pop();\n\t\t\tif (dp[n.y][n.x][n.dir] < c)continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ndir = (n.dir + i) % 4;\n\t\t\t\tint ny = dir[ndir] + n.y;\n\t\t\t\tint nx = dir[ndir + 1] + n.x;\n\t\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\t\tif (dp[ny][nx][ndir] > c + cost[i]) {\n\t\t\t\t\tdp[ny][nx][ndir] = c + cost[i];\n\t\t\t\t\tPQ.push({ c + cost[i],{ny,nx,ndir} });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[n.y][n.x] == 4)continue;\n\t\t\tint ndir = (n.dir + v[n.y][n.x]) % 4;\n\t\t\tint ny = dir[ndir] + n.y;\n\t\t\tint nx = dir[ndir + 1] + n.x;\n\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\tif (dp[ny][nx][ndir] > c) {\n\t\t\t\tdp[ny][nx][ndir] = c;\n\t\t\t\tPQ.push({ c ,{ ny,nx,ndir } });\n\t\t\t}\n\t\t}\n\t\tans.push_back(min(dp[H - 1][W - 1][0], dp[H - 1][W - 1][1]));\n\t\tcin >> W >> H;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint v[40][40], x[40][40][4], w, h, z[4], q[4];\nvoid d0(int c, int d, int p1, int p2) {\n\tif (d == 0) {\n\t\tx[p1 + 1][p2][d] = min(x[p1 + 1][p2][d], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1][p2 + 1][d] = min(x[p1][p2 + 1][d], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1 - 1][p2][d] = min(x[p1 - 1][p2][d], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1][p2 - 1][d] = min(x[p1][p2 - 1][d], x[p1][p2][d] + c);\n\t}\n}\nvoid d1(int c,int d,int p1,int p2) {\n\tif (d == 0) {\n\t\tx[p1][p2 - 1][(d + 1) % 4] = min(x[p1][p2 - 1][(d + 1) % 4], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1 + 1][p2][(d + 1) % 4] = min(x[p1 + 1][p2][(d + 1) % 4], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1][p2 + 1][(d + 1) % 4] = min(x[p1][p2 + 1][(d + 1) % 4], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1 - 1][p2][(d + 1) % 4] = min(x[p1 - 1][p2][(d + 1) % 4], x[p1][p2][d] + c);\n\t}\n}\nvoid d2(int c, int d, int p1, int p2) {\n\tif (d == 0) {\n\t\tx[p1 - 1][p2][(d + 2) % 4] = min(x[p1 - 1][p2][(d + 2) % 4], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1][p2 - 1][(d + 2) % 4] = min(x[p1][p2 - 1][(d + 2) % 4], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1 + 1][p2][(d + 2) % 4] = min(x[p1 + 1][p2][(d + 2) % 4], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1][p2 + 1][(d + 2) % 4] = min(x[p1][p2 + 1][(d + 2) % 4], x[p1][p2][d] + c);\n\t}\n}\nvoid d3(int c, int d, int p1, int p2) {\n\tif (d == 0) {\n\t\tx[p1][p2 + 1][(d + 3) % 4] = min(x[p1][p2 + 1][(d + 3) % 4], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1 - 1][p2][(d + 3) % 4] = min(x[p1 - 1][p2][(d + 3) % 4], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1][p2 - 1][(d + 3) % 4] = min(x[p1][p2 - 1][(d + 3) % 4], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1 + 1][p2][(d + 3) % 4] = min(x[p1 + 1][p2][(d + 3) % 4], x[p1][p2][d] + c);\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tmemset(x, 1, sizeof(x));\n\t\tcin >> w >> h; if (!w) { break; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> z[0] >> z[1] >> z[2] >> z[3];\n\t\tx[1][1][1] = 0;\n\t\tfor (int t = 0; t < 1999; t++) {\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\t\t\tif (v[i][j] == l) {\n\t\t\t\t\t\t\t\tq[l] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tq[l] = z[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td0(q[0], k, i, j);\n\t\t\t\t\t\td1(q[1], k, i, j);\n\t\t\t\t\t\td2(q[2], k, i, j);\n\t\t\t\t\t\td3(q[3], k, i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min(x[h][w][0], x[h][w][1]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <utility>\n#include <climits>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n// ori: 0 = 右向き, 1 = 下向き, 2 = 左向き, 3 = 上向き\nstruct state{\n    int cost, x, y, ori;\n    state(int c_, int x_, int y_, int ori_) : cost(c_), x(x_), y(y_), ori(ori_){}\n    bool operator>(const state& other) const {\n        return cost > other.cost;\n    }\n};\n\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\nint c[4];\nint w, h;\n// 右下左上\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\n\nint dijkstra(const Matrix<int>& m){\n    priority_queue<state, vector<state>, greater<state>> q;\n    q.push(state(0, 0, 0, 0));\n    // d[x][y][(x, y)にいる時のロボットの向き]\n    Matrix<vector<int>> d(w, vector<vector<int>>(h, vector<int>(4, INT_MAX)));\n    d[0][0][0] = 0;\n\n    while(!q.empty()){\n        state s = q.top();\n        q.pop();\n\n        if(s.x == w-1 && s.y == h-1) break;\n\n        for(int ope = 0; ope < 4; ++ope){ // 全ての命令を行う\n            int cost = 0;\n            int ori = s.ori;\n            if(ope != m[s.x][s.y]) cost = c[ope];\n            if(ope != 0){ // 向きを変える\n                if(ope == 1) ori = (ori + 1) % 4;// 右折\n                else if(ope == 2) ori = (ori + 2) % 4; // 反転\n                else ori = (ori + 3) % 4; // 左折\n            }\n            int next_x = s.x + dx[ori];\n            int next_y = s.y + dy[ori];\n            if(next_x < 0 || next_x >= w) continue;\n            if(next_y < 0 || next_y >= h) continue;\n            if(d[next_x][next_y][ori] > d[s.x][s.y][s.ori] + cost){\n                d[next_x][next_y][ori] = d[s.x][s.y][s.ori] + cost;\n                q.push(state(d[next_x][next_y][ori], next_x, next_y, ori));\n            }\n        }\n    }\n\n    int ans = INT_MAX;\n\n    for(int e : d[w-1][h-1]) ans = min(ans, e);\n\n    return ans;\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(!w) break;\n        Matrix<int> m(w, vector<int>(h));\n\n        for(int i = 0; i < h; ++i)\n            for(int j = 0; j < w; ++j)\n                cin >> m[j][i];\n\n        for(int i = 0; i < 4; ++i) cin >> c[i];\n\n        cout << dijkstra(m) << endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvvi a(h,vi(w));\n\t\tvi c(4);\n\t\tfor(auto&&l:a)for(auto&&i:l)cin>>i;\n\t\tfor(auto&&i:c)cin>>i;\n\t\t\n\t\tusing node=tuple<int,int,int,int>;\n\t\t\n\t\tauto cmp=[](node a,node b){return get<0>(a) > get<0>(b);};\n\t\tpriority_queue<node,vector<node>,decltype(cmp)> q(cmp);\n\t\tq.emplace(0,0,0,0);\n\t\tvector<vvi> ans(4,vvi(h,vi(w,INT_MAX)));\n\t\twhile(!q.empty()){\n\t\t\tint cost,v,y,x;\n\t\t\ttie(cost,v,y,x)=q.top();\n\t\t\tq.pop();\n\t\t\tif(ans[v][y][x]!=INT_MAX) continue;\n\t\t\t//cout<<v<<\" (\"<<y+1<<\",\"<<x+1<<\") =\"<<cost<<endl;\n\t\t\tans[v][y][x]=cost;\n\t\t\tif(y==h-1 and x==w-1){\n\t\t\t\tcout<<cost<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint vec[2][4]={{0,1,0,-1},{1,0,-1,0}};\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint j=(v+i+4)%4;\n\t\t\t\tint ny=y+vec[0][j], nx=x+vec[1][j];\n\t\t\t\tif(ny<0 or nx<0 or ny>=h or nx>=w or ans[j][ny][nx]!=INT_MAX) continue;\n\t\t\t\tif(a[y][x]==i){\n\t\t\t\t\tq.emplace(cost,j,ny,nx);\n\t\t\t\t}else{\n\t\t\t\t\tq.emplace(cost+c[i],j,ny,nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ??????: http://d.hatena.ne.jp/simezi_tan/20140920/1411169324\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) cout<<(#_v)<<\":\";for(auto(_x):(_v)){cout<<\" \"<<(_x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// 14:30-\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nint w, h;\nint a[30][30];\nint c[4];\nint d[30][30][4]; // d[i][j][k] = ??????(i, j)?????????k??§????????????????????§???????°??????????\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint dijkstra() {\n    using State = tuple<int, int, int, int>; // cost, i, j, k\n    priority_queue<State, vector<State>, greater<State>> pq;\n    rep(i, h) rep(j, w) rep(k, 4) d[i][j][k] = inf;\n    d[0][0][1] = 0;\n    pq.push(State(0, 0, 0, 1));\n\n    while (!pq.empty()) {\n        int cost, i, j, k;\n        tie(cost, i, j, k) = pq.top(); pq.pop();\n\n        bool debug = false;\n        if (i == 0 && j == 7 && k == 1) {\n            // debug = true;\n        }\n        if (debug) cout << \"i = \" << i << \", j = \" << j << \", k = \" << k << \", cost = \" << cost << endl;\n        if (d[i][j][k] < cost) continue;\n        rep(nk, 4) {\n            int ni = i + dx[nk], nj = j + dy[nk];\n            if (debug) cout << \"nk = \" << nk << \", ni = \" << ni << \", nj = \" << nj << endl;\n            if (!inside(ni, nj)) continue;\n            int ncost = c[(nk - k + 4) % 4];\n            if (a[i][j] != 4 && nk == (k + a[i][j]) % 4) {\n                // cerr << \"hey!\" << endl;\n                ncost = 0;\n            }\n            if (d[ni][nj][nk] > cost + ncost) {\n                d[ni][nj][nk] = cost + ncost;\n                pq.push(State(cost + ncost, ni, nj, nk));\n            }\n        }\n    }\n\n    // rep(k, 4) {\n    //     cout << \"k = \" << k << \":\" << endl;\n    //     rep(i, h) {\n    //         rep(j, w) {\n    //             cout << d[i][j][k] << \" \";\n    //         }\n    //         cout << endl;\n    //     }\n    //     cout << endl;\n    // }\n\n    int ret = inf;\n    rep(k, 4) chmin(ret, d[h-1][w-1][k]);\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    while (cin >> w >> h, w) {\n        // cerr << \"--- testcase \" << ++testcase << \" ---\" << endl;\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        rep(i, 4) cin >> c[i];\n        // if (testcase != 1) continue;\n        cout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <utility>\n#include <climits>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n// ori: 0 = 右向き, 1 = 下向き, 2 = 左向き, 3 = 上向き\nstruct state{\n    int cost, x, y, ori;\n    state(int c_, int x_, int y_, int ori_) : cost(c_), x(x_), y(y_), ori(ori_){}\n    bool operator<(const state& other) const {\n        return cost < other.cost;\n    }\n};\n\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\nint c[4];\nint w, h;\n// 右下左上\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\n\nint dijkstra(const Matrix<int>& m){\n    priority_queue<state> q;\n    q.push(state(0, 0, 0, 0));\n    // d[x][y][(x, y)にいる時のロボットの向き]\n    Matrix<vector<int>> d(w, vector<vector<int>>(h, vector<int>(4, INT_MAX)));\n    d[0][0][0] = 0;\n\n    while(!q.empty()){\n        state s = q.top();\n        q.pop();\n\n        for(int ope = 0; ope < 4; ++ope){ // 全ての命令を行う\n            int cost = 0;\n            int ori = s.ori;\n            if(ope != m[s.x][s.y]) cost = c[ope];\n            if(ope != 0){ // 向きを変える\n                if(ope == 1) ori = (ori + 1) % 4;// 右折\n                else if(ope == 2) ori = (ori + 2) % 4; // 反転\n                else ori = (ori + 3) % 4; // 左折\n            }\n            int next_x = s.x + dx[ori];\n            int next_y = s.y + dy[ori];\n            if(next_x < 0 || next_x >= w) continue;\n            if(next_y < 0 || next_y >= h) continue;\n            if(d[next_x][next_y][ori] > d[s.x][s.y][s.ori] + cost){\n                d[next_x][next_y][ori] = d[s.x][s.y][s.ori] + cost;\n                q.push(state(d[next_x][next_y][ori], next_x, next_y, ori));\n            }\n        }\n    }\n\n    int ans = INT_MAX;\n\n    for(int e : d[w-1][h-1]) ans = min(ans, e);\n\n    return ans;\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(!w) break;\n        Matrix<int> m(w, vector<int>(h));\n\n        for(int i = 0; i < h; ++i)\n            for(int j = 0; j < w; ++j)\n                cin >> m[j][i];\n\n        for(int i = 0; i < 4; ++i) cin >> c[i];\n\n        cout << dijkstra(m) << endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int &src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nmain {\n  int w, h;\n  while (cin >> w >> h, w) {\n    vvi v(h, vi(w));\n    cin >> v;\n    vi c(4);\n    cin >> c;\n    Graph g(h * w * 4);\n    vi di = {0, 1, 0, -1}, dj = {1, 0, -1, 0};\n    rep(i, h) rep(j, w) rep(k, 4) {\n      int t = (k + v[i][j]) % 4;\n      rep(l, 4) {\n        int z = (k + l) % 4;\n        int ni = i + di[z], nj = j + dj[z];\n        if (ni < 0 || nj < 0 || ni >= h || nj >= w) continue;\n        g.addArc(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + z, (z == t && v[i][j] != 4) ? 0 : c[l]);\n      }\n    }\n    vi dist = dijkstra<INF>(g, 0).first;\n    int mini = INF;\n    rep(k, 4) cmin(mini, dist[h * w * 4 - 1 - k]);\n    cout << mini << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define INF 1e8\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nstruct state{\n\tint cost;\n\tint x, y;\n\tint dir;\n\tstate(int _x, int _y, int _dir, int _cost) : x(_x), y(_y), dir(_dir), cost(_cost){}\n\tbool operator < (const state &r)const{\n\t\treturn cost > r.cost;\n\t}\n};\n\n\nint main(void){\n\tint w, h;\n\twhile(cin >> w >> h, w){\n\t\tint mem[35][35][4];\n\t\tint grid[35][35];\n\t\tint c[4];\n\t\tfor(int i = 0; i <= h; i++)\n\t\t\tfor(int j = 0; j <= w; j++)\n\t\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t\t\tmem[i][j][k] = INF;\n\t\tfor(int i = 0; i <= h+1; i++)\n\t\t\tfor(int j = 0; j <= w+1; j++)\n\t\t\t\tgrid[i][j] = INF;\n\t\t\n\t\tfor(int i = 1; i <= h; i++)\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> grid[i][j];\n\t\tfor(int i = 0; i < 4; i++) cin >> c[i];\n\t\tint mincost = INF;\n\t\tpriority_queue<state> pq;\n\t\tpq.push(state(1,1,1,0));\n\t\twhile(!pq.empty()){\n\t\t\tstate P = pq.top(); pq.pop();\n//\t\t\tcout << P.x << \":\" << P.y << \"->\" << P.cost << endl;\n\t\t\tif(P.y == h && P.x == w){\n\t\t\t\tmincost = min(mincost, P.cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(grid[P.y][P.x] == INF) continue;\n\t\t\tif(grid[P.y][P.x] != 4){\n\t\t\t\tint nd = (P.dir + grid[P.y][P.x]) % 4;\n\t\t\t\tint nx = P.x + dx[nd];\n\t\t\t\tint ny = P.y + dy[nd];\n\t\t\t\tif(mem[ny][nx][nd] > P.cost){\n\t\t\t\t\tmem[ny][nx][nd] = P.cost;\n\t\t\t\t\tpq.push(state(nx, ny, nd, P.cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nd = (P.dir + i) % 4;\n\t\t\t\tint nx = P.x + dx[nd];\n\t\t\t\tint ny = P.y + dy[nd];\n\t\t\t\t\n\t\t\t\tif(mem[ny][nx][nd] > P.cost + c[i]){\n\t\t\t\t\tmem[ny][nx][nd] = P.cost + c[i];\n\t\t\t\t\tpq.push(state(nx, ny, nd, P.cost + c[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mincost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct Edge { int to, cost; };\n\ntemplate<class T, class Edge> V<T> dijkstra(const VV<Edge>& g, int s = 0) {\n  V<T> dist(g.size(), numeric_limits<T>::max());\n  using P = pair<T, int>;\n  priority_queue< P, V<P>, greater<P> > pque;\n  pque.emplace(dist[s] = 0, s);\n  while (!pque.empty()) {\n    T d; int v;\n    tie(d, v) = pque.top(); pque.pop();\n    if (d > dist[v]) continue;\n    for (const auto& e : g[v]) if (dist[v] + e.cost < dist[e.to]) {\n      pque.emplace(dist[e.to] = dist[v] + e.cost, e.to);\n    } \n  }\n  return dist;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int w, h; cin >> w >> h;\n    if (!w) break;\n    VV<> s(h, V<>(w)); for (auto&& v : s) for (auto&& e : v) cin >> e;\n    V<> c(4); for (auto&& e : c) cin >> e;\n    V<> di{0, 1, 0, -1}, dj{1, 0, -1, 0};\n    auto in = [&](int i, int j) -> bool { return 0 <= i and i < h and 0 <= j and j < w; };\n    auto _ = [&](int i, int j) -> int { return i * w + j; };\n    VV<Edge> g(4 * h * w);\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) for (int k = 0; k < 4; ++k) {\n      for (int x = 0; x < 4; ++x) {\n        int ni = i + di[k + x & 3], nj = j + dj[k + x & 3];\n        if (!in(ni, nj)) continue;\n        g[_(i, j) << 2 | k].emplace_back(Edge{_(ni, nj) << 2 | k + x & 3, x != s[i][j] ? c[x] : 0});\n      }\n    }\n    auto d = dijkstra<int>(g, 0);\n    int res = 1e9;\n    for (int k = 0; k < 4; ++k) res = min(res, d[_(h - 1, w - 1) << 2 | k]);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,c[4],s[30][30],cost[30][30][4],*g;\nvoid rec(int y,int x,int d){\n\trep(r,4){\n\t\tint nd=d+r&3,ny=y+dy[nd],nx=x+dx[nd],nc=cost[y][x][d]+(r==s[y][x]?0:c[r]);\n\t\tif(ck(ny,h)&&ck(nx,w)&&cost[ny][nx][nd]>nc)cost[ny][nx][nd]=nc,rec(ny,nx,nd);\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w){\n\t\t\trep(k,4)cost[i][j][k]=INF;\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\trep(i,4)cin>>c[i]; cost[0][0][0]=0;\n\t\trec(0,0,0); g=cost[h-1][w-1];\n\t\tcout<<(g[0]>g[1]?g[1]:g[0])<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define INF (1<<29)\n#define Cost first.first\n#define Dir first.second\n#define X second.first\n#define Y second.second\n\nusing namespace std;\n\ntypedef pair<int,int> p2;\ntypedef pair<p2,p2> p4;\n\nint w,h,g[4][31][31],s[31][31],c[4];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint dijkstra(){\n\n  priority_queue<p4,vector<p4>, greater<p4> >que;\n\n  fill(*g[0],*g[4],INF);\n  g[0][0][0]=0;\n  \n  p4 st = p4(p2(0,0),p2(0,0));\n  que.push(st);\n\n  bool fg=false;\n\n  while(!que.empty()){\n    p4 now = que.top();\n    que.pop();\n\n    if(now.Y==h-1 && now.X==w-1)return now.Cost;    \n    if(g[now.Dir][now.Y][now.X]<=now.Cost && fg)continue;\n    fg=true;\n    g[now.Dir][now.Y][now.X]=now.Cost;\n    \n    rep(d,4){\n      p4 next;\n      next.Dir=(now.Dir+d)%4;\n      next.X=now.X+dx[next.Dir],next.Y=now.Y+dy[next.Dir];\n      if(0<=next.X && next.X<w && 0<=next.Y && next.Y<h){\n\tnext.Cost=now.Cost+c[d]*(s[now.Y][now.X]!=d);\n\tque.push(next);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  \n  while(cin >> w >> h,w|h){\n    rep(i,h)rep(j,w)cin >> s[i][j];\n    rep(i,4)cin >> c[i];\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, std::numeric_limits<T>::max());\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int w, h; cin >> w >> h;\n    if(w == 0) break;\n    vvi s(h, vi(w));\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        cin >> s[i][j];\n      }\n    }\n    vi c(4);\n    for(int i=0;i<4;++i) {\n      cin >> c[i];\n    }\n    Graph<int> g(4*h*w);\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        for(int k=0;k<4;++k) {\n          for(int l=0;l<4;++l) {\n            if(!(0 <= i+dx[l] && i+dx[l] < h && 0 <= j+dy[l] && j+dy[l] < w)) continue;\n            int diff = (l + 4 - k) % 4;\n            if(s[i][j] == diff) {\n              g[4*w*i + 4*j + k].push_back(Edge<int>(4*w*i + 4*j + k, 4*w*(i+dx[l]) + 4*(j+dy[l]) + l, 0));\n            } else {\n              g[4*w*i + 4*j + k].push_back(Edge<int>(4*w*i + 4*j + k, 4*w*(i+dx[l]) + 4*(j+dy[l]) + l, c[diff]));\n            }\n          }\n        }\n      }\n    }\n    vector<int> dist = dijkstra(g, 0);\n    cout << min(dist[(int)(dist.size())-3], dist[(int)(dist.size())-4]) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nstruct edge\n{\n\tint to, cost;\n\tedge(){};\n\tedge(int to, int cost) : to(to), cost(cost){};\n};\n\nint dat[50][50];\nint c[4];\n\nint dist[50][50][4];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\trep(i, h) rep(j, w) dat[i][j] = in.nextInt();\n\t\trep(i, 4) c[i] = in.nextInt();\n\t\trep(i, 50) rep(j, 50) rep(k, 4) dist[i][j][k] = (i == 0 && j == 0 && k == 0 ? 0 : INF);\n\t\t\n\t\tauto dijkstra = [&]{\n\t\t\ttypedef pair<pii, pii> P;\n\t\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\t\tq.push({{0, 0}, {0, 0}});\n\t\t\tP p;\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tint cost = p.fi.fi, dir = p.fi.se, y = p.se.fi, x = p.se.se;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint ndir = (dir + i) % 4;\n\t\t\t\t\tint nx = x + dx[ndir], ny = y + dy[ndir];\n\t\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t\tint nc = (i == dat[y][x] ? 0 : c[i]);\n\t\t\t\t\tif(dist[ny][nx][ndir] <= cost + nc) continue;\n\t\t\t\t\tdist[ny][nx][ndir] = cost + nc;\n\t\t\t\t\tq.push({{cost + nc, ndir}, {ny, nx}});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\t\n\t\tint ans = INF;\n\t\trep(i, 4) ans = min(ans, dist[h-1][w-1][i]);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t\t// for(int  k = 0; k < 4; k++){\n\t\t// \tfor(int i = 0; i < h; i++){\n\t\t// \t\tfor(int j = 0; j < w; j++){\n\t\t// \t\t\tint t = dist[i][j][k];\n\t\t// \t\t\tif(t == INF) t = -1;\n\t\t// \t\t\tprintf(\" %3d\", t);\n\t\t// \t\t}\n\t\t// \t\tcout<<endl;\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//49\n#include<iostream>\n#include<utility>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct P{\n  int x,y,d;\n  bool operator<(P a)const{\n    return false;\n  }\n};\n\ntypedef pair<int,P> CP;\n\nint main(){\n  for(int h,w;cin>>w>>h,h|w;){\n    int g[30][30];\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n      }\n    }\n    int c[4];\n    for(int i=0;i<4;i++){\n      cin>>c[i];\n    }\n    bool p[30][30][4]={{{}}};\n    priority_queue<CP,vector<CP>,greater<CP> > que;\n    P ip={0,0,0};\n    que.push(make_pair(0,ip));\n    for(;;){\n      P cs=que.top().second;\n      int ct=que.top().first;\n      if(cs.x==w-1&&cs.y==h-1)break;\n      que.pop();\n      if(p[cs.y][cs.x][cs.d]++)continue;\n      for(int i=0;i<4;i++){\n\tint dy[]={0,1,0,-1};\n\tint dx[]={1,0,-1,0};\n\tint ny=cs.y+dy[i];\n\tint nx=cs.x+dx[i];\n\tif(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t  P np={nx,ny,i};\n\t  int o=(i-cs.d+4)%4;\n\t  que.push(make_pair(ct+((o==g[cs.y][cs.x])?0:c[o]),np));\n\t}\n      }\n    }\n    cout<<que.top().first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <limits.h>\n#include <bitset>\n\n#include <tuple>\n#include <unordered_map>\n\n#define mp       make_pair\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint w,h;\nint board[40][40];\nint cost[5];\nint dir;\nint gy,gx;\nint cboard[40][40][4];\nint main(){\n\twhile(cin >> w >> h){\n\t\tdir = 0;\n\t\tgy = h, gx = w;\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 0; i < 40; i++){\n\t\t\tfor (int j = 0; j < 40; j++){\n\t\t\t\tboard[i][j] = -1;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tcboard[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcboard[1][1][0] = 0;\n\t\tif (w == 0 || h == 0)break;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tcin >> cost[i];\n\t\t}\n\t\tint cnt = 0;\n\t\twhile(cnt <= 3000){\n\t\tfor (int i = 1; i <= h; i++){//y\n\t\t\tfor (int j = 1; j <= w; j++){//x\n\t\t\t\tfor (int k = 0; k < 4; k++){//dir\n\t\t\t\t\tif (i == h && j == w){\n\t\t\t\t\t\tans = min(ans, cboard[i][j][k]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//no\n\t\t\t\t\t\tif (board[i][j] == 0){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 1){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 2){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 3){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//straight\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][0] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][1] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][2] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][3] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//right\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][0] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][1] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][2] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][3] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//back\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][0] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][1] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][2] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][3] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//left\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][0] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][1] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][2] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][3] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\t// for (int k = 0; k < 4; k++){\n\t\t\t// \tans = min(ans, cboard[h][w][k]);\n\t\t\t// }\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint h,w,c[4];\nint map[40][40];\nint memo[40][40][4];\n\nclass State{\npublic:\n  int y,x,muki,cost;\n  State(int y,int x,int muki,int cost):y(y),x(x),muki(muki),cost(cost){}\n};\n\nbool in(int y,int x)\n{\n  if(y<0 || x<0 || y>=h || x>=w)return false;\n  return true;\n}\n\nint main()\n{\n  queue<State> Q;\n  while(1){\n    cin>>w>>h;\n    if(h+w==0)break;\n\n    for(int i=0;i<40;i++){\n      for(int j=0;j<40;j++){\n\tfor(int k=0;k<4;k++)memo[i][j][k]=inf;\n      }\n    }\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>map[i][j];\n    for(int k=0;k<4;k++)cin>>c[k];\n\n    Q.push(State(0,0,1,0));\n    int ans=inf;\n    memo[0][0][1]=0;\n    while(!Q.empty()){\n      State u=Q.front();\n      Q.pop();\n      //      cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.cost<<endl;\n      if(u.y==h-1 && u.x==w-1){\n\tans=min(ans,u.cost);\n\tcontinue;\n      }\n\n      for(int k=0;k<4;k++){\n\tint mk=(u.muki+k)%4;\n\tint a=u.y+Y[mk],b=u.x+X[mk];\n        if(!in(a,b))continue;\n\tif(k==map[u.y][u.x]){\n\t  if(memo[a][b][mk]>u.cost){\n\t    memo[a][b][mk]=u.cost;\n\t    Q.push(State(a,b,mk,u.cost));\n\t  }\n\t}\n\telse {\n          if(memo[a][b][mk]>u.cost+c[k]){\n\t    memo[a][b][mk]=u.cost+c[k];\n\t    Q.push(State(a,b,mk,u.cost+c[k]));\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost>right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4];\n      int ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(d[ny][nx][ndir]>cost+c[i]){\n\td[ny][nx][ndir]=cost+c[i];\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n      if(data[y][x]!=i) continue;\n      if(d[ny][nx][ndir]>cost){\n\td[ny][nx][ndir]=cost;\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n    }\n  }\n  cout<<min(d[h-1][w-1][1],d[h-1][w-1][2])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\ntypedef pair < int , pair<pair<int , int> , int> > P;\n\n//0 ??????1?????????2?????????3??????\n\nint dx[] = { 1 , 0 , -1 , 0 };\nint dy[] = { 0 , 1 , 0 , -1 };\n\nint main ()\n{\n\tint W , H;\n\twhile( cin >> W >> H , W || H )\n\t{\n\t\tvector<vector<int>>data;\n\t\tvector<vector<vector<int>>>M;\n\t\tdata.resize ( H );\n\t\tM.resize ( H );\n\t\tfor( size_t i = 0; i < H; i++ )\n\t\t{\n\t\t\tM[i].resize ( W );\n\t\t\tdata[i].resize ( W );\n\t\t\tfor( size_t j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tM[i][j].resize ( 4 );\n\t\t\t\tfor( size_t k = 0; k < 4; k++ )\n\t\t\t\t{\n\n\t\t\t\tM[i][j][k] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint C[4] = {};\n\t\tfor( size_t i = 0; i < 4; i++ )\n\t\t{\n\t\t\tcin >> C[i];\n\t\t}\n\t\tpriority_queue<P , vector<P> , greater<P>>que;\n\t\tlong long int ans = -1;\n\t\tque.push ( P{ 0 , pair < pair<int , int> , int > {pair < int , int > {0 , 0} , 0} } );\n\t\tM[0][0][0] = 0;\n\t\twhile( !que.empty () )\n\t\t{\n\t\t\tP now = que.top (); que.pop ();\n\t\t\tint nowcost = now.first;\n\t\t\tint nowx = now.second.first.second;\n\t\t\tint nowy = now.second.first.first;\n\t\t\tint nowd = now.second.second;\n\n\t\t\t//cout << nowx << \" \" << nowy << \" \" << nowcost << endl;\n\n\t\t\t/*if( nowy == H - 1 && nowx == W - 1 )\n\t\t\t{\n\t\t\t\tans = nowcost;\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t\t//if( data[nowy][nowx] == 4 )continue;\n\t\t\tfor( size_t i = 0; i < 4; i++ )\n\t\t\t{\n\t\t\t\tint nextd = ( i + nowd ) % 4;\n\t\t\t\tint nextx = nowx + dx[nextd];\n\t\t\t\tint nexty = nowy + dy[nextd];\n\t\t\t\tif( nextx < 0 || nextx >= W || nexty < 0 || nexty >= H )continue;\n\t\t\t\tif( i == data[nowy][nowx] )\n\t\t\t\t{\n\t\t\t\t\tif( M[nexty][nextx][i]>nowcost )\n\t\t\t\t\t{\n\t\t\t\t\t\tM[nexty][nextx][i] = nowcost;\n\t\t\t\t\t\tque.push ( P{ nowcost , pair < pair<int , int> , int > {pair < int , int > {nexty , nextx} , nextd} } );\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif( M[nexty][nextx][i] > nowcost + C[i] )\n\t\t\t\t\t{\n\t\t\t\t\t\tM[nexty][nextx][i] = nowcost + C[i];\n\t\t\t\t\t\tque.push ( P{ nowcost + C[i] , pair < pair<int , int> , int > {pair < int , int > {nexty , nextx} , nextd} } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tint ans2 = INT_MAX;\n\t\tfor( size_t i = 0; i < 4; i++ )\n\t\t{\n\t\t\tans2 = min ( ans2 , M[H - 1][W - 1][i] );\n\t\t}\n\t\tcout << ans2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n#define H 30\n#define W 30\n#define N 4\n#define INF 10000\nint w, h;\nint board[H][W];\nint C[N];\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[H][W][N];\n    int dx[N] = {1, 0, -1, 0};\n    int dy[N] = {0, 1, 0, -1};\n    bool used[H][W][N];\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < N; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    d[0][0][0] = 0;\n    while (true) {\n        int x = -1, y, z;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < N; k++) {\n                    if (!used[i][j][k] && (x == -1 || d[i][j][k] < d[y][x][z])) {\n                        y = i; x = j; z = k;\n                    }\n                }\n            }\n        }\n        if (x == -1) {\n            break;\n        }\n        used[y][x][z] = true;\n        for (int i = 0; i < N; i++) {\n            int mx = x + dx[i];\n            int my = y + dy[i];\n            if (invalid(mx, my)) {\n                continue;\n            }\n            int k;\n            for (int j = 0; j < N; j++) {\n                if ((z + j) % N == i) {\n                    k = j;\n                    break;\n                }\n            }\n            if (board[y][x] == 4) {\n                d[my][mx][i] = min(d[my][mx][i], d[y][x][z] + C[k]);\n                continue;\n            }\n            if (board[y][x] == k) {\n                d[my][mx][i] = min(d[my][mx][i], d[y][x][z]);\n            }\n            else {\n                d[my][mx][i] = min(d[my][mx][i], d[y][x][z] + C[k]);\n            }\n        }\n    }\n    int ans = INF;\n    for (int i = 0; i < N; i++) {\n        ans = min(ans, d[h-1][w-1][i]);\n    }\n    return ans;\n}\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> board[i][j];\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            cin >> C[i];\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1156\n// Twirling Robot\n// 2016/6/9\n\n#include<iostream>\n#include<vector>\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX_W_H 30\n#define INF 1000000\nusing namespace std;\n\n// ??????:[0] = E, [1] = S, [2] = W, [3] = N\n// ??????:[0] = Straight, [1] = Right, [2] = Back, [3] = Left\nint f[4][4] = {{0, 1, 2, 3}, {3, 0, 1, 2}, {2, 3, 0, 1}, {1, 2, 3, 0}}; // [?¬???????????????????][???????????????????????????] = ???????????????\n\n// ??????(i, j, k) == ???????????????(j, i)??????????????????????????????k????????????????????¶???\n\nint w, h;\nint map[MAX_W_H][MAX_W_H];\nint d[MAX_W_H][MAX_W_H][4];\t// ??????(0, 0, 0)?????????????°??????????\nint instr_cost[4];\t\t// ?????????????????????\nbool used[MAX_W_H][MAX_W_H][4];\t// ?????§?????????????????????????????°\n\nbool in_map(int x, int y)\n{\n  return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nvoid dijkstra(void)\t\t// ??????(0, 0, 0)?????????????????????????°???????????±???????\n{\n  int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; // [0]=E, [1]=S, [2]=W, [3]=N\n  while(true)\n    {\n      int x = -1, y = -1, di = -1;\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++) \n\t  for(int k = 0; k < 4; k++)// ???????????????????????? and ?§?????????????????????????????°??????? == ???????????¢????¢????????????????\n\t    if(!used[i][j][k] && ((x == -1 && y == -1 && di == -1) || (d[i][j][k] < d[y][x][di])))\n\t      x = j, y = i, di = k;\n\n      if(x == -1 && y == -1 && di == -1)\n\tbreak;\n\n      used[y][x][di] = true;\n\n      // ??????(y, x, di)??¨??£??\\???????????????\"?§??????????????????¢\"?????´??°\n      for(int i = 0; i < 4; i++)\n\t{\n\t  int xx = x + dir[i][0];\n\t  int yy = y + dir[i][1];\n\t  int c;\n\t  if(!in_map(xx, yy))\n\t    continue;\n\n\t  int inst = f[di][i]; // d = ??????(x, y)????????????????????????, i = ??????(x, y)??????????????????(xx, yy)?????????, inst = ?§??????????????????????\n\t  if(inst == map[y][x])\n\t    c = 0;\n\t  else\n\t    c = instr_cost[inst];\n\n\t  d[yy][xx][i] = min(d[yy][xx][i], d[y][x][di] + c);\n\t}\n    }\n}\n\nint main(void)\n{\n  int ans = INF;\n  while(cin >> w >> h, (w && h))\n    {\n      for(int i = 0; i < MAX_W_H; i++)\n\tfor(int j = 0; j < MAX_W_H; j++)\n\t  for(int k = 0; k < 4; k++)\n\t    {\n\t      d[i][j][k] = INF;\n\t      used[i][j][k] = false;\n\t    }\n\n\n      d[0][0][0] = 0;\n\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  cin >> map[i][j];\n\n      for(int i = 0; i < 4; i++)\n\tcin >> instr_cost[i];\n\n      dijkstra();\n\n\n      for(int i = 0; i < 4; i++)\n\tans = min(ans, d[h - 1][w - 1][i]);\n\n      cout << ans << endl;\n\n      ans = INF;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n\nint W,H;\n\nint S[50][50];\nint C[5];\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n#define INF 1e9\n\nint dijkstra(){\n    int dist[H+1][W+1][5]={};\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<=4;k++){\n                dist[i][j][k]=INF;\n            }\n        }\n    }\n\n    dist[0][0][0]=0;\n    priority_queue<tuple<int,int,int,int>> PQ;\n    PQ.push(make_tuple(0,0,0,0));\n    while(!PQ.empty()){\n        int cost;\n        int x,y,d;\n        auto f=PQ.top();\n        PQ.pop();\n        cost=-get<0>(f);\n        x=get<1>(f);\n        y=get<2>(f);\n        d=get<3>(f);\n\n        if(dist[x][y][d]<cost) continue;\n        \n        if(x==H-1&&y==W-1) return cost;\n\n        for(int i=0;i<4;i++){\n            int nd=(d+i)%4;\n            int neco=0;\n            if(S[x][y]!=i) neco=C[i];\n\n            int nx=x+dx[nd];\n            int ny=y+dy[nd];\n\n            if(nx<0||nx>=H||ny<0||ny>=W) continue;\n            if(dist[nx][ny][nd]>dist[x][y][d]+neco){\n                dist[nx][ny][nd]=dist[x][y][d]+neco;\n                PQ.push(make_tuple(-dist[nx][ny][nd],nx,ny,nd));\n            }\n        }\n\n    }\n}\n\nvoid solve(){\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) cin>>S[i][j];\n    for(int i=0;i<4;i++) cin>>C[i];\n\n    cout<<dijkstra()<<endl;\n}\n\nint main(){\n    while(1){\n        cin>>W>>H;\n        if(H==0&&W==0) break;\n        solve();\n    }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//SPFA\n#include <cstdio>\n#include <cstring>\n#include<queue>\nusing namespace std;\n#define INF (10*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nint main(){\n\tqueue<Node> que;\n\tint inQ[30][30][4],dst[30][30][4];\n\tint head,tail;\t\n\tNode a,b;\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\twhile(!que.empty())que.pop();\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque.push(a);\n\t\twhile(head<tail){\n\t\t\ta=que.front();\n\t\t\tqu.pop();\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\tqu.push(b);\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\t\tqu.push(b);\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nstruct state{\n  int x,y,cost,dir;\n  state(int x,int y,int cost, int dir) :\n    x(x), y(y), cost(cost), dir(dir) {}\n};\nbool operator < (const state &u, const state &s){\n  return u.cost > s.cost;\n}\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint main(void){\n  int w,h;\n  int c[4];\n  int m[31][31];\n  while(cin>>w>>h,w&&h){\n    int shortest[31][31][4];\n    memset(shortest,-1,sizeof(shortest));\n    REP(y,h)REP(x,w)cin>>m[y][x];\n    REP(i,4)cin>>c[i];\n    priority_queue<state> que;\n    que.push(state(0,0,0,0));\n    while(!que.empty()){\n      state s = que.top(); que.pop();\n      if(shortest[s.y][s.x][s.dir]!=-1&&shortest[s.y][s.x][s.dir]<=s.cost){\n        continue;\n      }else{\n        shortest[s.y][s.x][s.dir] = s.cost;\n      }\n      if(s.x==w-1&&s.y==h-1){\n        cout<<s.cost<<endl;\n        break;\n      }\n      REP(r,4){\n        int nx = s.x + dx[s.dir];\n        int ny = s.y + dy[s.dir];\n        if(0<=nx&&0<=ny&&nx<w&&ny<h){\n          if(m[s.y][s.x]==r){\n            que.push(state(nx,ny,s.cost,s.dir));\n          }else{\n            que.push(state(nx,ny,s.cost+c[r],s.dir));\n          }\n        }\n        s.dir = (s.dir+1)%4;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define MAX_H 30\n#define MAX_W 30\n#define INF (1<<29)\n\nstruct State{\n  int cost,x,y,dir;\n  State(int cost,int x,int y,int dir) :\n    cost(cost),x(x),y(y),dir(dir) {}\n\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint H,W,c[4];\nint s[MAX_H][MAX_W];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint dijkstra(){\n  int d[MAX_H][MAX_W][4];\n  fill(d[0][0],d[0][0]+MAX_H*MAX_W*4,INF);\n  d[0][0][2] = 0;\n  priority_queue<State> Q;\n  Q.push(State(0,0,0,2));\n  while(!Q.empty()){\n    State cur = Q.top(); Q.pop();\n    int x = cur.x,y = cur.y,dir = cur.dir;\n    if(d[y][x][dir] < cur.cost) continue;\n    if(x == W-1 && y == H-1) return d[y][x][dir];\n    for(int i = 0 ; i < 4 ; i++){\n      int ndir = (dir+i)%4;\n      int nx = x + dx[ndir];\n      int ny = y + dy[ndir];\n      if(!inField(nx,ny)) continue;\n      if(s[y][x] == i){\n        if(d[y][x][dir] < d[ny][nx][ndir]){\n          d[ny][nx][ndir] = d[y][x][dir];\n          Q.push(State(d[ny][nx][ndir],nx,ny,ndir));\n        }\n      }else{\n        if(d[y][x][dir] + c[i] < d[ny][nx][ndir]){\n          d[ny][nx][ndir] = d[y][x][dir] + c[i];\n          Q.push(State(d[ny][nx][ndir],nx,ny,ndir));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> s[i][j];\n      }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n      cin >> c[i];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAX = 31;\nint w, h;\nint costs[4];\nint brd[MAX][MAX];\n\nenum { EAST = 0, SOUTH, WEST, NORTH };\nenum { STRAIGHT = 0, RIGHT, BACK, LEFT };\n\n// east, south, west, north\nint dy[4] = { 0, 1, 0, -1 };\nint dx[4] = { 1, 0, -1, 0 };\n\nclass State {\npublic:\n  int x, y, d, c;\n\n  State(int x, int y, int d, int c):x(x), y(y), d(d), c(c) {}\n\n  bool operator>(const State &a) const {\n    return c > a.c;\n  }\n};\n\nint dijkstra()\n{\n  int dist[MAX][MAX][4];\n  priority_queue<State, vector<State>, greater<State> > que;\n  que.push(State(0, 0, EAST, 0));\n  fill(dist[0][0], dist[MAX][0], INF);\n  dist[0][0][EAST] = 0;\n  while (!que.empty()) {\n    State s = que.top(); que.pop();\n    if (dist[s.y][s.x][s.d] < s.c) continue;\n    if (s.x == w-1 && s.y == h-1) return s.c;\n    for (int i = 0; i < 4; i++) {\n      int nx, ny, nd, nc;\n      nd = (s.d+i)%4;\n      nx = s.x + dx[nd];\n      ny = s.y + dy[nd];\n      nc = s.c + (i == brd[s.y][s.x]?0:costs[i]);\n      if (!(0 <= nx && nx < w)) continue;\n      if (!(0 <= ny && ny < h)) continue;\n      if (dist[ny][nx][nd] > nc) {\n        que.push(State(nx, ny, nd, nc));\n        dist[ny][nx][nd] = nc;\n      }\n    }\n  }\n\n  assert(false);\n  return -1;\n}\n\nint main()\n{\n  while (cin >> w >> h, w|h) {\n    for (int i = 0; i < h; i++)\n      for (int j = 0; j < w; j++)\n        cin >> brd[i][j];\n\n    for (int i = 0; i < 4; i++)\n      cin >> costs[i];\n\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define lp(i,n) for(int i=0;i<n;i++)\n#define INF (1<<28)\nint w,h;\n//x y direction\nvector<vector<vector<int> > > dp;\nvector<vector<int> > mp;\nint cost[4];\nint mx[]={1,0,-1,0},my[]={0,1,0,-1};\n\nclass point{\n   public:\n   int x;\n   int y;\n   int time;\n   int dir;\n   point(int a,int b,int c,int d):x(a),y(b),time(c),dir(d){}\n};\n\nbool operator<(const point &a,const point &b){\n   return a.time < b.time;\n}\nbool operator>(const point &a,const point &b){\n   return a.time > b.time;\n}\nbool operator==(const point &a,const point &b){\n   return a.time == b.time;\n}\nint func(){\n   dp.clear();\n   mp.clear();\n   dp.resize(30);\n   mp.resize(30);\n   lp(i,30){\n      mp[i].resize(30);\n      dp[i].resize(30);\n      lp(j,30){\n         dp[i][j].resize(4,INF);\n      }\n   }\n   lp(y,h){\n      lp(x,w){\n         cin >> mp[y][x];\n      }\n   }\n   lp(i,4){\n      cin >> cost[i];\n   }\n   priority_queue<point,vector<point>,greater<point> > que;\n   que.push(point(0,0,0,0));\n   dp[0][0][0]=0;\n   while(!que.empty()){\n      point d = que.top();\n      que.pop();\n      if(dp[d.y][d.x][d.dir]!=d.time)continue;\n      lp(i,4){\n         int ndir = (d.dir + i) % 4;\n         point nd = point(d.x + mx[ndir],d.y + my[ndir],d.time + (i==mp[d.y][d.x]?0:cost[i]),ndir);\n         if(nd.x < 0 || nd.x == w || nd.y < 0 || nd.y == h)continue;\n         if(dp[nd.y][nd.x][nd.dir] <= nd.time)continue;\n         dp[nd.y][nd.x][nd.dir] = nd.time;\n         que.push(nd);\n      }\n   }\n   int res = dp[h-1][w-1][0];\n   lp(i,4){\n      res = min(res,dp[h-1][w-1][i]);\n   }\n   return res;\n}\nint main(){\n   while(cin >> w >> h && w){\n      cout << func() << endl;\n/*      lp(y,h){\n         lp(x,w){\n            int count = 1<<20;\n            lp(k,4){\n               if(dp[x][y][k]!=-1)\n                  count = min(count,dp[x][y][k]);\n            }\n            cout << count << \" \";\n         }\n         cout << endl;\n      }*/\n   }\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<queue>\n#define INF 100000\n\nint w,h,m[30][30],costmap[30][30][4],c[4],ans;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool check[30][30][4];\n\nstruct State{\n\tint x,y,d,cost;\n};\n\nbool operator < (State x,State y){\n\treturn x.cost>y.cost;\n}\n\nvoid solve()\n{\n\tans=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>m[i][j];\n\t\t\tfor(int z=0;z<4;z++){\n\t\t\t\tcostmap[i][j][z]=INF;\n\t\t\t\tcheck[i][j][z]=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)\n\t\tcin>>c[i];\n\n\tState first;\n\tfirst.x=0;\n\tfirst.y=0;\n\tfirst.d=0;\n\tfirst.cost=0;\n\tcostmap[0][0][0]=0;\n\n\tpriority_queue<State> Q;\n\tQ.push(first);\n\n\tState temp;\n\twhile(!Q.empty()){\n\t\ttemp=Q.top();\n\t\tQ.pop();\n\t\tif(temp.x==w-1 && temp.y ==h-1){\n\t\t\tans=temp.cost;\n\t\t\treturn;\n\t\t}\n\t\tif(check[temp.y][temp.x][temp.d]==true)\n\t\t\tcontinue;\n\t\tcheck[temp.y][temp.x][temp.d]=true;\n\t\tfor(int s=0;s<4;s++){\n\t\t\tState temp2=temp;\n\t\t\tif(m[temp2.y][temp2.x]!=s)\n\t\t\t\ttemp2.cost+=c[s];\n\t\t\tint nextd=(s+temp2.d)%4;\n\t\t\ttemp2.x+=dx[nextd];\n\t\t\ttemp2.y+=dy[nextd];\n\t\t\ttemp2.d=nextd;\n\t\t\tif(temp2.x<0 || temp2.y<0 || temp2.x>=w || temp2.y>=h)\n\t\t\t\tcontinue;\n\t\t\tif(check[temp2.y][temp2.x][temp2.d]==true)\n\t\t\t\tcontinue;\n\t\t\tif(temp2.cost<costmap[temp2.y][temp2.x][temp2.d]){\n\t\t\t\tcostmap[temp2.y][temp2.x][temp2.d]=temp2.cost;\n\t\t\t\tQ.push(temp2);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"error\\n\";\n}\n\n\n\nint main()\n{\n\tcin>>w>>h;\n\twhile(w!=0){\n\t\tsolve();\n\t\tcout<<ans<<\"\\n\";\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, 1, 0, -1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nint main()\n{\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\t\tint b[50][50];\n\t\tint d[50][50][4];\n\t\tFill(d, INF);\n\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> b[y][x];\n\t\t}\n\t\tint c[4];\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\n\t\td[0][0][0] = 0;\n\t\tqueue<T> q;\n\t\tq.push(T(0, 0, 0));\n\t\twhile (q.size()){\n\t\t\tint y = get<0>(q.front()), x = get<1>(q.front()), dir = get<2>(q.front());\n\t\t\tq.pop();\n\t\t\trep(i, 4){\n\t\t\t\tint cost = c[i];\n\t\t\t\tif (b[y][x] == i)cost = 0;\n\t\t\t\tint nd = (dir + i) % 4;\n\t\t\t\tint ty = y + dy[nd], tx = x + dx[nd];\n\t\t\t\tif (cheak(tx, ty, w, h) and d[ty][tx][nd] > d[y][x][dir] + cost){\n\t\t\t\t\td[ty][tx][nd] = d[y][x][dir] + cost;\n\t\t\t\t\tq.push(T(ty, tx, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 4){\n\t\t\tans = min(ans,d[h - 1][w - 1][i]);\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 500000;\n\nint w, h;\n\nclass C{\n    public:\n        int y, x, cost, type;\n        C(int _y, int _x, int _c, int _t){\n            y = _y;\n            x = _x;\n            cost = _c;\n            type = _t;\n        }\n        bool operator>(const C &c) const{\n            return cost > c.cost;\n        }\n};\n\nbool isOK(int y, int x){\n    if(y < 0 || x < 0 || y >= h || x >= w) return false;\n    return true;\n}\n\nint main(){\n    while(cin >>w >>h && w){\n        vector< vector<int> > v(h, vector<int>(w));\n        REP(i, h) REP(j, w) cin >>v[i][j];\n        int c[4];\n        REP(i, 4) cin >>c[i];\n\n        priority_queue< C, vector<C>, greater<C> > open;\n        open.push( C(0, 0, 0, 1) );\n        vector< vector< vector<int> > > closed(h, vector< vector<int> >(w, vector<int>(4, INF)));\n\n        while(!open.empty()){\n            C now = open.top();\n            open.pop();\n\n            //debug\n            //cout <<now.y <<\", \" <<now.x <<\", \" <<now.cost <<\", \" <<now.type <<endl;\n\n            if(now.cost >= closed[now.y][now.x][now.type]) continue;\n            closed[now.y][now.x][now.type] = now.cost;\n\n            if(now.y == h - 1 && now.x == w - 1){\n                cout <<now.cost <<endl;\n                break;\n            }\n\n            int my[] = {-1, 0, 1, 0};\n            int mx[] = {0, 1, 0, -1};\n\n            REP(i, 4){\n                int next_cost = (i == v[now.y][now.x]? 0 : c[i]);\n                int next_type;\n                //debug\n                //cout <<\"! \" <<i <<\", \" <<next_cost <<\", \" <<now.cost + next_cost <<endl;\n                if(i == 0) next_type = now.type;\n                if(i == 1) next_type = (now.type + 1) % 4;\n                if(i == 2) next_type = (now.type + 2) % 4;\n                if(i == 3) next_type = (now.type + 3) % 4;\n                int ny = now.y + my[next_type], nx = now.x + mx[next_type];\n                if(!isOK(ny, nx)) continue;\n                open.push( C(ny, nx, now.cost + next_cost, next_type) );\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={0,1,0,-1} ,dy[] = {1,0,-1,0};\n\nint h,w;\n\nclass Node{\npublic:\n    int cost,x,y,pre;\n    Node(){}\n    Node(int a,int b,int c,int d){\n        cost = a;\n        x = b;\n        y = c;\n        pre = d;\n    }\n\n    bool operator < (const Node& nd) const{\n        return cost < nd.cost;\n    }\n    bool operator > (const Node& nd) const{\n        return cost > nd.cost;\n    }\n    bool operator == (const Node& nd) const{\n        return cost==nd.cost;\n    }\n\n    void print() const{\n        printf(\"Node : cost(%d) , (x,y)=(%d,%d), pre=%d\\n\",cost,x,y,pre);\n    }\n};\n\nint move(int dir,int m){\n    if(m==0){\n        return dir;\n    }else if(m==1){\n        return (dir+1)%4;\n    }else if(m==2){\n        return (dir+2)%4;\n    }else if(m==3){\n        return (dir-1+4)%4;\n    }else{\n        assert(false);\n    }\n    return -1;\n}\n\nvoid solve(){\n    using P = tuple<int,int,int,int>;\n    vvi s(h,vi(w));\n    vi c(4);\n    rep(i,h) rep(j,w) cin>>s[i][j];\n    rep(i,4) cin>>c[i];\n//    rep(i,h){\n//        rep(j,w) cout << s[i][j];\n//        cout << endl;\n//    }\n//    cout << c << endl;\n\n    int d[32][32][5];\n    rep(i,32) rep(j,32) rep(k,5) d[i][j][k]=INF;\n\n\n    priority_queue<Node,vector<Node>,greater<Node>> que;\n    que.push(Node(0,0,0,0));\n    while(!que.empty()){\n        Node p = que.top();\n        que.pop();\n        int cost=p.cost,x=p.x,y=p.y,pre=p.pre;\n\n        if(x==h-1 and y==w-1){\n            cout << cost << endl;\n            return;\n        }\n\n        rep(i,4){\n            int ndir = move(pre,i);\n            int nx=x+dx[ndir];\n            int ny=y+dy[ndir];\n            if(nx<0 or nx>=h or ny<0 or ny>=w) continue;\n\n            if(i==s[x][y]){\n                if(cost < d[nx][ny][ndir]) {\n                    d[nx][ny][ndir] = cost;\n                    que.push(Node(cost,nx,ny,ndir));\n                }\n            }else{\n                if(cost < d[nx][ny][ndir]){\n                    d[nx][ny][ndir] = cost + c[i];\n                    que.push(Node(cost+c[i],nx,ny,ndir));\n                }\n            }\n        }\n    }\n\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(h==0 and w==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nstruct Node {\n\tint x, y, dir, cost;\n};\nbool operator>(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint C[4];\nint W, H;\nvector< vector<int> > op;\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nvoid f(int x, int y, int dir, int dc, int o, priority_queue<Node, vector<Node>, greater<Node> >& Q, vector< vector< vector<int> > >& dp) {\n\tint nx = x, ny = y, nd = dir;\n\tif (o == 4) {\n\t\tif (x != W-1 || y != H-1) {\n\t\t\treturn;\n\t\t}\n\t}\n\telse {\n\t\tnd = (nd + o) % 4;\n\t\tnx += dx[nd];\n\t\tny += dy[nd];\n\t\tif ( !inRange(nx, ny) ) return;\n\t}\n\tif (dp[y][x][dir]+dc < dp[ny][nx][nd]) {\n\t\tdp[ny][nx][nd] = dp[y][x][dir]+dc;\n\t\tQ.push({nx, ny, nd, dp[ny][nx][nd]});\n\t}\n}\nint solve() {\n//\tcout << \"!\" << C[0] << \" \" << C[1] << \" \" << C[2] << \" \" << C[3] << endl;\n\tvector< vector< vector<int> > > dp(H, vector< vector<int> >(W, vector<int>(4, inf))); dp[0][0][1] = 0;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push({0, 0, 1, 0});\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tint x = node.x, y = node.y, dir = node.dir, cost = node.cost;\n\t\tif (cost < dp[y][x][dir]) continue;\n\t\tf(x, y, dir, 0, op[y][x], Q, dp);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tf(x, y, dir, C[i], i, Q, dp);\n\t\t}\n\t}\n\tint res = inf;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tres = min(res, dp[H-1][W-1][i]);\n\t}\n\treturn res;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile ( cin >> W >> H, W || H ) {\n\t\top = vector< vector<int> >(H, vector<int>(W, 0));\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> op[y][x];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tcin >> C[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n \nint G[SIZE][SIZE], C[4];\nint H, W;\n \nstruct State {\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost>s.cost;\n  }\n};\n \nint solve() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State> pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n     && 0 <= t.y && t.y < H \n     && cost[t.d][t.y][t.x] > t.cost) {\n    pq.push(t);\n    cost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n   \n  return INF;\n}\n \nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n    cin >> G[i][j];\n     \n    for(int i=0; i<4; i++) cin >> C[i];\n     \n    cout << solve() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst ll dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nint main(){\n    ll w,h;\n    ll s[31][31];\n    ll d[5][31][31];\n    ll c[5];\n    while(true){\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tREP(i,h)REP(j,w){\n\t    cin >> s[i][j];\n\t    REP(k,5)\n\t\td[k][i][j] = INF;\n\t}\n\tREP(i,4) cin >> c[i];\n\tc[4] = 0;\n\n\tqueue< pair<ll,ll> > qxy;\n\tqueue<ll> qv;\n\tqueue<ll> qs;\n\tqxy.push(MP(0,0));\n\tqv.push(0);\n\tqs.push(0);\n\twhile(!qxy.empty()){\n\t    ll x = qxy.front().first;\n\t    ll y = qxy.front().second;\n\t    ll v = qv.front();\n\t    ll st = qs.front();\n\t    qxy.pop();\n\t    qv.pop();\n\t    qs.pop();\n\t    REP(i,5){\n\t\tll nx,ny;\n\t\tll nv = v;\n\t\tll nst;\n\t\tif(i != 4 && s[y][x] != 4){\n\t\t    nst = (st+i)%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t    nv = v + c[i];\n\t\t}else{\n\t\t    nst = (st+s[y][x])%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t}\n\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\tif(nv < d[nst][ny][nx]){\n\t\t    d[nst][ny][nx] = nv;\n\t\t    qxy.push(MP(nx,ny));\n// \t\t    prllf(\"x = %d y = %d v = %d s = %d i = %d\\n\",nx,ny,nv,nst,i);\n\t\t    qv.push(nv);\n\t\t    qs.push(nst);\n\t\t}\n\t    }\n\t}\n\tll ans = INF;\n\tREP(i,5) ans = min(ans,d[i][h-1][w-1]);\n\tcout << ans << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint w, h;\nint board[32][32];\nint dist[32][32][4];\nint cost[4];\nint ans;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\ninline bool isGoal(int x, int y) \n{\n    return (x == w - 1 && y == h - 1);\n}\n\ninline bool isInside(int x, int y)\n{\n    return (x >= 0 && y >= 0 && x < w && y < h);\n}\n\nint dfs(int x, int y, int d, int c, int minValue) {\n    if (isGoal(x, y))\n        return c;\n\n    dist[y][x][d] = c;\n    for (int cmd = 0; cmd < 4; cmd++) {\n        int newd = (d + cmd) % 4;\n        int newc = cost[cmd] + c;\n        \n        if (cmd == board[y][x])\n            newc = c;\n        \n        int newx = x + dx[newd];\n        int newy = y + dy[newd];\n\n        if (newc < minValue && isInside(newx, newy) &&\n            dist[newy][newx][newd] > newc) \n            minValue = dfs(newx, newy, newd, newc, minValue);\n    }\n    \n    return minValue;\n}\n\nint main()\n{\n    while (cin >> w >> h, w || h) {\n        // Input\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++) {\n                cin >> board[y][x];\n                for (int d = 0; d < 4; d++)\n                    dist[y][x][d] = INT_MAX;\n            }\n        for (int i = 0; i < 4; i++)\n            cin >> cost[i];\n\n        // solve\n        cout << dfs(0, 0, 0, 0, INT_MAX) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <utility>\n#include <climits>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n// ori: 0 = 右向き, 1 = 下向き, 2 = 左向き, 3 = 上向き\nstruct state{\n    int cost, x, y, ori;\n    state(int c_, int x_, int y_, int ori_) : cost(c_), x(x_), y(y_), ori(ori_){}\n    bool operator<(const state& other) const {\n        return cost < other.cost;\n    }\n};\n\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\nint c[4];\nint w, h;\n// 右下左上\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\n\nint dijkstra(const Matrix<int>& m){\n    priority_queue<state> q;\n    q.push(state(0, 0, 0, 0));\n    // d[x][y][(x, y)にいる時のロボットの向き]\n    Matrix<vector<int>> d(w, vector<vector<int>>(h, vector<int>(4, INT_MAX)));\n    d[0][0][0] = 0;\n\n    while(!q.empty()){\n        state s = q.top();\n        q.pop();\n\n        if(s.x == w-1 && s.y == h-1) continue;\n\n        for(int ope = 0; ope < 4; ++ope){ // 全ての命令を行う\n            int cost = 0;\n            int ori = s.ori;\n            if(ope != m[s.x][s.y]) cost = c[ope];\n            if(ope != 0){ // 向きを変える\n                if(ope == 1) ori = (ori + 1) % 4;// 右折\n                else if(ope == 2) ori = (ori + 2) % 4; // 反転\n                else ori = (ori + 3) % 4; // 左折\n            }\n            int next_x = s.x + dx[ori];\n            int next_y = s.y + dy[ori];\n            if(next_x < 0 || next_x >= w) continue;\n            if(next_y < 0 || next_y >= h) continue;\n            if(d[next_x][next_y][ori] > d[s.x][s.y][s.ori] + cost){\n                d[next_x][next_y][ori] = d[s.x][s.y][s.ori] + cost;\n                q.push(state(d[next_x][next_y][ori], next_x, next_y, ori));\n            }\n        }\n    }\n\n    int ans = INT_MAX;\n\n    for(int e : d[w-1][h-1]) ans = min(ans, e);\n\n    return ans;\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(!w) break;\n        Matrix<int> m(w, vector<int>(h));\n\n        for(int i = 0; i < h; ++i)\n            for(int j = 0; j < w; ++j)\n                cin >> m[j][i];\n\n        for(int i = 0; i < 4; ++i) cin >> c[i];\n\n        cout << dijkstra(m) << endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define F first\n#define S second\n\ntypedef pair<int,int> P;\ntypedef pair< pair<int,int>, pair<int,int> > PPP;\n\nint W,H;\nint mp[35][35],cost[4];\nint end[35][35][4];\n\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nint main(){\n  int i,j,k;\n\n  while(1){\n    scanf(\"%d %d\",&W,&H);\n    if(W == 0 && H == 0) break;\n\n    rep(i,H) rep(j,W) scanf(\"%d\",&mp[i][j]);\n    rep(i,4) scanf(\"%d\",&cost[i]);\n    rep(i,35) rep(j,35) rep(k,4) end[i][j][k] = 0;\n\n    priority_queue<PPP,vector<PPP>, greater<PPP> > q;\n    q.push(PPP(P(0,1),P(0,0)));\n\n    int ans = -1;\n    while(q.size()){\n      PPP now = q.top(); q.pop();\n      int nowcost = now.F.F;\n      int dir = now.F.S;\n      int x = now.S.F;\n      int y = now.S.S;\n\n      if(x+1 == W && y+1 == H){ ans = nowcost; break; }\n      if(end[x][y][dir] == 1) continue;\n      end[x][y][dir] = 1;\n      rep(i,4){\n        int xx = x + dx[(i+dir)%4];\n        int yy = y + dy[(i+dir)%4];\n        int nextcost = nowcost;\n        if(mp[y][x] != i) nextcost += cost[i];\n        if(xx < 0 || yy < 0 || W <= xx || H <= yy) continue;\n        if(!end[xx][yy][(i+dir)%4]) q.push(PPP(P(nextcost,(i+dir)%4),P(xx,yy)));\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int a[32][32];\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++)\n\tcin>>a[j][i];\n    int b[4];\n    for(i=0;i<4;i++)\n      cin>>b[i];\n    int c[32][32][4];\n    memset(c,-1,sizeof(c));\n    priority_queue<pair<pair<int,int>,pair<int,int> >,vector<pair<pair<int,int>,pair<int,int> > >,greater<pair<pair<int,int>,pair<int,int> > > > d;\n    d.push(make_pair(make_pair(0,0),make_pair(1,1)));\n    while(d.empty()==0){\n      int x,y,z,s;\n      x=d.top().second.first;\n      y=d.top().second.second;\n      z=d.top().first.first;\n      s=d.top().first.second;\n      if(x==w&&y==h)\n\tbreak;\n      d.pop();\n      if(a[x][y]!=-1&&c[x][y][s]){\n\tc[x][y][s]=0;\n\tif(0){\n\t}else if(s==0){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),0),make_pair(x+1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),1),make_pair(x,y+1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),2),make_pair(x-1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),3),make_pair(x,y-1)));\n\t}else if(s==1){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),1),make_pair(x,y+1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),2),make_pair(x-1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),3),make_pair(x,y-1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),0),make_pair(x+1,y)));\n\t}else if(s==2){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),2),make_pair(x-1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),3),make_pair(x,y-1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),0),make_pair(x+1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),1),make_pair(x,y+1)));\n\t}else if(s==3){\n\t  d.push(make_pair(make_pair(z+(a[x][y]==0?0:b[0]),3),make_pair(x,y-1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==1?0:b[1]),0),make_pair(x+1,y)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==2?0:b[2]),1),make_pair(x,y+1)));\n\t  d.push(make_pair(make_pair(z+(a[x][y]==3?0:b[3]),2),make_pair(x-1,y)));\n\t}\n      }\n    }\n    cout<<d.top().first.first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint x, y, d, cost;\n\tNode(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nchar dx[] = {0,1,0,-1};\nchar dy[] = {1,0,-1,0};\n\nint main(){\n\tint w, h;\n\tint op[4];\n\tint b[30][30];\n\tint c[30][30][4];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tmemset(c, -1, sizeof(c));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++) cin >> b[i][j];\n\t\t}\n\t\tfor(int i=0;i<4;i++) cin >> op[i];\n\t\tpriority_queue<Node> qu;\n\t\tqu.push(Node(0,0,0,0));\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint x = nd.x, y = nd.y, d = nd.d, cost = nd.cost;\n\t\t\tif(c[x][y][d]!=-1) continue;\n\t\t\tc[x][y][d] = cost;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(nx<0||nx>=h||ny<0||ny>=w) continue;\n\t\t\t\tif(b[x][y]!=4&&(b[x][y]+d)%4==i){\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost));\n\t\t\t\t} else {\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost+op[(4+i-d)%4]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 9999999;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(c[h-1][w-1][i]!=-1) ans = min(ans,c[h-1][w-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconstexpr long long INF = (long long)1e18;\nconstexpr long long MOD = 1'000'000'007; \n\nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n} fio;\n\n\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\t\n\tint dy[5] = {-1,0,1,0};\n\tint dx[5] = {0,1,0,-1};\t\n\t\n\twhile(true) {\n\t\tint w, h, ans = -1;\n\t\tvector<int> C(4);\n\t\tvector<vector<int>> s;\n\t\tvector<vector<vector<int>>>dis;\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int>>, vector<pair<pair<int,int>,pair<int,int>>>, greater<pair<pair<int,int>,pair<int,int>>>> Q;\n\t\t\n\t\tcin>>w>>h;\n\t\t\n\t\tif(!w && !h) break;\n\t\t\n\t\ts.resize(h, vector<int>(w));\n\t\tdis.resize(4, vector<vector<int>>(h, vector<int>(w, INF)));\n\t\t\n\t\tdis[1][0][0] = 0;\n\t\tQ.push({{0,1},{0,0}});\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin>>C[i];\n\t\t}\n\t\t\n\t\twhile(Q.size()){\n\t\t\tpair<pair<int,int>,pair<int,int>> P = Q.top(); Q.pop();\n\t\t\tint c = P.first.first;\n\t\t\tint d = P.first.second;\n\t\t\tint y = P.second.first;\n\t\t\tint x = P.second.second;\n\t\t\t\n\t\t\tif(dis[d][y][x] < c) continue;\n\t\t\t\n\t\t\tif(y == h - 1 && x == w - 1) {\n\t\t\t\tans = c;\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nc = c + (!(s[y][x] == i)) * C[i];\n\t\t\t\tint nd = (d + i) % 4;\n\t\t\t\tint ny = y + dy[nd], nx = x + dx[nd];\n\t\t\t\t\n\t\t\t\tif(ny >= h || ny < 0 || nx >= w || nx < 0) continue;\n\t\t\t\t\n\t\t\t\tif(dis[nd][ny][nx] <= nc) continue;\n\t\t\t\t\n\t\t\t\tdis[nd][ny][nx] = nc;\n\t\t\t\t\n\t\t\t\tQ.push({{nc, nd},{ny, nx}});\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\n#define INF 32767\n\nint main()\n{\n  int w,h;cin>>w>>h;\n  while(w!=0||h!=0)\n  {\n    vector<vector<int>> s(h,vector<int>(w));\n    int i,j,k,l;\n    rep(i,h)rep(j,w)cin>>s[i][j];\n    vector<int> c(4);\n    rep(i,4)cin>>c[i];\n    int dp[h][w][4];\n    vector<int> dx={1,0,-1,0};\n    vector<int> dy={0,1,0,-1};\n    rep(i,h)rep(j,w)rep(k,4)\n    {\n      dp[i][j][k]=INF;\n    }\n    dp[0][0][0]=0;\n    bool update=true;\n    while(update)\n    {\n      update=false;\n      rep(i,h)rep(j,w)rep(k,4)rep(l,4)\n      {\n        int dir;\n        if(s[i][j]==4)dir=-1;\n        else dir=(l+s[i][j])%4;\n        if(i+dy[k]>=0&&i+dy[k]<h&&j+dx[k]>=0&&j+dx[k]<w)\n        {\n          int base=dp[i+dy[k]][j+dx[k]][k];\n          int aft;\n          if(dir==k)\n          {\n            dp[i+dy[k]][j+dx[k]][k]=min(dp[i+dy[k]][j+dx[k]][k],dp[i][j][l]);\n            aft=dp[i+dy[k]][j+dx[k]][k];\n          }\n          else\n          {\n            dp[i+dy[k]][j+dx[k]][k]=min(dp[i+dy[k]][j+dx[k]][k],dp[i][j][l]+c[(k-l+4)%4]);\n            aft=dp[i+dy[k]][j+dx[k]][k];\n          }\n          if(aft<base)update=true;\n        }\n      }\n    }\n    int ans=INF;\n    rep(i,4)\n    {\n      ans=min(ans,dp[h-1][w-1][i]);\n    }\n    cout<<ans<<endl;\n    cin>>w>>h;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nint term(State& begin);\nint expression(State& begin) {\n\tint now_value = 0;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tint d1 = expression(begin);\n\t\tint d2;\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\td2 = expression(begin);\n\t\t\tnow_value = max(d1, d2);\n\t\t}\n\t\telse if(*begin == '*'){\n\t\t\tbegin++;\n\t\t\td2 = expression(begin);\n\t\t\tnow_value = min(d1, d2);\n\t\t}\n\t\tbegin++;\n\t}\n\telse {\n\t\tnow_value = term(begin);\n\t}\n\treturn now_value;\n}\nint term(State& begin) {\n\tint now_value = 0;\n\tif (*begin == '-') {\n\t\tbegin++;\n\t\tnow_value = 2 - expression(begin);\n\t}\n\telse if (*begin >= '0' && *begin <= '9') {\n\t\tnow_value = *begin - '0';\n\t\tbegin++;\n\t}\n\treturn now_value;\n}\nint main() {\n#define int long long\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\tint grid[31][31];\n\t\tint dp[4][31][31] = {};\n\t\tint visited[4][31][31] = {};\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tcin >> grid[i][q];\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tdp[j][i][q] = LONG_INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint costings[4];\n\t\tREP(i, 4) {\n\t\t\tcin >> costings[i];\n\t\t}\n\t\tdp[0][0][0] = 0;\n\t\tpriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>>> next;\n\t\tnext.push(make_tuple(0, 0, 0, 0));\n\t\tint xe[4] = { 0,1,0,-1 };\n\t\tint ye[4] = { 1,0,-1,0 };\n\t\twhile (next.empty() == false) {\n\t\t\ttuple<int, int, int, int> now = next.top();\n\t\t\tnext.pop();\n\t\t\tif (visited[get<1>(now)][get<2>(now)][get<3>(now)] == 1) continue;\n\t\t\tvisited[get<1>(now)][get<2>(now)][get<3>(now)] = 0;\n\t\t\tREP(j, 4) {\n\t\t\t\tint cost = get<0>(now);\n\t\t\t\tif (grid[get<2>(now)][get<3>(now)] != j) {\n\t\t\t\t\tcost += costings[j];\n\t\t\t\t}\n\t\t\t\tint direction = get<1>(now) + j;\n\t\t\t\tdirection %= 4;\n\t\t\t\tint next_x = get<2>(now) + xe[direction];\n\t\t\t\tint next_y = get<3>(now) + ye[direction];\n\t\t\t\tif (next_x >= 0 && next_x < h && next_y >= 0 && next_y < w) {\n\t\t\t\t\tif (dp[direction][next_x][next_y] > cost) {\n\t\t\t\t\t\tdp[direction][next_x][next_y] = cost;\n\t\t\t\t\t\tnext.push(make_tuple(cost, direction, next_x, next_y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min({ dp[0][h - 1][w - 1],dp[1][h - 1][w - 1] ,dp[2][h - 1][w - 1] ,dp[3][h - 1][w - 1] }) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define INF 1e8\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nstruct state{\n\tint cost;\n\tint x, y;\n\tint dir;\n\tstate(int _x, int _y, int _dir, int _cost) : x(_x), y(_y), dir(_dir), cost(_cost){}\n\tbool operator < (const state &r)const{\n\t\treturn cost < r.cost;\n\t}\n};\n\n\nint main(void){\n\tint w, h;\n\twhile(cin >> w >> h, w){\n\t\tint mem[35][35][4];\n\t\tint grid[35][35];\n\t\tint c[4];\n\t\tfor(int i = 0; i <= h; i++)\n\t\t\tfor(int j = 0; j <= w; j++)\n\t\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t\t\tmem[i][j][k] = INF;\n\t\tfor(int i = 0; i <= h+1; i++)\n\t\t\tfor(int j = 0; j <= w+1; j++)\n\t\t\t\tgrid[i][j] = INF;\n\t\t\n\t\tfor(int i = 1; i <= h; i++)\n\t\t\tfor(int j = 1; j <= w; j++)\n\t\t\t\tcin >> grid[i][j];\n\t\tfor(int i = 0; i < 4; i++) cin >> c[i];\n\t\tint mincost = INF;\n\t\tpriority_queue<state> pq;\n\t\tpq.push(state(1,1,1,0));\n\t\twhile(!pq.empty()){\n\t\t\tstate P = pq.top(); pq.pop();\n//\t\t\tcout << P.x << \":\" << P.y << \"->\" << P.cost << endl;\n\t\t\tif(P.y == h && P.x == w){\n\t\t\t\tmincost = min(mincost, P.cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(grid[P.y][P.x] == INF) continue;\n\t\t\tif(grid[P.y][P.x] != 4){\n\t\t\t\tint nd = (P.dir + grid[P.y][P.x]) % 4;\n\t\t\t\tint nx = P.x + dx[nd];\n\t\t\t\tint ny = P.y + dy[nd];\n\t\t\t\tif(mem[ny][nx][nd] > P.cost){\n\t\t\t\t\tmem[ny][nx][nd] = P.cost;\n\t\t\t\t\tpq.push(state(nx, ny, nd, P.cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nd = (P.dir + i) % 4;\n\t\t\t\tint nx = P.x + dx[nd];\n\t\t\t\tint ny = P.y + dy[nd];\n\t\t\t\t\n\t\t\t\tif(mem[ny][nx][nd] > P.cost + c[i]){\n\t\t\t\t\tmem[ny][nx][nd] = P.cost + c[i];\n\t\t\t\t\tpq.push(state(nx, ny, nd, P.cost + c[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mincost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<29)\n\nint W,H;\nint C[5];\nint S[50][50];\nint D[50][50][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint dc[]={0,1,2,3};\n\nstruct state{\n  int x,y,d,c;\n  bool operator<(const state& s) const {\n    return c > s.c;\n  }\n};\n\nbool outcheck(int x,int y){\n  return x<0 || y<0|| x>=W || y>=H;\n}\n\n\nvoid solve(){\n\n  priority_queue<state> q;\n  fill(D[0][0],D[50][50],INF);\n  q.push( (state){0,0,1,0} );\n  D[0][0][1] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( D[p.x][p.y][p.d] < p.c ) continue;\n\n    //    cout << p.x << \"  \" << p.y << \" \"<<p.d << endl;\n    if( S[p.x][p.y] < 4 ){\n      int nd = (p.d + dc[S[p.x][p.y]])%4;\n      int nx = p.x + dx[nd], ny = p.y + dy[nd];\n      if( !outcheck(nx,ny) ){ \n\tif( D[nx][ny][nd] > p.c ){\n\t  D[nx][ny][nd] = p.c;\n\t  q.push( (state){nx,ny,nd,p.c} );\n\t}\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int nd = (p.d + dc[i])%4;\n      int nx = p.x + dx[nd], ny = p.y + dy[nd];\n      if( outcheck(nx,ny) ) continue;\n      //  cout << D[nx][ny][nd] << \" > \" << p.c + C[i]<< \" \" << i  <<endl;\n      if( D[nx][ny][nd] > p.c + C[i] ){\n\t//cout <<\"next \" << nx << \" \" << ny << \" \" << nd << endl;\n\tD[nx][ny][nd] = p.c+C[i];\n\tq.push( (state){nx,ny,nd,p.c+C[i]} );\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++){\n    res = min( res, D[W-1][H-1][i] );\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while( cin >> W>>H && (W||H ) ){\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> S[j][i];\n      }\n    }\n    for(int i=0;i<4;i++) \n      cin >> C[i];\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\ntypedef pair<int, pair<pii, int> > pnode;\n\nstruct node {\n\tpnode p;\n\tnode( pnode pn ) {\n\t\tp = pn;\n\t}\n};\nbool operator<( const node& l, const node &r ) {\n\treturn l.p.fi > r.p.fi;\n}\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w||h) {\n\t\tbool visit[31][31][4] = {};\n\t\tint field[31][31];\n\t\tint cost[4];\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> field[x][y];\n\t\t\t}\n\t\t}\n\t\trep(i,4) {\n\t\t\tcin >> cost[i];\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tque.push( node( pnode(0, pair<pii,int>(pii(0,0),0)) ) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( visit[nd.p.se.fi.fi][nd.p.se.fi.se][nd.p.se.se] ) continue;\n\t\t\tvisit[nd.p.se.fi.fi][nd.p.se.fi.se][nd.p.se.se] = true;\n\t\t\tif( nd.p.se.fi.fi == w-1 && nd.p.se.fi.se == h-1 ) {\n\t\t\t\tcout << nd.p.fi << endl;\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tcout << \"visit \" << nd.p.se.fi.fi << \", \" << nd.p.se.fi.se << \", \" << nd.p.se.se << \" c:\" << nd.p.fi << endl;\n\t\t\tint dx[4] = {1, 0, -1, 0};\n\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\trep(i, 4) {\n\t\t\t\tint dir = (i+nd.p.se.se)%4;\n\t\t\t\tint nx = nd.p.se.fi.fi+dx[dir];\n\t\t\t\tint ny = nd.p.se.fi.se+dy[dir];\n\t\t\t\tif( 0<=nx && nx<w && 0<=ny && ny<h && !visit[nx][ny][dir] ) {\n\t\t\t\t\tint c = (field[nd.p.se.fi.fi][nd.p.se.fi.se] == i) ? 0 : cost[i];\n\t\t\t\t\tque.push( node( pnode(nd.p.fi+c, pair<pii,int>(pii(nx, ny), dir)) ) );\n//\t\t\t\t\tcout << \"reg \" << nx << \", \" << ny << \", \" << dir << \" c:\" << nd.p.fi+c << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\n// → ↓ ← ⇡\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nstruct S {\n\tint x, y, d, c; // i座標 j座標 方向 命令コスト\n\tS(int xx, int yy, int dd, int cc) {x=xx,y=yy,d=dd,c=cc;}\n\tbool operator > (const S &e) const {return c > e.c;}\n};\n\nint h, w, s[30][30], c[4], d[30][30][4];\nvector<S> e[30][30][4];\n\nvoid dijkstra() {\n\tpriority_queue<S, vector<S>, greater<S> > que;\n\tque.push(S(0,0,0,0));\n\twhile(!que.empty()) {\n\t\tS p = que.top(); que.pop();\n\t\tint x = p.x, y = p.y, di = p.d, co = p.c;\n\t\tif (d[x][y][di] < co) continue;\n\t\tfor (int i = 0; i < e[x][y][di].size(); ++i) {\n\t\t\tS q = e[x][y][di][i];\n\t\t\tint xx = q.x, yy = q.y, din = q.d, con = q.c;\n\t\t\tif (d[xx][yy][din] > d[x][y][di] + con) {\n\t\t\t\td[xx][yy][din] = d[x][y][di] + con;\n\t\t\t\tque.push(S(xx, yy, din, d[xx][yy][din]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (h==0) break;\n\t\trep(i,h) rep(j,w) cin >> s[i][j];\n\t\trep(i,4) cin >> c[i];\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k] = inf, e[i][j][k].clear();\n\t\td[0][0][0] = 0;\n\t\t// k:現在の向き l:進みたい向き\n\t\trep(i,h) rep(j,w) rep(k,4) rep(l,4) {\n\t\t\tint ii = i + dx[l], jj = j + dy[l];\n\t\t\tif (ool(ii, jj, h, w)) continue;\n\t\t\te[i][j][k].pb(S(ii, jj, l, ((l-k+4)%4==s[i][j]) ? 0 : c[(l-k+4)%4]));\n\t\t}\n\t\tdijkstra();\n\t\tcout << *min_element(d[h-1][w-1], d[h-1][w-1]+4) << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nstruct state {\n\tint x, y, d, dist;\n\tstate(int x, int y, int d, int dist):x(x), y(y), d(d), dist(dist){}\n\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\n#define X first\n#define Y second\ntypedef pair<int, int> P;\n\nconst int MAX = 30;\nconst int EAST = 0, SOUTH = 1, WEST = 2,  NORTH = 3;\nconst int STRAIGHT = 0, RIGHT = 1, BACK = 2, LEFT = 3, HALT = 4;\nconst P dir[4] = {P(1, 0), P(0, 1), P(-1, 0), P(0, -1)};\n\nint w, h;\nint s[MAX][MAX];\nint cost[4];\n\nP turn(int d, int ori) {\n\tswitch(ori) {\n\tcase STRAIGHT: return dir[d]; break;\n\tcase RIGHT: return  P(-dir[d].Y, dir[d].X); break;\n\tcase BACK: return P(-dir[d].X, -dir[d].Y); break;\n\tcase LEFT: return P(dir[d].Y, -dir[d].X); break;\n\t}\n\tassert(false);\n}\n\nint dijkstra() {\n\tvector<vector<vector<int> > > dist(h, vector<vector<int> >(w, vector<int>(4, INT_MAX)));\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tque.push(state(0, 0, EAST, 0));\n\tdist[0][0][EAST] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst state sta = que.top();\n\t\tque.pop();\n\n\t\tif(dist[sta.y][sta.x][sta.d] < sta.dist)\n\t\t\tcontinue;\n\n\t\tif(sta.x == w - 1 && sta.y == h - 1)\n\t\t\treturn sta.dist;\n\n\t\tfor(int ori = 0; ori < 4; ++ori) {\n\t\t\tconst P forward = turn(sta.d, ori);\n\t\t\tconst int nx = sta.x + forward.X, ny = sta.y + forward.Y;\n\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\t\tcontinue;\n\n\t\t\tconst int nd = (sta.d + ori) % 4, nc = sta.dist + (ori == s[sta.y][sta.x] ? 0 : cost[ori]);\n\t\t\tif(dist[ny][nx][nd] > nc) {\n\t\t\t\tdist[ny][nx][nd] = nc;\n\t\t\t\tque.push(state(nx, ny, nd, nc));\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(false);\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcin >> s[i][j];\n\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t\tcin >> cost[i];\n\n\t\tcout << dijkstra() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n//((cost, dir), (y, x))\ntypedef pair<pii, pii> State;\n\nenum {kStraight = 0, kRight, kBack, kLeft, kHalt};\nenum {kEast = 0, kSourth, kWest, kNorth};\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0, 1, 0,-1};\n\nint main(void){\n    for(int w, h; cin >> w >> h, w;){\n        vvi field(h, vi(w));\n        rep(y, h) rep(x, w) cin >> field[y][x];\n\n        vi cost(4);\n        for(auto& c : cost) cin >> c;\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(mp(mp(0, kEast), mp(0, 0)));\n\n        map<pair<int, pii>, int> used;\n        int res;\n        while(!q.empty()){\n            pii cur_pos = q.top().S;\n            int cur_cost = q.top().F.F;\n            int cur_dir = q.top().F.S;\n            q.pop();\n\n            used[mp(cur_dir, cur_pos)] = true;\n            if(cur_pos == mp(h - 1, w - 1)){\n                res = cur_cost;\n                break;\n            }\n\n            rep(op, 4){\n                int next_cost = cur_cost;\n                if(field[cur_pos.F][cur_pos.S] != op) next_cost += cost[op];\n\n                pii next_pos = cur_pos;\n                int next_dir = (cur_dir + op) % 4;\n                next_pos.F += dy[next_dir];\n                next_pos.S += dx[next_dir];\n\n                if(next_pos.F < 0 || h <= next_pos.F ||\n                   next_pos.S < 0 || w <= next_pos.S) continue;\n                if(used[mp(next_dir, next_pos)]) continue;\n\n                q.push(mp(mp(next_cost, next_dir), next_pos));\n            }\n        }\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Robo\n{\n\tint x, y, dir, cost;\n\tRobo(int x, int y, int dir, int cost)\n\t\t: x(x), y(y), dir(dir), cost(cost) { }\n};\nbool operator<(const Robo& a, const Robo& b)\n{\n\treturn a.cost > b.cost;\n}\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tint s[32][32];\n\t\trep (y, h)\n\t\t\trep (x, w)\n\t\t\t\tcin >> s[y][x];\n\t\tint c[4];\n\t\trep (i, 4)\n\t\t\tcin >> c[i];\n\n\t\tconst int INF = 1 << 26;\n\t\tint dis[32][32][4];\n\t\trep (y, h)\n\t\t\trep (x, w)\n\t\t\t\trep (i, 4)\n\t\t\t\t\tdis[y][x][i] = INF;\n\n\t\tpriority_queue<Robo> q;\n\t\tdis[0][0][1] = 0;\n\t\tq.push(Robo(0, 0, 1, 0));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tRobo r = q.top(); q.pop();\n\t\t\tif (r.cost > dis[r.y][r.x][r.dir])\n\t\t\t\tcontinue;\n\t\t\telse if (r.x == w - 1 && r.y == h - 1)\n\t\t\t{\n\t\t\t\tcout << r.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint nc = r.cost;\n\t\t\t\tif (i != s[r.y][r.x])\n\t\t\t\t\tnc += c[i];\n\n\t\t\t\tint d = 0;\n\t\t\t\tif (i == 1)\n\t\t\t\t\td = 3;\n\t\t\t\telse if (i == 2)\n\t\t\t\t\td = 2;\n\t\t\t\telse if (i == 3)\n\t\t\t\t\td = 1;\n\t\t\t\tint nd = (r.dir + d) % 4;\n\t\t\t\tint nx = r.x + dx[nd], ny = r.y + dy[nd];\n\n\t\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && nc < dis[ny][nx][nd])\n\t\t\t\t{\n\t\t\t\t\tdis[ny][nx][nd] = nc;\n\t\t\t\t\tq.push(Robo(nx, ny, nd, nc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost>right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4],ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      int *ncost=&d[ny][nx][ndir];\n      if(*ncost>cost+c[i]) *ncost=cost+c[i],Q.push((dat){*ncost,ny,nx,ndir});\n      if(data[y][x]!=i) continue;\n      if(*ncost>cost) *ncost=cost,Q.push((dat){*ncost,ny,nx,ndir});\n    }\n  }\n  cout<<min(d[h-1][w-1][1],d[h-1][w-1][2])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\n\nint w, h;\nstruct P\n{\n\tint x, y;\n\tint cost;\n\tint i;\n\tset<piii> a;\n\tbool move()\n\t{\n\t\tx += dx[i];\n\t\ty += dy[i];\n\t\tif (a.count(piii(i,pii(x, y)))||x<=0||y<=0||w<x||h<y)return false;\n\t\ta.insert(piii(i,pii(x, y)));\n\t\treturn true;\n\t}\n\tvoid turn_right()\n\t{\n\t\ti+=1;\n\t\ti %= 4;\n\t}\n\tvoid turn_left()\n\t{\n\t\ti+=3;\n\t\ti %= 4;\n\t}\n\tvoid turn_back()\n\t{\n\t\ti += 2;\n\t\ti %= 4;\n\t}\n\tbool operator<(const P &right)const \n\t{\n\t\treturn cost < right.cost;\n\t}\n\tbool operator>(const P &right)const\n\t{\n\t\treturn cost > right.cost;\n\t}\n};\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\t\n\t\tvector<vi> a(35, vi(35, 4));\n\t\tvi cost(4, 0);\n\n\t\tcin >> w >> h; if (!w)break;\n\t\tFORI(i, 1, h + 1)FORI(j, 1, w + 1)\n\t\t\tcin >> a[i][j];\n\t\tFOR(i, 4)\n\t\t\tcin >> cost[i];\n\t\tP start{ 1,1,0,1,{} };\n\t\tpriority_queue< P, vector<P>, greater<P> > que;\n\t\tque.push(start);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif (now.x == w&&now.y == h)\n\t\t\t{\n\t\t\t\tcout << now.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFOR(i, 4)\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tif (a[now.y][now.x] == i)continue;\n\t\t\t\tnext.cost += cost[i];\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tnext.turn_right();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tnext.turn_back();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tnext.turn_left();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (next.move())\n\t\t\t\t{\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tswitch (a[now.y][now.x])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tnow.turn_right();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnow.turn_back();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tnow.turn_left();\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!ok)continue;\n\t\t\tif (now.move())\n\t\t\t{\n\t\t\t\tque.push(now);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint dist[32][32][5];\nint H, W, C[5];\n\nint field[32][32];\n\nstruct query{\n    int h;\n    int w;\n    int direction;\n    int nowdist;\n    query(int a, int b, int c, int d) {\n        h = a;\n        w = b;\n        direction = c;\n        nowdist = d;\n    }\n};\n\nconst bool operator> (const query &a, const query &b) {\n    return a.nowdist > b.nowdist;\n}\nint dh[4] = {-1, 0, 1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> W >> H;\n        if(W == 0) break;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                cin >> field[h][w];\n                for(int d = 0; d <= 3; d++) {\n                    dist[h][w][d] = INF;\n                }\n            }\n        }\n        priority_queue<query, vector<query>, greater<query>> que;\n        dist[1][1][1] = 0;\n        que.emplace(1, 1, 1, 0);\n        for(int i = 0; i <= 3; i++) cin >> C[i];\n        while(!que.empty()) {\n            query now = que.top();\n            que.pop();\n            //cerr << now.h << \" \" << now.w << \" \" << now.direction << \" \" << dist[now.h][now.w][now.direction] << endl;\n            if(now.h == H && now.w == W) {\n                cout << dist[H][W][now.direction] << endl;\n                break;\n            }\n            for(int ope = 0; ope <= 3; ope++) {\n                int newdist = dist[now.h][now.w][now.direction];\n                if(ope != field[now.h][now.w]) newdist += C[ope];\n                int newdirection = (now.direction + ope) % 4;\n                int newh = now.h + dh[newdirection];\n                int neww = now.w + dw[newdirection];\n                if(newh < 1 || newh > H || neww < 1 || neww > W) continue;\n                if(dist[newh][neww][newdirection] > newdist) {\n                    dist[newh][neww][newdirection] = newdist;\n                    que.emplace(newh, neww, newdirection, newdist);\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <memory>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pip;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint w, h;\nint area[31][31];\nint min_cost[31][31][4];\nint c[4];\n\nvoid bfs(){\n\tqueue<pip> qp;\n\tqp.push(make_pair(0, make_pair(1, 1)));\n\twhile(!qp.empty()){\n\t\tpip p = qp.front(); qp.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint d = p.first;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint y2 = y+dy[(d+i)%4];\n\t\t\tint x2 = x+dx[(d+i)%4];\n\t\t\tif(y2 < 1 || y2 > h || x2 < 1 || x2 > w) continue;\n\t\t\tint cost = 0;\n\t\t\tint d2 = (d+i)%4;\n\t\t\tif(area[y][x] != i) cost = c[i];\n\t\t\tif(min_cost[y2][x2][d2] < 0 || min_cost[y][x][d] + cost < min_cost[y2][x2][d2]){\n\t\t\t\tmin_cost[y2][x2][d2] = min_cost[y][x][d] + cost;\n\t\t\t\tqp.push(make_pair(d2, make_pair(y2, x2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(min_cost, -1, sizeof(min_cost));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tmin_cost[1][1][0] = 0;\n\t\tbfs();\n\t\tint cost = 10000;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(min_cost[h][w][i] > 0) cost = min(cost, min_cost[h][w][i]);\n\t\t}\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n\n// dir???0:??????1:??? 2:??????3:???\n// x:1~W y:1~H\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint W, H; \n\twhile (cin >> W >> H, W | H) {\n\t\t// s := square state\n\t\tvector<vector<int>> s(H + 2, vector<int>(W + 2, -1));\n\t\tfor (int h = 1; h <= H;h++) for (int w = 1; w <= W;w++) cin >> s[h][w];\n\n\t\t// c := command cost\n\t\tvector<int> c(5, INF);\n\t\tfor (int i = 0; i < 4;i++)cin >> c[i];\n\n\t\t//dist[h][w][dir] := stay s[h][w] / direction = dir\n\t\tvector<vector<vector<int>>> dist(H + 2, vector<vector<int>>(W + 2, vector<int>(4, INF)));\n\t\tdist[1][1][0] = 0;\n\n\t\t// tuple<h,w,dir>\n\t\tusing key = tuple<int, int, int>;\n\t\tqueue<key> q;\n\t\tq.push(key(1, 1, 0));\n\n\n\n\t\twhile (!q.empty()) {\n\t\t\tint h, w, dir;\n\t\t\ttie(h, w, dir) = q.front(); q.pop();\n\n\t\t\tfor (int com = 0; com < 4;com++) {\n\t\t\t\tint next_h = h + dy[(com + dir) % 4];\n\t\t\t\tint next_w = w + dx[(com + dir) % 4];\n\n\t\t\t\t// out square\n\t\t\t\tif (s[next_h][next_w] == -1) continue;\n\n\t\t\t\tint move_cost;\n\t\t\t\tif (s[h][w] == com) move_cost = 0;\n\t\t\t\telse move_cost = c[com];\n\n\t\t\t\tif (dist[next_h][next_w][(com + dir) % 4] > dist[h][w][dir] + move_cost) {\n\t\t\t\t\tdist[next_h][next_w][(com + dir) % 4] = dist[h][w][dir] + move_cost;\n\t\t\t\t\tif (next_h == H && next_w == W) continue;\n\n\t\t\t\t\tq.push(key(next_h, next_w, (com + dir) % 4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tans = min(ans, dist[H][W][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint w,h,s[30][30],c[4],d[30][30][4],ans; //d[pos][dir]:=位置posに向きdirで入るための最小コスト\n\nint encode(int y,int x){\n    return w*y+x;\n}\n\npii decode(int pos){\n    return pii(pos/w,pos%w);\n}\n\nvoid dijkstra(){\n    ans=inf;\n    fill_n((int*)d,900*4,inf);\n    d[0][0][0]=0;\n    typedef tuple<int,int,int> triple;\n    priority_queue<pair<int,triple>,vector<pair<int,triple>>,greater<pair<int,triple>>> que;\n    que.push(make_pair(0,triple(0,0,0)));\n    while(!que.empty()){\n        pair<int,triple> p=que.top(); que.pop();\n        int dist=p.first;\n        int y=get<0>(p.second),x=get<1>(p.second),dir=get<2>(p.second);\n\n        if(y==h-1 and x==w-1){\n            ans=min(ans,dist);\n            continue;\n        }\n        if(dist>d[y][x][dir]) continue;\n\n        rep(i,0,4){\n            int cost=c[i],ndir=(dir+i)%4;\n            if(i==s[y][x]) cost=0;\n\n            int ny=y+dy[ndir],nx=x+dx[ndir];\n            if(ny<0 or h<=ny or nx<0 or w<=nx) continue;\n            if(dist+cost<d[ny][nx][ndir]){\n                d[ny][nx][ndir]=dist+cost;\n                que.push(make_pair(d[ny][nx][ndir],triple(ny,nx,ndir)));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n\n        rep(y,0,h) rep(x,0,w) cin >> s[y][x];\n        rep(i,0,4) cin >> c[i];\n\n        dijkstra();\n\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint w,h,s[30][30],c[4],d[30][30][4],ans;\n\nint encode(int y,int x){\n    return w*y+x;\n}\n\npii decode(int pos){\n    return pii(pos/w,pos%w);\n}\n\nvoid dijkstra(){\n    ans=inf;\n    fill_n((int*)d,900*4,inf);\n    d[0][0][0]=0;\n    typedef tuple<int,int,int> triple;\n    priority_queue<pair<int,triple>,vector<pair<int,triple>>,greater<pair<int,triple>>> que;\n    que.push(make_pair(0,triple(0,0,0)));\n    while(!que.empty()){\n        pair<int,triple> p=que.top(); que.pop();\n        int dist=p.first;\n        int y=get<0>(p.second),x=get<1>(p.second),dir=get<2>(p.second);\n\n        if(y==h-1 and x==w-1){\n            ans=min(ans,dist);\n            continue;\n        }\n        if(dist>d[y][x][dir]) continue;\n\n        rep(i,0,4){\n            int cost=c[i],ndir=(dir+i)%4;\n            if(i==s[y][x]) cost=0;\n\n            int ny=y+dy[ndir],nx=x+dx[ndir];\n            if(ny<0 or h<=ny or nx<0 or w<=nx) continue;\n            if(dist+cost<d[ny][nx][ndir]){\n                d[ny][nx][ndir]=dist+cost;\n                que.push(make_pair(d[ny][nx][ndir],triple(ny,nx,ndir)));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n\n        rep(y,0,h) rep(x,0,w) cin >> s[y][x];\n        rep(i,0,4) cin >> c[i];\n\n        dijkstra();\n\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 10000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\tif(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int INF = 1<<30;\n\nstruct data{\n    int i, j, dir;\n    bool operator<(const data other) const{return true;}\n};\n\n#define inRange(x,a,b) (a <= x && x < b)\nint di[4] = {0,1,0,-1};\nint dj[4] = {1,0,-1,0};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w+h){\n        char mat[h][w];\n        int dp[4][h][w], c[4];\n        for(int i = 0; i < h*w; i++){\n            cin >> mat[i/w][i%w];\n            for(int j = 0; j < 4; j++)  dp[j][i/w][i%w] = INF;\n        }\n        for(int i = 0; i < 4; i++)  cin >> c[i];\n        priority_queue<pair<int,data>> pq;\n        pq.push({-0, data({0, 0, 0})});\n        int ans;\n        while(!pq.empty()){\n            auto p = pq.top();  pq.pop();\n            int cost = -p.first, i = p.second.i, j = p.second.j, dir = p.second.dir;\n            if(dp[dir][i][j] <= cost)   continue;\n            dp[dir][i][j] = cost;\n            if(i == h-1 && j == w-1){\n                ans = cost;\n                break;\n            }\n            for(int k = 0; k < 4; k++){\n                int way = (dir+k)%4;\n                int ni = i+di[way], nj = j+dj[way], ncost = cost;\n                if(!inRange(ni,0,h)||!inRange(nj,0,w))  continue;\n                if(k != mat[i][j]-'0')    ncost += c[k];\n                if(dp[way][ni][nj] > ncost)  pq.push({-ncost, data({ni,nj,way})});\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint w,h,mas[30][30],c[4];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nbool used[30][30][4];\nstruct P{\n  int x,y,MUKI,cnt;\n  P(){}\n  P(int x,int y,int MUKI,int cnt) : x(x),y(y),MUKI(MUKI),cnt(cnt) {}\n  bool operator < (const P &s) const{\n    return cnt > s.cnt;\n  }\n};\nint bfs();\nint main(){\n  while(cin >> w >> h && w||h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n      }\n    }\n    for(int i=0;i<4;i++) cin >> c[i];\n    memset(used,false,sizeof(used));\n    cout << bfs() << endl;\n  }\n}\nint bfs(){\n  priority_queue<P> que;\n  que.push(P(0,0,0,0));\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    if(used[p.x][p.y][p.MUKI]) continue;\n    used[p.x][p.y][p.MUKI] = true;\n    if(p.x == h-1 && p.y == w-1) return p.cnt;\n    for(int i=0;i<4;i++){\n      int nMUKI = (p.MUKI + i) % 4,ncos = p.cnt;\n      int nx = p.x + dx[nMUKI],ny = p.y + dy[nMUKI];\n      if(mas[p.x][p.y] != i) ncos += c[i];\n      if(nx>=0&&nx<h&&ny>=0&&ny<w){\n        que.push(P(nx,ny,nMUKI,ncos));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<vvi> vvvi;\nint cost[4][30][30];\nstruct cell{\n\tint cost,d,x,y;\n\tcell(int cost,int d,int x,int y):cost(cost),d(d),x(x),y(y){}\n\tbool operator<(const cell &other)const{\n\t\treturn cost>other.cost;\n\t}\n};\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w&&h){\n\t\tvvi s(w,vi(h));\n\t\tvi cd(4);\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcin>>s[j][i];\n\t\t\t}\n\t\t}\n\t\tREP(i,4){\n\t\t\tcin>>cd[i];\n\t\t}\n\t\tREP(i,4)REP(j,w)REP(k,h){\n\t\t\tcost[i][j][k]=INT_MAX;\n\t\t}\n\t\tpriority_queue<cell> q;\n\t\tq.push(cell(0,0,0,0));\n\t\tcost[0][0][0]=0;\n\t\twhile(!q.empty()){\n\t\t\tcell c=q.top();\n\t\t\tq.pop();\n\t\t\tif(c.cost>cost[c.d][c.x][c.y])continue;\n\t\t\tREP(i,4){\n\t\t\t\tint dir=(c.d+i)%4;\n\t\t\t\tint x=c.x+dx[dir],y=c.y+dy[dir];\n\t\t\t\tif(x>=0&&x<w&&y>=0&&y<h){\n\t\t\t\t\tif(s[c.x][c.y]!=4&&i==s[c.x][c.y]){\n\t\t\t\t\t\tif(cost[dir][x][y]>cost[c.d][c.x][c.y]){\n\t\t\t\t\t\t\tcost[dir][x][y]=cost[c.d][c.x][c.y];\n\t\t\t\t\t\t\tq.push(cell(cost[dir][x][y],dir,x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(cost[dir][x][y]>cost[c.d][c.x][c.y]+cd[i]){\n\t\t\t\t\t\t\tcost[dir][x][y]=cost[c.d][c.x][c.y]+cd[i];\n\t\t\t\t\t\t\tq.push(cell(cost[dir][x][y],dir,x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,4){\n\t\t\tbest=min(best,cost[i][w-1][h-1]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint s[35][35], d[35][35][4], c[4];\nsigned main(void)\n{\n  while(true) {\n    int w, h;\n    cin >> w >> h;\n    if(!w && !h) break;\n    REP(i, h) REP(j, w) cin >> s[i][j];\n    REP(i, 4) cin >> c[i];\n\n    priority_queue<VI, VVI, greater<VI>> q;\n    q.push({0, 0, 0, 0});\n    REP(i, h) REP(j, w) REP(k, 4) d[i][j][k] = INF;\n    d[0][0][0] = 0;\n    while(q.size()) {\n      VI v = q.top(); q.pop();\n      int x = v[1], y = v[2], dir = v[3];\n      //cout << x << \" \" << y << \" \" << dir << \" \" << d[y][x][dir] << endl;\n      if(x == w-1 && y == h-1) continue;\n      REP(i, 4) {\n        int ndir = (dir+i)%4, nx = x + dx[ndir], ny = y+dy[ndir];\n        int tmp;\n        if(s[y][x] == i) tmp = d[y][x][dir];\n        else tmp = d[y][x][dir] + c[i];\n        if(IN(0, w, nx) && IN(0, h, ny) && d[ny][nx][ndir] > tmp) {\n          d[ny][nx][ndir] = min(d[ny][nx][ndir], tmp);\n          q.push({d[ny][nx][ndir], nx, ny, ndir});\n        }\n      }\n    }\n\n    int ret = INF;\n    REP(i, 4) ret = min(ret, d[h-1][w-1][i]);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint main(){\n    int h,w,g[50][50], c[4];\n    int dist[50][50][4];\n    while(cin >> w >> h && w){\n        rep(i,h)rep(j,w) cin >> g[i][j];\n        rep(i,4) cin >> c[i];\n        // d, y, x, dir\n        typedef tuple<int,int,int,int> State;\n        rep(i,50)rep(j,50)rep(k,4) dist[i][j][k] = 1e9;\n        dist[0][0][1] = 0;\n        priority_queue<State> q;\n        int dx[] = {1,0,-1,0};\n        int dy[] = {0,1,0,-1};\n        q.emplace(0,0,0,0);\n        int ans = -1;\n        while(q.size()){\n            int d,y,x,dir;\n            tie(d,y,x,dir) = q.top();\n            q.pop();\n            d = -d;\n            //printf(\" %d %d %d %d\\n\", d,y,x,dir);\n            if(dist[y][x][dir] < d) continue;\n            if(y==h-1 && x==w-1){\n                ans = d;\n                break;\n            }\n            rep(op,4){\n                int nx, ny, nd, ndir;\n                int cost = op == g[y][x] ? 0 : c[op];\n                nd = d + cost;\n                ndir = (dir+op)%4;\n                nx = x+dx[ndir], ny = y+dy[ndir];\n                if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n                if(dist[ny][nx][ndir] <= nd) continue;\n                dist[ny][nx][ndir] = nd;\n                q.emplace(-nd,ny,nx,ndir);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <utility>\n#include <tuple>\n#include <math.h>\n#include <iomanip>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nclass Sover {\n};\n\nint main()\n{\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0)break;\n\n\t\tvector<vector<int>> grid(h, vector<int>(w, 0));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> grid[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<int> costs(4);\n\t\tfor (int i = 0; i < 4; i++)cin >> costs[i];\n\n\t\tvector<vector<vector<int>>> distances(h,\n\t\t\tvector<vector<int>>(w, vector<int>(4, 1e9)));\n\n\t\tqueue<tuple<int, int, int, int>> que;\n\t\tque.emplace(make_tuple(0, 0, 0, 0));\n\t\twhile (que.size() > 0) {\n\t\t\tint y, x, dire, cost;\n\t\t\ttie(y, x, dire, cost) = que.front();\n\t\t\tque.pop();\n\t\t\tif (distances[y][x][dire] <= cost)continue;\n\n\t\t\tdistances[y][x][dire] = cost;\n\n\t\t\tif (y > 0) {\n\t\t\t\tint next_cost = 0;\n\t\t\t\tif (dire == 0) {\n\t\t\t\t\tif (grid[y][x] != 3)next_cost = costs[3];\n\t\t\t\t}\n\t\t\t\tif (dire == 1) {\n\t\t\t\t\tif (grid[y][x] != 2)next_cost = costs[2];\n\t\t\t\t}\n\t\t\t\tif (dire == 2) {\n\t\t\t\t\tif (grid[y][x] != 1)next_cost = costs[1];\n\t\t\t\t}\n\t\t\t\tif (dire == 3) {\n\t\t\t\t\tif (grid[y][x] != 0)next_cost = costs[0];\n\t\t\t\t}\n\t\t\t\tnext_cost += cost;\n\t\t\t\tque.push(make_tuple(y - 1, x, 3, next_cost));\n\t\t\t}\n\t\t\tif (y + 1 < h) {\n\t\t\t\tint next_cost = 0;\n\t\t\t\tif (dire == 0) {\n\t\t\t\t\tif (grid[y][x] != 1)next_cost = costs[1];\n\t\t\t\t}\n\t\t\t\tif (dire == 1) {\n\t\t\t\t\tif (grid[y][x] != 0)next_cost = costs[0];\n\t\t\t\t}\n\t\t\t\tif (dire == 2) {\n\t\t\t\t\tif (grid[y][x] != 3)next_cost = costs[3];\n\t\t\t\t}\n\t\t\t\tif (dire == 3) {\n\t\t\t\t\tif (grid[y][x] != 2)next_cost = costs[2];\n\t\t\t\t}\n\t\t\t\tnext_cost += cost;\n\t\t\t\tque.push(make_tuple(y + 1, x, 1, next_cost));\n\t\t\t}\n\t\t\tif (x > 0) {\n\t\t\t\tint next_cost = 0;\n\t\t\t\tif (dire == 0) {\n\t\t\t\t\tif (grid[y][x] != 2)next_cost = costs[2];\n\t\t\t\t}\n\t\t\t\tif (dire == 1) {\n\t\t\t\t\tif (grid[y][x] != 1)next_cost = costs[1];\n\t\t\t\t}\n\t\t\t\tif (dire == 2) {\n\t\t\t\t\tif (grid[y][x] != 0)next_cost = costs[0];\n\t\t\t\t}\n\t\t\t\tif (dire == 3) {\n\t\t\t\t\tif (grid[y][x] != 3)next_cost = costs[3];\n\t\t\t\t}\n\t\t\t\tnext_cost += cost;\n\t\t\t\tque.push(make_tuple(y, x - 1, 2, next_cost));\n\t\t\t}\n\t\t\tif (x + 1 < w) {\n\t\t\t\tint next_cost = 0;\n\t\t\t\tif (dire == 0) {\n\t\t\t\t\tif (grid[y][x] != 0)next_cost = costs[0];\n\t\t\t\t}\n\t\t\t\tif (dire == 1) {\n\t\t\t\t\tif (grid[y][x] != 3)next_cost = costs[3];\n\t\t\t\t}\n\t\t\t\tif (dire == 2) {\n\t\t\t\t\tif (grid[y][x] != 2)next_cost = costs[2];\n\t\t\t\t}\n\t\t\t\tif (dire == 3) {\n\t\t\t\t\tif (grid[y][x] != 1)next_cost = costs[1];\n\t\t\t\t}\n\t\t\t\tnext_cost += cost;\n\t\t\t\tque.push(make_tuple(y, x + 1, 0, next_cost));\n\t\t\t}\n\t\t}\n\n\t\tint res = 1e9;\n\t\tfor (int i = 0; i < 4; i++)res = min(res, distances[h - 1][w - 1][i]);\n\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost<right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4];\n      int ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(d[ny][nx][ndir]>cost+c[i]){\n\td[ny][nx][ndir]=cost+c[i];\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n      if(data[y][x]!=i) continue;\n      if(d[ny][nx][ndir]>cost){\n\td[ny][nx][ndir]=cost;\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n    }\n  }\n  int mincost=INF;\n  for(int i=0;i<4;i++)\n    mincost=min(mincost,d[h-1][w-1][i]);\n  cout<<mincost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n#define MAX_X 30\n#define MAX_Y 30\n\nint cost[4];\nint w, h;\n\nint dx[] = {-1,0,1,0}; int dy[] = {0,-1,0,1};\n\nstruct P {\n    int cost, x, y, way;\n    bool operator >(const P& p) const {\n        if (cost != p.cost) return cost > p.cost;\n        return y < p.y;\n    }\n};\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        vector<vi> field(h, vi(w));\n        REP(iy, h) REP(ix, w) {\n            cin >> field[iy][ix];\n        }\n        REP(i, 4) {\n            cin >> cost[i];\n        }\n\n        vector<vector<vi>> costs(4, vector<vi>(h, vi(w, INF)));\n        costs[2][0][0] = 0; // right\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push((P){0, 0, 0, 2});\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.x == w - 1 && p.y == h - 1) {\n                cout << p.cost << endl;\n                break;\n            }\n\n            int way = (p.way + field[p.y][p.x]) % 4;\n            int sx = p.x + dx[way];\n            int sy = p.y + dy[way];\n\n            if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                if (field[p.y][p.x] != 4) {\n                    if (costs[way][sy][sx] > p.cost) {\n                        costs[way][sy][sx] = p.cost;\n                        que.push((P){p.cost, sx, sy, way});\n                    }\n                }\n            }\n\n            REP(d, 4) {\n                way = (p.way + d) % 4;\n                sx = p.x + dx[way];\n                sy = p.y + dy[way];\n\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    if (costs[way][sy][sx] > p.cost) {\n                        costs[way][sy][sx] = p.cost + cost[d];\n                        que.push((P){p.cost + cost[d], sx, sy, way});\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint d[3601];\nint h, w;\nvector<vector<edge>> es;\nint fld[30][30];\nint cost[4];\n\nvoid dijkstra(int s)\n{\n\tfill(ALL(d), INF);\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tREP(i, es[v].size())\n\t\t{\n\t\t\tedge e = es[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//i*w+j\n// 3\n//2 0\n// 1\nint dx[] = { 0, 1, 0, -1 }; int dy[] = { 1, 0, -1, 0 };\nint main()\n{\n\twhile (cin >> w >> h, w)\n\t{\n\t\tes.clear();\n\t\tREP(i, h)REP(j, w) cin >> fld[i][j];\n\t\tREP(i, 4) cin >> cost[i];\n\t\tint goal = w*h - 1;\n\t\tes.resize(h*w*4);\n\t\tREP(i, h)REP(j, w)REP(k, 4)\n\t\t{\n\t\t\tint tmp = (i*w + j) + h*w*k;\n\t\t\tREP(l, 4)\n\t\t\t{\n\t\t\t\tint nx = i + dx[l]; int ny = j + dy[l];\n\t\t\t\tint next = (nx*w + ny)+h*w*l;\n\t\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n\t\t\t\tif (fld[i][j] == 4) \n\t\t\t\t{\n\t\t\t\t\tes[tmp].push_back(edge{ tmp, next, cost[(l - k + 4) % 4] });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ((k + fld[i][j]) % 4 == l) es[tmp].push_back(edge{ tmp, next, 0 });\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tes[tmp].push_back(edge{ tmp, next, cost[(l - k + 4) % 4] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(0);\n\n\t\tcout << min({ d[goal], d[goal + h*w] }) << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int T[] = {0, 3, 2, 1};\nconst int INF = 1 << 28;\n\nint w, h;\nint s[30][30];\nint c[4];\n\nint dist[30][30][4];\n\nstruct State {\n\tint x, y, dir, sum;\n\tbool operator < (const State &rhs) const {\n\t\treturn sum > rhs.sum;\n\t}\n};\n\nint solve()\n{\n\tfill_n(**dist, 30 * 30 * 4, INF);\n\t\n\tpriority_queue<State> pq;\n\t\n\tdist[0][0][3] = 0;\n\tpq.push({0, 0, 3, 0});\n\t\n\twhile (pq.size()){\n\t\tState cur = pq.top(); pq.pop();\n\t\tif (dist[cur.x][cur.y][cur.dir] < cur.sum) continue;\n\t\tif (cur.x == h - 1 && cur.y == w - 1) return cur.sum;\n\t\t\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint ndir = (cur.dir + T[i]) % 4;\n\t\t\tint nx = cur.x + dx[ndir];\n\t\t\tint ny = cur.y + dy[ndir];\n\t\t\tint nsum = cur.sum + (i != s[cur.x][cur.y] ? c[i] : 0);\n\t\t\tif (nx < 0 || h <= nx) continue;\n\t\t\tif (ny < 0 || w <= ny) continue;\n\t\t\tif (dist[nx][ny][ndir] <= nsum) continue;\n\t\t\tdist[nx][ny][ndir] = nsum;\n\t\t\tpq.push({nx, ny, ndir, nsum});\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\trep(i, h) rep(j, w) scanf(\"%d\", &s[i][j]);\n\t\trep(i, 4) scanf(\"%d\", c + i);\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 100000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 10000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\tpair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\tif(p.second.first == P(h - 1, w - 1)) {\n\t\t\t\tif(p.second.second == 1) hoge.first = true;\n\t\t\t\tif(p.second.second == 2) hoge.second = true;\n\t\t\t}\n\t\t\tif(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h;\nint c[4];\nint s[31][31];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nstruct S{\n    int y, x, st, dis;\n    bool operator>(const S &s) const{\n        return dis > s.dis;\n    }\n};\n\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nconst int INF = 1e9;\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        rep(i, 0, h) rep(j, 0, w) cin >> s[i][j];\n        rep(i, 0, 4) cin >> c[i];\n        int d[31][31][4];\n        rep(i, 0, h) rep(j, 0, w) rep(k, 0, 4) d[i][j][k] = INF;\n        queue<S> q;\n        q.push((S){0, 0, 1, 0});\n        d[0][0][1] = 0;\n        while(!q.empty()){\n            S p = q.front(); q.pop();\n            // if(p.dis > d[p.y][p.x][p.dir]) continue;\n            rep(i, 0, 4){\n                int dir = (p.st + i) % 4;\n                int ny = p.y + dy[dir];\n                int nx = p.x + dx[dir];\n                int ndis = p.dis;\n                if(!contain(ny, nx)) continue;\n                if(s[p.y][p.x] != i){\n                    ndis += c[i];\n                }\n                if(ndis < d[ny][nx][dir]){\n                    d[ny][nx][dir] = ndis;\n                    q.push((S){ny, nx, dir, ndis});\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, 4) ans = min(ans, d[h - 1][w - 1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 10000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cost == 0) continue;\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//SPFA\n#include <cstdio>\n#include <cstring>\n#include<queue>\nusing namespace std;\n#define INF (10*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nint main(){\n\tqueue<Node> que;\n\tint inQ[30][30][4],dst[30][30][4];\n\tint head,tail;\t\n\tNode a,b;\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\twhile(!que.empty())que.pop();\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque.push(a);\n\t\twhile(head<tail){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\tque.push(b);\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\n#define ck(a,b) (0<=(a)&&(a)<(b))\n#define INF 10000\nusing namespace std;\n\nint crdx[4]={1,0,-1,0};\nint crdy[4]={0,1,0,-1};\nint crdp[31][31][4];\nint crmap[31][31];\nint crcost[4];\nint crw,crh,crmin;\n\nvoid crdfs(int x,int y,int muki){//muki:0-> clockwise\n\t//cout<<y<<\":\"<<x<<\":\"<<muki<<\" \"<<crdp[y][x][muki]<<endl;\n\tif(x==crw-1&&y==crh-1) crmin=min(crmin,crdp[y][x][muki]);\n\telse {\n\n\t\tint nmuki=(crmap[y][x]+muki)%4;\n\t\tif(crmap[y][x]==4) nmuki=4;\n\t\tREP(k,0,4){\n\t\t\tint nx=x+crdx[k],ny=y+crdy[k];\n\t\t\tif(!ck(ny,crh)||!ck(nx,crw)) continue;\n\t\t\tif(crdp[y][x][muki]>=crmin) continue;\n\n\t\t\tif(nmuki==k)\t{\n\t\t\t\tif(crdp[ny][nx][nmuki]>crdp[y][x][muki]){\n\t\t\t\t\tcrdp[ny][nx][nmuki]=crdp[y][x][muki];\n\t\t\t\t\tcrdfs(nx,ny,k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t{\n\t\t\t\tint cost;\n\t\t\t\tif(k>=muki) cost=crcost[k-muki];\n\t\t\t\telse        cost=crcost[4-(muki-k)];\n\t\t\t\tif(crdp[ny][nx][k]>crdp[y][x][muki]+cost){\n\t\t\t\t\tcrdp[ny][nx][k]=crdp[y][x][muki]+cost;\n\t\t\t\t\tcrdfs(nx,ny,k);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>crw>>crh,crw){\n\t\tmemset(crdp,INF,sizeof(crdp));\n\t\tcrmin=INF;\n\t\tREP(i,0,crh){\n\t\t\tREP(j,0,crw){\n\t\t\t\tcin>>crmap[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>crcost[0]>>crcost[1]>>crcost[2]>>crcost[3];\n\t\tcrdp[0][0][0]=0;\n\t\tcrdfs(0,0,0);\n\n\t\tp(crmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\nint INF = 1000000;\n\nint ban[35][35],w,h,c[4],dp[35][35][4];\nint dj[4][4] = {{0,1,0,-1},\n              {1,0,-1,0},\n              {0,-1,0,1},\n              {-1,0,1,0} };\nint di[4][4] = {{-1,0,1,0},\n              {0,1,0,-1},\n              {1,0,-1,0},\n              {0,-1,0,1}};\n\nint next_direction(int i,int j,int ni,int nj){\n    if(i == ni){\n        if(j > nj){\n            return 3;\n        }else{\n            return 1;\n        }\n    }else{\n        if(i > ni){\n            return 0;\n        }else{\n            return 2;\n        }\n    }\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(w + h == 0)break;\n        for(int i = 1;i <= h;i++){\n            for(int j = 1;j <= w;j++){\n                cin >> ban[i][j];\n                for(int k = 0;k < 4;k++) dp[i][j][k] = INF;\n            }\n        }\n        for(int i = 0;i < 4;i++){\n            cin >> c[i];\n        }\n        queue<T> que;\n        dp[1][1][1] = 0;\n        que.push(make_tuple(1,1,1,0));\n        while(!que.empty()){\n            T t = que.front(); que.pop();\n            int i = get<0>(t),j = get<1>(t),d = get<2>(t),cost = get<3>(t);\n     //       cout << \"i:\" << i << \", j:\" << j << \", d:\" << d << \", cost:\" << cost <<endl;\n            if(dp[i][j][d] != cost || (i == h && j == w)) continue;\n            for(int k = 0;k < 4;k++){\n                int ni = i + di[d][k],nj = j + dj[d][k];\n                int nd = next_direction(i,j,ni,nj);\n                if(ni <= 0 || ni > h || nj <= 0 || nj > w)continue;\n                int same_d = 0;\n                if(k == ban[i][j]) same_d = c[k];\n                if(dp[ni][nj][nd] > cost + c[k] - same_d){\n                    dp[ni][nj][nd] = cost + c[k] - same_d;\n                    que.push(make_tuple(ni,nj,nd,dp[ni][nj][nd]));\n                }\n            }\n        }\n        int ans = INF;\n        for(int k = 0;k < 4;k++){\n            ans = min(ans,dp[h][w][k]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct State {\n  int x, y, d, c;\n  State(){}\n  State(int x_, int y_, int d_, int c_) : x(x_), y(y_), d(d_), c(c_) {}\n  bool operator>(const State& s) const {\n    return c>s.c;\n  }\n};\n\nconst int S = 31;\nconst int INF = 1<<27;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint H, W;\nint G[S][S], C[4];\n\nbool in(int x, int y) {\n  return 0<=x && x<W && 0<=y & y<H;\n}\n\nint a() {\n  int c[4][S][S];\n  \n  priority_queue<State, vector<State>, greater<State> > q;\n  \n  fill(c[0][0], c[4][0], INF);\n  q.push(State(0,0,0,0));\n  c[0][0][0] = 0;\n\n  while(!q.empty()) {\n    const State s = q.top(); q.pop();\n    if(s.x == W-1 && s.y == H-1) return s.c;\n    \n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      t.c += i == G[s.y][s.x] ? 0 : C[i];\n      if(in(t.x, t.y) && c[t.d][t.y][t.x] > t.c) {\n\tq.push(t);\n\tc[t.d][t.y][t.x] = t.c;\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> W >>H, W+H ) {\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) cin >> G[i][j];\n    for(int i=0; i<4; i++) cin >> C[i];\n    cout << a() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a>b?b:a)\n\nint dx[8] = {1,0,-1,0,1,0,-1,0};\nint dy[8] = {0,1,0,-1,0,1,0,-1};\n\nint main() {\n\tint map[M+2][M+2], c[4], w, h;\n\tint dp[M+2][M+2][M*M+1][4], ans;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tcin >> map[i][j];\n\t\t\t\t\tfor(int t=0; t<=w*h; ++t) {\n\t\t\t\t\t\tfor(int k=0; k<4; ++k) dp[i][j][t][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\tdp[1][1][0][0] = 0; ans = INF;\n\t\tfor(int t=1; t<=w*h; ++t) {\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tif(i==h&&j==w) continue;\n\t\t\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\t\t\tfor(int l=0; l<4; ++l) {\n\t\t\t\t\t\t\tint d = k+l;\n\t\t\t\t\t\t\tif(map[i][j]==l) {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d%4] = min(dp[i+dy[d]][j+dx[d]][t][d%4], dp[i][j][t-1][k]);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d%4] = min(dp[i+dy[d]][j+dx[d]][t][d%4], dp[i][j][t-1][k]+c[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j+dx[d]==w&&i+dy[d]==h&&(d%4==0||d%4==1)) {\n\t\t\t\t\t\t\t\tans = min(ans, dp[i+dy[d]][j+dx[d]][t][d%4]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nstruct Entry\n{\n    int x, y;\n    int direction;\n};\n\nint main()\n{\n    int w, h;\n\n    while(cin >> w >> h, (w | h) )\n    {\n        //map[h][w]\n        int map[30][30];\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cin >> map[i][j];\n            }\n        }\n        \n        //command[0] to straight\n        //command[1] to right\n        //command[2] to back\n        //command[3] to left\n        int command[4];\n        for(int i = 0; i < 4; i++)\n        {\n            cin >> command[i];\n        }\n\n       \n        //direction and costs when comes to the Entry\n        //cost[direction][y][x]\n        int cost[4][30][30];\n\n        //cost[0][][] to right\n        //cost[1][][] to down\n        //cost[2][][] to left\n        //cost[3][][] to up\n\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cost[0][i][j] = INF;\n                cost[1][i][j] = INF;\n                cost[2][i][j] = INF;\n                cost[3][i][j] = INF;\n            }\n        }\n\n        const int dx[4] = {1, 0, -1, 0};\n        const int dy[4] = {0, 1, 0, -1};\n\n\n        //start\n        queue<Entry> que;\n\n        que.push(Entry{0, 0, 0});\n        cost[0][0][0] = 0;\n\n        bool check = true;\n\n        while(!que.empty())\n        {\n            Entry now = que.front();\n            que.pop();\n\n            //if follows the Entry rule\n            int followedDirection = now.direction + map[now.y][now.x];\n            followedDirection %= 4;\n\n            //halt\n            if(map[now.y][now.x] == 4)followedDirection = INF;\n\n            //(now.direction + i) % 4 is next direction\n            //i is rotating degree\n            for(int i = 0; i < 4; i++)\n            {\n                int nextDirection = (now.direction + i) % 4;\n\n                int nextX = now.x + dx[nextDirection];\n                int nextY = now.y + dy[nextDirection];\n\n                //if not out of range\n                if( !(nextX < 0 || nextX >= w || nextY < 0 || nextY >= h) ) \n                {\n                    int tmp_cost = cost[now.direction][now.y][now.x] + (nextDirection != followedDirection) * command[i];\n\n                    //update to lower costs\n                    if(tmp_cost < cost[nextDirection][nextY][nextX])\n                    {\n                        cost[nextDirection][nextY][nextX] = tmp_cost;\n                        que.push( Entry{ nextX, nextY, nextDirection } );\n                    }\n                }\n            }\n        }\n        cout << min(cost[0][h - 1][w - 1], cost[1][h - 1][w - 1]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\n// N,E,S,W = 0,1,2,3;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nbool inrange(int x,int y,int w,int h){return 0<=x&&x<w && 0<=y&&y<h;}\nint main(void)\n{\n  for(;;){\n    int w,h;\n    cin >> w >> h;\n    if(!w&&!h) return 0;\n    int ope[32][32];\n    REP(j,h) REP(i,w) cin >> ope[i][j];\n    int c[4];\n    REP(i,4) cin >> c[i];\n    set<tuple<int,int,int> > already;\n    priority_queue<pair<int,tuple<int,int,int> > > dijk;\n    // negc,(x,y,dir)\n    dijk.push(make_pair(0,make_tuple(0,0,1)));\n    while(!dijk.empty()){\n      pair<int,tuple<int,int,int> > tmp;\n      tmp=dijk.top();\n      int negc,x,y,dir;\n      negc=tmp.first;\n      tie(x,y,dir)=tmp.second;\n      dijk.pop();\n      if(!already.insert(make_tuple(x,y,dir)).second) continue;\n      if(x==w-1&&y==h-1){\n\tcout << -negc << endl;\n\tbreak;\n      }\n      REP(i,4){\n\tint cost=c[i];\n\tif(ope[x][y]==i) cost=0;\n\tint ndir=(dir+i)%4;\n\tif(inrange(x+dx[ndir],y+dy[ndir],w,h)) dijk.push(make_pair(negc-cost,make_tuple(x+dx[ndir],y+dy[ndir],ndir)));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<29)\n\nint W,H;\nint C[5];\nint S[50][50];\nint D[50][50][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint dc[]={0,1,2,3};\n\nstruct state{\n  int x,y,d,c;\n  bool operator>(const state& s) const {\n    return c < s.c;\n  }\n};\n\nbool outcheck(int x,int y){\n  return x<0 || y<0|| x>=W || y>=H;\n}\n\n\nvoid solve(){\n\n  priority_queue<state,vector<state>,greater<state> > q;\n  fill(D[0][0],D[50][50],INF);\n  q.push( (state){0,0,1,0} );\n  D[0][0][1] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( D[p.x][p.y][p.d] < p.c ) continue;\n\n    //    cout << p.x << \"  \" << p.y << \" \"<<p.d << endl;\n    if( S[p.x][p.y] < 4 ){\n      int nd = (p.d + dc[S[p.x][p.y]])%4;\n      int nx = p.x + dx[nd], ny = p.y + dy[nd];\n      if( !outcheck(nx,ny) ){ \n\tif( D[nx][ny][nd] > p.c ){\n\t  D[nx][ny][nd] = p.c;\n\t  q.push( (state){nx,ny,nd,p.c} );\n\t}\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int nd = (p.d + dc[i])%4;\n      int nx = p.x + dx[nd], ny = p.y + dy[nd];\n      if( outcheck(nx,ny) ) continue;\n      //  cout << D[nx][ny][nd] << \" > \" << p.c + C[i]<< \" \" << i  <<endl;\n      if( D[nx][ny][nd] > p.c + C[i] ){\n\t//cout <<\"next \" << nx << \" \" << ny << \" \" << nd << endl;\n\tD[nx][ny][nd] = p.c+C[i];\n\tq.push( (state){nx,ny,nd,p.c+C[i]} );\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++){\n    res = min( res, D[W-1][H-1][i] );\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while( cin >> W>>H && (W||H ) ){\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> S[j][i];\n      }\n    }\n    for(int i=0;i<4;i++) \n      cin >> C[i];\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <iostream>\n\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nenum{\n\tMAX_X = 30,\n\tMAX_Y = 30\n};\n\nint g_cost[MAX_X][MAX_Y][4];\nint g_table[MAX_X][MAX_Y];\nint g_opCost[4];\n\nstruct State{\n\tState(int x, int y, int cost, int dir) : x(x), y(y), cost(cost), dir(dir){}\n\tbool operator< (State & other){\n\t\treturn cost > other.cost;\n\t}\n\tbool operator< (const State & other) const{\n\t\treturn cost > other.cost;\n\t}\n\tint x;\n\tint y;\n\tint cost;\n\tint dir;\n};\n\n//右　下　左　上\nint dirX[4] = {1, 0, -1, 0};\nint dirY[4] = {0, 1, 0, -1};\n\nint OPedDir(int op, int oldDir){\n\treturn (oldDir + op)%4;\n}\n\nint solution(int w, int h){\n\n\tpriority_queue<State> que;\n\tvector<State> states;\n\tState current(0,0,0,0);\n\tstates.push_back(current);\n\tg_cost[0][0][0] = 0;\n\n\twhile(true){\n\t\twhile(true){\n\t\t\tint op = g_table[current.x][current.y];\n\t\t\tif(op==4){ // 止まったら\n\t\t\t\tif(current.x==w-1 && current.y==h-1) return current.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint dir = OPedDir(op, current.dir);\n\t\t\tint x = current.x + dirX[dir];\n\t\t\tint y = current.y + dirY[dir];\n\t\t\n\t\t\tif(x<0 || y<0 || x>=w || y>=h) break;\n\t\t\tif(g_cost[x][y][dir] <= current.cost) break;\n\t\t\tg_cost[x][y][dir] = current.cost;\n\t\t\tcurrent.x = x;\n\t\t\tcurrent.y = y;\n\t\t\tcurrent.dir = dir;\n\t\t\t\n\t\t\tstates.push_back(current);\n\t\t}\n\t\tfor(auto it=states.begin(); it!=states.end(); it++){\n\t\t\tfor(int op=0; op<4; op++){\n\t\t\t\tint dir = OPedDir(op, it->dir);\n\t\t\t\tint x = it->x + dirX[dir];\n\t\t\t\tint y = it->y + dirY[dir];\n\t\t\t\tif(x<0 || y<0 || x>=w || y>=h) continue;\n\t\t\t\tif(g_cost[x][y][dir] <= it->cost + g_opCost[op]) continue;\n\t\t\t\tg_cost[x][y][dir] = it->cost + g_opCost[op];\n\t\t\t\tque.emplace(x, y, g_cost[x][y][dir], dir);\n\t\t\t}\n\t\t}\n\t\tstates.clear();\n\t\tcurrent = que.top();\n\t\tstates.push_back(current);\n\t\tque.pop();\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile(true){\n\t\tcin >> w;\n\t\tcin >> h;\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tfill(&g_cost[0][0][0], &g_cost[w][h][4], 30000);\n\t\tfor(int y=0; y<h; y++){\n\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\tint op;\n\t\t\t\tcin >> op;\n\t\t\t\tg_table[x][y] = op;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint cost;\n\t\t\tcin >> cost;\n\t\t\tg_opCost[i] = cost;\n\t\t}\n\t\tcout << solution(w,h) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(int i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\nint w, h;\nint id(int i, int j, int k) {\n\treturn h * w*k + w * i + j;\n}\n\ntuple<int, int, int> rid(int ind) {\n\treturn tuple<int,int,int>(ind % (h*w) / w, ind%w, ind / (h*w));\n}\n\nstruct Edge {\n\tint  form, to, cost;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w) {\n\t\tvvi v(h, vi(w));\n\t\tREP(i, h)REP(j, w)cin >> v[i][j];\n\t\tvi c(4);\n\t\tREP(i, 4)cin >> c[i];\n\t\tvi d(h*w * 4, INF);\n\t\tvector<vector<Edge>> g(h*w * 4);\n\n\t\tREP(i, h*w * 4) {\n\t\t\tint x, y, z;\n\t\t\ttie(x, y, z) = rid(i);\n\t\t\tREP(j, 4) {\n\t\t\t\tint cost;\n\t\t\t\tif (v[x][y] == j) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcost = c[j];\n\t\t\t\t}\n\t\t\t\tint nx, ny, nz;\n\t\t\t\tnz = (z - j + 4) % 4;\n\t\t\t\tnx = x + dx[nz * 2], ny = y + dy[nz * 2];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\t\tg[i].push_back(Edge{ i, id(nx, ny, nz),cost });\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<>> q;\n\t\td[id(0, 0, 1)] = 0;\n\t\tq.push({ 0,id(0,0,1) });\n\t\twhile (!q.empty()) {\n\t\t\tauto p = q.top(); q.pop();\n\t\t\tif (p.first > d[p.second])continue;\n\t\t\tREP(i, g[p.second].size()) {\n\t\t\t\tif (d[g[p.second][i].to] > d[p.second] + g[p.second][i].cost) {\n\t\t\t\t\td[g[p.second][i].to] = d[p.second] + g[p.second][i].cost;\n\t\t\t\t\tq.push({ d[g[p.second][i].to],g[p.second][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP(i, 4)chmin(ans, d[id(h - 1, w - 1, i)]);\n\t\tcout << ans << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint w, h, a[35][35], c[4];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nstruct state{\n    int x, y, dir, dist;\n    state(int x, int y, int dir, int dist): x(x), y(y), dir(dir), dist(dist){}\n};\n\nbool in(int x, int y){\n    return 0<=x && x<h && 0<=y && y<w;\n}\n\nvoid solve(){\n    rep(i, h)rep(j, w) scanf(\"%d\", &a[i][j]);\n    rep(i, 4) scanf(\"%d\", &c[i]);\n    auto cmp = [](const state &s1, const state &s2){\n        return s1.dist > s2.dist;\n    };\n    priority_queue<state, vector<state>, decltype(cmp)> que(cmp);\n    int d[h][w][4];\n    rep(i, h)rep(j, w)rep(k, 4) d[i][j][k] = mod;\n    d[0][0][0] = 0;\n    que.emplace(0, 0, 0, 0);\n    while(!que.empty()){\n        auto s = que.top();\n        que.pop();\n        if(d[s.x][s.y][s.dir] < s.dist) continue;\n\n        rep(i, 4){\n            int nd = (s.dir + i) % 4;\n            int nx = s.x + dx[nd], ny = s.y + dy[nd];\n            if(in(nx, ny) && chmin(d[nx][ny][nd], s.dist + (a[s.x][s.y] != i) * c[i])){\n                que.emplace(nx, ny, nd, d[nx][ny][nd]);\n            }\n        }\n    }\n    int ans = mod;\n    rep(i, 4) chmin(ans, d[h-1][w-1][i]);\n    printf(\"%d\\n\", ans);\n}\n\nint main(){\n    while(scanf(\"%d%d\", &w, &h) && w){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct P\n{\n\tint y,x,c,d;//0:E 1:S 2:W 3:N\n\tbool operator <(const P &a)const{return c>a.c;};\n}P;\nP t;\nint W,H,S[30][30],C[5],mv[4][2]={{0,1},{1,0},{0,-1},{-1,0}},F[30][30][4];\n\nP set(int nd)\n{\n\tint c=(nd-t.d+4)%4;\n\tP r=t;\n\tr.y+=mv[nd][0];\n\tr.x+=mv[nd][1];\n\tr.d=nd;\n\tr.c+=S[t.y][t.x]==c?0:C[c];\n\treturn r;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&W,&H),W;)\n\t{\n\t\tmemset(F,0x7f,sizeof(F));\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tscanf(\"%d\",&S[i][j]);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tscanf(\"%d\",&C[i]);\n\t\tpriority_queue<P>Q;\n\t\tt.x=t.y=t.c=t.d=0;\n\t\tQ.push(t);\n\t\tint R=1000000;\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\tt=Q.top();Q.pop();\n\t\t\tint Y=t.y,X=t.x;\n\t\t\tif(Y==H-1&&X==W-1){R=min(R,t.c);continue;}\n\t\t\tif(X<0||X>=W||Y<0||Y>=H||F[Y][X][t.d]<t.c)continue;\n\t\t\tF[Y][X][t.d]=t.c;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tP ins=set(i);\n\t\t\t\tY=ins.y,X=ins.x;\n\t\t\t\tif(X<0||X>=W||Y<0||Y>=H||F[Y][X][ins.d]<=ins.c)continue;\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint w, h;\nint bo[40][40];\nint c[4];\n\nstruct edge {\n    int to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nll d[1000000];\n\nvoid addedge(int st, int ed, int co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nvoid dijkstra(int s) {\n    priority_queue<plglg, vector<plglg>, greater<plglg> > que;\n    fill(d, d + V + 10, llmax);\n    d[s] = 0;\n    que.push(plglg(0, s));\n\n    while (!que.empty()) {\n        plglg p = que.top();\n        que.pop();\n        ll v = p.second;\n        if (d[v] < p.first) {\n            continue;\n        }\n        int len = G[v].size();\n        for (int i = 0; i < len; i++) {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(plglg(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint calcost(int mark, int k, int l) {\n    int ans;\n    if (l == k) {\n        if (mark == 0) {\n            ans = 0;\n        } else {\n            ans = c[0];\n        }\n    } else if (l == (k + 1) % 4) {\n        if (mark == 3) {\n            ans = 0;\n        } else {\n            ans = c[3];\n        }\n    } else if (l == (k + 2) % 4) {\n        if (mark == 2) {\n            ans = 0;\n        } else {\n            ans = c[2];\n        }\n    } else {\n        if (mark == 1) {\n            ans = 0;\n        } else {\n            ans = c[1];\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> bo[i][j];\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            cin >> c[i];\n        }\n        V = w * h * 4 + 1;\n        for (int i = 0; i < w * h * 4 + 1; i++) {\n            G[i].clear();\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 4; k++) {\n                    for (int l = 0; l < 4; l++) {\n                        int x = i + dx[l];\n                        int y = j + dy[l];\n                        if (x >= 0 && x < h && y >= 0 && y < w) {\n                            addedge((i * w + j) * 4 + k, (x * w + y) * 4 + l, calcost(bo[i][j], k, l));\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            addedge(w * h * 4 - i - 1, w * h * 4, 0);\n        }\n        // for (int i = 0; i < h; i++) {\n        //     for (int j = 0; j < w; j++) {\n        //         for (int k = 0; k < 4; k++) {\n        //             int len = G[(i * w + j) * 4 + k].size();\n        //             for (int l = 0; l < len; l++) {\n        //                 edge e = G[(i * w + j) * 4 + k][l];\n        //                 cout << e.to << \" \" << e.cost << \" \";\n        //             }\n        //             cout << \" \";\n        //         }\n        //         cout << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        dijkstra(1);\n        // for (int i = 0; i < h; i++) {\n        //     for (int j = 0; j < w; j++) {\n        //         for (int k = 0; k < 4; k++) {\n        //             cout << d[(i * w + j) * 4 + k] << \" \";\n        //         }\n        //         cout << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        ll ans = d[w * h * 4];\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define min(a,b) ((a)>(b)?(b):(a))\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool inRange(int x, int y, int w, int h) {\n\treturn (0<=x && x<w && 0<=y && y<h);\n}\n\nint main() {\n\tpriority_queue<PP, vector<PP>, greater<PP> > q;\n\tint w, h, map[M][M], c[4], cost[M][M][4];\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\tfor(int i=0; i<h; ++i) {\n\t\t\tfor(int j=0; j<w; ++j) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tfor(int k=0; k<4; ++k) cost[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\t\n\t\t// dijkstra\n\t\tq.push(PP(P(0,0),P(0,0))); cost[0][0][0] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint co = q.top().first.first, dir = q.top().first.second;\n\t\t\tint x = q.top().second.first, y = q.top().second.second;\n\t\t\tq.pop();\n\t\t\tif(co>cost[y][x][dir]) continue;\n\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\tint d = (dir+k)%4;\n\t\t\t\tif(!inRange(x+dx[d], y+dy[d], w, h)) continue;\n\t\t\t\tif(map[y][x]==k) {\n\t\t\t\t\tif(cost[y][x][dir]<cost[y+dy[d]][x+dx[d]][d]) {\n\t\t\t\t\t\tcost[y+dy[d]][x+dx[d]][d] = cost[y][x][dir];\n\t\t\t\t\t\tq.push(PP(P(cost[y+dy[d]][x+dx[d]][d],d),P(x+dx[d],y+dy[d])));\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tif(cost[y][x][dir]+c[k]<cost[y+dy[d]][x+dx[d]][d]) {\n\t\t\t\t\t\tcost[y+dy[d]][x+dx[d]][d] = cost[y][x][dir] + c[k];\n\t\t\t\t\t\tq.push(PP(P(cost[y+dy[d]][x+dx[d]][d],d),P(x+dx[d],y+dy[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min(cost[h-1][w-1][0], cost[h-1][w-1][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nconst int INF = 1000000000;\nint w, h, cost[4], grid[35][35], dp[35][35][4];\n\nvoid dfs(int y, int x, int dir, int currentcost){\n  if(!CH(y,0,h) || !CH(x,0,w)) return;\n  if(dp[y][x][dir] <= currentcost) return;\n  dp[y][x][dir] = currentcost;\n  if((x == w-1 && y == h-1)/* || grid[y][x] == 4*/) return;\n  REP(k,0,5){\n    if(k == 0){ //????????????\n      switch (grid[y][x]) {\n        case 0:\n          dfs(y + dy[dir], x + dx[dir], dir, currentcost);\n          break;\n        case 1:\n          dfs(y + dy[(dir + 1) % 4], x + dx[(dir + 1) % 4], (dir + 1) % 4, currentcost);\n          break;\n        case 2:\n          dfs(y + dy[(dir + 2) % 4], x + dx[(dir + 2) % 4], (dir + 2) % 4, currentcost);\n          break;\n        case 3:\n          dfs(y + dy[(dir + 3) % 4], x + dx[(dir + 3) % 4], (dir + 3) % 4, currentcost);\n          break;\n        case 4:\n          //return;\n          break;\n        }\n    }else{  //???????????????tk: 0 ~ 3????????????4(halt)???????????????\n      int tk = k - 1;\n      if(tk == grid[y][x]) continue;\n      switch (tk) {\n        case 0:\n          dfs(y + dy[dir], x + dx[dir], dir, currentcost + cost[tk]);\n          break;\n        case 1:\n          dfs(y + dy[(dir + 1) % 4], x + dx[(dir + 1) % 4], (dir + 1) % 4, currentcost + cost[tk]);\n          break;\n        case 2:\n          dfs(y + dy[(dir + 2) % 4], x + dx[(dir + 2) % 4], (dir + 2) % 4, currentcost + cost[tk]);\n          break;\n        case 3:\n          dfs(y + dy[(dir + 3) % 4], x + dx[(dir + 3) % 4], (dir + 3) % 4, currentcost + cost[tk]);\n          break;\n        }\n    }\n  }\n  return;\n}\n\nint main() {\n\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    REP(i,0,h){\n      REP(j,0,w){\n        cin>>grid[i][j];\n      }\n    }\n    REP(k,0,4) cin>>cost[k];\n    //memset(dp, INF, sizeof(dp));\n    REP(i,0,h)REP(j,0,w)REP(k,0,4) dp[i][j][k] = INF;\n\n    dfs(0, 0, 0, 0);\n\n    cout<<*min_element(dp[h-1][w-1], dp[h-1][w-1]+4)<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define STRAIGHT 0\n#define RIGHT 1\n#define REV 2\n#define LEFT 3\n#define HALT 4\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct NODE{\n\tint x,y;\n\tint cost;\n\tint di;\n};\n\n\nbool operator>(const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nint w,h;\nbool check(const NODE &n){\n\tif(n.x<0 || n.x>=w)return false;\n\tif(n.y<0 || n.y>=h)return false;\n\treturn true;\n}\nNODE move(int cmd,const NODE &src){\n\tint di = src.di;\n\tNODE ret;\n\tswitch(cmd){\n\tcase STRAIGHT:\n\t\tbreak;\n\tcase RIGHT:\n\t\tdi = (di+1)%4;\n\t\tbreak;\n\tcase LEFT:\n\t\tdi = (di+3)%4;\n\t\tbreak;\n\tcase REV:\n\t\tdi = (di+2)%4;\n\t\tbreak;\n\t}\n\t\n\tret.x = src.x+dx[di];\n\tret.y = src.y+dy[di];\n\tret.di = di;\n\t\n\treturn ret;\n}\nint main(){\n\t\n\twhile(cin >> w >> h,w){\n\t\tint data[30][30] , c[4];\n\t\trep(i,h)rep(j,w)cin >> data[i][j];\n\t\trep(i,4)cin >> c[i];\n\t\tpriority_queue<NODE,vector<NODE>,greater<NODE> > Q;\n\t\tint gx = w-1,gy = h-1;\n\t\tNODE t; t.x = 0, t.y = 0, t.cost = 0; t.di = 0;\n\t\tQ.push(t);\n\t\tint memo[30][30][4]; rep(i,30)rep(j,30)rep(k,4)memo[i][j][k] = (1<<21);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\t\n\t\t\tif(memo[q.y][q.x][q.di] <= q.cost)continue;\n\t\t\tmemo[q.y][q.x][q.di] = q.cost;\n\t\t\t\n\t\t\tif(gx == q.x && gy == q.y){\n\t\t\t\tcout << q.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,4){\n\t\t\t\tNODE mv = move(i,q);\n\t\t\t\tmv.cost = q.cost + c[i];\n\t\t\t\tif(check(mv))Q.push(mv);\n\t\t\t}\n\t\t\t\n\t\t\tint fcmd = data[q.y][q.x];\n\t\t\t\n\t\t\tif(fcmd != HALT){\n\t\t\t\tNODE mv = move(fcmd,q);\n\t\t\t\tmv.cost = q.cost;\n\t\t\t\tif(check(mv))Q.push(mv);\n\t\t\t}\n\t\t}\n\t}\n}\n\t"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n//#include <stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n#include<fstream>\n \n \n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n \nint dy[5] = { 0,0,1,-1,0 };\nint dx[5] = { 1,-1,0,0,0 };\n\nstruct edge{\n\t\t\tlong long int to,cost;\n\t\t};\n\n \nint main(void){\n\n\twhile(1){\n\t\tlong long int w,h;\n\t\t\n\n\t\tcin>>w>>h;\n\t\tif(w==0&h==0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tlong long int s[31][31];\n\t\tlong long int c[4];\n\n\t\tFOR(i,1,h){\n\t\t\tFOR(j,1,w){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\tFOR(i,0,3){\n\t\t\tcin>>c[i];\n\t\t}\n\n\t\t\n\n\t\tvector<edge> G[18000];\n\t\tlong long int d[18000];\n\n\t\tedge ED;\n\n\t\tLFOR(y,1,h){\n\t\t\tLFOR(x,1,w){\n\t\t\t\tLFOR(l,0,3){\n\t\t\t\t\tED.cost=LINF;\n\t\t\t\t\tswitch(l){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tLFOR(k,0,4){\n\t\t\t\t\t\t\t\tif(s[y][x]==k){\n\t\t\t\t\t\t\t\t\tif(x<w){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*x+l;\n\t\t\t\t\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[0];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y<h){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*y+4*(x-1)+l+3;\n\t\t\t\t\t\t\t\t\t\tif(k==1){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*(x-2)+l+1;\n\t\t\t\t\t\t\t\t\t\tif(k==2){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[2];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-2)+4*(x-1)+l+2;\n\t\t\t\t\t\t\t\t\t\tif(k==3){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[3];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tLFOR(k,0,4){\n\t\t\t\t\t\t\t\tif(s[y][x]==k){\n\t\t\t\t\t\t\t\t\tif(x<w){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*x+l-1;\n\t\t\t\t\t\t\t\t\t\tif(k==2){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[2];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y<h){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*y+4*(x-1)+l+2;\n\t\t\t\t\t\t\t\t\t\tif(k==3){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[3];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*(x-2)+l;\n\t\t\t\t\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[0];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-2)+4*(x-1)+l+1;\n\t\t\t\t\t\t\t\t\t\tif(k==1){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tLFOR(k,0,4){\n\t\t\t\t\t\t\t\tif(s[y][x]==k){\n\t\t\t\t\t\t\t\t\tif(x<w){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*x+l-2;\n\t\t\t\t\t\t\t\t\t\tif(k==1){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y<h){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*y+4*(x-1)+l+1;\n\t\t\t\t\t\t\t\t\t\tif(k==2){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[2];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*(x-2)+l-1;\n\t\t\t\t\t\t\t\t\t\tif(k==3){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[3];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-2)+4*(x-1)+l;\n\t\t\t\t\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[0];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tLFOR(k,0,4){\n\t\t\t\t\t\t\t\tif(s[y][x]==k){\n\t\t\t\t\t\t\t\t\tif(x<w){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*x+l-3;\n\t\t\t\t\t\t\t\t\t\tif(k==3){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[3];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y<h){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*y+4*(x-1)+l;\n\t\t\t\t\t\t\t\t\t\tif(k==0){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[0];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(x>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-1)+4*(x-2)+l-2;\n\t\t\t\t\t\t\t\t\t\tif(k==1){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(y>1){\n\t\t\t\t\t\t\t\t\t\tED.to=4*w*(y-2)+4*(x-1)+l-1;\n\t\t\t\t\t\t\t\t\t\tif(k==2){\n\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tED.cost=c[2];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tG[4*w*(y-1)+4*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tLFOR(i,0,4*w*(h-1)+4*(w-1)+4){\n\t\t\td[i]=LINF;\n\t\t}\n\t\td[0]=0;\n\t\tque.push(P(0,0));\n\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tlong long int v=p.second;\n\n\t\t\tif(d[v]<p.first){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLFOR(i,0,G[v].size()-1){\n\t\t\t\tedge e=G[v][i];\n\t\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\n\t\tlong long int mini=LINF;\n\t\tFOR(i,0,4){\n\t\t\tif(d[4*w*(h-1)+4*(w-1)+i]<mini){\n\t\t\t\tmini=d[4*w*(h-1)+4*(w-1)+i];\n\t\t\t}\n\t\t}\n\n\t\tcout<<mini<<endl;\n\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1156&lang=jp\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\ntypedef tuple<int, int, int, int> pass; // x, y, d, cost\ntypedef tuple<int, int, int, int> state; // cur, x, y, d\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint main() {\n  int w, h;\n  while(cin >> w >> h && w) {\n    // 入力\n    int S[40][40];\n    for (int i=0; i<h; i++) {\n      for (int j=0; j<w; j++) {\n\tcin >> S[j][i];\n      }\n    }\n    int c[4];\n    cin >> c[0] >> c[1] >> c[2] >> c[3];\n    // 隣接リストを作る\n    vector<pass> V[40][40][4];\n    for (auto i=0; i<w; i++) {\n      for (auto j=0; j<h; j++) {\n\tfor (auto k=0; k<4; k++) {\n\t  for (auto l=0; l<4; l++) {\n\t    int nd = (k+l)%4;\n\t    int nx = i + dx[nd];\n\t    int ny = j + dy[nd];\n\t    int nc = c[l];\n\t    if (S[i][j] == l) nc = 0;\n\t    if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n\t      V[i][j][k].push_back(make_tuple(nx, ny, nd, nc));\n\t    }\n\t  }\n\t}      \n      }      \n    }\n    /* pass p = V[7][0][0][0];\n    cerr << \"(\" << get<0>(p) << \",\" << get<1>(p) << \") \"\n       << get<2>(p) << \" cost:\" << get<3>(p) << endl; */\n    // Dijkstra法を適用する。\n    priority_queue<state> Q;\n    bool visited[40][40][4];\n    int cost[40][40][4];\n    fill(&visited[0][0][0], &visited[0][0][0]+40*40*4, false);\n    fill(&cost[0][0][0], &cost[0][0][0]+40*40*4, (int)1e8);\n    Q.push(make_tuple(0, 0, 0, 0));\n    while (!Q.empty()) {\n      state s = Q.top();\n      int x = get<1>(s);\n      int y = get<2>(s);\n      int d = get<3>(s);\n      int C = -1 * get<0>(s);\n      Q.pop();\n      if (!visited[x][y][d]) {\n\tcost[x][y][d] = C;\n\t//\tcerr << \"(\" << x << \",\" << y << \")\" << \" of \" \n\t//\t<< d << \" costs \" << C << endl;\n\tvisited[x][y][d] = true;\n\tfor (auto i=0; i<V[x][y][d].size(); i++) {\n\t  pass p = V[x][y][d][i]; \n\t  int nx = get<0>(p);\n\t  int ny = get<1>(p);\n\t  int nd = get<2>(p);\n\t  int nc = get<3>(p);\n\t  if (!visited[nx][ny][nd]) {\n\t    Q.push(make_tuple(-1 * (C + nc), nx, ny, nd));\n\t  }\n\t}\n      }\n    }\n    int ans = (int)1e8;\n    for (auto i=0; i<4; i++) {\n      int t = cost[w-1][h-1][i];\n      // cerr << t << endl;\n      if (ans > t) ans = t;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvector<vector<int>>field;\n\nint ob(const int num,const int way) {\n\tif (num == 0) {\n\t\treturn way;\n\t}\n\telse if (num == 1) {\n\t\treturn (way + 3) % 4;\n\t}\n\telse if (num == 2) {\n\t\treturn (way + 2) % 4;\n\t}\n\telse if (num == 3) {\n\t\treturn (way + 1) % 4;\n\t}\n\telse if (num == 4) {\n\t\treturn -1;\n\t}\n\telse {\n\t\tassert(false);\n\t}\n}\n\nint memo[32][32][4];\n\nint c[4];\n\nstruct aa {\n\tint ny;\n\tint nx;\n\tint co;\n\tint way;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.co> r.co;\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tmemset(memo, 999999, sizeof(memo));\n\t\tint w, h; cin >> w >> h;\n\t\tif (!w)break;\n\t\tfield.clear();\n\t\tfield.resize(h + 2);\n\t\tfor (int i = 0; i < w + 2; ++i) {\n\t\t\tfield[0].push_back(5);\n\t\t}\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfield[i + 1].push_back(5);\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tint s; cin >> s;\n\t\t\t\tfield[i + 1].push_back(s);\n\t\t\t}\n\t\t\tfield[i + 1].push_back(5);\n\t\t}\n\t\tfor (int i = 0; i < w + 2; ++i) {\n\t\t\tfield[h+1].push_back(5);\n\t\t}\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\t\tint sx, sy, gx, gy;\n\t\tsx = 1;\n\t\tsy = 1;\n\t\tgx = w;\n\t\tgy = h;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sy,sx,0,2 });\n\t\tmemo[sy][sx][2] = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tconst int acost = field[atop.ny][atop.nx] == j ? 0 : c[j];\n\t\t\t\tconst int ncost = acost + atop.co;\n\t\t\t\tconst int nway = ob(j, atop.way);\n\t\t\t\tconst int newx = atop.nx + dx[nway];\n\t\t\t\tconst int newy = atop.ny + dy[nway];\n\t\t\t\tif (field[newy][newx] != 5) {\n\t\t\t\t\tif (memo[newy][newx][nway]>ncost) {\n\t\t\t\t\t\tmemo[newy][newx][nway] = ncost;\n\t\t\t\t\t\tque.push(aa{ newy,newx,ncost,nway });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tint ans = 889999999;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tans = min(ans, memo[gy][gx][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct State{\n    int cost;\n    int x, y;\n    int dir;  \n};\n\nbool operator< (const State& lhs, const State& rhs){\n    return (lhs.cost < rhs.cost);\n}\n\nbool operator> (const State& lhs, const State& rhs){\n    return (lhs.cost > rhs.cost);\n}\n\nState getNextState(State state, int process){\n    State ret;\n    \n    if(process == 0){\n        ret.dir = state.dir;\n    }\n    else if(process == 1){\n        ret.dir = (state.dir + 1) % 4;\n    }\n    else if(process == 2){\n        ret.dir = (state.dir + 2) % 4;\n    }\n    else if(process == 3){\n        ret.dir = (state.dir + 3) % 4;\n    }\n\n    ret.cost = state.cost;\n    ret.x = state.x + dx[ret.dir];\n    ret.y = state.y + dy[ret.dir];\n\n    return ret;\n}\n\nconst int INF = 1e9;\n\nbool used[30][30][4];\nint cost[30][30][4];\n\nint main(){\n\n    while(true){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0){\n            break;\n        }\n\n        vector<vector<int>> s(h, vector<int>(w));\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> s[i][j];\n            }\n        }\n\n        vector<int> c(4);\n        for(int i = 0; i < 4; i++){\n            cin >> c[i];\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < 4; k++){\n                    cost[i][j][k] = INF;\n                    used[i][j][k] = false;\n                }\n            }\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        State startState;\n        startState.cost = 0;\n        startState.dir = 0;\n        startState.x = 0;\n        startState.y = 0;\n        q.push(startState);\n        cost[0][0][0] = 0;\n\n        while(!q.empty()){\n            State state = q.top();\n            q.pop();\n\n            if(used[state.y][state.x][state.dir]){\n                continue;\n            }\n\n            used[state.y][state.x][state.dir] = true;\n\n            int process = s[state.y][state.x];\n\n            for(int i = 0; i < 4; i++){\n                State nextState = getNextState(state, i);\n\n                if(i != process){\n                    nextState.cost += c[i];\n                }\n\n                if(0 <= nextState.x && nextState.x < w && 0 <= nextState.y && nextState.y < h){\n                    if(!used[nextState.y][nextState.x][nextState.dir] && nextState.cost < cost[nextState.y][nextState.x][nextState.dir]){\n                        cost[nextState.y][nextState.x][nextState.dir] = nextState.cost;\n                        q.push(nextState);\n                    }\n                }\n            }\n        }\n\n        int ans = INF;\n        for(int i = 0; i < 4; i++){\n            ans = min(ans, cost[h - 1][w - 1][i]);\n        }\n    \n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n}\n\nint w,h;\n\nint trans(int x,int y, int k) {\n  return x*h*4+y*4+k;\n}\n\nint main() {\n  while(cin>>w>>h,w+h) {\n    int ba[w][h];\n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba[x][y];\n      }\n    }\n    int c[4];\n    REP(i,4)\n      cin >> c[i];\n    \n    Graph g(w*h*4);\n\n    int const dx[] = {0,1,0,-1};\n    int const dy[] = {-1,0,1,0};\n    // ツ湘」ツ右ツ可コツ債カ\n   \n    REP(y,h) {\n      REP(x,w) {\n        REP(k,4) {\n          REP(i,4) {\n            int xx = x+dx[i];\n            int yy = y+dy[i];\n            if(xx<0||w<=xx||yy<0||h<=yy) continue;\n\n            int hoge = i-k; if (hoge<0) hoge+=4;\n            int cost = c[hoge];\n            if (ba[x][y]!=4 && i==(k+ba[x][y])%4) cost = 0;\n            \n            g[trans(x,y,k)].push_back(Edge(trans(x,y,k), trans(xx,yy,i), cost));\n          }\n        }\n      }\n    }\n    vector<int> v;\n    shortestPath(g,1,v);\n    cout << min(v[trans(w-1,h-1,1)],v[trans(w-1,h-1,2)]) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct State{\n    int y, x, k, c;\n    State(int y, int x, int k, int c): y(y), x(x), k(k), c(c){}\n    bool operator<(const State& right ) const {\n        return c > right.c;\n    }\n};\n\nint main(){\n    while(1){\n        int W, H;\n        cin >> W >> H;\n        if(W == 0) break;\n\n        int field[30][30];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n            }\n        }\n\n        int cost[4];\n        for(int i=0;i<4;i++){\n            cin >> cost[i];\n        }\n\n        int minDist[30][30][4];\n        memset(minDist, -1, sizeof(minDist));\n        priority_queue<State> que;\n        que.emplace(0, 0, 0, 0);\n        minDist[0][0][0] = 0;\n\n        int ans;\n        while(que.size()){\n            State s = que.top(); que.pop();\n            if(minDist[s.y][s.x][s.k] < s.c) continue;\n            if(s.y == H-1 && s.x == W-1){\n                ans = s.c;\n                break;\n            }\n            for(int d=0;d<4;d++){\n                int nk = (s.k+d)%4, nc = s.c;\n                int ny = s.y + dy[nk], nx = s.x + dx[nk];\n                if(ny<0 || H<=ny || nx<0 || W<=nx) continue;\n                if(d != field[s.y][s.x]){\n                    nc += cost[d];\n                }\n                if(minDist[ny][nx][nk] == -1 || minDist[ny][nx][nk] > nc){\n                    minDist[ny][nx][nk] = nc;\n                    que.emplace(ny, nx, nk, nc);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 10000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\tll ans = INF;\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n \n#define REP(i,b,n) for(int i=b;i<n;++i)\n#define REPR(i,b,n) for(int i=n-1;i>=b;--i)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n\nusing namespace std;\n\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> stt;\ntypedef long long ll;\n\n\nenum{RIGHT, UP, LEFT, DOWN};\n\nint h, w;\nint field[32][32];\nint vtx[32][32][4];\nint cost[4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nint rev[] = {0, -1, 2, 1};\n\n\nbool border(int lo, int mid, int hi){\n\treturn lo <= mid && mid <= hi;\n}\n\n\nint solve(){\n\n\tqueue<stt> qu;\n\tqu.push(make_pair( make_pair(1,1), (int)(RIGHT)));\n\tvtx[1][1][RIGHT] = 0;\n\t\n\tstt now;\n\tint x, y, dir, nx, ny, ndir, pay;\n\t\n\twhile(!qu.empty()){\n\t\t\n\t\tnow = qu.front();\n\t\tx = now.first.first, y = now.first.second, dir = now.second;\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tif(i==field[y][x])\n\t\t\t\tpay = 0;\n\t\t\telse\n\t\t\t\tpay = cost[i];\n\t\t\t\n\t\t\tndir = (4+dir+rev[i])%4;\n\t\t\tnx = x+dx[ndir];\n\t\t\tny = y+dy[ndir];\n\t\t\t\n\t\t\tif(border(1, nx, w) && border(1, ny, h) && vtx[ny][nx][ndir] > vtx[y][x][dir] + pay){\n\t\t\t\tvtx[ny][nx][ndir] = vtx[y][x][dir] + pay;\n\t\t\t\tqu.push(make_pair( make_pair(nx,ny), ndir));\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tint res = INT_MAX;\n\t\n\tfor(int i=0; i<4; ++i)\n\t\tres = min(res, vtx[h][w][i]);\n\t\n\treturn res;\n}\n\n\nint main(){\n\t\n\twhile(cin >> w >> h, (w||h)){\n\t\t\n\t\tfor(int y=1; y<=h; ++y){\n\t\t\tfor(int x=1; x<=w; ++x){\n\t\t\t\n\t\t\t\tcin >> field[y][x];\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k)\n\t\t\t\t\tvtx[y][x][k] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<4; ++i)\n\t\t\tcin>> cost[i];\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n \nint G[SIZE][SIZE], C[4];\nint H, W;\n \nstruct State {\npublic:\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost>s.cost;\n  }\n};\n \nint solve() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State> pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n     && 0 <= t.y && t.y < H \n     && cost[t.d][t.y][t.x] > t.cost) {\n    pq.push(t);\n    cost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n   \n  return INF;\n}\n \nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n    cin >> G[i][j];\n     \n    for(int i=0; i<4; i++) cin >> C[i];\n     \n    cout << solve() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int inf = 999999;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint w, h;\nvector<vector<int> > s;\nvector<int> c;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(){\n    vector<vector<vector<int> > > mem(h, vector<vector<int> >(w, vector<int>(4, inf)));\n    mem[0][0][1] = 0;\n    auto comp = [&](const int a, const int b){\n        int ad = a / 10000, ax = a % 10000 / 100, ay = a % 100,\n            bd = b / 10000, bx = b % 10000 / 100, by = b % 100;\n        return mem[bx][by][bd] < mem[ax][ay][ad];\n    };\n    priority_queue<int, vector<int>, decltype(comp)> q(comp);\n    for(q.push(10000 + 0 * 100 + 0); !q.empty();){\n        int t = q.top(); q.pop();\n        int d = t / 10000, x = t % 10000 / 100, y = t % 100;\n        if(x == h-1 && y == w-1){\n            if(mem[h-1][w-1][1] != inf && mem[h-1][w-1][2] != inf)break;\n            continue;\n        }\n        rep(k, 4){\n            int nd = (d + k) % 4;\n            int nx = x + dx[nd], ny = y + dy[nd];\n            if(inrect(nx, ny)){\n                int cost = mem[x][y][d] + (s[x][y] == k? 0: c[k]);\n                if(mem[nx][ny][nd] <= cost)continue;\n                mem[nx][ny][nd] = cost;\n                q.push(nd * 10000 + nx * 100 + ny);\n            }\n        }\n    }\n    return min(mem[h-1][w-1][1], mem[h-1][w-1][2]);\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        s.assign(h, vector<int>(w));\n        rep(i, h)rep(j, w)cin >> s[i][j];\n        c.resize(4);\n        rep(i, 4)cin >> c[i];\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nclass QInfo {\npublic:\n\tint x;\n\tint y;\n\tint dir;\n\tint cost;\n\n\tQInfo(int x, int y, int dir, int cost) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->dir = dir;\n\t\tthis->cost = cost;\n\t}\n\n\tbool operator < (const QInfo &a) const {\n\t\treturn cost > a.cost;\n\t}\n};\n\nint w, h;\n\nbool inBoard(int y, int x) {\n\treturn x >= 0 && x < w && y >= 0 && y < h;\n}\n\nint nextDir(int now, int op) {\n\tif (op == 1) {\n\t\tnow--;\n\t\tif (now < 0) now += 4;\n\t} else if (op == 2) {\n\t\tnow -= 2;\n\t\tif (now < 0) now += 4;\n\t} else if (op == 3) {\n\t\tnow++;\n\t\tif (now > 3) now -= 4;\n\t}\n\treturn now;\n}\n\nsigned main() {\n\twhile (true) {\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) break;\n\n\t\tvector<string> board;\n\t\trep(y, h) {\n\t\t\tstring tmp = \"\";\n\t\t\trep(x, w) {\n\t\t\t\ttmp += nextChar();\n\t\t\t}\n\t\t\tboard.push_back(tmp);\n\t\t}\n\n\t\tint c[4];\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\n\t\tbool visit[30][30][4];\n\t\tbool pushed[30][30][4];\n\t\tint cost[30][30][4];\n\t\tmemset(visit, false, sizeof(visit));\n\t\tmemset(pushed, false, sizeof(pushed));\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\trep(dir, 4) {\n\t\t\t\t\tcost[y][x][dir] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<QInfo> q;\n\t\tq.push(QInfo(0, 0, 0, 0));\n\t\tcost[0][0][0] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tQInfo nowInfo = q.top(); q.pop();\n\t\t\tint nowX = nowInfo.x;\n\t\t\tint nowY = nowInfo.y;\n\t\t\tint nowDir = nowInfo.dir;\n\t\t\tint nowCost = nowInfo.cost;\n\n\t\t\tif (nowCost > cost[nowY][nowX][nowDir]) continue;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ndir = nextDir(nowDir, i);\n\t\t\t\tint nx = nowX + dx[ndir];\n\t\t\t\tint ny = nowY + dy[ndir];\n\t\t\t\tint ncost = ((i == board[nowY][nowX] - '0') ? 0 : c[i]);\n\t\t\t\tif (!inBoard(ny, nx)) continue;\n\t\t\t\tif (nowCost + ncost >= cost[ny][nx][ndir]) continue;\n\n\t\t\t\tcost[ny][nx][ndir] = nowCost + ncost;\n\t\t\t\tq.push(QInfo(nx, ny, ndir, cost[ny][nx][ndir]));\n\t\t\t}\n\t\t}\n\n\t\tint ret = INT_MAX;\n\t\trep(i, 4) {\n\t\t\tret = min(ret, cost[h - 1][w - 1][i]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\ntypedef pair<int,int> P;//h,w\ntypedef tuple<int,int,int,int> T;//cost,h,w,d;\n//d 0:north, 1:east, 2:south, 3:west\n\nint S[30][30];//h,w\nint memo[30][30][4];//h,w,d\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W|H){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>S[i][j];\n            }\n        }\n        int C[4];\n        for(int i=0;i<4;i++) cin>>C[i];\n        fill(memo[0][0],memo[30][0],1LL<<30);\n        priority_queue<T,vector<T>,greater<T>> que;\n        que.emplace(0,0,0,1);\n        memo[0][0][1]=1;\n        while(!que.empty()){\n            auto t = que.top(); que.pop();\n            int cost=get<0>(t), h=get<1>(t), w=get<2>(t), d=get<3>(t);\n            if(memo[h][w][d]<cost) continue;\n            if(h==H-1&&w==W-1){\n                cout<<cost<<endl;\n                break;\n            }\n            int c,d_;\n            int dh[4]={-1,0,1,0};\n            int dw[4]={0,1,0,-1};\n            //??´???\n            c = (S[h][w]==0?0:C[0]);\n            if(h+dh[d]>=0&&h+dh[d]<H&&w+dw[d]>=0&&w+dw[d]<W){\n                if(memo[h+dh[d]][w+dw[d]][d]>cost+c){\n                    memo[h+dh[d]][w+dw[d]][d]=cost+c;\n                    que.emplace(cost+c,h+dh[d],w+dw[d],d);\n                }\n            }\n            //??????\n            d_=(d+1)%4;\n            c = (S[h][w]==1?0:C[1]);\n            if(h+dh[d_]>=0&&h+dh[d_]<H&&w+dw[d_]>=0&&w+dw[d_]<W){\n                if(memo[h+dh[d_]][w+dw[d_]][d_]>cost+c){\n                    memo[h+dh[d_]][w+dw[d_]][d_]=cost+c;\n                    que.emplace(cost+c,h+dh[d_],w+dw[d_],d_);\n                }\n            }\n            //?????¢\n            d_=(d+2)%4;\n            c = (S[h][w]==2?0:C[2]);\n            if(h+dh[d_]>=0&&h+dh[d_]<H&&w+dw[d_]>=0&&w+dw[d_]<W){\n                if(memo[h+dh[d_]][w+dw[d_]][d_]>cost+c){\n                    memo[h+dh[d_]][w+dw[d_]][d_]=cost+c;\n                    que.emplace(cost+c,h+dh[d_],w+dw[d_],d_);\n                }\n            }\n            //??????\n            d_=(d+3)%4;\n            c = (S[h][w]==3?0:C[3]);\n            if(h+dh[d_]>=0&&h+dh[d_]<H&&w+dw[d_]>=0&&w+dw[d_]<W){\n                if(memo[h+dh[d_]][w+dw[d_]][d_]>cost+c){\n                    memo[h+dh[d_]][w+dw[d_]][d_]=cost+c;\n                    que.emplace(cost+c,h+dh[d_],w+dw[d_],d_);\n                }\n            }\n        }\n        while(!que.empty()) que.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\nusing namespace std;\n#define INF INT_MAX\nint G[30][30];\nint c[4];\n//\nconst int dirx[] = {-1, 0, 1, 0};\nconst int diry[] = { 0,-1, 0, 1};\n\nclass State{\n  public:\n    int x;\n    int y;\n    int dir;\n    int cost;\n    State(int x, int y, int dir, int cost){\n      this->x=x;this->y=y;this->dir=dir;this->cost=cost;\n    }\n    bool operator < (const State &s)const{\n      return cost > s.cost;\n    }\n};\n\nint main(void){\n  int w, h;\n  while(cin >> w >> h, w | h){\n    for(int i=0; i < h; i++){\n      for(int j=0; j < w; j++){\n        cin >> G[i][j];\n      }\n    }\n    for(int i=0; i < 4; i++){\n      cin >> c[i];\n    }\n\n    int d[30][30][4];\n    vector<vector <bool> > used(30, vector<bool>(30, false));\n    fill(d[0][0], d[0][0] + 30*30*4, INF);\n    d[0][0][2] = 0;\n    priority_queue<State> pq;\n    pq.push(State(0, 0, 2, 0));\n    while(!pq.empty()){\n      State s = pq.top(); pq.pop();\n      used[s.y][s.x] = true;\n      for(int i=0; i < 4; i++){\n        int ndir = (s.dir+i) % 4;\n        int nx = s.x + dirx[ndir]; int ny = s.y + diry[ndir];\n        if(!(nx >= 0 && nx < w && ny >= 0 && ny < h)) continue;\n        if(G[s.y][s.x] == i){\n          if(d[s.y][s.x][s.dir] < d[ny][nx][ndir]){\n            d[ny][nx][ndir] = d[s.y][s.x][s.dir];\n            pq.push(State(nx, ny, ndir, d[ny][nx][ndir]));\n          }\n        }else{\n          if(d[s.y][s.x][s.dir] + c[i] < d[ny][nx][ndir]){\n            d[ny][nx][ndir] = d[s.y][s.x][s.dir] + c[i];\n            pq.push(State(nx, ny, ndir, d[ny][nx][ndir]));\n          }\n        }\n      }\n    }\n    cout << min(d[h-1][w-1][0], min(d[h-1][w-1][1], min(d[h-1][w-1][2], d[h-1][w-1][3]))) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nclass Element {\n    public:\n        int x, y, d, cost;\n        Element(int x, int y, int d, int cost):\n                x(x), y(y), d(d), cost(cost) {\n        }\n        bool operator<(const Element &e) const {\n            return (e.cost < this->cost);\n        }\n};\n\nclass Solver {\n    private:\n    public:\n        int w, h;\n        int c[4];\n        int s[30][30];\n        int solve() {\n            int retval = -1;\n            int dx[] = {1, 0, -1, 0};\n            int dy[] = {0, 1, 0, -1};\n            priority_queue<Element> heap;\n            int costs[30][30][4];\n            for (int y = 0; y < h; ++y) {\n                for (int x = 0; x < w; ++x) {\n                    for (int d = 0; d < 4; ++d) {\n                        costs[x][y][d] = -1;\n                    }\n                }\n            }\n            heap.push(Element(0, 0, 0, 0));\n            costs[0][0][0] = 0;\n            while (!heap.empty()) {\n                Element e = heap.top();\n                heap.pop();\n                for (int di = 0; di < 4; ++di) {\n                    int nd = (e.d + di) % 4;\n                    int nx = e.x + dx[nd];\n                    int ny = e.y + dy[nd];\n                    int cost = e.cost;\n                    if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n                        continue;\n                    }\n                    if (di != s[e.x][e.y]) {\n                        cost += c[di];\n                    }\n                    if (costs[nx][ny][nd] < 0 || cost < costs[nx][ny][nd]) {\n                        costs[nx][ny][nd] = cost;\n                        heap.push(Element(nx, ny, nd, cost));\n                    }\n                }\n            }\n            for (int d = 0; d < 4; ++d) {\n                if (costs[w - 1][h - 1][d] >= 0) {\n                    if (retval < 0) {\n                        retval = costs[w - 1][h - 1][d];\n                    } else {\n                        retval = min(retval, costs[w - 1][h - 1][d]);\n                    }\n                }\n            }\n            return retval;\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.w >> s.h;\n        if (s.w == 0) {\n            return 0;\n        }\n        for (int y = 0; y < s.h; ++y) {\n            for (int x = 0; x < s.w; ++x) {\n                cin >> s.s[x][y];\n            }\n        }\n        for (int i = 0; i < 4; ++i) {\n            cin >> s.c[i];\n        }\n        cout << s.solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) cout<<(#_v)<<\":\";for(auto(_x):(_v)){cout<<\" \"<<(_x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// 14:30-15:00\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nint w, h;\nint a[30][30];\nint c[4];\nint d[30][30][4]; // d[i][j][k] = (i, j):pos, k:dir\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint dijkstra() {\n    using State = tuple<int, int, int, int>; // cost, i, j, k\n    priority_queue<State, vector<State>, greater<State>> pq;\n    rep(i, h) rep(j, w) rep(k, 4) d[i][j][k] = inf;\n    d[0][0][1] = 0;\n    pq.push(State(0, 0, 0, 1));\n\n    while (!pq.empty()) {\n        int cost, i, j, k;\n        tie(cost, i, j, k) = pq.top(); pq.pop();\n        if (d[i][j][k] < cost) continue;\n        rep(nk, 4) {\n            int ni = i + dx[nk], nj = j + dy[nk];\n            if (!inside(ni, nj)) continue;\n            int ncost = c[(nk - k + 4) % 4];\n            if (a[i][j] != 4 && nk == (k + a[i][j]) % 4) {\n                ncost = 0;\n            }\n            if (d[ni][nj][nk] > cost + ncost) {\n                d[ni][nj][nk] = cost + ncost;\n                pq.push(State(cost + ncost, ni, nj, nk));\n            }\n        }\n    }\n\n    int ret = inf;\n    rep(k, 4) chmin(ret, d[h-1][w-1][k]);\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    while (cin >> w >> h, w) {\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        rep(i, 4) cin >> c[i];\n        cout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct state { \n    int x, y, c, d;\n    bool operator>(const state& rhs) const\n    {\n        return c > rhs.c;\n    };\n\n    bool operator<(const state& rhs) const\n    {\n        return c < rhs.c;\n    };\n\n    bool operator==(const state& rhs) const\n    {\n        return c == rhs.c;\n    };\n};\n\nint cs[5], field[31][31];\n        bool visited[31][31][4];\nint main()\n{\n    int w, h;\n    while(cin >> w >> h && w && h) {\n        for(int i = 1; i <= h; i++)\n            for(int j = 1; j <= w; j++)\n                cin >> field[i][j];\n        \n        for(int i = 0; i < 4; i++)\n            cin >> cs[i];\n        \n\n        for(int i = 0; i <= 30; i++)\n            for(int j = 0; j <= 30; j++)\n                fill(visited[i][j], visited[i][j] + 4, false);\n        \n        priority_queue<state, vector<state>, greater<state> > que;\n        que.push((state){1, 1, 0, 1});\n        \n        int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0};\n        while(!que.empty()) {\n            state s = que.top(); que.pop();\n            int x, y, c, d;\n            x = s.x; y = s.y; c = s.c; d = s.d;\n            if(visited[y][x][d])\n                continue;\n\n            visited[y][x][d] = true;\n\n            if(x == w && y == h) {\n                cout << c << endl;\n                break;\n            }\n\n            for(int k = 0; k < 4; k++) {\n                int nd = (d + k) % 4;\n                int nx, ny, nc;\n                nx = x + dx[nd];\n                ny = y + dy[nd];\n                if(k == field[y][x]) {\n                    nc = c;\n                } else {\n                    nc = c + cs[k];\n                }\n                if(nx >= 1 && nx <= w && ny >= 1 && ny <= h)\n                    que.push((state){nx, ny, nc, nd});\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n\n    int c[4];\n    vector<vector<int> > s(h + 2, vector<int>(w + 2, -1));\n    for(int i = 1; i <= h; i++)\n      for(int j = 1; j <= w; j++)\n        cin >> s[i][j];\n    cin >> c[0] >> c[1] >> c[2] >> c[3];\n\n    int cost[5][4][4];\n    for(int i = 0; i < 5; i++){\n      for(int in = 0; in < 4; in++){\n        for(int out = 0; out < 4; out++){\n          int compass = (out + 4 - in) % 4;\n          if(i == compass){ cost[i][in][out] = 0; }\n          else{ cost[i][in][out] = c[compass]; }\n        }\n      }\n    }\n      \n    priority_queue<pair<int, pair<pair<int, int>, int> > > wait;\n    vector<vector<vector<int> > > result(h + 2, vector<vector<int> >(w + 2, vector<int>(4, INF)));\n    wait.push(make_pair(0, make_pair(make_pair(1, 1), 0)));\n    result[1][1][0] = 0;\n    while(!wait.empty()){\n      int nowcost = -wait.top().first;\n      int nowX = wait.top().second.first.first;\n      int nowY = wait.top().second.first.second;\n      int nowCompass = wait.top().second.second;\n      wait.pop();\n      if(s[nowX][nowY] == -1 || result[nowX][nowY][nowCompass] < nowcost){ continue; }\n      \n      for(int i = 0; i < 4; i++){\n        int nextCompass = i;\n        int nextcost = nowcost + cost[s[nowX][nowY]][nowCompass][nextCompass];\n        int nextX = nowX + dx[i];\n        int nextY = nowY + dy[i];\n        if(result[nextX][nextY][nextCompass] > nextcost){\n          wait.push(make_pair(-nextcost, make_pair(make_pair(nextX, nextY), nextCompass)));\n          result[nextX][nextY][nextCompass] = nextcost;\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int i = 0; i < 4; i++){ ans = min(ans, result[h][w][i]); }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n/*}}}*/\n\n#define Y real()\n#define X imag()\n\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum Direction {\n\tNORTH,\n\tEAST,\n\tSOUTH,\n\tWEST\n};\n\nenum Operation {\n\tSTRAIGHT,\n\tRIGHT,\n\tBACK,\n\tLEFT,\n\tHALT\n};\n\nclass Node {\npublic:\n\tP pos;\n\tint direction;\n\n\tNode(P p, int d): pos(p), direction(d) {\n\t}\n\n\t// for std::map\n\tbool operator < (const Node& other) const {\n\t\t// Need to be deterministic\n\t\t// BE CAREFUL -- this comparison is likely to be buggy\n\t\tif (direction != other.direction) {\n\t\t\treturn direction < other.direction;\n\t\t} else {\n\t\t\tif (pos.Y != other.pos.Y) {\n\t\t\t\treturn pos.Y < other.pos.Y;\n\t\t\t} else {\n\t\t\t\treturn pos.X < other.pos.X;\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef pair<int, Node> Qtype; // cost and Node\nclass Comp {\npublic:\n\tbool operator() (const Qtype& l, const Qtype& r) const {\n\t\t// compair costs for each Node\n\t\treturn (l.F > r.F);\n\t}\n};\n\nbool in_field(P p, int height, int width)\n{\n\treturn (0 <= p.Y && p.Y < height) && (0 <= p.X && p.X < width);\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\t\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tVVI field(h, VI(w));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tVI operation_costs(4);\n\t\tREP (i, 4) {\n\t\t\tcin >> operation_costs[i];\n\t\t}\n\n\t\tmap<Node, int> costs;\n\t\tpriority_queue< Qtype, vector<Qtype>, Comp > q;\n\n\t\tq.push( MP(0, Node(P(0, 0), EAST)) );\n\t\twhile (!q.empty()) {\n\t\t\tQtype t = q.top(); q.pop();\n\t\t\tint cost_here = t.F; Node node = t.S;\n\n\t\t\t// Skip if already visited\n\t\t\tif (EXIST(costs, node)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcosts[node] = cost_here;\n\n\t\t\tREP (op, 4) {\n\t\t\t\tint cost_to_next = (op == field[node.pos.Y][node.pos.X] ? 0 : operation_costs[op]);\n\t\t\t\tint ndir = (node.direction + op) % 4;\n\t\t\t\tP np = node.pos + P(dy[ndir], dx[ndir]);\n\t\t\t\tif (in_field(np, h, w)) {\n\t\t\t\t\tq.push(MP(cost_here + cost_to_next, Node(np, ndir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP (dir, 4) {\n\t\t\tNode n = Node(P(h-1, w-1), dir);\n\t\t\tif (EXIST(costs, n)) {\n\t\t\t\tans = min(ans, costs[n]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define min(a,b) ((a)>(b)?(b):(a))\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main() {\n\tint map[M+4][M+4], c[4], w, h;\n\tint dp[M+4][M+4][M*M*2+10][4], ans;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\tfor(int i=1; i<=h; ++i) {\n\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tfor(int t=0; t<=w*h; ++t) {\n\t\t\t\t\tfor(int k=0; k<4; ++k) dp[i][j][t][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\tdp[1][1][0][0] = 0; ans = INF;\n\t\tfor(int t=1; t<=w*h*2; ++t) {\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tif(i==h&&j==w) continue;\n\t\t\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\t\t\tfor(int l=0; l<4; ++l) {\n\t\t\t\t\t\t\tint d = (k+l)%4;\n\t\t\t\t\t\t\tif(map[i][j]==l) {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]+c[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j+dx[d]==w&&i+dy[d]==h) {\n\t\t\t\t\t\t\t\tans = min(ans, dp[i+dy[d]][j+dx[d]][t][d]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\nint G[SIZE][SIZE], C[4];\nint H, W;\nstruct dijkstra {\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost<s.cost;\n  }\n};\n \nint dijkstra() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State,greater<State> > pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n     && 0 <= t.y && t.y < H \n     && cost[t.d][t.y][t.x] > t.cost) {\n    pq.push(t);\n    cost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n   \n  return INF;\n}\n \nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n    cin >> G[i][j];\n    for(int i=0; i<4; i++) cin >> C[i];\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 100000000\nusing namespace std;\n\nint W, H, S[30][30], C[4];\nint dd[5] = { 0, 1, 0, -1, 0 };\nbool vd[30][30][4];\n\nint isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid move(int cy, int cx, int dir, int inst, int* ny, int* nx, int* ndir) {\n  *ndir = (dir + inst) % 4;\n  *ny = cy + dd[*ndir];\n  *nx = cx + dd[*ndir + 1];\n  // cout << cy << \" \" << cx << \" \" << dir << \" \" << inst << \" -> \" << *ny << \" \" << *nx << \" \" << *ndir << endl;\n}\n\nint dfs(int cy, int cx, int dir, int cost, int m) {\n  // cout << cy << \" \" << cx << \" \" << dir << \" \" << cost << endl;\n  if(cy == H - 1 && cx == W - 1) return cost;\n\n  REP(i, 0, 4) {\n    int ny, nx, ndir, temp = S[cy][cx];\n    move(cy, cx, dir, S[cy][cx] = i, &ny, &nx, &ndir);\n\n    int c = cost + (i != temp ? C[i] : 0);\n    if(isin(ny, nx) && !vd[cy][cx][ndir] && c < m) {\n      bool v = vd[cy][cx][ndir];\n      vd[cy][cx][ndir] = true;\n      m = min(m, dfs(ny, nx, ndir, c, m));\n      vd[cy][cx][ndir] = v;\n    }\n\n    S[cy][cx] = temp;\n  }\n\n  return m;\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n    REP(i, 0, 4) cin >> C[i];\n    REP(i, 0, H) REP(j, 0, W) REP(k, 0, 4) vd[i][j][k] = false;\n    cout << dfs(0, 0, 0, 0, INF) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nclass node {\npublic:\n  int cost, x, y, d;\n  node(int _cost, int _x, int _y, int _d) {\n    cost = _cost;\n    x = _x;\n    y = _y;\n    d = _d;\n  }\n  bool operator > (const node &s) const {\n    return cost > s.cost;\n  }\n};\n\nint main() {\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {-1, 0, 1, 0};\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) {\n      break;\n    }\n\n    int field[w][h];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n\tcin >> field[j][i];\n      }\n    }\n    int d[4];\n    for (int i = 0; i < 4; i++) {\n      cin >> d[i];\n    }\n\n    int memo[w][h][4];\n    memset(memo, -1, sizeof(memo));\n    priority_queue <node, vector<node>, greater<node> > pque;\n    pque.push(node(0, 0, 0, 1));\n    while (!pque.empty()) {\n      node p = pque.top(); pque.pop();\n\n      for (int i = 0; i < 4; i++) {\n\tint nd = (i+p.d)%4;\n\tint nx = p.x+dx[nd];\n\tint ny = p.y+dy[nd];\n\n\tif (nx < 0 || ny < 0 || nx >= w || ny >= h) {\n\t  continue;\n\t}\n\tif (field[p.x][p.y] == i) {\n\t  if (memo[nx][ny][nd] == -1 ||\n\t      memo[nx][ny][nd] > memo[p.x][p.y][p.d]) {\n\t    memo[nx][ny][nd] = memo[p.x][p.y][p.d];\n\t    pque.push(node(memo[nx][ny][nd], nx, ny, nd));\n\t  }\n\t}else {\n\t  if (memo[nx][ny][nd] == -1 ||\n\t      memo[nx][ny][nd] > memo[p.x][p.y][p.d]+d[i]) {\n\t    memo[nx][ny][nd] = memo[p.x][p.y][p.d]+d[i];\n\t    pque.push(node(memo[nx][ny][nd], nx, ny, nd));\n\t  }\n\t}\n      }\n    }\n\n    std::cout << min(memo[w-1][h-1][1], memo[w-1][h-1][2])+1 << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\nconst int INFTY=1<<29;\n\nstruct State{\n\tint i,j,dir,cost;\n\tState(){}\n\tState(int i,int j,int d,int c):i(i),j(j),dir(d),cost(c){}\n\tbool operator<(const State& s)const{return cost<s.cost;}\n\tbool operator>(const State& s)const{return cost>s.cost;}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tint grid[30][30];\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>grid[i][j];\n\t\tint c[4];\n\t\trep(i,4)\n\t\t\tcin>>c[i];\n\t\t\n\t\tint cost[30][30][4];\n\t\trep(i,h) rep(j,w) rep(k,4)\n\t\t\tcost[i][j][k]=INFTY;\n\t\t\n\t\tpriority_queue<State,vector<State>,greater<State> > pq;\n\t\tpq.push(State(0,0,0,0));\n\t\twhile(pq.size()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(cost[cur.i][cur.j][cur.dir]!=INFTY)\n\t\t\t\tcontinue;\n\t\t\tcost[cur.i][cur.j][cur.dir]=cur.cost;\n\t\t\t\n\t\t\tint di[]={0,-1,0,1},dj[]={1,0,-1,0};\n\t\t\t{ // straight\n\t\t\t\tint d=cur.dir,ni=cur.i+di[d],nj=cur.j+dj[d],f=grid[cur.i][cur.j]!=0;\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w)\n\t\t\t\t\tpq.push(State(ni,nj,d,cur.cost+f*c[0]));\n\t\t\t}\n\t\t\t{ // right\n\t\t\t\tint d=(cur.dir+3)%4,ni=cur.i+di[d],nj=cur.j+dj[d],f=grid[cur.i][cur.j]!=1;\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w)\n\t\t\t\t\tpq.push(State(ni,nj,d,cur.cost+f*c[1]));\n\t\t\t}\n\t\t\t{ // back\n\t\t\t\tint d=(cur.dir+2)%4,ni=cur.i+di[d],nj=cur.j+dj[d],f=grid[cur.i][cur.j]!=2;\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w)\n\t\t\t\t\tpq.push(State(ni,nj,d,cur.cost+f*c[2]));\n\t\t\t}\n\t\t\t{ // left\n\t\t\t\tint d=(cur.dir+1)%4,ni=cur.i+di[d],nj=cur.j+dj[d],f=grid[cur.i][cur.j]!=3;\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w)\n\t\t\t\t\tpq.push(State(ni,nj,d,cur.cost+f*c[3]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,4)\n\t\t\tres=min(res,cost[h-1][w-1][i]);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\nclass state{\npublic:\n\tint dir,x,y,cost;\n\tstate(int _d, int _x, int _y, int _c){\n\t\tdir=_d; x=_x; y=_y; cost=_c;\n\t}\n\tbool operator<(const state& tmp)const{\n\t\treturn cost>tmp.cost;\n\t}\n};\n\nconst int dx[] = {0,1,0,-1}; // up, right, down, left\nconst int dy[] = {-1,0,1,0};\nint memo[4][32][32];\n\nint main(){\n\tint w,h;\n\tint field[32][32],c[4];\n\twhile(scanf(\"%d%d\",&w,&h),w|h){\n\t\trep(i,32)rep(j,32)memo[0][i][j]=memo[1][i][j]=memo[2][i][j]=memo[3][i][j]=INT_MAX;\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&field[i][j]);\n\t\tscanf(\"%d%d%d%d\",c,c+1,c+2,c+3);\n\t\t\n\t\tpriority_queue<state> q;\n\t\tq.push(state(1,0,0,0));\n\t\tmemo[1][0][0]=0;\n\t\t\n\t\tint karikari = INT_MAX;\n\t\twhile( !q.empty() ){\n\t\t\tint x = q.top().x;\n\t\t\tint y = q.top().y;\n\t\t\tint co = q.top().cost;\n\t\t\tint d = q.top().dir;\n\t\t\t\n\t\t\tif( karikari<co )break;\n\t\t\tq.pop();\n\t\t\trep(i,4){\n\t\t\t\tint next_dir = (d+i)%4;\n\t\t\t\tint tx = x + dx[next_dir];\n\t\t\t\tint ty = y + dy[next_dir];\n\t\t\t\t\n\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h )continue;\n\t\t\t\t//if( !(tx==w-1 && ty==h-1) && field[ty][tx]==4 )continue;\n\t\t\t\t\n\t\t\t\t//printf(\"t(%d,%d),(dir:%d, i:%d, (%d,%d), c:%d)\",tx,ty,d,i,x,y,co);\n\t\t\t\tif( i==field[y][x] ){\n\t\t\t\t\t//printf(\" --(y)-->(dir:%d ,(%d,%d), c:%d)\\n\",next_dir,tx,ty,co);\n\t\t\t\t\tif( memo[next_dir][ty][tx] > co ){\n\t\t\t\t\t\tmemo[next_dir][ty][tx] = co;\n\t\t\t\t\t\tif( !(tx==w-1&&ty==h-1) ){\n\t\t\t\t\t\t\tq.push(state(next_dir, tx, ty, co));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tkarikari = min(karikari,co);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//printf(\" --(n)-->(dir:%d ,(%d,%d), c:%d)\\n\",next_dir,tx,ty,co+c[i]);\n\t\t\t\t\tif( memo[next_dir][ty][tx] > co + c[i] ){\n\t\t\t\t\t\tmemo[next_dir][ty][tx] = co + c[i];\n\t\t\t\t\t\tif( !(tx==w-1&&ty==h-1) ){\n\t\t\t\t\t\t\tq.push(state(next_dir, tx, ty, co+c[i]));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tkarikari = min(karikari,co+c[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\t\n\t\tint ans = INT_MAX;\n\t\trep(i,4)ans=min(ans,memo[i][h-1][w-1]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 10000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\tll ans = INF;\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint cost[4][31][31];\nint field[31][31];\n\nconst int INF = 1 << 28;\n\nstruct state{\n\tint x;\n\tint y;\n\tint dir;\n\tint cost;\n\n\tstate(int a, int b, int c, int d){\n\t\tx = a; y = b; dir = c; cost = d;\n\t}\n\n\tbool operator <(const state &rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\twhile(1){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(!w && !h) break;\n\n\n\t\trep(i, 4){\n\t\t\trep(j, h){\n\t\t\t\trep(k, w){\n\t\t\t\t\tcost[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint c[4];\n\t\trep(i, 4){\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tpriority_queue<state> q;\n\n\t\tq.push(state(0, 0, 0, 0));\n\n\t\twhile(!q.empty()){\n\t\t\tstate s = q.top();\n\t\t\tq.pop();\n\n\t\t\tif( cost[s.dir][s.y][s.x] <= s.cost ) continue;\n\t\t\tcost[s.dir][s.y][s.x] = s.cost;\n\t\t\t//printf(\"(%d,%d) dir=%d cost=%d\\n\", s.x, s.y, s.dir, s.cost);\n\n\t\t\trep(i, 4){\t// i=>相対方向\n\t\t\t\tint d = (s.dir + i) % 4; // d=>絶対方向\n\t\t\t\tint x = s.x + dx[d];\n\t\t\t\tint y = s.y + dy[d];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h) continue;\n\t\t\t\tint co = c[i];\n\t\t\t\tif(i == field[s.y][s.x]) co = 0;\n\t\t\t\tq.push(state(x, y, d, s.cost+co));\n\t\t\t}\n\t\t}\n\n\t\tint best = INF;\n\t\trep(i, 4){\n\t\t\tbest = min(best, cost[i][h-1][w-1]);\n\t\t}\n\t\tcout << best << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Tag {\n    int r, c, dir;\n    int cost;\n\n    Tag() {}\n    Tag(int r, int c, int dir, int cost) : r(r), c(c), dir(dir), cost(cost) {}\n\n    bool operator <(const Tag &other) const {\n        return cost > other.cost;\n    }\n};\n\n// dir = EAST, NORTH, WEST, SOUTH\nint DR[4] = {0, -1, 0, 1};\nint DC[4] = {1, 0, -1, 0};\n// {STRAIGHT, RIGHT, BACK, LEFT}\nint DD[4] = {0, 3, 2, 1};\n\ninline bool in_range(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nbool update(int &a, int v) {\n    if(v < a) {\n        a = v;\n        return true;\n    }\n    return false;\n}\n\n// memo[dir][r][c]\nint memo[4][30][30];\nint main() {\n    while(true) {\n        int W, H;\n        cin >> W >> H;\n        if(!W && !H) break;\n\n        vector<vector<int> > field(H);\n        for(int i = 0; i < H; ++i) {\n            field[i].resize(W);\n            for(int j = 0; j < W; ++j) {\n                cin >> field[i][j];\n            }\n        }\n        vector<int> cost(4);\n        for(int i = 0; i < 4; ++i) {\n            cin >> cost[i];\n        }\n\n        for(int dir = 0; dir < 4; ++dir) {\n            for(int r = 0; r < H; ++r) {\n                for(int c = 0; c < W; ++c) {\n                    memo[dir][r][c] = INT_MAX;\n                }\n            }\n        }\n        int ans = -1;\n        priority_queue<Tag> q;\n        q.push(Tag(0, 0, 0, 0));\n        memo[0][0][0] = 0;\n        while(!q.empty()) {\n            Tag cur = q.top();\n            q.pop();\n            if(cur.r == H-1 && cur.c == W-1) {\n                ans = cur.cost;\n                break;\n            }\n            if(memo[cur.dir][cur.r][cur.c] < cur.cost) continue;\n\n            for(int act = 0; act < 4; ++act) {\n                const int ncost = (field[cur.r][cur.c] == act) ? cur.cost : (cur.cost+cost[act]);\n                const int nd = (cur.dir + DD[act]) % 4;\n                const int nr = cur.r + DR[nd];\n                const int nc = cur.c + DC[nd];\n                if(in_range(0, nr, H) && in_range(0, nc, W)) {\n                    if(update(memo[nd][nr][nc], ncost)) {\n                        q.push(Tag(nr, nc, nd, ncost));\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint s[31][31],mini[30][30][4];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\nstruct Data{\n    int x,y,dir,cost;\n    bool operator<(const Data &obj)const{\n        if(cost != obj.cost)return cost > obj.cost;\n        return false;\n    }\n};\n\nint main(){\n\n    while(1){\n        int w, h;\n\n        scanf(\"%d %d\",&w,&h);\n        if(w == 0 && h == 0)break;\n\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                scanf(\"%d\",&s[i][j]);\n            }\n        }\n        int c[4];\n        scanf(\"%d %d %d %d\",&c[0],&c[1],&c[2],&c[3]);\n\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                for(int k=0;k<4;++k){\n                    mini[i][j][k] = INT_MAX;\n                }\n            }\n        }\n        mini[0][0][0] = 0;\n\n        priority_queue<Data> Q;\n        Q.push((Data){0,0,0,0});\n\n        while(!Q.empty()){\n            Data state = Q.top();\n            Q.pop();\n            if(state.x == w-1 && state.y == h-1){\n                cout << state.cost << endl;\n                break;\n            }\n            for(int i=0;i<4;++i){\n                int newdir=(state.dir+i)&3, newcost=state.cost;\n                int newx=state.x+dx[newdir], newy=state.y+dy[newdir];\n                if(newx < 0 || newy < 0 || newx >= w || newy >= h)continue;\n                if(s[state.y][state.x] != i)newcost += c[i];\n                if(newcost < mini[newy][newx][newdir]){\n                    Q.push((Data){newx,newy,newdir,newcost});\n                    mini[newy][newx][newdir] = newcost;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nclass state{\npublic:\n  int x,y,dir,cost;\n  state(int _x, int _y, int _d, int _c){\n    x=_x;\n    y=_y;\n    dir=_d;\n    cost=_c;\n  }\n  bool operator<(const state& a)const{\n    return cost > a.cost;\n  }\n};\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h;\nint field[32][32];\nint dp[4][32][32];\nint C[4];\n\nbool inside(int x, int y){\n  return !(x<0 || y<0 || x>=w || y>=h);\n}\n\nint main(){\n  int i,j,k;\n  while(cin>>w>>h,w|h){\n    rep(i,4)rep(j,32)rep(k,32)dp[i][j][k]=INT_MAX;\n    rep(i,h){\n      rep(j,w){\n\tcin>>field[i][j];\n      }\n    }\n    scanf(\"%d%d%d%d\",C,C+1,C+2,C+3);\n\n    int ans = -1;\n    priority_queue<state> q;\n    dp[1][0][0] = 0;\n    q.push(state(0,0,1,0));\n    while( !q.empty() ){\n      int x = q.top().x;\n      int y = q.top().y;\n      int dir = q.top().dir;\n      int cost = q.top().cost;\n      q.pop();\n      \n      if( x==w-1 && y==h-1 ){\n\tans = cost;\n\tbreak;\n      }\n#if DEB\n      printf(\"(%d,%d) dir:%d, cost:%d\\n\",x,y,dir,cost);\n#endif\n\n      rep(k,4){\n\tint nextdir = (dir+k)%4;\n\tint tx = x + dx[nextdir];\n\tint ty = y + dy[nextdir];\n\tif( !inside(tx,ty) )continue;\n\t\n\tif( field[y][x] == k ){\n\t  if( dp[nextdir][ty][tx] > cost ){\n\t    dp[nextdir][ty][tx] = cost;\n\t    q.push(state(tx,ty,nextdir,cost));\n\t  }\n\t}else{\n\t  if( dp[nextdir][ty][tx] > cost + C[k] ){\n\t    dp[nextdir][ty][tx] = cost + C[k];\n\t    q.push(state(tx,ty,nextdir,cost+C[k]));\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nvector< vector< vector< int > > > costs;\n\nstruct data_t {\n\tint m_d, m_x, m_y;\n\tdata_t(int d, int y, int x) { m_d = d; m_y = y; m_x = x; }\n};\n\nint solve(void);\n\nint main(void) {\n\t\t\n\twhile (solve());\n\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\t//\tinput\n\tint w, h;\n\n\tcin >> w >> h;\n\tif (!(w | h)) { return 0; }\n\n\tvector< vector< int > > s(h, vector< int > (w, (1<<30)));\n\tcosts.clear();\n\tcosts.resize(4, s);\n\tvector<int> c(4);\n\n\t// right, down, left, up\n\tint d[4][2] = { {0,1}, {1,0}, {0,-1},{-1,0} };\n\n\tfor (int i = 0; i < h; i++)\n\t\tfor (int j = 0; j < w; j++)\n\t\t\tcin >> s[i][j];\n\n\tfor (int i = 0; i < 4; i++)\n\t\tcin >> c[i];\n\n\tcosts[0][0][0] = 0;\n\n\tqueue< data_t > q;\n\tq.push(data_t(0, 0, 0));\n\n\twhile (!q.empty()) {\n\n\t\tdata_t doneNode = q.front();\n\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tdata_t to = doneNode;\n\t\t\tint cost = costs[doneNode.m_d][doneNode.m_y][doneNode.m_x] + c[i];\n\t\t\tif (i == s[to.m_y][to.m_x]) { cost = costs[doneNode.m_d][doneNode.m_y][doneNode.m_x]; }\n\n\t\t\tto.m_d = (to.m_d + i) % 4;\n\t\t\tto.m_y += d[to.m_d][0];\n\t\t\tto.m_x += d[to.m_d][1];\n\t\t\t\n\t\t\tif (to.m_x >= 0 && to.m_x < w && to.m_y >= 0 && to.m_y < h) {\n\t\t\t\tif (cost < costs[to.m_d][to.m_y][to.m_x]) {\n\t\t\t\t\tcosts[to.m_d][to.m_y][to.m_x] = cost;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t\n\tint ans = costs[0][h - 1][w - 1];\n\n\tfor (int i = 0; i < 4; i++)\n\t\tans = min(ans, costs[i][h - 1][w - 1]);\n\n\tcout << ans << endl;\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s first\n#define p second\nusing namespace std;\ntypedef pair<pair<int,int>,pair<int,int> > P;\nint d[32][32][4],h,w,c[32][32],e[4],dx[]={0,1,0,-1},dy[]={-1,0,1,0};\npriority_queue<P,vector<P>,greater<P> >Q;\nvoid Pb(int a,int b,int f,int g){Q.push(make_pair(make_pair(a,b),make_pair(f,g)));}\nvoid B(int k,int z,int y,int x){\n\td[y][x][z]=k;\n\tfor(int i=0;i<4;i++){\n\t\tint r=(i+z)%4,xx=x+dx[r],yy=y+dy[r];\n\t\tif(xx<0||yy<0||xx==w||yy==h)continue;\n\t\tif(i==c[y][x])Pb(k,r,yy,xx);\n\t\telse Pb(k+e[i],r,yy,xx);\n\t}\n}\nint main(){\n\twhile(cin>>w>>h&&w){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>c[i][j];\n\t\t\tfor(int k=0;k<4;k++)d[i][j][k]=11451419;\n\t\t}\n\t}Pb(0,1,0,0);\n\tfor(int i=0;i<4;i++)cin>>e[i];\n\twhile(!Q.empty()){\n\t\tint a=Q.top().s.s,b=Q.top().s.p,f=Q.top().p.s,g=Q.top().p.p;\n\t\tQ.pop();if(d[f][g][b]>a)B(a,b,f,g);\n\t}\n\tint a=11451419;\n\tfor(int i=0;i<4;i++)a=min(a,d[h-1][w-1][i]);\n\tcout<<a<<endl;\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\nclass Node{\npublic:\n\tint cost;\n\tint w;//x\n\tint h;//y\n\tint dir;//up:0 right:1 down:2 left:3\n\tNode(int c,int _h,int _w,int d){\n\t\tcost=c;\n\t\tw=_w;\n\t\th=_h;\n\t\tdir=d;\n\t}\n\n\tbool operator < (const Node &o) const{\n\t\treturn cost > o.cost;\n\t}\n};\n#define MAX 1000000\n#define MAX_NODE 30\n#define MAX_FUNC 5\n#define STOP 1000\nint map[MAX_NODE+1][MAX_NODE+1];\nint func[MAX_FUNC];\nint w,h;\nint dx[]={ 0, 1, 0,-1};\nint dy[]={-1, 0, 1, 0};\ntypedef priority_queue<Node> PQ;\n//visited[][]\nbool closed[MAX_NODE+1][MAX_NODE+1][MAX_FUNC];\nint d[MAX_NODE+1][MAX_NODE+1][MAX_FUNC];\n\nvoid init(){\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)for(int k=0;k<MAX_FUNC;k++)d[i][j][k]=MAX;\n}\nint search(){\n\tinit();\n\tPQ pq;\n\tpq.push(Node(0,1,1,1));\n\td[1][1][1]=0;\n\twhile(!pq.empty()){\n\t\tNode current = pq.top();pq.pop();\n\t\tif(current.h==h&&current.w==w){\n\t\t\t//cout<<\"goal[\"<<current.h<<\"][\"<<current.w<<\"]\"<<endl;\n\t\t\treturn current.cost;\n\t\t}\n//\t\tcout<<\"[\"<<current.h<<\"][\"<<current.w<<\"]\"<<current.cost<<\"(\"<<current.dir<<\")\"<<endl;\n\n\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nextdir=(i+current.dir)%4;\n\t\t\tint nextCost;\n\t\t\tif(i==map[current.h][current.w])nextCost=current.cost;\n\t\t\telse nextCost=current.cost+func[i];\n\n\t\t\tNode next(nextCost,current.h+dy[nextdir],current.w+dx[nextdir],nextdir);\n\t\t//\tcout<<\"    next(\"<<next.h<<\",\"<<next.w<<\")\"<<next.cost<<endl;\n\t\t\tif(next.h<1||next.w<1||next.h>h||next.w>w){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//cout<<\"    d[\"<<next.h<<\"][\"<<next.w<<\"]\"<<d[next.h][next.w][next.dir]<<\":\"<<next.cost<<endl;\n\t\t\t\tif(d[next.h][next.w][next.dir]>next.cost){\n\t\t\t\t\td[next.h][next.w][next.dir]=next.cost;\n\t\t\t\t\tpq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool input(){\n\tcin>>w>>h;\n\t//cout<<\"w:\"<<w<<\" h:\"<<h<<endl;\n\tif(w==0&&h==0)return false;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)cin>>map[i][j];\n\tfor(int i=0;i<MAX_FUNC-1;i++){\n\t\tcin>>func[i];\n\t\t//cout<<func[i]<<endl;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(input()){\n\t\tcout<<search()<<endl;;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[31][31];\nint memo[4][31][31];\nint memo2[31][31];\nint c[4];\nint ans;\nint cnt;\nstring str = \">v<^\";\n \nvoid saiki(int x,int y,int dir,int cost) {\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,1,0,-1};\n \n   \n  if(x == w-1 && y == h-1 && ans > cost) ans = cost;\n  else if(memo[dir%4][y][x]>cost && ans > cost){\n    memo[dir%4][y][x] = cost;\n    cnt++;\n     \n    //    cout << str[dir%4];\n    //  cout <<\" \"<< x <<\" \" << y <<\" cost=\"<<cost<<endl\n     \n    for(int i=0;i<4;i++){\n      int ii = (i+dir%4)%4;\n      int nx = x + dx[ii];\n      int ny = y + dy[ii]; \n      if(nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n      if(i == mp[y][x]) {\n\tsaiki(nx,ny,(dir+i),cost);\n      }\n      else\n\tsaiki(nx,ny,(dir+i),cost+c[i]);\n       \n    }\n  }\n}\n \nint main() {\n   \n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n \n \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> mp[i][j];\n \n \n    for(int i=0;i<4;i++)cin >> c[i];\n \n \n \n    for(int i=0;i<4;i++)\n      for(int j=0;j<31;j++)\n\tfor(int k=0;k<31;k++)\n\t  memo[i][j][k] = 1000000000;\n \n    ans = 1000000000;\n    cnt = 0;\n    saiki(0,0,0,0);\n \n    cout << ans<< endl;\n    //  cout << cnt <<endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<array>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nstruct Entry\n{\n    int x, y;\n    int direction;\n};\n\nint main()\n{\n    int w, h;\n\n    while(cin >> w >> h, (w | h) )\n    {\n\n        //map[h][w]\n        array< array<int, 30>, 30> map{};\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cin >> map[i][j];\n            }\n        }\n        \n        //command[0]?????´???\n        //command[1]?????????\n        //command[2]????????¢\n        //command[3]?????????\n        array<int, 4> command;\n        for(int i = 0; i < 4; i++)\n        {\n            cin >> command[i];\n        }\n\n       \n        //??????????????\\?????????????????¨?????????\n        array< array< array< int, 4>, 30>, 30> cost;\n\n        //cost[0][][]??????\n        //cost[1][][]??????\n        //cost[2][][]??????\n        //cost[3][][]??????\n\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cost[0][i][j] = INF;\n                cost[1][i][j] = INF;\n                cost[2][i][j] = INF;\n                cost[3][i][j] = INF;\n            }\n        }\n\n        const int dx[4] = {1, 0, -1, 0};\n        const int dy[4] = {0, 1, 0, -1};\n\n\n        //start\n        cost[0][0][0] = 0;\n\n        queue<Entry> que;\n\n        que.push(Entry{0, 0, 0});\n\n        while(!que.empty())\n        {\n            Entry now = que.front();\n            //cout << que.size() << \" : (\" << now.x << \", \" << now.y  << \") \" << now.direction << \" : \" << cost[now.direction][now.y][now.x] << endl;\n\n            int followedDirection = now.direction + map[now.y][now.x];\n            followedDirection %= 4;\n\n            if(map[now.y][now.x] == 4)followedDirection = INF;\n\n            //(i + now.direction) % 4????¬??????????\n            //i????????¢???????§????\n            for(int i = 0; i < 4; i++)\n            {\n                int nextDirection = (i + now.direction) % 4;\n                int tmp_cost = cost[now.direction][now.y][now.x] + !(nextDirection == followedDirection) * command[i];\n\n                int nextX = now.x + dx[nextDirection];\n                int nextY = now.y + dy[nextDirection];\n\n                //???????????????????????????\n                if( !(nextX < 0 || nextX >= w || nextY < 0 || nextY >= h) ) \n                {\n                    //?????????????°???????????????°?§????\n                    if(tmp_cost < cost[nextDirection][nextY][nextX])\n                    {\n                        cost[nextDirection][nextY][nextX] = tmp_cost;\n                        que.push( Entry{ nextX, nextY, nextDirection } );\n                    }\n                }                \n            }\n            que.pop();\n        }\n\n        int ans = INF;\n        for(int i = 0; i < 4; i++)\n        {\n            if(cost[i][h - 1][w - 1] < ans)ans = cost[i][h - 1][w - 1];\n            //cout << cost[i][h - 1][w - 1] << endl;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\ntypedef pair<int,pair<pair<int,int>,int>> PACK;\n\nint main(){\n  int w,h;\n  while(cin>>w>>h,w){\n    vector<vector<int>> s(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>s[i][j];\n      }\n    }\n    vector<int> c(4);\n    for(int i=0;i<4;i++){\n      cin>>c[i];\n    }\n    const int INF=1e8;\n    vector<vector<vector<int>>> dp(h,vector<vector<int>>(w,vector<int>(4,INF)));\n    dp[0][0][0]=0;\n    priority_queue<PACK,vector<PACK>,greater<PACK>> que;\n    que.push(make_pair(0,make_pair(make_pair(0,0),0)));\n\n    auto isrange=[w,h](int x,int y){return 0<=x && x<h && 0<=y && y<w;};\n      \n    int res=1e9;\n    while(!que.empty()){\n      auto buf=que.top();\n      que.pop();\n      int cost=buf.first;\n      auto state=buf.second;\n      pair<int,int> place=state.first;\n      int dir=state.second;\n      if(place.first==h-1 && place.second==w-1){\n\tres=cost;\n\tbreak;\n      }\n      if(cost>dp[place.first][place.second][dir]){\n\tcontinue;\n      }\n      int pat;\n      if((pat=s[place.first][place.second])!=4){\n\tint todir=(dir+pat)%4;\n\tint tox=place.first+dx[todir];\n\tint toy=place.second+dy[todir];\n\tif(isrange(tox,toy) && dp[tox][toy][todir]>cost){\n\t  dp[tox][toy][todir]=cost;\n\t  auto tostate=make_pair(make_pair(tox,toy),todir);\n\t  auto quing=make_pair(cost,tostate);\n\t  que.push(quing);\n\t}\n      }\n      for(int i=0;i<4;i++){\n\tint todir=(dir+i)%4;\n\tint tox=place.first+dx[todir];\n\tint toy=place.second+dy[todir];\n\tif(isrange(tox,toy) && dp[tox][toy][todir]>cost+c[i]){\n\t  dp[tox][toy][todir]=cost+c[i];\n\t  auto tostate=make_pair(make_pair(tox,toy),todir);\n\t  auto quing=make_pair(dp[tox][toy][todir],tostate);\n\t  que.push(quing);\n\t}\n      }\n    }\n\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\n\nint const N = 30;\nint const Ord = 4;\nint const inf = 1234567; //std::numeric_limits<int>::max() - 500000;\n\nint const x_diff[] = {1, 0, -1, 0};\nint const y_diff[] = {0, 1, 0, -1};\n\n\nclass robot\n{\npublic:\n    robot( int x, int y, int dir )\n        : x_(x)\n        , y_(y)\n        , dir_(dir)\n    {}\n\n    bool operator<(robot const&) const{ return true; }\n\npublic:\n    void forward()\n    {\n        x_ += x_diff[dir_];\n        y_ += y_diff[dir_];\n    }\n\n    bool right_forward()\n    {\n        turn_right(); \n        forward();\n    }\n\n    void back()\n    {\n        turn_right(); turn_right(); \n        forward();\n    }\n\n    bool left_forward()\n    {\n        turn_left(); \n        forward();\n    }                       \n\n\n    int x() const { return x_; }\n    int y() const { return y_; }\n    int dir() const { return dir_; }\n\nprivate:\n    void turn_right()\n    {\n        ++dir_;\n        if ( dir_ > 3 )\n            dir_ = 0;\n    }\n\n    void turn_left()\n    {\n        --dir_;\n        if ( dir_ < 0 )\n            dir_ = 3;\n    }\n\nprivate:\n    int x_, y_, dir_;\n};\n\n\n\nrobot forward( robot const& r )\n{\n    robot d(r);\n    d.forward();\n\n    return d;\n}\n\nrobot right_forward( robot const& r )\n{\n    robot d(r);\n    d.right_forward();\n\n    return d;\n}\n\nrobot back( robot const& r )\n{\n    robot d(r);\n    d.back();\n\n    return d;\n}\n\nrobot left_forward( robot const& r )\n{\n    robot d(r);\n    d.left_forward();\n\n    return d;\n}\n\nrobot do_action( robot const& r, int const id )\n{\n    switch( id )\n    {\n    case 0:\n        return forward( r );\n    case 1:\n        return right_forward( r );\n    case 2:\n        return back( r );\n    case 3:\n        return left_forward( r );\n    }\n\n    return r;\n}\n\n\n\n\nint main()\n{\n    using namespace std;\n\n    for(;;)   \n    {\n        int table[N][N]; //x ,y\n        int c[Ord];\n\n        int w, h;\n        cin >> w >> h;\n\n        if ( w == 0 && h == 0 )\n            break;\n\n        for( int i=0; i<h; ++i )\n            for( int j=0; j<w; ++j )\n                cin >> table[j][i]; // set [x, y]\n\n        for( int i=0; i<Ord; ++i ) {\n            cin >> c[i];\n        }\n\n        int const g_x = w - 1;\n        int const g_y = h - 1;\n\n \n        int cost[N][N][Ord]; // x, y ,dir\n        fill( &cost[0][0][0], &cost[0][0][0]+N*N*Ord, inf );\n\n        robot const base_r( 0, 0, 0 );\n        cost[base_r.x()][base_r.y()][base_r.dir()] = 0;\n\n        typedef std::pair<int, robot> data_set;\n        priority_queue<data_set, vector<data_set>, greater<data_set> > q;\n        q.push( make_pair( 0, base_r ) );\n        \n        for(;;) {\n            robot const r = q.top().second;\n            int const r_cost = q.top().first;\n            \n//            cout\n//                << \"-- \" << endl\n//                << r.x() << \":\" << r.y() << \"/\" << r.dir() << \" cost \" << cost[r.x()][r.y()][r.dir()] << \" : \" << r_cost << endl;\n//            \n  \n            if ( r.x() == g_x && r.y() == g_y )\n                break;\n\n            q.pop();\n\n                  \n\n\n            int per_cost[Ord];\n            per_cost[0] = c[0];       // Forward\n            per_cost[1] = c[1];       // Right\n            per_cost[2] = c[2];       // Back\n            per_cost[3] = c[3];       // Left\n\n            int const action = table[r.x()][r.y()]; \n            if ( action != 4 ) {\n                per_cost[action] = 0;\n            }\n            \n\n\n            for( int act_id=0; act_id<Ord; ++act_id ) {\n                robot const d = do_action( r, act_id );\n\n                if ( d.x() < 0 || d.y() < 0 || d.x() >= w || d.y() >= h )\n                    continue;\n\n//                cout << \"  \" << d.x() << \" : \" << d.y() << \" : \" << d.dir() << \" cost-> \" << cost[d.x()][d.y()][d.dir()] << \" > \" << r_cost + per_cost[act_id]  << endl;\n\n                if ( cost[d.x()][d.y()][d.dir()] > r_cost + per_cost[act_id] ) {\n                    cost[d.x()][d.y()][d.dir()] = r_cost + per_cost[act_id];\n                    q.push( make_pair( cost[d.x()][d.y()][d.dir()], d ) );\n                }\n            }\n        }\n\n\n        cout << \"cost \" << q.top().first << endl;\n        //return -1;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define INF 1e9\n\nstruct state{\n    int cost,y,x,dir;\n};\n\nbool operator>(const state &a, const state &b){\n    return a.cost > b.cost;\n}\n\n//           →↓←↑\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint X,Y;\nint s[30][30];\nint dp[30][30][4];\nint c[4]; // straight, right, back, left, halt\n\nvoid dijkstra(){\n    using P = state;\n    priority_queue<P,vector<P>,greater<P>> qu;\n    qu.push({dp[0][0][0] = 0, 0,0,0});\n    while(qu.size()){\n        P cur = qu.top(); qu.pop();\n        int y = cur.y;\n        int x = cur.x;\n        int dir = cur.dir;\n        if(y == Y-1 && x == X-1) return;\n        if(dp[y][x][dir] < cur.cost) continue;\n        rep(i,4){\n            int nd = (dir+i)%4;\n            int ny = y + dy[nd];\n            int nx = x + dx[nd];\n            int cost = (i==s[y][x] ? 0 : c[i]);\n            if(ny<0 || nx<0 || nx>=X || ny>=Y) continue;\n            if( dp[ny][nx][nd] > dp[y][x][dir] + cost){\n                dp[ny][nx][nd] = dp[y][x][dir] + cost;\n                qu.push({dp[ny][nx][nd],ny,nx,nd});\n            }\n        }\n    }\n}\n\nint main(void){\n    while(cin>>X>>Y, X|Y){\n        rep(y,30)rep(x,30)rep(i,4){\n            dp[y][x][i] = INF;\n        }\n        rep(y,Y) rep(x,X) cin>>s[y][x];\n        rep(i,4) cin>>c[i];\n        dijkstra();\n        int res = INF;\n        rep(i,4){\n            res = min(res, dp[Y-1][X-1][i]);\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<P, P>;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 35;\nconst int dx[4][4] = {{1, 0, -1, 0}, {0, -1, 0, 1}, {0, 1, 0, -1}, {-1, 0, 1, 0}};\nconst int dy[4][4] = {{0, 1, 0, -1}, {1, 0, -1, 0}, {-1, 0, 1, 0}, {0, -1, 0, 1}};\nint memo[4][4] = {{0, 1, 3, 2}, {1, 3, 2, 0}, {2, 0, 1, 3}, {3, 2, 0, 1}};\nint w, h;\nvector<int> c(4);\nint table[MAX_N][MAX_N];\nint solve()\n{\n    priority_queue<PP, vector<PP>, greater<PP>> que;\n    int used[h][w][4];\n    for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) for(int k = 0; k < 4; k++) used[i][j][k] = INF;\n    used[0][0][0] = 0;\n    que.push(PP(P(0, 0), P(0, 0)));\n    while(que.size())\n    {\n        PP p = que.top(); que.pop();\n        int cost = p.first.first;\n        int dir = p.first.second;\n        int y = p.second.first;\n        int x = p.second.second;\n        if(y == h - 1 and x == w - 1) return cost;\n        if(used[y][x][dir] < cost) continue;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = y + dy[dir][i];\n            int nx = x + dx[dir][i];\n            if(ny < 0 or nx < 0 or ny >= h or nx >= w) continue;\n            int d = memo[dir][i];\n            if(table[y][x] == i)\n            {\n                if(used[ny][nx][d] > used[y][x][dir])\n                {\n                    used[ny][nx][d] = used[y][x][dir];\n                    que.push(PP(P(used[ny][nx][d], d), P(ny, nx)));\n                }\n            }\n            else\n            {\n                if(used[ny][nx][d] > used[y][x][dir] + c[i])\n                {\n                    used[ny][nx][d] = used[y][x][dir] + c[i];\n                    que.push(PP(P(used[ny][nx][d], d), P(ny, nx)));\n                }\n            }\n        }\n    }\n    return -1;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w or h)\n    {\n        memset(table, 0, sizeof(table));\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++) cin >> table[i][j];\n        }\n        for(int i = 0; i < 4; i++) cin >> c[i];\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <math.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n//typedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\n#define INIT INF\ntypedef int Weight;\ntypedef pair<P,P> PP;\ntypedef vector< vector< vector<Weight> > > DIST;\n\n// ^0 >1 v2 <3\n\nint w,h;\nint fld[30][30];\nint change_dir[4];\nint convert_x[]={0,1,0,-1},convert_y[]={-1,0,1,0};\n\nbool check(int x,int y) {\n\tif(x<0||x>=w||y<0||y>=h) return false;\n\treturn true;\n}\n\nvoid dijkstra(const int fld[30][30],DIST &dist) {\n\tdist.assign(h,vector< vector<Weight> >(w,vector<Weight>(4,INIT)));\n\tdist[0][0][1]=0;\n\tpriority_queue< PP,vector<PP>,greater<PP> > Q;\n\tQ.push(PP(P(0,1),P(0,0)));\n\twhile(!Q.empty()) {\n\t\tPP p=Q.top();Q.pop();\n\t\tint cost=p.fi.fi,from_dir=p.fi.se,x=p.se.fi,y=p.se.se;\n\t\tint cur_dir=(from_dir+fld[y][x])%4;\n\t\tif(dist[y][x][from_dir]<cost) continue;\n\t\t//cout<<\"cost=\"<<cost<<\",from_dir=\"<<from_dir<<\",(x,y)=\"<<x<<','<<y<<\",cur_dir=\"<<cur_dir<<endl;\n\t\tREP(i,4) {\n\t\t\tint nx=x+convert_x[i],ny=y+convert_y[i];\n\t\t\tif(!check(nx,ny)) continue;\n\t\t\tif(i==cur_dir&&fld[y][x]!=4) {\n\t\t\t\tif(dist[ny][nx][i]<=cost) continue;\n\t\t\t\tdist[ny][nx][i]=cost;\n\t\t\t\tQ.push(PP(P(dist[ny][nx][i],i),P(nx,ny)));\n\t\t\t\t//cout<<\" i=\"<<i<<\",cost=0\"<<endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint new_cost=change_dir[(i-from_dir+4)%4];\n\t\t\t\t//cout<<\" i=\"<<i<<\",i-from+4%4=\"<<(i-from_dir+4)%4<<\",new_cost=\"<<new_cost<<endl;\n\t\t\t\tif(dist[ny][nx][i]<=cost+new_cost) continue;\n\t\t\t\tdist[ny][nx][i]=cost+new_cost;\n\t\t\t\tQ.push(PP(P(dist[ny][nx][i],i),P(nx,ny)));\n\t\t\t}\n\t\t}\n\t\t/*REP(i,h) {\n\t\t\tREP(k,4) {\n\t\t\t\tREP(j,w) {\n\t\t\t\t\tif(dist[i][j][k]==INF) cout<<\"# \";\n\t\t\t\t\telse cout<<dist[i][j][k]<<' ';\n\t\t\t\t}\n\t\t\t\tcout<<'|';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t\tstring tmp;cin>>tmp;*/\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>w>>h;\n\tREP(i,h) REP(j,w) cin>>fld[i][j];\n\tREP(i,4) cin>>change_dir[i];\n\tDIST dist(h,vector< vector<Weight> >(w,vector<Weight>(4)));\n\tdijkstra(fld,dist);\n\tint ans=INF;\n\tREP(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\tcout<<ans<<endl;\n\n\t/*REP(k,4) {\n\t\tREP(i,h) {\n\t\t\tREP(j,w) {\n\t\t\t\tif(dist[i][j][k]==INF) cout<<\"# \";\n\t\t\t\telse cout<<dist[i][j][k]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    新しく辺を張る関数作ろうか 2/9\n    create_edge();\n*/\n\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconstexpr auto MAX = 30;\nconstexpr auto INF = 10000000;\n\nauto w = 0;\nauto h = 0;\n\nint d[MAX][MAX][4] = {};\nint order[MAX][MAX] = {};\nint cost[4] = {};\n\nstruct State {\n    State(int x, int y, int d, int c) \n        : x(x), y(y), dir(d), cost(c) {}\n    int x;\n    int y;\n    int dir;\n    int cost;\n};\n\n/*  \n          270\n    \n    \n    180          0\n    \n         \n          90\n*/\nauto change_dir(int current_dir, int order) -> int {\n    return (current_dir + order) % 360;\n}\n\n\n\nauto search() -> void {\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n    auto comp = [](auto rhs, auto lhs) -> bool {return rhs.cost < lhs.cost;};\n    priority_queue<State, vector<State>, decltype(comp)> que(comp);\n    que.push(State(0, 0, 0, 0));\n\n    while (!que.empty()) {\n        State s = que.top();\n        que.pop();\n\n        for (auto i = 0; i < 4; i++) {\n            auto nx = s.x + dx[i];\n            auto ny = s.y + dy[i];\n            if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                auto new_dir = change_dir(s.dir, i * 90);\n                auto new_cost = cost[new_dir/90];\n                if ( s.cost + new_cost < d[nx][ny][new_dir] ) {\n                    d[nx][ny][new_dir/90] = s.cost + new_cost;\n                    que.push(State(nx, ny, new_dir, s.cost + new_cost));\n                }\n            }\n        }\n    }\n}\n\nauto init() -> void {\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            for (int k = 0; k < 4; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n} \n\nauto main(int argc, char const *argv[]) -> int {\n    while (cin>>w>>h, w||h) {\n        init();\n        for (auto i = 0; i < h; i++) {\n            for (auto j = 0; j < w; j++) {\n                cin>>order[i][j];\n            }\n        }\n\n        for (auto i = 0; i < 4; i++) {\n            cin>>cost[i];\n        }\n\n        search();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 100000 //2^31\n\nusing namespace std;\nint h, w,V;\nint cost[4000][4000];\nint sign[4];//0A a> 1V 3< \nint area[40][40];\nint d[4000];\nbool used[4000];\nvoid solve(int s){\n\trep(i, 0, V)d[i] = INF, used[i] = false;\n\td[s] = 0;\n\twhile (true){\n\t\tint v = -1;\n\t\trep(u, 0, V)if (!used[u] && (v == -1 || d[u]<d[v]))v = u;\n\n\t\tif (v == -1)break;\n\t\tused[v] = true;\n\t\trep(u, 0, V)d[u] = min_int(d[u], d[v] + cost[v][u]);\n\t//\trep(i, 0, V)printf(\"%d/\", d[i]); cout << endl;\n\t}\n}\n\nint calc_d(int dx,int dy){\n\tif (dx > 0)return(1);\n\tif (dx < 0)return(3);\n\tif (dy>0)return(2);\n\treturn(0);\n}\nvoid inset_cost(){\n\trep(i, 0, V)rep(j, 0, V){\n\t\tint dx, dy;//差\n\t\tint before_d = i % 4, after_d = j % 4;//方向 \n\t\tif (i == j)cost[i][i] = 0;\n\t\telse{\n\t\t\tdx = (j / 4) % w - (i / 4) % w;\n\t\t\tdy = (j / 4) / w - (i / 4) / w;\n\t\t\tif (dx*dx + dy*dy == 1){\n\t\t\t\tint temp;\n\t\t\t\tif (calc_d(dx, dy) != after_d)cost[i][j] = INF;\n\t\t\t\telse{\n\n\t\t\t\t\tcost[i][j] = sign[temp = ((after_d - before_d + 4) % 4)];\n\t\t\t\t\tint x = (i / 4) % w, y = (i / 4) / w;\n\t\t\t\t\tif (temp == area[y][x])cost[i][j] = 0;//\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcost[i][j] = INF;\n\n\t\t}\n\n\t}\n\n\t//rep(i, 0, V){\n\t//\trep(j, 0, V)printf(\"x=%d,y=%d,ax=%d,ay=%d,bd=%d,ad=%d,%11d, \", (i / 4) % w, (i / 4) / w, (j / 4) % w, (j / 4) / w, i % 4, j % 4, cost[i][j]);\n\t\t//cout << endl;\n\t//}\n\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> w >> h;\n\t\tif (h == 0)break;\n\t\trep(i, 0, h)rep(j, 0, w)cin >> area[i][j];\n\t\trep(i, 0, 4)cin >> sign[i];\n\t\tV = 4 * h*w;\n\t\t\n\t\tinset_cost();\n\n\t\tsolve(1);\n\t\tint result = d[V - 1];\n\t\tfor (int i = V - 2; i > V - 5; i--)\n\t\t\tresult = min_int(result, d[i]);\n\n\t\tcout << result << endl;\n\n\t}\n\n\n\n\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nconst int INF = 1<<29;\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int change_d[5] = {0, 1, 2, 3, 0};\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    int ope[31][31], dist[31][31][4], ch_cost[4];\n    REP(i, h) REP(j, w) cin >> ope[i][j];\n    REP(i, 4) cin >> ch_cost[i];\n    REP(i, h) REP(j, w) REP(k, 4) dist[i][j][k] = INF;\n    dist[0][0][1] = 0;\n    priority_queue<T> pque;\n    pque.push(T(0, 0, 1));\n    while (!pque.empty()) {\n      int d, r, c, dir;\n      tie(d, r, dir) = pque.top(); pque.pop();\n      d = -d, c = r % w, r /= w;\n      //cout << c << ',' << r << ',' << dir << ':' << d << endl;\n      if (dist[r][c][dir] < d || (r == h-1 && c == w-1)) continue;\n      int default_d = ope[r][c] != 4 ? (dir + change_d[ope[r][c]]) % 4 : 4;\n      REP(i, 4) {\n\tint nd = (dir + i) % 4, nr = r + dr[nd], nc = c + dc[nd], cost = (nd == default_d ? 0 : ch_cost[i]);\n\t//cout << nr << ',' << nc << endl;\n\tif (0 <= nr && nr < h && 0 <= nc && nc < w && dist[nr][nc][nd] > d + cost) {\n\t  dist[nr][nc][nd] = d + cost;\n\t  pque.push(T(-dist[nr][nc][nd], nr * w + nc, nd));\n\t}\n      }      \n    }\n    int ret = INF;\n    REP(i, 4) ret = min(ret, dist[h-1][w-1][i]);\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n \n#define REP(i,b,n) for(int i=b;i<n;++i)\n#define REPR(i,b,n) for(int i=n-1;i>=b;--i)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n\nusing namespace std;\n\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> stt;\ntypedef long long ll;\n\n\nenum{RIGHT, UP, LEFT, DOWN};\n\nint h, w;\nint field[32][32];\nint vtx[32][32][4];\nint cost[4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nint rev[] = {0, -1, 2, 1};\n\n\nbool border(int lo, int mid, int hi){\n\treturn lo <= mid && mid <= hi;\n}\n\n\nint solve(){\n\n\tqueue<stt> qu;\n\tqu.push(make_pair( make_pair(1,1), (int)(RIGHT)));\n\tvtx[1][1][RIGHT] = 0;\n\t\n\tstt now;\n\tint x, y, dir, nx, ny, ndir, pay;\n\t\n\twhile(!qu.empty()){\n\t\t\n\t\tnow = qu.front();\n\t\tx = now.first.first, y = now.first.second, dir = now.second;\n\t\tqu.pop();\n\t\t\n\t\tif(field[y][x] == 4)\n\t\t\tcontinue;\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tif(i==field[y][x])\n\t\t\t\tpay = 0;\n\t\t\telse\n\t\t\t\tpay = cost[i];\n\t\t\t\n\t\t\tndir = (4+dir+rev[i])%4;\n\t\t\tnx = x+dx[ndir];\n\t\t\tny = y+dy[ndir];\n\t\t\t\n\t\t\tif(border(1, nx, w) && border(1, ny, h) && vtx[ny][nx][ndir] > vtx[y][x][dir] + pay){\n\t\t\t\tvtx[ny][nx][ndir] = vtx[y][x][dir] + pay;\n\t\t\t\tqu.push(make_pair( make_pair(nx,ny), ndir));\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tint res = INT_MAX;\n\t\n\tfor(int i=0; i<4; ++i)\n\t\tres = min(res, vtx[h][w][i]);\n\t\n\treturn res;\n}\n\n\nint main(){\n\t\n\twhile(cin >> w >> h, (w||h)){\n\t\t\n\t\tfor(int y=1; y<=h; ++y){\n\t\t\tfor(int x=1; x<=w; ++x){\n\t\t\t\n\t\t\t\tcin >> field[y][x];\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k)\n\t\t\t\t\tvtx[y][x][k] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<4; ++i)\n\t\t\tcin>> cost[i];\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint w, h;\nint s[35][35];\nint c[4];\nint vx[4][4] = {{1, 0, -1, 0}, {0, 1, 0, -1}, {-1, 0, 1, 0}, {0, -1, 0, 1}};\nint vy[4][4] = {{0, 1, 0, -1}, {-1, 0, 1, 0}, {0, -1, 0, 1}, {1, 0, -1, 0}};\nint vv[4][4] = {{0, 3, 2, 1}, {1, 0, 3, 2}, {2, 1, 0, 3}, {3, 2, 1, 0}};\n\nclass robot {\n\tpublic :\n\t\tint x;\n\t\tint y;\n\t\tint v; // 向き\n\t\tint c;\n\n\t\trobot() {\n\t\t\tx = 0; y = 0; v = 0; c = 0;\n\t\t}\n\n\t\tbool operator<(const robot& other) const{\n\t\t\treturn c > other.c;\n\t\t}\n\n\t\tbool operator>(const robot& other) const{\n\t\t\treturn c < other.c;\n\t\t}\n\n\t\tbool next(int o) {\n\t\t\tif(o != s[y][x])\n\t\t\t\tc += ::c[o];\n\t\t\tx += vx[v][o];\n\t\t\ty += vy[v][o];\n\t\t\tv = vv[v][o];\n\n\t\t\tif(x < 0 || y < 0 || x >= w || y >= h)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n}; \n\nbool input() {\n\tcin >> w >> h;\n\tif(w == 0 && h == 0)\n\t\treturn 0;\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++)\n\t\tcin >> c[i];\n\n\treturn 1;\n}\n\nint solve(void) {\n\tpriority_queue<robot> q;\n\tint use[35][35][4];\n\tmemset(use, -1, 35 * 35 * 4 * sizeof(int));\n\n\tq.push(robot());\n\twhile(!q.empty()) {\n\t\trobot now = q.top();\n\t\tq.pop();\n\n\t\tif(use[now.x][now.y][now.v] == -1) {\n\t\t\tuse[now.x][now.y][now.v] = now.c;\n\t\t}\n\n\t\telse\n\t\t\tcontinue;\n\n\t\tif(now.x == w - 1 && now.y == h - 1){\n\t\t\treturn now.c;\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\trobot temp = now;\n\t\t\tif(temp.next(i)){\n\t\t\t\t\tq.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void) {\n\twhile(input()){\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tpair<pii,int>\tppiii;\n\nconst int inf=1<<29,dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint inst[30][30],memo[30][30][4];\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tint cost[4];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",inst[i]+j),inst[i][j];\n\t\tfor(int i=0;i<4;i++)\tscanf(\"%d\",cost+i);\n\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<4;k++)\tmemo[i][j][k]=inf;\n\n\t\tpriority_queue< pair<int,ppiii> > pq;\n\t\tpq.push(mp(0,mp(mp(0,0),0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,ppiii> a=pq.top();\tpq.pop();\n\t\t\tint nowcost=-a.first;\n\t\t\tint y=a.second.first.first;\n\t\t\tint x=a.second.first.second;\n\t\t\tint dir=a.second.second;\n\t\t\tif(y==h-1 && x==w-1)\tbreak;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nextdir=(dir+4-i)%4;\n\t\t\t\tint yy=y+dy[nextdir],xx=x+dx[nextdir];\n\t\t\t\tif(yy<0 || h<=yy || xx<0 || w<=xx)\tcontinue;\n\n\t\t\t\tint nextcost=nowcost+(inst[y][x]==i?0:cost[i]);\n\t\t\t\tif(nextcost<memo[yy][xx][nextdir]){\n\t\t\t\t\tmemo[yy][xx][nextdir]=nextcost;\n\t\t\t\t\tpq.push(mp(-nextcost,mp(mp(yy,xx),nextdir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",min(memo[h-1][w-1][0],memo[h-1][w-1][3]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int MAX_V = 30;\nconst int INF = (1 << 28);\n\ntypedef pair<int, int> pii;\n// ??????: 0 -> ???, 1 -> ???, 2 -> ???, 3 -> ???\ntypedef pair<pii, pii> P; // (??????????????????)?????§?¨?\n\nint w, h;\nint cost[4][MAX_V][MAX_V];\nint s[MAX_V][MAX_V];\nint c[4];\npii dir[4] = {pii(1, 0), pii(0, 1), pii(-1, 0), pii(0, -1)};\n\nint main(void) {\n    while (cin >> w >> h, w) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> s[i][j];\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            cin >> c[i];\n        }\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(P(pii(0, 0), pii(0, 0)));\n\n        for (int i = 0; i < 4; i++)\n            for (int j = 0; j < MAX_V; j++)\n                for (int k = 0; k < MAX_V; k++)\n                    cost[i][j][k] = INF;\n        cost[0][0][0] = 0;\n\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            pii v = p.second;\n            int d = p.first.second;\n\n            if (cost[d][v.second][v.first] < p.first.first) continue;\n\n            // cout << \"#: \" << v.first << \" \" << v.second << \" d = \" << d << endl;\n            for (int i = 0; i < 4; i++) {\n                int nd = (i+d)%4;\n                int x = v.first + dir[nd].first;\n                int y = v.second + dir[nd].second;\n\n                if (0 <= x && x < w && 0 <= y && y < h) {\n                    int nc = cost[d][v.second][v.first] + ((i == s[v.second][v.first]) ? 0 : c[i]);\n                    if (cost[nd][y][x] > nc) {\n                        cost[nd][y][x] = nc;\n                        que.push(P(pii(nc, nd), pii(x, y)));\n                    }\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < 4; i++) {\n            ans = min(ans, cost[i][h-1][w-1]);\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define MAX_H 30\n#define MAX_W 30\n\n#define INF (1<<28)\n\nint w, h;\nint F[MAX_H][MAX_W];\nint cost[4];\n\nint dp[MAX_H][MAX_W][4];\nstruct P {\n    int y, x;\n    int d;\n    P() {}\n    P(int y, int x, int d) : y(y), x(x), d(d) {}\n};\n#define N 0\n#define E 1\n#define S 2\n#define W 3\n\n#define Straight 0\n#define Right 1\n#define Reverse 2\n#define Left 3\nint C(int y, int x, int from, int to) { // calculate cost\n    switch ((4+from-to) % 4) {\n        case 0:\n            if (F[y][x] == Straight) return 0;\n            return cost[Straight];\n        case 1:\n            if (F[y][x] == Left) return 0;\n            return cost[Left];\n        case 2:\n            if (F[y][x] == Reverse) return 0;\n            return cost[Reverse];\n        case 3:\n            if (F[y][x] == Right) return 0;\n            return cost[Right];\n    }\n}\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int nd[] = {S, E, N, W};\nvoid solve() {\n    for (int i = 0; i < h; i++) \n        for (int j = 0; j < w; j++)\n            for (int k = 0; k < 4; k++) \n                dp[i][j][k] = INF;\n    queue<P> q;\n    q.push(P(0, 0, E));\n    dp[0][0][E] = 0;\n    while (!q.empty()) {\n        P p = q.front(); q.pop();\n        for (int i = 0; i < 4; i++) {\n            int ny = p.y + dy[i];\n            int nx = p.x + dx[i];\n            if (ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            int c = dp[p.y][p.x][p.d] + C(p.y, p.x, p.d, nd[i]);\n            if (dp[ny][nx][nd[i]] <= c) continue;\n            q.push(P(ny, nx, nd[i]));\n            dp[ny][nx][nd[i]] = c;\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &w, &h), w || h) {\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++)\n                scanf(\"%d\", &F[i][j]);\n        for (int i = 0; i < 4; i++) \n            scanf(\"%d\", &cost[i]);\n        solve();\n        int min_cost = INF;\n        //for (int k = 0; k < 4; k++) {\n        //    for (int i = 0; i < h; i++) {\n        //        for (int j = 0; j < w; j++) {\n        //            printf(\"%d \", dp[i][j][k]);\n        //        }\n        //        printf(\"\\n\");\n        //    }\n        //    printf(\"\\n\");\n        //}\n\n        for (int i = 0; i < 4; i++) \n            min_cost = min(dp[h-1][w-1][i], min_cost);\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100000\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool check[100][100][4] = { false };\nint cost[100][100][4];\n\nclass Node{\npublic:\n\tint x;\n\tint y;\n\tint way;//0 -> up, 1 -> right, 2 -> down, 3-> left\n\tint num;\n\n\tNode(){ x = 0; y = 0; way = 0; num = 0; }\n\tNode(int x, int y, int way, int num) : x(x), y(y), way(way), num(num){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.num < n2.num;\n}\n\nbool operator>(const Node &n1, const Node &n2){\n\treturn n1.num > n2.num;\n}\n\nint main(void){\n\n\tint w, h;\n\tint map[100][100];\n\tint c[4];\n\n\twhile (cin >> w >> h, w, h){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcost[j][i][3] = cost[j][i][2] = cost[j][i][1] = cost[j][i][0] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcheck[j][i][3] = check[j][i][2] = check[j][i][1] = check[j][i][0] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < h; j++){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t}\n\t\t}\n\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\n\t\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que;\n\n\t\tque.push(Node(0, 0, 1, 0));\n\n\t\twhile (!que.empty()){\n\t\t\tNode buff = que.top();\n\t\t\tque.pop();\n\n\t\t\t//cout << \"hoge!\" << endl;\n\n\t\t\tif (check[buff.y][buff.x][buff.way]) continue;\n\t\t\tcheck[buff.y][buff.x][buff.way] = true;\n\t\t\tcost[buff.y][buff.x][buff.way] = min(cost[buff.y][buff.x][buff.way] , buff.num);\n\n\t\t\tif ((buff.x == w - 1) && (buff.y == h - 1)){\n\t\t\t\tcout << buff.num << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (map[buff.y][buff.x] != 4){\n\t\t\t\tint next_way = (buff.way + map[buff.y][buff.x]) % 4;\n\t\t\t\tint next_x = buff.x + dx[next_way];\n\t\t\t\tint next_y = buff.y + dy[next_way];\n\t\t\t\tif (0 <= next_x && next_x < w && 0 <= next_y && next_y < h)\n\t\t\t\t\tque.push(Node(next_x, next_y, next_way, buff.num));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint next_x = buff.x + dx[i];\n\t\t\t\tint next_y = buff.y + dy[i];\n\t\t\t\tif (0 <= next_x && next_x < w && 0 <= next_y && next_y < h)\n\t\t\t\t\tque.push(Node(next_x, next_y, i, buff.num + c[(4 + i - buff.way) % 4]));\n\n\t\t\t}\n\n\n\t\t}\n\t\t/*\n\t\tfor (int j = 0; j < h; j++){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << min(cost[j][i][0], min(cost[j][i][1], min(cost[j][i][2], cost[j][i][3]))) << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\n\treturn 0;\n}\n\n/*\nfor(i=0;i<N;i++){\ncin >> X[i];\n}\n\n\nfor(i=0;i<N;i++){\nfor(j=0;j<N;j++){\ncin >> X[i][j];\n}\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main() {\n  int n,m;\n  while(cin >> m >> n && n) {\n    int a[n][m];\n    rep(i,n)rep(j,m) R a[i][j];\n    int d[n][m][4],c[4];\n    rep(i,n)rep(j,m)rep(k,4) d[i][j][k]=MAX;\n    rep(i,4) R c[i];\n    d[0][0][1]=0;\n    priority_queue<P2,vector<P2>,greater<P2> > que;\n    que.push(P2(P(0,1),P(0,0)));\n    int ans=-1;\n    while(!que.empty()) {\n      P2 p=que.top();que.pop();\n      int nx=p.S.F,ny=p.S.S,cc=p.F.F,k=p.F.S;\n      if(cc<d[nx][ny][k]) continue;\n      if(nx==n-1 && ny==m-1) {\n\tans=d[nx][ny][k];\n\tbreak;\n      }\n      rep(i,4) {\n\tint z=c[i],kk=(k+i)%4;\n\tint x=nx+dx[kk],y=ny+dy[kk];\n\tif(!check(n,m,x,y)) continue;\n\tif(a[nx][ny]==i) z=0;\n\tif(d[x][y][kk]>d[nx][ny][k]+z) {\n\t  d[x][y][kk]=d[nx][ny][k]+z;\n\t  que.push(P2(P(d[x][y][kk],kk),P(x,y)));\n\t}\n      }\n    }\n    pr(ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint W,H;\nint inf = 1e9;\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint dp[31][31][4] = {};\nint S[31][31] = {};\nint C[4] = {};\n\nstruct state{\n    int x,y,direction,dist;\n    bool operator<(const state& right)const{\n        return dist > right.dist;\n    }\n    void go(){\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void turn_right(){\n        direction--;\n        (direction += 4)%=4;\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void turn_back(){\n        (direction += 2)%=4;\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void turn_left(){\n        direction++;\n        direction %= 4;\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void instruction(int i){\n        if(i==0) go();\n        if(i==1) turn_right();\n        if(i==2) turn_back();\n        if(i==3) turn_left();\n    }\n    bool in(){\n        return 1<=x && x<=H && 1<=y && y<=W;\n    }\n};\n\nint main(){\n    while(cin >> W >> H && W>0){\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> S[i][j];\n                for(int k=0;k<4;k++) dp[i][j][k] = inf;\n            }\n        }\n        for(int i=0;i<4;i++) cin >> C[i];\n        dp[1][1][0] = 0;\n        priority_queue<state> Q;\n        state init = {1,1,0,0};\n        Q.push(init);\n        while(!Q.empty()){\n            state now = Q.top(); Q.pop();\n            if(dp[now.x][now.y][now.direction]<now.dist) continue;\n            for(int i=0;i<4;i++){\n                state ne = now;\n                ne.instruction(i);\n                int c = now.dist+C[i]*(i!=S[now.x][now.y]);\n                if(!ne.in()) continue;\n                if(dp[ne.x][ne.y][ne.direction]>c){\n                    dp[ne.x][ne.y][ne.direction] = c;\n                    ne.dist = c;\n                    Q.push(ne);\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=0;i<4;i++) ans = min(ans,dp[H][W][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 30;\nconst int W = 30;\nconst int INF = 1 << 29;\nconst int dy[4] = {0, 1, 0, -1};\nconst int dx[4] = {1, 0, -1, 0};\n\nstruct state{\n  int y,x,c,dir;\n  state(int y=0, int x=0, int c=0, int d=0):y(y),x(x),c(c),dir(d){}\n  bool operator < (const state &s) const {\n    return c > s.c;\n  }\n};\n\n\nint w, h, v[H][W], c[4];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nint solve(){\n  priority_queue<state> q;\n  state u, u2;\n  int d[H][W][4];\n  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<4;k++){\n        d[i][j][k] = INF;\n      }\n    }\n  }\n  d[0][0][0] = 0;\n\n  for(q.push(state(0,0,0,0));!q.empty();){\n    u = q.top();\n    q.pop();\n\n    if(u.y == h-1 && u.x == w-1) {\n      return u.c;\n    }\n    \n    if(v[u.y][u.x] != 4){\n      u2 = u;\n      u2.dir = (u.dir + v[u.y][u.x]) % 4;\n      u2.y += dy[u2.dir];\n      u2.x += dx[u2.dir];\n      if(check(u2.y, u2.x) && d[u2.y][u2.x][u2.dir] > u2.c){\n        d[u2.y][u2.x][u2.dir] = u2.c;\n        q.push(u2);\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      u2 = u;\n      u2.dir = (u.dir + i) % 4;\n      u2.y += dy[u2.dir];\n      u2.x += dx[u2.dir];\n      u2.c += c[i];\n      if(check(u2.y, u2.x) && d[u2.y][u2.x][u2.dir] > u2.c){\n        d[u2.y][u2.x][u2.dir] = u2.c;\n        q.push(u2);\n      }\n    }\n  }\n \n  return -1;\n}\n\nint main(){\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> v[i][j];\n      }\n    }\n    for(int i=0;i<4;i++) cin >> c[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\n#define FOR(a,b,c) for ( int a = b; a < (int)c; a++ )\n#define REP(a,b) FOR(a,0,b)\n#define DEBUG 0\n\nclass Pos {\npublic:\n    int r, c;\n    bool operator == ( const Pos& p ) const {\n        return r == p.r && c == p.c;\n    }\n    bool operator < ( const Pos& p ) const {\n        return r == p.r ? c < p.c : r < p.r;\n    }\n    Pos() { r=0, c=0; }\n    Pos( int r_, int c_ ): r(r_), c(c_) {}\n\n#if DEBUG\n    string toStr()\n    {\n        ostringstream os;\n        os << \"(\" << r << \",\" << c << \")\";\n        return os.str();\n    }\n#endif\n};\n\nclass Node {\npublic:\n    int cost;\n    int a;\n    Pos p;\n    Node() { cost = 0, a = 0, p = Pos(0,0); }\n    Node( int cost_, int a_, int r, int c ) { cost = cost_, a = a_, p = Pos( r, c ); }\n    bool operator == ( const Node& node ) const {\n        return cost == node.cost;\n    }\n    bool operator < ( const Node& node ) const {\n        return cost < node.cost;\n    }\n    bool operator > ( const Node& node ) const {\n        return cost > node.cost;\n    }\n\n#if DEBUG\n    string toStr() {\n        ostringstream os;\n        os << \"Node: \" << cost << \", \" << a << \", \" << p.toStr();\n        return os.str();\n    }\n#endif\n};\n\ntypedef priority_queue <Node, vector<Node>, greater<Node> > QUEUE;\n\n// global var\nconst int size = 31;\nint w, h;\nint s[size][size];\nint c[4];\nint D[4][size][size]; // min cost\n\nbool isValid( Pos p ) \n{\n    return p.r >= 0 && p.r < h && p.c >= 0 && p.c < w;\n}\n\n// a%b\nint getRem( int a, int b )\n{\n    int rem = a % b;\n    if ( rem < 0 ) rem = b + rem;\n    return rem;\n}\n\nint main( void )\n{\n    while ( cin >> w >> h && w && h ) {\n        // init\n        REP(i,size) REP(j,size) s[i][j]=0;\n        REP(i,size) REP(j,size) REP(k,4) D[k][i][j]=1<<24;\n        REP(i,4) c[i] = 0;\n\n        // input\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                cin >> s[i][j];\n            }\n        }\n        for ( int i = 0; i < 4; i++ ) {\n            cin >> c[i];\n        }\n\n        // proc\n        int answer = 1<<24;\n        QUEUE Q;\n        Node start;\n        Pos goal( h-1, w-1 );\n        Q.push( start );\n        D[0][start.p.r][start.p.c] = 0;\n\n        while ( !Q.empty() ) {\n            Node node = Q.top();\n            Q.pop();\n\n            if ( node.p == goal ) {\n                answer = min( answer, D[node.a][node.p.r][node.p.c] );\n                break;\n            }\n#if DEBUG\n            // cout << Q.size() << endl;\n            // cout << node.toStr() << endl;\n#endif\n            // proc\n            for ( int i = 0; i < 4; i++ ) {\n                int cost = node.cost;\n                int a = node.a;\n                Pos p = node.p;\n                Node next_node = node;\n\n                // cost\n                if ( i != s[p.r][p.c] ) {\n                    cost += c[i];\n                }\n\n                // operation\n                if ( i == 1 ) {\n                    a = getRem( a+1, 4 );\n                } else if ( i == 2 ) {\n                    a = getRem( a+2, 4 );\n                } else if ( i == 3 ) {\n                    a = getRem( a-1, 4 );\n                }\n\n                // move\n                if ( a == 0 ) {\n                    p.c++;\n                } else if ( a == 1 ) {\n                    p.r++;\n                } else if ( a == 2 ) {\n                    p.c--;\n                } else if ( a == 3 ) {\n                    p.r--;\n                }\n\n                if ( !isValid( p ) ) {\n                    continue;\n                }\n\n                if ( cost >= D[a][p.r][p.c] ) continue;\n                D[a][p.r][p.c] = cost;\n                next_node.cost = cost;\n                next_node.a = a;\n                next_node.p = p;\n                Q.push( next_node );\n#if DEBUG\n                if ( w == 2 && h == 8 ) cout << node.toStr() << \" | \" << next_node.toStr() << endl;\n#endif\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> Node; \ntypedef pair<int,Node> State;\nconst int INF = 1e+8;\nint dx[4] = {+1,0,-1,0};\nint dy[4] = {0,+1,0,-1};\n\nint w, h;\nint s[31][31];\nint c[4];\n\nint command(int c, int dir){\n\treturn (dir + c) % 4;\n}\n\nint dijkstra(){\n\tint sx=0, sy=0, dir=0;\n\t\n\tint d[4][31][31];\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tfor(int j=0 ; j < 31 ; j++ ){\n\t\t\tfor(int k=0 ; k < 31 ; k++ ){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue< State , vector<State> , greater<State> > q;\n\td[0][0][0] = 0;\n\tNode start( P(0,0) , 0 );\n\tq.push( State(0,start) );\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint cost = q.top().first;\n\t\tint x = q.top().second.first.first;\n\t\tint y = q.top().second.first.second;\n\t\tint dir = q.top().second.second;\n\t\tq.pop();\n\t\t\n\t\tif( x == w-1 && y == h-1 ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint next_dir = command( dir , i );\n\t\t\tint mx = x + dx[next_dir];\n\t\t\tint my = y + dy[next_dir];\n\t\t\tint next_cost;\n\t\t\t\n\t\t\tif( i == s[y][x] ){\n\t\t\t\tnext_cost = cost;\n\t\t\t}else{\n\t\t\t\tnext_cost = cost + c[i];\n\t\t\t}\n\t\t\t\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\n\t\t\tNode next( P(mx,my) , next_dir );\n\t\t\tif( next_cost < d[next_dir][my][mx] ){\n\t\t\t\td[next_dir][my][mx] = next_cost;\n\t\t\t\tq.push( State( next_cost , next ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tcout << dijkstra() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n2017_02_25_AC\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nconst int INF = 1000000000;\nint w, h, cost[4], grid[35][35], dp[35][35][4];\n\nvoid dfs(int y, int x, int dir, int currentcost){\n  if(!CH(y,0,h) || !CH(x,0,w)) return;\n  if(dp[y][x][dir] <= currentcost) return;\n  dp[y][x][dir] = currentcost;\n  if((x == w-1 && y == h-1)/* || grid[y][x] == 4*/) return;\n  REP(k,0,5){\n    if(k == 0){ //????????????\n      int d = grid[y][x];\n      if(0<=d && d<=3){ //grid[y][x]==4 (halt) ??????????????????\n        dfs(y + dy[(dir + d) % 4], x + dx[(dir + d) % 4], (dir + d) % 4, currentcost);\n      }\n      /*\n      switch (grid[y][x]) {\n        case 0:\n          dfs(y + dy[dir], x + dx[dir], dir, currentcost);\n          break;\n        case 1:\n          dfs(y + dy[(dir + 1) % 4], x + dx[(dir + 1) % 4], (dir + 1) % 4, currentcost);\n          break;\n        case 2:\n          dfs(y + dy[(dir + 2) % 4], x + dx[(dir + 2) % 4], (dir + 2) % 4, currentcost);\n          break;\n        case 3:\n          dfs(y + dy[(dir + 3) % 4], x + dx[(dir + 3) % 4], (dir + 3) % 4, currentcost);\n          break;\n        case 4:\n          //return;\n          break;\n        }\n        */\n    }else{  //???????????????tk: 0 ~ 3????????????4(halt)???????????????\n      int tk = k - 1;\n      if(tk == grid[y][x]) continue;\n      dfs(y + dy[(dir + tk) % 4], x + dx[(dir + tk) % 4], (dir + tk) % 4, currentcost + cost[tk]);\n      /*\n      switch (tk) {\n        case 0:\n          dfs(y + dy[dir], x + dx[dir], dir, currentcost + cost[tk]);\n          break;\n        case 1:\n          dfs(y + dy[(dir + 1) % 4], x + dx[(dir + 1) % 4], (dir + 1) % 4, currentcost + cost[tk]);\n          break;\n        case 2:\n          dfs(y + dy[(dir + 2) % 4], x + dx[(dir + 2) % 4], (dir + 2) % 4, currentcost + cost[tk]);\n          break;\n        case 3:\n          dfs(y + dy[(dir + 3) % 4], x + dx[(dir + 3) % 4], (dir + 3) % 4, currentcost + cost[tk]);\n          break;\n        }\n      */\n    }\n  }\n  return;\n}\n\nint main() {\n\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    REP(i,0,h){\n      REP(j,0,w){\n        cin>>grid[i][j];\n      }\n    }\n    REP(k,0,4) cin>>cost[k];\n    //memset(dp, INF, sizeof(dp));\n    REP(i,0,h)REP(j,0,w)REP(k,0,4) dp[i][j][k] = INF;\n\n    dfs(0, 0, 0, 0);\n\n    cout<<*min_element(dp[h-1][w-1], dp[h-1][w-1]+4)<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int MAX_V = 4000;\nconst int INF = 9999999;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvvi cost;\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nint h, w;\n\nbool in(int i, int j){\n\treturn 0 <= i && i < h && 0 <= j && j < w;\n}\n\nint toV(int i, int j, int dir){\n\treturn 4 * (i * w + j) + dir;\n}\n\nvoid calc(){\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[0] = 0;\n\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t}\n\n\t\tif (v == -1)break;\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tvvi s = vvi(h, vi(w, 0));\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> s[i][j];\n\t\tint c[4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tcin >> c[i];\n\n\t\tV = 4 * w * h;\n\t\tcost = vvi(V, vi(V, INF));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\t\tcost[toV(i, j, dir)][toV(i, j, dir)] = 0;\n\t\t\t\t\tfor (int ndir = 0; ndir < 4; ndir++) {\n\t\t\t\t\t\tint ni = i + dy[ndir], nj = j + dx[ndir];\n\t\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\t\tif (s[i][j] != 4 && (dir + s[i][j]) % 4 == ndir)\n\t\t\t\t\t\t\tcost[toV(i, j, dir)][toV(ni, nj, ndir)] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcost[toV(i, j, dir)][toV(ni, nj, ndir)] = c[(ndir - dir + 4) % 4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalc();\n\n\t\tint ans = INF;\n\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\tans = min(ans, d[toV(h - 1, w - 1, dir)]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct Data\n{\n\tint y, x, d, cost;\n\tData(int y, int x, int d, int cost) : y(y), x(x), d(d), cost(cost) {}\n\n\tbool operator< (const Data& d)const\n\t{\n\t\treturn cost > d.cost;\n\t}\n};\n\nint main()\n{\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tvvi field(h, vi(w));\n\t\trep(i, h) rep(j, w)\n\t\t\tscanf(\"%d\", &field[i][j]);\n\n\t\tint c[4];\n\t\trep(i, 4) scanf(\"%d\", &c[i]);\n\n\t\tvector<vvi> done(h, vvi(w, vi(4, 0)));\n\n\t\tint ans;\n\t\tpriority_queue<Data> Q;\n\t\tData start(0, 0, 0, 0);\n\t\tQ.push(start);\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(done[d.y][d.x][d.d])\n\t\t\t\tcontinue;\n\n\t\t\tdone[d.y][d.x][d.d] = 1;\n\t\t\tif(d.y == h-1 && d.x == w-1){\n\t\t\t\tans = d.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst int dx[] = {1, 0, -1, 0};\n\t\t\tconst int dy[] = {0, 1, 0, -1};\n\t\t\trep(i, 4){\n\t\t\t\tint pd = (i + d.d) % 4;\n\t\t\t\tint py = d.y + dy[pd];\n\t\t\t\tint px = d.x + dx[pd];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(done[py][px][pd])\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint pc = d.cost + (i==field[d.y][d.x] ? 0 : c[i]);\n\t\t\t\tQ.push(Data(py, px, pd, pc));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nint c[4];\n\nstruct State{\n\tint x,y,d,cost;\n};\n\n\nbool operator < (const State a, State b){\n\treturn a.cost>b.cost;\n}\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid calc(int w,int h){\n\tint direction[30][30];\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tcin>>direction[j][i];\n\n\tfor(int i=0;i<4;i++)\n\t\tcin>>c[i];\n\n\tpriority_queue<State> Q;\n\tbool costmap[30][30][4];\n\n\tfor(int i=0;i<30;i++)\n\t\tfor(int j=0;j<30;j++)\n\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\tcostmap[i][j][z]=false;\n\n\tcostmap[0][0][0]=true;\n\n\tState first;\n\tfirst.x=first.y=first.cost=first.d=0;\n\tQ.push(first);\n\n\tState k;\n\twhile(!Q.empty()){\n\t\tk=Q.top();\n\t\tQ.pop();\n\t\tcostmap[k.x][k.y][k.d]=true;\n\t\tif(k.x==w-1 && k.y==h-1)\n\t\t\tbreak;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx,ty,td,tcost;\n\t\t\tState temp;\n\t\t\ttd=(k.d+i)%4;\n\t\t\ttx=k.x+dx[td];\n\t\t\tty=k.y+dy[td];\n\t\t\tif(tx<0 || ty<0 || tx>w || ty>h)\n\t\t\t\tcontinue;\n\t\t\ttcost=k.cost;\n\t\t\tif(direction[k.x][k.y]!=i)\n\t\t\t\ttcost+=c[i];\n\t\t\ttemp.x=tx;\n\t\t\ttemp.y=ty;\n\t\t\ttemp.d=td;\n\t\t\ttemp.cost=tcost;\n\t\t\tif(!costmap[temp.x][temp.y][temp.d])\n\t\t\t\tQ.push(temp);\n\t\t}\n\t}\n\n\tcout<<k.cost<<\"\\n\";\n}\n\nint main(){\n\tint w,h;\n\tcin>>w>>h;\n\twhile(w!=0){\n\t\tcalc(w,h);\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nint op[32][32];\nint dist[32][32][4];\nint c[4];\n\nstruct State {\n\tint i, j, dir, dist;\n\tconst bool operator<(const State& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tfor (;;) {\n\t\tint w, h; cin >> w >> h;\n\t\tif (!w && !h) break;\n\t\t\n\t\t// reset\n\t\trep(i, 0, 32) rep(j, 0, 32) op[i][j] = -1;\n\t\trep(i, 0, 32) rep(j, 0, 32) rep(k, 0, 4) dist[i][j][k] = 999999;\n\n\t\trep(i, 0, h) rep(j, 0, w) cin >> op[i][j];\n\t\trep(i, 0, 4) cin >> c[i];\n\n\t\tpriority_queue<State> pq;\n\t\tdist[0][0][0] = 0;\n\t\tpq.push(State {0, 0, 0, 0});\n\n\t\twhile (!pq.empty()) {\n\t\t\tState st = pq.top(); pq.pop();\n\t\t\tif (st.dist > dist[st.i][st.j][st.dir])\n\t\t\t\tcontinue;\n\t\t\tfor (int dd = 0; dd < 4; dd++) {\n\t\t\t\tint ndir = (st.dir + dd) % 4;\n\t\t\t\tint cost = op[st.i][st.j] != dd ? c[dd] : 0;\n\t\t\t\tint ni = st.i + dir[ndir][0], nj = st.j + dir[ndir][1];\n\t\t\t\tif (0 <= ni && ni < h && 0 <= nj && nj < w && st.dist + cost < dist[ni][nj][ndir]) {\n\t\t\t\t\t//printf(\"(%d, %d, %d) -> (%d, %d, %d) = %d\\n\", st.i, st.j, st.dir, ni, nj, ndir, st.dist + cost);\n\t\t\t\t\tdist[ni][nj][ndir] = st.dist + cost;\n\t\t\t\t\tpq.push(State {ni, nj, ndir, st.dist + cost});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 9999999;\n\t\trep(i, 0, 4) ans = min(ans, dist[h - 1][w - 1][i]);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nint dp[30][30][4],H,W,map[30][30],cost[4];\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdir = arg_dir;\n\t}\n\n\tint row,col;\n\tDIR dir;\n};\n\nDIR turn_R(DIR dir){\n\tswitch(dir){\n\tcase North:\n\t\treturn East;\n\tcase East:\n\t\treturn South;\n\tcase South:\n\t\treturn West;\n\tcase West:\n\t\treturn North;\n\t}\n}\n\nDIR turn_L(DIR dir){\n\tswitch(dir){\n\tcase North:\n\t\treturn West;\n\tcase East:\n\t\treturn North;\n\tcase South:\n\t\treturn East;\n\tcase West:\n\t\treturn South;\n\t}\n}\n\nDIR turn_180(DIR dir){\n\tswitch(dir){\n\tcase North:\n\t\treturn South;\n\tcase East:\n\t\treturn West;\n\tcase South:\n\t\treturn North;\n\tcase West:\n\t\treturn East;\n\t}\n}\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint next_row,next_col;\n\tDIR next_dir;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&map[i][k]);\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++)scanf(\"%d\",&cost[i]);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tfor(int p = 0; p < 4; p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][0][East] = 0;\n\n\t\tqueue<Info> Q;\n\n\t\tQ.push(Info(0,0,East));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row == H-1 && Q.front().col == W-1){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i <= 5; i++){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tnext_dir = Q.front().dir;\n\n\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[0]){\n\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[0];\n\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tnext_dir = turn_R(Q.front().dir);\n\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[1]){\n\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[1];\n\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tnext_dir = turn_180(Q.front().dir);\n\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[2]){\n\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[2];\n\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tnext_dir = turn_L(Q.front().dir);\n\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[3]){\n\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[3];\n\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tswitch(map[Q.front().row][Q.front().col]){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tnext_dir = Q.front().dir;\n\n\t\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tnext_dir = turn_R(Q.front().dir);\n\t\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tnext_dir = turn_180(Q.front().dir);\n\t\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tnext_dir = turn_L(Q.front().dir);\n\t\t\t\t\t\t\tswitch(Q.front().dir){\n\t\t\t\t\t\t\tcase North:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase East:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase South:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase West:\n\t\t\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_dir));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\n\t\tprintf(\"%d\\n\",min(dp[H-1][W-1][East],dp[H-1][W-1][South]));\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E9;\nstatic const int dx[] = {0, 1, 0, -1};\nstatic const int dy[] = {1, 0, -1, 0};\nint w, h;\nint s[55][55];\nint c[5];\nbool used[55][55][5];\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint main()\n{\n  while(cin >> w >> h, w){\n    rep(i, h) rep(j, w) rep(k, 5) used[i][j][k] = false;\n    rep(i, h) rep(j, w) cin >> s[i][j];\n    rep(i, 4) cin >> c[i];\n\n    priority_queue<vi, vector<vi>, greater<vi> > que;\n    vi tmp(4);\n    tmp[0] = 0, tmp[1] = 0, tmp[2] = 0, tmp[3] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vi here = que.top();  que.pop();\n      int cost = here[0];\n      int hd = here[1];\n      int hx = here[2];\n      int hy = here[3];\n      if(hx == h - 1 && hy == w - 1){\n        cout << cost << endl;\n        break;\n      }\n      if(used[hx][hy][hd]) continue;\n      used[hx][hy][hd] = true;\n      rep(k, 4){\n        int nd = (hd + k) % 4;\n        int nx = hx + dx[nd];\n        int ny = hy + dy[nd];\n        if(!check(nx, ny)) continue;\n        tmp[0] = cost + (s[hx][hy] == k ? 0 : c[k]);\n        tmp[1] = nd, tmp[2] = nx, tmp[3] = ny;\n        que.push(tmp);\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w,h;\n\nint table[35][35];\nint c[4];\nint dist[35][35][4];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\ntypedef tuple<int,int,int,int> state;\nvoid dijkstra(){\n\trep(i,h)rep(j,w)rep(k,4)dist[i][j][k]=inf;\n\tdist[0][0][1]=0;\n\tstate s=make_tuple(0,0,0,1);\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint x,y,d,costs;\n\t\ttie(costs,y,x,d)=cur;\n\t\tif(dist[y][x][d]<costs)\n\t\t\tcontinue;\n\t\trep(i,4){\n\t\t\tint nx=x,ny=y,nd=d,ncosts=costs;\n\t\t\tnd=(nd+i)%4;\n\t\t\tnx+=dx[nd],ny+=dy[nd];\n\t\t\tif(table[y][x]!=i)\n\t\t\t\tncosts+=c[i];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\tif(dist[ny][nx][nd]>ncosts){\n\t\t\t\t\tdist[ny][nx][nd]=ncosts;\n\t\t\t\t\tq.push(make_tuple(ncosts,ny,nx,nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0)\n\t\t\tbreak;\n\t\trep(i,h)rep(j,w) scanf(\"%d\",&table[i][j]);\n\t\trep(i,4) scanf(\"%d\",&c[i]);\n\t\tdijkstra();\n\t\tint ans=inf;\n\t\trep(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n#define INF 999999999\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP; // h, w, cost, direction\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nvoid solve()\n{\n\tint w, h;\n\twhile(cin >> w >> h, w || h)\n\t{\n\t\tvector< vector<int> > order(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tcin >> order[i][j];\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tcin >> c[i];\n\t\t}\n\t\tint dist[31][31][4];\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < 4; ++k)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[0][0][1] = 0;\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > pq;\n\t\tpq.push(PP(P(0, 0), P(0, 1)));\n\t\twhile(!pq.empty())\n\t\t{\n\t\t\tPP pp = pq.top();\n\t\t\tint y = pq.top().first.first;\n\t\t\tint x = pq.top().first.second;\n\t\t\tint sum_cost = pq.top().second.first;\n\t\t\tint dir = pq.top().second.second;\n\t\t\tpq.pop();\n\t\t\tif(dist[y][x][dir] < sum_cost)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint cost = c[i];\n\t\t\t\tif(order[y][x] == i)\n\t\t\t\t{\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tint prev = dir;\n\t\t\t\tint next = (prev + i) % 4;\n\t\t\t\tint nx = x + dx[next];\n\t\t\t\tint ny = y + dy[next];\n\n\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}\n\t\t\t\tif(dist[ny][nx][next] > sum_cost + cost)\n\t\t\t\t{\n\t\t\t\t\tdist[ny][nx][next] = sum_cost + cost;\n\t\t\t\t\tpq.push(PP(P(ny, nx), P(sum_cost + cost, next)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_cost = INF;\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif(min_cost > dist[h - 1][w - 1][i])\n\t\t\t{\n\t\t\t\tmin_cost = dist[h - 1][w - 1][i];\n\t\t\t}\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<pair<int, int>, pair<int, int> > pii; // cost, from, x, y\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nint INF = 10e8;\nint w, h;\nint map[30][30][4];\nint cmap[30][30][4];\nint c[4];\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0) break;\n\n        REP(i, h) REP(j, w) REP(k, 4) map[i][j][k] = INF;\n        REP(i, h){\n            REP(j, w){\n                int s;\n                cin >> s;\n                if(s<=3){\n                    map[i][j][s] = 0;\n                }\n            }\n        }\n\n        REP(i, 4) cin >> c[i];\n        REP(i, h) REP(j, w) REP(k, 4) map[i][j][k] = min(map[i][j][k], c[k]);\n\n        REP(i, h) REP(j, w) REP(k, 4) cmap[i][j][k] = INF;\n        cmap[0][9][1] = 0;\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        que.push(pii(make_pair(0, 1), make_pair(0, 0)));\n        while(!que.empty()){\n            pii p = que.top();\n            que.pop();\n            int cost = p.first.first;\n            int from = p.first.second;\n            int x = p.second.first;\n            int y = p.second.second;\n            REP(i, 4){\n                int nx = x+dx[(i+from)%4];\n                int ny = y+dy[(i+from)%4];\n                if(cmap[ny][nx][(i+from)%4] > map[y][x][i] + cost){\n                    cmap[ny][nx][(i+from)%4] = map[y][x][i] + cost;\n                    que.push(pii(make_pair(cmap[ny][nx][(i+from)%4], (i+from)%4), make_pair(nx, ny)));\n                }\n            }\n        }\n\n        /*\n        REP(i, h){\n            REP(j, w){\n                int out = INF;\n                REP(k, 4) out = min(cmap[i][j][k], out);\n                cout << out;\n            }\n            cout << endl;\n        }\n        */\n\n        int output = INF;\n        REP(i, 4) output  = min(output, cmap[h-1][w-1][i]);\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\nusing namespace std;\nint a[31][31],co[4],d[31][31][5];\ntypedef pair<int,pair<int,int> > P;\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0},w,h;\nP lp;\nint main(){\n  while(cin>>w>>h,w){\n    r(i,31)r(j,31)r(k,5)d[i][j][k]=1e9;\n    r(i,h)r(j,w){\n      cin>>a[i][j];\n      if(a[i][j]!=4)a[i][j]=(a[i][j]+1)%4;\n    }\n    r(i,4)cin>>co[(i+1)%4];\n    priority_queue<P,vector<P>,greater<P> >q;\n    d[0][0][1]=0;\n    lp.fi=0,lp.se.fi=0,lp.se.se=1;\n    q.push(lp);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int x=p.se.fi%100,y=p.se.fi/100,v=p.se.se;\n      r(i,5){\n        if(i==4){if(d[y][x][4]>p.fi)d[y][x][4]=p.fi;}\n        else{\n          int vv=(v+3+i)%4;\n          int xx=x+dx[vv],yy=y+dy[vv];\n          if(xx<0||xx>=w||yy<0||yy>=h)continue;\n          int cost=(i==a[y][x])?0:co[i];cost+=p.fi;\n          if(d[yy][xx][vv]>cost){\n            d[yy][xx][vv]=cost;\n            lp.fi=cost,lp.se.fi=yy*100+xx,lp.se.se=vv;\n            q.push(lp);\n          }\n        }\n      }\n    }\n    cout<<d[h-1][w-1][4]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n\nconst double EPS = 1e-9;\n\n// 0: \"Straight\"\n// 1: \"Right\"\n// 2: \"Back\"\n// 3: \"Left\"\n// 4: \"Halt\"\n\nconst int dx[][4] = {\n    // → ↓ ← ↑\n    {1,0,-1,0},\n    // ↑ → ↓ ←\n    {0,1,0,-1},\n    // ← ↑ → ↓\n    {-1,0,1,0},\n    // ↓ ← ↑ →\n    {0,-1,0,1}\n};\n\nconst int dy[][4] = {\n    // → ↓ ← ↑\n    {0,1,0,-1},\n    // ↑ → ↓ ←\n    {-1,0,1,0},\n    // ← ↑ → ↓\n    {0,-1,0,1},\n    // ↓ ← ↑ →\n    {1,0,-1,0}\n};\n\n// → ↑ ← ↓\nconst int dd[][4] = {\n    // → ↓ ← ↑\n    {0,3,2,1},\n    // ↑ → ↓ ←\n    {1,0,1,3},\n    // ← ↑ → ↓\n    {2,1,0,3},\n    // ↓ ← ↑ →\n    {3,2,1,0}\n};\nstruct Robot{\n    int y,x,dir,step;\n    Robot(int y,int x,int dir,int step) : y(y),x(x),dir(dir),step(step) {};\n};\n\nbool operator<(const Robot& lhs,const Robot& rhs){\n    return lhs.step < rhs.step;\n}\nbool operator>(const Robot& lhs,const Robot& rhs){\n    return lhs.step > rhs.step;\n}\n\nint main(){\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0 and h == 0) break;\n        int gy = h-1,gx = w - 1;\n        vector<vector<int> > field(h,vector<int>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n            }\n        }\n\n        vector<int> costs(4);\n        for(int i=0;i<4;i++) cin >> costs[i];\n\n        vector<vector<vector<char> > > used(h,vector<vector<char> >(w,vector<char>(4,false)));\n        priority_queue<Robot,vector<Robot>,greater<Robot> > que;\n        que.push(Robot(0,0,0,0));\n        int ret = 0;\n        while(not que.empty()){\n            Robot r = que.top();\n            que.pop();\n            if(used[r.y][r.x][r.dir]) continue;\n            used[r.y][r.x][r.dir] = true;\n            if(r.y == gy and r.x == gx){\n                ret = r.step;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                int ny = r.y + dy[r.dir][i];\n                int nx = r.x + dx[r.dir][i];\n                if(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n                if(i == field[r.y][r.x]){\n                    que.push(Robot(ny,nx,dd[r.dir][i],r.step));\n                }else{\n                    que.push(Robot(ny,nx,dd[r.dir][i],r.step+costs[i]));\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <functional>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n\n#define ALL(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define each(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\ntypedef long long LINT;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\n\nconst int INF = 1 << 29;\nconst int MAX_WH = 30;\nconst int MAX_D = 4;\n\nstruct robot {\n\tint x, y, dir;\n\trobot ( int ix, int iy, int id ) : x(ix), y(iy), dir(id) {}\n};\nenum { R, D, L, U };\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\ntypedef vector<VVI> VVVI;\n\nint main ( void )\n{\n\tint w, h;\n\twhile (cin >> w >> h, w|h) {\n\t\tVVI cmd(h, VI(w));\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tcin >> cmd[i][j];\n\t\t\t}\n\t\t}\n\t\tVI changeCost(MAX_D);\n\t\tfor (int i = 0; i < MAX_D; ++i) {\n\t\t\tcin >> changeCost[i];\n\t\t}\n\t\tVVVI mc(MAX_D, VVI(h, VI(w, INF)));\n\t\tqueue<robot> que;\n\t\tque.push(robot(0, 0, R));\n\t\tmc[R][0][0] = 0;\n\t\twhile (!que.empty()) {\n\t\t\trobot p = que.front(); que.pop();\n\t\t\tfor (int d = 0; d < MAX_D; ++d) {\n\t\t\t\tint todir = (p.dir + d) % MAX_D;\n\t\t\t\tint mx = p.x + dx[todir];\n\t\t\t\tint my = p.y + dy[todir];\n\t\t\t\tif (mx < 0 || w <= mx || my < 0 || h <= my) { continue; }\n\t\t\t\tint cost = mc[p.dir][p.y][p.x] + (cmd[p.y][p.x] == d ? 0 : changeCost[d]);\n\t\t\t\tif (mc[todir][my][mx] > cost) {\n\t\t\t\t\tmc[todir][my][mx] = cost;\n\t\t\t\t\tque.push(robot(mx, my, todir));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < MAX_D; ++i) {\n\t\t\tans = min(ans, mc[i][h-1][w-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum DIR{\n    North,\n    East,\n    South,\n    West,\n};\n\nint dp[30][30][4],H,W,map[30][30],cost[4];\n\nstruct Info{\n    Info(int arg_row,int arg_col,DIR arg_dir){\n        row = arg_row;\n        col = arg_col;\n        dir = arg_dir;\n    }\n\n    int row,col;\n    DIR dir;\n};\n\nDIR turn_R(DIR dir){\n    switch(dir){\n    case North:\n        return East;\n    case East:\n        return South;\n    case South:\n        return West;\n    case West:\n        return North;\n    }\n}\n\nDIR turn_L(DIR dir){\n    switch(dir){\n    case North:\n        return West;\n    case East:\n        return North;\n    case South:\n        return East;\n    case West:\n        return South;\n    }\n}\n\nDIR turn_180(DIR dir){\n    switch(dir){\n    case North:\n        return South;\n    case East:\n        return West;\n    case South:\n        return North;\n    case West:\n        return East;\n    }\n}\n\nbool rangeCheck(int row,int col){\n    if(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n    else{\n        return false;\n    }\n}\n\nint main(){\n\n    int next_row,next_col;\n    DIR next_dir;\n\n    while(true){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0)break;\n\n        for(int i = 0; i < H; i++){\n            for(int k = 0; k < W; k++)scanf(\"%d\",&map[i][k]);\n        }\n\n        for(int i = 0; i < 4; i++)scanf(\"%d\",&cost[i]);\n\n        for(int i = 0; i < H; i++){\n            for(int k = 0; k < W; k++){\n                for(int p = 0; p < 4; p++)dp[i][k][p] = BIG_NUM;\n            }\n        }\n\n        dp[0][0][East] = 0;\n\n        queue<Info> Q;\n\n        Q.push(Info(0,0,East));\n\n        while(!Q.empty()){\n\n            if(Q.front().row == H-1 && Q.front().col == W-1){\n                Q.pop();\n            }else{\n\n                for(int i = 0; i <= 5; i++){\n                    switch(i){\n                    case 0:\n                        next_dir = Q.front().dir;\n\n                        switch(Q.front().dir){\n                        case North:\n                            next_row = Q.front().row-1;\n                            next_col = Q.front().col;\n                            break;\n                        case East:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col+1;\n                            break;\n                        case South:\n                            next_row = Q.front().row+1;\n                            next_col = Q.front().col;\n                            break;\n                        case West:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col-1;\n                            break;\n                        }\n\n                        if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[0]){\n                            dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[0];\n                            Q.push(Info(next_row,next_col,next_dir));\n                        }\n                        break;\n                    case 1:\n                        next_dir = turn_R(Q.front().dir);\n                        switch(Q.front().dir){\n                        case North:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col+1;\n                            break;\n                        case East:\n                            next_row = Q.front().row+1;\n                            next_col = Q.front().col;\n                            break;\n                        case South:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col-1;\n                            break;\n                        case West:\n                            next_row = Q.front().row-1;\n                            next_col = Q.front().col;\n                            break;\n                        }\n\n                        if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[1]){\n                            dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[1];\n                            Q.push(Info(next_row,next_col,next_dir));\n                        }\n\n                        break;\n                    case 2:\n                        next_dir = turn_180(Q.front().dir);\n                        switch(Q.front().dir){\n                        case North:\n                            next_row = Q.front().row+1;\n                            next_col = Q.front().col;\n                            break;\n                        case East:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col-1;\n                            break;\n                        case South:\n                            next_row = Q.front().row-1;\n                            next_col = Q.front().col;\n                            break;\n                        case West:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col+1;\n                            break;\n                        }\n                        if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[2]){\n                            dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[2];\n                            Q.push(Info(next_row,next_col,next_dir));\n                        }\n\n                        break;\n                    case 3:\n                        next_dir = turn_L(Q.front().dir);\n                        switch(Q.front().dir){\n                        case North:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col-1;\n                            break;\n                        case East:\n                            next_row = Q.front().row-1;\n                            next_col = Q.front().col;\n                            break;\n                        case South:\n                            next_row = Q.front().row;\n                            next_col = Q.front().col+1;\n                            break;\n                        case West:\n                            next_row = Q.front().row+1;\n                            next_col = Q.front().col;\n                            break;\n                        }\n                        if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]+cost[3]){\n                            dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir]+cost[3];\n                            Q.push(Info(next_row,next_col,next_dir));\n                        }\n                        break;\n                    case 4:\n                        switch(map[Q.front().row][Q.front().col]){\n                        case 0:\n                            next_dir = Q.front().dir;\n\n                            switch(Q.front().dir){\n                            case North:\n                                next_row = Q.front().row-1;\n                                next_col = Q.front().col;\n                                break;\n                            case East:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col+1;\n                                break;\n                            case South:\n                                next_row = Q.front().row+1;\n                                next_col = Q.front().col;\n                                break;\n                            case West:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col-1;\n                                break;\n                            }\n\n                            if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n                                dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n                                Q.push(Info(next_row,next_col,next_dir));\n                            }\n                            break;\n                        case 1:\n                            next_dir = turn_R(Q.front().dir);\n                            switch(Q.front().dir){\n                            case North:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col+1;\n                                break;\n                            case East:\n                                next_row = Q.front().row+1;\n                                next_col = Q.front().col;\n                                break;\n                            case South:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col-1;\n                                break;\n                            case West:\n                                next_row = Q.front().row-1;\n                                next_col = Q.front().col;\n                                break;\n                            }\n\n                            if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n                                dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n                                Q.push(Info(next_row,next_col,next_dir));\n                            }\n\n                            break;\n                        case 2:\n                            next_dir = turn_180(Q.front().dir);\n                            switch(Q.front().dir){\n                            case North:\n                                next_row = Q.front().row+1;\n                                next_col = Q.front().col;\n                                break;\n                            case East:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col-1;\n                                break;\n                            case South:\n                                next_row = Q.front().row-1;\n                                next_col = Q.front().col;\n                                break;\n                            case West:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col+1;\n                                break;\n                            }\n                            if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n                                dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n                                Q.push(Info(next_row,next_col,next_dir));\n                            }\n\n                            break;\n                        case 3:\n                            next_dir = turn_L(Q.front().dir);\n                            switch(Q.front().dir){\n                            case North:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col-1;\n                                break;\n                            case East:\n                                next_row = Q.front().row-1;\n                                next_col = Q.front().col;\n                                break;\n                            case South:\n                                next_row = Q.front().row;\n                                next_col = Q.front().col+1;\n                                break;\n                            case West:\n                                next_row = Q.front().row+1;\n                                next_col = Q.front().col;\n                                break;\n                            }\n                            if(rangeCheck(next_row,next_col) == true && dp[next_row][next_col][next_dir] > dp[Q.front().row][Q.front().col][Q.front().dir]){\n                                dp[next_row][next_col][next_dir] = dp[Q.front().row][Q.front().col][Q.front().dir];\n                                Q.push(Info(next_row,next_col,next_dir));\n                            }\n                            break;\n                        case 4:\n                            //Do nothing\n                            break;\n                        }\n                        break;\n                    }\n                }\n\n                Q.pop();\n            }\n        }\n\n\n        printf(\"%d\\n\",min(dp[H-1][W-1][East],dp[H-1][W-1][South]));\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& out, const std::vector<T>& v) {\n  if (!v.empty()) {\n    out << '[';\n    std::copy(v.begin(), v.end(), std::ostream_iterator<T>(out, \", \"));\n    out << \"\\b\\b]\";\n  }\n  return out;\n}\n\ntemplate <typename T>\nclass Dijkstra {\n public:\n  Dijkstra(int vertex_num) {\n    this->vertex_num = vertex_num;\n    edges = vector<vector<tuple<int, T>>>(vertex_num);\n    distances = vector<T>(vertex_num);\n  }\n\n  void addEdge(int from, int dest, T cost) {\n    edges[from].push_back(make_tuple(dest, cost));\n  }\n\n  void update(int source) {\n    for (int i = 0; i < vertex_num; ++i) distances[i] = -1;\n    distances[source] = 0;\n    priority_queue<tuple<T, int>, vector<tuple<T, int>>, greater<tuple<T, int>>>\n        q;\n    q.push(make_tuple(0, source));\n    while (!q.empty()) {\n      int vertex = get<1>(q.top());\n      T distance = get<0>(q.top());\n      q.pop();\n      if (distances[vertex] < distance) continue;\n      for (auto e : edges[vertex]) {\n        int next_vertex = get<0>(e);\n        T next_distance = get<1>(e) + distance;\n        if (distances[next_vertex] == -1 ||\n            next_distance < distances[next_vertex]) {\n          distances[next_vertex] = next_distance;\n          q.push(make_tuple(next_distance, next_vertex));\n        }\n      }\n    }\n  }\n\n  T getDistance(int vertex) { return distances[vertex]; }\n\n  // private:\n  int vertex_num;\n  vector<vector<tuple<int, T>>> edges;\n  vector<T> distances;\n  Dijkstra() {}\n};\n\nvoid solve(int w, int h, vector<vector<int>>& board, vector<int> c) {\n  Dijkstra<int> dijkstra(w * h * 4);\n  int WH = w * h;\n  for (int k = 0; k < 4; ++k) {  // u,r,d,l\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        vector<int> cost = c;\n        if (board[i][j] != 4) cost[board[i][j]] = 0;\n        int v = w * i + j;\n\n        int u = i > 0 ? v - w : -1;\n        int r = j < w - 1 ? v + 1 + WH : -1;\n        int d = i < h - 1 ? v + w + 2 * WH : -1;\n        int l = j > 0 ? v - 1 + 3 * WH : -1;\n\n        int straight = -1, right = -1, back = -1, left = -1;\n        if (k == 0) {\n          if (u >= 0) straight = u;\n          if (r >= 0) right = r;\n          if (d >= 0) back = d;\n          if (l >= 0) left = l;\n        } else if (k == 1) {\n          if (u >= 0) left = u;\n          if (r >= 0) straight = r;\n          if (d >= 0) right = d;\n          if (l >= 0) back = l;\n        } else if (k == 2) {\n          if (u >= 0) back = u;\n          if (r >= 0) left = r;\n          if (d >= 0) straight = d;\n          if (l >= 0) right = l;\n        } else {\n          if (u >= 0) right = u;\n          if (r >= 0) back = r;\n          if (d >= 0) left = d;\n          if (l >= 0) straight = l;\n        }\n\n        if (straight >= 0) dijkstra.addEdge(v + k * WH, straight, cost[0]);\n        if (right >= 0) dijkstra.addEdge(v + k * WH, right, cost[1]);\n        if (back >= 0) dijkstra.addEdge(v + k * WH, back, cost[2]);\n        if (left >= 0) dijkstra.addEdge(v + k * WH, left, cost[3]);\n      }\n    }\n  }\n  int start = WH * 1;\n  dijkstra.update(start);\n  int ans = 1000000000;\n  for (int i = 0; i < 4; ++i) {\n    int goal = h * w - 1 + WH * i;\n    int cost = dijkstra.getDistance(goal);\n    if (cost >= 0 && cost < ans) ans = cost;\n  }\n  // for (int k = 0; k < 4; ++k) {\n  //   for (int i = 0; i < h; ++i) {\n  //     for (int j = 0; j < w; ++j) {\n  //       cout << dijkstra.distances[i * w + j + WH * k] << \" \";\n  //     }\n  //     cout << endl;\n  //   }\n  //   cout << endl;\n  // }\n  cout << ans << endl;\n}\n\nint main() {\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0) break;\n\n    vector<vector<int>> board(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> board[i][j];\n      }\n    }\n    vector<int> c(4);\n    for (int i = 0; i < 4; ++i) cin >> c[i];\n    solve(w, h, board, c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int inf = 999999;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint w, h;\nvector<vector<int> > s;\nvector<int> c;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(){\n    vector<vector<vector<int> > > mem(h, vector<vector<int> >(w, vector<int>(4, inf)));\n    mem[0][0][1] = 0;\n    auto comp = [&](const int a, const int b){\n        int ad = a / 10000, ax = a % 10000 / 100, ay = a % 100,\n            bd = b / 10000, bx = b % 10000 / 100, by = b % 100;\n        return mem[bx][by][bd] < mem[ax][ay][ad];\n    };\n    priority_queue<int, vector<int>, decltype(comp)> q(comp);\n    for(q.push(10000 + 0 * 100 + 0); !q.empty();){\n        int t = q.top(); q.pop();\n        int d = t / 10000, x = t % 10000 / 100, y = t % 100;\n        if(x == h-1 && y == w-1)continue;\n        rep(k, 4){\n            int nd = (d + k) % 4;\n            int nx = x + dx[nd], ny = y + dy[nd];\n            if(inrect(nx, ny)){\n                int cost = mem[x][y][d] + (s[x][y] == k? 0: c[k]);\n                if(mem[nx][ny][nd] <= cost)continue;\n                mem[nx][ny][nd] = cost;\n                q.push(nd * 10000 + nx * 100 + ny);\n            }\n        }\n    }\n    return min(mem[h-1][w-1][1], mem[h-1][w-1][2]);\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        s.assign(h, vector<int>(w));\n        rep(i, h)rep(j, w)cin >> s[i][j];\n        c.resize(4);\n        rep(i, 4)cin >> c[i];\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,c[4],s[30][30],cost[30][30][4],*g;\nvoid rec(int y,int x,int d){\n\trep(r,4){\n\t\tint nd=d+r&3,ny=y+dy[nd],nx=x+dx[nd],nc=cost[y][x][d]+(r==s[y][x]?0:c[r]);\n\t\tif(cost[ny][nx][nd]>nc)cost[ny][nx][nd]=nc,rec(ny,nx,nd);\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w){\n\t\t\trep(k,4)cost[i][j][k]=INF;\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\trep(i,4)cin>>c[i]; cost[0][0][0]=0;\n\t\trec(0,0,0); g=cost[h-1][w-1];\n\t\tcout<<(g[0]>g[1]?g[1]:g[0])<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 35\n\nint w, h;\nint s[MAX][MAX];\nint dp[MAX][MAX];\nint cost[MAX][MAX][4];\nint c[4];\nstruct Point {\n\tint y, x, dir, cost;\n};\n//bool next_flag(Point& now) {\n//\tint i;\n//\tbool flag = false;\n//\trep(i, 4) {\n//\t\tint ny = now.y + dy[i];\n//\t\tint nx = now.x + dx[i];\n//\t\tif (ny < 0 || h <= ny) continue;\n//\t\tif (nx < 0 || w <= nx) continue;\n//\t\tif (cost[ny][nx] > cost[now.y][now.x]) flag = true;\n//\t}\n//\treturn flag;\n//}\nint ddir[] = { 0,3,2,1 };\nvoid wfs() {\n\tint i, j, k;\n\trep(i, h) rep(j, w) rep(k, 4) cost[i][j][k] = INT_MAX;\n\tqueue<Point> q;\n\tq.push({ 0,0,1,0 });\n\tcost[0][0][1] = 0;\n\twhile (q.size()) {\n\t\tPoint now = q.front(); q.pop();\n\t\trep(i, 4) {\n\t\t\tint ndir = (now.dir + ddir[i]) % 4;\n\t\t\tint ny = now.y + dy[ndir];\n\t\t\tint nx = now.x + dx[ndir];\n\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\tif (nx < 0 || w <= nx) continue;\n\n\t\t\tint ncost = now.cost;\n\t\t\tif (s[now.y][now.x] != i) ncost += c[i];\n\n\t\t\tif (ncost < cost[ny][nx][ndir]) {\n\t\t\t\tcost[ny][nx][ndir] = ncost;\n\t\t\t\tq.push({ ny,nx,ndir,ncost });\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 4) dump(cost[0][w - 1][i]);\n\t//rep(i, 4) dump(cost[1][w - 1][i]);\n\t//dump(cost[2][w - 1][0]);\n\t//dump(cost[2][w - 1][1]);\n\t//dump(cost[2][w - 1][2]);\n\t//dump(cost[2][w - 1][3]);\n\n\t//dump(cost[2][w - 2][0]);\n\t//dump(cost[2][w - 2][1]);\n\t//dump(cost[2][w - 2][2]);\n\t//dump(cost[2][w - 2][3]);\n\n\t//dump(cost[1][0][0]);\n\t//dump(cost[1][0][1]);\n\t//dump(cost[1][0][2]);\n\t//dump(cost[1][0][3]);\n}\n\nsigned main(void)\n{\n\tint i, j, k;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) rep(j, w) reader(s[i][j]);\n\t\trep(i, 4) reader(c[i]);\n\t\twfs();\n\t\tint ans = INT_MAX;\n\t\trep(i, 4) {\n\t\t\tif (cost[h - 1][w - 1][i] < ans) {\n\t\t\t\tans = cost[h - 1][w - 1][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n#define mkp make_pair\n#define PB push_back\n#define ALL(v) v.begin(),v.end()\n#define maxs(a,b) (a=max(a,b))\n#define mins(a,b) (a=min(a,b))\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<vector<int>> vvint;\ntypedef pair<int,int> pii;\n\nint dp[40][40][4];\nint dd[]={-1,0,1,0,-1};\ntypedef pair<pii,pii> P;\nint w,h;\n\nbool inside(pii a){\n\treturn 0<=a.F&&a.F<h&&0<=a.S&&a.S<w;\n}\n\n\nint main(){\n\twhile(cin>>w>>h,h||w){\n\t\tvvint vv(h,vint(w));\n\t\trep(i,h){\n\t\t\trep(j,w) cin>>vv[i][j];\n\t\t}\n\t\tvint co(4);\n\t\trep(i,4) cin>>co[i];\n\t\t// rep(i,4) cout<<co[i]<<\" \";cout<<endl;\n\t\trep(i,40) rep(j,40) rep(k,4) dp[i][j][k]=INF;\n\t\tdp[0][0][1]=0;\n\t\tpriority_queue<P> pq;\n\t\tpq.push(mkp(pii(0,1),pii(0,0)));\n\t\twhile(pq.size()){\n\t\t\tP top=pq.top();\n\t\t\tpii pos = top.S;\n\t\t\tint cost = -top.F.F;\n\t\t\tint di = top.F.S;\n\t\t\tpq.pop();\n\t\t\tif(dp[pos.F][pos.S][di]<cost) continue;\n\t\t\t// cout<<pos.F<<\" \"<<pos.S<<\" \"<<di<<\" \"<<cost<<endl;\n\t\t\tif(vv[pos.F][pos.S]!=4){\n\t\t\t\tint nd = (di+vv[pos.F][pos.S])%4;\n\t\t\t\tpii npos(pos.F+dd[nd],pos.S+dd[nd+1]);\n\t\t\t\tif(inside(npos)){\n\t\t\t\t\tif(dp[npos.F][npos.S][nd]>cost){\n\t\t\t\t\t\tdp[npos.F][npos.S][nd]=cost;\n\t\t\t\t\t\tpq.push(mkp(pii(-cost,nd),npos));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tint nd = (di+i)%4;\n\t\t\t\tpii npos(pos.F+dd[nd],pos.S+dd[nd+1]);\n\t\t\t\tif(inside(npos)){\n\t\t\t\t\tif(dp[npos.F][npos.S][nd]>cost+co[i]){\n\t\t\t\t\t\tdp[npos.F][npos.S][nd]=cost+co[i];\n\t\t\t\t\t\tpq.push(mkp(pii(-cost-co[i],nd),npos));\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i,4){\n\t\t\tmins(ans,dp[h-1][w-1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tint color = 0;\n\n\tmap<string,int> t;\n\tvector<priority_queue<int,vector<int> ,greater<int> > > tt;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tint d;\n\t\tcin>>s>>d;\n\t\tif(t.find(s) == t.end() ){\n\t\t\tpriority_queue<int,vector<int> ,greater<int> > q;\n\t\t\tt[s] = tt.size();\n\t\t\tq.push(d);\n\t\t\ttt.push_back(q);\n\t\t}else{\n\t\t\tint ss = t[s];\n\t\t\ttt[ss].push(d);\n\t\t}\n\t}\n\n\tint m;\n\tcin>>m;\n\tbool f = false;\n\tint now = -1;\n\tfor(int i=0;i<m;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(f)continue;\n\t\tif(t.find(s) == t.end()){\n\t\t\t//cout<<\"color not exsit\"<<endl;\n\t\t\tf = true;\n\t\t\tcontinue;\n\t\t}\n\t\tint ss = t[s];\n\t\tif(tt[ss].empty() ){\n\t\t\t//cout<<\"color used \"<<endl;\n\t\t\tf = true;\n\t\t\t//cout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint next=tt[ss].top();\n\t\ttt[ss].pop();\n\t\t//cout<<s<<' '<<next<<endl;\n\t\twhile(now  >= next){\n\t\t\tif(tt[ss].empty() ){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext = tt[ss].top();\n\t\t\ttt[ss].pop();\n\t\t\t//cout<<now<<' '<<next<<endl;\n\t\t\t//cout<<2<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tnow = next;\n\t}\n\tif(f){\n\t\tcout<<\"No\"<<endl;\n\t}else{\n\t\tcout<<\"Yes\"<<endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n\n#define INF INT_MAX>>1 //要climits#includ\n\nusing namespace std;\n\ntypedef long long ll;\n\nint dx[] ={0, 1, 0, -1};\nint dy[] ={-1, 0, 1, 0};\n\ntypedef struct robot{\n\tint x;\n\tint y;\n\tint dir;\n\tint cost;\n}robot;\n\nint main() {\n\twhile(1) {\n\t\tint w, h; cin >> w >> h;\n\t\tif(!w && !h) break;\n\n\t\tint s[30][30];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tfor(int i=0; i<4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tint dp[30][30][4];\n\t\tfill(dp[0][0], dp[30][0], INF);\n\t\tdp[0][0][1] = 0;\n\t\trobot initial ={0, 0, 1, 0};\n\t\tqueue<robot> q;\n\t\tq.push(initial);\n\n\t\twhile(!q.empty()) {\n\t\t\trobot prev = q.front(); \n\t\t\tq.pop();\n\n\t\t\tif(prev.cost > dp[prev.y][prev.x][prev.dir]) continue;\n\n\t\t\t//回転方向\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\trobot next;\n\t\t\t\tnext.dir = (prev.dir + i) % 4;\n\t\t\t\tnext.cost = prev.cost;\n\t\t\t\tif(s[prev.y][prev.x] != i) next.cost += c[i];\n\t\t\t\tnext.y = prev.y + dy[next.dir];\n\t\t\t\tnext.x = prev.x + dx[next.dir];\n\t\t\t\tif(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) continue;\n\t\t\t\tif(dp[next.y][next.x][next.dir] > next.cost) {\n\t\t\t\t\tdp[next.y][next.x][next.dir] = next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tans = min(ans, dp[h - 1][w - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint w, h;\nint s[32][32];\nint cost[4];\n\n// dir\n// 0 : right\n// 1 : up\n// 2 : left\n// 3 : down\nconst int dr[4] = {0, -1, 0, 1};\nconst int dc[4] = {1, 0, -1, 0};\nconst int dd[4] = {0, 3, 2, 1};\n\ntypedef std::pair<int, int> Pii;\n\nclass Node {\npublic:\n  Node() {}\n  Node(int r_, int c_, int dir_) : r(r_), c(c_), dir(dir_) {}\n  int r, c, dir;\n};\n\nclass Data {\npublic:\n  Data() {}\n  Data(Node s_, Node t_, int cost_) : s(s_), t(t_), cost(cost_) {}\n  Node s, t;\n  int cost;\n};\n\ninline bool operator < (const Data& a, const Data& b) {\n  return a.cost > b.cost;\n}\n\nint dist[32][32][8];\nint dijkstra() {\n  std::priority_queue<Data> q;\n  int r = 0;\n  int c = 0;\n  int dir = 0;\n  dist[r][c][dir] = 0;\n  for(int k = 0; k < 4; ++k) {\n    int nd = (dir + dd[k]) % 4;\n    int nr = r + dr[nd];\n    int nc = c + dc[nd];\n    if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n    q.push(Data(Node(r, c, dir), Node(nr, nc, nd), dist[r][c][dir] + (k == s[r][c] ? 0 : cost[k])));\n  }\n  while( not q.empty() ) {\n    Data t = q.top(); q.pop();\n    int r = t.t.r, c = t.t.c, dir = t.t.dir;\n    if( dist[r][c][dir] <= t.cost ) continue;\n    dist[r][c][dir] = t.cost;\n    if( r == h - 1 and c == w - 1 ) continue;\n    for(int k = 0; k < 4; ++k) {\n      int nd = (dir + dd[k]) % 4;\n      int nr = r + dr[nd];\n      int nc = c + dc[nd];\n      if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n      int ncost = dist[r][c][dir] + (k == s[r][c] ? 0 : cost[k]);\n      if( ncost >= dist[nr][nc][nd] ) continue;\n      q.push(Data(Node(r, c, dir), Node(nr, nc, nd), ncost));\n    }\n  }\n  int res = (1 << 30);\n  for(int i = 0; i < 4; ++i) {\n    res = std::min(res, dist[h-1][w-1][i]);\n  }\n  return res;\n}\n\nvoid Init() {\n  for(int i = 0; i < 32; ++i) {\n    for(int j = 0; j < 32; ++j) {\n      for(int k = 0; k < 4; ++k) {\n        dist[i][j][k] = (1 << 29);\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    Init();\n    scanf(\"%d %d\", &w, &h);\n    if( w == 0 and h == 0 ) break;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\"%d\", &s[i][j]);\n      }\n    }\n    for(int i = 0; i < 4; ++i) {\n      scanf(\"%d\", &cost[i]);\n    }\n    int res = dijkstra();\n    printf(\"%d\\n\", res);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint w, h;\nint s[31][31];\nint c[4];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint solve()\n{\n\tint cost[31][31][4];\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tcost[i][j][k] = mod;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pair<pair<int, int>, int> > qu;\n\tcost[0][0][0] = 0;\n\tqu.push(make_pair(make_pair(0, 0), 0));\n\twhile(!qu.empty()){\n\t\tint x = ((qu.front()).first).first;\n\t\tint y = ((qu.front()).first).second;\n\t\tint d = (qu.front()).second;\n\t\t// (x, y)?????????????????????d (dx, dy??¨??????)\n\t\tqu.pop();\n\t\t// cout << x << \" \" << y << \" \" << d << \":\" << endl;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\t// i : ???????????????\n\t\t\tint nc = cost[x][y][d];\n\t\t\tint nd = (d + i) % 4;\n\t\t\tint nx = x + dx[nd];\n\t\t\tint ny = y + dy[nd];\n\t\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w) continue;\n\t\t\tif(i != s[x][y]) nc += c[i];\n\t\t\tif(cost[nx][ny][nd] > nc){\n\t\t\t\tcost[nx][ny][nd] = nc;\n\t\t\t\tqu.push(make_pair(make_pair(nx, ny), nd));\n\t\t\t\t// cout << nx << \" \" << ny << \" \" << nd << \" \" << nc << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = mod;\n\tfor(int i = 0; i < 4; i++){\n\t\tans = min(ans, cost[h - 1][w - 1][i]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\ntypedef pair<int,mp> mmp;\ntypedef pair<int,mmp> fmp;\n\n\nint main(void){\n\tfor(;;){\n\t\tint w,h;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(h==0)break;\n\t\tint dat[35][35]={};\n\t\tmemset(dat,-1,sizeof(dat));\n\t\treg(y,1,h){\n\t\t\treg(x,1,w){\n\t\t\t\tscanf(\"%d\",&dat[y][x]);\n\t\t\t}\n\t\t}\n\t\tint cs[4];\n\t\trep(i,4)scanf(\"%d\",&cs[i]);\n\t\t\n\t\tint dp[35][35][4];\n\t\tmemset(dp,-1,sizeof(dp));\n\t\t\n\t\tpriority_queue<fmp,vector<fmp>,greater<fmp> > que;\n\t\tque.push(fmp(0,mmp(0,mp(1,1))));\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tfmp fpa = que.top(); que.pop();\n\t\t\tint co=fpa.fir,\n\t\t\t\tnd=fpa.sec.fir,\n\t\t\t\ty=fpa.sec.sec.fir,\n\t\t\t\tx=fpa.sec.sec.sec;\n\t\t\t\n\t\t\t//printf(\"%d %d %d %d\\n\",co,nd,y,x);\n\t\t\t\n\t\t\tif(dat[y][x]<0)continue;\n\t\t\tif(dp[y][x][nd]!=-1 && dp[y][x][nd]<=co)continue;\n\t\t\tdp[y][x][nd]=co;\n\t\t\t\n\t\t\tif(x==w && y==h){\n\t\t\t\tprintf(\"%d\\n\",co);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\trep(i,4){\n\t\t\t\tint tc=co;\n\t\t\t\tif(dat[y][x]!=i)tc+=cs[i];\n\t\t\t\t\n\t\t\t\tint tx=x,ty=y,td=nd;\n\t\t\t\tif(i!=0)td=(td+i)%4;\n\t\t\t\ttx+=dx[td];\n\t\t\t\tty+=dy[td];\n\t\t\t\t\n\t\t\t\t//printf(\"push_ %d %d %d %d\\n\",tc,td,ty,tx);\n\t\t\t\tque.push(fmp(tc,mmp(td,mp(ty,tx))));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint const INF = 100000000;\nvector<vector<vector<int>>> dijkstra(vector<vector<int>> &field, vector<int> c, int H, int W) {\n    // d[y座標][x座標][方向]\n    vector<vector<vector<int>>> d(H+2, vector<vector<int>>(W+2, vector<int>(4, INF)));\n\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {-1, 0, 1, 0};\n    d[1][1][1] = 0;\n    priority_queue<pair<int, pair<int, pair<int, int>>>, vector<pair<int, pair<int, pair<int, int>>>>, greater<pair<int, pair<int, pair<int, int>>>>> que;\n    que.push({0, {1, {1, 1}}});\n\n    while (!que.empty()) {\n        pair<int, pair<int, pair<int, int>>> p = que.top();\n        que.pop();\n        int dir = p.second.second.second;\n        int y = p.second.first;\n        int x = p.second.second.first;\n        int dist = p.first;\n        if (dist > d[y][x][dir]) continue;\n        for (int i = 0; i < 4; i++) {\n            int cost = c[i];\n            if (field[y][x] == i) cost = 0;\n            int changedDir = (dir + i)%4;\n            int ny = y + dy[changedDir];\n            int nx = x + dx[changedDir];\n            if (field[ny][nx] == -1) continue;\n            if (d[ny][nx][changedDir] > dist + cost) {\n                int nextCost = dist + cost;\n                d[ny][nx][changedDir] = nextCost;\n                que.push({nextCost, {ny, {nx, changedDir}}});\n            }\n        }\n    }\n    return d;\n}\n\nint solve(int H, int W) {\n    vector<vector<int>> field(H+2, vector<int>(W+2, -1));\n    for (int y = 1; y <= H; y++) {\n        for (int x = 1; x <= W; x++) {\n            cin >> field[y][x];\n        }\n    }\n    vector<int> cost(4);\n    for (int i = 0; i < 4; i++) {\n        cin >> cost[i];\n    }\n\n    vector<vector<vector<int>>> d = dijkstra(field, cost, H, W);\n    int ret = INF;\n    for (int i = 0; i < 4; i++) {\n        ret = min(d[H][W][i], ret);\n    }\n    return ret;\n}\n\nint main(void) {\n    int W, H;\n    vector<int> ans;\n    while (1) {\n        cin >> W >> H;\n        if (!W && !H) break;\n        ans.push_back(solve(H, W));\n    }\n    for (auto &i: ans) {\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nint H, W, s[30][30], c[4], d[30][30][4];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint main() {\n\twhile (~scanf(\"%d%d\", &W, &H)) {\n\t\tif (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &s[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) scanf(\"%d\", &c[i]);\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) d[i][j][k] = 999999999;\n\t\t\t}\n\t\t}\n\t\td[0][0][0] = 0;\n\t\tpriority_queue<vector<int> > que; que.push({ 0, 0, 0, 0 }); // (cost, x, y, dir)\n\t\twhile (!que.empty()) {\n\t\t\tvector<int> v1 = que.top(); que.pop();\n\t\t\tif (v1[1] + 1 == W && v1[2] + 1 == H) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint sx = v1[1] + dx[(v1[3] + i) % 4];\n\t\t\t\tint sy = v1[2] + dy[(v1[3] + i) % 4];\n\t\t\t\tif (0 <= sx && sx < W && 0 <= sy && sy < H) {\n\t\t\t\t\tint cost = -v1[0] + (s[v1[2]][v1[1]] != i ? c[i] : 0);\n\t\t\t\t\tif (cost < d[sy][sx][(v1[3] + i) % 4]) {\n\t\t\t\t\t\td[sy][sx][(v1[3] + i) % 4] = cost;\n\t\t\t\t\t\tque.push({ -cost, sx, sy, (v1[3] + i) % 4 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 999999999;\n\t\tfor (int i = 0; i < 4; i++) ret = min(ret, d[H - 1][W - 1][i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nclass Pos {\npublic:\n  int i, j, k;\n  Pos(int i, int j, int k):i(i), j(j), k(k){}\n\n  bool operator<(const Pos &another) const\n  {\n    return i < another.i;\n  };\n  \n};\n\n#define P pair<int, Pos>\n\nint main() {\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) return 0;\n    vii a(h + 2, vi(w + 2, -1));\n    rep1 (i, h) rep1 (j, w) cin >> a[i][j];\n    vi c(4);\n    rep (i, 4) cin >> c[i];\n\n    vector<vii> d(h + 2, vii(w + 2, vi(4, inf)));\n    rep (k, 4) {\n      rep (i, h + 2) d[i][0][k] = d[i][w + 1][k] = -inf;\n      rep (i, w + 2) d[0][i][k] = d[h + 1][i][k] = -inf;\n    }\n\n    d[1][1][1] = 0;\n    P now = {0, Pos(1, 1, 1)};\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(now);\n    while (!pq.empty()) {\n      P now = pq.top();\n      pq.pop();\n      int cost = now.first, i0 = now.second.i, j0 = now.second.j, k0 = now.second.k;\n      int nk;\n      \n      rep (k, 4) {\n        int nc = cost;\n        if (k != a[i0][j0]) nc += c[k];\n        int nk = (k0 + k) % 4;\n        int ni = i0 + dx[nk], nj = j0 + dy[nk];\n\n        if (d[ni][nj][nk] > nc) {\n          d[ni][nj][nk] = nc;\n          pq.push({nc, Pos(ni, nj, nk)});\n        }\n      }\n    }\n    int ans = inf;\n    rep (k, 4) {\n      chmin(ans, d[h][w][k]);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 32\n\nstruct cells {\n  int x;\n  int y;\n  int d;\n  int cost;\n\n  bool operator<(const cells& a) const {\n    return a.cost < cost;\n  }\n  // cells(int p, int q, int r, int s) {x(p), y(q), d(r), cost(s);}\n};\n\n\nint mp[MAX_N][MAX_N][4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n  cin.sync_with_stdio(false);\n\n  int w, h;\n  while(cin >> w >> h, w) {\n    priority_queue<cells> q;\n    rep(i, MAX_N)rep(j, MAX_N)rep(k, 4) mp[i][j][k] = 5;\n    repl(i, 1, h + 1)repl(j, 1, w + 1) {\n      cin >> mp[i][j][0];\n      mp[i][j][1] = mp[i][j][2] = mp[i][j][3] = mp[i][j][0];\n    }\n    int c[4] = {};\n    rep(i, 4) cin >> c[i];\n\n    q.push(cells{1, 1, 0, 0});\n    int ans = 0;\n    while(!q.empty()) {\n      cells p = q.top(); q.pop();\n      if(p.x == w && p.y == h) {\n        ans = p.cost;\n        break;\n      } else if (mp[p.y][p.x][p.d] < 5) {\n        rep(i, 4) {\n          if (mp[p.y + dy[i]][p.x + dx[i]][i] != 5) {\n            if ((i + 4 - p.d) % 4 == mp[p.y][p.x][p.d]) {\n              q.push(cells{p.x + dx[i], p.y + dy[i], i, p.cost});\n            } else {\n              q.push(cells{p.x + dx[i], p.y + dy[i], i, p.cost + c[(i + 4 - p.d) % 4]});\n            }\n          }\n        }\n        mp[p.y][p.x][p.d] = 5;\n      }\n    }\n\n    print(ans);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define Gr(y,x,compass) G[index(y,x,compass)]\nusing namespace std;\n\nconst int HMAX = 32, WMAX = 32, VMAX = 6 * HMAX * WMAX;\nconst int INF = 1e6;\n\nint w, h;\nint s[HMAX][WMAX];\nint c[4];\nvector<pair<int,int> > G[VMAX];\nint node_cost[VMAX];\n\nconst int NORTH=0, EAST=1, SOURTH=2, WEST=3;\n\nint left(int compass) { return (compass + 3) % 4; }\nint back(int compass) { return (compass + 2) % 4; }\nint right(int compass) { return (compass + 1) % 4; }\n\npair<int,int> step(int y, int x, int compass) {\n  int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n  return make_pair(y + dy[compass], x + dx[compass]);\n}\n\nbool in_field(int y, int x, int dir) {\n  pair<int,int> p = step(y,x,dir);\n  return  (0 <= p.first and p.first < h and\n           0 <= p.second and p.second < w);\n}\n\nint index(int y, int x, int compass) {\n  return compass * w * h + y * w + x;\n}\n\nconst int STRAIGHT=0, RIGHT=1, BACK=2, LEFT=3;\nint cost(int y, int x, int command) {\n  return (s[y][x] == command ? 0 : c[command]);\n}\n\nvoid calculate_cost() {\n  int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n  REP(compass, 4) REP(y,h) REP(x,w) {\n    int d = compass;\n    if (in_field(y,x,d)) {\n      Gr(y,x,compass).push_back(\n        make_pair(cost(y,x,STRAIGHT), index(y+dy[d],x+dx[d],d)));\n    }\n\n    d = left(compass);\n    if (in_field(y,x,d)) {\n      Gr(y,x,compass).push_back(\n        make_pair(cost(y,x,LEFT), index(y+dy[d],x+dx[d],d)));\n    }\n\n    d = back(compass);\n    if (in_field(y,x,d)) {\n      Gr(y,x,compass).push_back(\n        make_pair(cost(y,x,BACK), index(y+dy[d],x+dx[d],d)));\n    }\n\n    d = right(compass);\n    if (in_field(y,x,d)) {\n      Gr(y,x,compass).push_back(\n        make_pair(cost(y,x,RIGHT), index(y+dy[d],x+dx[d],d)));\n    }\n  }\n}\n\nint dijkstra() {\n  priority_queue<pair<int,int> > q;\n  q.push(make_pair(0,index(0,0,EAST)));\n  while (not q.empty()) {\n    pair<int,int> current = q.top(); q.pop();\n    int current_cost = current.first,\n        current_idx = current.second;\n    for (pair<int,int> p : G[current_idx]) {\n      int edge_cost = p.first, destination = p.second;\n/*      cout << current_idx << \"->\" << destination\n        << \"(\" << node_cost[destination] << \"vs.\" << current_cost\n        << \"+\" << edge_cost << \")\" << endl;*/\n      if (node_cost[destination] <= current_cost + edge_cost) \n        continue;\n\n      node_cost[destination] = current_cost + edge_cost;\n      q.push(make_pair(node_cost[destination], destination));\n    }\n  }\n  \n  int ans = INF;\n  REP(i, 4) {\n    ans = min(ans, node_cost[index(h-1,w-1,i)]);\n  }\n  return ans;\n}\n\nvoid init() {\n  REP(y, h) REP(x,w) REP(compass,4) {\n    node_cost[index(y,x,compass)] = INF;\n  }\n  REP(i, 4 * w * h) {\n    G[i].clear();\n  }\n}\n\nint main() {\n  while (cin >> w >> h and h) {\n    init();\n    REP(y,h) REP(x,w) { cin >> s[y][x]; }\n    REP(i,4) { cin >> c[i]; }\n  \n    calculate_cost();\n/*    REP(i, 4 * w * h) {\n      cout << \"G[\" << i << \"]=<\";\n      REP(j, G[i].size()) {\n          cout << \"(\" << G[i][j].first << \",\" << G[i][j].second \n            << \")\";\n      }\n      cout << \">\" << endl;\n    }*/\n    cout << dijkstra() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple < int, int, int , int > Tp; \ntypedef priority_queue < Tp, vector < Tp >, greater < Tp > > Que;\n\nint w, h;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nbool isover(int y, int x)\n{\n\treturn (y < 0 || y >= h || x < 0 || x >= w);\n}\n\nint edge[32][32];\nint vis[32][32][4];\nint c[32];\n\nint dijkstra()\n{\n\tQue que;\n\tfill_n(**vis, 32*32*4, 0);\n\t// cost, \n\tque.push(make_tuple(0, 0, 0, 0));\n\twhile(!que.empty()){\n\t\tTp top = que.top(); que.pop();\n\t\tint cost, y, x, dir;\n\t\ttie(cost, y, x, dir) = top;\n\t\tif (y == h-1 && x == w-1) return cost;\n\t\tif (vis[y][x][dir]++) continue;\n\t\t\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint ndir = (dir+i)%4;\n\t\t \tint ny = y + dy[ndir];\n\t\t \tint nx = x + dx[ndir];\n\t\t \t// cout << nx << \" \" << ny << endl;\n\t\t \tif (isover(ny, nx)) continue;\n\t\t \tint ncost = cost + (edge[y][x] == i ? 0 : c[i]);\n//\t\t \tif (min_cost[ny][nx] > ncost)\n//\t\t \t{\n\t\t \t\tque.push(make_tuple(ncost, ny, nx, ndir));\n//\t\t \t}\n\t\t } \n\t}\n\treturn -1;\n}\n\nint main(int argc, char const *argv[])\n{\n\twhile(cin >> w >> h && w){\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\t\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tcin >> edge[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tcout << dijkstra() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint x, y, d, cost;\n\tNode(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nchar dx[] = {0,1,0,-1};\nchar dy[] = {1,0,-1,0};\n\nint main(){\n\tint w, h;\n\tint op[4];\n\tint b[30][30];\n\tint c[30][30][4];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tmemset(c, -1, sizeof(c));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++) cin >> b[i][j];\n\t\t}\n\t\tfor(int i=0;i<4;i++) cin >> op[i];\n\t\tpriority_queue<Node> qu;\n\t\tqu.push(Node(0,0,0,0));\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint x = nd.x, y = nd.y, d = nd.d, cost = nd.cost;\n\t\t\tif(c[x][y][d]!=-1) continue;\n\t\t\tc[x][y][d] = cost;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(nx<0||nx>=h||ny<0||ny>=w) continue;\n\t\t\t\tif(b[x][y]!=4&&(b[x][y]+d)%4==i){\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost));\n\t\t\t\t} else {\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost+op[(4+i-d)%4]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 9999999;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(c[h-1][w-1][i]!=-1) ans = min(ans,c[h-1][w-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint w,h;\nint board[31][31];\nint c[4];\n\n// dir : ??? 0,??? 1,??? 2,??? 3\nP next(P p,int &dir,int cmd) {\n    if(cmd==1) {\n        dir++;\n    }\n    else if(cmd==2) {\n        dir+=2;\n    }\n    else if(cmd==3) {\n        dir--;\n    }\n\n    while(dir<0) dir+=4;\n    dir%=4;\n    p.fr+=dy[dir];\n    p.sc+=dx[dir];\n\n    return p;\n}\n\nint bfs() {\n    map<Pi,int> d;\n    queue<Pi> que;\n    que.push(Pi(P(0,0),0));\n    rep(y,h) rep(x,w) rep(k,4) d[Pi(P(y,x),k)]=INF;\n    d[Pi(P(0,0),0)]=0;\n    while(que.size()) {\n        Pi p=que.front();\n        que.pop();\n        int y=p.fr.fr;\n        int x=p.fr.sc;\n        int dir=p.sc;\n        int cmd=board[y][x];\n\n        //printf(\"[debug] %d,%d,%d : %d\\n\",y,x,dir,d[p]);\n        if(cmd!=4) {\n            Pi next_p={next(p.fr,dir,cmd),0};\n            next_p.sc=dir;\n\n            if(0<=next_p.fr.fr<h && 0<=next_p.fr.sc<w && d[next_p]>d[p]) {\n                d[next_p]=min(d[next_p],d[p]);\n                que.push(next_p);\n            }\n        }\n        rep(i,4) {\n            dir=p.sc;\n            Pi next_p={next(p.fr,dir,i),0};\n            next_p.sc=dir;\n            if(0<=next_p.fr.fr<h && 0<=next_p.fr.sc<w && d[next_p]>d[p]+c[i]) {\n                d[next_p]=min(d[next_p],d[p]+c[i]);\n                que.push(next_p);\n            }\n        }\n    }\n    int ret=INF;\n    rep(i,4) if(d.count(Pi(P(h-1,w-1),i))) {\n        //printf(\"%d %d\\n\",i,d[Pi(P(h-1,w-1),i)]);\n        ret=min(ret,d[Pi(P(h-1,w-1),i)]);\n    }\n\n    return ret;\n}\nvoid solve() {\n    rep(y,h) rep(x,w) cin>>board[y][x];\n    rep(i,4) cin>>c[i];\n    int ans=bfs();\n\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>w>>h) {\n        if(!w) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint w, h;\nint s[32][32];\nint cost[4];\n\n// dir\n// 0 : right\n// 1 : up\n// 2 : left\n// 3 : down\nconst int dr[4] = {0, -1, 0, 1};\nconst int dc[4] = {1, 0, -1, 0};\nconst int dd[4] = {0, 3, 2, 1};\n\ntypedef std::pair<int, int> Pii;\n\nclass Node {\npublic:\n  Node() {}\n  Node(int r_, int c_, int dir_) : r(r_), c(c_), dir(dir_) {}\n  int r, c, dir;\n};\n\nclass Data {\npublic:\n  Data() {}\n  Data(Node s_, Node t_, int cost_) : s(s_), t(t_), cost(cost_) {}\n  Node s, t;\n  int cost;\n};\n\ninline bool operator < (const Data& a, const Data& b) {\n  return a.cost > b.cost;\n}\n\nint dist[32][32][8];\nint dijkstra() {\n  std::priority_queue<Data> q;\n  int r = 0;\n  int c = 0;\n  int dir = 0;\n  dist[r][c][dir] = 0;\n  for(int k = 0; k < 4; ++k) {\n    int nd = (dir + dd[k]) % 4;\n    int nr = r + dr[nd];\n    int nc = c + dc[nd];\n    if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n    q.push(Data(Node(r, c, dir), Node(nr, nc, nd), dist[r][c][dir] + (k == s[r][c] ? 0 : cost[k])));\n  }\n  while( not q.empty() ) {\n    Data t = q.top(); q.pop();\n    int r = t.t.r, c = t.t.c, dir = t.t.dir;\n    if( dist[r][c][dir] <= t.cost ) continue;\n    dist[r][c][dir] = t.cost;\n    if( r == h - 1 and c == w - 1 ) continue;\n    for(int k = 0; k < 4; ++k) {\n      int nd = (dir + dd[k]) % 4;\n      int nr = r + dr[nd];\n      int nc = c + dc[nd];\n      if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n      q.push(Data(Node(r, c, dir), Node(nr, nc, nd), dist[r][c][dir] + (k == s[r][c] ? 0 : cost[k])));\n    }\n  }\n  int res = (1 << 30);\n  for(int i = 0; i < 4; ++i) {\n    res = std::min(res, dist[h-1][w-1][i]);\n  }\n  return res;\n}\n\nvoid Init() {\n  for(int i = 0; i < 32; ++i) {\n    for(int j = 0; j < 32; ++j) {\n      for(int k = 0; k < 4; ++k) {\n        dist[i][j][k] = (1 << 29);\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    Init();\n    scanf(\"%d %d\", &w, &h);\n    if( w == 0 and h == 0 ) break;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\"%d\", &s[i][j]);\n      }\n    }\n    for(int i = 0; i < 4; ++i) {\n      scanf(\"%d\", &cost[i]);\n    }\n    int res = dijkstra();\n    printf(\"%d\\n\", res);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXW = 31;\nconst int MAXH = 31;\nconst int INF = 1<<28;\nint W, H;\nint G[MAXH][MAXW];\nint C[4];\n\nstruct State {\n  int i, j, d, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint bfs() {\n  static int di[] = {0,1,0,-1};\n  static int dj[] = {1,0,-1,0};\n  priority_queue<State> que;\n  int cost[MAXH][MAXW][4];\n  que.push((State){0,0,0});\n  fill(cost[0][0], cost[MAXH][0], INF);\n  cost[0][0][0] = 0;\n  while(!que.empty()) {\n    const State s = que.top();\n    que.pop();\n    if(cost[s.i][s.j][s.d] < s.cost) continue;\n    if(s.i == H-1 && s.j == W-1) return s.cost;\n    for(int k = 0; k < 4; ++k) {\n      State t = s;\n      t.cost += ( G[s.i][s.j] == k ? 0 : C[k] );\n      t.d = (t.d + k) % 4;\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) continue;\n      if(t.j < 0 || t.j >= W) continue;\n      if(cost[t.i][t.j][t.d] > t.cost) {\n        que.push(t);\n        cost[t.i][t.j][t.d] = t.cost;\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    for(int i = 0; i < 4; ++i) cin >> C[i];\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\nusing ll = long long;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint dp[33][33][4];\nint W, H;\n\nvoid init() {\n    REP(i, H) {\n        REP(j, W) {\n            REP(k, 4) { dp[i][j][k] = 1e9; }\n        }\n    }\n    dp[0][0][0] = 0;\n}\n\nint A[55][55];\n\nusing arr4 = array<int, 4>;\nint C[5];\nbool solve() {\n    cin >> W >> H;\n    if (W == 0) return false;\n    init();\n    REP(i, H) {\n        REP(j, W) { cin >> A[i][j]; }\n    }\n    REP(i, 4) cin >> C[i];\n    priority_queue<arr4, vector<arr4>, greater<arr4>> que;\n    que.push({0, 0, 0, 0});\n    while (!que.empty()) {\n        arr4 ar = que.top();\n        que.pop();\n        int c = ar[0], x = ar[1], y = ar[2], dir = ar[3];\n        if (c > dp[x][y][dir]) continue;\n        if (A[x][y] != 4) {\n            int nx = x + dx[(dir + A[x][y]) % 4];\n            int ny = y + dy[(dir + A[x][y]) % 4];\n            if (nx < H && nx >= 0 && ny < W && ny >= 0) {\n                int nd = (dir + A[x][y]) % 4;\n                if (dp[nx][ny][nd] > dp[x][y][dir]) {\n                    dp[nx][ny][nd] = dp[x][y][dir];\n                    que.push({dp[nx][ny][nd], nx, ny, nd});\n                }\n            }\n        }\n        REP(i, 4) {\n            int nd = (dir + i) % 4;\n            int nx = x + dx[nd];\n            int ny = y + dy[nd];\n            if (nx < H && nx >= 0 && ny < W && ny >= 0) {\n                if (dp[nx][ny][nd] > dp[x][y][dir] + C[i]) {\n                    dp[nx][ny][nd] = dp[x][y][dir] + C[i];\n                    que.push({dp[nx][ny][nd], nx, ny, nd});\n                }\n            }\n        }\n        //\n    }\n    int ans = 1e9;\n    REP(i, 4) { ans = min(ans, dp[H - 1][W - 1][i]); }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint w, h;\nstruct edge { int to, cost; };\nint V;\nvector<edge> G[100000];\nint d[100000];\nvoid init() {\n\trep(i, V) {\n\t\tG[i].clear();\n\t}\n}\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + V, (int)MOD);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> w >> h, w) {\n        int d1[4] = { -(w+2),1,w+2,-1 };\n\t\tint c[4];\n\t\tinit();\n\t\tV = (h+2) * (w+2) * 4;\n\t\tint board[32][32];\n\t\trep(i, 32) {\n\t\t\trep(j, 32) {\n\t\t\t\tboard[i][j] = 5;\n\t\t\t}\n\t\t}\n\t\trep1(i, h) {\n\t\t\trep1(j, w) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i, 4) {\n\t\t\tcin >> c[i];\n\t\t}\n\t\tint uni = (h + 2)*(w + 2) * 4;\n\t\trep(i, h+2) {\n\t\t\trep(j, w+2) {\n\t\t\t\tif (board[i][j] == 5)continue;\n\t\t\t\t//kが今の向き\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint loc = k * (h + 2)*(w + 2) + i * (w + 2) + j;\n\t\t\t\t\t//直進とか\n\t\t\t\t\trep(dir, 4) {\n\t\t\t\t\t\tint cost = c[dir];\n\t\t\t\t\t\tif (dir == board[i][j])cost = 0;\n\t\t\t\t\t\tif (dir == 0) {\n\t\t\t\t\t\t\tG[loc].push_back({ loc + d1[k],cost });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dir == 1) {\n\t\t\t\t\t\t\tG[loc].push_back({ (loc + d1[(k + 1) % 4] + (h + 2)*(w + 2)) % uni,cost });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dir == 2) {\n\t\t\t\t\t\t\tG[loc].push_back({ (loc + d1[(k + 2) % 4] + 2*(h + 2)*(w + 2)) % uni,cost });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dir == 3) {\n\t\t\t\t\t\t\tG[loc].push_back({ (loc + d1[(k + 3) % 4] + 3*(h + 2)*(w + 2)) % uni,cost });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sta = w + 3 + (h + 2)*(w + 2);\n\t\tdijkstra(sta);\n\t\tint mi = (int)MOD;\n\t\tint goal = h * (w + 2) + w;\n\t\trep(i, 4) {\n\t\t\tmi = min(mi, d[goal + i * (h + 2)*(w + 2)]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int>  pii;\ntypedef pair<int, pii>  piii;//distinct, x, y\ntypedef pair<int ,piii> robot;//cost, piii\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(int argc, char *argv[]){\n  int w, h;\n  const int INF = 1e8;\n  while(cin >> w >> h, w){\n    int grid[h][w];\n    int dp[4][h][w];\n    int cost[4];//straight, right, back, left\n    for (int i = 0; i < 4; i++) {\n      for (int j = 0; j < h; j++) {\n        for (int k = 0; k < w; k++) {\n          dp[i][j][k] = INF;\n        }\n      }      \n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n      }\n    }\n    for (int i = 0; i < 4; i++) {\n      cin >> cost[i];\n    }\n      \n    priority_queue<robot, vector<robot>, greater<robot> > que;\n    dp[0][0][0] = 0;\n    que.push(mp(dp[0][0][0], mp(0, mp(0,0))));\n\n    while(!que.empty()){\n      robot r = que.top();que.pop();\n      int x, y, dist, c;\n      x    = r.second.second.first;\n      y    = r.second.second.second;\n      dist = r.second.first;\n      c    = r.first;\n      // std::cout << \"dist:\" << dist << std::endl;\n      // std::cout << \"   x:\" << x    << std::endl;\n      // std::cout << \"   y:\" << y    << std::endl;\n      // std::cout << \"cost:\" << c    << std::endl;\n      \n      for (int i = 0; i < 4; i++) {\n        int nd = (dist + i)%4, nc = c + cost[i];\n        int nx = x + dx[nd], ny = y + dy[nd];\n        if(grid[y][x] == i)nc -= cost[i];\n        if(0 <= nx && nx < w &&\n           0 <= ny && ny < h &&\n           nc < dp[nd][ny][nx]){\n          dp[nd][ny][nx] = nc;\n          que.push(mp(nc, mp(nd, mp(nx, ny))));\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < 4; i++) {\n      ans = min(ans, dp[i][h - 1][w - 1]);\n    }\n    // for (int i = 0; i < 4; i++) {\n    //   std::cout << \"i:\" << i << std::endl;\n    //   for (int j = 0; j < h; j++) {\n    //     for (int k = 0; k < w; k++) {\n    //       if(dp[i][j][k] == INF)\n    //         std::cout << \"INF\" << \" \";\n    //       else printf(\"%3d \", dp[i][j][k]);\n    //     }\n    //     std::cout << std::endl;\n    //   }\n    // }\n    \n    std::cout << ans << std::endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1156\n// Twirling Robot\n//\n\n#include<iostream>\n#include<vector>\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX_W_H 30\n#define INF 1000000\nusing namespace std;\n\n// ??????:[0] = E, [1] = S, [2] = W, [3] = N\n// ??????:[0] = Straight, [1] = Right, [2] = Back, [3] = Left\nint f[4][4] = {{0, 1, 2, 3}, {3, 0, 1, 2}, {2, 3, 0, 1}, {1, 2, 3, 0}}; // [?¬???????????????????][???????????????????????????] = ???????????????\n\n// ??????(i, j, k) == ???????????????(j, i)??????????????????????????????k????????????????????¶???\n\nint w, h;\nint map[MAX_W_H][MAX_W_H];\nint d[MAX_W_H][MAX_W_H][4];\t// ??????(0, 0, 0)?????????????°??????????\nint instr_cost[4];\t\t// ?????????????????????\nbool used[MAX_W_H][MAX_W_H][4];\t// ?????§?????????????????????????????°\n\nbool in_map(int x, int y)\n{\n  return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nvoid dijkstra(void)\t\t// ??????(0, 0)?????????????????????????°???????????±???????\n{\n  int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; // [0]=E, [1]=S, [2]=W, [3]=N\n  while(true)\n    {\n      int x = -1, y = -1, di = -1;\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++) // ???????????????????????? and ?§?????????????????????????????°??????? == ???????????¢????¢????????????????\n\t  for(int k = 0; k < 4; k++)\n\t    if(!used[i][j][k] && ((x == -1 && y == -1 && di == -1) || (d[i][j][k] < d[y][x][di])))\n\t      x = j, y = i, di = k;\n\n      if(x == -1 && y == -1 && di == -1)\n\tbreak;\n\n      used[y][x][di] = true;\n\n      // ??????(x, y, d)??¨??£??\\???????????????\"?§??????????????????¢\"?????´??°\n      for(int i = 0; i < 4; i++)\n\t{\n\t  int xx = x + dir[i][0];\n\t  int yy = y + dir[i][1];\n\t  int c;\n\t  if(!in_map(xx, yy))\n\t    continue;\n\n\t  int inst = f[di][i]; // d = ??????(x, y)????????????????????????, i = ??????(x, y)??????????????????(xx, yy)?????????, inst = ?§??????????????????????\n\t  if(inst == map[y][x])\n\t    c = 0;\n\t  else\n\t    c = instr_cost[inst];\n\n\t  if(d[yy][xx][i] > d[y][x][di] + c)\n\t    d[yy][xx][i] = d[y][x][di] + c;\n\t}\n    }\n}\n\nint main(void)\n{\n  int ans = INF;\n  while(cin >> w >> h, (w && h))\n    {\n      for(int i = 0; i < MAX_W_H; i++)\n\tfor(int j = 0; j < MAX_W_H; j++)\n\t  for(int k = 0; k < 4; k++)\n\t    {\n\t      d[i][j][k] = INF;\n\t      used[i][j][k] = false;\n\t    }\n\n\n      d[0][0][0] = 0;\n\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  cin >> map[i][j];\n\n      for(int i = 0; i < 4; i++)\n\tcin >> instr_cost[i];\n\n      dijkstra();\n\n\n      for(int i = 0; i < 4; i++)\n\tans = min(ans, d[h - 1][w - 1][i]);\n\n      cout << ans << endl;\n\n      ans = INF;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n  int w,h;\n  for(;cin>>w>>h,w;)\n    {\n      int maps[h][w];\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t  }\n      int c[4];\n      for(int i=0;i<4;i++)\n\tcin>>c[i];\n\n      //cost,move,now;\n      priority_queue<pair<pair<int,int>,pair<int,int> > > qu;\n      qu.push(make_pair(make_pair(0,0),make_pair(0,0)));\n      \n      pair<int,int> goal=make_pair(h-1,w-1);\n      int dx[]={0,1,0,-1};\n      int dy[]={1,0,-1,0};\n      bool closed[4][h][w];\n      memset(closed,false,sizeof(closed));\n      while(!qu.empty())\n\t{\n\t  int cost=-qu.top().first.first;\n\t  int move=qu.top().first.second;\n\t  pair<int,int> now=qu.top().second;\n\t  qu.pop();\n\t  if(now==goal)\n\t    {\n\t      cout<<cost<<endl;\n\t      break;\n\t    }\n\t  int x=now.first;\n\t  int y=now.second;\n\t  //  cout<<cost<<\" \"<<move<<\" <\"<<x<<\",\"<<y<<\">\"<<endl;\n\t  if(closed[move][x][y])\n\t    continue;\n\t  closed[move][x][y]=true;\n\t  \n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int add=0;\n\t      if(maps[x][y]!=i)\n\t\tadd=c[i];\n\t      if(x+dx[move]>=0 && x+dx[move]<h &&\n\t\t y+dy[move]>=0 && y+dy[move]<w &&\n\t\t !closed[move][x+dx[move]][y+dy[move]])\n\t\tqu.push(make_pair(make_pair(-(cost+add),move),\n\t\t\t\t  make_pair(x+dx[move],y+dy[move])));\n\t      move=(move+1)%4;\n\t    }\n\t}\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct State{\n  int x,y,t,dir;\n  State(int a, int b, int c, int d):x(a),y(b),t(c),dir(d){}\n  bool operator < (const State& s) const{\n    return t > s.t;\n  }\n};\nconst int MAX = 31;\nconst int INF = (1<<25);\nint M[MAX][MAX],h,w;\nint cost[4],T[4][MAX][MAX];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nbool isInside(int x, int y){return 0<=x&&x<w&&0<=y&&y<h;}\n\n\nvoid init(){\n  for(int i = 0; i < 4; i++)\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n}\n\nvoid input(){\n\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++) cin >> M[i][j];\n\n  for(int i = 0; i < 4; i++) cin >> cost[i];\n}\n\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(0,0,0,0));\n  T[0][0][0] = 0;\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.dir][s.y][s.x] < s.t) continue;\n\n    //obey\n    if(M[s.y][s.x] != 4){\n      State tmp = s;\n      tmp.dir = (tmp.dir+M[tmp.y][tmp.x])%4;\n      tmp.x += dx[tmp.dir];\n      tmp.y += dy[tmp.dir];\n      if(isInside(tmp.x,tmp.y) && T[tmp.dir][tmp.y][tmp.x] > tmp.t){\n\tT[tmp.dir][tmp.y][tmp.x] = tmp.t;\n\tQ.push(tmp);\n      }\n    }\n    //order\n    for(int i = 0; i < 4; i++){\n      State tmp = s;\n      tmp.dir = (tmp.dir+i)%4;\n      tmp.t += cost[i];\n      tmp.x += dx[tmp.dir];\n      tmp.y += dy[tmp.dir];\n      if(isInside(tmp.x,tmp.y) && T[tmp.dir][tmp.y][tmp.x] > tmp.t){\n\tT[tmp.dir][tmp.y][tmp.x] = tmp.t;\n\tQ.push(tmp);\n      }\n    }\n  }\n\n  int ans = INF;\n  for(int i = 0; i < 4; i++)\n    ans = min(ans,T[i][h-1][w-1]);\n  cout << ans << endl;\n}    \n\nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\n// int dx[4]={1,0,-1,0};\n// int dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\n// bool debug=false;\n\n/*---------------------------------------------------*/\n\n// 右, 下, 左, 上(時計回り)\nconst int dx[4]={1,  0, -1,  0};\nconst int dy[4]={0,  1,  0, -1};\nconst int INF = 10000000;\n\nint W, H;\nint s[55][55];\nint c[55];\nint dist[55][55][4];\n\nstruct State {\n  int x;\n  int y;\n  int cost;\n  int direct;\n\n  bool operator<(const State &state) const {\n    return cost < state.cost;//年齢を比較\n  };\n\n  bool operator>(const State &state) const {\n    return cost > state.cost;//年齢を比較\n  };\n};\n\ninline bool inArea(int x, int y, int W, int H) {\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init(){\n  for(int i = 0; i < 55; i++) {\n    for(int j = 0; j < 55; j++) {\n      for(int k = 0; k < 4; k++) {\n\tdist[i][j][k] = INF;\n      }\n    }\n  }\n}\n\nvoid dijkstra() {\n  init();\n  priority_queue<State, vector<State>, greater<State>> que;\n  que.push({0, 0, 0, 0});\n  while(que.size()) {\n    State state = que.top(); que.pop();\n    int x = state.x, y = state.y, cost = state.cost, direct = state.direct;\n    for(int i = 0; i < 4; i++) {\n      int next_direct = (direct + i) % 4;\n      int nx = x + dx[next_direct], ny = y + dy[next_direct];\n      if(!inArea(nx, ny, W, H)) continue;\n      if(i == s[y][x]) {\n\tif(cost < dist[ny][nx][next_direct]) {\n\t  dist[ny][nx][next_direct] = cost;\n\t  que.push({nx, ny, cost, next_direct});\n\t}\n      } else {\n\tif(cost + c[i] < dist[ny][nx][next_direct]) {\n\t  dist[ny][nx][next_direct] = cost + c[i];\n\t  que.push({nx, ny, cost + c[i], next_direct});\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H) {\n    if(W == 0 && H == 0) break;\n    for(int i = 0;  i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcin >> s[i][j];\n      }\n    }\n    for(int i = 0; i < 4; i++) {\n      cin >> c[i];\n    }\n\n    dijkstra();\n\n    int ans = INF;\n    for(int i = 0; i < 4; i++) {\n      ans = min(ans, dist[H - 1][W - 1][i]);\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 10000000;\nconst int MAX_W = 30;\nconst int MAX_H = 30;\nconst int MAX_V = MAX_W * MAX_H * 4;\n\nint field[MAX_H][MAX_W];\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\n// 入力\nint w, h;\nint c[4];\n\nvoid dijkstra(int s) {\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[s] = 0;\n\t\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v])) {\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nvoid solve() {\n\tfor (int i = 0; i < V; i++) {\n\t\tint place = i / 4;\n\t\tint placex = place % w;\n\t\tint placey = place / w;\n\t\tint direction = i % 4;\n\t\t//int nextS = i + next(direction, 0);\n\t\t//int nextR = i + next(direction, 1);\n\t\t//int nextU = i + next(direction, 2);\n\t\t//int nextL = i + next(direction, 3);\n\t\t// 向きと次に進む方向で場合分け\n\t\tswitch (direction) {\n\t\tcase 0: // 右向きの場合\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i+4] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4] = c[0];\n\t\t\t}\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i+4*w+1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w+1] = c[1];\n\t\t\t}\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i-4+2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4+2] = c[2];\n\t\t\t}\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i-4*w+3] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w+3] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: // 下向きの場合\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i+4*w] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w] = c[0];\n\t\t\t}\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i-4+1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4+1] = c[1];\n\t\t\t}\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i-4*w+2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w+2] = c[2];\n\t\t\t}\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i+4-1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4-1] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // 左向きの場合\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i-4] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4] = c[0];\n\t\t\t}\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i-4*w+1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w+1] = c[1];\n\t\t\t}\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i+4-2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4-2] = c[2];\n\t\t\t}\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i+4*w-1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w-1] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: // 上向きの場合\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i-4*w] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w] = c[0];\n\t\t\t}\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i+4-3] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4-3] = c[1];\n\t\t\t}\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i+4*w+2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w+2] = c[2];\n\t\t\t}\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i-4-1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4-1] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tdijkstra(0);\n\tint ans = min(d[4*(w*h-1)], d[4*(w*h-1)+1]);\n\tcout << ans << endl;\n\t\n\treturn;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tV = w * h * 4;\n\t\t\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\t\tfor (int i = 0; i < MAX_V; i++) {\n\t\t\tfill(cost[i], cost[i] + MAX_V, INF);\n\t\t\tcost[i][i] = 0;\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n\nusing namespace std;\n\nconst int inf = 1 << 30;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nclass Edge {\npublic:\n  int cost;\n  int nextx;\n  int nexty;\n  int direction;\n  Edge (int c, int x, int y, int d):cost(c), nextx(x), nexty(y), direction(d) {}\n};\n\nbool operator> (Edge e1, Edge e2) {\n  return (e1.cost > e2.cost);\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w + h) {\n    vector<vector<int>> s(h, vector<int>(w));\n    int c[4];    \n    REP (i, 0, h) REP (j, 0, w) cin >> s[i][j];\n    REP (i, 0, 4) cin >> c[i];\n    priority_queue<Edge, vector<Edge>, greater<Edge> > edge;\n    vector<vector<vector<int>>> memo(4, vector<vector<int>>(h, vector<int>(w, inf)));\n    vector<vector<vector<int>>> isAccess(4, vector<vector<int>>(h, vector<int>(w, 0)));\n    edge.emplace(0, 0, 0, 0);\n    \n    while (edge.size()) {\n      Edge e = edge.top();\n      edge.pop();\n      int x = e.nextx;\n      int y = e.nexty;\n      int d = e.direction;\n      if (isAccess[d][y][x]) continue;\n      isAccess[d][y][x] = 1;\n      REP (k, 0, 4) {\n\tint nextd = (d + k) % 4;\n\tint nextx = x + dx[nextd];\n\tint nexty = y + dy[nextd];\n\n\tif (nextx < 0 || nextx >= w || nexty < 0 || nexty >= h) continue;\n\tint cost = (k == s[y][x] ? 0 : c[k]) + e.cost;\n\tif (memo[nextd][nexty][nextx] > cost) {\n\t  edge.emplace(cost, nextx, nexty, nextd);\n\t  memo[nextd][nexty][nextx] = cost;\n\t}\n      }      \n    }\n    \n    int min_ = inf;\n    REP (i, 0, 4) min_ = min(min_, memo[i][h - 1][w - 1]);\n    cout << min_ << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a>b?b:a)\n\nint dx[8] = {1,0,-1,0,1,0,-1,0};\nint dy[8] = {0,1,0,-1,0,1,0,-1};\n\nint main() {\n\tint map[M+2][M+2], c[4], w, h;\n\tint dp[M+2][M+2][M*M+1][4], ans;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tcin >> map[i][j];\n\t\t\t\t\tfor(int t=0; t<=w*h; ++t) {\n\t\t\t\t\t\tfor(int k=0; k<4; ++k) dp[i][j][t][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\tdp[1][1][0][0] = 0; ans = INF;\n\t\tfor(int t=1; t<=w*h; ++t) {\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tif(i==h&&j==w) continue;\n\t\t\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\t\t\tfor(int l=0; l<4; ++l) {\n\t\t\t\t\t\t\tint d = k+l;\n\t\t\t\t\t\t\tif(map[i][j]==l) {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]+c[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j+dx[d]==w&&i+dy[d]==h&&(d==0||d==1)) {\n\t\t\t\t\t\t\t\tans = min(ans, dp[i+dy[d]][j+dx[d]][t][d]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\n#define INF INT_MAX>>1 //要climits#includ\n\nusing namespace std;\n\ntypedef long long ll;\n\nint dx[] ={0, 1, 0, -1};\nint dy[] ={-1, 0, 1, 0};\n\ntypedef struct robot{\n\tint x;\n\tint y;\n\tint dir;\n\tint cost;\n}robot;\n\nint main() {\n\twhile(1) {\n\t\tint w, h; cin >> w >> h;\n\t\tif(!w && !h) break;\n\n\t\tint s[30][30];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tfor(int i=0; i<4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tint dp[30][30][4];\n\t\tfill(dp[0][0], dp[30][0], INF);\n\t\tdp[0][0][1] = 0;\n\t\trobot initial ={0, 0, 1, 0};\n\t\tqueue<robot> q;\n\t\tq.push(initial);\n\n\t\twhile(!q.empty()) {\n\t\t\trobot prev = q.front(); \n\t\t\tq.pop();\n\t\t\tif(prev.cost > dp[prev.y][prev.x][prev.dir]) continue;\n\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\trobot next;\n\t\t\t\tnext.dir = (prev.dir + i) % 4;\n\t\t\t\tnext.cost = prev.cost;\n\t\t\t\tif(s[prev.y][prev.x] != i) next.cost += c[i];\n\t\t\t\tnext.y = prev.y + dy[next.dir];\n\t\t\t\tnext.x = prev.x + dx[next.dir];\n\t\t\t\tif(next.y < 0 || h <= next.y || next.x < 0 || w <= next.x) continue;\n\t\t\t\tif(dp[next.y][next.x][next.dir] > next.cost) {\n\t\t\t\t\tdp[next.y][next.x][next.dir] = next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tans = min(ans, dp[h - 1][w - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <queue>\n#include <functional>\n#include <cstring>\nint field[30][30] = { 0 };\nint m[4][30][30]; //[??????][y][x] = ????°??????????\nint costs[4] = { 0 };\nint dx[] = { 1, 0, -1, 0, 1, 0, -1, 0 }, dy[] = {0, 1, 0, -1, 0, 1, 0, -1 };\n\nstruct Node{\n\tint x, y, cost = 0, d;\n\tbool operator < (const Node& rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n\tbool operator < (Node&& rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n\tbool operator > (const Node& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n\tbool operator > (Node&& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile (std::cin >> w >> h && (w || h)) {\n\t\tstd::memset(m, 0x7f, sizeof(int) * 4 * 30 * 30);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tstd::cin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) std::cin >> costs[i];\n\n\t\tstd::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n\t\tq.push({0, 0, 0, 0});\n\t\tbool isOk = false;\n\t\tint minCost = INT_MAX;\n\t\twhile (!q.empty() && !isOk) {\n\t\t\tNode node = q.top(); q.pop();\n\t\t\tif (node.x == w - 1 && node.y == h - 1) {\n\t\t\t\tisOk = true;\n\t\t\t\tminCost = node.cost;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tNode next = node;\n\t\t\t\tif (i == 1) next.d++;\n\t\t\t\telse if (i == 2) next.d += 2;\n\t\t\t\telse if (i == 3) next.d--;\n\t\t\t\tif (next.d < 0) next.d = 4 + next.d;\n\t\t\t\telse if (next.d >= 4) next.d = next.d - 4;\n\n\t\t\t\tnext.x += dx[next.d];\n\t\t\t\tnext.y += dy[next.d];\n\t\t\t\tif (field[node.y][node.x] != i) next.cost += costs[i];\n\n\t\t\t\tif (next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\tif (m[next.d][next.y][next.x] <= next.cost) continue;\n\t\t\t\tm[next.d][next.y][next.x] = next.cost;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tstd::cout << minCost << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//SPFA\n#include <cstdio>\n#include <cstring>\n#include<queue>\nusing namespace std;\n#define INF (10*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nbool in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nint main(){\n\tqueue<Node> que;\n\tbool inQ[30][30][4];\n\tint dst[30][30][4];\n\tNode a,b;\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,false,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\twhile(!que.empty())que.pop();\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque.push(a);\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tinQ[a.y][a.x][a.dir]=false;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(!inQ[b.y][b.x][b.dir]){\n\t\t\t\t\tque.push(b);\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(!inQ[b.y][b.x][b.dir]){\n\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",*min_element(dst[h-1][w-1],dst[h-1][w-1]+4));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<ll, ll>P;\ntypedef pair<P, P>PP;\n\n\nll dy[5] = {0, 1, 0, -1, 0};\nll dx[5] = {1, 0, -1, 0, 0};\nll change[5][5] = {\n    {0, 1, 2, 3, 4},\n    {1, 2, 3, 0, 4},\n    {2, 3, 0, 1, 4},\n    {3, 0, 1, 2, 4},\n    {4, 4, 4, 4, 4}\n};\n\nll mp[33][33];\nll mn[33][33][5];\nll c[5];\nvoid init(){\n    for(ll y = 0; y < 33; y++){\n        for(ll x = 0; x < 33; x++){\n            mp[y][x] = -1;\n            for(ll i = 0; i < 5; i++){\n                mn[y][x][i] = -1145141919;\n            }\n        }\n    }\n\n}\n\nint main(){\n    \n    for(ll w, h; cin >> w >> h, w;){\n        init();\n        for(ll y = 1; y <= h; y++){\n            for(ll x = 1; x <= w; x++){\n                cin >> mp[y][x];\n                for(ll i = 0; i < 5; i++){\n                    mn[y][x][i] = 1145141919;\n                }\n            }\n        }\n        for(ll i = 0; i < 4; i++)cin >> c[i];\n        priority_queue<PP, vector<PP>, greater<PP> >Q;\n        Q.push(PP(P(0, 1), P(1, 0)));\n        while(!Q.empty()){\n            ll cost = Q.top().first.first;\n            ll x = Q.top().first.second;\n            ll y = Q.top().second.first;\n            ll d = Q.top().second.second;\n            Q.pop();\n            if(mp[y][x] == -1)continue;\n            if(mn[y][x][d] <= cost)continue;\n            mn[y][x][d] = cost;            \n            if(y == h && x == w){\n                cout << cost << endl;\n                break;\n            }\n            for(ll i = 0; i < 4; i++){\n                ll nxtC = cost;\n                if(mp[y][x] != i)nxtC += c[i];\n                ll dd = change[d][i];\n                ll yy = y + dy[dd];\n                ll xx = x + dx[dd];\n                if(mn[yy][xx][dd] > nxtC){\n                    Q.push(PP(P(nxtC, xx), P(yy, dd)));\n                }\n            }\n        }\n    }\n    \n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>istream &operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\n//template <typename T, typename S>ostream &operator<<(ostream &os, pair<T, S> &p) {os << p.first << \" \" << p.second;return os;}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T, class U>bool chmin(T& a, U b) { if (a > b) { a = b; return true; }return false; }\ntemplate <class T, class U>bool chmax(T& a, U b) { if (a < b) { a = b; return true; }return false; }\n\nvoid solve(int W, int H) {\n\tvector<vector<int>>s(H, vector<int>(W));\n\trep(i, 0, H)rep(j, 0, W) { cin >> s[i][j]; }\n\tauto inrange = [&](int x, int y) { return 0 <= x and x < H and 0 <= y and y < W; };\n\tvector<int>c(4); rep(i, 0, 4) { cin >> c[i]; }\n\n\tvector<vector<vector<int>>>dist(H, vector<vector<int>>(W, vector<int>(4, INF)));\n\tconst int dx4[4] = { 1, 0, -1, 0 }, dy4[4] = { 0, 1, 0, -1 };\n\tdist[0][0][0] = 0;\n\tusing State = tuple<int, int, int, int>;// cost, h,w,dir\n\tpriority_queue < State, vector<State>, greater<State >> pq;\n\tpq.emplace(0, 0, 0, 0);\n\twhile (pq.size()) {\n\t\tint cost, h, w, dir;\n\t\ttie(cost, h, w, dir) = pq.top(); pq.pop();\n\t\tif (cost > dist[h][w][dir])continue;\n\t\tdump(cost, h, w, dir);\n\t\trep(i, 0, c.size()) {\n\t\t\tint a = (s[h][w] != i)*c[i];\n\t\t\tint nd = (dir + i + 4) % 4;\n\t\t\tdump(i, nd);\n\t\t\tint x = w + dx4[nd], y = h + dy4[nd];\n\t\t\tif (not inrange(y, x))continue;\n\t\t\tif (chmin(dist[y][x][nd], cost + a)) {\n\t\t\t\t//printf(\"(%d,%d,%d) -> (%d,%d,%d)\\n\", h, w, dir, y, x, nd);\n\t\t\t\tpq.emplace(cost + a, y, x, nd);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 0, 4) {\n\t\tchmin(ans, dist[H - 1][W - 1][i]);\n\t}\n\tcout << ans << endl;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\twhile (1) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 and H == 0)break;\n\t\tsolve(W, H);\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 99999999\n#define eps 1e-9\n\nint main(){\n    int w,h;\n    while(cin>>w>>h&&w&&h){\n        int data[40][40]={};\n        rep(i,h) rep(j,w) cin>>data[i][j];\n        int c[5];\n        rep(i,4)cin>>c[i];\n        \n        int d[40][40][4];\n        bool used[40][40][4];\n        rep(i,40)rep(j,40)rep(k,4){d[i][j][k]=INF;used[i][j][k]=false;}\n        \n        d[0][0][0]=0;\n        \n        int dy[]={0,1,0,-1};\n        int dx[]={1,0,-1,0};\n        while(1){\n            int vx=-1,vy=-1,dir=-1;\n            rep(i,h){\n                rep(j,w){\n                    rep(k,4){\n                        if(!used[i][j][k]&&(vx==-1||d[i][j][k]<d[vy][vx][dir]))vy=i,vx=j,dir=k;\n                    }\n                }\n            }\n\n            if(vy==-1)break;\n            used[vy][vx][dir]=true;\n            if(data[vy][vx]!=4){\n                int ddy=vy+dy[(dir+data[vy][vx])%4],ddx=vx+dx[(dir+data[vy][vx])%4];\n                if(ddy<h && ddx<w && ddx>=0 && ddy>=0){\n                    d[ddy][ddx][(dir+data[vy][vx])%4]=min(d[vy][vx][dir],d[ddy][ddx][(dir+data[vy][vx])%4]);\n                }\n            }\n            rep(i,4){\n                int ddy=vy+dy[(dir+i)%4],ddx=vx+dx[(dir+i)%4];\n                if(ddy<h && ddx<w && ddx>=0 && ddy>=0){\n                    d[ddy][ddx][(dir+i)%4]=min(d[vy][vx][dir]+c[i],d[ddy][ddx][(dir+i)%4]);\n                }\n            }\n        }\n        int ans=INF;\n        rep(i,4)ans=min(d[h-1][w-1][i],ans);\n        cout<<ans<<endl;   \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int H, W;\n    while (cin >> W >> H, H | W)\n    {\n        vector<vector<int>> order(H, vector<int>(W));\n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n                cin >> order[i][j];\n        }\n        vector<int> C(4);\n        for (int i = 0; i < 4; i++)\n            cin >> C[i];\n\n        vector<vector<vector<int>>> dp(H, vector<vector<int>>(W, vector<int>(5, 1e9)));\n        dp[0][0][0] = 0;\n        // →0,↓1,←2,↑3,停止4\n        using tp = tuple<int, int, int>;\n        priority_queue<pair<int, tp>, vector<pair<int, tp>>, greater<pair<int, tp>>> que;\n        que.push(make_pair(0, make_tuple(0, 0, 0)));\n        while (!que.empty())\n        {\n            auto s = que.top();\n            que.pop();\n            int d = s.first;\n            int x = get<0>(s.second);\n            int y = get<1>(s.second);\n            int dir = get<2>(s.second);\n            for (int i = 0; i < 4; i++)\n            {\n                int c = 0;\n                if (order[y][x] != i)\n                {\n                    c = C[i];\n                }\n                int ndir = (dir + i) % 4;\n                if (ndir == 0)\n                {\n                    if (x + 1 < W && dp[y][x + 1][ndir] > dp[y][x][dir] + c)\n                    {\n                        dp[y][x + 1][ndir] = dp[y][x][dir] + c;\n                        que.push(make_pair(dp[y][x + 1][ndir], make_tuple(x + 1, y, ndir)));\n                    }\n                }\n                else if (ndir == 1)\n                {\n                    if (y + 1 < H && dp[y + 1][x][ndir] > dp[y][x][dir] + c)\n                    {\n                        dp[y + 1][x][ndir] = dp[y][x][dir] + c;\n                        que.push(make_pair(dp[y + 1][x][ndir], make_tuple(x, y + 1, ndir)));\n                    }\n                }\n                else if (ndir == 2)\n                {\n                    if (x - 1 >= 0 && dp[y][x - 1][ndir] > dp[y][x][dir] + c)\n                    {\n                        dp[y][x - 1][ndir] = dp[y][x][dir] + c;\n                        que.push(make_pair(dp[y][x - 1][ndir], make_tuple(x - 1, y, ndir)));\n                    }\n                }\n                else if (ndir == 3)\n                {\n                    if (y - 1 >= 0 && dp[y - 1][x][ndir] > dp[y][x][dir] + c)\n                    {\n                        dp[y - 1][x][ndir] = dp[y][x][dir] + c;\n                        que.push(make_pair(dp[y - 1][x][ndir], make_tuple(x, y - 1, ndir)));\n                    }\n                }\n            }\n        }\n        // for (int k = 0; k < 4; k++)\n        // {\n        //     for (int i = 0; i < H; i++)\n        //     {\n        //         for (int j = 0; j < W; j++)\n        //         {\n        //             cout << dp[i][j][k] << ' ';\n        //         }\n        //         cout << endl;\n        //     }\n        //     cout << endl;\n        // }\n\n        int res = 1e9;\n\n        for (int i = 0; i < 4; i++)\n        {\n            res = min(res, dp[H - 1][W - 1][i]);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[31][31];\nint memo[4][31][31];\nint memo2[31][31];\nint c[4];\nint ans;\nint cnt;\nstring str = \">v<^\";\n\nvoid saiki(int x,int y,int dir,int cost) {\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,1,0,-1};\n\n  \n  if(x == w-1 && y == h-1 && ans > cost) ans = cost;\n  else if(memo[dir%4][y][x]>cost && ans > cost){\n    memo[dir%4][y][x] = cost;\n    cnt++;\n    \n    //    cout << str[dir%4];\n    //  cout <<\" \"<< x <<\" \" << y <<\" cost=\"<<cost<<endl\n    \n    for(int i=0;i<4;i++){\n      int ii = (i+dir%4)%4;\n      int nx = x + dx[ii];\n      int ny = y + dy[ii]; \n      if(nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n      if(i == mp[y][x]) {\n\tsaiki(nx,ny,(dir+i),cost);\n      }\n      else\n      saiki(nx,ny,(dir+i),cost+c[i]);\n      \n    }\n  }\n}\n\nint main() {\n  \n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> mp[i][j];\n\n\n    for(int i=0;i<4;i++)cin >> c[i];\n\n\n\n    for(int i=0;i<4;i++)\n      for(int j=0;j<31;j++)\n\tfor(int k=0;k<31;k++)\n\t  memo[i][j][k] = 1000000000;\n\n    ans = 1000000000;\n    cnt = 0;\n    saiki(0,0,0,0);\n\n    cout << ans<< endl;\n    //  cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n2017_02_25_AC\n??????????????????\n?????????????????§????????°???????????¨????????????????????§??\\??±??????????????¨\n???dfs()???????????§grid[y][x]?????¨???return?????????????????¨???\n??????????????????????????????????¬????????????????????????¨?????§??????????????£???????????????\n????????????\n???memset(dp, INF, sizeof(dp));??§?????????????????±\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nconst int INF = 1000000000;\nint w, h, cost[4], grid[35][35], dp[35][35][4];\n\nvoid dfs(int y, int x, int dir, int currentcost){\n  if(!CH(y,0,h) || !CH(x,0,w)) return;\n  if(dp[y][x][dir] <= currentcost) return;\n  dp[y][x][dir] = currentcost;\n  if((x == w-1 && y == h-1)/* || grid[y][x] == 4*/) return;\n  REP(k,0,5){\n    if(k == 0){ //????????????\n      int d = grid[y][x];\n      if(d == 4) continue;//grid[y][x]==4 (halt) ??????????????????\n      dfs(y + dy[(dir + d) % 4], x + dx[(dir + d) % 4], (dir + d) % 4, currentcost);\n    }else{  //???????????????tk: 0 ~ 3????????????4(halt)???????????????\n      int tk = k - 1; //k=0??????????????????????????????????????????????????´??????\n      if(tk == grid[y][x]) continue;\n      dfs(y + dy[(dir + tk) % 4], x + dx[(dir + tk) % 4], (dir + tk) % 4, currentcost + cost[tk]);\n    }\n  }\n  return;\n}\n\nint main() {\n\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    REP(i,0,h){\n      REP(j,0,w){\n        cin>>grid[i][j];\n      }\n    }\n    REP(k,0,4) cin>>cost[k];\n    //memset(dp, INF, sizeof(dp));\n    REP(i,0,h)REP(j,0,w)REP(k,0,4) dp[i][j][k] = INF;\n\n    dfs(0, 0, 0, 0);\n\n    cout<<*min_element(dp[h-1][w-1], dp[h-1][w-1]+4)<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define N 30\n#define INF 10000\nint w, h;\nint s[N][N];\nint c[4];\n\nstruct point{\n    int x, y;\n};\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[N][N][4];\n    int used[N][N][4];\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 4; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    \n    d[0][0][0] = 0;\n    \n    while (true) {\n        int p;\n        point v;\n        v.x = -1; v.y = -1;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 4; k++) {\n                    if (!used[i][j][k] && ((v.x == -1 && v.y == -1) || d[i][j][k] < d[v.y][v.x][p])) {\n                        v.y = i; v.x = j; p = k;\n                    }\n                }\n            }\n        }\n        \n        if (v.x == -1 && v.y == -1) {\n            break;\n        }\n        \n        used[v.y][v.x][p] = true;\n\n        for (int i = 0; i < 4; i++) {\n            int mx = v.x + dx[i];\n            int my = v.y + dy[i];\n            if (invalid(mx, my)) {\n                continue;\n            }\n            \n            if (s[v.y][v.x] != 4 && i == (p + s[v.y][v.x]) % 4) {\n                d[my][mx][i] = min(d[my][mx][i], d[v.y][v.x][p]);\n            }\n            else{\n                int k = -1;\n                for (int j = 0; j < 4; j++) {\n                    if (i == (p + j) % 4) {\n                        k = j;\n                        break;\n                    }\n                }\n                d[my][mx][i] = min(d[my][mx][i], d[v.y][v.x][p] + c[k]);\n            }\n        }\n    }\n    \n    int ans = INF;\n    for (int i = 0; i < 4; i++) {\n        ans = min(ans, d[h - 1][w - 1][i]);\n    }\n    return ans;\n}\n\n\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> s[i][j];\n            }\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            cin >> c[i];\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint v[40][40], x[40][40][4], w, h, z[4], q[4];\nvoid d0(int c, int d, int p1, int p2) {\n\tif (d == 0) {\n\t\tx[p1 + 1][p2][0] = min(x[p1 + 1][p2][d], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1][p2 + 1][1] = min(x[p1][p2 + 1][d], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1 - 1][p2][2] = min(x[p1 - 1][p2][d], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1][p2 - 1][3] = min(x[p1][p2 - 1][d], x[p1][p2][d] + c);\n\t}\n}\nvoid d3(int c,int d,int p1,int p2) {\n\tif (d == 0) {\n\t\tx[p1][p2 + 1][1] = min(x[p1][p2 + 1][1], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1 - 1][p2][2] = min(x[p1 - 1][p2][2], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1][p2 - 1][3] = min(x[p1][p2 - 1][3], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1 + 1][p2][0] = min(x[p1 + 1][p2][0], x[p1][p2][d] + c);\n\t}\n}\nvoid d2(int c, int d, int p1, int p2) {\n\tif (d == 0) {\n\t\tx[p1 - 1][p2][2] = min(x[p1 - 1][p2][2], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1][p2 - 1][3] = min(x[p1][p2 - 1][3], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1 + 1][p2][0] = min(x[p1 + 1][p2][0], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1][p2 + 1][1] = min(x[p1][p2 + 1][1], x[p1][p2][d] + c);\n\t}\n}\nvoid d1(int c, int d, int p1, int p2) {\n\tif (d == 0) {\n\t\tx[p1][p2 - 1][3] = min(x[p1][p2 - 1][3], x[p1][p2][d] + c);\n\t}\n\telse if (d == 1) {\n\t\tx[p1 + 1][p2][0] = min(x[p1 + 1][p2][0], x[p1][p2][d] + c);\n\t}\n\telse if (d == 2) {\n\t\tx[p1][p2 + 1][1] = min(x[p1][p2 + 1][1], x[p1][p2][d] + c);\n\t}\n\telse {\n\t\tx[p1 - 1][p2][2] = min(x[p1 - 1][p2][2], x[p1][p2][d] + c);\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tmemset(x, 1, sizeof(x));\n\t\tcin >> w >> h; if (!w) { break; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> z[0] >> z[1] >> z[2] >> z[3];\n\t\tx[1][1][1] = 0;\n\t\tfor (int t = 0; t < 1999; t++) {\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\t\t\tif (v[i][j] == l) {\n\t\t\t\t\t\t\t\tq[l] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tq[l] = z[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td0(q[0], k, i, j);\n\t\t\t\t\t\td1(q[1], k, i, j);\n\t\t\t\t\t\td2(q[2], k, i, j);\n\t\t\t\t\t\td3(q[3], k, i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min(x[h][w][0], x[h][w][1]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 4000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int inf = 1e9;\n\nint dx[4]={0,-1, 0, 1};\nint dy[4]={1, 0,-1, 0};\nstruct cell{\n\tint y;\n\tint x;\n\tint dir;\n\tint cost;\n\tcell(int y, int x, int d, int c):\n\t\ty(y),x(x),dir(d),cost(c){}\n};\n\nnamespace std{\n\tbool operator < (const cell& a, const cell& b){\n\t\treturn b.cost < a.cost;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0) break;\n\t\t\n\t\tint map[31][31];\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\tint cost[4];\n\t\tfor(int i=0; i<4; i++){\n\t\t\tcin >> cost[i];\n\t\t}\n\t\t\n\t\tvector<cell> adj[32][32][4];\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tfor(int t=0; t<4; t++){\n\t\t\t\t\t\tint y=i+dy[(k+t)%4];\n\t\t\t\t\t\tint x=j+dx[(k+t)%4];\n\t\t\t\t\t\tint c;\n\t\t\t\t\t\tif(map[i][j]==t) c=0;\n\t\t\t\t\t\telse c=cost[t];\n\t\t\t\t\t\tadj[i][j][k].push_back(cell(y,x,(k+t)%4,c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<cell> q;\n\t\tq.push(cell(1,1,3,0));\n\t\tint mincost[32][32][4];\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tmincost[i][j][k] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmincost[1][1][3] = 0;\n\t\twhile(!q.empty()){\n\t\t\tint y=q.top().y;\n\t\t\tint x=q.top().x;\n\t\t\tint d=q.top().dir;\n\t\t\tint c=q.top().cost;\n\t\t\tq.pop();\n\t\t\tif(c > mincost[y][x][d]) continue;\n\t\t\tif(y==h && x==w){\n\t\t\t\tcout << c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0; i<(int)adj[y][x][d].size(); i++){\n\t\t\t\tcell nc=adj[y][x][d][i];\n\t\t\t\tif(nc.cost+c <mincost[nc.y][nc.x][nc.dir]){\n\t\t\t\t\tmincost[nc.y][nc.x][nc.dir] = nc.cost+c;\n\t\t\t\t\tnc.cost +=c;\n\t\t\t\t\tq.push(nc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<29)\n\nint W,H;\nint C[5];\nint S[50][50];\nint D[50][50][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint dc[]={0,1,2,3};\n\nstruct state{\n  int x,y,d,c;\n  bool operator<(const state& s) const {\n    return c > s.c;\n  }\n};\n\nbool outcheck(int x,int y){\n  return x<0 || y<0|| x>=W || y>=H;\n}\n\n\nvoid solve(){\n\n  priority_queue<state> q;\n  for(int i=0;i<=H;i++)for(int j=0;j<=W;j++)for(int k=0;k<4;k++)D[j][i][k]=INF;\n  q.push( (state){0,0,1,0} );\n  D[0][0][1] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( D[p.x][p.y][p.d] < p.c ) continue;\n\n    //    cout << p.x << \"  \" << p.y << \" \"<<p.d << endl;\n    if( S[p.x][p.y] < 4 ){\n      int nd = (p.d + dc[S[p.x][p.y]])%4;\n      int nx = p.x + dx[nd], ny = p.y + dy[nd];\n      if( !outcheck(nx,ny) ){ \n\tif( D[nx][ny][nd] > p.c ){\n\t  D[nx][ny][nd] = p.c;\n\t  q.push( (state){nx,ny,nd,p.c} );\n\t}\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int nd = (p.d + dc[i])%4;\n      int nx = p.x + dx[nd], ny = p.y + dy[nd];\n      if( outcheck(nx,ny) ) continue;\n      //  cout << D[nx][ny][nd] << \" > \" << p.c + C[i]<< \" \" << i  <<endl;\n      if( D[nx][ny][nd] > p.c + C[i] ){\n\t//cout <<\"next \" << nx << \" \" << ny << \" \" << nd << endl;\n\tD[nx][ny][nd] = p.c+C[i];\n\tq.push( (state){nx,ny,nd,p.c+C[i]} );\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++){\n    res = min( res, D[W-1][H-1][i] );\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while( cin >> W>>H && (W||H ) ){\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> S[j][i];\n      }\n    }\n    for(int i=0;i<4;i++) \n      cin >> C[i];\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct data{\n    int x,y,dir,cost;\n    bool operator < (const data & a) const{\n        if(cost != a.cost) return cost > a.cost;\n        if(dir != a.dir) return dir < a.dir;\n        if(x != a.x) return x < a.x;\n        return y < a.y;\n    }\n};\n\nint memo[30][30][4],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint main(void){\n    int w,h,i,j,k,s[30][30],c[4];\n\n    while(1){\n        scanf(\"%d %d\",&w,&h);\n        if(w == 0 && h == 0)break;\n\n        for(i=0;i<h;++i){\n            for(j=0;j<w;++j){\n                scanf(\"%d\",&s[i][j]);\n            }\n        }\n\n        for(i=0;i<4;++i){\n            scanf(\"%d\",&c[i]);\n        }\n\n        priority_queue <data> Q;\n\n        for(i=0;i<30;i++){\n            for(j=0;j<30;j++){\n                for(k=0;k<4;k++){\n                    memo[i][j][k] = INT_MAX;\n                }\n            }\n        }\n        memo[0][0][0] = 0;\n\n        Q.push((data){0,0,0,0});\n\n        while(!Q.empty()){\n            data temp;\n            temp = Q.top();\n            Q.pop();\n            if(temp.x == h-1 && temp.y == w-1){\n                printf(\"%d\\n\",temp.cost);\n                break;\n            }\n            for(i=0;i<4;++i){\n                int ncost = temp.cost, ndir = (temp.dir+i)&3;\n                int nx = temp.x+dx[ndir], ny = temp.y+dy[ndir];\n                if(s[temp.x][temp.y] != i){\n                    ncost = temp.cost + c[i];\n                }\n                if(nx >= 0 && nx < h && ny >= 0 && ny < w){\n                    if(memo[nx][ny][ndir] > ncost){\n                        memo[nx][ny][ndir] = ncost;\n                        Q.push((data){nx,ny,ndir,ncost});\n                    }\n                }\n            }\n        }\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing tii = tuple<int, int, int>;\nusing pit = pair<int, tii>;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst int INF = 1e9;\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<vector<int>> s(h, vector<int>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<int> cost(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcin >> cost[i];\n\t\t}\n\t\tvector<vector<vector<int>>> d(h, vector<vector<int>>(w, vector<int>(4, INF)));\n\t\tpriority_queue<pit, vector<pit>, greater<pit>> pq;\n\t\tpq.emplace(0, make_tuple(0, 0, 0));\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint c = p.first, x = get<0>(p.second), y = get<1>(p.second), dir = get<2>(p.second);\n\t\t\tif (d[x][y][dir] != INF) continue;\n\t\t\td[x][y][dir] = c;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint com = (i + 4 - dir) % 4, tx = x + dx[i], ty = y + dy[i], tc = c + (com == s[x][y] ? 0 : cost[com]);\n\t\t\t\tif (0 <= tx && tx < h && 0 <= ty && ty < w && d[tx][ty][i] == INF) {\n\t\t\t\t\tpq.emplace(tc, make_tuple(tx, ty, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tres = min(res, d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nint ban[33][33];\nbool sumi[33][33][4];\npriority_queue<pa4,vector<pa4>,greater<pa4>> pq; \nvoid solve(){\n\tint h,w;\n\tcin>>w>>h;\n\tif(h==0 && w==0) exit(0);\n\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\tcin>>ban[i][j];\n\t\tfor(int k=0;k<4;k++)sumi[i][j][k]=0;\n\t}\n\t\n\twhile(pq.size())pq.pop();\n\t\tpq.push({0,1,1,0});\n\tint cost[4];\n\tfor(int i=0;i<4;i++)cin>>cost[i];\n\twhile(1){\n\t\tpa4 z=pq.top();\n\t\tpq.pop();\n\t\tif(sumi[z.y][z.z][z.w])continue;\n\t\tsumi[z.y][z.z][z.w]=1;\n\t\t//cout<<z.y<<\" \"<<z.z<<\" \"<<z.w<<\" \"<<z.x<<endl;\n\t\tif(z.y==h&&z.z==w){\n\t\t\tcout<<z.x<<endl;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=z.w;i<z.w+4;i++){\n\t\t\tint di=z.y+dx[i%4];\n\t\t\tint dj=z.z+dy[i%4];\n\t\t\tif(di<1 ||dj<1 || di>h || dj>w)continue;\n\t\t\tif(i-z.w==ban[z.y][z.z]){\n\t\t\t\t\tpq.push({z.x,di,dj,i%4});\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\tpq.push({z.x+cost[i-z.w],di,dj,i%4});\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n//????????¢???\nP next(int n,P p) {\n\tswitch (n) {\n\tcase 0:\n\t\treturn p;\n\tcase 1:\n\t\tif (p == P(0, 1))return P(-1, 0);\n\t\tif (p == P(1, 0))return P(0, 1);\n\t\tif (p == P(0, -1))return P(1, 0);\n\t\tif (p == P(-1, 0))return P(0, -1);\n\tcase 2:\n\t\treturn P(-p.first, -p.second);\n\tcase 3:\n\t\tif (p == P(0, 1))return P(1, 0);\n\t\tif (p == P(1, 0))return P(0, -1);\n\t\tif (p == P(0, -1))return P(-1, 0);\n\t\tif (p == P(-1, 0))return P(0, 1);\n\t}\n}\n//????§??¬???????\nint direction(P p) {\n\tif (p == P(1, 0))return 0;\n\tif (p == P(0, 1))return 1;\n\tif (p == P(-1, 0))return 2;\n\tif (p == P(0, -1))return 3;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\t//??\\?????¨??????\n\t\tvector<vector<int>>command(w, vector<int>(h));\n\t\tvector<vector<vector<int>>>memo(w, vector<vector<int>>(h, vector<int>(4)));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint buf; cin >> buf;\n\t\t\t\tcommand[j][i] = buf;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tmemo[j][i][k] = 10000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>cost(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint buf; cin >> buf;\n\t\t\tcost[i] = buf;\n\t\t}\n\t\t//???????????????????????§??¨??¢?´¢\n\t\tqueue<P> q; q.push(P(0, 0));\n\t\tqueue<P> q_dir; q_dir.push(P(1, 0));\n\t\tmemo[0][0][0] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tP now = q.front();\n\t\t\tP dir = q_dir.front();\n\t\t\tint nd = direction(dir);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tP neo = next(i, dir);\n\t\t\t\tint d = direction(neo);\n\t\t\t\tint next_x = now.first + neo.first;\n\t\t\t\tint next_y = now.second + neo.second;\n\t\t\t\tif (next_x >= 0 && next_y >= 0 && next_x < w && next_y < h) {\n\t\t\t\t\tbool flag = 0;\n\t\t\t\t\tif (i != command[now.first][now.second]) {\n\t\t\t\t\t\tif (memo[now.first][now.second][nd] + cost[i] < memo[next_x][next_y][d]) {\n\t\t\t\t\t\t\tmemo[next_x][next_y][d] = memo[now.first][now.second][nd] + cost[i];\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (memo[now.first][now.second][nd] < memo[next_x][next_y][d]) {\n\t\t\t\t\t\t\tmemo[next_x][next_y][d] = memo[now.first][now.second][nd];\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tq.push(P(next_x, next_y)); q_dir.push(neo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop(); q_dir.pop();\n\t\t}\n\t\tint ans = 10000;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tans = min(ans, memo[w - 1][h - 1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost<right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost<d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4];\n      int ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(d[ny][nx][ndir]>cost+c[i]){\n\td[ny][nx][ndir]=cost+c[i];\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n      if(data[y][x]!=i) continue;\n      if(d[ny][nx][ndir]>cost){\n\td[ny][nx][ndir]=cost;\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n    }\n  }\n  int mincost=INF;\n  for(int i=0;i<4;i++)\n    mincost=min(mincost,d[h-1][w-1][i]);\n  cout<<mincost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define MAXH 31\n#define MAXW MAXH\n#define MAXC 4\n#define INF (1<<20)\ntypedef enum {STRA=0,RIGHT=1,BACK=2,LEFT=3,STOP=4} TYPE;\nint W,H;\nint F[MAXH][MAXW];\nint cost[MAXC+1]; // cost[STOP]=0;\nint D[MAXH][MAXW][4];\nbool visited[MAXH][MAXW][4];\n\nclass State {\npublic:\n  int i,j,d,c; // i,j,direction,cost\n  State (int i, int j, int d, int c) : i(i),j(j),d(d),c(c) {}\n  bool operator < (const State &s) const {\n    return c > s.c;\n  }\n};\n\nbool ok(int i, int j) {\n  return 1 <= i && i <= H && 1 <= j && j <= W;\n}\n\nint solve() {\n  priority_queue<State> PQ;\n  for(int i=1;i<=H;i++) {\n    for(int j=1;j<=W;j++) {\n      for(int k=0;k<MAXC;k++) {\n\tD[i][j][k]=INF;\n      }\n    }\n  }\n  memset(visited,0,sizeof(visited));\n  PQ.push(State(1,1,RIGHT,0));\n  D[1][1][RIGHT]=0;\n  // x=>l, y=>k\n  int di[][4]={ {-1, 0, 1, 0},\n\t\t{ 0, 1, 0,-1},\n\t\t{ 1, 0,-1, 0},\n\t\t{ 0,-1, 0, 1}};\n  int dj[][4]={ { 0, 1, 0,-1},\n\t\t{ 1, 0,-1, 0},\n\t\t{ 0,-1, 0, 1},\n\t\t{-1, 0, 1, 0}};\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int i = u.i, j=u.j, d=u.d, c=u.c;\n    if(i==H&&j==W) {\n      return D[i][j][d];\n    }\n    visited[i][j][d]=true;\n    \n    for(int k=0;k<4;k++) {\n      int ui = i + di[d][k];\n      int uj = j + dj[d][k];\n      if(!ok(ui,uj)) continue;\n      if(k == F[i][j]) { // no cost\n\tint _cost = D[i][j][d] + 0;\n\tif(_cost < D[ui][uj][(d+k)%4]) {\n\t  D[ui][uj][(d+k)%4] = _cost;\n\t  PQ.push(State(ui,uj,(d+k)%4,_cost));\n\t}\n      } else { // have to pay cost\n\tint _cost = D[i][j][d] + cost[k];\n\tif(_cost < D[ui][uj][(d+k)%4]) {\n\t  D[ui][uj][(d+k)%4] = _cost;\n\t  PQ.push(State(ui,uj,(d+k)%4,_cost));\n\t}\n      }\n    } // for4\n    \n  }\n}\n\nmain() {\n  while(cin>>W>>H,W) {\n    for(int i=1;i<=H;i++) {\n      for(int j=1;j<=W;j++) {\n\tcin>>F[i][j];\n      }\n    }\n    for(int i=0;i<MAXC;i++) \n      cin>>cost[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint f[55][55];\nint c[4];\nint h,w,ans = -1;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nbool memo[55][55][4];\n\nbool can(int y,int x) {\n    if(0 <= y && y < h && 0 <= x && x < w) return true;\n    return false;\n}\n\nvoid func() {\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(P(0,0),P(0,0)));\n    \n    memset(memo,0,sizeof(memo));\n\n    while(que.size()) {\n        PP p = que.top();\n        que.pop();\n\n        int cost = p.first.first;\n        int d = p.first.second;\n        int y = p.second.first;\n        int x = p.second.second;\n\n        if(y == h-1 && x == w-1) {\n            ans = cost;\n            break;\n        }\n\n        if(memo[y][x][d]) continue;\n        memo[y][x][d] = true;\n\n        rep(i,4)\n        {\n            int nd = (d+i)%4;\n            int ny = y + dy[nd];\n            int nx = x + dx[nd];\n\n            if(can(ny,nx)) {\n                if(f[y][x] == i) {\n                    que.push(PP(P(cost,nd),P(ny,nx)));\n                }\n                else {\n                    que.push(PP(P(cost+c[i],nd),P(ny,nx)));\n                }\n            }\n        }\n    }\n}\nint main() {\n    \n    while(cin >> w >> h) {\n        if(w == 0 && h == 0) break;\n        \n        memset(f,0,sizeof(f));\n        rep(i,h) {\n            rep(j,w) {\n                cin >> f[i][j];\n            }\n        }\n\n        rep(i,4) cin >> c[i];\n\n        func();\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll w, h;\nll s[100][100];\nll c[4];\n\nll dx[] = { 1,0,-1,0 };\nll dy[] = { 0,1,0,-1 };\n\nll d[4][100][100];\n\nvoid dijkstra(P start) {\n\trep(i, 4)rep(j, 100)rep(k, 100)d[i][j][k] = INF;\n\td[0][start.first][start.second] = 0;\n\n\ttypedef pair<P, P> PP;\n\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push({ P(0, 0),start });\n\n\twhile (!que.empty()) {\n\t\tPP p = que.top();\n\t\tque.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint dir = p.first.second;\n\t\tif (y == h - 1 && x == w - 1)continue;\n\t\tif (d[dir][y][x] < p.first.first)continue;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ndir = (dir + i) % 4;\n\t\t\tint ny = y + dy[ndir];\n\t\t\tint nx = x + dx[ndir];\n\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w)continue;\n\t\t\tif (i == s[y][x]) {\n\t\t\t\tif (d[ndir][ny][nx] > d[dir][y][x]) {\n\t\t\t\t\td[ndir][ny][nx] = d[dir][y][x];\n\t\t\t\t\tque.push({ P(d[ndir][ny][nx], ndir),P(ny,nx) });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d[ndir][ny][nx] > d[dir][y][x] + c[i]) {\n\t\t\t\t\td[ndir][ny][nx] = d[dir][y][x] + c[i];\n\t\t\t\t\tque.push({ P(d[ndir][ny][nx], ndir),P(ny,nx) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\trep(i, h) {\n\t\t\trep(j, w)cin >> s[i][j];\n\t\t}\n\t\trep(i, 4)cin >> c[i];\n\t\tdijkstra(P(0, 0));\n\t\t//rep(i, 4) {\n\t\t//\trep(j, h) {\n\t\t//\t\trep(k, w)cout << d[i][j][k] << \" \";\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tll ans = INF;\n\t\trep(i, 4)ans = min(ans, d[i][h - 1][w - 1]);\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endlvd;\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nint dh[4]={0,1,0,-1},dw[4]={1,0,-1,0},mp[30][30],h,w,c[4],d[124*31],inf=1e8;\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,124*31) d[i]=inf;\n\td[s]=0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.sc;\n\t\tint vh=v/124,vw=v%124/4,vd=v%4;\n\t\tif(d[v]<p.fs) continue;\n\t\tif(mp[vh][vw]!=4){\n\t\t\tint dd=mp[vh][vw];\n\t\t\tint nd=(vd+dd)%4,nh=vh+dh[nd],nw=vw+dw[nd];\n\t\t\tif(0<=nh && nh<h && 0<=nw && nw<w){\n\t\t\t\tint to=nh*124+nw*4+nd;\n\t\t\t\tif(d[to]>d[v]){\n\t\t\t\t\td[to]=d[v];\n\t\t\t\t\tque.push(P(d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,4){\n\t\t\tint dd=i;\n\t\t\tint nd=(vd+dd)%4,nh=vh+dh[nd],nw=vw+dw[nd];\n\t\t\tif(0<=nh && nh<h && 0<=nw && nw<w){\n\t\t\t\tint to=nh*124+nw*4+nd;\n\t\t\t\tif(d[to]>d[v]+c[dd]){\n\t\t\t\t\td[to]=d[v]+c[dd];\n\t\t\t\t\tque.push(P(d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> w>>h;\n\t\tif(w==0) break;\n\t\trep(i,h) rep(j,w) cin >> mp[i][j];\n\t\trep(i,4) cin >> c[i];\n\t\tdijkstra(0);\n\t\tint ans=inf;\n\t\trep(i,4) ans=min(ans,d[(h-1)*124+(w-1)*4+i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define all(a) (a).begin(),(a).end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n#define ub(s,x) upper_bound(all(s),x)-s.begin()\n#define uniq(a) a.erase(unique(all(a)),a.end())\n#define debug(x) cout<<#x<<\": \"<<x<<endl\ntemplate<class T,class U>\nostream& operator<<(ostream& o, const pair<T,U> &p){\n    o<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n    return o;\n}\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\ntypedef long long ll;\n#define INF 1e9\n\nint s[30][30];\nint dp[30][30][4];\nint c[4]; // straight, right, back, left, halt\n\nstruct state{\n    int cost,y,x,dir;\n};\n\nbool operator>(const state &a, const state &b){\n    return a.cost > b.cost;\n}\n\n//           →↓←↑\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint X,Y;\n\nvoid dijkstra(){\n    using P = state;\n    priority_queue<P,vector<P>,greater<P>> qu;\n    qu.push({dp[0][0][0] = 0, 0,0,0});\n    while(qu.size()){\n        P cur = qu.top(); qu.pop();\n        int y = cur.y;\n        int x = cur.x;\n        int dir = cur.dir;\n        if(y == Y-1 && x == X-1) return;\n        if(dp[y][x][dir] < cur.cost) continue;\n        rep(i,4){\n            int nd = (dir+i)%4;\n            int ny = y + dy[nd];\n            int nx = x + dx[nd];\n            int cost = (i==s[y][x] ? 0 : c[i]);\n            if(ny<0 || nx<0 || nx>=X || ny>=Y) continue;\n            if( dp[ny][nx][nd] > dp[y][x][dir] + cost){\n                dp[ny][nx][nd] = dp[y][x][dir] + cost;\n                qu.push({dp[ny][nx][nd],ny,nx,nd});\n            }\n        }\n    }\n}\n\nint main(void){\n    while(cin>>X>>Y, X|Y){\n        rep(y,30)rep(x,30)rep(i,4){\n            dp[y][x][i] = INF;\n        }\n        rep(y,Y) rep(x,X) cin>>s[y][x];\n        rep(i,4) cin>>c[i];\n        dijkstra();\n        int res = INF;\n        rep(i,4){\n            res = min(res, dp[Y-1][X-1][i]);\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=10005,INF=1<<29;\nvector<pair<int,ll>> G[MAX];\nll dis[MAX];\nint H,W;\n\nvoid dijkstra(){\n    priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> PQ;\n    \n    dis[0]=0;\n    PQ.push({0,0});\n    while(!PQ.empty()){\n        ll a=PQ.top().first;\n        int b=PQ.top().second;\n        PQ.pop();\n        if(dis[b]<a) continue;\n        for(int i=0;i<G[b].size();i++){\n            int c=G[b][i].first;\n            ll d=G[b][i].second;\n            if(dis[c]>dis[b]+d){\n                dis[c]=dis[b]+d;\n                PQ.push(make_pair(dis[c],c));\n            }\n        }\n    }\n    return;\n}//a,dが長さ\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>W>>H;\n        if(H+W==0) break;\n        \n        for(int i=0;i<MAX;i++) dis[i]=INF;\n        for(int i=0;i<MAX;i++) G[i].clear();\n        \n        vector<vector<int>> S(H,vector<int>(W));\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>S[i][j];\n            }\n        }\n        vector<int> cost(4);\n        for(int i=0;i<4;i++) cin>>cost[i];\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<4;k++){\n                    for(int l=0;l<4;l++){\n                        int toi=i+dh[l],toj=j+dw[l];\n                        if(toi<0||toi>=H||toj<0||toj>=W) continue;\n                        \n                        if(S[i][j]==((4+l-k)%4)) G[k*H*W+(i*W+j)].push_back({l*H*W+(toi*W+toj),0});\n                        else G[k*H*W+(i*W+j)].push_back({l*H*W+(toi*W+toj),cost[(4+l-k)%4]});\n                    }\n                }\n            }\n        }\n        \n        dijkstra();\n        \n        ll ans=INF;\n        \n        for(int k=0;k<2;k++) ans=min(ans,dis[k*H*W+(H*W-1)]);\n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define MAX_H 30\n#define MAX_W 30\n\n#define DIR_UP 0\n#define DIR_RIGHT 1\n#define DIR_DOWN 2\n#define DIR_LEFT 3\n\n#define INST_STRAIGHT 0\n#define INST_RIGHT 1\n#define INST_BACK 2\n#define INST_LEFT 3\n\n#define REP(i,a,e) for(int i = (int)(a); i < (int)(e); ++i)\n\nconst int inv = -1;\nconst int infty = 1<<27;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {-1,0,1,0};\n\nint h,w;\nint map[MAX_H][MAX_W];\nbool G[MAX_H][MAX_W][MAX_H][MAX_W];\nint W[MAX_H][MAX_W][4];\nint C[4];\n\nvoid ResetGraph(){\n  h=0;\n  w=0;\n  C[0]=C[1]=C[2]=C[3]=0;\n  REP(i,0,MAX_H){\n    REP(j,0,MAX_W){\n      REP(k,0,MAX_H){\n\tREP(l,0,MAX_W){\n\t  G[i][j][k][l] = false;\n\t}\n      }\n      map[i][j] = inv;\n      REP(k,0,4)\n\tW[i][j][k]=infty;\n    }\n  }\n}\n\nbool isInside(int i, int j){\n  return 0<=i&&i<h&&0<=j&&j<w;\n}\n\nstruct state{\n  int i,j;\n  int dir;\n  int cost;\n  bool operator<(const state &t)const{\n    return cost > t.cost;\n  }\n};\n\nbool isGoal(int i, int j){ return i==h-1&&j==w-1; }\n\npair<int,int> proceed(int i, int j, int dir){\n  switch(dir){\n  case DIR_UP: return make_pair(i-1,j);\n  case DIR_RIGHT: return make_pair(i,j+1);\n  case DIR_DOWN : return make_pair(i+1,j);\n  case DIR_LEFT: return make_pair(i,j-1);\n  }\n  return make_pair(-1,-1);\n}\n\nint Dijkstra(){\n  priority_queue< state > pq;\n  state st;\n\n  st.i = 0;\n  st.j = 0;\n  st.dir = DIR_RIGHT;\n  st.cost = 0;\n\n  pq.push(st);\n  while(!pq.empty()){\n    st = pq.top();\n    pq.pop();\n\n    if( W[st.i][st.j][st.dir] <= st.cost ) continue;\n    if( W[st.i][st.j][st.dir] > st.cost ) W[st.i][st.j][st.dir] = st.cost;\n    if( isGoal( st.i, st.j ) ) return st.cost;\n    // if( map[st.i][st.j] == 4 ) continue;\n\n    // cout << \"I:\"<<st.i << \" J:\"<<st.j<<\" DIR : \" << st.dir << \" COST : \" << st.cost<<endl;\n\n    for(int d=0;d<4;++d){\n      state next=st;\n      next.dir = (st.dir+d)%4;\n      pair<int,int> np = proceed( st.i, st.j, next.dir );\n      \n      // cout << \" NEXT : \" << np.first << \" , \" << np.second << endl;\n      if( isInside( np.first, np.second ) ){\n\tnext.i = np.first;\n\tnext.j = np.second;\n\t\n\tif( d != map[st.i][st.j] )\n\t  next.cost += C[ d ];\n\tpq.push( next );\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n\n  while(true){\n    ResetGraph();\n\n    cin >> w >> h;\n    if(w==0&&h==0)break;\n\n    REP(i,0,h){\n      REP(j,0,w){\n\tcin >> map[i][j];\n      }\n    }\n\n    cin >> C[0] >> C[1] >> C[2] >> C[3];\n\n    cout << Dijkstra() << endl;\n\n    //break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct NODE{ int x, y, cost, di; };\nbool operator>(const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nNODE move(int cmd,const NODE &n){\n\tNODE ret;\n\t\n\tret.di = (n.di + cmd)%4;\n\tret.x = n.x + dx[ret.di];\n\tret.y = n.y + dy[ret.di];\n\t\n\treturn ret;\n}\n\nint w,h;\nbool check(const NODE &n){\n\treturn n.x >= 0 && n.y >= 0 && n.x < w && n.y < h;\n}\nint main(){\n\t\n\twhile(cin >> w >> h,w){\n\t\tint data[30][30],c[4];\n\t\trep(i,h)rep(j,w)cin >> data[i][j];\n\t\trep(i,4)cin >> c[i];\n\t\t\n\t\tpriority_queue<NODE,vector<NODE>,greater<NODE> > Q;\n\t\tNODE t = {0,0,0,0}; Q.push(t);\n\n\t\tbool done[30][30][4] = {false};\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[q.y][q.x][q.di])continue;\n\t\t\tdone[q.y][q.x][q.di] = true;\n\t\t\t\n\t\t\tif(q.x == w-1 && q.y == h-1){\n\t\t\t\tcout << q.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tNODE mv = move(i,q);\n\t\t\t\tmv.cost = q.cost;\n\t\t\t\tif(data[q.y][q.x] != i)mv.cost += c[i];\n\t\t\t\tif(check(mv))Q.push(mv);\n\t\t\t}\n\t\t}\n\t}\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int S = 40;\nconst int INF = 1 << 30;\n\nint W, H;\nint board[S][S], dist[S][S][4], cc[4];\n\n// north, east, south, west\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct Elem {\n    int x, y, dir;\n    bool operator<(const Elem &e) const {\n        return dist[x][y][dir] > dist[e.x][e.y][e.dir];\n    }\n};\n\nint main() {\n    while(scanf(\"%d%d\", &W, &H)) {\n        for(int i=0; i<S; i++) {\n            for(int j=0; j<S; j++) {\n                for(int k=0; k<4; k++) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n\n        if(W == 0) break;\n\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                scanf(\"%d\", &board[i][j]);\n            }\n        }\n\n        for(int i=0; i<4; i++) {\n            scanf(\"%d\", &cc[i]);\n        }\n\n        priority_queue<Elem> que;\n        // initial: east\n        que.push(Elem{0, 0, 1});\n        dist[0][0][1] = 0;\n\n        while(!que.empty()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, d = cur.dir;\n\n            for(int dd=0; dd<4; dd++) {\n                int d_new = (d + dd) % 4;\n                int cost = (board[x][y] == dd ? 0 : cc[dd]);\n                int nx = x + dx[d_new], ny = y + dy[d_new];\n\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if(dist[nx][ny][d_new] > dist[x][y][d] + cost) {\n                    dist[nx][ny][d_new] = dist[x][y][d] + cost;\n                    que.push(Elem{nx, ny, d_new});\n                }\n            }\n        }\n\n        int ans = *min_element(dist[H-1][W-1], dist[H-1][W-1] + 4);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\n\nint w, h;\nint d[30][30][4];\nint di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < h & j < w;\n}\n\nint main() {\n    while (cin >> w >> h && w){\n        VVI s(h, VI(w));\n        VI c(4);\n        REP(i,h) REP(j,w) cin >> s[i][j];\n        REP(i,4) cin >> c[i];\n        REP(i,h) REP(j,w) REP(k,4) d[i][j][k] = INF;\n        d[0][0][0] = 0;\n        priority_queue<pair<P, P>, vector<pair<P, P> >, greater<pair<P, P> > > q;\n        q.push(make_pair(P(0,0), P(0,0)));\n        while (!q.empty()){\n            pair<P,P> a = q.top();\n            q.pop();\n            int i = a.second.first, j = a.second.second, dir = a.first.second;\n            int dist = a.first.first;\n            if(d[i][j][dir] < dist) continue;\n            int cost[4] = {};\n            if (s[i][j] != 0) cost[dir] = c[0];\n            if (s[i][j] != 1) cost[(dir+1)%4] = c[1];\n            if (s[i][j] != 2) cost[(dir+2)%4] = c[2];\n            if (s[i][j] != 3) cost[(dir+3)%4] = c[3];\n            REP(k,4){\n                int ii = i + di[k], jj = j + dj[k];\n                if (!isin(ii, jj)) continue;\n                if (d[ii][jj][k] > d[i][j][dir] + cost[k]){\n                    d[ii][jj][k] = d[i][j][dir] + cost[k];\n                    q.push(make_pair(P(d[ii][jj][k], k), P(ii, jj)));\n                }\n            }\n        }\n        int ans = INF;\n        REP(k,4) ans = min(ans, d[h-1][w-1][k]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n\nconst double EPS = 1e-9;\n\n// 0: \"Straight\"\n// 1: \"Right\"\n// 2: \"Back\"\n// 3: \"Left\"\n// 4: \"Halt\"\nconst int dx[][4] = {\n    // → ↓ ← ↑\n    {1,0,-1,0},\n    // ↑ → ↓ ←\n    {0,1,0,-1},\n    // ← ↑ → ↓\n    {-1,0,1,0},\n    // ↓ ← ↑ →\n    {0,-1,0,1}\n};\n\nconst int dy[][4] = {\n    // → ↓ ← ↑\n    {0,1,0,-1},\n    // ↑ → ↓ ←\n    {-1,0,1,0},\n    // ← ↑ → ↓\n    {0,-1,0,1},\n    // ↓ ← ↑ →\n    {1,0,-1,0}\n};\n\n// → ↑ ← ↓\nconst int dd[][4] = {\n    // → ↓ ← ↑\n    {0,3,2,1},\n    // ↑ → ↓ ←\n    {1,0,3,2},\n    // ← ↑ → ↓\n    {2,1,0,3},\n    // ↓ ← ↑ →\n    {3,2,1,0}\n};\nstruct Robot{\n    int y,x,dir,step;\n    Robot(int y,int x,int dir,int step) : y(y),x(x),dir(dir),step(step) {};\n};\n\nbool operator<(const Robot& lhs,const Robot& rhs){\n    return lhs.step < rhs.step;\n}\nbool operator>(const Robot& lhs,const Robot& rhs){\n    return lhs.step > rhs.step;\n}\n\nint main(){\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0 and h == 0) break;\n        int gy = h-1,gx = w - 1;\n        vector<vector<int> > field(h,vector<int>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n            }\n        }\n\n        vector<int> costs(4);\n        for(int i=0;i<4;i++) cin >> costs[i];\n\n        vector<vector<vector<char> > > used(h,vector<vector<char> >(w,vector<char>(4,false)));\n        priority_queue<Robot,vector<Robot>,greater<Robot> > que;\n        que.push(Robot(0,0,0,0));\n        int ret = 0;\n        while(not que.empty()){\n            Robot r = que.top();\n            que.pop();\n            if(used[r.y][r.x][r.dir]) continue;\n            used[r.y][r.x][r.dir] = true;\n            if(r.y == gy and r.x == gx){\n                ret = r.step;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                int ny = r.y + dy[r.dir][i];\n                int nx = r.x + dx[r.dir][i];\n                if(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n                if(i == field[r.y][r.x]){\n                    que.push(Robot(ny,nx,dd[r.dir][i],r.step));\n                }else{\n                    que.push(Robot(ny,nx,dd[r.dir][i],r.step+costs[i]));\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e9\n#define NODE(x, y, d) (make_pair(make_pair(x, y), d))\n\nusing namespace std;\ntypedef pair<pair<int, int>, int> Node;\ntypedef pair<int, Node> P;\n\nstruct edge{\n\tNode to;\n\tint cost;\n\tedge(){}\n\tedge(Node a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint w, h;\nint map[35][35];\nint c[4];\nvector<edge> G[35][35][4];\nint dist[35][35][4];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nNode S;\n\nvoid dijkstra()\n{\n\tfor(int x = 1; x <= w; x++){\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tdist[x][y][d] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdist[1][1][0] = 0;\n\t\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(make_pair(0, S));\n\t\n\tint x, y, dir, d;\n\twhile(Q.size()){\n\t\tx = Q.top().second.first.first;\n\t\ty = Q.top().second.first.second;\n\t\tdir = Q.top().second.second;\n\t\td = Q.top().first;\n\t\tQ.pop();\n\t\tif(dist[x][y][dir] < d) continue;\n\t\tfor(int i = 0; i < G[x][y][dir].size(); i++){\n\t\t\tNode u = G[x][y][dir][i].to;\n\t\t\tint nx = u.first.first, ny = u.first.second, ndir = u.second;\n\t\t\tif(dist[nx][ny][ndir] > d + G[x][y][dir][i].cost){\n\t\t\t\tdist[nx][ny][ndir] = d + G[x][y][dir][i].cost;\n\t\t\t\tQ.push(make_pair(dist[nx][ny][ndir], NODE(nx, ny, ndir)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) cin >> c[i];\n\t\tS = NODE(1, 1, 0);\n\t\t\n\t\tfor(int x = 1; x <= w; x++){\n\t\t\tfor(int y = 1; y <= h; y++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tG[x][y][d].clear();\n\t\t\t\t\t\n\t\t\t\t\tint nx, ny, nd, cost;\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tnd = (d+4-i)%4;\n\t\t\t\t\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\t\t\t\t\tcost = c[i];\n\t\t\t\t\t\tif(map[x][y] == i) cost = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(nx <= 0 || nx > w || ny <= 0 || ny > h) continue;\n\t\t\t\t\t\tG[x][y][d].push_back(edge(NODE(nx, ny, nd), cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra();\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i = 0; i < 4; i++) ans = min(ans, dist[w][h][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fi first\n#define sc second\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\ntypedef pair<int,Q> R;\nint dist[32][32][4];\nint n,m,f[32][32];\nint c[4];\n\nint main(){\n\twhile(1){\n\t\tcin >> m >> n; if(n==0) return 0;\n\t\trep(i,n)rep(j,m) cin>>f[i][j];\n\t\trep(i,32)rep(j,32)rep(k,4) dist[i][j][k] = 1e9;\n\t\trep(i,4) cin>>c[i];\n\t\tpriority_queue<R,vector<R>,greater<R> >que;\n\t\tdist[0][0][0] = 0;\n\t\tque.push(R(0,Q(0,P(0,0))));\n\t\tint dx[4]={0,1,0,-1};\n\t\tint dy[4]={1,0,-1,0};\n\t\twhile(!que.empty()){\n\t\t\tR r = que.top(); que.pop();\n\t\t\tint x = r.sc.sc.fi, y = r.sc.sc.sc, d = r.sc.fi;\n\t\t\tif(dist[x][y][d] != r.fi) continue;\n\t\t\tif(f[x][y] <= 3){\n\t\t\t\tint D = (d+f[x][y])%4;\n\t\t\t\tint nx = x+dx[D], ny = y+dy[D];\n\t\t\t\tif(0<=nx&&nx<n&&0<=ny&&ny<m&&dist[nx][ny][D] > r.fi){\n\t\t\t\t\tdist[nx][ny][D] = r.fi;\n\t\t\t\t\tque.push(R(r.fi,Q(D,P(nx,ny))));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(go,4){\n\t\t\t\tint D = (d+go)%4;\n\t\t\t\tint nx = x+dx[D], ny = y+dy[D];\n\t\t\t\tif(0<=nx&&nx<n&&0<=ny&&ny<m&&dist[nx][ny][D] > r.fi+c[go]){\n\t\t\t\t\tdist[nx][ny][D] = r.fi+c[go];\n\t\t\t\t\tque.push(R(r.fi+c[go],Q(D,P(nx,ny))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e9;\n\t\trep(i,4) ans = min(ans,dist[n-1][m-1][i]);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint w, h;\nint s[32][32];\nint cost[4];\n\n// dir\n// 0 : right\n// 1 : up\n// 2 : left\n// 3 : down\nconst int dr[4] = {0, -1, 0, 1};\nconst int dc[4] = {1, 0, -1, 0};\nconst int dd[4] = {0, 3, 2, 1};\n\ntypedef std::pair<int, int> Pii;\n\nclass Node {\npublic:\n  Node() {}\n  Node(int r_, int c_, int dir_) : r(r_), c(c_), dir(dir_) {}\n  int r, c, dir;\n};\n\nclass Data {\npublic:\n  Data() {}\n  Data(Node s_, Node t_, int cost_) : s(s_), t(t_), cost(cost_) {}\n  Node s, t;\n  int cost;\n};\n\ninline bool operator < (const Data& a, const Data& b) {\n  return a.cost > b.cost;\n}\n\nint dist[32][32][8];\nint dijkstra() {\n  std::priority_queue<Data> q;\n  int r = 0;\n  int c = 0;\n  int dir = 0;\n  dist[r][c][dir] = 0;\n  for(int k = 0; k < 4; ++k) {\n    int nd = (dir + dd[k]) % 4;\n    int nr = r + dr[nd];\n    int nc = c + dc[nd];\n    if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n    q.push(Data(Node(r, c, dir), Node(nr, nc, nd), k == s[r][c] ? 0 : cost[k]));\n  }\n  while( not q.empty() ) {\n    Data t = q.top(); q.pop();\n    int r = t.t.r, c = t.t.c, dir = t.t.dir;\n    if( dist[r][c][dir] <= dist[t.s.r][t.s.c][t.s.dir] + t.cost ) continue;\n    dist[r][c][dir] = dist[t.s.r][t.s.c][t.s.dir] + t.cost;\n    if( r == h - 1 and c == w - 1 ) continue;\n    for(int k = 0; k < 4; ++k) {\n      int nd = (dir + dd[k]) % 4;\n      int nr = r + dr[nd];\n      int nc = c + dc[nd];\n      if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n      q.push(Data(Node(r, c, dir), Node(nr, nc, nd), k == s[r][c] ? 0 : cost[k]));\n    }\n  }\n  int res = (1 << 30);\n  for(int i = 0; i < 4; ++i) {\n    res = std::min(res, dist[h-1][w-1][i]);\n  }\n  return res;\n}\n\nvoid Init() {\n  for(int i = 0; i < 32; ++i) {\n    for(int j = 0; j < 32; ++j) {\n      for(int k = 0; k < 4; ++k) {\n        dist[i][j][k] = (1 << 29);\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    Init();\n    scanf(\"%d %d\", &w, &h);\n    if( w == 0 and h == 0 ) break;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\"%d\", &s[i][j]);\n      }\n    }\n    for(int i = 0; i < 4; ++i) {\n      scanf(\"%d\", &cost[i]);\n    }\n    int res = dijkstra();\n    printf(\"%d\\n\", res);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef tuple<int, int, pair<int, int> > tup;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint w, h;\nint s[32][32];\nint c[6];\n//dist[t][y][x] :=????????¨?????§?¨????(x, y)??§??\\????????????t????????????????????????\nint dist[6][32][32];\n\nvoid dijkstra(void){\n    rep(i, 6)rep(j, 32)rep(k, 32){\n    \tdist[i][j][k] = INF;\n    }\n\n    priority_queue<tup, vector<tup>, greater<tup> >  q;//????????????????????????????????\\?????? ?????¨?????§?¨?\n    dist[1][0][0] = 0;\n    q.push(make_tuple(0, 1, make_pair(0, 0)));\n\n    if(s[0][0] == 0){\n        q.push(make_tuple(0, 1, make_pair(0, 1)));\n        dist[1][0][1] = 0;\n    }else if(s[0][0] == 1){\n        q.push(make_tuple(0, 2, make_pair(1, 0)));\n        dist[2][1][0] = 0;\n    }else if(s[0][0] == 2 || s[0][0] == 3 || s[0][0] == 4){\n        q.push(make_tuple(c[0], 1, make_pair(0, 1)));\n        dist[1][0][1] = c[0];\n        q.push(make_tuple(c[1], 2, make_pair(1, 0)));\n        dist[2][1][0] = c[1];\n    }\n\n    while(!q.empty()){\n        int cost, v;\n        pair<int, int> p;\n        tie(cost, v, p) = q.top(); q.pop();\n        int y = p.first, x = p.second;\n        if(dist[v][y][x] < cost) continue;\n\n        for (int i = 0; i < 4; ++i){//??´??????????????¢?????????????????????\n            int nextv = (v + i) % 4;\n                //?????????????????????????????????\n            int ny = y + dy[nextv], nx = x + dx[nextv];\n            if(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n            if(i == s[y][x]){//????????????\n                if(cost < dist[nextv][ny][nx]){\n                    dist[nextv][ny][nx] = cost;\n                    q.push(make_tuple(dist[nextv][ny][nx], nextv, make_pair(ny, nx)));\n                }\n            }else{\n                if(cost + c[i] < dist[nextv][ny][nx]){\n                    dist[nextv][ny][nx] = cost + c[i];\n                    q.push(make_tuple(dist[nextv][ny][nx], nextv, make_pair(ny, nx)));\n                }\n            }\n        }\n    }\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n        rep(i, h)rep(j, w) cin >> s[i][j];\n        rep(i, 4){\n            cin >> c[i];\n        }\n\n\t\tdijkstra();\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tans = min(ans, dist[i][h - 1][w - 1]);\n\t\t}\n        printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef tuple<int, int, pair<int, int> > tup;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint w, h;\nint s[32][32];\nint c[6];\n//dist[t][y][x] :=????????¨?????§?¨????(x, y)??§??\\????????????t????????????????????????\nint dist[6][32][32];\n\nvoid dijkstra(void){\n    rep(i, 6)rep(j, 32)rep(k, 32){\n    \tdist[i][j][k] = INF;\n    }\n\n    priority_queue<tup, vector<tup>, greater<tup> >  q;//????????????????????????????????\\?????? ?????¨?????§?¨?\n    dist[1][0][0] = 0;\n    q.push(make_tuple(0, 1, make_pair(0, 0)));\n\n    while(!q.empty()){\n        int cost, v;\n        pair<int, int> p;\n        tie(cost, v, p) = q.top(); q.pop();\n        int y = p.first, x = p.second;\n        if(dist[v][y][x] < cost) continue;\n\n        for (int i = 0; i < 4; ++i){//??´??????????????¢?????????????????????\n            int nextv = (v + i) % 4;\n                //?????????????????????????????????\n            int ny = y + dy[nextv], nx = x + dx[nextv];\n            if(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n            if(i == s[y][x]){//????????????\n                if(cost < dist[nextv][ny][nx]){\n                    dist[nextv][ny][nx] = cost;\n                    q.push(make_tuple(dist[nextv][ny][nx], nextv, make_pair(ny, nx)));\n                }\n            }else{\n                if(cost + c[i] < dist[nextv][ny][nx]){\n                    dist[nextv][ny][nx] = cost + c[i];\n                    q.push(make_tuple(dist[nextv][ny][nx], nextv, make_pair(ny, nx)));\n                }\n            }\n        }\n    }\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n        rep(i, h)rep(j, w) cin >> s[i][j];\n        rep(i, 4){\n            cin >> c[i];\n        }\n\n\t\tdijkstra();\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tans = min(ans, dist[i][h - 1][w - 1]);\n\t\t}\n        printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint w, h;\nint result[31][31][5][5];\nint s[31][31];\nint c[4];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> s[i][j];\n                for(int k = 0; k < 5; k++){\n                    for(int l = 0; l < 5; l++){\n                        result[i][j][k][l] = mod;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < 4; i++){\n            cin >> c[i];\n        }\n\n        int ans = mod;\n        for(int i = 0; i < 5; i++){\n            priority_queue<pair<int, pair<pair<pair<int, int>, int>, int > > > qu;\n            qu.push(make_pair(0, make_pair(make_pair(make_pair(0, 0), 0), i)));\n            while(!qu.empty()){\n                int cost = (qu.top()).first;\n                int order = ((qu.top()).second).second;\n                pair<int, int> place = (((qu.top()).second).first).first;\n                int direction = (((qu.top()).second).first).second;\n                int x = place.first, y = place.second;\n                qu.pop();\n                // cout << x << \" \" << y << \" \" << direction << \" \" << order << \" \" << cost << endl;\n                if(order == 4) continue;\n                if(result[x][y][direction][order] <= -cost) continue;\n                result[x][y][direction][order] = -cost;\n                int nextdirection = (direction + order) % 4;\n                int nx = x + dx[nextdirection], ny = y + dy[nextdirection];\n                if(nx == h - 1 && ny == w - 1){\n                    if(s[0][0] != i) cost -= c[i];\n                    ans = min(ans, -cost);\n                    break;\n                }\n                if(nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n                for(int j = 0; j < 4; j++){\n                    int nextcost = cost;\n                    if(s[nx][ny] != j) nextcost -= c[j];\n                    if(result[nx][ny][nextdirection][j] > -nextcost){\n                        qu.push(make_pair(nextcost, make_pair(make_pair(make_pair(nx, ny), nextdirection), j)));\n                    } \n                }\n            }\n            // cout << endl;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={0,1,0,-1} ,dy[] = {1,0,-1,0};\n\nint h,w;\n\nclass Node{\npublic:\n    int cost,x,y,pre;\n    Node(){}\n    Node(int a,int b,int c,int d){\n        cost = a;\n        x = b;\n        y = c;\n        pre = d;\n    }\n\n    bool operator < (const Node& nd) const{\n        return cost < nd.cost;\n    }\n    bool operator > (const Node& nd) const{\n        return cost > nd.cost;\n    }\n    bool operator == (const Node& nd) const{\n        return cost==nd.cost;\n    }\n\n    void print() const{\n        printf(\"Node : cost(%d) , (x,y)=(%d,%d), pre=%d\\n\",cost,x,y,pre);\n    }\n};\n\nint move(int dir,int m){\n    if(m==0){\n        return dir;\n    }else if(m==1){\n        return (dir+1)%4;\n    }else if(m==2){\n        return (dir+2)%4;\n    }else if(m==3){\n        return (dir-1+4)%4;\n    }else{\n        assert(false);\n    }\n    return -1;\n}\n\nvoid solve(){\n    using P = tuple<int,int,int,int>;\n    vvi s(h,vi(w));\n    vi c(4);\n    rep(i,h) rep(j,w) cin>>s[i][j];\n    rep(i,4) cin>>c[i];\n\n    int d[32][32][5];\n    rep(i,32) rep(j,32) rep(k,5) d[i][j][k]=INF;\n\n\n    priority_queue<Node,vector<Node>,greater<Node>> que;\n    que.push(Node(0,0,0,0));\n    while(!que.empty()){\n        Node p = que.top();\n        que.pop();\n        int cost=p.cost,x=p.x,y=p.y,pre=p.pre;\n\n        if(x==h-1 and y==w-1){\n            cout << cost << endl;\n            return;\n        }\n\n        rep(i,4){\n            int ndir = move(pre,i);\n            int nx=x+dx[ndir];\n            int ny=y+dy[ndir];\n            if(nx<0 or nx>=h or ny<0 or ny>=w) continue;\n\n            if(i==s[x][y]){\n                if(cost < d[nx][ny][ndir]) {\n                    d[nx][ny][ndir] = cost;\n                    que.push(Node(cost,nx,ny,ndir));\n                }\n            }else{\n                if(cost + c[i] < d[nx][ny][ndir]){\n                    d[nx][ny][ndir] = cost + c[i];\n                    que.push(Node(cost+c[i],nx,ny,ndir));\n                }\n            }\n        }\n    }\n\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(h==0 and w==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (ll)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#define ALL(x) x.begin(), x.end()\n#ifdef DEBUG\n#define line() cerr << \"[\" << __LINE__ << \"] \";\n#define dump(i) cerr << #i \": \" << i << \" \";\n#define dumpl(i) cerr << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\n\nint w, h;\n\nbool validpos(int y, int x)\n{\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nvoid show(map<vector<int>, int> &mincost)\n{\n    rep(i, h)\n    {\n\n        rep(j, w)\n        {\n            int best = -1; // (1 << 30);\n            rep(k, 4)\n            {\n                best = max(best, mincost[{i, j, k}]);\n            }\n            cerr << best << \" \";\n        }\n        cerr << endl;\n    }\n}\n\nint main()\n{\n    while (true)\n    {\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {-1, 0, 1, 0};\n\n        cin >> w >> h;\n        if (w == 0 && h == 0)\n            break;\n        vector<vector<int>> g(h, vector<int>(w, 0));\n        rep(i, h) rep(j, w) cin >> g[i][j];\n        int c[4];\n        rep(i, 4) cin >> c[i];\n        map<vector<int>, int> mincost;\n        map<vector<int>, bool> visited;\n\n        auto compare = [](vector<int> &a, vector<int> &b) {\n            return ((h - 1) - a[0] + (w - 1) - a[1]) > ((h - 1) - b[0] + (w - 1) - b[1]);\n        };\n\n        priority_queue<vector<int>, vector<vector<int>>> que;\n        que.push({0,\n                  0,\n                  1, 0}); // y,x,dir,cost\n        mincost[{0, 0, 1}] = 0;\n        visited[{0, 0, 1}] = true;\n        while (!que.empty())\n        {\n            auto nowstate = que.top();\n            que.pop();\n            int y = nowstate[0];\n            int x = nowstate[1];\n            int dir = nowstate[2];\n            int cost = nowstate[3];\n            if (cost > mincost[{y, x, dir}])\n            {\n                continue;\n            }\n            rep(i, 4)\n            {\n                int ndir = (dir + i) % 4;\n                int nx = x + dx[ndir];\n\n                // cerr << \"y = \" << y << \",dy[ndir]=\" << dy[ndir] << endl;\n                int ny = y + dy[ndir];\n                //cerr << \"so ny = \" << ny << endl;\n\n                int ncost = cost + (g[y][x] == i ? 0 : c[i]);\n                //cerr << \"eval \" << ny << \",\" << nx << \",\" << ndir << \",\" << ncost << \",\" << y << endl;\n\n                if (validpos(ny, nx))\n                {\n\n                    if (visited[{ny, nx, ndir}] == false || mincost[{ny, nx, ndir}] > ncost)\n                    {\n                        // cerr << \"push \" << ny << \",\" << nx << \",\" << ndir << endl;\n                        que.push({ny, nx, ndir, ncost});\n                        visited[{ny, nx, ndir}] = true;\n                        mincost[{ny, nx, ndir}] = ncost;\n                    }\n                }\n                //cerr << \"for : \" << i << endl;\n            }\n            //  show(mincost);\n\n            //  rep(i, 4)\n            //        cerr\n            //   << mincost[{h - 1, w - 1, i}] << \" \";\n            //cerr << endl;\n        }\n        int ans = (1 << 30);\n        rep(i, 4)\n        {\n            if (visited[{h - 1, w - 1, i}] == true)\n            {\n                ans = min(ans, mincost[{h - 1, w - 1, i}]);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n\n    while (true) {\n\n        int W, H;\n        cin >> W >> H;\n\n        if (!(W | H)) break;\n\n        vector<vector<int>> S(H, vector<int>(W));\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) cin >> S[i][j];\n\n        vector<int> c(4);\n        for (int i = 0; i < 4; i++) cin >> c[i];\n\n        vector<vector<vector<int>>> dp(H, vector<vector<int>>(W, vector<int>(4, INT_MAX)));\n        dp[0][0][1] = 0;\n        priority_queue<tuple<int, pair<int, int>, int>, vector<tuple<int, pair<int, int>, int>>, greater<tuple<int, pair<int, int>, int>>> Q;\n        Q.push(make_tuple(0, make_pair(0, 0), 1));\n        while (!Q.empty()) {\n            auto t = Q.top();\n            Q.pop();\n            int cost = get<0>(t);\n            int y = get<1>(t).first;\n            int x = get<1>(t).second;\n            int d = get<2>(t);\n            if (dp[y][x][d] < cost) continue;\n            for (int i = 0; i < 4; i++) {\n                int nd = (d + i) % 4;\n                int ncost = cost;\n                if (i != S[y][x]) ncost += c[i];\n                int toY = y + dy[nd];\n                int toX = x + dx[nd];\n                if (toY < 0 || toY >= H || toX < 0 || toX >= W) continue;\n                if (dp[toY][toX][nd] > ncost) {\n                    dp[toY][toX][nd] = ncost;\n                    Q.push(make_tuple(ncost, make_pair(toY, toX), nd));\n                }\n            }\n        }\n\n        int ans = INT_MAX;\n        for (int i = 0; i < 4; i++) ans = min(dp[H - 1][W - 1][i], ans);\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tint color = 0;\n\n\tmap<string,int> t;\n\tvector<priority_queue<int,vector<int> ,greater<int> > > tt;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tint d;\n\t\tcin>>s>>d;\n\t\tif(t.find(s) == t.end() ){\n\t\t\tpriority_queue<int,vector<int> ,greater<int> > q;\n\t\t\tt[s] = tt.size();\n\t\t\tq.push(d);\n\t\t\ttt.push_back(q);\n\t\t}else{\n\t\t\tint ss = t[s];\n\t\t\ttt[ss].push(d);\n\t\t}\n\t}\n\n\tint m;\n\tcin>>m;\n\tbool f = false;\n\tint now = -1;\n\tfor(int i=0;i<m;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(f)continue;\n\t\tif(t.find(s) == t.end()){\n\t\t\t//cout<<\"color not exsit\"<<endl;\n\t\t\tf = true;\n\t\t\tcontinue;\n\t\t}\n\t\tint ss = t[s];\n\t\tif(tt[ss].empty() ){\n\t\t\t//cout<<\"color used \"<<endl;\n\t\t\tf = true;\n\t\t\t//cout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint next=tt[ss].top();\n\t\ttt[ss].pop();\n\t\t//cout<<s<<' '<<next<<endl;\n\t\twhile(now  >= next){\n\t\t\tif(tt[ss].empty() ){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext = tt[ss].top();\n\t\t\ttt[ss].pop();\n\t\t\t//cout<<now<<' '<<next<<endl;\n\t\t\t//cout<<2<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tnow = next;\n\t}\n\tif(f){\n\t\tcout<<\"No\"<<endl;\n\t}else{\n\t\tcout<<\"Yes\"<<endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define Y first\n#define X second\n#define ALL(x) (x).begin(), (x).end()\n#define RANGE(x, y, maxX, maxH) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxH))\n#define MP(x, y) make_pair(x, y)\n\nconst int INF = 0x3f3f3f3f;\nconst int DX[] = {1, 0, -1, 0};\nconst int DY[] = {0, 1, 0, -1};\n\nint W, H;\nVVI ts;\nVI cs;\n\nstruct State {\n    State(){}\n    State (PII p_, int dir_, int cost_) : p(p_), dir(dir_), cost(cost_) {}\n\n    PII p;\n    int dir; // ??????\n    int cost;\n\n    bool operator > (const State &s) const {\n        return cost > s.cost;\n    }\n\n    void dump() {\n        cout << p.X << \" \" << p.Y << \" \" << dir << \" \" << cost << endl;\n    }\n\n    void dump(string pre) {\n        cout << pre << p.X << \" \" << p.Y << \" \" << dir << \" \" << cost << endl;\n    }\n};\n\nvoid dump_dist(VVVI &dist) {\n    for (int k = 0; k < 4; k++) {\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                int c = dist[y][x][k];\n                cout << (c == INF ? -1 : c) << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;\n    }\n}\n\nint solve() {\n    VVVI dist(H, VVI(W, VI(4, INF))); // ????°??????????\n    dist[0][0][0] = 0;\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(MP(0, 0), 0, 0));\n    \n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n//        cur.dump(\"-- \");\n\n        // ???????????????????????????\n        if (cur.cost > dist[cur.p.Y][cur.p.X][cur.dir]) continue;\n\n        // 4???????????????\n        for (int i = 0; i < 4; i++) {\n            State n;\n\n            n.cost = cur.cost + (ts[cur.p.Y][cur.p.X] == i ? 0 : cs[i]);\n\n            n.dir = (cur.dir + i) % 4;\n\n            n.p.Y = cur.p.Y + DY[n.dir];\n            n.p.X = cur.p.X + DX[n.dir];\n\n            // ??´???\n            if (!RANGE(n.p.X, n.p.Y, W, H)) continue;\n\n//            n.dump(\"** \");\n\n            if (dist[n.p.Y][n.p.X][n.dir] > n.cost) {\n                dist[n.p.Y][n.p.X][n.dir] = n.cost;\n                q.push(n);\n            }\n        }\n    }\n\n//    dump_dist(dist);\n\n    int ans = *min_element(ALL(dist[H - 1][W - 1]));\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> W >> H, W) {\n        ts.clear();\n        ts.resize(H, VI(W));\n        cs.clear();\n        cs.resize(4);\n\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                cin >> ts[y][x];\n            }\n        }\n\n        for (int i = 0; i < 4; i++) {\n            cin >> cs[i];\n        }\n\n        cout << solve() << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define Repr(i, n, a) for (int i = (n); i >= (a); i--)\n#define rep(i, n) Rep(i, 0, n)\n#define repr(i, n) Repr(i, n, 0)\n#define all(a) a.begin(), a.end()\nusing namespace std;\ntypedef pair<int, int> P;\n//typedef pair<int, P> PP;\nconst int mod = 1000000007;\ntypedef pair<P, P> PP;\n\nint w, h, c[4];\nint s[50][50], d[50][50][4];\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nbool In(int x, int y) { return 0 <= x && x < h && 0 <= y && y < w; }\nvoid solve()\n{\n    priority_queue<PP, vector<PP>, greater<PP>> que;\n    for (int i = 0; i < 50; i++)\n        for (int j = 0; j < 50; j++)\n            for (int k = 0; k < 4; k++)\n                d[i][j][k] = INF;\n    d[0][0][0] = 0;\n    que.push(PP(P(0, 0), P(0, 0)));\n    while (!que.empty())\n    {\n        PP p = que.top();\n        que.pop();\n        int v = p.first.second;\n        int cost = p.first.first;\n        int x = p.second.first;\n        int y = p.second.second;\n        if (d[x][y][v] < cost)\n            continue;\n        if (x == h - 1 && y == w - 1)\n            continue;\n        rep(i, 4)\n        {\n            int nx = x + dx[(v + i) % 4];\n            int ny = y + dy[(v + i) % 4];\n            int nv = (v + i) % 4;\n            if (!In(nx, ny))\n                continue;\n            int ncost = cost;\n            if (s[x][y] != i)\n                ncost += c[i];\n            if (d[nx][ny][nv] > ncost)\n            {\n                d[nx][ny][nv] = ncost;\n                que.push(PP(P(ncost, nv), P(nx, ny)));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1)\n    {\n        cin >> w >> h;\n        if (w == 0)\n            break;\n        rep(i, h) rep(j, w) cin >> s[i][j];\n        cin >> c[0] >> c[1] >> c[2] >> c[3];\n        solve();\n        int ans = INF;\n        rep(i, 4) ans = min(ans, d[h - 1][w - 1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n \n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n \nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n \nll h,w;\nll gy,gx;\n \nll d[30][30][4];\n \nvector<vector<ll>> G;\nll c[4];\n \nll dx[] = {1,0,-1,0};\nll dy[] = {0,1,0,-1};\n \nbool in(int y,int x){\n    return y >= 0 && y < h && x >= 0 && x < w;\n}\n \nvoid dijkstra(ll sy,ll sx,ll dir){\n    rep(i,30)rep(j,30)rep(k,4)d[i][j][k] = INF;\n    d[sy][sx][dir] = 0;\n \n    typedef pair<P,P> PP;\n    priority_queue<PP, vector<PP>, greater<PP>> que;\n    que.push(PP(P(0,dir),P(sy,sx)));\n \n    while (!que.empty()){\n        PP p = que.top();\n        que.pop();\n        ll cdir = p.first.second;\n        ll cost = p.first.first;\n        ll cy = p.second.first;\n        ll cx = p.second.second;\n        if(cost > d[cy][cx][cdir])continue;\n        if(cy == gy && cx == gx)continue;\n        rep(i,4){\n            ll ny = cy + dy[(i + cdir)%4];\n            ll nx = cx + dx[(i + cdir)%4];\n            ll ndir = (cdir + i)%4;\n            if(!in(ny,nx))continue;\n            ll ncost = cost;\n            if(i != G[cy][cx])ncost += c[i];\n            if(d[ny][nx][ndir] > ncost){\n                d[ny][nx][ndir] = ncost;\n                que.push(PP(P(ncost,ndir),P(ny,nx)));\n            }\n        }\n    }\n}\n \nint main(){\n    while(cin >> w >> h && w){\n        gy = h - 1; gx = w - 1;\n        G.clear();\n        G.resize(h);\n        rep(i,h)G[i].resize(w);\n        rep(i,h){\n            rep(j,w){\n                cin >> G[i][j];\n            }\n        }\n        cin >> c[0] >> c[1] >> c[2] >> c[3];\n        dijkstra(0,0,0);\n        ll ans = INF;\n        rep(i,4)ans = min(ans,d[h-1][w-1][i]);\n        cout << ans << endl;\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct st {\n\tint x, y, c, d;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint dx[]{ 0,1,0,-1 }, dy[]{ 1,0,-1,0 };\nint s[30][30], c[4];\nint d[30][30][4];\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &s[i][j]);\n\t\trep(i, 4)scanf(\"%d\", &c[i]);\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\td[0][0][0] = 0;\n\t\tpriority_queue<st>que;\n\t\tque.push({ 0,0,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.x][p.y][p.d] != p.c)continue;\n\t\t\tint nx, ny;\n\t\t\trep(i, 4) {\n\t\t\t\tnx = p.x + dx[i]; ny = p.y + dy[i];\n\t\t\t\tint y = (i + 4 - p.d) % 4;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny<w&&d[nx][ny][i]>p.c + c[y]) {\n\t\t\t\t\td[nx][ny][i] = p.c + c[y];\n\t\t\t\t\tque.push({ nx,ny,d[nx][ny][i],i });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[p.x][p.y] < 4) {\n\t\t\t\tnx = p.x + dx[(p.d + s[p.x][p.y]) % 4];\n\t\t\t\tny = p.y + dy[(p.d + s[p.x][p.y]) % 4];\n\t\t\t}\n\t\t\telse continue;\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny<w&&d[nx][ny][(p.d + s[p.x][p.y]) % 4]>p.c) {\n\t\t\t\td[nx][ny][(p.d + s[p.x][p.y]) % 4] = p.c;\n\t\t\t\tque.push({ nx,ny,d[nx][ny][(p.d + s[p.x][p.y]) % 4],(p.d + s[p.x][p.y]) % 4 });\n\t\t\t}\n\t\t}\n\t\tint Min = INT_MAX;\n\t\trep(i, 4)Min = min(Min, d[h - 1][w - 1][i]);\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint m[33][33];\nmap<char,vector<vector<int>>> c;\n\n/*\n0: ?????´????????????\n1: ??????????????????\n2: ????????¢?????????\n3: ??????????????????\n4: ????????¢?????????\n*/\n\nstruct Point{ int x, y; };\nint dy[5] = {-1,0,1,0,-100}, dx[5] = {0,1,0,-1,-100};\nchar ch[5] = \"nwse\";\nint mc[4];\nint h, w;\nint limit;\n\nint direction(int com, char dis){\n    if(com == 4) return com;\n    if(dis == 'n') return com;\n    else if(dis == 'w') return (com + 1) % 4;\n    else if(dis == 's') return (com + 2) % 4;\n    else if(dis == 'e') return (com + 3) % 4;\n    return -1;\n}\n\nvoid dfs(int y, int x, char dis, int cost, int k){\n    //cout << y << ' ' << x << endl;\n    //show(m[y][x])\n    //    show(dis)\n    //if(k > w * h) return;\n    if(cost > limit) return;\n\n    rep(i,4){\n        int p = direction(i,dis);\n        int ny = y + dy[p];\n        int nx = x + dx[p];\n        int next_cost = cost + (i == m[y][x] ? 0 : mc[i]);\n\n        if(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n        if(c[ch[p]][ny][nx] <= next_cost) continue;\n        c[ch[p]][ny][nx] = next_cost;\n        dfs(ny,nx,ch[p], next_cost, k + 1);\n    }\n}\n\nint main(){\n    while(scanf(\"%d%d\",&w,&h),h){\n        rep(k,4) c[ ch[k] ] = vector<vector<int>>(33,vector<int>(33));\n        rep(k,4) rep(i,h) rep(j,w) c[ch[k]][i][j] = INF;\n        c['w'][0][0] = 0;\n\n        rep(i,h) rep(j,w) scanf(\"%d\",&m[i][j]);\n        rep(i,4) scanf(\"%d\",&mc[i]);\n        limit = mc[0] * (h + w) + min(mc[1],mc[3]);\n\n        dfs(0, 0, 'w', 0, 0);\n\n        //rep(i,h){ rep(j,w){ cout << c['w'][i][j] << ' '; } cout << endl; }\n\n        int mini = INF;\n        rep(i,4) mini = min(mini, c[ch[i]][h - 1][w - 1]);\n        cout << mini << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define min(a,b) ((a)>(b)?(b):(a))\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main() {\n\tint map[M+2][M+2], c[4], w, h;\n\tint dp[M+2][M+2][M*M+3][4], ans;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\tfor(int i=1; i<=h; ++i) {\n\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tfor(int t=0; t<=w*h; ++t) {\n\t\t\t\t\tfor(int k=0; k<4; ++k) dp[i][j][t][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\tdp[1][1][0][0] = 0; ans = INF;\n\t\tfor(int t=1; t<=w*h; ++t) {\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tif(i==h&&j==w) continue;\n\t\t\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\t\t\tfor(int l=0; l<4; ++l) {\n\t\t\t\t\t\t\tint d = (k+l)%4;\n\t\t\t\t\t\t\tif(map[i][j]==l) {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]+c[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j+dx[d]==w&&i+dy[d]==h&&d<2) {\n\t\t\t\t\t\t\t\tans = min(ans, dp[i+dy[d]][j+dx[d]][t][d%4]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<array>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nstruct Entry\n{\n    int x, y;\n    int direction;\n};\n\nint main()\n{\n    int w, h;\n\n    while(cin >> w >> h, (w | h) )\n    {\n        //cout << \"\\n\\n\" << w << \" \" << h << endl;\n\n        //map[h][w]\n        array< array<int, 30>, 30> map{};\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cin >> map[i][j];\n            }\n        }\n        \n        //command[0]?????´???\n        //command[1]?????????\n        //command[2]????????¢\n        //command[3]?????????\n        array<int, 4> command;\n        for(int i = 0; i < 4; i++)\n        {\n            cin >> command[i];\n        }\n\n       \n        //??????????????\\????????????????????????????????¨?????????\n        //array< array< array< int, 4>, 30>, 30> cost;\n        int cost[4][30][30];\n\n        //cost[0][][]??????\n        //cost[1][][]??????\n        //cost[2][][]??????\n        //cost[3][][]??????\n\n\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cost[0][i][j] = INF;\n                cost[1][i][j] = INF;\n                cost[2][i][j] = INF;\n                cost[3][i][j] = INF;\n            }\n        }\n\n        const int dx[4] = {1, 0, -1, 0};\n        const int dy[4] = {0, 1, 0, -1};\n\n\n        //start\n        queue<Entry> que;\n\n        que.push(Entry{0, 0, 0});\n        cost[0][0][0] = 0;\n\n        bool check = true;\n\n        while(!que.empty())\n        {\n            Entry now = que.front();\n            que.pop();\n            //cout << que.size() << \" : (\" << now.x << \", \" << now.y  << \") \" << now.direction << \" : \" << cost[now.direction][now.y][now.x] << endl;\n\n            //????????????????????£?????????????????????\n            int followedDirection = now.direction + map[now.y][now.x];\n            followedDirection %= 4;\n\n            //halt\n            if(map[now.y][now.x] == 4)followedDirection = INF;\n\n            //(now.direction + i) % 4????¬??????????\n            //i????????¢???????§????\n            for(int i = 0; i < 4; i++)\n            {\n                int nextDirection = (now.direction + i) % 4;\n\n                int nextX = now.x + dx[nextDirection];\n                int nextY = now.y + dy[nextDirection];\n\n                //???????????????????????????\n                if( !(nextX < 0 || nextX >= w || nextY < 0 || nextY >= h) ) \n                {\n                    int tmp_cost = cost[now.direction][now.y][now.x] + (nextDirection != followedDirection) * command[i];\n\n                    //cout << cost[2][h - 1][w - 1] << \"  \";\n\n                    //?????????????°???????????????°??´??°\n                    if(tmp_cost < cost[nextDirection][nextY][nextX])\n                    {\n                        cost[nextDirection][nextY][nextX] = tmp_cost;\n                        que.push( Entry{ nextX, nextY, nextDirection } );\n\n                    /*\n                    if(cost[2][h - 1][w - 1] != INF && check)\n                    {\n                        cout << \"\\n\\n\";\n\n                        cout <<  \"(\" << nextX << \", \" << nextY << \") \" << nextDirection << \" : \" << cost[nextDirection][nextY][nextX] << \" \" << cost[2][h - 1][w - 1] << endl;\n                        cout << que.size() << \" : (\" << now.x << \", \" << now.y  << \") \" << now.direction << \" : \" << cost[now.direction][now.y][now.x] << endl;\n                        \n                        cout << \"\\n\\n\";\n                    }\n                    check = cost[2][h - 1][w - 1] == INF;                \n                    */\n                    }\n                }\n\n            }\n        }\n\n        int ans = INF;\n        for(int i = 0; i < 4; i++)\n        {\n            if(cost[i][h - 1][w - 1] < ans)ans = cost[i][h - 1][w - 1];\n            //cout << cost[i][h - 1][w - 1] << \" \";\n        }\n//        cout << ans << endl;\n        cout << min(cost[0][h - 1][w - 1], cost[1][h - 1][w - 1]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nint main(){\n    ll w,h;\n    ll s[31][31];\n    ll d[5][31][31];\n    ll c[5];\n    while(true){\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tREP(i,h)REP(j,w){\n\t    cin >> s[i][j];\n\t    REP(k,5)\n\t\td[k][i][j] = INF;\n\t}\n\tREP(i,4) cin >> c[i];\n\tc[4] = 0;\n\n\tqueue< pair<ll,ll> > qxy;\n\tqueue<ll> qv;\n\tqueue<ll> qs;\n\tqxy.push(MP(0,0));\n\tqv.push(0);\n\tqs.push(0);\n\twhile(!qxy.empty()){\n\t    ll x = qxy.front().first;\n\t    ll y = qxy.front().second;\n\t    ll v = qv.front();\n\t    ll st = qs.front();\n\t    qxy.pop();\n\t    qv.pop();\n\t    qs.pop();\n\t    REP(i,5){\n\t\tll nx,ny;\n\t\tll nv = v;\n\t\tll nst;\n\t\tif(i != 4 && s[y][x] != 4){\n\t\t    nst = (st+i)%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t    nv = v + c[i];\n\t\t}else{\n\t\t    nst = (st+s[y][x])%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t}\n\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\tif(nv < d[nst][ny][nx]){\n\t\t    d[nst][ny][nx] = nv;\n\t\t    qxy.push(MP(nx,ny));\n// \t\t    prllf(\"x = %d y = %d v = %d s = %d i = %d\\n\",nx,ny,nv,nst,i);\n\t\t    qv.push(nv);\n\t\t    qs.push(nst);\n\t\t}\n\t    }\n\t}\n\tll ans = INF;\n\tREP(i,5) ans = min(ans,d[i][h-1][w-1]);\n\tcout << ans << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nint d[3600],w,h,c[4],dx[]={1,0,-1,0},dy[]={0,-1,0,1},dd[]={0,3,2,1};\nint m[30][30];\nvector<edge> g[3600];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+4*h*w,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\trep(i,4*h*w)g[i].clear();\n\t\trep(i,h)rep(j,w)cin>>m[i][j];\n\t\trep(i,4)cin>>c[i];\n\t\trep(i,h)rep(j,w)rep(k,4)rep(l,5){\n\t\t\tedge e;\n\t\t\tint nk;\n\t\t\tif(l<4||m[i][j]<4){\n\t\t\t\tif(l<4)nk=(k+dd[l])%4;\n\t\t\t\telse nk=(k+dd[m[i][j]])%4;\n\t\t\t\tint nx=j+dx[nk],ny=i+dy[nk];\n\t\t\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h){\n\t\t\t\t\te.to=nk*h*w+ny*w+nx;\n\t\t\t\t\tif(l<4)e.cost=c[l];\n\t\t\t\t\telse e.cost=0;\n\t\t\t\t\tg[k*h*w+i*w+j].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tint ans=INF;\n\t\trep(i,4)ans=min(ans,d[(i+1)*h*w-1]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvector<edge> G[4096];\nll d[4096];\n\nvoid dijkstra(int n, vector<edge> G[], int s, ll d[]) {\n\tfill(d, d + n, LLONG_MAX); d[s] = 0;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i> > q;\n\tq.push(ll_i(0, s));\n\twhile (!q.empty()) {\n\t\tll_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint w, h;\n\nint encode(int y, int x, int k) {\n\treturn (y * w + x) * 4 + k;\n}\n\nint main() {\n\tfor (;;) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\t\tvector< vector<int> > s(h + 2, vector<int>(w + 2, 4));\n\t\tfor (int y = 1; y <= h; y++)\n\t\t\tfor (int x = 1; x <= w; x++)\n\t\t\t\tcin >> s[y][x];\n\t\th += 2; w += 2;\n\t\tvector<int> c(4);\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tcin >> c[i];\n\t\tint n = h * w * 4;\n\t\tfor (int u = 0; u < n; u++) {\n\t\t\tG[u].clear();\n\t\t\tint y = u / (w * 4);\n\t\t\tint x = u % (w * 4) / 4;\n\t\t\tint k = u % 4;\n\t\t\tif (x - 1 >= 0 && x + 1 < w && y - 1 >= 0 && y + 1 < h);\n\t\t\telse continue;\n\t\t\tif (s[y][x] != 4) {\n\t\t\t\tint _k = (k + s[y][x]) % 4;\n\t\t\t\tint _x = x + dx[_k], _y = y + dy[_k];\n\t\t\t\tint _u = encode(_y, _x, _k);\n\t\t\t\tedge e = {u, _u, 0};\n\t\t\t\tG[u].push_back(e);\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint _k = (k + i) % 4;\n\t\t\t\tint _x = x + dx[_k], _y = y + dy[_k];\n\t\t\t\tint _u = encode(_y, _x, _k);\n\t\t\t\tedge e = {u, _u, c[i]};\n\t\t\t\tG[u].push_back(e);\n\t\t\t}\n\t\t}\n\t\tdijkstra(n, G, encode(1, 1, 2), d);\n\t\tll mini = LLONG_MAX;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tmini = min(mini, d[encode(h - 2, w - 2, i)]);\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nenum { STRAIGHT, RIGHT, BACK, LEFT, D };\n\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nconstexpr int MAX_SIZE = 30;\n\nint w, h;\nint s[MAX_SIZE][MAX_SIZE];\nint c[D];\n\nint dist[MAX_SIZE][MAX_SIZE][D];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nint dijkstra() {\n\ttypedef tuple<int, int, int, int> state;\n\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INT_MAX);\n\n\tque.push(state(0, 0, 0, 0));\n\tdist[0][0][0] = 0;\n\n\twhile(!que.empty()) {\n\t\tint d, x, y, dir;\n\t\ttie(d, x, y, dir) = que.top();\n\t\tque.pop();\n\n\t\tif(dist[x][y][dir] < d) continue;\n\t\tif(x == w - 1 && y == h - 1) return d;\n\n\t\tfor(int command = 0; command < 4; ++command) {\n\t\t\tconst int next_dir = (dir + command) & 0x3;\n\t\t\tconst int nx = x + dx[next_dir];\n\t\t\tconst int ny = y + dy[next_dir];\n\n\t\t\tif(out(nx, ny)) continue;\n\n\t\t\tconst int next_dist = d + (s[y][x] == command ? 0 : c[command]);\n\t\t\tif(dist[nx][ny][next_dir] > next_dist) {\n\t\t\t\tdist[nx][ny][next_dir] = next_dist;\n\t\t\t\tque.push(state(next_dist, nx, ny, next_dir));\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h && w) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < D; ++i) {\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tcout << dijkstra() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {0, 1, 0, -1};\nvector<int> dx = {1, 0, -1, 0};\nint INF = 1000000;\nint main(){\n  while (1){\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0){\n      break;\n    }\n    vector<vector<int>> s(h, vector<int>(w));\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        cin >> s[i][j];\n      }\n    }\n    vector<int> c(4);\n    for (int i = 0; i < 4; i++){\n      cin >> c[i];\n    }\n    int V = h * w * 4 + 1;\n    vector<vector<pair<int, int>>> E(V);\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        for (int k = 0; k < 4; k++){\n          for (int l = 0; l < 4; l++){\n            int y = i + dy[(k + l) % 4];\n            int x = j + dx[(k + l) % 4];\n            if (0 <= y && y < h && 0 <= x && x < w){\n              int u = (i * w + j) * 4 + k;\n              int v = (y * w + x) * 4 + (k + l) % 4;\n              int cost = c[l];\n              if (s[i][j] == l){\n                cost = 0;\n              }\n              E[u].push_back(make_pair(cost, v));\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < 4; i++){\n      E[V - 5 + i].push_back(make_pair(0, V - 1));\n    }\n    vector<int> d(V, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push(make_pair(0, 0));\n    while (!pq.empty()){\n      int c = pq.top().first;\n      int u = pq.top().second;\n      pq.pop();\n      if (d[u] == INF){\n        d[u] = c;\n        for (auto P : E[u]){\n          int v = P.second;\n          if (d[v] == INF){\n            pq.push(make_pair(c + P.first, v));\n          }\n        }\n      }\n    }\n    cout << d[V - 1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint d[33][33][4];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint n,m;\nint c[4];\nint a[33][33];\nmain()\n{\n\twhile(cin>>m>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tfor(int r=0;r<4;r++)d[i][j][r]=1e9;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++)cin>>c[i];\n\t\td[0][0][0]=0;\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >P;\n\t\tP.push({{0,0},{0,0}});\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint nc,r,x,y;\n\t\t\tnc=-P.top().first.first;\n\t\t\tr=P.top().first.second;\n\t\t\tx=P.top().second.first;\n\t\t\ty=P.top().second.second;\n\t\t\tP.pop();\n\t\t\tif(d[x][y][r]<nc)continue;\n\t\t\tif(a[x][y]<4)\n\t\t\t{\n\t\t\t\tint nr=(r+a[x][y])%4;\n\t\t\t\tint tx=x+dx[nr],ty=y+dy[nr];\n\t\t\t\tif(!(tx<0||ty<0||tx>=n||ty>=m||d[tx][ty][nr]<=nc))\n\t\t\t\t{\n\t\t\t\t\td[tx][ty][nr]=nc;\n\t\t\t\t\tP.push({{-nc,nr},{tx,ty}});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int dr=0;dr<4;dr++)\n\t\t\t{\n\t\t\t\tint nr=(r+dr)%4;\n\t\t\t\tint tx=x+dx[nr],ty=y+dy[nr];\n\t\t\t\tif(!(tx<0||ty<0||tx>=n||ty>=m||d[tx][ty][nr]<=nc+c[dr]))\n\t\t\t\t{\n\t\t\t\t\td[tx][ty][nr]=nc+c[dr];\n\t\t\t\t\tP.push({{-nc-c[dr],nr},{tx,ty}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min({d[n-1][m-1][0],d[n-1][m-1][1],d[n-1][m-1][2],d[n-1][m-1][3]})<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <memory>\n#include <cstdio>\n#include <memory.h>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pip;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint w, h;\nint area[31][31];\nint min_cost[31][31][4];\nint c[4];\n\nvoid bfs(){\n\tqueue<pip> qp;\n\tqp.push(make_pair(0, make_pair(1, 1)));\n\twhile(!qp.empty()){\n\t\tpip p = qp.front(); qp.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint d = p.first;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint y2 = y+dy[(d+i)%4];\n\t\t\tint x2 = x+dx[(d+i)%4];\n\t\t\tif(y2 < 1 || y2 > h || x2 < 1 || x2 > w) continue;\n\t\t\tint cost = 0;\n\t\t\tint d2 = (d+i)%4;\n\t\t\tif(area[y][x] != i) cost = c[i];\n\t\t\tif(min_cost[y2][x2][d2] < 0 || min_cost[y][x][d] + cost < min_cost[y2][x2][d2]){\n\t\t\t\tmin_cost[y2][x2][d2] = min_cost[y][x][d] + cost;\n\t\t\t\tqp.push(make_pair(d2, make_pair(y2, x2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(min_cost, -1, sizeof(min_cost));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tmin_cost[1][1][0] = 0;\n\t\tbfs();\n\t\tint cost = 10000;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(min_cost[h][w][i] > 0) cost = min(cost, min_cost[h][w][i]);\n\t\t}\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\n//お手上げ\n//ループがあったらダメとかかな？\n\n//           →  ↓  ←   ↑\nint di[4] = {0, 1, 0, -1};\nint dj[4] = {1, 0, -1, 0};\n\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    while(1){\n        int w, h; cin >> w >> h;\n        if(!w) break;\n        vector<vector<int> > a(h, vector<int> (w));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> a[i][j];\n            }\n        }\n\n        int c[4];\n        for(int i = 0; i < 4; i++) cin >> c[i];\n        map<pair<pair<int, int>, int>, int > m;                   //{ , } 方向\n        int n = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < 4; k++){\n                    m[{{i, j}, k}] = n;\n                    n++;\n                }\n            }\n        }\n\n        vector<vector<pair<int, int> > > adjlist(3610);      //first := コスト　second := 行先\n\n        //グラフを作っていきます\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                //if(a[i][j] == 4) continue;\n                for(int k = 0; k < 4; k++){          //今向いてる方向\n\n                    int now = m[{{i, j}, k}];\n                    if(a[i][j] == 0){                //直進\n                        for(int l = 0; l < 4; l++){\n                            if(0 <= i + di[l] && i + di[l] < h && 0 <= j + dj[l] && j + dj[l] < w){\n                                int next = m[{{i + di[l], j + dj[l]}, l}];\n                                if(k == l) adjlist[now].push_back({0, next});\n                                else adjlist[now].push_back({c[(4 + l - k) % 4], next});\n                            }\n                        }\n                    }else if(a[i][j] == 1){          //右折\n                        for(int l = 0; l < 4; l++){\n                            if(0 <= i + di[l] && i + di[l] < h && 0 <= j + dj[l] && j + dj[l] < w){                            \n                                int next = m[{{i + di[l], j + dj[l]}, l}];\n                                if((4 + l - k) % 4 == 1) adjlist[now].push_back({0, next});\n                                else adjlist[now].push_back({c[(4 + l - k) % 4], next});\n                            }\n                        }\n                    }else if(a[i][j] == 2){\n                        for(int l = 0; l < 4; l++){\n                            if(0 <= i + di[l] && i + di[l] < h && 0 <= j + dj[l] && j + dj[l] < w){\n                                int next = m[{{i + di[l], j + dj[l]}, l}];\n                                if((4 + l - k) % 4 == 2) adjlist[now].push_back({0, next});\n                                else adjlist[now].push_back({c[(4 + l - k) % 4], next});\n                            }\n                        }\n                    }else if(a[i][j] == 3){\n                        for(int l = 0; l < 4; l++){\n                            if(0 <= i + di[l] && i + di[l] < h && 0 <= j + dj[l] && j + dj[l] < w){                            \n                                int next = m[{{i + di[l], j + dj[l]}, l}];\n                                if((4 + l - k) % 4 == 3) adjlist[now].push_back({0, next});\n                                else adjlist[now].push_back({c[(4 + l - k) % 4], next});\n                            }\n                        }\n                    }else{\n                         for(int l = 0; l < 4; l++){\n                            if(0 <= i + di[l] && i + di[l] < h && 0 <= j + dj[l] && j + dj[l] < w){                            \n                                int next = m[{{i + di[l], j + dj[l]}, l}];\n                                //if((4 + l - k) % 4 == 3) adjlist[now].push_back({0, next});\n                                adjlist[now].push_back({c[(4 + l - k) % 4], next});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<int> result(n);\n        int s = m[{{0, 0}, 0}];\n        result = dijk(s, n, adjlist);\n        //cout << result[G] << endl;\n\n        /*for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                int ans = INF;\n                for(int k = 0; k < 4; k++){\n                    ans = min(ans, result[m[{{i, j}, k}]]);\n                }\n                cout << ans << \" \";\n            }\n            cout << endl;\n        }*/\n        int ans = INF;\n        for(int i = 0; i < 4; i++){\n            int node = m[{{h - 1, w - 1}, i}];\n            ans = min(ans, result[node]);\n        }\n        cout << ans << endl;\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint w,h,s[30][30],c[4],d[900][4],ans;\n\nint encode(int y,int x){\n    return w*y+x;\n}\n\npii decode(int pos){\n    return pii(pos/w,pos%w);\n}\n\nvoid dijkstra(){\n    ans=inf;\n    fill_n((int*)d,900*4,inf);\n    d[0][0]=0;\n    priority_queue<pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>>> que;\n    que.push(make_pair(0,pii(0,0)));\n    while(!que.empty()){\n        pair<int,pii> p=que.top(); que.pop();\n        int dist=p.first,pos=p.second.first;\n        int y=decode(pos).first,x=decode(pos).second,dir=p.second.second;\n\n        if(y==h-1 and x==w-1){\n            ans=min(ans,dist);\n            continue;\n        }\n        if(dist>d[encode(y,x)][dir]) continue;\n\n        rep(i,0,4){\n            int cost=c[i],ndir=(dir+i)%4;\n            if(i==s[y][x]) cost=0;\n            \n            int ny=y+dy[ndir],nx=x+dx[ndir];\n            int npos=encode(ny,nx);\n            if(ny<0 or h<=ny or nx<0 or w<=nx) continue;\n            if(dist+cost<d[npos][ndir]){\n                d[npos][ndir]=dist+cost;\n                que.push(make_pair(d[npos][ndir],pii(npos,ndir)));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n\n        rep(y,0,h) rep(x,0,w) cin >> s[y][x];\n        rep(i,0,4) cin >> c[i];\n\n        dijkstra();\n\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<functional>\n#include<map>\n#include<climits>\nusing namespace std;\nstruct S{int x,y,c,a;}s,t;\nstruct C:unary_function<S,int>{int operator()(S a,S b){return a.c>b.c;}};\nint main()\n{\n\tint h,w,m[30][30],c[4],i,j,k,x[]={1,0,-1,0},d[30][30][4];\n\twhile(scanf(\"%d%d\",&w,&h),h)\n\t{\n\t\tfor(i=0;i<h;++i)for(j=0;j<w;++j)scanf(\"%d\",&m[i][j]);\n\t\tfor(i=0;i<4;++i)scanf(\"%d\",&c[i]);\n\t\tfor(i=0;i<h;++i)for(j=0;j<w;++j)for(k=0;k<4;++k)d[i][j][k]=INT_MAX;\n\n\t\tpriority_queue<S,vector<S>,C>q;\n\t\ts.x=s.y=s.c=s.a=0;\n\t\tq.push(s);\n\t\tfor(;;)\n\t\t{\n\t\t\ts=q.top(),q.pop();\n\t\t\tif(s.x<0||s.x>=w||s.y<0||s.y>=h)continue;\n\t\t\tif(d[s.y][s.x][s.a]<=s.c)continue;\n\t\t\tif(s.x==w-1&&s.y==h-1)break;\n\t\t\td[s.y][s.x][s.a]=s.c;\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tt=s;\n\t\t\t\tif(m[s.y][s.x]-i)t.c+=c[i];\n\t\t\t\tt.a=(t.a+i)%4;\n\t\t\t\tt.x+=x[t.a], t.y+=x[(t.a+3)%4];\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s.c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint h,w;\n\nbool in(int x, int y){\n    if(x < 0 || x >= h)return false;\n    if(y < 0 || y >= w)return false;\n    return true;\n}\n\nint main(void) {\n    int i,j,k;\n    while(cin >> w >> h, h){\n        int g[30][30];\n        rep(i,h)rep(j,w) cin >> g[i][j];\n        vi c(4);\n        rep(i,4)cin >> c[i];\n        int cost[30][30][4];//up,right,down,left\n        rep(i,h)rep(j,w)rep(k,4)cost[i][j][k] = INF;\n        cost[0][0][1] = 0;\n        queue<vi> q;\n        vi v(3);\n        v[0] = v[1] = 0;\n        v[2] = 1;\n        q.push(v);\n        int dx[4] = {-1,0,1,0};\n        int dy[4] = {0,1,0,-1};\n        while(q.size()){\n            vi t = q.front();\n            q.pop();\n            int x = t[0];\n            int y = t[1];\n            int z = t[2]; //up,right,down,left\n            int d = g[x][y];\n            rep(i,4){\n                t[0] = x + dx[(z+i)%4]; // x\n                t[1] = y + dy[(z+i)%4]; // y\n                t[2] = (z + i)%4; // up,right,down,left\n                if(!in(t[0],t[1]))continue;\n                if(i == d){\n                    if(cost[t[0]][t[1]][t[2]] > cost[x][y][z]){\n                        cost[t[0]][t[1]][t[2]] = cost[x][y][z];\n                        q.push(t);\n                    }\n                }else{\n                    if(cost[t[0]][t[1]][t[2]] > cost[x][y][z] + c[i]){\n                        cost[t[0]][t[1]][t[2]] = cost[x][y][z] + c[i];\n                        q.push(t);\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,4) ans = min(ans, cost[h-1][w-1][i]);\n        cout << ans << endl;\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost>right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4],ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      int ncost=d[ny][nx][ndir];\n      if(ncost>cost+c[i]) ncost=cost+c[i],Q.push((dat){ncost,ny,nx,ndir});\n      if(data[y][x]!=i) continue;\n      if(ncost>cost) ncost=cost,Q.push((dat){ncost,ny,nx,ndir});\n    }\n  }\n  cout<<min(d[h-1][w-1][1],d[h-1][w-1][2])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n  #define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cerr\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\nvector<int> DY = {-1, 0, 1, 0};\nvector<int> DX = {0, 1, 0, -1};\n\nvector<vector<vector<ll>>> dijkstra(int sy, int sx, int h, int w, vector<int>& c, vector<vector<int>>& g){\n    priority_queue<pair<int, pair<pii, int>>, vector<pair<int, pair<pii, int>>>, greater<pair<int, pair<pii, int>>>> pque;\n    vector<vector<vector<ll>>> d(h+2, vector<vector<int>>(w+2, vector<int>(4, INF)));\n    d[sy][sx][1] = 0;\n    pque.push({0, {{sy, sx}, 1}});\n\n    while (!pque.empty()){\n        pair<int, pair<pii, int>> p = pque.top(); pque.pop();\n        int y = p.se.fi.fi;\n        int x = p.se.fi.se;\n        int k = p.se.se;\n        //cerr << y << \" \"<<  x << \" \" << k << endl;\n        if (y == 0 || y == h+1 || x == 0 || x == w+1) continue;\n        if (d[y][x][k] < p.first) continue;\n        //指示なし\n        int ny, nx;\n        if (g[y][x] != 4) {\n          ny = y + DY[(k + g[y][x]) % 4];\n          nx = x + DX[(k + g[y][x]) % 4];\n          if (d[y][x][k] < d[ny][nx][(k + g[y][x]) % 4]) {\n            d[ny][nx][(k + g[y][x]) % 4] = d[y][x][k];\n            pque.push({d[ny][nx][(k + g[y][x]) % 4], {{ny, nx}, (k + g[y][x]) % 4}});\n          }\n        }\n        //指示あり\n        rep(l, 4) {\n          ny = y + DY[(k + l) % 4];\n          nx = x + DX[(k + l) % 4];\n          //cerr << ny << \" \" << nx << endl;\n          if (d[y][x][k] + c[l] < d[ny][nx][(l + k) % 4]) {\n            d[ny][nx][(l + k) % 4] = d[y][x][k] + c[l];\n            pque.push({d[ny][nx][(l + k) % 4], {{ny, nx}, (k + l) % 4}});\n          }\n        }\n    }\n    return d;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0) break;\n    vector<vector<int>> g(h+2, vector<int>(w+2, -1));\n    rep(i, h)rep(j, w) {\n      cin >> g[i+1][j+1];\n    }\n    vector<int> c(4);\n    rep(i, 4) cin >> c[i];\n    vector<vector<vector<int>>> d = dijkstra(1, 1, h, w, c, g);\n    //cerr << \"passed\" << endl;\n    int ans = INFLL;\n    rep(k, 4) ans = min(ans, d[h][w][k]);\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\nint cost[31][31][4];\n\nstruct Location {\n\tint x, y, dir, score;\n\tLocation(int _x, int _y, int _dir, int _s) :\n\t\tx(_x), y(_y), dir(_dir), score(_s)\n\t{ }\n};\nstruct LocationComparator {\n\tbool operator()(const Location &a, const Location &b) const {\n\t\treturn a.score > b.score;\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){ break; }\n\t\tvector< vector<int> > s(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){ cin >> s[i][j]; }\n\t\t}\n\t\tint c[4];\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\t\tmemset(cost, -1, sizeof(cost));\n\t\tpriority_queue<Location, vector<Location>, LocationComparator> pq;\n\t\tcost[0][0][0] = 0;\n\t\tpq.push(Location(0, 0, 0, 0));\n\t\tint answer = -1;\n\t\twhile(!pq.empty()){\n\t\t\tLocation loc = pq.top();\n\t\t\tif(loc.x == w - 1 && loc.y == h - 1){\n\t\t\t\tanswer = cost[loc.x][loc.y][loc.dir];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tint next = cost[loc.x][loc.y][loc.dir];\n\t\t\t\tif(i != s[loc.y][loc.x]){ next += c[i]; }\n\t\t\t\tint dir = (loc.dir + i) % 4;\n\t\t\t\tint x = loc.x + dx[dir], y = loc.y + dy[dir];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h){ continue; }\n\t\t\t\tif(cost[x][y][dir] < 0 || next < cost[x][y][dir]){\n\t\t\t\t\tcost[x][y][dir] = next;\n\t\t\t\t\tpq.push(Location(x, y, dir, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 99999999\nusing namespace std;\nint h,w,t[30][30],u[30][30][4],v[30][30][4];\nint ny,nx,nz,y,x,z,mini;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint cost[4];\n\nvoid input();\nvoid init();\nint compute();\nint check(int,int);\nint co(int);\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    input();\n    init();\n    cout<<compute()<<endl; \n  }\n  return 0;\n}\nvoid input(){\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>t[i][j];\n    }\n  }  \n}\nvoid init(){\n  for(int i=0;i<30;i++){\n    for(int j=0;j<30;j++){\n      for(int k=0;k<4;k++){\n\tu[i][j][k]=INF;\n\tv[i][j][k]=0;\n      }\n    }\n  }\n  for(int i=0;i<4;i++)cin>>cost[i];\n}\n\nint compute(){\n  u[0][0][1]=0;\n  while(1){\n    mini=INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<4;k++){\n\t  if(u[i][j][k]<mini&&v[i][j][k]==0){\n\t    mini=u[i][j][k];\n\t    y=i;x=j;z=k;\n\t  }\n\t}//k\n      }//j\n    }//i\n    \n    //cout<<y<<' '<<x<<' '<<z<<' '<<u[y][x][z]<<endl;\n    //cout<<u[1][7][2]<<endl;\n    if(mini==INF)break;\n    v[y][x][z]=1;\n\n    for(int i=0;i<4;i++){\n      nz=(z+i)%4;\n      nx=x+dx[nz];\n      ny=y+dy[nz];\n      if(!check(ny,nx))continue;\n      if(u[ny][nx][nz]>u[y][x][z]+cost[i]){\n\tu[ny][nx][nz]=u[y][x][z]+cost[i];\n      }\n    }\n    \n    if(t[y][x]==4){\n    }else{\n      nz=(z+t[y][x])%4;\n      nx=x+dx[nz];\n      ny=y+dy[nz];\n      if(!check(ny,nx))continue;\n      if(u[ny][nx][nz]>u[y][x][z]){\n\t//cout<<u[y][x][z]<<endl;\n\tu[ny][nx][nz]=u[y][x][z];\n      }\n    }\n  }\n  mini=INF;\n  for(int i=0;i<4;i++){\n    if(mini>u[h-1][w-1][i]){\n      mini=u[h-1][w-1][i];\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<4;k++){\n\tif(u[i][j][k]!=INF){\n\t  cout<<i<<' '<<j<<' '<<k<<endl;\n\t  cout<<u[i][j][k]<<endl;\n\t}\n      }//k\n    }//j\n  }//i\n  */\n\n  return mini;\n}\nint check(int y,int x){\n  if(0<=y&&y<h&&0<=x&&x<w)return 1;\n  else return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n#include <queue>\nusing namespace std;\n#define INF 1 << 28\n\ntypedef tuple<int, int, pair<int, int>> Node;\ntypedef pair<int, int> Point;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint w, h;\nint cost_table[4][31][31];\nint grid[31][31];\nint order_cost[4];\n\nint dijkstra(){\n  for(int i=0;i<4;i++){\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        cost_table[i][j][k] = INF;\n      }\n    }\n  }\n  cost_table[1][0][0] = 0;\n  priority_queue<Node, vector<Node>, greater<Node>> que;\n  que.push(make_tuple(0, 1, make_pair(0,0)));\n\n  while(!que.empty()){\n    int cost, dir;\n    Point pt;\n    Node now = que.top(); que.pop();\n    tie(cost, dir, pt) = now;\n    int x = pt.first, y = pt.second;\n    if(cost_table[dir][y][x] < cost) continue;\n    if(x == w - 1 && y == h - 1) return cost;\n    for(int i=0; i<4; i++){\n      int nd = (dir + i) % 4;\n      int nx = x  + dx[nd], ny = y + dy[nd];\n      if(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n      int ncost = (i == grid[y][x]) ? cost : cost + order_cost[i];\n      if(ncost >= cost_table[nd][ny][nx]) continue;\n      que.push(make_tuple(ncost, nd, make_pair(nx, ny)));\n      cost_table[nd][ny][nx] = ncost;\n    }\n  }\n}\n\nint main(void){\n  while(true){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i = 0;i<h;i++){\n      for(int j = 0;j<w;j++){\n        cin >> grid[i][j];\n      }\n    }\n    for(int i = 0;i<4;i++) cin >> order_cost[i];\n    cout << dijkstra() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <queue>\n\n#define MAX_W 30\n#define MAX_H 30\n\nusing namespace std;\n\nint inf = 1<<29;\n\nint H, W;\nint map[MAX_W+1][MAX_H+1];\nint dist[MAX_W+1][MAX_H+1][4];\nint c[4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state{\n\tint dist, x, y, dr;\n\tstate(int a,int b, int c, int d):dist(a),x(b),y(c),dr(d){}\n};\n\nbool operator<(const state& a, const state& b){ return a.dist > b.dist; }\n\nint solve(){\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tfor (int j = 0; j < H; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tdist[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<state> Q;\n\tQ.push(state(0, 0, 0, 0));\n\twhile(!Q.empty()){\n\t\tstate tp = Q.top(); Q.pop();\n\t\tif(tp.x == W-1 && tp.y == H-1) return tp.dist;\n\t\tif(dist[tp.x][tp.y][tp.dr] != inf) continue;\n\t\tdist[tp.x][tp.y][tp.dr] = tp.dist;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint nx = tp.x+dx[i], ny = tp.y+dy[i], ndr = i;\n\t\t\tif(0 <= ny && ny < H && 0 <= nx && nx < W && dist[nx][ny][ndr] == inf){\n\t\t\t\tint odr = (tp.dr+map[tp.x][tp.y])%4;//????????????????????£??????????????????\n\t\t\t\tint cost;\n\t\t\t\tif(map[tp.x][tp.y] == 4){\n\t\t\t\t\tcost = c[(ndr-tp.dr+4)%4];\n\t\t\t\t}else{\n\t\t\t\t\tif(odr == ndr){\n\t\t\t\t\t\tcost = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcost = c[(ndr-tp.dr+4)%4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.push(state(tp.dist+cost, nx, ny, ndr));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> W >> H;\n\t\tif(W == 0) break;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> map[j][i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tcin >> c[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint w,h,s[30][30],c[4],d[30][30][4],ans; //d[pos][dir]:=位置posに向きdirで入るための最小コスト\n\nint encode(int y,int x){\n    return w*y+x;\n}\n\npii decode(int pos){\n    return pii(pos/w,pos%w);\n}\n\nvoid dijkstra(){\n    ans=inf;\n    fill_n((int*)d,900*4,inf);\n    d[0][0][0]=0;\n    //priority_queue<pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>>> que;\n    //que.push(make_pair(0,pii(0,0)));\n    using triple=tuple<int,int,int>;\n    priority_queue<pair<int,triple>,vector<pair<int,triple>>,greater<pair<int,triple>>> que;\n    while(!que.empty()){\n        pair<int,triple> p=que.top(); que.pop();\n        int dist=p.first;\n        int y=get<0>(p.second),x=get<1>(p.second),dir=get<2>(p.second);\n\n        if(y==h-1 and x==w-1){\n            ans=min(ans,dist);\n            continue;\n        }\n        if(dist>d[y][x][dir]) continue;\n\n        rep(i,0,4){\n            int cost=c[i],ndir=(dir+i)%4;\n            if(i==s[y][x]) cost=0;\n\n            int ny=y+dy[ndir],nx=x+dx[ndir];\n            if(ny<0 or h<=ny or nx<0 or w<=nx) continue;\n            if(dist+cost<d[ny][nx][ndir]){\n                d[ny][nx][ndir]=dist+cost;\n                que.push(make_pair(d[ny][nx][ndir],triple(ny,nx,ndir)));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n\n        rep(y,0,h) rep(x,0,w) cin >> s[y][x];\n        rep(i,0,4) cin >> c[i];\n\n        dijkstra();\n\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main(){\n  int w,h;\n  while(scanf(\"%d%d\",&w,&h), w+h){\n    int board[h][w];\n    int cost[4];\n    REP(i,h) REP(j,w) scanf(\"%d\",&board[i][j]);\n    REP(i,4) scanf(\"%d\",&cost[i]);\n\n    typedef pair<int,pair<int,pair<int,int> > > data;\n    priority_queue<data> pq;\n    bool memo[h][w][4];\n    memset(memo, 0, sizeof(memo));\n    pq.push(mp(0,mp(0,mp(0,0))));\n\n    while(!pq.empty()){\n      data d = pq.top(); pq.pop();\n      int x = d.s.s.f;\n      int y = d.s.s.s;\n      int dir = d.s.f;\n      int c = -d.f;\n\n      if(memo[y][x][dir]) continue;\n      memo[y][x][dir] = true;\n\n      if(x == w-1 && y == h-1){\n        printf(\"%d\\n\",c);\n        break;\n      }\n\n      REP(i,4){\n        int cc = c + (board[y][x] == i ? 0 : cost[i]);\n        int dd = (dir + i) % 4;\n        int xx = x + dx[dd];\n        int yy = y + dy[dd];\n        if(xx < 0 || y < 0) continue;\n        if(xx >=w || y >=h) continue;\n        if(memo[yy][xx][dd]) continue;\n        pq.push(mp(-cc,mp(dd,mp(xx,yy))));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<tuple>\n#include<functional>\n\nusing namespace std;\ntypedef tuple<int, int, int, int> T4i;\ntypedef long long ll;\n\nstruct pos {\n\tint x, y;\n\tpos(int a, int b) { x = a, y = b; }\n};\n\nint W, H;\nint field[30][30];\nll d[30][30][4];\nll c[4];//問題文と添え字が一つずれてることに注意\n\n//v[i][j]: iの向きのときの動き方の増分\npos v[4][4] = {\n\t{pos(0, 1), pos(1, 0), pos(0, -1), pos(-1, 0)},\n\t{pos(1, 0), pos(0, -1), pos(-1, 0), pos(0, 1)},\n\t{pos(0, -1), pos(-1, 0), pos(0, 1), pos(1, 0)},\n\t{pos(-1, 0), pos(0, 1), pos(1, 0), pos(0, -1)}\n};\n\nint vdirect[4][4] = {\n\t{0, 1, 2, 3},\n\t{1, 2, 3, 0},\n\t{2, 3, 0, 1},\n\t{3, 0, 1, 2}\n};\n//0: 右向き 1: 下向き 2:左向き  3: 上向き \n\nvoid djkstra() {\n\tpriority_queue<T4i, vector<T4i>, greater<T4i>> pq;\n\n\t//queueの中身は　コスト、座標、向いてる方向\n\t//始まりは、(0, 0)で向きは右向き　つまり0\n\td[0][0][0] = 0;\n\tpq.push(make_tuple(0, 0, 0, 0));\n\n\twhile (pq.size()) {\n\n\t\tauto now = pq.top(); pq.pop();\n\t\tpos nowp = pos(get<1>(now), get<2>(now));\n\t\tint nowd = get<3>(now);\n\t\tif (d[nowp.x][nowp.y][nowd] < get<0>(now))continue;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t//ここから４種類の行き方をそれぞれエッジとして試す\n\t\t\tll cost = 0;\n\t\t\tif (i == field[nowp.x][nowp.y])cost = 0;\n\t\t\telse cost = c[i];\n\n\t\t\tpos nextp = pos(nowp.x + v[nowd][i].x, nowp.y + v[nowd][i].y);\n\t\t\t\n\t\t\t//範囲外になってないかをチェック\n\t\t\tif (nextp.x < 0 || nextp.y < 0 || nextp.x >= H || nextp.y >= W)continue;\n\n\t\t\t//ゴール判定\n\t\t\tif (nextp.x == H - 1 && nextp.y == W - 1) {\n\t\t\t\td[nextp.x][nextp.y][0] = min(d[nextp.x][nextp.y][0], d[nowp.x][nowp.y][nowd] + cost);\n\t\t\t}\n\n\t\t\t//行先処理\n\t\t\tif (d[nextp.x][nextp.y][vdirect[nowd][i]] > d[nowp.x][nowp.y][nowd] + cost) {\n\t\t\t\td[nextp.x][nextp.y][vdirect[nowd][i]] = d[nowp.x][nowp.y][nowd] + cost;\n\t\t\t\tpq.push(make_tuple(d[nextp.x][nextp.y][vdirect[nowd][i]], \n\t\t\t\t\tnextp.x, nextp.y, \n\t\t\t\t\tvdirect[nowd][i]));\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nint main() {\n\n\twhile (1) {\n\t\tcin >> W >> H;\n\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tfor (int j = 0; j < 30; j++)\n\t\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t\t\td[i][j][k] = 999999999;\n\t\t\n\t\tif (W + H == 0)break;\n\t\t\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\t\t\n\t\tdjkstra();\n\t\n\t\t//d[H - 1][W - 1]だけは、Stop確実なのでここだけ例外措置でStraightのところに答えを置く。\n\t\tcout << d[H - 1][W - 1][0] << endl;\n\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef pair<int, TIII> QIIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b,c))\n#define MQ(a,b,c,d) MP(a, MT(b,c,d))\n#define Q1 first\n#define Q2 second.first\n#define Q3 second.second.first\n#define Q4 second.second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n#define MOD 1000000007\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint board[33][33];\nint memo[33][33][4];\nint w,h;\nint c[4];\n\nint main(){\n\twhile(cin>>w>>h, w){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tmemset(board, -1, sizeof(board));\n\t\tREP(i,h)REP(j,w)scanf(\"%d\", &board[i+1][j+1]);\n\t\tREP(i,4)scanf(\"%d\", c+i);\n\t\tpriority_queue<QIIII, vector<QIIII>, greater<QIIII> > q;\n\t\tq.push(MQ(0, 1, 1, 0));\n\t\twhile(!q.empty()){\n\t\t\tQIIII tmp = q.top();\n\t\t\tq.pop();\n\t\t\tint y=tmp.Q2;\n\t\t\tint x=tmp.Q3;\n\t\t\tint d=tmp.Q4;\n\t\t\tif(memo[y][x][d]>=0)continue;\n\t\t\tmemo[y][x][d] = tmp.Q1;\n\t\t\tREP(i,4){\n\t\t\t\tint nd = (i+d)%4;\n\t\t\t\tint nx = x+dx[nd];\n\t\t\t\tint ny = y+dy[nd];\n\t\t\t\tif(board[ny][nx]!=-1){\n\t\t\t\t\tif(board[y][x]==i)q.push(MQ( tmp.Q1, ny, nx, nd));\n\t\t\t\t\telse q.push(MQ( tmp.Q1+c[i], ny, nx, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 1000000000;\n\t\tREP(i,2)ret = min(ret, memo[h][w][i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(!w) break;\n    vector<vector<int>> s(h,vector<int>(w));\n    for(int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> s[i][j];\n      }\n    }\n    int c[4];\n    for(int i = 0; i < 4; ++i) {\n      cin >> c[i];\n    }\n    typedef vector<tuple<int,int,int>> edge;\n    vector<vector<vector<edge>>> to(h,vector<vector<edge>>(w,vector<edge>(4)));\n    vector<vector<vector<vector<int>>>> cost(h,vector<vector<vector<int>>>(w,vector<vector<int>>(4)));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int di[] = {1,0,-1,0};\n        int dj[] = {0,1,0,-1};\n        for (int k = 0; k < 4; ++k) {\n          int ni=i+di[k];\n          int nj=j+dj[k];\n          if(ni<0||nj<0||ni>=h||nj>=w)continue;\n          for (int l = 0; l < 4; ++l) {\n            to[i][j][l].push_back(make_tuple(ni,nj,k));\n            if ((l - k + 4) % 4 == s[i][j]) {\n              cost[i][j][l].push_back(0);\n            } else {\n              cost[i][j][l].push_back(c[(l - k + 4) % 4]);\n            }\n          }\n        }\n      }\n    }\n    typedef tuple<int, int, int, int> T;\n    priority_queue<T, vector<T>, greater<T>> q;\n    q.push(make_tuple(0,0,0,1));\n    vector<vector<vector<int>>> d(h,vector<vector<int>>(w,vector<int>(4,1000000000)));\n    d[0][0][1] = 0;\n    while(!q.empty()) {\n      auto p = q.top(); q.pop();\n      int c,i,j,k;\n      tie(c,i,j,k) = p;\n      if (c > d[i][j][k]) continue;\n      for (int l = 0; l < to[i][j][k].size(); ++l) {\n        int ni,nj,nk;\n        tie(ni,nj,nk) = to[i][j][k][l];\n        if (d[ni][nj][nk] > d[i][j][k] + cost[i][j][k][l]) {\n          d[ni][nj][nk] = d[i][j][k] + cost[i][j][k][l];\n          q.push(make_tuple(d[ni][nj][nk],ni,nj,nk));\n        }\n      }\n    }\n    int minc = 1000000000;\n    for (int i = 0; i < 4; ++i) {\n      minc = min(minc,d[h-1][w-1][i]);\n    }\n    cout << minc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <queue>\n#include <functional>\nint field[30][30] = { 0 };\nint m[4][30][30]; //[??????][y][x] = ????°??????????\nint costs[4] = { 0 };\nint dx[] = { 1, 0, -1, 0, 1, 0, -1, 0 }, dy[] = {0, 1, 0, -1, 0, 1, 0, -1 };\n\nstruct Node{\n\tint x, y, cost = 0, d;\n\tbool operator < (const Node& rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n\tbool operator < (Node&& rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n\tbool operator > (const Node& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n\tbool operator > (Node&& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile (std::cin >> w >> h && (w || h)) {\n\t\tstd::memset(m, 0x7f, sizeof(int) * 4 * 30 * 30);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tstd::cin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) std::cin >> costs[i];\n\n\t\tstd::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n\t\tq.push({0, 0, 0, 0});\n\t\tbool isOk = false;\n\t\tint minCost = INT_MAX;\n\t\twhile (!q.empty() && !isOk) {\n\t\t\tNode node = q.top(); q.pop();\n\t\t\tif (node.x == w - 1 && node.y == h - 1) {\n\t\t\t\tisOk = true;\n\t\t\t\tminCost = node.cost;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tNode next = node;\n\t\t\t\tif (i == 1) next.d++;\n\t\t\t\telse if (i == 2) next.d += 2;\n\t\t\t\telse if (i == 3) next.d--;\n\t\t\t\tif (next.d < 0) next.d = 4 + next.d;\n\t\t\t\telse if (next.d >= 4) next.d = next.d - 4;\n\n\t\t\t\tnext.x += dx[next.d];\n\t\t\t\tnext.y += dy[next.d];\n\t\t\t\tif (field[node.y][node.x] != i) next.cost += costs[i];\n\n\t\t\t\tif (next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\tif (m[next.d][next.y][next.x] <= next.cost) continue;\n\t\t\t\tm[next.d][next.y][next.x] = next.cost;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tstd::cout << minCost << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(3);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\n\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nconstexpr int DEB_LEN =20;\nconstexpr int DEB_LEN_H =12;\nstring deb_tos(const int &v) { if (abs(v) == inf || abs(v) == linf)return \"e\"; else return to_string(v); }\ntemplate<class T> string deb_tos(const T &a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string deb_tos(const vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), DEB_LEN);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << deb_tos(a[i]);        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            lens[wi] = max(lens[wi], sz(deb_tos(a[h][W[wi]])) + 1);            lens[wi] = max(lens[wi], sz(deb_tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            ss << std::right << std::setw(lens[wi]) << deb_tos(a[h][w]);            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), DEB_LEN_H});    W = min({W, sz(a[0]), DEB_LEN_H});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return deb_tos(a, hs, ws, key);}\ntemplate<class T> string deb_tos(const vector<vector<vector<T> > > &a, ll H = inf) {    stringstream ss;    if (H == inf)H = DEB_LEN_H;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << deb_tos(a[i], inf, inf, i);    }    return ss.str();}\ntemplate<class T, size_t A> string deb_tos(T (&a)[A]) { return deb_tos(vector<T>(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B> string deb_tos(T (&a)[A][B]) { return deb_tos(vector<vector<T> >(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B, size_t C> string deb_tos(T (&a)[A][B][C]) { return deb_tos(vector<vector<vector<T> > >(begin(a), end(a))); }\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<deb_tos(x)<<\", \"<< debugName(y)<<\" = \"<<deb_tos(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<deb_tos(x)  << \", \" <<  debugName(y)<<\" = \"<<deb_tos(y) <<\", \" debugName(z)<<\" = \"<<deb_tos(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) <<\", \" <<   debugName(y)<<\" = \"<<deb_tos(y) <<\", \" <<  debugName(z)<<\" = \"<<deb_tos(z) <<\", \" <<  debugName(a)<<\" = \"<<deb_tos(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) <<\", \" <<   debugName(y)<<\" = \"<<deb_tos(y) <<\", \" <<  debugName(z)<<\" = \"<<deb_tos(z) <<\", \" <<  debugName(a)<<\" = \"<<deb_tos(a)<<\", \" <<  debugName(b)<<\" = \"<<deb_tos(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T, class U> pair<T,U> operator+(const pair<T,U> &a, const pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.push_back(v);\n    r_ a;\n}\ntemplate<class T> v_<T>& operator+=(v_<T> & a,const v_<T> & b){\n    fora(v, b)a += v;\n    return a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    rep(i, sz(m)){os << m[i];if(i < sz(m)-1)os<<\" \";}   r_ os;}\nostream &operator<<(ostream &os, v_<char> &m) {rep(i, sz(m)){os << m[i];}   r_ os;}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<v_<T>> &m) {rep(i, sz(m)){os << m[i]; if(i < sz(m)-1)os << endl;}   r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nvoid out() { cout << \"\" << endl; }\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n#define VEC vector\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n/*@formatter:off*/\n//整数用幾何ライブラリ   *@formatter:off*/\nvp ort_next_ = {{1, 0}, {0,  1}, {-1, 0}, {0,  -1}, {1,  0}};\nvp ort_prev_ = {{1, 0}, {1,  0}, {0, 1}, {-1,  0}, {0,  -1}};\nclass D {\npublic:\n    int x, y;\n    D(): x(0), y(0) {}\n    D(int x, int y): x(x), y(y) {}\n    D(P p): x(p.first), y(p.second){}\n    D& operator+=( D& v) { x += v.x; y += v.y; return *this;}\n    D operator+( D& v)  { return D(*this) += v;}\n    D& operator-=( D& v) { x -= v.x; y -= v.y; return *this;}\n    D operator-( D& v)  { return D(*this) -= v;}\n    D& operator*=(int s) { x *= s; y *= s; return *this;}\n    D operator*(int s)  { return D(*this) *= s;}\n    D& operator/=(int s) { x /= s; y /= s; return *this;}\n    D operator/(int s)  { return D(*this) /= s;}\n    bool operator==(D & v) {return x == v.x && y == v.y;}\n    bool operator!=(D & v) {return !operator==(v);}\n    //内積\n    int dot( D& v)  { return x*v.x + y*v.y;}\n    //外積\n    int cross( D& v)  { return x*v.y - v.x*y;}\n    int cross( int rx,int ry)  { return x*ry - rx*y;}\n    //距離の2乗\n    int norm2()  { return x*x + y*y;}\n    double norm()  { return sqrt(norm2());}\n    //単位ベクトルを返す\n    D unit(){return (*this)/ norm();}\n    // 象限\n    int ort()  {        if (abs(x) < eps && abs(y) <= eps) return 0;        if (y > 0) return x>0 ? 1 : 2;        else return x<0 ? 3 : 4;    }\n    int ort(int x,int y)  {        if (abs(x) < eps && abs(y) <= eps) return 0;        if (y > 0) return x>0 ? 1 : 2;        else return x<0 ? 3 : 4;    }\n    //偏角でソート出来る\n    bool operator<(const D &v) const {return x == v.x ? y < v.y : x < v.x;}\n    bool operator>(D &v) {return x == v.x ? y > v.y : x > v.x;}\n    /*@formatter:off*/\n    //反時計回りで隣接する象限との境界にある、長さ1の点を返す\n    //(+,+)で呼ぶと(0, 1)が返る\n    D ort_bound_next(){        int i=ort();        assert(i);        return D(ort_next_[i]);    }\n    //時計回り\n    D ort_bound_prev(){        int i=ort();        assert(i);        return D(ort_prev_[i]);    }\n};\n//反時計回り\nclass rot {//@formatter:off\n    vector<vc> pre;//今が斜めでないときは使えない\n    int preAdd=0;    void rot90() {        preAdd += 2;        swap(H, W);        vvc(nv, H, W);        rep(fh, W) {            rep(fw, H) {                int th = H - fw - 1;                int tw = fh;                nv[th][tw] = v[fh][fw];            }        }        swap(v, nv);    }    void rot180() {        preAdd += 4;        vvc(nv, H, W);        rep(fh, H) {            rep(fw, W) {                int th = H - fh - 1;                int tw = W - fw - 1;                nv[th][tw] = v[fh][fw];            }        }        swap(v, nv);    }    void rot270() {        preAdd += 6;        swap(H, W);        vvc(nv, H, W);        rep(fh, W) {            rep(fw, H) {                int th = fw;                int tw = W - 1 - fh;                nv[th][tw] = v[fh][fw];            }        }        swap(v, nv);    }\npublic:\n    vector<vc> v;\n    int H, W;\n    bool naname = 0;\n    rot(vector<vc> &b) : v(b), H(sz(b)), W(sz(b[0])) {}\n    P rot45(int h, int w) { return P(h - w + W - 1, h + w); }\n    P rot45_rev(int h, int w) { return P(h + w, -h + w + H - 1); }\n    rot &operator++() {        /*preを90度回転させる*/        if (naname) {            H = sz(pre[0]);            W = sz(pre);            vvc(nv, H, W);            rep(fh, W) {                rep(fw, H) {                    int th = H - fw - 1;                    int tw = fh;                    nv[th][tw] = pre[fh][fw];                }            }            swap(pre, v);            swap(v, nv);            naname ^= 1;            operator+=(preAdd);            preAdd = 0;            return *this;        } else {            int NH = H + W - 1;            int NW = H + W - 1;            vvc(a, NH, NW);            /*h += Wとする*/            rep(h, H) {                rep(w, W) {                    int nh, nw;                    tie(nh, nw) = rot45(h, w);                    a[nh][nw] = v[h][w];                }            }            swap(a, v);            swap(pre, a);            H = NH;            W = NW;            naname ^= 1;            return *this;        }    }\n    rot operator++(signed) {        rot ret = *this;        operator++();        return ret;    }\n    rot operator+(int k) {        rot ret = *this;        ret.operator+=(k);        return ret;    }\n    void operator+=(int k) {        k %= 8;        if (k >= 6) {            rot270();            k -= 6;        } else if (k >= 4) {            rot180();            k -= 4;        } else if (k >= 2) {            rot90();            k -= 2;        }        if (k)operator++();    }\n    /*反時計回りで統一しないと、preがおかしくなる*/\n    /*preを廃止して遷移するのは実装がつらい上に見返りが少なそう*/\n    /*必要になったら作る*/\n    rot &operator--() {        rot270();        return operator++();    }\n    rot operator--(signed) {        rot ret = *this;        operator--();        return ret;    }\n    rot operator-(int k) {        rot ret = *this;        ret.operator-=(k);        return ret;    }\n    void operator-=(int k) { operator+=(((-k % 8) + 8) % 8); }\n    int size() { return H; }\n    vector<vector<char>>& operator()(){return v;}\n    vc &operator[](int i) { return v[i]; }\n    operator vector<vc> &() { return v; }\n};\nostream &operator<<(ostream &os, rot &v) {os << v.v;return os;}\nusing dots = vector<D>;\n//線分\nstruct E { D f, t; E(D f = D(), D t = D()) : f(f), t(t) {}};\nbool eq(dots &a, dots &b) {    if (sz(a) != sz(b))return false;    rep(i, sz(a)) { if (a[i] != b[i])return false; }    return true;}\n//fを中心として、tを90*inc度 反時計回りに回転\nD rot90(D &f, D &t, int inc) {    inc=((inc % 4)+4)%4;    D ret = t - f;    if (inc < 0) {        while (inc) {            ret = D(ret.y, -ret.x);            inc++;        }    } else if (inc > 0) {        while (inc > 0) {            ret = D(-ret.y, ret.x);            inc--;        }    }    return f + ret;}\ndots rot90(D &f, dots &t, int inc) {    int N = sz(t);    dots res(N);    rep(i, N) { res[i] = rot90(f, t[i], inc); }    return res;}\nistream &operator>>(istream &ist, D &v) {    ist >> v.x >> v.y;    return ist;}ostream &operator<<(ostream &os, D &v) {    os << \"(\" << v.x << \",\" << v.y << \")\";    return os;}\nvector<D> operator-=(dots &a, D &b) {    fora(v, a) { v -= b; }    return a;}\nvector<D> operator-(dots &a, D &b) {    dots c(sz(a));    int i = 0;    fora(v, a) { c[i++] = v - b; }    return c;}\n/*@formatter:on*/\nP rot90(const P &p, int inc) {\n    P now = p;\n    inc = ((inc % 4) + 4) % 4;\n    auto rot = [&](P &now) {\n        int y, x;\n        tie(y, x) = now;\n        now = P(x, -y);\n    };\n    while (inc--)rot(now);\n    return now;\n}\n/*@formatter:off*/\n//Pはh, wで渡す その他は不明\n\n/*@formatter:on*/\n//反時計回り\n//y軸からx軸にかけての回転なので、右下へ向かう場合は時計回りになる事に注意\nvoid solve() {\n    //現在の方向p, dをマージ\n    while (cin >> W >> H, H && W) {\n        vvi(S);\n        nt(S, H, W);\n        auto mix = [&](P p, int d) {\n            if (d == 0)return p;\n            if (d == 1)return rot90(p, 1);\n            if (d == 2)return rot90(p, 2);\n            if (d == 3)return rot90(p, 3);\n            if (d == 4)return P(0, 0);\n        };\n\n        vi C;\n        na(C, 4);\n        C += linf;\n        VEC<VEC<map<P, int>>> dp;\n        resize(dp, H, W);\n        rep(h, H)\n            rep(w, W) {\n                dp[h][w][mp(0, 0)] = linf;\n                dp[h][w][mp(0, 1)] = linf;\n                dp[h][w][mp(0, -1)] = linf;\n                dp[h][w][mp(1, 0)] = linf;\n                dp[h][w][mp(-1, 0)] = linf;\n            }\n        dp[0][0][mp(0, 1)] = 0;\n        using T =tuple<int, int, int, P>;\n        priority_queue<T, vector<T>, greater<T> > q;//小さい順\n        int cost = linf;\n        q.push(mt(0, 0, 0, mp(0, 1)));\n        while (sz(q)) {\n            int c;\n            int h, w;\n            P d;\n            tie(c, h, w, d) = q.top();\n            q.pop();\n            if (cost < c)continue;\n            vi C2 = C;\n            C2[S[h][w]] = 0;\n            rep(adi, 4) {\n                P nd = mix(d, adi);\n                int nc = c + C2[adi];\n                int nh, nw;\n                tie(nh, nw) = mp(h, w) + nd;\n                if (!inside(nh, nw, H, W))continue;\n                if (nh == h && nw == w)continue;\n                if (chmi(dp[nh][nw][nd], nc)) {\n                    if (nh == H - 1 && nw == W - 1) {\n                        chmi(cost, nc);\n                    }\n                    q.push(mt(nc, nh, nw, nd));\n                }\n            }\n        }\n        int mi = linf;\n        chmi(mi, dp[H - 1][W - 1][mp(0, 0)]);\n        chmi(mi, dp[H - 1][W - 1][mp(0, 1)]);\n        chmi(mi, dp[H - 1][W - 1][mp(0, -1)]);\n        chmi(mi, dp[H - 1][W - 1][mp(1, 0)]);\n        chmi(mi, dp[H - 1][W - 1][mp(-1, 0)]);\n        out(mi);\n    }\n}\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\n\nint const N = 30;\nint const Ord = 4;\nint const inf = std::numeric_limits<int>::max() - 500000;\n\nint const x_diff[] = {1, 0, -1, 0};\nint const y_diff[] = {0, 1, 0, -1};\n\n\nclass robot\n{\npublic:\n    robot( int x, int y, int dir )\n        : x_(x)\n        , y_(y)\n        , dir_(dir)\n    {}\n\n    bool operator<(robot const&) const{ return true; }\n\npublic:\n    void forward()\n    {\n        x_ += x_diff[dir_];\n        y_ += y_diff[dir_];\n    }\n\n    bool right_forward()\n    {\n        turn_right(); \n        forward();\n    }\n\n    void back()\n    {\n        turn_right(); turn_right(); \n        forward();\n    }\n\n    bool left_forward()\n    {\n        turn_left(); \n        forward();\n    }                       \n\n\n    int x() const { return x_; }\n    int y() const { return y_; }\n    int dir() const { return dir_; }\n\nprivate:\n    void turn_right()\n    {\n        ++dir_;\n        if ( dir_ > 3 )\n            dir_ = 0;\n    }\n\n    void turn_left()\n    {\n        --dir_;\n        if ( dir_ < 0 )\n            dir_ = 3;\n    }\n\nprivate:\n    int x_, y_, dir_;\n};\n\n\n\nrobot forward( robot const& r )\n{\n    robot d(r);\n    d.forward();\n\n    return d;\n}\n\nrobot right_forward( robot const& r )\n{\n    robot d(r);\n    d.right_forward();\n\n    return d;\n}\n\nrobot back( robot const& r )\n{\n    robot d(r);\n    d.back();\n\n    return d;\n}\n\nrobot left_forward( robot const& r )\n{\n    robot d(r);\n    d.left_forward();\n\n    return d;\n}\n\nrobot do_action( robot const& r, int const id )\n{\n    switch( id )\n    {\n    case 0:\n        return forward( r );\n    case 1:\n        return right_forward( r );\n    case 2:\n        return back( r );\n    case 3:\n        return left_forward( r );\n    }\n\n    return r;\n}\n\n\n\n\nint main()\n{\n    using namespace std;\n\n    for(;;)   \n    {\n        int table[N][N]; //x ,y\n        int c[Ord];\n\n        int w, h;\n        cin >> w >> h;\n\n        if ( w == 0 && h == 0 )\n            break;\n\n        for( int i=0; i<h; ++i )\n            for( int j=0; j<w; ++j )\n                cin >> table[j][i]; // set [x, y]\n\n        for( int i=0; i<Ord; ++i ) {\n            cin >> c[i];\n        }\n\n        int const g_x = w - 1;\n        int const g_y = h - 1;\n\n \n        int cost[N][N][Ord]; // x, y ,dir\n        fill( &cost[0][0][0], &cost[0][0][0]+N*N*Ord, inf );\n\n        robot const base_r( 0, 0, 0 );\n        cost[base_r.x()][base_r.y()][base_r.dir()] = 0;\n\n        typedef std::pair<int, robot> data_set;\n        priority_queue<data_set, vector<data_set>, greater<data_set> > q;\n        q.push( make_pair( 0, base_r ) );\n        \n        for(;;) {\n            robot const r = q.top().second;\n            int const r_cost = q.top().first;\n            \n            if ( r.x() == g_x && r.y() == g_y )\n                break;\n\n            q.pop();\n  \n            int per_cost[Ord];\n            per_cost[0] = c[0];       // Forward\n            per_cost[1] = c[1];       // Right\n            per_cost[2] = c[2];       // Back\n            per_cost[3] = c[3];       // Left\n\n            int const action = table[r.x()][r.y()]; \n            if ( action != 4 ) {\n                per_cost[action] = 0;\n            }\n            \n\n\n            for( int act_id=0; act_id<Ord; ++act_id ) {\n                robot const d = do_action( r, act_id );\n\n                if ( d.x() < 0 || d.y() < 0 || d.x() >= w || d.y() >= h )\n                    continue;\n\n                if ( cost[d.x()][d.y()][d.dir()] > r_cost + per_cost[act_id] ) {\n                    cost[d.x()][d.y()][d.dir()] = r_cost + per_cost[act_id];\n                    q.push( make_pair( cost[d.x()][d.y()][d.dir()], d ) );\n                }\n            }\n        }\n\n\n        cout << q.top().first << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool solve(){\n  int w,h,c[4];\n  int mm[SIZE][SIZE];\n  int dp[SIZE][SIZE][4];\n\n  scanf(\"%d%d\",&w,&h);\n  \n  if(w == 0) return false;\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\"%d\",mm[i]+j);\n\n      for(int k=0;k<4;k++)\n        dp[i][j][k] = -INF;\n    }\n  }\n\n  for(int i=0;i<4;i++)\n    scanf(\"%d\",c+i);\n  \n  priority_queue<pair<pair<int,int>,pair<int,int> > > pq;\n\n  pq.push({{0,0},{0,0}});\n\n  while(pq.size()){\n    int y = pq.top().second.first;\n    int x = pq.top().second.second;\n    int d = pq.top().first.second;\n    int sum_c = pq.top().first.first;\n    pq.pop();\n    \n    if(y == h-1 && x == w-1){\n      printf(\"%d\\n\",-sum_c);\n      return true;\n    }\n\n    if(dp[y][x][d] != -INF) continue;\n\n    dp[y][x][d] = -sum_c;\n\n    //floor\n    if(mm[y][x] != 4){\n      int next_d = (d+mm[y][x])%4;\n      \n      if(0 <= y+dy[next_d] && y+dy[next_d] < h &&\n         0 <= x+dx[next_d] && x+dx[next_d] < w){\n        pq.push({{sum_c,next_d},{y+dy[next_d], x+dx[next_d]}});\n      }\n    }\n\n    \n    for(int i=0;i<4;i++){\n      int next_d = (d+i)%4;\n      if(0 <= y+dy[next_d] && y+dy[next_d] < h &&\n         0 <= x+dx[next_d] && x+dx[next_d] < w){\n        pq.push({{sum_c-c[i],next_d},{y+dy[next_d], x+dx[next_d]}});\n      }\n    }\n    \n  }\n\n  assert(false);\n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<set>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int H = 33;\n\nclass P{\n\tpublic:\n\tint x,y,dir,val;\n\tP(int x,int y,int dir,int val):x(x),y(y),dir(dir),val(val){}\n\tbool operator<(const P& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\nint w,h;\nint masu[H][H];\nint cost[4];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvoid initQue(priority_queue<P>& que){\n\tque.push(P(0,0,0,0));\n}\n\nvoid addQue(priority_queue<P>& que, P& u){\n\t\n\tint ndx = dx[u.dir];\n\tint ndy = dy[u.dir];\n\t\n\tfor(int i=0;i<4;i++){\n\t\t\n\t\tint c = cost[i];\n\t\tif(i==masu[u.y][u.x])c = 0;\n\t\t\n\t\tque.push(P(u.x+ndx, u.y+ndy, (u.dir+i)%4, u.val+c));\n\t\t\n\t\tint temp = ndx;\n\t\tndx = -ndy;\n\t\tndy = temp;\n\t}\n}\n\nbool isGoal(P& u){\n\treturn u.x==w-1 && u.y==h-1;\n}\n\nint visit[H][H][4];\nint solve(){\n\trep(i,h)rep(j,w)cin>>masu[i][j];\n\t\n\tpriority_queue<P> que;\n\tinitQue(que);\n\t\n\trep(i,4)cin>>cost[i];\n\t\n\trep(i,H)rep(j,H)rep(k,4)visit[i][j][k]=0;\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tP u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(u.x<0 || u.y<0 || u.x>=w || u.y>=h)continue;\n\t\t\n\t\tif(visit[u.x][u.y][u.dir]==1)continue;\n\t\tvisit[u.x][u.y][u.dir]=1;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\",u.x,u.y,u.dir,u.val);\n\t\t\n\t\tif(isGoal(u)){\n\t\t\treturn u.val;\n\t\t}\n\t\t\n\t\taddQue(que,u);\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#define pb push_back\n#define F first\n#define S second\n#define INF (1<<26)\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {-1,0,1,0};\nint w,h;\nint imap[30][30];\nint c[4],d[30][30][5];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint get_dir(int x,int y){\n  if(y == 0){\n    return x;\n  }\n  else if(y == 1){\n    return (x+1)%4;\n  }\n  else if(y == 2){\n    return (x+2)%4;\n  }\n  else if(y == 3){\n    return (x+3)%4;\n  }\n  else if(y == 4){\n    return -1;\n  }\n \n  assert(true);\n}\n\nint get_c_index(int x,int y){\n  if(x == y)return 0;\n  if((x+1)%4 == y)return 1;\n  if((x+2)%4 == y)return 2;\n  if((x+3)%4 == y)return 3;\n  assert(true);\n}\n\n\nint main(){\n\n  while(true){\n    scanf(\"%d %d\",&w,&h);\n    if(w+h == 0)break;\n    rep(i,h)rep(j,w)rep(k,5)d[i][j][k] = INF;\n    rep(i,h)rep(j,w)scanf(\"%d\",&imap[i][j]);\n \n    scanf(\"%d %d %d %d\",&c[0],&c[1],&c[2],&c[3]);\n   \n    int men = INF;\n    queue<PP> que;\n    que.push(insert(0,0,1,0));\n    d[0][0][4] = 0;\n\n    while(!que.empty() ){\n      PP pp = que.front(); que.pop();\n\n    if(pp.F.F == w-1 && pp.F.S == h-1){\n\tmen = min(men,pp.S.S);\n\tcontinue;\n      }\n      if(men <= pp.S.S)continue;\n      \n      int dir = get_dir(pp.S.F,imap[pp.F.S][pp.F.F]);\n      //cout <<\"---------- \" << \"pp = \" << pp.F.F << \",\" << pp.F.S << endl;\n      rep(i,4){\n\tint nx = pp.F.F+dx[i],ny = pp.F.S+dy[i];\n\tif(!(0<=nx && nx<w && 0<=ny && ny<h))continue;\n\n\t// cout << \"nx = \"<< nx << \", ny = \" << ny <<\", pp.S.S = \" <<pp.S.S <<\",pp.S.S+c[\"<<i<<\"] = \" << pp.S.S+c[i] << endl;\n\tif(dir == i){\n\n\t  if(d[ny][nx][i] > pp.S.S){\n\t    d[ny][nx][i] = pp.S.S;\n\t    que.push(insert(nx,ny,i,pp.S.S));\n\t  }\n\t}\n\telse{\n\t  int ind = get_c_index(pp.S.F,i); \n\t\n\t  if(d[ny][nx][i] > pp.S.S+c[ind]){\n\t    d[ny][nx][i] = pp.S.S+c[ind];\n\t    que.push(insert(nx,ny,i,pp.S.S+c[ind]));\n\t  }\n\t}\n      }\n\n    }\n\n\n\n\n    //  int mine = INF;\n    //rep(i,4)mine = min(d[h-1][w-1][i],mine);\n\tcout << men << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#include <map>\ntypedef pair<int,int>Pos;\ntypedef pair<Pos,int>p;\ntypedef pair<int,p>P;\n#define C top().first\n#define X top().second.first.first\n#define Y top().second.first.second\n#define Z top().second.second\n#define mp(a,b,c,d) make_pair(a,make_pair(make_pair(b,c),d))\n#define Push(a,b,c,d) push(mp(a,b,c,d))\n\nint xv[]={0,1,0,-1};\nint yv[]={-1,0,1,0};\n\n\nint main(){\n\tfor(int W,H;cin>>W>>H,W;){\n\t\tint M[32][32],F[32][32][4];\n\t\tmemset(M,-1,sizeof(M));\n\t\tmemset(F,-1,sizeof(F));\n\t\tfor(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>M[j][i];\n\t\tpriority_queue<P, vector<P>, greater<P> > Q;\n\t\tQ.Push(0,1,1,1);\n\t\tint L[4];\n\t\tfor(int i=0;i<4;i++)cin>>L[i];\n\t\t\n\t\tfor(int c,x,y,z;!Q.empty();){\n\t\t\tc=Q.C;\n\t\t\tx=Q.X;\n\t\t\ty=Q.Y;\n\t\t\tz=Q.Z;\n\t\t\tQ.pop();\n\t\t\tif(x==W&&y==H){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(F[x][y][z]<0){\n\t\t\t\t//cout<<\"$\"<<endl;\n\t\t\t\tF[x][y][z]=c;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx,ny,nz;\n\t\t\t\t\tif(i==0)nz=z;\n\t\t\t\t\tif(i==1)nz=(z+1)%4;\n\t\t\t\t\tif(i==2)nz=(z+2)%4;\n\t\t\t\t\tif(i==3)nz=(z+3)%4;\n\t\t\t\t\tnx=x+xv[nz];\n\t\t\t\t\tny=y+yv[nz];\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(M[nx][ny]>=0&&((M[x][y]==i?c:c+L[i])<F[nx][ny][nz]||F[nx][ny][nz]<0)){\n\t\t\t\t\t\tQ.Push((M[x][y]==i?c:c+L[i]),nx,ny,nz);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nstruct robot{\n\tint dir;\n\tint x;\n\tint y;\n\tint cost;\n\trobot(int a,int b,int c,int d):dir(a),x(b),y(c),cost(d){}\n};\nint w,h;\nint s[30][30];\nint dp[30][30][4];\nint c[4];\nvector<int> ans;\nqueue<robot> q;\n\nvoid bfs(){\n\twhile(q.size()){\n\t\trobot aa=q.front();q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint t=(i+aa.dir)%4;\n\t\t\tint nx=aa.x+dx[t];\n\t\t\tint ny=aa.y+dy[t];\n\t\t\tif(!(0<=nx&&nx<w&&0<=ny&&ny<h)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i==s[aa.y][aa.x]){\n\t\t\t\tif(aa.cost<dp[ny][nx][t]){\n\t\t\t\t\tq.push(robot(t,nx,ny,aa.cost));\n\t\t\t\t\tdp[ny][nx][t]=aa.cost;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(aa.cost+c[i]<dp[ny][nx][t]){\n\t\t\t\t\tq.push(robot(t,nx,ny,aa.cost+c[i]));\n\t\t\t\t\tdp[ny][nx][t]=aa.cost+c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\t\t\t\nint main(){\n\twhile(1){\n\t\twhile(q.size())q.pop();\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)return 0;\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0][0][1]=0;\n\t\tq.push(robot(1,0,0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tcin>>c[i];\n\t\t}\n\t\tbfs();\n\t\t\n\t\tans.push_back(min(dp[h-1][w-1][1],dp[h-1][w-1][2]));\n\t\tcout<<min(dp[h-1][w-1][1],dp[h-1][w-1][2])<<endl;\n\t}\n\t/*for(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i]<<endl;\n\t}*/\n\treturn 0;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<pair<int, int>, pair<int, int> > pii; // cost, from, x, y\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nint INF = 10e8;\nint w, h;\nint map[30][30][4];\nint cmap[30][30][4];\nint c[4];\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0) break;\n\n        REP(i, h) REP(j, w) REP(k, 4) map[i][j][k] = INF;\n        REP(i, h){\n            REP(j, w){\n                int s;\n                cin >> s;\n                if(s<=3){\n                    map[i][j][s] = 0;\n                }\n            }\n        }\n\n        REP(i, 4) cin >> c[i];\n        REP(i, h) REP(j, w) REP(k, 4) map[i][j][k] = min(map[i][j][k], c[k]);\n\n        REP(i, h) REP(j, w) REP(k, 4) cmap[i][j][k] = INF;\n        cmap[0][0][1] = 0;\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        que.push(pii(make_pair(0, 1), make_pair(0, 0)));\n        while(!que.empty()){\n            pii p = que.top();\n            que.pop();\n            int cost = p.first.first;\n            int from = p.first.second;\n            int x = p.second.first;\n            int y = p.second.second;\n            REP(i, 4){\n                int nx = x+dx[(i+from)%4];\n                int ny = y+dy[(i+from)%4];\n                if(nx>=0 && ny>=0 && nx<w && ny<h){\n                    if(cmap[ny][nx][(i+from)%4] > map[y][x][i] + cost){\n                        cmap[ny][nx][(i+from)%4] = map[y][x][i] + cost;\n                        que.push(pii(make_pair(cmap[ny][nx][(i+from)%4], (i+from)%4), make_pair(nx, ny)));\n                    }\n                }\n            }\n        }\n\n        /*\n        REP(i, h){\n            REP(j, w){\n                int out = INF;\n                REP(k, 4) out = min(cmap[i][j][k], out);\n                cout << out;\n            }\n            cout << endl;\n        }\n        */\n\n        int output = INF;\n        REP(i, 4) output  = min(output, cmap[h-1][w-1][i]);\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nint main(){\n    int w,h;\n    int s[31][31];\n    int d[5][31][31];\n    int c[5];\n    while(true){\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tREP(i,h)REP(j,w){\n\t    cin >> s[i][j];\n\t    REP(k,5)\n\t\td[k][i][j] = INF;\n\t}\n\tREP(i,4) cin >> c[i];\n\tc[4] = 0;\n\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qv;\n\tqueue<int> qs;\n\tqxy.push(MP(0,0));\n\tqv.push(0);\n\tqs.push(0);\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int v = qv.front();\n\t    int st = qs.front();\n\t    qxy.pop();\n\t    qv.pop();\n\t    qs.pop();\n\t    REP(i,5){\n\t\tint nx,ny;\n\t\tint nv = v;\n\t\tint nst;\n\t\tif(i != 4 && s[y][x] != 4){\n\t\t    nst = (st+i)%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t    nv = v + c[i];\n\t\t}else{\n\t\t    nst = (st+s[y][x])%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t}\n\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\tif(nv < d[nst][ny][nx]){\n\t\t    d[nst][ny][nx] = nv;\n\t\t    qxy.push(MP(nx,ny));\n// \t\t    printf(\"x = %d y = %d v = %d s = %d i = %d\\n\",nx,ny,nv,nst,i);\n\t\t    qv.push(nv);\n\t\t    qs.push(nst);\n\t\t}\n\t    }\n\t}\n\tint ans = INF;\n\tREP(i,5) ans = min(ans,d[i][h-1][w-1]);\n\tcout << ans << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nconst int INF = 1<<29;\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int change_d[5] = {0, 1, 2, 3, 0};\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    int ope[31][31], dist[31][31][4], ch_cost[4];\n    REP(i, h) REP(j, w) cin >> ope[i][j];\n    REP(i, 4) cin >> ch_cost[i];\n    REP(i, h) REP(j, w) REP(k, 4) dist[i][j][k] = INF;\n    dist[0][0][1] = 0;\n    priority_queue<T> pque;\n    pque.push(T(0, 0, 1));\n    while (!pque.empty()) {\n      int d, r, c, dir;\n      tie(d, r, dir) = pque.top(); pque.pop();\n      d = -d, c = r % w, r /= w;\n      //cout << c << ',' << r << ',' << dir << ':' << d << endl;\n      if (dist[r][c][dir] < d) continue;\n      int default_d = ope[r][c] != 4 ? (dir + change_d[ope[r][c]]) % 4 : 4;\n      REP(i, 4) {\n\tint nd = (dir + i) % 4, nr = r + dr[nd], nc = c + dc[nd], cost = (nd == default_d ? 0 : ch_cost[i]);\n\t//cout << nr << ',' << nc << endl;\n\tif (0 <= nr && nr < h && 0 <= nc && nc < w && dist[nr][nc][nd] > d + cost) {\n\t  dist[nr][nc][nd] = d + cost;\n\t  pque.push(T(-dist[nr][nc][nd], nr * w + nc, nd));\n\t}\n      }      \n    }\n    int ret = INF;\n    REP(i, 4) ret = min(ret, dist[h-1][w-1][i]);\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nclass State {\npublic:\n  int cost;\n  int dir;\n  int x;\n  int y;\n  State(int cost, int dir, int x, int y) : cost(cost), dir(dir), x(x), y(y) {}\n  bool operator <(const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(x != s.x) return x > s.x;\n    if(y != s.y) return y > s.y;\n    if(dir != s.dir) return dir > s.dir;\n    return false;\n  }\n};\n\nint main() {\n  while(1) {\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    int data[h][w];\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> data[i][j];\n      }\n    }\n\n    int c[4];\n    for(int i = 0; i < 4; i++) {\n      cin >> c[i];\n    }\n\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n    priority_queue<State> PQ;\n    PQ.push(State(0, 0, 0, 0));\n    set<State> visited;\n    while(!PQ.empty()) {\n      State s = PQ.top();\n      PQ.pop();\n      if(visited.find(s) != visited.end()) continue;\n      visited.insert(s);\n      if(s.x == w-1 && s.y == h-1) {\n\tcout << s.cost << endl;\n\tbreak;\n      }\n      for(int i = 0; i < 4; i++) {\n\tint dir;\n\tswitch(i) {\n\tcase 0: dir = s.dir;break;\n\tcase 1: dir = (s.dir+1)%4;break;\n\tcase 2: dir = (s.dir+2)%4;break;\n\tcase 3: dir = (s.dir+3)%4;break;\n\t}\n\tint nx = s.x + d[dir][0];\n\tint ny = s.y + d[dir][1];\n\tif(nx < 0 || nx >= w) continue;\n\tif(ny < 0 || ny >= h) continue;\n\tPQ.push(State(s.cost+c[i], dir, nx, ny));\n      }\n      int dir;\n      if(data[s.y][s.x] != 4) {\n\tswitch(data[s.y][s.x]) {\n\tcase 0: dir = s.dir;break;\n\tcase 1: dir = (s.dir+1)%4;break;\n\tcase 2: dir = (s.dir+2)%4;break;\n\tcase 3: dir = (s.dir+3)%4;break;\n\t}\n\tint nx = s.x + d[dir][0];\n\tint ny = s.y + d[dir][1];\n\tif(nx < 0 || nx >= w) continue;\n\tif(ny < 0 || ny >= h) continue;\n\tPQ.push(State(s.cost, dir, nx, ny));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int MAX = 31;\nconst int MAX_D = 4;\nconst int INF = 1<<27;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint cost[MAX][MAX][MAX_D],g[MAX][MAX],order[MAX_D];\nint n,m;\n\nstruct State{\n  int x,y,d,cost;\n  State(){}\n  State(int _x,int _y,int _d,int _cost) : x(_x), y(_y) ,d(_d), cost(_cost){}\n\n  bool operator > (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint ans(){\n  priority_queue<State,vector<State>, greater<State> >Q; \n  fill(cost[0][0],cost[MAX][0],INF);\n  Q.push(State(0,0,0,0));\n  cost[0][0][0] = 0;\n\n  while(!Q.empty()){\n    const State t = Q.top(); Q.pop();\n    if(t.x == m-1 && t.y == n-1) return t.cost;\n    for(int i = 0 ; i < 4 ; i++){\n      State u = t;\n      u.cost += (g[t.y][t.x] == i ? 0 : order[i]);\n      u.d = (t.d + i) % 4;\n      u.x += dx[u.d],u.y += dy[u.d];\n      if(0 <= u.y && u.y < n && 0 <= u.x && u.x < m &&\n\t cost[u.y][u.x][u.d] > u.cost){\n\tcost[u.y][u.x][u.d] = u.cost;\n\tQ.push(u);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin >> m >> n ,n+m){\n    for(int i = 0 ; i < n ; i++)\n      for(int j = 0 ; j < m ; j++)\n\tcin >> g[i][j];\n\n    for(int i = 0 ; i < 4 ; i++) cin >> order[i];\n\n    cout << ans() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint w,h,s[30][30],c[4],d[30][30][4],ans; //d[pos][dir]:=位置posに向きdirで入るための最小コスト\n\nint encode(int y,int x){\n    return w*y+x;\n}\n\npii decode(int pos){\n    return pii(pos/w,pos%w);\n}\n\nvoid dijkstra(){\n    ans=inf;\n    fill_n((int*)d,900*4,inf);\n    d[0][0][0]=0;\n    //using triple=tuple<int,int,int>;\n    typedef tuple<int,int,int> triple;\n    priority_queue<pair<int,triple>,vector<pair<int,triple>>,greater<pair<int,triple>>> que;\n    while(!que.empty()){\n        pair<int,triple> p=que.top(); que.pop();\n        int dist=p.first;\n        int y=get<0>(p.second),x=get<1>(p.second),dir=get<2>(p.second);\n\n        if(y==h-1 and x==w-1){\n            ans=min(ans,dist);\n            continue;\n        }\n        if(dist>d[y][x][dir]) continue;\n\n        rep(i,0,4){\n            int cost=c[i],ndir=(dir+i)%4;\n            if(i==s[y][x]) cost=0;\n\n            int ny=y+dy[ndir],nx=x+dx[ndir];\n            if(ny<0 or h<=ny or nx<0 or w<=nx) continue;\n            if(dist+cost<d[ny][nx][ndir]){\n                d[ny][nx][ndir]=dist+cost;\n                que.push(make_pair(d[ny][nx][ndir],triple(ny,nx,ndir)));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n\n        rep(y,0,h) rep(x,0,w) cin >> s[y][x];\n        rep(i,0,4) cin >> c[i];\n\n        dijkstra();\n\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define INF INT_MAX\nint G[30][30];\nint c[4];\n//\nconst int dirx[] = {-1, 0, 1, 0};\nconst int diry[] = { 0,-1, 0, 1};\n\nclass State{\n  public:\n    int x;\n    int y;\n    int dir;\n    int cost;\n    State(int x, int y, int dir, int cost){\n      this->x=x;this->y=y;this->dir=dir;this->cost=cost;\n    }\n    bool operator < (const State &s)const{\n      return cost > s.cost;\n    }\n};\n\nint main(void){\n  int w, h;\n  while(cin >> w >> h, w | h){\n    for(int i=0; i < h; i++){\n      for(int j=0; j < w; j++){\n        cin >> G[i][j];\n      }\n    }\n    for(int i=0; i < 4; i++){\n      cin >> c[i];\n    }\n\n    int d[30][30][4];\n    vector<vector <bool> > used(30, vector<bool>(30, false));\n    fill(d[0][0], d[0][0] + 30*30*4, INF);\n    d[0][0][2] = 0;\n    priority_queue<State> pq;\n    pq.push(State(0, 0, 2, 0));\n    while(!pq.empty()){\n      State s = pq.top(); pq.pop();\n      used[s.y][s.x] = true;\n      for(int i=0; i < 4; i++){\n        int ndir = (s.dir+i) % 4;\n        int nx = s.x + dirx[ndir]; int ny = s.y + diry[ndir];\n        if(!(nx >= 0 && nx < w && ny >= 0 && ny < h)) continue;\n        if(G[s.y][s.x] == i){\n          if(d[s.y][s.x][s.dir] < d[ny][nx][ndir]){\n            d[ny][nx][ndir] = d[s.y][s.x][s.dir];\n            pq.push(State(nx, ny, ndir, d[ny][nx][ndir]));\n          }\n        }else{\n          if(d[s.y][s.x][s.dir] + c[i] < d[ny][nx][ndir]){\n            d[ny][nx][ndir] = d[s.y][s.x][s.dir] + c[i];\n            pq.push(State(nx, ny, ndir, d[ny][nx][ndir]));\n          }\n        }\n      }\n    }\n    cout << min(d[h-1][w-1][0], min(d[h-1][w-1][1], min(d[h-1][w-1][2], d[h-1][w-1][3]))) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n \nusing namespace std;\n \n#define MAX_H 30\n#define MAX_W 30\n#define INF (1<<29)\n \nstruct State{\n    int cost,x,y,dir;\n    State(int cost,int x,int y,int dir) :\n\tcost(cost),x(x),y(y),dir(dir) {}\n \n    bool operator < (const State &s)const{\n\treturn cost > s.cost;\n    }\n};\n \nint H,W,c[4];\nint s[MAX_H][MAX_W];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n \nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n \nint dijkstra(){\n    int d[MAX_H][MAX_W][4];\n    fill(d[0][0],d[0][0]+MAX_H*MAX_W*4,INF);\n    d[0][0][2] = 0;\n    priority_queue<State> Q;\n    Q.push(State(0,0,0,2));\n    while(!Q.empty()){\n\tState cur = Q.top(); Q.pop();\n\tint x = cur.x,y = cur.y,dir = cur.dir;\n\tif(d[y][x][dir] < cur.cost) continue;\n\tif(x == W-1 && y == H-1) return d[y][x][dir];\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    int ndir = (dir+i)%4;\n\t    int nx = x + dx[ndir];\n\t    int ny = y + dy[ndir];\n\t    if(!inField(nx,ny)) continue;\n\t    if(s[y][x] == i){\n\t\tif(d[y][x][dir] < d[ny][nx][ndir]){\n\t\t    d[ny][nx][ndir] = d[y][x][dir];\n\t\t    Q.push(State(d[ny][nx][ndir],nx,ny,ndir));\n\t\t}\n\t    }else{\n\t\tif(d[y][x][dir] + c[i] < d[ny][nx][ndir]){\n\t\t    d[ny][nx][ndir] = d[y][x][dir] + c[i];\n\t\t    Q.push(State(d[ny][nx][ndir],nx,ny,ndir));\n\t\t}\n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    while(true){\n\tcin >> W >> H;\n\tif(W == 0 && H == 0) break;\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> s[i][j];\n\t    }\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    cin >> c[i];\n\t}\n\tcout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, -1, 0, 1 };\nstruct state{\n\tint x;\n\tint y;\n\tint way;\n\tint cost;\n\tbool operator<(const state &right) const{\n\t\treturn cost != right.cost ? cost > right.cost : x != right.x ? x < right.x : y != right.y ? y < right.y : way<right.way;\n\t}\n};\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w){\n\t\tvector<vector<int>> cell(h, vector<int>(w));\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tcin >> cell[i][j];\n\t\t\t}\n\t\t}\n\t\tint com[4];\n\t\tREP(i, 4)\n\t\t\tcin >> com[i];\n\t\tvector<vector<vector<int>>> memo(h, vector<vector<int>>(w,vector<int>(4,100000)));\n\t\tmemo[0][0][2] = 0;\n\t\tpriority_queue<state> Q;\n\t\tQ.push({0,0,2,0});\n\t\tint ans=-1;\n\t\twhile (!Q.empty()){\n\t\t\tstate q = Q.top(); Q.pop();\n\t\t\tif (q.x == w - 1 && q.y == h - 1){\n\t\t\t\tans = q.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tREP(i,4){\n\t\t\t\tif (0 <= q.x + dx[(q.way + i) % 4] && q.x + dx[(q.way + i) % 4] < w && 0 <= q.y + dy[(q.way + i) % 4] && q.y + dy[(q.way + i) % 4] < h)\n\t\t\t\t\t\tif (memo[q.y + dy[(q.way + i) % 4]][q.x + dx[(q.way + i) % 4]][(q.way + i) % 4] > q.cost + (i == cell[q.y][q.x] ? 0 : com[i])){\n\t\t\t\t\t\t\tmemo[q.y + dy[(q.way + i) % 4]][q.x + dx[(q.way + i) % 4]][(q.way + i) % 4] = q.cost + (i == cell[q.y][q.x] ? 0 : com[i]);\n\t\t\t\t\t\t\tQ.push({ q.x + dx[(q.way + i) % 4], q.y + dy[(q.way + i) % 4], (q.way + i) % 4, q.cost + (i == cell[q.y][q.x] ? 0 : com[i]) });\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint m[33][33];\nmap<char,vector<vector<int>>> c;\n\n/*\n0: ?????´????????????\n1: ??????????????????\n2: ????????¢?????????\n3: ??????????????????\n4: ????????¢?????????\n*/\n\nstruct Point{ int x, y; };\nint dy[5] = {-1,0,1,0,-100}, dx[5] = {0,1,0,-1,-100};\nchar ch[5] = \"nwse\";\nint mc[4];\nint h, w;\nint limit;\n\nint direction(int com, char dis){\n    if(dis == 'n') return com;\n    else if(dis == 'w') return (com + 1) % 4;\n    else if(dis == 's') return (com + 2) % 4;\n    else if(dis == 'e') return (com + 3) % 4;\n    else return 4;\n}\n\nvoid dfs(int y, int x, char dis, int cost, int k){\n    //cout << y << ' ' << x << endl;\n    //show(m[y][x])\n    //    show(dis)\n    if(k > w * h) return;\n    if(cost > limit) return;\n\n    rep(i,4){\n        int p = direction(i,dis);\n        int ny = y + dy[p];\n        int nx = x + dx[p];\n        int next_cost = cost + (i == m[y][x] ? 0 : mc[i]);\n\n        if(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n        if(c[ch[p]][ny][nx] <= next_cost) continue;\n        c[ch[p]][ny][nx] = next_cost;\n        dfs(ny,nx,ch[p], next_cost, k + 1);\n    }\n}\n\nint main(){\n    while(scanf(\"%d%d\",&w,&h),h){\n        rep(k,4) c[ ch[k] ] = vector<vector<int>>(33,vector<int>(33));\n        rep(k,4) rep(i,h) rep(j,w) c[ch[k]][i][j] = INF;\n        c['w'][0][0] = 0;\n\n        rep(i,h) rep(j,w) scanf(\"%d\",&m[i][j]);\n        rep(i,4) scanf(\"%d\",&mc[i]);\n        limit = mc[0] * (h + w) + min(mc[1],mc[3]);\n\n        dfs(0, 0, 'w', 0, 0);\n\n        //rep(i,h){ rep(j,w){ cout << c['w'][i][j] << ' '; } cout << endl; }\n\n        int mini = INF;\n        rep(i,4) mini = min(mini, c[ch[i]][h - 1][w - 1]);\n        cout << mini << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nclass TwirlingRobot {\npublic:\n\n    int w, h;\n    int p(int i, int j, int k) {\n      return i*w*h + j*w + k;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      while(true) {\n        cin >> w >> h;\n        if (w==0 && h==0) return;\n\n        int dp[4*h*w];\n        int mat[h][w];\n        vector<P> graph[4*h*w];\n\n        rep(j, h) {\n          rep(k, w) {\n            cin >> mat[j][k];\n          }\n        }\n\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n\n        rep(i, 4*h*w) {\n          dp[i] = INT_MAX/2;\n        }\n        // right: 0\n        // down: 1\n        // left: 2\n        // up: 3\n        dp[0] = 0;\n\n        rep(j, h) {\n          rep(k, w) {\n            // straight;\n            int aa = a;\n            int bb = b;\n            int cc = c;\n            int dd = d;\n            if (mat[j][k] == 0) aa = 0;\n            if (mat[j][k] == 1) bb = 0;\n            if (mat[j][k] == 2) cc = 0;\n            if (mat[j][k] == 3) dd = 0;\n            // move right\n            if (k+1<w) {\n              graph[p(0, j, k)].emplace_back(p(0, j, k+1), aa);\n              graph[p(1, j, k)].emplace_back(p(0, j, k+1), dd);\n              graph[p(2, j, k)].emplace_back(p(0, j, k+1), cc);\n              graph[p(3, j, k)].emplace_back(p(0, j, k+1), bb);\n            }\n            // down\n            if (j+1<h) {\n              graph[p(0, j, k)].emplace_back(p(1, j+1, k), bb);\n              graph[p(1, j, k)].emplace_back(p(1, j+1, k), aa);\n              graph[p(2, j, k)].emplace_back(p(1, j+1, k), dd);\n              graph[p(3, j, k)].emplace_back(p(1, j+1, k), cc);\n            }\n            // move left\n            if (k>0) {\n              graph[p(0, j, k)].emplace_back(p(2, j, k-1), cc);\n              graph[p(1, j, k)].emplace_back(p(2, j, k-1), bb);\n              graph[p(2, j, k)].emplace_back(p(2, j, k-1), aa);\n              graph[p(3, j, k)].emplace_back(p(2, j, k-1), dd);\n            }\n            // up\n            if (j>0) {\n              graph[p(0, j, k)].emplace_back(p(3, j-1, k), dd);\n              graph[p(1, j, k)].emplace_back(p(3, j-1, k), cc);\n              graph[p(2, j, k)].emplace_back(p(3, j-1, k), bb);\n              graph[p(3, j, k)].emplace_back(p(3, j-1, k), aa);\n            }\n          }\n        }\n\n        priority_queue<P, vector<P>, greater<>> que;\n        que.emplace(0, 0);\n        dp[0] = 0;\n        while(!que.empty()) {\n          auto p = que.top(); que.pop();\n          if (p.first > dp[p.second]) continue;\n          for(const auto& e: graph[p.second]) {\n            if (dp[e.first] > p.first + e.second) {\n              dp[e.first] = p.first + e.second;\n              que.emplace(dp[e.first], e.first);\n            }\n          }\n        }\n\n        int ans = INT_MAX;\n        rep(i, 4) {\n          chmin(ans, dp[p(i, h-1, w-1)]);\n        }\n        cout << ans << endl;\n      }\n\n    }\n};\n\nsigned main() {\n  TwirlingRobot solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nenum { STRAIGHT, RIGHT, BACK, LEFT, D };\n\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nconstexpr int MAX_SIZE = 30;\n\nint w, h;\nint s[MAX_SIZE][MAX_SIZE];\nint c[D];\n\nint dist[MAX_SIZE][MAX_SIZE][D];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nint dijkstra() {\n\ttypedef tuple<int, int, int, int> state;\n\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INT_MAX);\n\n\tque.push(state(0, 0, 0, 0));\n\tdist[0][0][0] = 0;\n\n\twhile(!que.empty()) {\n\t\tint d, x, y, dir;\n\t\ttie(d, x, y, dir) = que.top();\n\t\tque.pop();\n\n\t\tif(dist[x][y][dir] < d) continue;\n\t\tif(x == w - 1 && y == h - 1) return d;\n\n\t\tfor(int command = 0; command < 4; ++command) {\n\t\t\tconst int next_dir = (dir + command) & 0x3;\n\t\t\tconst int nx = x + dx[next_dir];\n\t\t\tconst int ny = y + dy[next_dir];\n\n\t\t\tif(out(nx, ny)) continue;\n\n\t\t\tconst int next_dist = d + (s[y][x] == command ? 0 : c[command]);\n\t\t\tif(dist[nx][ny][next_dir] > next_dist) {\n\t\t\t\tdist[nx][ny][next_dir] = next_dist;\n\t\t\t\tque.push(state(next_dist, nx, ny, next_dir));\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h && w) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < D; ++i) {\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tcout << dijkstra() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nint c[4];\n\nstruct State{\n\tint x,y,d,cost;\n};\n\n\nbool operator < (const State a, State b){\n\treturn a.cost>b.cost;\n}\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid calc(int w,int h){\n\tint direction[30][30];\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tcin>>direction[j][i];\n\n\tfor(int i=0;i<4;i++)\n\t\tcin>>c[i];\n\n\tpriority_queue<State> Q;\n\tbool costmap[30][30][4];\n\n\tfor(int i=0;i<30;i++)\n\t\tfor(int j=0;j<30;j++)\n\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\tcostmap[i][j][z]=false;\n\n\tcostmap[0][0][0]=true;\n\n\tState first;\n\tfirst.x=first.y=first.cost=first.d=0;\n\tQ.push(first);\n\n\tState k;\n\twhile(!Q.empty()){\n\t\tk=Q.top();\n\t\tQ.pop();\n\t\tcostmap[k.x][k.y][k.d]=true;\n\t\tif(k.x==w-1 && k.y==h-1)\n\t\t\tbreak;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx,ty,td,tcost;\n\t\t\tState temp;\n\t\t\ttd=(k.d+i)%4;\n\t\t\ttx=k.x+dx[td];\n\t\t\tty=k.y+dy[td];\n\t\t\tif(tx<0 || ty<0 || tx>=w || ty>=h)\n\t\t\t\tcontinue;\n\t\t\ttcost=k.cost;\n\t\t\tif(direction[k.x][k.y]!=i)\n\t\t\t\ttcost+=c[i];\n\t\t\ttemp.x=tx;\n\t\t\ttemp.y=ty;\n\t\t\ttemp.d=td;\n\t\t\ttemp.cost=tcost;\n\t\t\tif(!costmap[temp.x][temp.y][temp.d])\n\t\t\t\tQ.push(temp);\n\t\t}\n\t}\n\n\tcout<<k.cost<<\"\\n\";\n}\n\nint main(){\n\tint w,h;\n\tcin>>w>>h;\n\twhile(w!=0){\n\t\tcalc(w,h);\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\ntypedef pair<mp,mp> mmp;\nint dx[] = {0,1,0,-1};//h\nint dy[] = {1,0,-1,0};//w\n\nint main(){\n\twhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tpriority_queue<mmp,vector<mmp> ,greater<mmp> > q;\n\tvector<vector<vector<int> > > dp(h+2,vector<vector<int> >(w+2,vector<int>(4,inf ) ) );\n\tvector<vector<int> > s(h+2,vector<int>(w+2,0) );\n\tint c[4];\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)cin>>c[i];\n\n\t//dp[1][1] = 0;\n\tq.push(mmp(mp(0,0),mp(1,1) ));\n\tint res = inf;\n\twhile(!q.empty()){\n\t\tmmp now = q.top();\n\t\tq.pop();\n\t\tint cost = now.first.first;\n\t\tint dir = now.first.second;\n\t\tint x = now.second.first;\n\t\tint y = now.second.second;\n\t\tif(cost >= dp[x][y][dir])continue;\n\t\tdp[x][y][dir] = cost;\n\t\tif(s[x][y]!=4){\n\t\t\tint nd = (dir+s[x][y])%4;\n\t\t\tint nx = x+dx[nd];\n\t\t\tint ny = y+dy[nd];\n\t\t\tif(1<=nx&&nx<=h&&1<=ny&&ny<=w){\n\t\t\t\tq.push(mmp(mp(cost,nd),mp(nx,ny) ) );\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nc = cost+c[i];\n\t\t\tint nd = (dir+i)%4;\n\t\t\tint nx = x+dx[nd];\n\t\t\tint ny = y+dy[nd];\n\t\t\tif(1<=nx&&nx<=h&&1<=ny&&ny<=w){\n\t\t\t\tq.push(mmp(mp(nc,nd),mp(nx,ny) ) );\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tres = min(res,dp[h][w][i]);\n\t}\n\tcout<<res<<endl;\n\t/*\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcout<<dp[i][j]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n#include <queue>\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nusing namespace std;\n\n// avoid name conflict\n#define left  LEFT\n#define right RIGHT\n\nint W, H;\nconst int dx[] = {  0,  0, -1,  1 };\nconst int dy[] = { -1,  1,  0,  0 };\nenum direction { up, down, left, right };\nconst direction rgt[] = { right, left, up, down };\nconst direction bck[] = { down, up, right, left };\nconst direction lft[] = { left, right, down, up };\nstruct state { int x, y; direction d; };\nbool is_valid(const state & s) { return 0 <= s.y and s.y < H and 0 <= s.x and s.x < W and 0 <= s.d and s.d < 4; }\nint encode(const state & s) { assert (is_valid(s)); return s.y*W*4 + s.x*4 + s.d; }\nbool operator < (const state & a, const state & b) { return encode(a) < encode(b); }\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    W = 3; H =4;\n    while (true) {\n        cin >> W >> H;\n        if (W == 0 and H == 0) break;\n        vector<vector<int> > S(W, vector<int>(H));\n        repeat (h,H) repeat (w,W) cin >> S[w][h];\n        vector<int> C(4); repeat (i,4) cin >> C[i];\n\n        vector<bool> used(W*H*4);\n        priority_queue<pair<ll,state>, vector<pair<ll,state> >, greater<pair<ll,state> > > que;\n        que.push(make_pair(0, (state) { 0, 0, right }));\n        while (true) {\n            const ll cost = que.top().first;\n            const state s = que.top().second;\n            que.pop();\n            if (s.x == W-1 and s.y == H-1) {\n                cout << cost << endl;\n                break;\n            }\n            if (not used[encode(s)]) {\n                used[encode(s)] = true;\n                repeat (instr,4) {\n                    state t = s;\n                    switch (instr) {\n                        case 0: break; // straight\n                        case 1: t.d = rgt[t.d]; break; // right\n                        case 2: t.d = bck[t.d]; break; // back\n                        case 3: t.d = lft[t.d]; break; // left\n                        default: assert(false);\n                    }\n                    t.x += dx[t.d];\n                    t.y += dy[t.d];\n                    if (is_valid(t)) {\n                        ll dcost = instr == S[s.x][s.y] ? 0 : C[instr];\n                        if (not used[encode(t)]) {\n                            que.push(make_pair(cost+dcost, t));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 10000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost>right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4];\n      int ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(d[ny][nx][ndir]>cost+c[i]){\n\td[ny][nx][ndir]=cost+c[i];\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n      if(data[y][x]!=i) continue;\n      if(d[ny][nx][ndir]>cost){\n\td[ny][nx][ndir]=cost;\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n    }\n  }\n  int mincost=INF;\n  for(int i=0;i<4;i++)\n    mincost=min(mincost,d[h-1][w-1][i]);\n  cout<<mincost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n  int x, y, d, cost;\n  State(){}\n  State(int x_, int y_, int d_, int cost_) : x(x_), y(y_), d(d_), cost(d_) {}\n  bool operator>(const State& s) const {\n    return cost>s.cost;\n  }\n};\n\nconst int SIZE = 31;\nconst int INF = 1<<27;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint H, W;\nint G[SIZE][SIZE], C[4];\n\nbool inField(int x, int y) {\n  return 0<=x && x<W && 0<=y & y<H;\n}\n\nint dijkstra() {\n  int cost[4][SIZE][SIZE];\n  \n  priority_queue<State, vector<State>, greater<State> > pq;\n  \n  fill(cost[0][0], cost[4][0], INF);\n  pq.push(State(0,0,0,0));\n  cost[0][0][0] = 0;\n\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    \n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      t.cost += i == G[s.y][s.x] ? 0 : C[i];\n      if(inField(t.x, t.y) && cost[t.d][t.y][t.x] > t.cost) {\n\tpq.push(t);\n\tcost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n  \n  return -1;\n}\n\nint main() {\n  \n  while( cin >> W >> H, W+H ) {\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n\tcin >> G[i][j];\n      }\n    }\n    for(int i=0; i<4; i++) cin >> C[i];\n    \n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint mem[40][40][4],m[40][40];\n\nint turn(int d,int ord){\n\tswitch(ord){\n\tcase 0: return d;\n\tcase 1:\n\t\tif(d==0)return 2;\n\t\tif(d==1)return 3;\n\t\tif(d==2)return 1;\n\t\tif(d==3)return 0;\n\tcase 2: return d^1;\n\tcase 3:\n\t\tif(d==0)return 3;\n\t\tif(d==1)return 2;\n\t\tif(d==2)return 0;\n\t\tif(d==3)return 1;\n\t}\n\tassert(0);\n}\n\nint main() {\n\tint w,h,cost[4];\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h)rep(j,w)rep(k,4)mem[i][j][k]=INF;\n\t\trep(i,h)rep(j,w)cin>>m[i][j];\n\t\trep(i,4)cin>>cost[i];\n\t\tpriority_queue<pair<int,pair<pint,int> >,vector<pair<int,pair<pint,int> > >,greater<pair<int,pair<pint,int> > > > que;\n\t\tque.push(MP(0,MP(MP(0,0),0)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,pair<pint,int> > now=que.top();\n\t\t\tque.pop();\n\t\t\tint c=now.first,x=now.second.first.second,y=now.second.first.first,d=now.second.second;\n\t\t\tif(x<0||w<=x||y<0||h<=0)continue;\n\t\t\tif(mem[y][x][d]<=c)continue;\n\t\t\tmem[y][x][d]=c;\n\t\t\trep(ord,4){\n\t\t\t\tint nd=turn(d,ord);\n\t\t\t\tque.push(MP(c+(ord!=m[y][x]?cost[ord]:0),MP(MP(y+dy[nd],x+dx[nd]),nd)));\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\trep(i,4)chmin(res,mem[h-1][w-1][i]);\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 1000000000\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<int> > s(h, vector<int>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tint cc[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcin >> cc[i];\n\t\t}\n\t\tvector< vector< vector<long long int> > > dp(h, vector< vector<long long int> >(w, vector<long long int>(4, INF)));\n\t\tdp[0][0][0] = 0;\n\t\tint dx[] = { 1, 0, -1, 0 };\n\t\tint dy[] = { 0, 1, 0, -1 };\n\t\tbool hh = true;\n\t\twhile (hh) {\n\t\t\thh = false;\n\t\t\tvector< vector< vector<long long int> > > dp2;\n\t\t\tdp2 = dp;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tfor (int kk = 0; kk < 4; kk++) {\n\t\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << ' ' << kk << endl;\n\t\t\t\t\t\t\tint mm = (k + kk) % 4;\n\t\t\t\t\t\t\tint cost = cc[kk];\n\t\t\t\t\t\t\tif (s[i][j] == kk) {\n\t\t\t\t\t\t\t\tcost = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (0 <= j+dx[mm] && j+dx[mm] < w && 0 <= i+dy[mm] && i+dy[mm] < h && dp2[i+dy[mm]][j+dx[mm]][mm] > dp[i][j][k]+cost) {\n\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t\tdp2[i + dy[mm]][j + dx[mm]][mm] = dp[i][j][k] + cost;\n\t\t\t\t\t\t\t\t//cout << i + dy[mm] << ' ' << j + dx[mm] << ' ' << dp2[i + dy[mm]][j + dx[mm]][mm] << endl;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp2;\n\t\t}\n\t\tcout << min(dp[h - 1][w - 1][0], min(dp[h - 1][w - 1][1], min(dp[h - 1][w - 1][2], dp[h - 1][w - 1][3]))) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int INF = 1000000000;\ntypedef pair<int, int> P;\n\nint w, h, s[30][30], c[4];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ndir[4] = {2, 3, 0, 1};\n\nint getNum(int y, int x, int dir) { // dir: 0=right, 1=down, 2=left, 3=up\n  return (y * w + x) * 4 + dir;\n}\n\nint V;\nstruct edge { int to, cost; };\nvector<edge> G[3601];\nint d[3601];\n\nint dijkstra() {\n  for (int i = 0; i < V; i++) d[i] = INF;\n  d[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0, 0));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int num = p.second;\n    if (d[num] < p.first) continue;\n    for (int i = 0; i < G[num].size(); i++) {\n      edge e = G[num][i];\n      int to = e.to, cost = e.cost;\n      if (d[to] > d[num] + cost) {\n        d[to] = d[num] + cost;\n        que.push(P(d[to], to));\n      }\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i < 4; i++) ans = min(ans, d[getNum(h - 1, w - 1, i)]);\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    V = w * h * 4;\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) scanf(\"%d\", &s[i][j]);\n    for (int i = 0; i < 4; i++) scanf(\"%d\", &c[i]);\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n      for (int k = 0; k < 4; k++) for (int r = 0; r < 4; r++) {\n        int dir = (k + r) % 4;\n        int ny = i + dy[dir], nx = j + dx[dir];\n        if (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n        int cost = c[r];\n        if (s[i][j] == r) cost = 0;\n        edge e; e.cost = cost; e.to = getNum(ny, nx, dir);\n        G[getNum(i, j, k)].push_back(e);\n      }\n    }\n    printf(\"%d\\n\", dijkstra());\n    for (int i = 0; i < w * h * 4; i++) G[i].clear();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Twirling Robot\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1156&lang=jp\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\n\nconst int INF = (int)1e9;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint dc[] = {0, 1, 2, 3, 0};\n\nstruct P {\n  int x, y, w;\n  int cost;\n\n  bool operator >(const P& p) const {\n    if (cost == p.cost) return x + y > p.x + p.y;\n    return cost > p.cost;\n  }\n};\n\nint main() {\n  int w, h;\n  int c[4];\n\n  while(cin >> w >> h, w | h) {\n    vvi field(h, vi(w, 4));\n    REP(y, h){\n      REP(x, w){\n        cin >> field[y][x];\n      }\n    }\n    REP(i, 4){\n      cin >> c[i];\n    }\n\n    vector<vvi> G(h, vvi(w, vi(4, INF)));\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({0, 0, 2, 0});\n    G[0][0][2] = 0;\n\n    while(!que.empty()) {\n      P p = que.top(); que.pop();\n\n      if (p.x == w - 1 && p.y == h - 1) {\n        cout << p.cost << endl;\n        break;\n      }\n\n      if (field[p.y][p.x] != 4) {\n        int sw = (p.w + dc[field[p.y][p.x]]) % 4;\n        int sx = p.x + dx[sw];\n        int sy = p.y + dy[sw];\n        int sc = p.cost;\n        if (0 <= sx && 0 <= sy && sx < w && sy < h) {\n          if (G[sy][sx][sw] > sc) {\n            G[sy][sx][sw] = sc;\n            que.push({sx, sy, sw, sc});\n          }\n        }\n      }\n      REP(i, 4){\n        int sw = (p.w + dc[i]) % 4;\n        int sx = p.x + dx[sw];\n        int sy = p.y + dy[sw];\n        int sc = p.cost + c[i];\n        if (0 <= sx && 0 <= sy && sx < w && sy < h) {\n          if (G[sy][sx][sw] > sc) {\n            G[sy][sx][sw] = sc;\n            que.push({sx, sy, sw, sc});\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<pint,pint> ppi;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\npint ss[2001];\nint s[31][31],c[4];\nint d[1001][4];\nint INF=1000100010;\nint n,w,h;\nint dijkstra(){\n    priority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n    rep(i,n)rep(j,4) d[i][j]=INF;\n    d[w+1][0]=0;\n    pq.push({{0,0},{0,1}});\n    while(!pq.empty()){\n        ppi pi=pq.top();pq.pop();\n        int cost=pi.first.first,dr=pi.first.second;\n        int x=pi.second.first,y=pi.second.second;\n        int tx=x+dx[dr],ty=y+dy[dr];\n        if(tx>0&&tx<=w&&ty>0&&ty<=h){\n            if(ty==h&&tx==w) return cost;\n            rep(i,4){\n                if(i==s[ty][tx]){\n                    int tt=0;\n                    if(d[tx+ty*(w+1)][(dr+i)%4]>cost+tt){\n                        d[tx+ty*(w+1)][(dr+i)%4]=cost+tt;\n                        pq.push({{cost+tt,(dr+i)%4},{tx,ty}});\n                    }\n                }\n                else{\n                    int tt=c[i];\n                    if(d[tx+ty*(w+1)][(dr+i)%4]>cost+tt){\n                        d[tx+ty*(w+1)][(dr+i)%4]=cost+tt;\n                        pq.push({{cost+tt,(dr+i)%4},{tx,ty}});\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    while(cin>>w>>h,w|h){\n        n=(w+1)*(h+1);\n        rep(i,h)rep(j,w){\n            cin>>s[i+1][j+1];\n        }\n        rep(i,4) cin>>c[i];\n        cout<<dijkstra()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nint dw[4] = {1,0,-1,0};\nint dh[4] = {0,1,0,-1};\nint brd[50][50];\nint c[4];\nint cost[4][50][50];//dir*50*50+h*50+w\n\nvoid solve(){\n\trep(i,4) rep(j,50) rep(k,50) cost[i][j][k] = INF;\n\trep(i,h) rep(j,w) cin >> brd[i][j];\n\trep(i,4) cin >> c[i];\n\tcost[0][0][0] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0,0));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tint dir = q.second/2500, hh = (q.second%2500)/50, ww = q.second%50;\n\t\trep(i,4){\n\t\t\tint co, di;\n\t\t\tif(i == brd[hh][ww]) co = 0;\n\t\t\telse co = c[i];\n\t\t\tdi = (dir+i)%4;\n\t\t\tif(0>hh+dh[di]||hh+dh[di]>=h||0>ww+dw[di]||ww+dw[di]>=w) continue;\n\t\t\tif(cost[di][hh+dh[di]][ww+dw[di]] <= cost[dir][hh][ww]+co) continue;\n\t\t\tcost[di][hh+dh[di]][ww+dw[di]] = cost[dir][hh][ww]+co;\n\t\t\tque.push(P(cost[di][hh+dh[di]][ww+dw[di]],di*2500+(hh+dh[di])*50+ww+dw[di]));\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,4) ans = min(ans,cost[i][h-1][w-1]);\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> w  >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tsolve();\n\t}\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)a); --i)\n#define sz(x) ((int)x.size())\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, s.size()) {\n        char x = s[i];\n        if (p == 0 && x == ',') {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#ifdef LOCAL\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n#else\n#define dump(...)\n#endif\n\nconst int INF = 1e9;\n\ntemplate <class T>\nbool chmin(T &a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool inrange(int x, int l, int r) {\n    return l <= x && x < r;\n}\n\nconst int DY[] = {-1, 0, 1, 0};\nconst int DX[] = {0, 1, 0, -1};\n\nint rot(int dir, int type) {\n    if (type == 0) return dir;\n    if (type == 1) return (dir + 1) % 4;\n    if (type == 2) return (dir + 2) % 4;\n    if (type == 3) return (dir + 3) % 4;\n    if (type == 4) return -1;\n    assert(false);\n}\n\nvoid solve(int W, int H) {\n    vvi B(H, vi(W));\n    rep(i, 0, H) rep(j, 0, W) cin >> B[i][j];\n    vi C(5);\n    rep(i, 0, 4) cin >> C[i];\n    C[4] = 0;\n\n    vector<vvi> dist(H, vvi(W, vi(4, INF)));\n    dist[0][0][1] = 0;\n    using dijkstra_state = tuple<int, int, int, int>;\n    priority_queue<dijkstra_state, vector<dijkstra_state>, greater<>> pq;\n    pq.push(dijkstra_state(0, 0, 0, 1));\n    while (sz(pq)) {\n        int cur_dist, y, x, dir;\n        tie(cur_dist, y, x, dir) = pq.top(); pq.pop();\n        if (cur_dist > dist[y][x][dir]) continue;\n        rep(r, 0, 5) {\n            int dd = (r < 4 ? rot(dir, r) : rot(dir, B[y][x]));\n            if (dd == -1) {\n                continue;\n            }\n            int yy = y + DY[dd];\n            int xx = x + DX[dd];\n            if (inrange(yy, 0, H) && inrange(xx, 0, W)) {\n                if (chmin(dist[yy][xx][dd], dist[y][x][dir] + C[r])) {\n                    pq.push(dijkstra_state(dist[yy][xx][dd], yy, xx, dd));\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i, 0, 4) chmin(ans, dist[H - 1][W - 1][i]);\n    cout << ans << endl;\n}\n\nsigned main() {\n    while (1) {\n        int W, H;\n        cin >> W >> H;\n        if (W == 0 && H == 0) break;\n        solve(W, H);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\n\nint G[SIZE][SIZE], C[4];\nint H, W;\n\nclass State {\npublic:\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost>s.cost;\n  }\n};\n\nint solve() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State> pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n\t && 0 <= t.y && t.y < H \n\t && cost[t.d][t.y][t.x] > t.cost) {\n\tpq.push(t);\n\tcost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n  \n  return INF;\n}\n\nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n\tcin >> G[i][j];\n    \n    for(int i=0; i<4; i++) cin >> C[i];\n    \n    cout << solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint w,h;\nint board[31][31];\nint c[4];\n\n// dir : ??? 0,??? 1,??? 2,??? 3\nP next(P p,int &dir,int cmd) {\n    if(cmd==1) {\n        dir++;\n    }\n    else if(cmd==2) {\n        dir+=2;\n    }\n    else if(cmd==3) {\n        dir--;\n    }\n\n    while(dir<0) dir+=4;\n    dir%=4;\n    p.fr+=dy[dir];\n    p.sc+=dx[dir];\n\n    return p;\n}\n\nint bfs() {\n    map<Pi,int> d;\n    queue<Pi> que;\n    que.push(Pi(P(0,0),0));\n    rep(y,h) rep(x,w) rep(k,4) d[Pi(P(y,x),k)]=INF;\n    d[Pi(P(0,0),0)]=0;\n    while(que.size()) {\n        Pi p=que.front();\n        que.pop();\n        int y=p.fr.fr;\n        int x=p.fr.sc;\n        int dir=p.sc;\n        int cmd=board[y][x];\n\n        //printf(\"[debug] %d,%d,%d : %d\\n\",y,x,dir,d[p]);\n        if(cmd!=4) {\n            Pi next_p={next(p.fr,dir,cmd),0};\n            next_p.sc=dir;\n\n            if(0<=next_p.fr.fr<h && 0<=next_p.fr.sc<w && d[next_p]>d[p]) {\n                d[next_p]=min(d[next_p],d[p]);\n                que.push(next_p);\n            }\n        }\n        rep(i,4) {\n            dir=p.sc;\n            Pi next_p={next(p.fr,dir,i),0};\n            next_p.sc=dir;\n            if(0<=next_p.fr.fr<h && 0<=next_p.fr.sc<w && d[next_p]>d[p]+c[i]) {\n                d[next_p]=min(d[next_p],d[p]+c[i]);\n                que.push(next_p);\n            }\n        }\n    }\n    int ret=INF;\n    rep(i,4) if(d.count(Pi(P(h-1,w-1),i))) {\n        //printf(\"%d %d\\n\",i,d[Pi(P(h-1,w-1),i)]);\n        ret=min(ret,d[Pi(P(h-1,w-1),i)]);\n    }\n\n    return ret;\n}\nvoid solve() {\n    rep(y,h) rep(x,w) cin>>board[y][x];\n    rep(i,4) cin>>c[i];\n    int ans=bfs();\n\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>w>>h) {\n        if(!w) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define N_MAX 30\n#define INF (1e9)\nusing namespace std;\nvoid dijkstra();\nint w,h,data[N_MAX][N_MAX],d[N_MAX][N_MAX][4],c[4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\ntypedef struct stu{\n  int mincost,y,x,dir;\n  bool operator<(const stu & right)const{\n    return mincost<right.mincost;\n  }\n} dat;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>data[i][j];\n    for(int i=0;i<4;i++) cin>>c[i];\n    dijkstra();\n  }\n  return 0;\n}\n\nvoid dijkstra(){\n  priority_queue<dat > Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  d[0][0][1]=0;\n  Q.push((dat){0,0,0,1});\n  while(!Q.empty()){\n    dat t=Q.top(); Q.pop();\n    int cost=t.mincost,y=t.y,x=t.x,dir=t.dir;\n    if(cost>d[y][x][dir]) continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[(dir+i)%4],nx=x+dx[(dir+i)%4];\n      int ndir=(dir+i)%4;\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(d[ny][nx][ndir]>cost+c[i]){\n\td[ny][nx][ndir]=cost+c[i];\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n      if(data[y][x]!=i) continue;\n      if(d[ny][nx][ndir]>cost){\n\td[ny][nx][ndir]=cost;\n\tQ.push((dat){d[ny][nx][ndir],ny,nx,ndir});\n      }\n    }\n  }\n  int mincost=INF;\n  for(int i=0;i<4;i++)\n    mincost=min(mincost,d[h-1][w-1][i]);\n  cout<<mincost<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 1<<28;\nint w, h;\nint bd[32][32];\nint cost[4];\nint dist[32][32][4];\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nstruct node {\n  int y, x, dir, d;\n  node(int y, int x, int dir, int d) : y(y), x(x), dir(dir), d(d) {}\n  bool operator>(const node &n) const { return this->d > n.d; }\n};\n\nint solve() {\n  for (int i = 0; i < 32; i++)\n    for (int j = 0; j < 32; j++)\n      for (int k = 0; k < 4; k++)\n        dist[i][j][k] = INF;\n\n  priority_queue<node, vector<node>, greater<node> > Q;\n  Q.push(node(0, 0, 0, 0));\n  dist[0][0][0] = 0;\n\n  while (!Q.empty()) {\n    int y = Q.top().y;\n    int x = Q.top().x;\n    int dir = Q.top().dir;\n    int d = Q.top().d;\n    Q.pop();\n\n    if (d > dist[y][x][dir])\n      continue;\n\n    for (int i = 0; i < 4; i++) {\n      int c = bd[y][x] == i ? 0 : cost[i];\n      int k = (dir + i) % 4;\n      int xt = x + dx[k];\n      int yt = y + dy[k];\n      int dt = d + c;\n\n      if (yt < 0 || yt >= h || xt < 0 || xt >= w)\n        continue;\n      if (dist[yt][xt][k] > dt) {\n        dist[yt][xt][k] = dt;\n        Q.push(node(yt, xt, k, dt));\n      }\n    }\n  }\n\n  int ret = INF;\n  for (int i = 0; i < 4; i++)\n    ret = min(ret, dist[h-1][w-1][i]);\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  while (~scanf(\" %d %d\", &w, &h)) {\n    if (!w && !h)\n      break;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        scanf(\" %d\", bd[i] + j);\n      }\n    }\n    for (int i = 0; i < 4; i++)\n      scanf(\" %d\", cost + i);\n    int ret = solve();\n    printf(\"%d\\n\", ret);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define pb push_back\n\n#define MAX 30\nint W, H;\nint S[MAX][MAX];\nint C[4];\n\n\ntypedef pair<int,int> pi;\nint B[MAX][MAX][4];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint main()\n{\n  \n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)return 0;\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      scanf(\"%d\",&S[i][j]);\n\t      rep(k,4)\n\t\t{\n\t\t  B[i][j][k]=114514;\n\t\t}\n\t    }\n\t}\n      rep(i,4)\n\t{\n\t  scanf(\"%d\", &C[i]);\n\t}\n      //int dir = 0;\n\n      queue<pi> Q;\n      B[0][0][0]=0;\n      Q.push(pi(0,0));\n      queue<int> R;\n      R.push(0);\n      int ans = 114514;\n      while(!Q.empty())\n\t{\n\t  int y = Q.front().first;\n\t  int x = Q.front().second;\n\t  Q.pop();\n\t  int r = R.front();\n\t  R.pop();\n\t  if(y==H-1 && x==W-1)\n\t    {\n\t      ans=min(ans,B[y][x][r]);\n\t      continue;\n\t    }\n\t  \n\t  int cost;\n\t  rep(i,4)\n\t    {\n\t      if(S[y][x]==i)cost=0;\n\t      else cost = C[i];\n\n\t      int dir = (r+i)%4;\n\t      int ty = y + dy[dir];\n\t      int tx = x + dx[dir];\n\t      if(ty<0 || ty>=H || tx<0 || tx>=W)continue;\n\t      if(B[ty][tx][dir]>B[y][x][r]+cost)\n\t\t{\n\t\t  Q.push(pi(ty,tx));\n\t\t  R.push(dir);\n\t\t  B[ty][tx][dir]=B[y][x][r]+cost;\n\t\t  //printf(\"ty=%d,tx=%d,dis=%d,dir=%d,y=%d,x=%d,r=%d\\n\",ty,tx,B[ty][tx][dir],dir,y,x,r);\n\t\t}\n\t    }\n\t \n\t  \n\t}\n      printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <math.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n//typedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\n#define INIT INF\ntypedef int Weight;\ntypedef pair<P,P> PP;\ntypedef vector< vector< vector<Weight> > > DIST;\n\n// ^0 >1 v2 <3\n\nint w,h;\nint fld[30][30];\nint change_dir[4];\nint convert_x[]={0,1,0,-1},convert_y[]={-1,0,1,0};\n\nbool check(int x,int y) {\n\tif(x<0||x>=w||y<0||y>=h) return false;\n\treturn true;\n}\n\nvoid dijkstra(const int fld[30][30],DIST &dist) {\n\tdist.assign(h,vector< vector<Weight> >(w,vector<Weight>(4,INIT)));\n\tdist[0][0][1]=0;\n\tpriority_queue< PP,vector<PP>,greater<PP> > Q;\n\tQ.push(PP(P(0,1),P(0,0)));\n\twhile(!Q.empty()) {\n\t\tPP p=Q.top();Q.pop();\n\t\tint cost=p.fi.fi,from_dir=p.fi.se,x=p.se.fi,y=p.se.se;\n\t\tint cur_dir=(from_dir+fld[y][x])%4;\n\t\tif(dist[y][x][from_dir]<cost) continue;\n\t\tREP(i,4) {\n\t\t\tint nx=x+convert_x[i],ny=y+convert_y[i];\n\t\t\tif(!check(nx,ny)) continue;\n\t\t\tif(i==cur_dir&&fld[y][x]!=4) {\n\t\t\t\tif(dist[ny][nx][i]<=cost) continue;\n\t\t\t\tdist[ny][nx][i]=cost;\n\t\t\t\tQ.push(PP(P(dist[ny][nx][i],i),P(nx,ny)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint new_cost=change_dir[(i-from_dir+4)%4];\n\t\t\t\tif(dist[ny][nx][i]<=cost+new_cost) continue;\n\t\t\t\tdist[ny][nx][i]=cost+new_cost;\n\t\t\t\tQ.push(PP(P(dist[ny][nx][i],i),P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\tcin>>w>>h;\n\tif(w==0&&h==0) break;\n\tREP(i,h) REP(j,w) cin>>fld[i][j];\n\tREP(i,4) cin>>change_dir[i];\n\tDIST dist(h,vector< vector<Weight> >(w,vector<Weight>(4)));\n\tdijkstra(fld,dist);\n\tint ans=INF;\n\tREP(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 31;\nconst int MAX_DIR=5;\nconst int INF = 1<<28;\n\n\n\nint h,w;\nint c[4]={0};\n\nstruct state{\n\tint x,y,dir,cost;\n\tstate(int t_x,int t_y,int t_dir,int t_cost){\n\t\tx=t_x;y=t_y;dir=t_dir,cost=t_cost;\n\t}\n\tbool operator>(const state& s) const {\n\t\treturn cost > s.cost;\n\t}\n};\n\nint d[MAX_V][MAX_V][MAX_DIR];\n\n\nint dx[] ={1,0,-1,0};\nint dy[] ={0,1,0,-1};\n\nvoid dijkstra(vector<vector<int> > G){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((int *)d, sizeof(d)/sizeof(int),-1);\n\tque.push(state(0,0,0,0));\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tif(d[p.y][p.x][p.dir]!=-1&&d[p.y][p.x][p.dir]<=p.cost) continue;\n\t\telse d[p.y][p.x][p.dir] = p.cost;\t\n\n\t\tif(p.x==w-1 && p.y==h-1){\n\t\t\tcout << p.cost << endl;\n\t\t\treturn;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tint x=p.x+dx[p.dir];\n\t\t\tint y=p.y+dy[p.dir];\n\t\t\tif(x<w&&y<h&&x>=0&&y>=0){\n\t\t\t\tif(G[p.y][p.x]==i) que.push(state(x,y,p.dir,p.cost));\n\t\t\t\telse que.push(state(x,y,p.dir,p.cost+c[i]));\n\t\t\t}\n\t\t\tp.dir=(p.dir+1)%4;\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0) break;\n\t\tvector<vector<int> > G(h,vector<int>(w));\n\n\t\trep(i,h) rep(j,w) cin >> G[i][j];\n\t\trep(i,4) cin >> c[i];\n\n\t\tdijkstra(G);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P1;\ntypedef pair<P1,P1> P2;\nvector<P2> G[30][30][4];\nint s[30][30],c[4];\nint d[30][30][4];\nbool used[30][30][4];\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0}; //??? ??± ??? ?\\?\nint turn(int d,bool r) {\n\tif(r) {\n\t\treturn (d+1)%4;\n\t}else {\n\t\treturn (d+3)%4;\n\t}\n}\nint main() {\n\tint w,h;\n\twhile(scanf(\"%d %d\",&w,&h),w) {\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tscanf(\"%d\",&s[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tscanf(\"%d\",&c[i]);\n\t\t}\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tG[i][j][k].clear();\n\t\t\t\t\tfor(int op=0;op<4;op++) {\n\t\t\t\t\t\tint cost=(op==s[i][j])?0:c[op];\n\t\t\t\t\t\tint nk=k;\n\t\t\t\t\t\tif(op==1) nk=turn(k,1);\n\t\t\t\t\t\tif(op==2) nk=(k+2)%4;\n\t\t\t\t\t\tif(op==3) nk=turn(k,0);\n\t\t\t\t\t\tint ni=i+dy[nk],nj=j+dx[nk];\n\t\t\t\t\t\tif(0>ni||ni>=h||0>nj||nj>=w) continue;\n\t\t\t\t\t\tG[i][j][k].push_back(P2(P1(ni,nj),P1(nk,cost)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill((bool*)used,(bool*)(used+30),0);\n\t\tfill((int*)d,(int*)(d+30),1<<30);\n\t\td[0][0][1]=0;\n\t\twhile(1) {\n\t\t\tint ni,nj,nk;\n\t\t\tni=nj=nk=-1;\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) for(int k=0;k<4;k++) {\n\t\t\t\tif(!used[i][j][k] && (ni==-1||d[i][j][k]<d[ni][nj][nk])) ni=i,nj=j,nk=k;\n\t\t\t}\n\t\t\tif(ni==-1) break;\n\t\t\tused[ni][nj][nk]=1;\n\t\t\tfor(int i=0;i<G[ni][nj][nk].size();i++) {\n\t\t\t\tint ti=G[ni][nj][nk][i].first.first;\n\t\t\t\tint tj=G[ni][nj][nk][i].first.second;\n\t\t\t\tint tk=G[ni][nj][nk][i].second.first;\n\t\t\t\tint tc=G[ni][nj][nk][i].second.second;\n\t\t\t\td[ti][tj][tk]=min(d[ti][tj][tk],d[ni][nj][nk]+tc);\n\t\t\t}\n\t\t}\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tans=min(ans,d[h-1][w-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w,h;\n\nint table[35][35];\nint c[4];\nint dist[35][35][4];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\ntypedef tuple<int,int,int,int> state;\nvoid dijkstra(){\n\trep(i,h)rep(j,w)rep(k,4)dist[i][j][k]=inf;\n\tdist[0][0][1]=0;\n\tstate s=make_tuple(0,0,0,1);\n\tpriority_queue<state> q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint x,y,d,costs;\n\t\ttie(costs,y,x,d)=cur;\n\t\tif(dist[y][x][d]<costs)\n\t\t\tcontinue;\n\t\trep(i,4){\n\t\t\tint nx=x,ny=y,nd=d,ncosts=costs;\n\t\t\tnd=(nd+i)%4;\n\t\t\tnx+=dx[nd],ny+=dy[nd];\n\t\t\tif(table[y][x]!=i)\n\t\t\t\tncosts+=c[i];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\tif(dist[ny][nx][nd]>ncosts){\n\t\t\t\t\tdist[ny][nx][nd]=ncosts;\n\t\t\t\t\tq.push(make_tuple(ncosts,ny,nx,nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\twhile(cin >> w >> h){\n\t\tif(w==0)\n\t\t\tbreak;\n\t\trep(i,h)rep(j,w) cin >> table[i][j];\n\t\trep(i,4) cin >> c[i];\n\t\tdijkstra();\n\t\tint ans=inf;\n\t\trep(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nclass MyClass {\npublic:\n\tint x, y;\n\tint dir;\n\tint cost;\n\n\tMyClass(int _x, int _y, int _dir, int _cost):x(_x),y(_y),dir(_dir),cost(_cost){}\n\n\tbool operator < (const MyClass& obj) const\n\t{\n\t\treturn cost < obj.cost;\n\t}\n\n\tbool operator > (const MyClass& obj) const\n\t{\n\t\treturn cost > obj.cost;\n\t}\n};\n\nconst int INF = 1 << 29;\nconst int MAX = 30;\nconst int dx[4][4] = { { 1, 0, -1, 0 },{ 0, -1, 0, 1 },{ -1, 0, 1, 0 },{ 0, 1, 0, -1 } };\nconst int dy[4][4] = { { 0, 1, 0, -1 },{ 1, 0, -1, 0 },{ 0, -1, 0, 1 },{ -1, 0, 1, 0 } };\n\nint main()\n{\n\twhile (true) {\n\t\tint w, h;\n\t\t\n\t\tcin >> w >> h;\n\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint grid[MAX][MAX];\n\t\tint cost[MAX][MAX][MAX];\n\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\trep(i, 4) {\n\t\t\t\t\tcost[y][x][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint robot[4];\n\t\tpriority_queue<MyClass, vector<MyClass>, greater<MyClass>> pq;\n\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> grid[y][x];\n\t\t\t}\n\t\t}\n\n\t\trep(i, 4) {\n\t\t\tcin >> robot[i];\n\t\t}\n\n\t\tpq.push(MyClass(0, 0, 0, 0));\n\t\tcost[0][0][0] = 0;\n\n\t\twhile (pq.empty() == false) {\n\t\t\tMyClass temp = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint x = temp.x;\n\t\t\tint\ty = temp.y;\n\t\t\tint\tdir = temp.dir;\n\t\t\tint\tc = temp.cost;\n\t\t\tint\tg = grid[y][x];\n\n\t\t\tif (x == w - 1 && y == h - 1) {\n\t\t\t\tcout << c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx = x + dx[dir][g];\n\t\t\tint\tny = y + dy[dir][g];\n\t\t\tint\tnd = (dir + g) % 4;\n\n\t\t\tif (g != 4 && 0 <= nx && nx < w && 0 <= ny && ny < h && c < cost[ny][nx][nd]) {\n\t\t\t\tpq.push(MyClass(nx, ny, nd, c));\n\t\t\t}\n\n\t\t\trep(i, 4) {\n\t\t\t\tif (i == g) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nx = x + dx[dir][i],\n\t\t\t\t\tny = y + dy[dir][i],\n\t\t\t\t\tnd = (dir + i) % 4;\n\n\t\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && c + robot[i] < cost[ny][nx][nd]) {\n\t\t\t\t\tpq.push(MyClass(nx, ny, nd, c + robot[i]));\n\t\t\t\t\tcost[ny][nx][nd] = c + robot[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 1000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll h,w;\nll gy,gx;\n\nll d[30][30][4];\n\nvector<vector<ll>> G;\nll c[4];\n\nll dx[] = {1,0,-1,0};\nll dy[] = {0,1,0,-1};\n\nbool in(int y,int x){\n    return y >= 0 && y < h && x >= 0 && x < w;\n}\n\nvoid dijkstra(ll sy,ll sx,ll dir){\n    rep(i,30)rep(j,30)rep(k,4)d[i][j][k] = INF;\n    d[sy][sx][dir] = 0;\n\n    typedef pair<P,P> PP;\n    priority_queue<PP, vector<PP>, greater<PP>> que;\n    que.push(PP(P(0,dir),P(sy,sx)));\n\n    while (!que.empty()){\n        PP p = que.top();\n        que.pop();\n        ll cdir = p.first.second;\n        ll cost = p.first.first;\n        ll cy = p.second.first;\n        ll cx = p.second.second;\n        if(cost > d[cy][cx][cdir])continue;\n        if(cy == gy && cx == gx)continue;\n        rep(i,4){\n            ll ny = cy + dy[(i + cdir)%4];\n            ll nx = cx + dx[(i + cdir)%4];\n            ll ndir = (cdir + i)%4;\n            if(!in(ny,nx))continue;\n            ll ncost = cost;\n            if(i != G[cy][cx])ncost += c[i];\n            if(d[ny][nx][ndir] > ncost){\n                d[ny][nx][ndir] = ncost;\n                que.push(PP(P(ncost,ndir),P(ny,nx)));\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h && w){\n        gy = h - 1; gx = w - 1;\n        G.clear();\n        G.resize(h);\n        rep(i,h)G[i].resize(w);\n        rep(i,h){\n            rep(j,w){\n                cin >> G[i][j];\n            }\n        }\n        cin >> c[0] >> c[1] >> c[2] >> c[3];\n        dijkstra(0,0,0);\n        ll ans = INF;\n        rep(i,4)ans = min(ans,d[h-1][w-1][i]);\n        cout << ans << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCà\\I2008 D. ¿åë¿åë{bg\n\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint x, y, d, cost;\n\tNode(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nchar dx[] = {0, 1, 0, -1};\nchar dy[] = {1, 0, -1, 0};\n\nint main(){\n\tint w, h;\n\tint op[4];\n\tint b[30][30];\n\tint c[30][30][4];\n\twhile(cin >> w >> h, w){\n\t\tmemset(c, -1, sizeof(c));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++) cin >> b[i][j];\n\t\t}\n\t\tfor(int i=0;i<4;i++) cin >> op[i];\n\t\tpriority_queue<Node> qu;\n\t\tqu.push(Node(0,0,0,0));\n\t\tint ans = 9999999;\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint x = nd.x, y = nd.y, d = nd.d, cost = nd.cost;\n\t\t\tif(c[x][y][d]!=-1) continue;\n\t\t\tif(x==h-1&&y==w-1) { ans = cost; break; }\n\t\t\tc[x][y][d] = cost;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(nx<0||nx>=h||ny<0||ny>=w) continue;\n\t\t\t\tif(b[x][y]!=4&&(b[x][y]+d)%4==i)\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost));\n\t\t\t\telse\n\t\t\t\t\tqu.push(Node(nx,ny,i,cost+op[(4+i-d)%4]));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\n#define MAX_V 200000\n\nstruct edge{\n\tint to;\n\tlong long int cost;\n    edge(int to_, long long int cost_){\n        to = to_;\n        cost = cost_;\n    }\n};\n\nvector<edge> G[MAX_V];\nlong long int d[MAX_V];\n\n// O(ElogV)\n\nvoid shortest_path(int s, int V){\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint s[32][32];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tint c_[4];\n\t\tcin >> c_[0] >> c_[1] >> c_[2] >> c_[3];\n\t\tint CON = (w + 1) * (h + 1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tint p00 = i * (w + 1) + j;\n\t\t\t\tint p01 = i * (w + 1) + j + CON;\n\t\t\t\tint p10 = i * (w + 1) + j + CON * 2;\n\t\t\t\tint p11 = i * (w + 1) + j + CON * 3;\n\t\t\t\tint p20 = (i + 1) * (w + 1) + j;\n\t\t\t\tint p21 = (i + 1) * (w + 1) + j + CON;\n\t\t\t\tint p30 = i * (w + 1) + j + 1 + CON * 2;\n\t\t\t\tint p31 = i * (w + 1) + j + 1 + CON * 3;\n\t\t\t\tint c[5];\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tc[k] = c_[k];\n\t\t\t\t}\n\t\t\t\tc[s[i][j]] = 0;\n\t\t\t\tG[p01].emplace_back(p21, c[0]);\n\t\t\t\tG[p11].emplace_back(p31, c[0]);\n\t\t\t\tG[p20].emplace_back(p00, c[0]);\n\t\t\t\tG[p30].emplace_back(p10, c[0]);\n\t\t\t\tG[p01].emplace_back(p10, c[1]);\n\t\t\t\tG[p11].emplace_back(p21, c[1]);\n\t\t\t\tG[p20].emplace_back(p31, c[1]);\n\t\t\t\tG[p30].emplace_back(p00, c[1]);\n\t\t\t\tG[p01].emplace_back(p00, c[2]);\n\t\t\t\tG[p11].emplace_back(p10, c[2]);\n\t\t\t\tG[p20].emplace_back(p21, c[2]);\n\t\t\t\tG[p30].emplace_back(p31, c[2]);\n\t\t\t\tG[p01].emplace_back(p31, c[3]);\n\t\t\t\tG[p11].emplace_back(p00, c[3]);\n\t\t\t\tG[p20].emplace_back(p10, c[3]);\n\t\t\t\tG[p30].emplace_back(p21, c[3]);\n\t\t\t}\n\t\t}\n\t\tshortest_path(CON * 3, CON * 4);\n\t\t/*\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < h + 1; j++){\n\t\t\t\tfor(int k = 0; k < w + 1; k++){\n\t\t\t\t\tcout << d[j * (w + 1) + k + CON * i] << \" \";\n\t\t\t\t}cout << endl;\n\t\t\t}cout << endl;\n\t\t}\n\t\t*/\n\t\tint pos = (h - 1) * (w + 1) + w - 1;\n\t\tcout << min(d[pos + CON], d[pos + CON * 3]) << endl;\n\t\tfor(int i = 0; i < CON * 4; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst int INF = INT_MAX/3;\nconst int MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nint main(){\n    int w,h;\n    int s[31][31];\n    int d[5][31][31];\n    int c[5];\n    while(true){\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tREP(i,h)REP(j,w){\n\t    cin >> s[i][j];\n\t    REP(k,5)\n\t\td[k][i][j] = INF;\n\t}\n\tREP(i,4) cin >> c[i];\n\tc[4] = 0;\n\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qv;\n\tqueue<int> qs;\n\tqxy.push(MP(0,0));\n\tqv.push(0);\n\tqs.push(0);\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int v = qv.front();\n\t    int st = qs.front();\n\t    qxy.pop();\n\t    qv.pop();\n\t    qs.pop();\n\t    REP(i,5){\n\t\tint nx,ny;\n\t\tint nv = v;\n\t\tint nst;\n\t\tif( i < 4 ){\n\t\t    nst = (st+i)%4;\n\t\t    nx = x + dx[nst];\n\t\t    ny = y + dy[nst];\n\t\t    nv = v + c[i];\n\t\t}else{\n\t\t    if(s[y][x] == 4){\n\t\t\tnst = 4;\n\t\t\tcontinue;\n// \t\t\tnx = x;\n// \t\t\tny = y;\n\t\t    }else{\n\t\t\tnst = (st+s[y][x])%4;\n\t\t\tnx = x + dx[nst];\n\t\t\tny = y + dy[nst];\n\t\t    }\n\t\t}\n\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\tif(nv < d[nst][ny][nx]){\n\t\t    d[nst][ny][nx] = nv;\n\t\t    qxy.push(MP(nx,ny));\n// \t\t    printf(\"x = %d y = %d v = %d s = %d i = %d\\n\",nx,ny,nv,nst,i);\n\t\t    qv.push(nv);\n\t\t    qs.push(nst);\n\t\t}\n\t    }\n\t}\n\tint ans = INF;\n\tREP(i,5) ans = min(ans,d[i][h-1][w-1]);\n\tcout << ans << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 100000) {\n\t\t\tif(d[np.first.first][np.first.second][np.second] == 0) break;\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\tll ans = INF;\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nint c[4];\n\nstruct State{\n\tint x,y,d,cost;\n};\n\n\nbool operator < (const State a, State b){\n\treturn a.cost>b.cost;\n}\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid calc(int w,int h){\n\tint direction[30][30];\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tcin>>direction[j][i];\n\n\tfor(int i=0;i<4;i++)\n\t\tcin>>c[i];\n\n\tpriority_queue<State> Q;\n\tbool costmap[30][30][4];\n\n\tfor(int i=0;i<30;i++)\n\t\tfor(int j=0;j<30;j++)\n\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\tcostmap[i][j][z]=false;\n\n\tcostmap[0][0][0]=true;\n\n\tState first;\n\tfirst.x=first.y=first.cost=first.d=0;\n\tQ.push(first);\n\n\tState k;\n\twhile(!Q.empty()){\n\t\tk=Q.top();\n\t\tQ.pop();\n\t\tcostmap[k.x][k.y][k.d]=true;\n\t\tcout<<k.x<<\" \"<<k.y<<\" \"<<k.d<<\" \"<<k.cost<<\"\\n\";\n\t\tif(k.x==w-1 && k.y==h-1)\n\t\t\tbreak;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx,ty,td,tcost;\n\t\t\tState temp;\n\t\t\ttd=(k.d+i)%4;\n\t\t\ttx=k.x+dx[td];\n\t\t\tty=k.y+dy[td];\n\t\t\tif(tx<0 || ty<0 || tx>w || ty>h)\n\t\t\t\tcontinue;\n\t\t\ttcost=k.cost;\n\t\t\tif(direction[k.x][k.y]!=i)\n\t\t\t\ttcost+=c[i];\n\t\t\ttemp.x=tx;\n\t\t\ttemp.y=ty;\n\t\t\ttemp.d=td;\n\t\t\ttemp.cost=tcost;\n\t\t\tif(!costmap[temp.x][temp.y][temp.d])\n\t\t\t\tQ.push(temp);\n\t\t}\n\t}\n\n\tcout<<k.cost<<\"\\n\";\n}\n\nint main(){\n\tint w,h;\n\tcin>>w>>h;\n\twhile(w!=0){\n\t\tcalc(w,h);\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct P {\n\tint x, y;\n};\nstruct Node {\n\tP p;\n\tint dir, cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\nP operator +(const P& p1, const P& p2) {\n\treturn (P){ p1.x + p2.x, p1.y + p2.y };\n}\n\nP Dir[4] = {\n\t(P){1, 0},\n\t(P){0, 1},\n\t(P){-1, 0},\n\t(P){0, -1},\n};\n\n#define INF 1e9\n\nvoid AddQueue(priority_queue<Node, vector<Node>, greater<Node> >& Q, Node node, int op) {\n\tint dd = op;\n\tnode.dir = (node.dir + dd) % 4;\n\tnode.p = node.p + Dir[node.dir];\n\tQ.push(node);\n}\n\nint main() {\n\tint w, h;\n\twhile ( cin >> w >> h, w || h ) {\n\t\tint s[30][30];\n\t\tfor (int y = 0; y < h; ++y) for (int x = 0; x < w; ++x) {\n\t\t\tcin >> s[y][x];\n\t\t}\n\t\tint c[4];\n\t\tfor (int i = 0; i < 4; ++i) cin >> c[i];\n\n\t\tint cost[30][30][4];\n\t\tfill(&cost[0][0][0], &cost[0][0][0]+30*30*4, -1);\n\t\tpriority_queue<Node, vector<Node>, greater<Node> > Q;\n\t\tQ.push( (Node){ (P){0, 0}, 0, 0 } );\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.top(); Q.pop();\n\t\t\tP p = node.p;\n\t\t\tif (p.x < 0 || p.x >= w || p.y < 0 || p.y >= h) continue;\n\t\t\tif (cost[p.y][p.x][node.dir] >= 0) continue;\n\t\t\tcost[p.y][p.x][node.dir] = node.cost;\n\n\t\t\tif (s[p.y][p.x] != 4) AddQueue(Q, node, s[p.y][p.x]);\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tAddQueue(Q, (Node){ node.p, node.dir, node.cost + c[i] }, i);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 4; ++i) if (cost[h-1][w-1][i] >= 0) ans = min(ans, cost[h-1][w-1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\nconst int INF = 1e9;\n\nvector<int> dijkstra(vector< vector< pair<int,int> > > G, int s, int v){\n  priority_queue< pair<int, int> > wait;\n  vector<int> result(v, INF);\n  result[s] = 0;\n  wait.push(make_pair(0, s));\n  while(!wait.empty()){\n    int nowpoint = wait.top().second;\n    int nowcost = wait.top().first;\n    wait.pop();\n    if(nowcost <= result[nowpoint]){\n      for(int i = 0; i < G[nowpoint].size(); ++i){\n        int nextpoint = G[nowpoint][i].second;\n        int nextcost = -nowcost + G[nowpoint][i].first;\n        if(nextcost < result[nextpoint]){\n          wait.push(make_pair(-nextcost, nextpoint));\n          result[nextpoint] = nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector< vector<int> > M(h, vector<int>(w));\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        cin >> M[i][j];\n    vector<int> C(4);\n    for(int i = 0; i < 4; ++i) cin >> C[i];\n    int n = 4*h*w, dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n    vector< vector< pair<int,int> > > G(n);\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        for(int k = 0; k < 4; ++k){\n          int v = i*w + j + k*h*w;\n          for(int l = 0; l < 4; ++l){\n            int d = (k+l)%4, i_ = i + dy[d], j_ = j + dx[d], v_ = i_*w + j_ + d*h*w;\n            if((!in_range(i_, h)) || (!in_range(j_, w))) continue;\n            if(M[i][j] == l){\n              G[v].push_back(make_pair(0, v_));\n            }else{\n              G[v].push_back(make_pair(C[l], v_));\n            }\n          }\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < n; ++i){\n      int d = i/(h*w), x = (i%(h*w))/w, y = (i%(h*w))%w;\n      printf(\"(d = %d, x = %d, y = %d)\\n\", d, x, y);\n      for(int j = 0; j < G[i].size(); ++j){\n        int t = G[i][j].second, c = G[i][j].first;\n        int d = t/(h*w), x = (t%(h*w))/w, y = (t%(h*w))%w;\n        printf(\"(d = %d, x = %d, y = %d) : c = %d\\n\", d, x, y, c);\n      }\n      cout << endl;\n    }\n    */\n    vector<int> D = dijkstra(G, 0, n);\n    int ans = INF;\n    for(int i = 0; i < 4; ++i){\n      ans = min(ans, D[h*w*i + h*w - 1]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define DBG_N(hoge) cerr<<\" \"<<(hoge)<<endl;\n#define DBG cerr<<\"!\"<<endl;\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\n//0:right,1:left,2:up,3:down\nint vx[4]={0,0,-1,1};\nint vy[4]={1,-1,0,0};\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin>>n>>m,n){\n    ll hoge[m+10][n+10];\n    ll c[4];\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tcin>>hoge[i][j];\n    for(int i=0;i<4;i++)\n      cin>>c[i];\n    ll dist[m+10][n+10][5];\n    for(int i=0;i<m+10;i++)\n      for(int j=0;j<n+10;j++)\n\tfor(int k=0;k<5;k++)\n\t  dist[i][j][k]=llINF;\n    dist[0][0][0] = 0;\n    priority_queue<pair<pair<ll,ll>,pair<ll,ll>>,vector<pair<pair<ll,ll>,pair<ll,ll>>>,greater<>>que;\n    que.push(mp(mp(0,0),mp(0,0)));\n    while(!que.empty()){\n      pair<ll,ll> now = que.top().S;\n      ll d = que.top().F.F;\n      //0:right,1:left,2:up,3:down\n      ll muki = que.top().F.S;\n      que.pop();\n    \n      for(int j=0;j<4;j++){\n\tif(dist[now.F][now.S][muki] < d)continue;\n\tll tox=now.F+vx[j],toy=now.S+vy[j];\n\tif(0>tox||tox>=m||0>toy||toy>=n)continue;\n\tll cost=0;\n\tif(muki == 0){\n\t  if(j == 0){\n\t    if(hoge[now.F][now.S] == 0){\n\t      cost=0;\n\t    }else{\n\t      cost=c[0];\n\t    }\n\t  }else if(j == 1){\n\t    if(hoge[now.F][now.S] == 2){\n\t      cost=0;\n\t    }else{\n\t      cost=c[2];\n\t    }\n\t  }else if(j == 2){\n\t    if(hoge[now.F][now.S] == 3){\n\t      cost = 0;\n\t    }else{\n\t      cost=c[3];\n\t    }\n\t  }else if(j == 3){\n\t    if(hoge[now.F][now.S] == 1){\n\t      cost=0;\n\t    }else{\n\t      cost = c[1];\n\t    }\n\t  }\n\t \n\t}else if(muki == 1){\n\t  if(j == 0){\n\t    if(hoge[now.F][now.S] == 2){\n\t      cost=0;\n\t    }else{\n\t      cost=c[2];\n\t    }\n\t  }else if(j == 1){\n\t    if(hoge[now.F][now.S] == 0){\n\t      cost=0;\n\t    }else{\n\t      cost=c[0];\n\t    }\n\t  }else if(j == 2){\n\t    if(hoge[now.F][now.S] == 1){\n\t      cost = 0;\n\t    }else{\n\t      cost=c[1];\n\t    }\n\t  }else if(j == 3){\n\t    if(hoge[now.F][now.S] == 3){\n\t      cost=0;\n\t    }else{\n\t      cost = c[3];\n\t    }\n\t  }\n\t \n\t}else if(muki == 2){\n\t  if(j == 0){\n\t    if(hoge[now.F][now.S] == 1){\n\t      cost=0;\n\t    }else{\n\t      cost=c[1];\n\t    }\n\t  }else if(j == 1){\n\t    if(hoge[now.F][now.S] == 3){\n\t      cost=0;\n\t    }else{\n\t      cost=c[3];\n\t    }\n\t  }else if(j == 2){\n\t    if(hoge[now.F][now.S] == 0){\n\t      cost = 0;\n\t    }else{\n\t      cost=c[0];\n\t    }\n\t  }else if(j == 3){\n\t    if(hoge[now.F][now.S] == 2){\n\t      cost=0;\n\t    }else{\n\t      cost = c[2];\n\t    }\n\t  }\n\t \n\t}else if(muki == 3){\n\t  if(j == 0){\n\t    if(hoge[now.F][now.S] == 3){\n\t      cost=0;\n\t    }else{\n\t      cost=c[3];\n\t    }\n\t  }else if(j == 1){\n\t    if(hoge[now.F][now.S] == 1){\n\t      cost=0;\n\t    }else{\n\t      cost=c[1];\n\t    }\n\t  }else if(j == 2){\n\t    if(hoge[now.F][now.S] == 2){\n\t      cost = 0;\n\t    }else{\n\t      cost=c[2];\n\t    }\n\t  }else if(j == 3){\n\t    if(hoge[now.F][now.S] == 0){\n\t      cost=0;\n\t    }else{\n\t      cost = c[0];\n\t    }\n\t  }\n\t \n\t}\n\tif(dist[tox][toy][j] > dist[now.F][now.S][muki]+cost){\n\t  dist[tox][toy][j] = dist[now.F][now.S][muki]+cost;\n\t  que.push(mp(mp(dist[tox][toy][j],j),mp(tox,toy)));\n\t}\n      }\n    }\n    /*for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++)cout<<dist[i][j]<<\" \";\n      cout<<endl;\n     }*/\n    ll ans=llINF;\n    for(int i=0;i<4;i++)\n      ans=min(ans,dist[m-1][n-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// start: 2013/07/11 3:12\n// end: 2013/07/12 12:50\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <queue>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n#define INF INT_MAX\n\nusing namespace std;\n\nclass Rec {\npublic:\n    int x;\n    int y;\n    int d;\n    int cost;\n\n    Rec( int xx, int yy, int dd, int s): x(xx), y(yy), d(dd), cost(s){}\n};\n\nbool operator< (const Rec& rec1, const Rec &rec2) {\n    return rec1.cost > rec2.cost;\n}\nbool operator> (const Rec& rec1, const Rec &rec2) {\n    return rec1.cost < rec2.cost;\n}\n\nint mx[4][4] = {{1, 0, -1, 0},\n                {0, -1, 0, 1},\n                {-1, 0, 1, 0},\n                {0, 1, 0, -1}};\nint my[4][4] = {{0, 1, 0, -1},\n                {1, 0, -1, 0},\n                {0, -1, 0, 1},\n                {-1, 0, 1, 0}};\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        // cout << w << \" \" << h << endl;\n        priority_queue< Rec, vector<Rec>, less<vector<Rec>::value_type> > pq;\n\n        vector< vector<int> > f(h, vector<int>(w));\n        int closed[h][w][4];\n        int COST[4];\n\n        REP(y, h) REP(x, w) REP(i, 4) closed[y][x][i] = INF;\n\n        REP(y, h) REP(x, w) cin >> f[y][x];\n        REP(i, 4) cin >> COST[i];\n\n        // dump(f);\n\n        pq.push( Rec(0, 0, 0, 0));\n\n        closed[0][0][0] = 0;\n\n        while(!pq.empty()) {\n\n            Rec tmp = pq.top(); pq.pop();\n            int x = tmp.x,\n                y = tmp.y,\n                d = tmp.d,\n                cost = tmp.cost,\n                o = f[y][x];\n\n            // printf(\"n:%d %d %d: %d\\n\", x, y, d, (0 <= x && x < w && 0 <= y && y < h));\n\n            // ゴール\n            if ( x == w-1 && y == h-1 ) {\n                cout << cost << endl;\n                break;\n            }\n\n            int nx = x + mx[d][o],\n                ny = y + my[d][o],\n                nd = (d+o) % 4;\n\n            // マス目移動\n            if ( o != 4 && 0 <= nx && nx < w && 0 <= ny && ny < h && cost < closed[ny][nx][nd] ) pq.push( Rec(nx, ny, nd, cost) );\n\n            // 命令出す\n            REP(i, 4) {\n                if ( i == o ) continue; // マス目の命令と同じ\n\n                int nx = x + mx[d][i],\n                    ny = y + my[d][i],\n                    nd = (d+i)%4;\n\n                if ( 0 <= nx && nx < w && 0 <= ny && ny < h && cost+COST[i] < closed[ny][nx][nd] ) {\n                    pq.push( Rec(nx, ny, nd, cost+COST[i]) );\n                    closed[ny][nx][nd] = cost+COST[i];\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 100000;\n#define P pair < int , pair < int , pair < int , int > > > \n#define dis first\n#define dir second.first\n#define x second.second.first\n#define y second.second.second\nusing namespace std;\nint w,h;\nint mp[31][31];\nint c[4];\n//> v < ^\n//0 1 2 3\n\nint mk(int dr,int i) {\n  if(dr==0) return (0+i)%4;\n  else if(dr==3) return (1+i)%4;\n  else if(dr==2) return (2+i)%4; \n  else if(dr==1) return (3+i)%4;\n\n  return -1;\n}\n\nint dijkstra() {\n  priority_queue <P> Q;\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,1,0,-1};\n  bool visited[4][31][31] = {};\n  int d[4][31][31];\n  for(int i=0;i<4;i++)\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++) \n\td[i][j][k] = -INF;\n\n  P t;\n  t.dis = 0,   t.dir = 0,   t.x = 0,   t.y = 0;\n  d[0][0][0] = 0;\n  Q.push(t);\n\n  while(!Q.empty()){\n    t = Q.top() , Q.pop();\n    if(visited[t.dir][t.y][t.x] == 1) continue;\n    visited[t.dir][t.y][t.x] = 1;\n    if(t.y == h-1 && t.x==w-1) cout <<\"dis=\"<< t.dis <<endl;\n    // if(mp[t.y][t.x] == 4) continue;\n\n    for(int i=0;i<4;i++) {\n      int nx = t.x+dx[i],ny = t.y+dy[i];\n      if(nx<0 ||ny<0 ||w<=nx ||h<=ny) continue;\n      int ii = mk(t.dir,i);\n      int cost = c[ii];\n      if(mp[t.y][t.x] == ii) cost = 0;\n      if(nx==w-1 && t.y==h-2) {\n\tcout << cost <<endl;\n\t\n      }\n      if(d[i][ny][nx] < d[t.dir][t.y][t.x]-cost) {\n\td[i][ny][nx] = d[t.dir][t.y][t.x]-cost;\n\tP tt;\n\ttt.x = nx,  tt.y = ny,  tt.dir = i,  tt.dis = d[i][ny][nx];\n\tQ.push(tt);\n      }\n    }\n  }\n\n  int ans = -INF;\n  for(int i=0;i<4;i++) ans = max(ans,d[i][h-1][w-1]),cout << d[i][h-1][w-1]<<endl;\n  return ans;\n}\n\nint main() {\n\n  while(1) {\n  cin >> w >> h;\n  if(w == 0 && h == 0) break;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mp[i][j];\n    }\n  }\n   \n  for(int i=0;i<4;i++) cin >> c[i];\n\n  cout << -dijkstra() <<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\ntypedef pair<pii,pii> P;\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvint co(4);\nvvint vv;\nint w,h;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint dp[32][32][4];\nint dijkstra(){\n\trep(i,32){\n\t\trep(j,32){\n\t\t\trep(k,4){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0]=0;\n\tpriority_queue<P> pq;\n\tpq.push(mkp(mkp(0,0),mkp(0,0)));\n\twhile(!pq.empty()){\n\t\tP top=pq.top();\n\t\t// cout<<top.S.F<<\" \"<<top.S.S<<endl;\n\t\tpq.pop();\n\t\tif(dp[top.S.F][top.S.S][top.F.S]<-top.F.F) continue;\n\t\tif(top.S.F==h-1&&top.S.S==w-1) return -top.F.F;\n\t\trep(i,4){\n\t\t\tP tmp=top;\n\t\t\tif(vv[tmp.S.F][tmp.S.S]==i){\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp.F.F-=co[i];\n\t\t\t}\n\t\t\ttmp.F.S=(tmp.F.S+i)%4;\n\t\t\ttmp.S.F+=dx[tmp.F.S];\n\t\t\ttmp.S.S+=dy[tmp.F.S];\n\t\t\tif(tmp.S.F<0||tmp.S.F>h-1||tmp.S.S<0||tmp.S.S>w-1) continue;\n\t\t\tif(dp[tmp.S.F][tmp.S.S][tmp.F.S]<=-tmp.F.F){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpq.push(tmp);\n\t\t\t\tdp[tmp.S.F][tmp.S.S][tmp.F.S]=-tmp.F.F;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid mainmain(){\n\twhile(cin>>w>>h,w||h){\n\t\tinitvv(vv,h,w);\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>vv[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,4){\n\t\t\tcin>>co[i];\n\t\t}\n\t\tcout<<dijkstra()<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 1000000000;\n\ntypedef struct {\n  int to, cost;\n}edge;\n\nvector<edge> G[4*30*30+1];\nint d[4*30*30+1];\n\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d+4*30*30+1, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    for (int i = 0; i < G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\n\nint main() {\n  while (true) {\n     int w, h;\n  scanf(\"%d%d\", &w, &h);\n  if (w == 0 and h == 0) break;\n  int s[h][w];\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      scanf(\"%d\", &s[i][j]);\n    }\n  }\n  int c[4];\n  for (int i = 0; i < 4; i++)\n    scanf(\"%d\", &c[i]);\n\n\n\n  int dx[4] = {1, 0, -1, 0};\n  int dy[4] = {0, 1, 0, -1};\n  for (int i = 0; i < 4*30*30+1; i++) {\n    G[i].clear();\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      for (int k = 0; k < 4; k++) {\n\tfor (int l = 0; l < 4; l++) {\n\t  int t = (k + l) % 4;\n\t  int x = j + dx[t], y = i + dy[t];\n\t  if (0 <= x and x < w and 0 <= y and y < h) {\n\t    G[4*(w*i+j)+k].push_back(l == s[i][j] ? edge{4*(w*y+x)+t, 0} : edge{4*(w*y+x)+t, c[l]});\n\t  }\n\t}\n      }\n    }\n  }\n  \n    dijkstra(0);\n    printf(\"%d\\n\", min(d[4*(w*(h-1)+w-1)], d[4*(w*(h-1)+w-1)+1]));\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint sdx[4] = {0, 1, 0, -1};\nint sdy[4] = {-1, 0, 1, 0};\n\nstruct Edge{\n  int src,dst,weight;\n  Edge(int src,int dst,int weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return (e.weight != f.weight) ? e.weight>f.weight :\n    (e.src != f.src) ? e.src<f.src : e.dst<f.src;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nconst int INF = 0x7fffffff;\nint w,h;\nvoid dijkstra(const Graph &g, int s, vector<int> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF);\n  dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q;\n\n  for(Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top();\n    Q.pop();\n    if(prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    for(Edges::const_iterator it = g[e.dst].begin(); it != g[e.dst].end(); ++it) {\n      if(dist[it->dst] > e.weight + it->weight) {\n\tdist[it->dst] = e.weight + it->weight;\n\tQ.push(Edge(it->src, it->dst, e.weight + it->weight));\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin>>w>>h, w||h) {\n    Graph g(w*h*4);\n    int t,tk,nx,ny,inp;\n\n    for(int i=0; i<h; ++i) {\n      for(int j=0; j<w; ++j) {\n\tcin>>t;\n\tif(t==4) continue;\n\tfor(int k=0; k<4; ++k) {\n\t  tk = (k+t)%4;\n\t  nx = j+sdx[tk], ny = i+sdy[tk];\n\t  if(nx >= 0 && (nx<w) && ny >= 0 && ny < h )\n\t    g[(i*w+j)*4+k].push_back( Edge((i*w+j)*4+k, (ny*w+nx)*4+tk, 0) );\n\t}\n      }\n    }\n\n    int c[4];\n    cin>>c[0]>>c[1]>>c[2]>>c[3];\n\n    for(int i=0; i<h; ++i) {\n      for(int j=0; j<w; ++j) {\n\tfor(int t=0; t<4; ++t) {\n\t  for(int k=0; k<4; ++k) {\n\t    tk = (k+t)%4;\n\t    nx = j+sdx[tk],ny = i+sdy[tk];\n\t    if(nx >= 0 && nx < w && ny >= 0 && ny < h)\n\t       g[(i*w+j)*4+k].push_back( Edge((i*w+j)*4+k, (ny*w+nx)*4+tk, c[t]) );\n\t  }\n\t}\n      }\n    }\n\n    vector<int> dist;\n    vector<int> prev;\n    dijkstra(g, 1, dist, prev);\n\n    cout<<min( dist[dist.size()-2], dist[dist.size()-3] )<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct State {\n  int x, y, d, c;\n  State(){}\n  State(int x_, int y_, int d_, int c_) : x(x_), y(y_), d(d_), c(c_) {}\n  bool operator>(const State& s) const {\n    return c>s.c;\n  }\n};\n\nconst int S = 31;\nconst int INF = 1<<27;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint H, W;\nint G[S][S], C[4];\n\nbool in(int x, int y) {\n  return 0<=x && x<W && 0<=y & y<H;\n}\n\nint a() {\n  int c[4][S][S];\n  \n  priority_queue<State, vector<State>, greater<State> > pq;\n  \n  fill(c[0][0], c[4][0], INF);\n  pq.push(State(0,0,0,0));\n  c[0][0][0] = 0;\n\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(s.x == W-1 && s.y == H-1) return s.c;\n    \n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      t.c = i == G[s.y][s.x] ? 0 : C[i];\n      if(in(t.x, t.y) && c[t.d][t.y][t.x] > t.c) {\n\tpq.push(t);\n\tc[t.d][t.y][t.x] = t.c;\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  \n  while( cin >> W >> H, W+H ) {\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) cin >> G[i][j];\n    for(int i=0; i<4; i++) cin >> C[i];\n    cout << a() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//SPFA\n#include <cstdio>\n#include <cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define INF (10*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nbool in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nint main(){\n\tqueue<Node> que;\n\tbool inQ[30][30][4];\n\tint dst[30][30][4];\n\tNode a,b;\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,false,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\twhile(!que.empty())que.pop();\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque.push(a);\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tinQ[a.y][a.x][a.dir]=false;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(!inQ[b.y][b.x][b.dir]){\n\t\t\t\t\tque.push(b);\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(!inQ[b.y][b.x][b.dir]){\n\t\t\t\t\t\tque.push(b);\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",*min_element(dst[h-1][w-1],dst[h-1][w-1]+4));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<pair<ll, ll>, ll> >, vector<pair<ll, pair<pair<ll, ll>, ll> > >, greater<pair<ll, pair<pair<ll, ll>, ll> > > > q;\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 100000) {\n\t\t\tif(d[np.first.first][np.first.second][np.second] == 0) break;\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\tll ans = INF;\n\t\t//pair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t//if(p.second.first == P(h - 1, w - 1)) {\n\t\t\t//\tif(p.second.second == 1) hoge.first = true;\n\t\t\t//\tif(p.second.second == 2) hoge.second = true;\n\t\t\t//}\n\t\t\t//if(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef tuple<int, int, pair<int, int> > tup;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nint w, h;\nint s[32][32];\nint c[6];\n//dist[t][y][x] :=????????¨?????§?¨????(x, y)??§??\\????????????t????????????????????????\nint dist[32][32][6];\n\nvoid dijkstra(void){\n    rep(i, 32)rep(j, 32)rep(k, 6){\n    \tdist[i][j][k] = INF;\n    }\n\n    priority_queue<tup, vector<tup>, greater<tup> >  q;//????????????????????????????????\\?????? ?????¨?????§?¨?\n    if(s[0][0] == 0){\n        q.push(make_tuple(0, 1, make_pair(0, 1)));\n    }else if(s[0][0] == 1){\n        q.push(make_tuple(0, 2, make_pair(1, 0)));\n    }else if(s[0][0] == 2 || s[0][0] == 3 || s[0][0] == 4){\n        q.push(make_tuple(c[0], 1, make_pair(0, 1)));\n        q.push(make_tuple(c[1], 2, make_pair(1, 0)));\n    }\n\n    while(!q.empty()){\n        int cost, v;\n        pair<int, int> p;\n        tie(cost, v, p) = q.top(); q.pop();\n        int y = p.first, x = p.second;\n        if(dist[v][y][x] < cost) continue;\n        // printf(\"v %d y %d x %d\\n\", v, y, x);\n        /*\n        for (int i = v, j = 0; i < v + 4; ++i, ++j){//??´?????????180????????????????????????\n            //?????????????????????????????????\n            int nextv = i % 4;\n            int ny = y + dy[nextv], nx = x + dx[nextv];\n            if(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n            if(j == s[y][x]){//????????????\n                if(cost < dist[nextv][ny][nx]){\n                    q.push(make_tuple(cost, nextv, make_pair(ny, nx)));\n                    dist[nextv][ny][nx] = cost;\n                    printf(\"1 dist[%d][%d][%d] = %d\\n\", nextv, ny, nx, dist[nextv][ny][nx]);\n                }\n            }else{\n                if(cost + c[j] < dist[nextv][ny][nx]){\n                    q.push(make_tuple(cost + c[j], nextv, make_pair(ny, nx)));\n                    dist[nextv][ny][nx] = cost + c[j];\n                    printf(\"2 dist[%d][%d][%d] = %d\\n\", nextv, ny, nx, dist[nextv][ny][nx]);\n                }\n            }\n        }\n        */\n        for (int i = 0; i < 4; ++i){\n            int nextv = (v + i) % 4;\n                //?????????????????????????????????\n            int ny = y + dy[nextv], nx = x + dx[nextv];\n            if(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n            if(i == s[y][x]){//????????????\n                if(cost < dist[nextv][ny][nx]){\n                    q.push(make_tuple(cost, nextv, make_pair(ny, nx)));\n                    dist[nextv][ny][nx] = cost;\n                    // printf(\"1 dist[%d][%d][%d] = %d\\n\", nextv, ny, nx, dist[nextv][ny][nx]);\n                }\n            }else{\n                if(cost + c[i] < dist[nextv][ny][nx]){\n                    q.push(make_tuple(cost + c[i], nextv, make_pair(ny, nx)));\n                    dist[nextv][ny][nx] = cost + c[i];\n                    // printf(\"2 dist[%d][%d][%d] = %d\\n\", nextv, ny, nx, dist[nextv][ny][nx]);\n                }\n            }\n        }\n    }\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n        rep(i, h)rep(j, w) cin >> s[i][j];\n        rep(i, 4){\n            cin >> c[i];\n        }\n\n\t\tdijkstra();\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tans = min(ans, dist[i][h - 1][w - 1]);\n\t\t}\n        printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_H = 30, MAX_W = 30;\nconst int INF = 1000000;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppii;\ntypedef pair<int, ppii> node;\n\nint w, h, s[MAX_H][MAX_W], c[4];\nint d[MAX_H][MAX_W][4]; // 0: right, 1: down, 2: left, 3: up\nint t[4][3] = {{1, 0, 0}, {0, 1, 1}, {-1, 0, 2}, {0, -1, 3}};\n\nint md(int x, int y)\n{\n    int m = d[x][y][0];\n    for (int k = 1; k < 4; ++k)\n        m = min(m, d[x][y][k]);\n    return m;\n}\n\nvoid pd()\n{\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            printf(\"%7d \", md(j, i));\n        }\n        puts(\"\");\n    }\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                scanf(\"%d\", &s[j][i]);\n        for (int i = 0; i < 4; ++i)\n            scanf(\"%d\", &c[i]);\n\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                for (int k = 0; k < 4; ++k)\n                    d[j][i][k] = INF;\n\n        //printf(\"  start dijkstra\\n\");\n        priority_queue<node, vector<node>, greater<node> > q;\n        d[0][0][0] = 0;\n        q.push(node(0, ppii(pii(0, 0), 0)));\n        int e = 0;\n        while (!q.empty()) {\n            node p = q.top();\n            q.pop();\n            int x = p.second.first.first, y = p.second.first.second, z = p.second.second;\n\n            if (d[x][y][z] < p.first) {\n                //printf(\"    skip (%d, %d, %d)\\n\", x, y, z);\n                continue;\n            }\n            //printf(\"    [%3d / %3d] pop (%d, %d, %d)\\n\", e++, w * h * 4, x, y, z);\n            //pd();\n\n            for (int i = 0; i < 4; ++i) {\n                int nx = x + t[(i + z) % 4][0], ny = y + t[(i + z) % 4][1], nz = t[(i + z) % 4][2];\n\n                if (nx < 0 || nx >= w || ny < 0 || ny >= h)\n                    continue;\n                //printf(\"      check (%d, %d, %d)\\n\", nx, ny, nz);\n\n                int nd;\n                if (s[x][y] == i)\n                    nd = min(d[nx][ny][nz], d[x][y][z]);\n                else\n                    nd = min(d[nx][ny][nz], d[x][y][z] + c[i]);\n                if (nd < d[nx][ny][nz]) {\n                    d[nx][ny][nz] = nd;\n                    q.push(node(nd, ppii(pii(nx, ny), nz)));\n                }\n            }\n        }\n        //printf(\"  finish dijkstra\\n\");\n\n        printf(\"%d\\n\", md(w - 1, h - 1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\n//const int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvp g;\n\tpublic:\n\tvi DIJ(int s){\n\t\tpriority_queue<P> q;\n\t\tvi d(n,inf);\n\t\td[s]=0;\n\t\tq.push({0,s});\n\t\twhile(!q.empty()){\n\t\t\tP p=q.top();\n\t\t\tq.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<-p.first) continue;\n\t\t\tfor(auto i:g[v]){\n\t\t\t\tint u=i.first,D=d[v]+i.second;\n\t\t\t\tif(d[u]>D){\n\t\t\t\t\td[u]=D;\n\t\t\t\t\tq.push({-D,u});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvp(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tg[s].push_back({t,c});\n\t}\n};\n\nint h,w;\n\nint f(int x,int y,int k){\n\treturn k*h*w+x*w+y;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(h==0) break;\n\t\tvvi a(h,vi(w));\n\t\tvi b(4);\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>a[i][j];\n\t\tfor(int i=0;i<4;i++) cin>>b[i];\n\t\tGraph g(h*w*4);\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\tif(a[i][j]<4){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint K=(k+a[i][j])%4;\n\t\t\t\tint x=i+dx[K],y=j+dy[K];\n\t\t\t\tif(x>=0&&x<h&&y>=0&&y<w){\n\t\t\t\t\tg.add_edge(f(i,j,k),f(x,y,K),0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++) for(int l=0;l<4;l++){\n\t\t\t\tint K=(k+l)%4;\n\t\t\t\tint x=i+dx[K],y=j+dy[K];\n\t\t\t\tif(x>=0&&x<h&&y>=0&&y<w){\n\t\t\t\t\tg.add_edge(f(i,j,k),f(x,y,K),b[l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=inf;\n\t\tvi d=g.DIJ(f(0,0,0));\n\t\tfor(int i=0;i<4;i++) res=min(res,d[f(h-1,w-1,i)]);\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1 << 28)\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint w,h;\n\nstruct data_t {\n\tint row;\n\tint col;\n\tint dir;\n\tint cost;\n\n\tbool operator<(const data_t& right) const {\n\t\treturn (cost > right.cost);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> w >> h, w) {\n\t\tvector< vector<int> > s(h+2,vector<int>(w+2));\n\t\tfor (int i = 0; i < h+2; ++i) {\n\t\t\tfor (int j = 0; j < w+2; ++j) {\n\t\t\t\tif (i == 0 || i == h+1 || j == 0 || j == w+1) {\n\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcin >> s[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> c(4);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tint cost[h+2][w+2][4];\n\t\tfor (int i = 0; i < h+2; ++i) {\n\t\t\tfor (int j = 0; j < w+2; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tcost[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<data_t> pq;\n\t\tpq.push((data_t){1,1,0,0});\n\t\tcost[1][1][0] = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tdata_t sn = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (sn.row == h && sn.col == w) {\n\t\t\t\tcout << sn.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int op = 0; op < 4; ++op) {\n\t\t\t\t\tint d = (sn.dir + op) % 4;\n\t\t\t\t\tif (sn.row+dy[d] > 0 && sn.row+dy[d] <= h && sn.col+dx[d] > 0 && sn.col+dx[d] <= w) {\n\t\t\t\t\t\tif (s[sn.row][sn.col] == op) {\n\t\t\t\t\t\t\tif (sn.cost < cost[sn.row+dy[d]][sn.col+dx[d]][d]) {\n\t\t\t\t\t\t\t\tcost[sn.row+dy[d]][sn.col+dx[d]][d] = sn.cost;\n\t\t\t\t\t\t\t\tpq.push((data_t){sn.row+dy[d],sn.col+dx[d],d,sn.cost});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (sn.cost+c[op] < cost[sn.row+dy[d]][sn.col+dx[d]][d]) {\n\t\t\t\t\t\t\t\tcost[sn.row+dy[d]][sn.col+dx[d]][d] = sn.cost + c[op];\n\t\t\t\t\t\t\t\tpq.push((data_t){sn.row+dy[d],sn.col+dx[d],d,sn.cost+c[op]});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n#define STRAIGHT 0\n#define RIGHT 1\n#define BACK 2\n#define LEFT 3\n#define HALT 4\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n\n\nint memo[30][30][4];\nint c[4];\nint field[30][30];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint h, w;\nvoid rec(int x, int y, int dir) {\n  for (int i = 0; i < 4; i++) {\t// iは命令\n    int p = (i+dir)%4;\t\t// マップ上の向き\n    int nx = x+dx[p];\n    int ny = y+dy[p];\n    if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n    if (field[x][y] == i &&\n\t(memo[nx][ny][p] == -1 ||\n\t memo[nx][ny][p] > memo[x][y][dir])) {\n      memo[nx][ny][p] = memo[x][y][dir];\n      rec(nx, ny, p);\n    }else if (memo[nx][ny][p] == -1 ||\n\t      memo[nx][ny][p] > memo[x][y][dir]+c[i]) {\n      memo[nx][ny][p] = memo[x][y][dir]+c[i];\n      rec(nx, ny, p);\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (w == 0 && h == 0) {\n      break;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n\tint s;\n\tcin >> s;\n\tif (s == STRAIGHT) {\n\t  field[j][i] = STRAIGHT;\n\t}else if (s == RIGHT) {\n\t  field[j][i] = RIGHT;\n\t}else if (s == BACK) {\n\t  field[j][i] = BACK;\n\t}else if (s == LEFT) {\n\t  field[j][i] = LEFT;\n\t}else {\n\t  field[j][i] = HALT;\n\t}\n      }\n    }\n\n    // for (int i = 0; i < h; i++) {\n    //   for (int j = 0; j < w; j++) {\n    // \tstd::cout << field[j][i] << \" \";\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    for (int i = 0; i < 4; i++) {\n      cin >> c[i];\n    }\n\n    memset(memo, -1, sizeof(memo));\n    memo[0][0][RIGHT] = 0;\n    rec(0, 0, RIGHT);\n    // for (int i = 0; i < h; i++) {\n    //   for (int j = 0; j < w; j++) {\n    // \tstd::cout << memo[j][i][LEFT] << \" \";\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n\n    int ans = min(memo[w-1][h-1][EAST], memo[w-1][h-1][SOUTH]);\n\n    std::cout << ans << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\n#define PREV(c, d) ((c - d + 4) % 4)\n#define NEXT(c, d) ((c + d) % 4)\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, iP > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nint h, w, mas[31][31], cost[4];\n// > v < ^\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint dijkstra() {\n    priority_queue< iiP, vector< iiP >, greater< iiP > > que;\n    int costed[31][31][4];\n    que.push(iiP(iP(0, 0),iP(0, 0)));\n    costed[0][0][0] = 0;\n    fill_n(**costed, 31 * 31 * 4, INF);\n    while(!que.empty()) {\n        iiP p = que.top(); que.pop();\n        int x = p.sc.fr, y = p.sc.sc, dir = p.fr.sc, c = p.fr.fr;\n        if(x == w - 1 && y == h - 1) return c;\n        for(int i = 0; i < 4; i++) {\n            int nd = NEXT(dir, i);\n            int nc = (i == mas[y][x] ? c : cost[i] + c);\n            int nx = x + dx[nd], ny = y + dy[nd];\n            if(0 <= nx && nx < w && 0 <= ny && ny < h && nc < costed[nx][ny][nd]) {\n                que.push(iiP(iP(nc, nd), iP(nx, ny)));\n                costed[nx][ny][nd] = nc;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n\n    while(cin >> w >> h, w) {\n        for(int i = 0; i < h; i++)\n            for(int j = 0; j < w; j++)\n                cin >> mas[i][j];\n\n        for(int i = 0; i < 4; i++)\n            cin >> cost[i];\n\n        cout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 10000000;\nconst int MAX_W = 30;\nconst int MAX_H = 30;\nconst int MAX_V = MAX_W * MAX_H * 4;\n\nint field[MAX_H][MAX_W];\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\n// 入力\nint w, h;\nint c[4];\n\nvoid dijkstra(int s) {\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[s] = 0;\n\t\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v])) {\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nvoid solve() {\n\tfor (int i = 0; i < MAX_V; i++) {\n\t\tfill(cost[i], cost[i] + MAX_V, INF);\n\t\tcost[i][i] = 0;\n\t}\n\tfor (int i = 0; i < V; i++) {\n\t\tint place = i / 4;\n\t\tint placex = place % w;\n\t\tint placey = place / w;\n\t\tint direction = i % 4;\n\t\t// 向きと次に進む方向で場合分け\n\t\tswitch (direction) {\n\t\tcase 0: // 右向きの場合\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i+4] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4] = c[0];\n\t\t\t}\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i+4*w+1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w+1] = c[1];\n\t\t\t}\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i-4+2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4+2] = c[2];\n\t\t\t}\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i-4*w+3] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w+3] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: // 下向きの場合\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i+4*w] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w] = c[0];\n\t\t\t}\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i-4+1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4+1] = c[1];\n\t\t\t}\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i-4*w+2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w+2] = c[2];\n\t\t\t}\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i+4-1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4-1] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // 左向きの場合\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i-4] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4] = c[0];\n\t\t\t}\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i-4*w+1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w+1] = c[1];\n\t\t\t}\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i+4-2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4-2] = c[2];\n\t\t\t}\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i+4*w-1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w-1] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: // 上向きの場合\n\t\t\tif (placey == 0) {\n\t\t\t} else if (field[placey][placex] == 0) {\n\t\t\t\tcost[i][i-4*w] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4*w] = c[0];\n\t\t\t}\n\t\t\tif (placex == w - 1) {\n\t\t\t} else if (field[placey][placex] == 1) {\n\t\t\t\tcost[i][i+4-3] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4-3] = c[1];\n\t\t\t}\n\t\t\tif (placey == h - 1) {\n\t\t\t} else if (field[placey][placex] == 2) {\n\t\t\t\tcost[i][i+4*w-2] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i+4*w-2] = c[2];\n\t\t\t}\n\t\t\tif (placex == 0) {\n\t\t\t} else if (field[placey][placex] == 3) {\n\t\t\t\tcost[i][i-4-1] = 0;\n\t\t\t} else {\n\t\t\t\tcost[i][i-4-1] = c[3];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tdijkstra(0);\n\tint ans = min(d[4*(w*h-1)], d[4*(w*h-1)+1]);\n\tcout << ans << endl;\n\t\n\treturn;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tV = w * h * 4;\n\t\t\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint main()\n{\n\tint dx[4]={0, 1, 0, -1}, dy[4]={1, 0, -1, 0};\n\twhile(1){\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0) return 0;\n\t\tint s[30][30];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tfor(int i=0; i<4; i++){\n\t\t\tcin>>c[i];\n\t\t}\n\t\tint d[4][30][30];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\td[k][i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[0][0][0]=0;\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tque.push(PP(P(0, 0), P(0, 0)));\n\t\twhile(!que.empty()){\n\t\t\tPP p=que.top();\n\t\t\tque.pop();\n\t\t\tint k=p.first.second;\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tint t=c[i];\n\t\t\t\tif(s[x][y]==i) t=0;\n\t\t\t\tif(!(x+dx[(k+i)%4]>=0 && x+dx[(k+i)%4]<h && y+dy[(k+i)%4]>=0 && y+dy[(k+i)%4]<w)) continue;\n\t\t\t\tif(d[(k+i)%4][x+dx[(k+i)%4]][y+dy[(k+i)%4]]>d[k][x][y]+t){\n\t\t\t\t\td[(k+i)%4][x+dx[(k+i)%4]][y+dy[(k+i)%4]]=d[k][x][y]+t;\n\t\t\t\t\tque.push(PP(P(d[(k+i)%4][x+dx[(k+i)%4]][y+dy[(k+i)%4]], (k+i)%4), P(x+dx[(k+i)%4], y+dy[(k+i)%4])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(d[i][h-1][w-1]<ans) ans=d[i][h-1][w-1];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\t\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 100000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0) return 0;\n    vector<vector<int>> s(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++) cin >> s[i][j];\n    }\n    vector<int> c(4),vx={1,0,-1,0},vy={0,1,0,-1};\n    cin >> c[0] >> c[1] >> c[2] >> c[3];\n    vector<vector<vector<int>>> dist(h,vector<vector<int>>(w,vector<int>(4,INF)));\n    priority_queue<pair<int,tuple<int,int,int>>> dijk;\n    dijk.push({0,make_tuple(0,0,0)});\n    pair<int,tuple<int,int,int>> now;\n    int nx,ny,muki;\n    while(!dijk.empty()){\n      now=dijk.top();\n      dijk.pop();\n      if(dist[get<1>(now.second)][get<0>(now.second)][get<2>(now.second)]==INF){\n        dist[get<1>(now.second)][get<0>(now.second)][get<2>(now.second)]=-now.first;\n        if(get<1>(now.second)==h-1&&get<0>(now.second)==w-1){\n          // for(int k=0;k<4;k++){\n          //   for(int i=0;i<h;i++){\n          //     for(int j=0;j<w;j++){\n          //       cout << dist[i][j][k] << \" \";\n          //     }\n          //     cout << endl;\n          //   }\n          //   cout << endl;\n          // }\n          cout << -now.first << endl;\n          break;\n        }\n        for(int i=0;i<4;i++){\n          muki=(get<2>(now.second)+i)%4;\n          nx=get<0>(now.second)+vx[muki];\n          ny=get<1>(now.second)+vy[muki];\n          if(0<=nx&&nx<w&&0<=ny&&ny<h){\n            if(dist[ny][nx][muki]==INF){\n              if(s[get<1>(now.second)][get<0>(now.second)]==i){\n                dijk.push({now.first,make_tuple(nx,ny,muki)});\n              }else{\n                dijk.push({now.first-c[i],make_tuple(nx,ny,muki)});\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint c[5];\nint m[50][50];\nint ijk[50][50][4];\nint v[50][50][4];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\tfor(int i=0;i<4;i++)scanf(\"%d\",c+i);\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >Q;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(0,0)));\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tijk[i][j][k]=999999999;\n\t\t\t\t\tv[i][j][k]=0;\n\t\t\t\t}\n\t\tijk[0][0][0]=0;\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first.first;\n\t\t\tint dir=Q.top().first.second;\n\t\t\tint row=Q.top().second.first;\n\t\t\tint col=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[row][col][dir])continue;\n\t\t\tv[row][col][dir]=1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint val=cost;\n\t\t\t\tif(m[row][col]!=i){\n\t\t\t\t\tval+=c[i];\n\t\t\t\t}\n\t\t\t\tint tr=row;\n\t\t\t\tint tc=col;\n\t\t\t\tint td=dir;\n\t\t\t\tif(i==1)td=(td+1)%4;\n\t\t\t\tif(i==2)td=(td+2)%4;\n\t\t\t\tif(i==3)td=(td+3)%4;\n\t\t\t\ttr+=dx[td];\n\t\t\t\ttc+=dy[td];\n\t\t\t\tif(0<=tr&&tr<a&&0<=tc&&tc<b&&!v[tr][tc][td]&&ijk[tr][tc][td]>val){\n\t\t\t\t\tijk[tr][tc][td]=val;\n\t\t\t\t\tQ.push(make_pair(make_pair(-val,td),make_pair(tr,tc)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<4;i++)ret=min(ret,ijk[a-1][b-1][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// start: 3:12\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <sstream>\n#include <deque>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n#define INF INT_MAX\n\nusing namespace std;\n\nclass Rec {\npublic:\n    int x;\n    int y;\n    int d;\n    int cost;\n\n    Rec( int xx, int yy, int dd, int s): x(xx), y(yy), d(dd), cost(s){}\n};\n\nbool operator< (const Rec& rec1, const Rec &rec2) {\n    return rec1.cost > rec2.cost;\n}\nbool operator> (const Rec& rec1, const Rec &rec2) {\n    return rec1.cost < rec2.cost;\n}\n\nint mx[4][4] = {{1, 0, -1, 0},\n                {0, -1, 0, 1},\n                {-1, 0, 1, 0},\n                {0, 1, 0, -1}};\nint my[4][4] = {{0, 1, 0, -1},\n                {1, 0, -1, 0},\n                {0, -1, 0, 1},\n                {-1, 0, 1, 0}};\n\nvoid dump(vector<vector<int> > &f, int x = -1, int y = -1) {\n    REP(i, f.size()) {\n        REP(j, f[i].size()) {\n            if ( i == x, j == y ) cout << \"# \";\n            else cout << f[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        // cout << w << \" \" << h << endl;\n        priority_queue< Rec, vector<Rec>, less<vector<Rec>::value_type> > pq;\n\n        vector< vector<int> > f(h, vector<int>(w));\n        int closed[h][w][4];\n        int COST[4];\n\n        REP(y, h) REP(x, w) REP(i, 4) closed[y][x][i] = INF;\n\n        REP(y, h) REP(x, w) cin >> f[y][x];\n        REP(i, 4) cin >> COST[i];\n\n        // dump(f);\n\n        pq.push( Rec(0, 0, 0, 0));\n\n        closed[0][0][0] = 0;\n\n        while(!pq.empty()) {\n\n            Rec tmp = pq.top(); pq.pop();\n            int x = tmp.x,\n                y = tmp.y,\n                d = tmp.d,\n                cost = tmp.cost,\n                o = f[y][x];\n\n            // printf(\"n:%d %d %d: %d\\n\", x, y, d, (0 <= x && x < w && 0 <= y && y < h));\n\n            // ゴール\n            if ( x == w-1 && y == h-1 ) {\n                cout << cost << endl;\n                break;\n            }\n\n            int nx = x + mx[d][o],\n                ny = y + my[d][o],\n                nd = (d+o) % 4;\n\n            // マス目移動\n            if ( o != 4 && 0 <= nx && nx < w && 0 <= ny && ny < h && cost < closed[ny][nx][nd] ) pq.push( Rec(nx, ny, nd, cost) );\n\n            // 命令出す\n            REP(i, 4) {\n                if ( i == o ) continue; // マス目の命令と同じ\n\n                int nx = x + mx[d][i],\n                    ny = y + my[d][i],\n                    nd = (d+i)%4;\n\n                if ( 0 <= nx && nx < w && 0 <= ny && ny < h && cost+COST[i] < closed[ny][nx][nd] ) {\n                    pq.push( Rec(nx, ny, nd, cost+COST[i]) );\n                    closed[ny][nx][nd] = cost+COST[i];\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nclass S{\npublic:\n  int y, x, d, cost;\n  S(){}\n  S(int y, int x, int d, int cost) : y(y), x(x), d(d), cost(cost) {}\n};\n\nint h, w;\nint map[30][30];\nint cost[4];\nint vis[30][30][4];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool check(int y, int x){\n  if(y<0 || y>=h) return false;\n  if(x<0 || x>=w) return false;\n  return true;\n}\n\nint solve(){\n  S u, v;\n  queue<S> q;\n  q.push(S(0, 0, 1, 0));\n  fill(vis[0][0], vis[30][0], INF);\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    if(map[u.y][u.x] != 4){\n      v.d = (u.d+map[u.y][u.x])%4;\n      v.y = u.y + dy[v.d];\n      v.x = u.x + dx[v.d];\n      v.cost = u.cost;\n      if(check(v.y, v.x) && vis[v.y][v.x][v.d] > v.cost){\n        vis[v.y][v.x][v.d] = v.cost;\n        q.push(v);\n      }\n    }\n    for(int i=0;i<4;i++){\n      v.d = (u.d+i) % 4;\n      v.y = u.y + dy[v.d];\n      v.x = u.x + dx[v.d];\n      v.cost = u.cost + cost[i];\n      if(check(v.y, v.x) && vis[v.y][v.x][v.d] > v.cost){\n        vis[v.y][v.x][v.d] = v.cost;\n        q.push(v);\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++) res = min(res, vis[h-1][w-1][i]);\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (h|w)){\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> map[i][j];\n    for(int i=0;i<4;i++) cin >> cost[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint w,h,s[30][30],c[4],d[900][4],ans; //d[pos][dir]:=位置posに向きdirで入るための最小コスト\n\nint encode(int y,int x){\n    return w*y+x;\n}\n\npii decode(int pos){\n    return pii(pos/w,pos%w);\n}\n\nvoid dijkstra(){\n    ans=inf;\n    fill_n((int*)d,900*4,inf);\n    d[0][0]=0;\n    priority_queue<pair<int,pii>,vector<pair<int,pii>>,greater<pair<int,pii>>> que;\n    que.push(make_pair(0,pii(0,0)));\n    while(!que.empty()){\n        pair<int,pii> p=que.top(); que.pop();\n        int dist=p.first,pos=p.second.first;\n        int y=decode(pos).first,x=decode(pos).second,dir=p.second.second;\n\n        if(y==h-1 and x==w-1){\n            ans=min(ans,dist);\n            continue;\n        }\n        if(dist>d[encode(y,x)][dir]) continue;\n\n        rep(i,0,4){\n            int cost=c[i],ndir=(dir+i)%4;\n            if(i==s[y][x]) cost=0;\n            \n            int ny=y+dy[ndir],nx=x+dx[ndir];\n            int npos=encode(ny,nx);\n            if(ny<0 or h<=ny or nx<0 or w<=nx) continue;\n            if(dist+cost<d[npos][ndir]){\n                d[npos][ndir]=dist+cost;\n                que.push(make_pair(d[npos][ndir],pii(npos,ndir)));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n\n        rep(y,0,h) rep(x,0,w) cin >> s[y][x];\n        rep(i,0,4) cin >> c[i];\n\n        dijkstra();\n\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n#define inf 101010\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pp;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nint w, h;\nint g[31][31];\nint dp[31][31][4];\nint c[4];\n\nbool r(int y, int x) {\n    if (y >= 0 && y < h && x >= 0 && x < w) return true;\n    else return false;\n}\n\nint main(void){\n    while (cin>>w>>h && w) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> g[i][j];\n                for (int k = 0; k < 4; k++) dp[i][j][k] = inf;\n            }\n        }\n        for (int i = 0; i < 4; i++) cin >> c[i];\n        \n        dp[0][0][1] = 0;\n        queue<pp> que;\n        que.push(mp(mp(0,0), 1));\n        \n        while (!que.empty()) {\n            pp p = que.front(); que.pop();\n            int ty = p.first.first, tx = p.first.second, td = p.second;\n            for (int i = 0; i < 4; i++) {\n                int nd = (td+i)%4;\n                int ny = ty + dy[nd], nx = tx + dx[nd];\n                if (!r(ny,nx)) continue;\n                \n                int cost = c[i];\n                if (g[ty][tx] == i) cost = 0;\n                \n                if (dp[ny][nx][nd] > dp[ty][tx][td]+cost) {\n                    dp[ny][nx][nd] = dp[ty][tx][td]+cost;\n                    que.push(mp(mp(ny,nx), nd));\n                }\n            }\n        }\n        int ans = inf;\n        for (int i = 0; i < 4; i++) ans = min(ans, dp[h-1][w-1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define ck(a,b) (0<=a&&a<b)\nusing namespace std;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,c[4],s[30][30],cost[30][30][4];\nstruct S{\n\tint y,x,d,c;\n\tbool operator<(const S &a)const{\n\t\treturn c>a.c;\n\t}\n};\nint main(){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w){\n\t\t\trep(k,4)cost[i][j][k]=INF;\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\trep(i,4)cin>>c[i]; cost[0][0][0]=0;\n\t\tpriority_queue<S> Q;\n\t\tS cs,ns; cs.y=cs.x=cs.d=cs.c=0; Q.push(cs);\n\t\twhile(!Q.empty()){\n\t\t\tcs=Q.top(),Q.pop();\n\t\t\tif(cs.y==h-1&&cs.x==w-1){\n\t\t\t\tcout<<cs.c<<endl; break;\n\t\t\t}\n\t\t\trep(r,4){\n\t\t\t\tns.d=cs.d+r&3,ns.y=cs.y+dy[ns.d],ns.x=cs.x+dx[ns.d],\n\t\t\t\tns.c=cs.c+(r==s[cs.y][cs.x]?0:c[r]);\n\t\t\t\tif(ck(ns.y,h)&&ck(ns.x,w)&&cost[ns.y][ns.x][ns.d]>ns.c)\n\t\t\t\tcost[ns.y][ns.x][ns.d]=ns.c,Q.push(ns);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll MOD=1000000007;\nconst ll E=1e18;\n\nconst ll MX=40;\n\nll dp[MX][MX][4];\nll A[MX][MX];\n\nvector<ll> dx={-1,0,1,0};\nvector<ll> dy={0,1,0,-1};\n\n\nint main(){\n  ll h,w;\n  while(cin>>w>>h){\n    if(h==0){break;}\n  for(int i=0;i<h;i++){\n    for(int t=0;t<w;t++){\n      for(int j=0;j<4;j++){dp[i][t][j]=-E;}\n      cin>>A[i][t];\n    }\n  }\n  vector<ll> cost(4);\n  for(auto &I:cost){cin>>I;}\n  priority_queue<pair<pll,pll>> Q;//cost,muki,h,w\n  dp[0][0][1]=0;\n  Q.push({{0,1},{0,0}});\n  while(!Q.empty()){\n    auto I=Q.top(); Q.pop();\n    ll x=I.S.F,y=I.S.S,k=I.F.S;\n    if(dp[x][y][k]!=I.F.F){continue;}\n    //cout<<x<<\" \"<<y<<\" \"<<k<<\" \"<<-1LL*I.F.F<<endl;\n    for(int i=0;i<4;i++){\n      ll d=(k+i)%4;\n      ll X=x+dx[d];\n      ll Y=y+dy[d];\n      if(X<0 || Y<0 || X>=h || Y>=w){continue;}\n      ll n=I.F.F;\n      if(i!=A[x][y]){n-=cost[i];}\n      if(dp[X][Y][d]<n){dp[X][Y][d]=n; Q.push({{n,d},{X,Y}});}\n    }\n  }\n  \n  ll ans=E;\n  for(int j=0;j<4;j++){\n    ans=min(ans,-1LL*dp[h-1][w-1][j]);\n  }\n  cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Robo\n{\n\tint x, y, dir, cost;\n\tRobo(int x, int y, int dir, int cost)\n\t\t: x(x), y(y), dir(dir), cost(cost) { }\n};\nbool operator<(const Robo& a, const Robo& b)\n{\n\treturn a.cost > b.cost;\n}\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w)\n\t{\n\t\tint s[32][32];\n\t\trep (y, h)\n\t\t\trep (x, w)\n\t\t\t\tscanf(\"%d\", &s[y][x]);\n\t\tint c[4];\n\t\trep (i, 4)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tconst int INF = 1 << 26;\n\t\tint dis[32][32][4];\n\t\trep (y, h)\n\t\t\trep (x, w)\n\t\t\t\trep (i, 4)\n\t\t\t\t\tdis[y][x][i] = INF;\n\n\t\tpriority_queue<Robo> q;\n\t\tdis[0][0][1] = 0;\n\t\tq.push(Robo(0, 0, 1, 0));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tRobo r = q.top(); q.pop();\n\t\t\tif (r.cost > dis[r.y][r.x][r.dir])\n\t\t\t\tcontinue;\n\t\t\telse if (r.x == w - 1 && r.y == h - 1)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", r.cost);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint nc = r.cost;\n\t\t\t\tif (i != s[r.y][r.x])\n\t\t\t\t\tnc += c[i];\n\n\t\t\t\tint d = 0;\n\t\t\t\tif (i == 1)\n\t\t\t\t\td = 3;\n\t\t\t\telse if (i == 2)\n\t\t\t\t\td = 2;\n\t\t\t\telse if (i == 3)\n\t\t\t\t\td = 1;\n\t\t\t\tint nd = (r.dir + d) % 4;\n\t\t\t\tint nx = r.x + dx[nd], ny = r.y + dy[nd];\n\n\t\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && nc < dis[ny][nx][nd])\n\t\t\t\t{\n\t\t\t\t\tdis[ny][nx][nd] = nc;\n\t\t\t\t\tq.push(Robo(nx, ny, nd, nc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nint s[31][31];\nint c[4];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nbool ischecked[31][31][4];\n// N : 2 S : 0 E: 1 W : 3\n\nbool solve(int x, int y, int d, int cost, int maxcost)\n{\n    if(cost > maxcost) return false;\n    // cout << x << y << d << cost << endl;\n    if(x == h - 1 && y == w - 1) return true;\n    for(int i = 0; i < 4; i++){\n        int nx, ny;\n        int newd = d;\n        if(i == 1){\n            newd += 3;\n        } else if(i == 2){\n            newd += 2;\n        } else if(i == 3){\n            newd += 1;\n        }\n        newd = newd % 4;\n        nx = x + dx[newd];\n        ny = y + dy[newd];\n        if(nx < 0 || ny < 0 || nx >= h || ny >= w || ischecked[nx][ny][newd]) continue;\n        ischecked[nx][ny][newd] = true;\n        if((i == s[x][y] && solve(nx, ny, newd, cost, maxcost)) || solve(nx, ny, newd, cost + c[i], maxcost)){\n            ischecked[nx][ny][newd] = false;\n            return true;\n        }\n        ischecked[nx][ny][newd] = false;\n    }\n    return false;\n    // cout << x << y << d << \" \" << mincost[x][y][d] << endl;\n    // if(mincost[x][y][d] == 1000000) mincost[x][y][d] = 1000001;\n    // return mincost[x][y][d];\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> s[i][j];\n                for(int k = 0; k < 4; k++){\n                    ischecked[i][j][k] = false;\n                }\n            }\n        }\n        for(int i = 0; i < 4; i++){\n            cin >> c[i];\n        }\n        ischecked[0][0][1] = true;\n        int left = 0, right = 9 * 31 * 31;\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            // cout << mid << endl;\n            if(solve(0, 0, 1, 0, mid)) right = mid;\n            else left = mid;\n        }\n        cout << right << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nvector< vector< vector< int > > > costs;\n\nstruct data_t {\n\tint m_d, m_x, m_y;\n\tdata_t(int d, int y, int x) { m_d = d; m_y = y; m_x = x; }\n};\n\nint solve(void);\n\nint main(void) {\n\t\t\n\twhile (solve());\n\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\t//\tinput\n\n\tint w, h;\n\n\tcin >> w >> h;\n\tif (!(w | h)) { return 0; }\n\n\tvector< vector< int > > s(h, vector< int > (w, (1<<30)));\n\tcosts.clear();\n\tcosts.resize(4, s);\n\tvector<int> c(4);\n\n\t// right, down, left, up\n\tint d[4][2] = { {0,1}, {1,0}, {0,-1},{-1,0} };\n\n\tfor (int i = 0; i < h; i++)\n\t\tfor (int j = 0; j < w; j++)\n\t\t\tcin >> s[i][j];\n\n\tfor (int i = 0; i < 4; i++)\n\t\tcin >> c[i];\n\n\t//0: ?????´????????????\n\t//1 : ??????????????????\n\t//2 : ????????¢?????????\n\t//3 : ??????????????????\n\t//4 : ????????¢?????????\n\n\tcosts[0][0][0] = 0;\n\n\tqueue< data_t > q;\n\tq.push(data_t(0, 0, 0));\n\n\twhile (!q.empty()) {\n\n\t\tdata_t doneNode = q.front();\n\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tdata_t to = doneNode;\n\t\t\tint cost = costs[doneNode.m_d][doneNode.m_y][doneNode.m_x] + c[i];\n\t\t\tif (i == s[to.m_y][to.m_x]) { cost = costs[doneNode.m_d][doneNode.m_y][doneNode.m_x]; }\n\n\t\t\tto.m_d = (to.m_d + i) % 4;\n\t\t\tto.m_y += d[to.m_d][0];\n\t\t\tto.m_x += d[to.m_d][1];\n\t\t\t\n\t\t\tif (to.m_x >= 0 && to.m_x < w && to.m_y >= 0 && to.m_y < h) {\n\t\t\t\tif (cost < costs[to.m_d][to.m_y][to.m_x]) {\n\t\t\t\t\tcosts[to.m_d][to.m_y][to.m_x] = cost;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t\n\tint ans = costs[0][h - 1][w - 1];\n\n\tfor (int i = 0; i < 4; i++)\n\t\tans = min(ans, costs[i][h - 1][w - 1]);\n\n\tcout << ans << endl;\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <memory>\n#include <cstdio>\n#include <memory.h>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pip;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint w, h;\nint area[31][31];\nint min_cost[31][31][4];\nint c[4];\n\nvoid bfs(){\n\tqueue<pip> qp;\n\tqp.push(make_pair(0, make_pair(1, 1)));\n\twhile(!qp.empty()){\n\t\tpip p = qp.front(); qp.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint d = p.first;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint y2 = y+dy[(d+i)%4];\n\t\t\tint x2 = x+dx[(d+i)%4];\n\t\t\tif(y2 < 1 || y2 > h || x2 < 1 || x2 > w) continue;\n\t\t\tint cost = 0;\n\t\t\tint d2 = (d+i)%4;\n\t\t\tif(area[y][x] != i) cost = c[i];\n\t\t\tif(min_cost[y2][x2][d2] < 0 || min_cost[y][x][d] + cost < min_cost[y2][x2][d2]){\n\t\t\t\tmin_cost[y2][x2][d2] = min_cost[y][x][d] + cost;\n\t\t\t\tqp.push(make_pair(d2, make_pair(y2, x2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(min_cost, -1, sizeof(min_cost));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tmin_cost[1][1][0] = 0;\n\t\tbfs();\n\t\tint cost = 1 << 15;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(min_cost[h][w][i] > 0) cost = min(cost, min_cost[h][w][i]);\n\t\t}\n\t\tif(cost == 1 << 15) cout << -1 << endl;\n\t\telse cout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,c,w;\n\tbool operator<(const data &d)const{\n\t\treturn d.c<c;\n\t}\n};\n\nint w,h;\nint fie[31][31];\nint dp[31][31][4];\nint c[5];\nint sx[4]={1,0,-1,0};\nint sy[4]={0,1,0,-1};\nint dijk(){\n\tpriority_queue<data> que;\n\tdata ind;\n\tmemset(dp,-1,sizeof(dp));\n\tind.x=0,ind.y=0,ind.c=0,ind.w=0;\n\tque.push(ind);\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.w]!=-1 && dp[d.x][d.y][d.w]<d.c)continue;\n\t\tif(d.x==w-1 && d.y==h-1)return d.c;\n\t\tdp[d.x][d.y][d.w]=d.c;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tdata nd=d;\n\t\t\tif(fie[d.x][d.y]!=i)nd.c+=c[i];\n\t\t\tnd.w=(nd.w+i)%4;\n\t\t\tnd.x+=sx[nd.w];\n\t\t\tnd.y+=sy[nd.w];\n\t\t\tif(nd.x>=0 && nd.x<w && nd.y>=0 && nd.y<h){\n\t\t\t\tif(dp[nd.x][nd.y][nd.w]>nd.c || dp[nd.x][nd.y][nd.w]==-1){\n\t\t\t\t\tdp[nd.x][nd.y][nd.w]=nd.c;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d\",&c[i]);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <array>\n#include <complex>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n#define _gp(l) const auto gcu{getchar##l}; const auto pcu{putchar##l}\n#ifdef __linux\n_gp(_unlocked);\n#else\n_gp();\n#endif\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n_T _DEF(T,in,int c){T n=0;int m=1;while(isspace(c)){c=gcu();}if(c=='-')m=-1,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n_DEF(int,in,){return in<int>(gcu());}\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n_T _SCAN(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_DEF(bool, scan, int &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_SCAN(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=(char)c;}}\n#endif\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);} _OUT(const char *s){while(*s)pcu(*s++);} _OUT(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_OUT(string s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _OUT(vector<T> v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _OUTL(T&&... t){out(move(t)...);outl();}\nstruct range{\n\tint e,b=0,s=1; range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it { int v, s; it (int _v, int _s) : v(_v), s(_s) {} operator int()const{return v;} operator int&(){return v;} int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin() {return {b, s};} it end() {return {e, s};}};\n\n_T using V = vector<T>;\n_T using A = array<T, 4>;\nusing P = complex<int>;\n#define pos(o, p) o[imag(p)][real(p)]\nstruct N {\n\tint c, d; P p;\n\tN (int ct, int dt, P pt) : c{ct}, d{dt}, p{pt} {}\n\tbool operator < (const N a) const {return c > a.c;}\n};\n\nint main() {\n\tconst A<P> r {P{1, 0}, P{0, 1}, P{-1, 0}, P{0, -1}};\n\trange r4(4);\n\tfor (int w, h; w = in(), h = in();) {\n\t\tV<V<int>> m(h + 2, V<int>(w + 2));\n\t\tfor (int i: range(1, h + 1))\n\t\t\tm[i][0] = m[i][w + 1] = -1;\n\t\tfor (int i: range(m[0].size()))\n\t\t\tm[0][i] = m[h + 1][i] = -1;\n\t\tV<V<V<int>>> v(h + 2, V<V<int>>(w + 2, V<int>(4, INT_MAX)));\n\t\tA<int> c;\n\n\t\tfor (int i: range(1, h + 1))\n\t\t\tfor (int j: range(1, w + 1))\n\t\t\t\tm[i][j] = in();\n\t\tfor (int &i: c)\n\t\t\ti = in();\n\n\t\tpriority_queue<N> q;\n\t\tq.emplace(0, 0, P{1, 1});\n\t\tconst P e {w, h};\n\t\twhile (!q.empty()) {\n\t\t\tN n = q.top();\n\t\t\tq.pop();\n\t\t\tif (n.p == e) {\n\t\t\t\toutl(n.c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (exchange(pos(v, n.p)[n.d], n.c) < n.c)\n\t\t\t\tcontinue;\n\t\t\tint o = pos(m, n.p);\n\t\t\tfor (int i: r4) {\n\t\t\t\tint d {(n.d + i) % 4};\n\t\t\t\tP t {n.p + r[d]};\n\t\t\t\tint cost = n.c + (i == o ? 0 : c[i]);\n\t\t\t\tif (pos(m, t) >= 0 && cost < pos(v, t)[d]) {\n\t\t\t\t\tpos(v, t)[d] = cost;\n\t\t\t\t\tq.emplace(cost, d, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int MAX_V = 3600;\nconst int INF = 9999999;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nint h, w;\n\nbool in(int i, int j){\n\treturn 0 <= i && i < h && 0 <= j && j < w;\n}\n\nint toV(int i, int j, int dir){\n\treturn 4 * (i * w + j) + dir;\n}\n\nvoid calc(){\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[0] = 0;\n\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t}\n\n\t\tif (v == -1)break;\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tvvi s = vvi(h, vi(w, 0));\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> s[i][j];\n\t\tint c[4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tcin >> c[i];\n\n\t\tfor (int i = 0; i < MAX_V; i++)\n\t\t\tfor (int j = 0; j < MAX_V; j++)\n\t\t\t\tcost[i][j] = INF;\n\n\t\tV = 4 * w * h;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\t\tcost[toV(i, j, dir)][toV(i, j, dir)] = 0;\n\t\t\t\t\tfor (int ndir = 0; ndir < 4; ndir++) {\n\t\t\t\t\t\tint ni = i + dy[ndir], nj = j + dx[ndir];\n\t\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\t\tif (s[i][j] != 4 && (dir + s[i][j]) % 4 == ndir)\n\t\t\t\t\t\t\tcost[toV(i, j, dir)][toV(ni, nj, ndir)] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcost[toV(i, j, dir)][toV(ni, nj, ndir)] = c[(ndir - dir + 4) % 4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalc();\n\n\t\tint ans = INF;\n\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\tans = min(ans, d[toV(h - 1, w - 1, dir)]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct State{\n  int x,y;\n  int cnt;\n  int rotate;\n};\n\nint main(void){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int s[31][31],min[31][31][4];\n    for(int i=0;i<h;++i){\n      for(int j=0;j<w;++j){\n        cin>>s[i][j];\n      }\n    }\n    int c[4];\n    for(int i=0;i<4;++i){\n      cin>>c[i];\n    }\n    for(int i=0;i<h;++i){\n      for(int j=0;j<w;++j){\n        for(int k=0;k<4;++k){\n          min[i][j][k]=(w+h)*10;\n        }\n      }\n    }\n    State initial;\n    initial.x=0;initial.y=0;initial.cnt=0;initial.rotate=0;\n    vector<State> qu;\n    qu.push_back(initial);\n    while(!qu.empty()){\n      const int DX[]={1,0,-1,0},DY[]={0,1,0,-1};\n      State b=qu.back();qu.pop_back();\n      if(b.x<0 || w<=b.x || b.y<0 || h<=b.y) continue;\n      if(min[b.y][b.x][b.rotate]>b.cnt)min[b.y][b.x][b.rotate]=b.cnt;\n      else continue;\n      State a;\n      for(int i=0;i<4;++i){\n        if(s[b.y][b.x]==i) a.cnt=b.cnt;\n        else a.cnt=b.cnt+c[i];\n        a.rotate=(b.rotate+i)%4;\n        a.x=b.x+DX[a.rotate];a.y=b.y+DY[a.rotate];\n        qu.push_back(a);\n      }\n    }\n#if 0\n     for(int i=0;i<h;++i){\n      for(int j=0;j<w;++j){\n        for(int k=0;k<4;++k){\n          cerr<<min[i][j][k]<<\" \";\n        }\n        cerr<<\",\";\n      }\n      cerr<<endl;\n    }\n#endif\n    int ans=(w+h)*10;\n    for(int i=0;i<4;++i){\n    \tif(ans>min[h-1][w-1][i])ans=min[h-1][w-1][i];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nconst int SIZE = 31;\nconst int INF = 1<<27;\nint G[SIZE][SIZE], C[4];\nint H, W;\nstruct dijkstra {\n  int x, y, d, cost;\n  State() {}\n  State(int x, int y, int d, int cost) : x(x), y(y), d(d), cost(cost) {}\n  bool operator<(const State &s) const {\n    return cost<s.cost;\n  }\n};\n \nint dijkstra() {\n  int cost[4][SIZE][SIZE];\n  priority_queue<State,vector<State>,greater<State> > pq;\n  pq.push(State(0,0,0,0));\n  fill(cost[0][0], cost[4][0], INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()) {\n    const State s = pq.top(); pq.pop();\n    if(cost[s.d][s.y][s.x] < s.cost) continue;\n    if(s.x == W-1 && s.y == H-1) return s.cost;\n    for(int i=0; i<4; i++) {\n      State t = s;\n      t.cost += ( G[s.y][s.x] == i ? 0 : C[i] );\n      t.d = (s.d + i) % 4;\n      t.x += dx[t.d], t.y += dy[t.d];\n      if(0 <= t.x && t.x < W \n     && 0 <= t.y && t.y < H \n     && cost[t.d][t.y][t.x] > t.cost) {\n    pq.push(t);\n    cost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n   \n  return INF;\n}\n \nint main() {\n  while(cin >> W >> H, W+H) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n    cin >> G[i][j];\n    for(int i=0; i<4; i++) cin >> C[i];\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nclass node {\npublic:\n  int cost, x, y, d;\n  node(int _cost, int _x, int _y, int _d) {\n    cost = _cost;\n    x = _x;\n    y = _y;\n    d = _d;\n  }\n  bool operator > (const node &s) const {\n    return cost > s.cost;\n  }\n};\n\nint main() {\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {-1, 0, 1, 0};\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) {\n      break;\n    }\n\n    int field[w][h];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n\tcin >> field[j][i];\n      }\n    }\n    int d[4];\n    for (int i = 0; i < 4; i++) {\n      cin >> d[i];\n    }\n\n    int memo[w][h][4];\n    memset(memo, -1, sizeof(memo));\n    memo[0][0][1] = 0;\n    priority_queue <node, vector<node>, greater<node> > pque;\n    pque.push(node(0, 0, 0, 1));\n    while (!pque.empty()) {\n      node p = pque.top(); pque.pop();\n\n      for (int i = 0; i < 4; i++) {\n\tint nd = (i+p.d)%4;\n\tint nx = p.x+dx[nd];\n\tint ny = p.y+dy[nd];\n\n\tif (nx < 0 || ny < 0 || nx >= w || ny >= h) {\n\t  continue;\n\t}\n\tif (field[p.x][p.y] == i) {\n\t  if (memo[nx][ny][nd] == -1 ||\n\t      memo[nx][ny][nd] > memo[p.x][p.y][p.d]) {\n\t    memo[nx][ny][nd] = memo[p.x][p.y][p.d];\n\t    pque.push(node(memo[nx][ny][nd], nx, ny, nd));\n\t  }\n\t}else {\n\t  if (memo[nx][ny][nd] == -1 ||\n\t      memo[nx][ny][nd] > memo[p.x][p.y][p.d]+d[i]) {\n\t    memo[nx][ny][nd] = memo[p.x][p.y][p.d]+d[i];\n\t    pque.push(node(memo[nx][ny][nd], nx, ny, nd));\n\t  }\n\t}\n      }\n    }\n\n    std::cout << min(memo[w-1][h-1][1], memo[w-1][h-1][2]) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 5000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\tpair<bool, bool> hoge = pair<bool, bool>(false, false);\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\tif(p.second.first == P(h - 1, w - 1)) {\n\t\t\t\tif(p.second.second == 1) hoge.first = true;\n\t\t\t\tif(p.second.second == 2) hoge.second = true;\n\t\t\t}\n\t\t\tif(hoge.first && hoge.second) break;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nconst int dh[] = {-1, 0, 1, 0};\nconst int dw[] = {0, 1, 0, -1};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int W, H;\n    while(cin>>W>>H, W|H){\n        vector<vector<int>> field(H, vector<int>(W));\n        vector<int> dcost(4);\n        \n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                cin >> field[i][j];\n        for(int i=0; i<4; i++)\n            cin >> dcost[i];\n        \n        vector<vector<vector<int>>> d(H, vector<vector<int>>(W, vector<int>(4, INF)));\n        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<pair<int, vector<int>>>> que;\n        d[0][0][1] = 0;\n        que.push(make_pair(d[0][0][1], vector<int>{0, 0, 1}));\n        \n        while (!que.empty()) {\n            auto v = que.top(); que.pop();\n            int cost = v.first;\n            int h = v.second[0], w = v.second[1], dir = v.second[2];\n            if(d[h][w][dir] != cost)\n                continue;\n            \n            for(int i=0; i<4; i++){\n                int ncost;\n                if(field[h][w] == i){\n                    ncost = cost;\n                }else{\n                    ncost = cost + dcost[i];\n                }\n                int ndir = (dir+i)%4;\n                int nh = h + dh[ndir];\n                int nw = w + dw[ndir];\n                if(0<=nh&&nh<H && 0<=nw&&nw<W && d[nh][nw][ndir]>ncost){\n                    d[nh][nw][ndir] = ncost;\n                    que.push(make_pair(ncost, vector<int>{nh, nw, ndir}));\n                }\n            }\n        }\n        \n        int ans = INF;\n        for(int i=0; i<4; i++)\n            ans = min(ans, d[H-1][W-1][i]);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define M 30\n#define INF 10000000\n\n#define min(a,b) ((a)>(b)?(b):(a))\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main() {\n\tint map[M+4][M+4], c[4], w, h;\n\tint dp[M+4][M+4][M*M*2+10][5], ans;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!w&&!h) break;\n\t\tfor(int i=1; i<=h; ++i) {\n\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tfor(int t=0; t<=w*h; ++t) {\n\t\t\t\t\tfor(int k=0; k<4; ++k) dp[i][j][t][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; ++i) cin >> c[i];\n\t\tdp[1][1][0][0] = 0; ans = INF;\n\t\tfor(int t=1; t<=w*h*2; ++t) {\n\t\t\tfor(int i=1; i<=h; ++i) {\n\t\t\t\tfor(int j=1; j<=w; ++j) {\n\t\t\t\t\tif(i==h&&j==w) continue;\n\t\t\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\t\t\tfor(int l=0; l<4; ++l) {\n\t\t\t\t\t\t\tint d = (k+l)%4;\n\t\t\t\t\t\t\tif(map[i][j]==l) {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]);\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdp[i+dy[d]][j+dx[d]][t][d] = min(dp[i+dy[d]][j+dx[d]][t][d], dp[i][j][t-1][k]+c[l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j+dx[d]==w&&i+dy[d]==h) {\n\t\t\t\t\t\t\t\tans = min(ans, dp[i+dy[d]][j+dx[d]][t][d]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tint x, y, d, c;\n\tstate(int x, int y, int d, int c) : x(x), y(y), d(d), c(c) {};\n\tbool operator<(const state other)const {\n\t\treturn c>other.c;\n\t}\n};\n\nint dd(int s, int d) {\n\tswitch(s) {\n\tcase 0:\n\t\treturn d;\n\tcase 1:\n\t\treturn (d+1)%4;\n\tcase 2:\n\t\treturn (d+2)%4;\n\tcase 3:\n\t\treturn (d+3)%4;\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h, vi(w));\n\t\tvi  pay(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> pay[i];\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0, 0, 0));\n\t\tvector<vvi> cost(h, vvi(w, vi(4, INF)));\n\t\tcost[0][0][0] = 0;\n\t\tint ans = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.x == w-1 && st.y == h-1) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(s, 4) {\n\t\t\t\tint nd = dd(s, st.d);\n\t\t\t\tint nx = st.x + dx[nd];\n\t\t\t\tint ny = st.y + dy[nd];\n\t\t\t\tint nc = st.c;\n\t\t\t\tif(field[st.y][st.x] != s) {\n\t\t\t\t\tnc += pay[s];\n\t\t\t\t}\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h) {\n\t\t\t\t\tif(cost[ny][nx][nd] > nc) {\n\t\t\t\t\t\tcost[ny][nx][nd] = nc;\n\t\t\t\t\t\tQ.push(state(nx, ny, nd, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w,h;\n\nint table[35][35];\nint c[4];\nint dist[35][35][4];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nstruct state{\n\tint x,y,d,costs;\n\tbool operator<(const state &arg)const{\n\t\treturn costs < arg.costs;\n\t}\n};\n\nvoid dijkstra(){\n\trep(i,h)rep(j,w)rep(k,4)dist[i][j][k]=inf;\n\tdist[0][0][1]=0;\n\tstate s;\n\ts.x=0,s.y=0,s.d=1,s.costs=0;\n\tpriority_queue<state> q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint x,y,d,costs;\n\t\tx=cur.x,y=cur.y,d=cur.d,costs=cur.costs;\n\t\tif(dist[y][x][d]<costs)\n\t\t\tcontinue;\n\t\trep(i,4){\n\t\t\tint nx=x,ny=y,nd=d,ncosts=costs;\n\t\t\tnd=(nd+i)%4;\n\t\t\tnx+=dx[nd],ny+=dy[nd];\n\t\t\tif(table[y][x]!=i)\n\t\t\t\tncosts+=c[i];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\tif(dist[ny][nx][nd]>ncosts){\n\t\t\t\t\tdist[ny][nx][nd]=ncosts;\n\t\t\t\t\tstate nexts;\n\t\t\t\t\tnexts.x=nx,nexts.y=ny,nexts.d=nd,nexts.costs=ncosts;\n\t\t\t\t\tq.push(nexts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0)\n\t\t\tbreak;\n\t\trep(i,h)rep(j,w) scanf(\"%d\",&table[i][j]);\n\t\trep(i,4) scanf(\"%d\",&c[i]);\n\t\tdijkstra();\n\t\tint ans=inf;\n\t\trep(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nconst Vector<Int> dx({0, 1, 0, -1}), dy({1, 0, -1, 0});\n\nBool solve() {\n    Int w, h;\n    std::cin >> w >> h;\n    if (w == 0) return false;\n\n    Matrix<Int> s = genv<Int>(h, w, 0LL);\n    for (auto& v : s) {\n        for (auto& x : v) {\n            std::cin >> x;\n        }\n    }\n\n    Vector<Int> c(4);\n    for (auto& x : c) std::cin >> x;\n\n    auto dp = genv<Int>(h, w, 4, INF);\n    dp[0][0][0] = 0;\n\n    MinHeap<Tuple<Int, Int, Int, Int>> heap;\n    heap.emplace(0, 0, 0, 0);\n    while (!heap.empty()) {\n        Int dist, x, y, d;\n        std::tie(dist, x, y, d) = heap.top();\n        heap.pop();\n        if (dist > dp[x][y][d]) continue;\n\n        for (Int i = 0; i < 4; ++i) {\n            Int nd = (d + i) % 4;\n            Int nx = x + dx[nd], ny = y + dy[nd];\n            Int cost = (i == s[x][y] ? 0 : c[i]);\n\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny ||\n                dp[nx][ny][nd] <= dp[x][y][d] + cost) continue;\n\n            dp[nx][ny][nd] = dp[x][y][d] + cost;\n            heap.emplace(dp[nx][ny][nd], nx, ny, nd);\n        }\n    }\n\n    std::cout << *std::min_element(dp[h - 1][w - 1].begin(), dp[h - 1][w - 1].end()) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\ntypedef pair<mp,mp> mmp;\nll inf =  1e9;\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\nint main(){\n while(1){\n  ll w,h;\n  cin>>w>>h;\n  if(w==0)break;\n  vector<vector<ll> > t(h,vector<ll>(w,4) );\n  for(ll i=0;i<h;i++){\n   for(ll j=0;j<w;j++)cin>>t[i][j];\n  }\n\n  ll c[4];\n  for(ll i=0;i<4;i++)cin>>c[i];\n\n  priority_queue<mmp,vector<mmp>,greater<mmp> > q;\n  vector<vector<vector<ll> > > dp(4,vector<vector<ll> >(h,vector<ll>(w,inf) ) );\n  //dp[0][0][0] = 0;\n  //ll dir = 0;\n  q.push( mmp( mp(0,0) , mp(0,0) ) );\n\n  while( !q.empty() ){\n   mmp now = q.top();\n   q.pop();\n   ll x = now.second.first;\n   ll y = now.second.second;\n   ll dir = now.first.second;\n   ll cost = now.first.first;\n   if( dp[dir][x][y] != inf ) continue;\n   dp[dir][x][y] = cost;\n   if( t[x][y] != 4 ){\n    ll nd = (dir + t[x][y])%4;\n    ll nx = x + dx[nd];\n    ll ny = y + dy[nd];\n    if( 0<= nx && nx < h && 0<= ny && ny < w )\n     q.push( mmp( mp( cost , nd ) , mp( nx,ny ) ) );\n   }\n\n   for(ll i=0;i<4;i++){\n    ll nd = (dir + i)%4;\n    ll nx = x + dx[nd];\n    ll ny = y + dy[nd];\n    if( 0<= nx && nx < h && 0<= ny && ny < w )\n     q.push( mmp( mp( cost+c[i] , nd ) ,mp( nx,ny ) ) );\n   }\n\n  }\n  ll res = inf;\n  for(ll i=0;i<4;i++) res = min( res , dp[i][h-1][w-1] );\n  cout<<res<<endl;\n\n }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n,m;\nvvi in;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n  while(cin>>m>>n,n+m){\n    in=vvi(n,vi(m));\n    rep(i,n)rep(j,m)cin>>in[i][j];\n    vi co(4);\n    rep(i,4)cin>>co[i];\n    int dp[40][40][4];\n    rep(i,40)rep(j,40)rep(k,4)\n      dp[i][j][k]=inf;\n    dp[0][0][0]=0;\n    queue<pair<pii,pii> >q;\n    q.push(pair<pii,pii>(pii(0,0),pii(0,0)));\n    while(!q.empty()){\n      pii a=q.front().first;\n      pii b=q.front().second;\n      q.pop();\n      //      cout<<a.first<<\" \"<<a.second<<\" \"<<b.first<<\" \"<<b.second<<endl;\n      if(a.first==n-1&&a.second==m-1)continue;\n      if(dp[a.first][a.second][b.first]<b.second)continue;\n      rep(i,4){\n\tint nx=a.first+dx[(b.first+i)%4];\n\tint ny=a.second+dy[(b.first+i)%4];\n\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\tint cost=b.second;\n\tif(in[a.first][a.second]!=i)cost+=co[i];\n\tif(dp[nx][ny][(i+b.first)%4]>cost){\n\t  dp[nx][ny][(b.first+i)%4]=cost;\n\t  q.push(pair<pii,pii>(pii(nx,ny),pii((b.first+i)%4,cost)));\n\t}\n      }\n    }\n    int out=inf;\n    rep(i,4)out=min(out,dp[n-1][m-1][i]);\n    cout<<out<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define INF (1<<29)\n#define Cost first.first\n#define Dir first.second\n#define X second.first\n#define Y second.second\n\nusing namespace std;\n\ntypedef pair<int,int> p2;\ntypedef pair<p2,p2> p4;\n\nint w,h,g[4][31][31],s[31][31],c[4];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint dijkstra(){\n\n  priority_queue<p4,vector<p4>, greater<p4> >que;\n\n  for(int i=0;i<4;i++)\n    for(int j=0;j<31;j++)\n      for(int k=0;k<31;k++)g[i][j][k]=INF;\n  \n  g[0][0][0]=0;\n  \n  p4 st = p4(p2(0,0),p2(0,0));\n  que.push(st);\n\n  bool fg=false;\n\n  while(!que.empty()){\n    p4 now = que.top();\n    que.pop();\n\n    if(now.Y==h-1 && now.X==w-1)return now.Cost;    \n    if(g[now.Dir][now.Y][now.X]<=now.Cost && fg)continue;\n    fg=true;\n    g[now.Dir][now.Y][now.X]=now.Cost;\n    \n    for(int d=0;d<4;d++){\n      int index=(now.Dir+d)%4;\n      int nx=now.X+dx[index],ny=now.Y+dy[index];\n      if(0<=nx && nx<w && 0<=ny && ny<h){\n\tp4 next;\n\tnext.Cost=now.Cost+c[d]*(s[now.Y][now.X]!=d);\n\tnext.Dir=index;\n\tnext.X=nx,next.Y=ny;\n\tque.push(next);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  \n  while(cin >> w >> h,w|h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> s[i][j];\n      }\n    }\n    \n    for(int i=0;i<4;i++)cin >> c[i];\n\n    cout << dijkstra() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint mp[31][31];\nint memo[4][31][31];\nint c[4];\nint ans;\nint cnt;\nstring str = \">v<^\";\n\nvoid saiki(int x,int y,int dir,int cost) {\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,1,0,-1};\n\n  \n  if(x == w-1 && y == h-1 && ans > cost) ans = cost;\n  else if(memo[dir%4][y][x]>cost){\n    memo[dir%4][y][x] = cost;\n    cnt++;\n    \n    //    cout << str[dir%4];\n    //  cout <<\" \"<< x <<\" \" << y <<\" cost=\"<<cost<<endl\n    \n    for(int i=0;i<4;i++){\n      int ii = (i+dir%4)%4;\n      int nx = x + dx[ii];\n      int ny = y + dy[ii]; \n      if(nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n      if(i == mp[y][x]) {\n\tsaiki(nx,ny,(dir+i),cost);\n      }\n      else\n      saiki(nx,ny,(dir+i),cost+c[i]);\n      \n    }\n  }\n}\n\nint main() {\n  \n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> mp[i][j];\n\n\n    for(int i=0;i<4;i++)cin >> c[i];\n\n\n\n    for(int i=0;i<4;i++)\n      for(int j=0;j<31;j++)\n\tfor(int k=0;k<31;k++)\n\t  memo[i][j][k] = 1000000000;\n\n    ans = 1000000000;\n    cnt = 0;\n    saiki(0,0,0,0);\n\n    cout << ans<< endl;\n    //  cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1 << 28)\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint w,h;\n\nstruct data_t {\n\tint row;\n\tint col;\n\tint dir;\n\tint cost;\n\n\tbool operator<(const data_t& right) const {\n\t\treturn (cost > right.cost);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> w >> h, w) {\n\t\tvector< vector<int> > s(h+2,vector<int>(w+2));\n\t\tfor (int i = 0; i < h+2; ++i) {\n\t\t\tfor (int j = 0; j < w+2; ++j) {\n\t\t\t\tif (i == 0 || i == h+1 || j == 0 || j == w+1) {\n\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcin >> s[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> c(4);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tint cost[h+2][w+2][4];\n\t\tfor (int i = 0; i < h+2; ++i) {\n\t\t\tfor (int j = 0; j < w+2; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tcost[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<data_t> pq;\n\t\tpq.push((data_t){1,1,0,0});\n\t\tcost[1][1][0] = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tdata_t sn = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (sn.row == h && sn.col == w) {\n\t\t\t\tcout << sn.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int op = 0; op < 4; ++op) {\n\t\t\t\t\tint d = (sn.dir + op) % 4;\n\t\t\t\t\tif (sn.row+dy[d] > 0 && sn.row+dy[d] <= h && sn.col+dx[d] > 0 && sn.col+dx[d] <= w) {\n\t\t\t\t\t\tif (s[sn.row][sn.col] == op) {\n\t\t\t\t\t\t\tif (sn.cost < cost[sn.row+dy[d]][sn.col+dx[d]][d]) {\n\t\t\t\t\t\t\t\tcost[sn.row+dy[d]][sn.col+dx[d]][d] = sn.cost;\n\t\t\t\t\t\t\t\tpq.push((data_t){sn.row+dy[d],sn.col+dx[d],d,sn.cost});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (sn.cost+c[op] < cost[sn.row+dy[d]][sn.col+dx[d]][d]) {\n\t\t\t\t\t\t\t\tcost[sn.row+dy[d]][sn.col+dx[d]][d] = sn.cost + c[op];\n\t\t\t\t\t\t\t\tpq.push((data_t){sn.row+dy[d],sn.col+dx[d],d,sn.cost+c[op]});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<P, P>;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 35;\nconst int dx[4][4] = {{1, 0, -1, 0}, {0, -1, 0, 1}, {0, 1, 0, -1}, {-1, 0, 1, 0}};\nconst int dy[4][4] = {{0, 1, 0, -1}, {1, 0, -1, 0}, {-1, 0, 1, 0}, {0, -1, 0, 1}};\nint memo[4][4] = {{0, 1, 3, 2}, {1, 3, 2, 0}, {2, 0, 1, 3}, {3, 2, 0, 1}};\nint w, h;\nvector<int> c(4);\nint table[MAX_N][MAX_N];\nint solve()\n{\n    priority_queue<PP, vector<PP>, greater<PP>> que;\n    int used[h][w][4];\n    for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) for(int k = 0; k < 4; k++) used[i][j][k] = INF;\n    used[0][0][0] = 0;\n    que.push(PP(P(0, 0), P(0, 0)));\n    while(que.size())\n    {\n        PP p = que.top(); que.pop();\n        int cost = p.first.first;\n        int dir = p.first.second;\n        int y = p.second.first;\n        int x = p.second.second;\n        if(y == h - 1 and x == w - 1) return cost;\n        if(used[y][x][dir] < cost) continue;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = y + dy[dir][i];\n            int nx = x + dx[dir][i];\n            if(ny < 0 or nx < 0 or ny >= h or nx >= w) continue;\n            int d = memo[dir][i];\n            if(table[y][x] == i)\n            {\n                if(used[ny][nx][d] > used[y][x][dir])\n                {\n                    used[ny][nx][d] = used[y][x][dir];\n                    que.push(PP(P(used[ny][nx][d], d), P(ny, nx)));\n                }\n            }\n            else\n            {\n                if(used[ny][nx][d] > used[y][x][dir] + c[i])\n                {\n                    used[ny][nx][d] = used[y][x][dir] + c[i];\n                    que.push(PP(P(used[ny][nx][d], d), P(ny, nx)));\n                }\n            }\n        }\n    }\n    return -1;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w or h)\n    {\n        memset(table, 0, sizeof(table));\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++) cin >> table[i][j];\n        }\n        for(int i = 0; i < 4; i++) cin >> c[i];\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 100000;\n#define P pair < int , pair < int , pair < int , int > > > \n#define dis first\n#define dir second.first\n#define x second.second.first\n#define y second.second.second\nusing namespace std;\nint w,h;\nint mp[31][31];\nint c[4];\n//> v < ^\n//0 1 2 3\n\nint mk(int dr,int i) {\n  if(dr==0) return (0+i)%4;\n  else if(dr==3) return (1+i)%4;\n  else if(dr==2) return (2+i)%4; \n  else if(dr==1) return (3+i)%4;\n\n  return -1;\n}\n\nint dijkstra() {\n  priority_queue <P> Q;\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,1,0,-1};\n  bool visited[4][31][31] = {};\n  int d[4][31][31];\n  for(int i=0;i<4;i++)\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++) \n\td[i][j][k] = -INF;\n\n  P t;\n  t.dis = 0,   t.dir = 0,   t.x = 0,   t.y = 0;\n  d[0][0][0] = 0;\n  Q.push(t);\n\n  while(!Q.empty()){\n    t = Q.top() , Q.pop();\n    if(visited[t.dir][t.y][t.x] == 1) continue;\n    visited[t.dir][t.y][t.x] = 1;\n\n    // if(mp[t.y][t.x] == 4) continue;\n\n    for(int i=0;i<4;i++) {\n      int nx = t.x+dx[i],ny = t.y+dy[i];\n      if(nx<0 ||ny<0 ||w<=nx ||h<=ny) continue;\n      int ii = mk(t.dir,i);\n      int cost = c[ii];\n      if(mp[t.y][t.x] == ii) cost = 0;\n\n      if(d[i][ny][nx] < d[t.dir][t.y][t.x]-cost) {\n\td[i][ny][nx] = d[t.dir][t.y][t.x]-cost;\n\tP tt;\n\ttt.x = nx,  tt.y = ny,  tt.dir = i,  tt.dis = d[i][ny][nx];\n\tQ.push(tt);\n      }\n    }\n  }\n\n  int ans = -INF;\n  for(int i=0;i<4;i++) ans = max(ans,d[i][h-1][w-1]);\n  return ans;\n}\n\nint main() {\n\n  while(1) {\n  cin >> w >> h;\n  if(w == 0 && h == 0) break;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mp[i][j];\n    }\n  }\n   \n  for(int i=0;i<4;i++) cin >> c[i];\n\n  cout << -dijkstra() <<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Data{\npublic:\n\tint cost;\n\tint x;\n\tint y;\n\tint dir;\n\n\tData(int cost,int x,int y,int dir){\n\t\tthis->cost = cost;\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->dir = dir;\n\t}\n};\n\nbool operator<(const Data& d1,const Data& d2){\n\treturn d1.cost < d2.cost;\n}\n\nbool operator>(const Data& d1,const Data& d2){\n\treturn d1.cost > d2.cost;\n}\n\nint stage[31][31];\nint costTable[31][31][4];\nint W,H;\n\nvoid dfs(int x,int y,int dir,int* c){\n\tfor(int i=0;i<=3;i++){\n\t\tint cost = c[i];\n\t\tif(stage[y][x] == i) cost = 0;\n\n\t\tint prev = dir;\n\t\tint next = (prev+i)%4;\n\t\tint dx = x + tx[next];\n\t\tint dy = y + ty[next];\n\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\tif(costTable[dy][dx][next] > costTable[y][x][prev] + cost){\n\t\t\tcostTable[dy][dx][next] = costTable[y][x][prev] + cost;\n\t\t\tdfs(dx,dy,next,c);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d\",&W,&H)){\n\t\tif(W==H && H==0) break;\n\n\t\tmemset(costTable,0x3f,sizeof(costTable));\n\n\t\tfor(int y=0;y<W;y++){\n\t\t\tfor(int x=0;x<H;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tint c[4];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d\",c+i);\n\t\t}\n\t\tcostTable[0][0][1] = 0;\n\n\t\tpriority_queue<Data,vector<Data>,greater<Data> > que;\n\n\t\tque.push(Data(0,0,0,1));\n\n\t\twhile(!que.empty()){\n\t\t\tint sum = que.top().cost;\n\t\t\tint x = que.top().x;\n\t\t\tint y = que.top().y;\n\t\t\tint dir = que.top().dir;\n\n\t\t\tque.pop();\n\n\t\t\tfor(int i=0;i<=3;i++){\n\t\t\t\tint cost = c[i];\n\t\t\t\tif(stage[y][x] == i) cost = 0;\n\n\t\t\t\tint prev = dir;\n\t\t\t\tint next = (prev+i)%4;\n\t\t\t\tint dx = x + tx[next];\n\t\t\t\tint dy = y + ty[next];\n\t\t\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\t\t\tif(costTable[dy][dx][next] > sum + cost){\n\t\t\t\t\tcostTable[dy][dx][next] = sum + cost;\n\t\t\t\t\tque.push(Data(sum+cost,dx,dy,next));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t//dfs(0,0,1,c);\n\n\t\tint minv = numeric_limits<int>::max();\n\t\tfor(int i=0;i<=3;i++){\n\t\t\tminv = min(minv,costTable[H-1][W-1][i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",minv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 4;\n\nconst int dy[] = { 0, 1, 0, -1 };\nconst int dx[] = { 1, 0, -1, 0 };\n\nstruct State\n{\n\tint y, x, d;\n\tState( int y, int x, int d ) : y( y ), x( x ), d( d )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\treturn x < a.x;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int w, h; cin >> w >> h, w | h; )\n\t{\n\t\tVVI board( h, VI( w ) );\n\t\tFOR( line, board )\n\t\t{\n\t\t\tFOR( a, line )\n\t\t\t{\n\t\t\t\tcin >> a;\n\t\t\t}\n\t\t}\n\t\tVI cs( 4 );\n\t\tFOR( c, cs )\n\t\t{\n\t\t\tcin >> c;\n\t\t}\n\n\t\tvector<VVI> costs( h, VVI( w, VI( 4, INF ) ) );\n\t\tcosts[0][0][0] = 0;\n\t\t// →↓←↑\n\n\t\tpriority_queue< pair<int,State>, vector< pair<int,State> >, greater< pair<int,State> > > que;\n\t\tque.push( MP( 0, State( 0, 0, 0 ) ) );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tint c = que.top().fst;\n\t\t\tState cur = que.top().snd;\n\t\t\tque.pop();\n\n\t\t\tif ( costs[ cur.y ][ cur.x ][ cur.d ] < c )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( i, 0, 4 )\n\t\t\t{\n\t\t\t\tconst int d = ( cur.d + i ) % 4;\n\t\t\t\n\t\t\t\tconst int ny = cur.y + dy[d];\n\t\t\t\tconst int nx = cur.x + dx[d];\n\n\t\t\t\tif ( !( 0 <= ny && ny < h && 0 <= nx && nx < w ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst int nc = c + ( i == board[ cur.y ][ cur.x ] ? 0 : cs[i] );\n\t\t\t\tif ( nc < costs[ ny ][ nx ][d] )\n\t\t\t\t{\n\t\t\t\t\tcosts[ ny ][ nx ][d] = nc;\n\t\t\t\t\tque.push( MP( nc, State( ny, nx, d ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *min_element( ALL( costs.back().back() ) ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint INF = 1'000'000'000;\ntypedef tuple<int, int, int> T;\n\nint moved(int z, int m){\n    if (m == 0) return z;\n    if (m == 1) return (z + 1) % 4;\n    if (m == 2) return (z + 2) % 4;\n    if (m == 3) return (z + 3) % 4;\n    else return 10;\n}\n\nvoid next(int nz, int &nx, int &ny){\n    if (nz == 0) nx--;\n    else if (nz == 1) ny++;\n    else if (nz == 2) nx++;\n    else ny--;\n}\n\nbool check(int x, int y, int h, int w){\n    return (0 <= x && x < h && 0 <= y && y < w);\n}\n\nint main(){\n    while (1){\n        int w, h;\n        cin >> w >> h;\n        if (!w) break;\n        vector<vector<vector<int>>> distance(h, vector<vector<int>>(w, vector<int>(4, INF)));\n        vector<vector<int>> command(h, vector<int>(w));\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++) cin >> command[i][j];\n        }\n        vector<int> c(4);\n        for (int i = 0; i < 4; i++) cin >> c[i];\n        priority_queue<T, vector<T>, greater<T>> que;\n        int a = 0; int b = 0; int q = 1;\n        que.push(tie(a, b, q));\n        while (que.size()){\n            int d = get<0>(que.top());\n            int x = get<1>(que.top());\n            int y = x % 100; x /= 100;\n            int z = get<2>(que.top());\n            que.pop();\n            if (distance[x][y][z] <= d) continue;\n            distance[x][y][z] = d;\n            if (x == h - 1 && y == w - 1) break;\n            for (int i = 0; i < 4; i++){\n                if (i == command[x][y]){\n                    int nx = x;\n                    int ny = y;\n                    int nz;\n                    nz = moved(z, i);\n                    next(nz, nx, ny);\n                    if (check(nx, ny, h, w)){\n                        nx *= 100;\n                        nx += ny;\n                        que.push(tie(d, nx, nz));\n                    }\n                }\n                else {\n                    int nx = x;\n                    int ny = y;\n                    int nz;\n                    nz = moved(z, i);\n                    next(nz, nx, ny);\n                    if (check(nx, ny, h, w)){\n                        nx *= 100;\n                        nx += ny;\n                        int nd = d + c[i];\n                        que.push(tie(nd, nx, nz));\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i < 4; i++){\n            ans = min(ans, distance[h-1][w-1][i]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass State\n{\npublic:\n  int x, y, dir, cost;\n  State(int xx = 0, int yy = 0, int d = 0, int c = 0)\n    :x(xx), y(yy), dir(d), cost(c) {}\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint main()\n{\n  const int INF = 1 << 30;\n\n  int w, h;\n  while (scanf(\"%d %d\", &w, &h) != EOF) {\n    if (w == 0 && h == 0)\n      break;\n\n    vector<vector<int> > field(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j)\n\tscanf(\"%d\", &field[i][j]);\n    }\n\n    vector<int> c(4);\n    for (int i = 0; i < 4; ++i)\n      scanf(\"%d\", &c[i]);\n\n    State next;\n    priority_queue<State> que;\n    que.push(State(0, 0, 0, 0));\n    vector<vector<vector<int> > > cost(h, vector<vector<int> >(w, vector<int>(4, INF)));\n    vector<vector<vector<int> > > visited(h, vector<vector<int> >(w, vector<int>(4, 0)));\n    while (!que.empty()) {\n      State st = que.top();\n      que.pop();\n\n      if (st.x == w-1 && st.y == h-1) {\n\tprintf(\"%d\\n\", st.cost);\n\tbreak;\n      }\n\n      if (visited[st.y][st.x][st.dir] || cost[st.y][st.x][st.dir] < st.cost)\n\tcontinue;\n\n      visited[st.y][st.x][st.dir] = 1;\n      for (int i = 0; i < 4; ++i) {\n\tnext.dir = (st.dir+i) % 4;\n\tnext.cost = st.cost;\n\tif (field[st.y][st.x] != i)\n\t  next.cost += c[i];\n\tnext.x = st.x + dx[next.dir];\n\tnext.y = st.y + dy[next.dir];\n\n\tif (next.x < 0 || next.x >= w || next.y < 0 || next.y >= h)\n\t    continue;\n\n\tif (cost[next.y][next.x][next.dir] > next.cost) {\n\t  cost[next.y][next.x][next.dir] = next.cost;\n\t  que.push(next);\n\t}\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <memory>\n#include <cstdio>\n#include <memory.h>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pip;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint w, h;\nint area[31][31];\nint min_cost[31][31][4];\nint c[4];\n\nvoid bfs(){\n\tqueue<pip> qp;\n\tqp.push(make_pair(0, make_pair(1, 1)));\n\twhile(!qp.empty()){\n\t\tpip p = qp.front(); qp.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint d = p.first;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint y2 = y+dy[(d+i)%4];\n\t\t\tint x2 = x+dx[(d+i)%4];\n\t\t\tif(y2 < 1 || y2 > h || x2 < 1 || x2 > w) continue;\n\t\t\tint cost = 0;\n\t\t\tint d2 = (d+i)%4;\n\t\t\tif(area[y][x] != i) cost = c[i];\n\t\t\tif(min_cost[y2][x2][d2] < 0 || min_cost[y][x][d] + cost < min_cost[y2][x2][d2]){\n\t\t\t\tmin_cost[y2][x2][d2] = min_cost[y][x][d] + cost;\n\t\t\t\tqp.push(make_pair(d2, make_pair(y2, x2)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tmemset(min_cost, -1, sizeof(min_cost));\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tcin >> c[i];\n\t\t}\n\t\tmin_cost[1][1][0] = 0;\n\t\tbfs();\n\t\tint cost = 1 << 15;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(min_cost[h][w][i] >= 0) cost = min(cost, min_cost[h][w][i]);\n\t\t}\n\t\tif(cost == 1 << 15) cout << -1 << endl;\n\t\telse cout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nusing edge=pair<pair<int,int>,int>;\nusing P=pair<int,edge>;\n#define me(x,y,z) make_pair(make_pair((x),(y)),(z))\n#define x first.first\n#define y first.second\n#define z second\nconst int INF=1<<29;\nint d[32][32][4];\nint V,E;\n\nint w,h;\nint s[32][32];\nint c[3];\n//O(E*logV)\nvoid dijkstra(){\n  priority_queue<P,vector<P>,greater<P>> que;\n  REP(i,32)REP(j,32)REP(k,4)d[i][j][k]=INF;\n  REP(i,4){\n    d[1][1][i]=s[1][1]==i?0:c[i];\n    que.push(P(d[1][1][i],me(1,1,i)));\n  }\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    edge v=p.second;\n    if(v.z==0)v.x++;\n    if(v.z==1)v.y++;\n    if(v.z==2)v.x--;\n    if(v.z==3)v.y--;\n    if((v.x<1)||(v.x>w)||(v.y<1)||(v.y>h))\n      continue;\n    REP(i,4){//i=new meirei\n      int cost=i==s[v.y][v.x]?p.first:p.first+c[i];\n      if(d[v.y][v.x][(v.z+i)%4]<=cost)continue;\n      d[v.y][v.x][(v.z+i)%4]=cost;\n      que.push(P(d[v.y][v.x][(v.z+i)%4],me(v.x,v.y,(v.z+i)%4)));\n    }\n  }\n  cout<<min({d[h-1][w][1],d[h][w-1][0]})<<endl;\n}\n\nint main(){ _;\n  while(cin>>w>>h,(w|h)!=0){\n    REP(i,h)REP(j,w)cin>>s[i+1][j+1];\n    REP(i,4)cin>>c[i];\n    dijkstra();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;//h,w\ntypedef tuple<int,int,int,int> T;//cost,h,w,d;\n//d 0:north, 1:east, 2:south, 3:west\n\nint S[30][30];//h,w\nint memo[30][30][4];//h,w,d\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W|H){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>S[i][j];\n            }\n        }\n        int C[4];\n        for(int i=0;i<4;i++) cin>>C[i];\n        fill(memo[0][0],memo[30][0],1LL<<30);\n        priority_queue<T,vector<T>,greater<T>> que;\n        que.emplace(0,0,0,1);\n        memo[0][0][1]=1;\n        while(!que.empty()){\n            auto t = que.top(); que.pop();\n            int cost=get<0>(t), h=get<1>(t), w=get<2>(t), d=get<3>(t);\n            if(memo[h][w][d]<cost) continue;\n            if(h==H-1&&w==W-1){\n                cout<<cost<<endl;\n                break;\n            }\n            int c,d_;\n            int dh[4]={-1,0,1,0};\n            int dw[4]={0,1,0,-1};\n            //??´???\n            c = (S[h][w]==0?0:C[0]);\n            if(h+dh[d]>=0&&h+dh[d]<H&&w+dw[d]>=0&&w+dw[d]<W){\n                if(memo[h+dh[d]][w+dw[d]][d]>cost+c){\n                    memo[h+dh[d]][w+dw[d]][d]=cost+c;\n                    que.emplace(cost+c,h+dh[d],w+dw[d],d);\n                }\n            }\n            //??????\n            d_=(d+1)%4;\n            c = (S[h][w]==1?0:C[1]);\n            if(h+dh[d_]>=0&&h+dh[d_]<H&&w+dw[d_]>=0&&w+dw[d_]<W){\n                if(memo[h+dh[d_]][w+dw[d_]][d_]>cost+c){\n                    memo[h+dh[d_]][w+dw[d_]][d_]=cost+c;\n                    que.emplace(cost+c,h+dh[d_],w+dw[d_],d_);\n                }\n            }\n            //?????¢\n            d_=(d+2)%4;\n            c = (S[h][w]==2?0:C[2]);\n            if(h+dh[d_]>=0&&h+dh[d_]<H&&w+dw[d_]>=0&&w+dw[d_]<W){\n                if(memo[h+dh[d_]][w+dw[d_]][d_]>cost+c){\n                    memo[h+dh[d_]][w+dw[d_]][d_]=cost+c;\n                    que.emplace(cost+c,h+dh[d_],w+dw[d_],d_);\n                }\n            }\n            //??????\n            d_=(d+3)%4;\n            c = (S[h][w]==3?0:C[3]);\n            if(h+dh[d_]>=0&&h+dh[d_]<H&&w+dw[d_]>=0&&w+dw[d_]<W){\n                if(memo[h+dh[d_]][w+dw[d_]][d_]>cost+c){\n                    memo[h+dh[d_]][w+dw[d_]][d_]=cost+c;\n                    que.emplace(cost+c,h+dh[d_],w+dw[d_],d_);\n                }\n            }\n        }\n        while(!que.empty()) que.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dy[]={0,-1,0,1,1,-1,1,-1,0};\n\nint mem[40][40][4],m[40][40];\n\nint turn(int d,int ord){\n\tswitch(ord){\n\tcase 0: return d;\n\tcase 1: return (d+3)%4;\n\tcase 2: return d^2;\n\tcase 3: return (d+1)%4;\n\t}\n\tassert(0);\n}\n\nint main() {\n\tint w,h,cost[4];\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h)rep(j,w)rep(k,4)mem[i][j][k]=INF;\n\t\trep(i,h)rep(j,w)cin>>m[i][j];\n\t\trep(i,4)cin>>cost[i];\n\t\tpriority_queue<pair<int,pair<pint,int> >,vector<pair<int,pair<pint,int> > >,greater<pair<int,pair<pint,int> > > > que;\n\t\tque.push(MP(0,MP(MP(0,0),0)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,pair<pint,int> > now=que.top();\n\t\t\tque.pop();\n\t\t\tint c=now.first,x=now.second.first.X,y=now.second.first.Y,d=now.second.second;\n//debug<<x<<\" \"<<y<<\" \"<<c<< \" \"<<d<<endl;\n\t\t\tif(x<0||w<=x||y<0||h<=y)continue;\n\t\t\tif(mem[y][x][d]<=c)continue;\n\t\t\tmem[y][x][d]=c;\n\t\t\trep(ord,4){\n\t\t\t\tint nd=turn(d,ord);\n\t\t\t\tque.push(MP(c+(ord!=m[y][x]?cost[ord]:0),MP(MP(y+dy[nd],x+dx[nd]),nd)));\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\trep(i,4)chmin(res,mem[h-1][w-1][i]);\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint x,y;\n\tint angle;\n\tint cost;\n};\n\nvector<edge> G[30][30][4];\nint d[30][30][4];\n// cost,angle,y,x\ntypedef pair<pair<int,int>,pair<int,int> > P;\nint V;\nconst int INF = 10000000;\nint field[31][31];\nint w,h;\n\nvoid dijkstra(pair<int,int> s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\n\tfor(int i = 0; i < 30; i++)\n\t\tfor(int j = 0; j < 30; j++)\n\t\t\tfill(d[i][j],d[i][j]+4,INF);\n\n\td[s.first][s.second][1] = 0;\n\tque.push(P(make_pair(0,1),s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tpair<int,int> v = p.second;\n\t\tif(d[v.first][v.second][p.first.second] < p.first.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v.first][v.second][p.first.second].size(); i++){\n\t\t\tedge e = G[v.first][v.second][p.first.second][i];\n\t\t\tif(d[e.y][e.x][e.angle] > d[v.first][v.second][p.first.second] + e.cost){\n\t\t\t\td[e.y][e.x][e.angle] = d[v.first][v.second][p.first.second] + e.cost;\n\t\t\t\tque.push(P(make_pair(d[e.y][e.x][e.angle],e.angle),make_pair(e.y,e.x)));\n\t\t\t}\n\t\t}\n\t}\n\n\t// ツゴツーツδ仰づ個マツスツつェツ津「ツ止ツ鳴スツ療淞づ個湘ェツ債つゥツづつ、ツつゥツづ湘ェツ債づュツつッ\n\tint minCost = INF;\n\tfor(int i = 0; i < 4; i++){\n\t\tminCost = min(minCost,d[h-1][w-1][i]);\n\t}\n\tcout << minCost << endl;\n\n}\n\nint main(){\n\t// Gツづ個凝ヲツ静伉づィツづ債つサツづェツつシツづェツ督ッツつカツ暗環置ツづ個暗。ツつ、ツ古シツつォツづーツ表ツつキ\n\t// G 0-3,4-6,7-9,10-12...\n\t// 0ツ湘」,1ツ右,2ツ可コ,3ツ債カ\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tG[i][j][k].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tedge e;\n\t\t\t\te.x = j;\n\t\t\t\te.y = i;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(k == 0 && i >= 1){\n\t\t\t\t\t\tif(field[i][j] == 0)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te.y = i-1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\te.angle = 0;\n\t\t\t\t\t\tG[i][j][0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 1 && j < w - 1){\n\t\t\t\t\t\tif(field[i][j] == 0)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j + 1;\n\t\t\t\t\t\te.angle = 1;\n\t\t\t\t\t\tG[i][j][1].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 2 && i < h - 1){\n\t\t\t\t\t\tif(field[i][j] == 0)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 2;\n\t\t\t\t\t\te.y = i + 1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][2].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 3 && j >= 1){\n\t\t\t\t\t\tif(field[i][j] == 0)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 3;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j - 1;\n\t\t\t\t\t\tG[i][j][3].push_back(e);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif(k == 0 && j < w - 1){\n\t\t\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te.angle = 1;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j+1;\n\t\t\t\t\t\tG[i][j][0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 1 && i < h - 1){\n\t\t\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 2;\n\t\t\t\t\t\te.y = i+1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][1].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 2 && j >= 1){\n\t\t\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 3;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j-1;\n\t\t\t\t\t\tG[i][j][2].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 3 && i >= 1){\n\t\t\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 0;\n\t\t\t\t\t\te.y = i - 1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][3].push_back(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(k == 0 && i < h-1){\n\t\t\t\t\t\tif(field[i][j] == 2)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 2;\n\t\t\t\t\t\te.y = i+1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 1 && j >=1){\n\t\t\t\t\t\tif(field[i][j] == 2)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 3;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j - 1;\n\t\t\t\t\t\tG[i][j][1].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 2 && i >= 1){\n\t\t\t\t\t\tif(field[i][j] == 2)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 0;\n\t\t\t\t\t\te.y = i - 1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][2].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 3 && j < w - 1){\n\t\t\t\t\t\tif(field[i][j] == 2)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 1;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j + 1;\n\t\t\t\t\t\tG[i][j][3].push_back(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(k == 0 && j >= 1){\n\t\t\t\t\t\tif(field[i][j] == 3)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 3;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j-1;\n\t\t\t\t\t\tG[i][j][0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 1 && i >= 1){\n\t\t\t\t\t\tif(field[i][j] == 3)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 0;\n\t\t\t\t\t\te.y = i-1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][1].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 2 && j < w - 1){\n\t\t\t\t\t\tif(field[i][j] == 3)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 1;\n\t\t\t\t\t\te.y = i;\n\t\t\t\t\t\te.x = j+1;\n\t\t\t\t\t\tG[i][j][2].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if(k == 3 && i < h - 1){\n\t\t\t\t\t\tif(field[i][j] == 3)\n\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\te.cost = c[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\te.angle = 2;\n\t\t\t\t\t\te.y = i + 1;\n\t\t\t\t\t\te.x = j;\n\t\t\t\t\t\tG[i][j][3].push_back(e);\n\t\t\t\t\t}\n}\n}\n}\n//\ndijkstra(make_pair(0,0));\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 31;\nint w, h;\nint costs[4];\nint brd[MAX][MAX];\n\nenum {\n  DUP = 0,\n  DRIGHT,\n  DDOWN,\n  DLEFT\n};\n\nenum {\n  OSTRAIGHT = 0,\n  ORIGHT,\n  OTURN,\n  OLEFT,\n  OHALT\n};\n\n// up, right, down, left\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n// straight, right, turn, left\nconst int dd[4] = { 0, 3, 2, 1 };\n\nclass State {\npublic:\n  int x, y, d, c;\n\n  State(int x, int y, int d, int c):x(x), y(y), d(d), c(c) {}\n\n  bool operator>(const State &a) const {\n    return c > a.c;\n  }\n};\n\nint solve()\n{\n  int vis[MAX][MAX][4];\n\n  memset(vis, 0, sizeof(vis));\n  priority_queue<State, vector<State>, greater<State> > que;\n  que.push(State(0, 0, DRIGHT, 0));\n\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if (s.x == w-1 && s.y == h-1) {\n      return s.c;\n    }\n    vis[s.y][s.x][s.d] = true;\n    \n    for (int i = 0; i < 4; i++) {\n      int nx, ny, nd, nc;\n      nd = (s.d+dd[i])%4;\n      nx = s.x + dx[nd];\n      ny = s.y + dy[nd];\n      nc = s.c + (i==brd[s.y][s.x]?0:costs[i]);\n      if (!(0 <= nx && nx <= w)) continue;\n      if (!(0 <= ny && ny <= h)) continue;\n      if (!vis[ny][nx][nd])\n        que.push(State(nx, ny, nd, nc));\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while (cin >> w >> h, w|h) {\n    for (int i = 0; i < h; i++)\n      for (int j = 0; j < w; j++)\n        cin >> brd[i][j];\n\n    for (int i = 0; i < 4; i++)\n      cin >> costs[i];\n\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\n\tusing i4 = std::array<int, 4>;\n\tusing vi4 = std::vector<i4>;\n\tusing vvi4 = std::vector<vi4>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint W, H;\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (H == 0 && W == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tvvi board(H + 2, vi(W + 2, -1));\n\t\tfor (int i{1}; i <= H; i++)\n\t\t\tfor (int j{1}; j <= W; j++)\n\t\t\t\tscanf(\"%d\", &board[i][j]);\n\t\t\n\t\tint c[4];\n\t\tfor (int i{}; i < 4; i++) scanf(\"%d\", c + i);\n\n\t\tvvi4 distance(H + 2, vi4(W + 2));\n\t\tfor (int i{}; i < H + 2; i++)\n\t\t\tfor (int j{}; j < 4; j++)\n\t\t\t\tdistance[i][0][j] = distance[i][W + 1][j] = -1;\n\t\tfor (int i{}; i < W + 2; i++)\n\t\t\tfor (int j{}; j < 4; j++)\n\t\t\t\tdistance[0][i][j] = distance[H + 1][i][j] = -1;\n\t\tfor (int i{1}; i <= H; i++)\n\t\t\tfor (int j{1}; j <= W; j++)\n\t\t\t\tfor (int k{}; k < 4; k++)\n\t\t\t\t\tdistance[i][j][k] = 1 << 30;\n\n\t\tdistance[1][1][0] = 0;\n\t\tstd::priority_queue<i4, std::vector<i4>, std::greater<i4>> dij;\n\t\tdij.push({0, 1, 1, 0});\n\t\t\n\t\tint dir[4][2]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\ti4 now{dij.top()};\n\t\t\tdij.pop();\n\t\t\tif (now[1] == H && now[2] == W) break;\n\t\t\tif (now[0] > distance[now[1]][now[2]][now[3]]) continue;\n\t\t\tfor (int i{}; i < 4; i++)\n\t\t\t{\n\t\t\t\ti4 next(now);\n\t\t\t\tnext[3] = (next[3] + i) % 4;\n\t\t\t\tnext[1] += dir[next[3]][0];\n\t\t\t\tnext[2] += dir[next[3]][1];\n\t\t\t\tif (i != board[now[1]][now[2]]) next[0] += c[i];\n\t\t\t\tif (next[0] >= distance[next[1]][next[2]][next[3]]) continue;\n\t\t\t\tdistance[next[1]][next[2]][next[3]] = next[0];\n\t\t\t\tdij.push(next);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *std::min_element(distance[H][W].begin(), distance[H][W].end()));\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 35\n\nint w, h;\nint s[MAX][MAX];\nint dp[MAX][MAX];\nint cost[MAX][MAX][4];\nint c[4];\nstruct Point {\n\tint y, x, dir, cost;\n};\n//bool next_flag(Point& now) {\n//\tint i;\n//\tbool flag = false;\n//\trep(i, 4) {\n//\t\tint ny = now.y + dy[i];\n//\t\tint nx = now.x + dx[i];\n//\t\tif (ny < 0 || h <= ny) continue;\n//\t\tif (nx < 0 || w <= nx) continue;\n//\t\tif (cost[ny][nx] > cost[now.y][now.x]) flag = true;\n//\t}\n//\treturn flag;\n//}\nint ddir[] = { 0,3,2,1 };\nvoid bfs() {\n\tint i, j, k;\n\trep(i, h) rep(j, w) rep(k, 4) cost[i][j][k] = INT_MAX;\n\tqueue<Point> q;\n\tq.push({ 0,0,1,0 });\n\tcost[0][0][1] = 0;\n\twhile (q.size()) {\n\t\tPoint now = q.front(); q.pop();\n\t\trep(i, 4) {\n\t\t\tint ndir = (now.dir + ddir[i]) % 4;\n\t\t\tint ny = now.y + dy[ndir];\n\t\t\tint nx = now.x + dx[ndir];\n\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\tif (nx < 0 || w <= nx) continue;\n\n\t\t\tint ncost = now.cost;\n\t\t\tif (s[now.y][now.x] != i) ncost += c[i];\n\n\t\t\tif (ncost < cost[ny][nx][ndir]) {\n\t\t\t\tcost[ny][nx][ndir] = ncost;\n\t\t\t\tq.push({ ny,nx,ndir,ncost });\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(void)\n{\n\tint i, j, k;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) rep(j, w) reader(s[i][j]);\n\t\trep(i, 4) reader(c[i]);\n\t\tbfs();\n\t\tint ans = INT_MAX;\n\t\trep(i, 4) {\n\t\t\tif (cost[h - 1][w - 1][i] < ans) {\n\t\t\t\tans = cost[h - 1][w - 1][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100000\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool check[100][100][4] = { false };\nint cost[100][100][4];\n\nclass Node{\npublic:\n\tint x;\n\tint y;\n\tint way;//0 -> up, 1 -> right, 2 -> down, 3-> left\n\tint num;\n\n\tNode(){ x = 0; y = 0; way = 0; num = 0; }\n\tNode(int x, int y, int way, int num) : x(x), y(y), way(way), num(num){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.num < n2.num;\n}\n\nbool operator>(const Node &n1, const Node &n2){\n\treturn n1.num > n2.num;\n}\n\nint main(void){\n\n\tint w, h;\n\tint map[100][100];\n\tint c[4];\n\n\twhile (cin >> w >> h, w, h){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcost[j][i][3] = cost[j][i][2] = cost[j][i][1] = cost[j][i][0] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcheck[j][i][3] = check[j][i][2] = check[j][i][1] = check[j][i][0] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < h; j++){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t}\n\t\t}\n\n\t\tcin >> c[0] >> c[1] >> c[2] >> c[3];\n\n\t\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que;\n\n\t\tque.push(Node(0, 0, 1, 0));\n\n\t\twhile (!que.empty()){\n\t\t\tNode buff = que.top();\n\t\t\tque.pop();\n\n\t\t\tif (check[buff.y][buff.x][buff.way]) continue;\n\t\t\tcheck[buff.y][buff.x][buff.way] = true;\n\t\t\tcost[buff.y][buff.x][buff.way] = min(cost[buff.y][buff.x][buff.way] , buff.num);\n\n\t\t\tif ((buff.x == w - 1) && (buff.y == h - 1)){\n\t\t\t\tcout << buff.num << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (map[buff.y][buff.x] != 4){\n\t\t\t\tint next_way = (buff.way + map[buff.y][buff.x]) % 4;\n\t\t\t\tint next_x = buff.x + dx[next_way];\n\t\t\t\tint next_y = buff.y + dy[next_way];\n\t\t\t\tif (0 <= next_x && next_x < w && 0 <= next_y && next_y < h)\n\t\t\t\t\tque.push(Node(next_x, next_y, next_way, buff.num));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint next_x = buff.x + dx[i];\n\t\t\t\tint next_y = buff.y + dy[i];\n\t\t\t\tif (0 <= next_x && next_x < w && 0 <= next_y && next_y < h)\n\t\t\t\t\tque.push(Node(next_x, next_y, i, buff.num + c[(4 + i - buff.way) % 4]));\n\n\t\t\t}\n\n\n\t\t}\n\t\t/*\n\t\tfor (int j = 0; j < h; j++){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << min(cost[j][i][0], min(cost[j][i][1], min(cost[j][i][2], cost[j][i][3]))) << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w,h;\n\nint table[35][35];\nint c[4];\nint dist[35][35][4];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\ntypedef tuple<int,int,int,int> state;\nvoid dijkstra(){\n\trep(i,h)rep(j,w)rep(k,4)dist[i][j][k]=inf;\n\tdist[0][0][1]=0;\n\tstate s=make_tuple(0,0,0,1);\n\tpriority_queue<state> q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint x,y,d,costs;\n\t\ttie(costs,y,x,d)=cur;\n\t\tif(dist[y][x][d]<costs)\n\t\t\tcontinue;\n\t\trep(i,4){\n\t\t\tint nx=x,ny=y,nd=d,ncosts=costs;\n\t\t\tnd=(nd+i)%4;\n\t\t\tnx+=dx[nd],ny+=dy[nd];\n\t\t\tif(table[y][x]!=i)\n\t\t\t\tncosts+=c[i];\n\t\t\tif(0<=x&&x<w&&0<=y&&y<h){\n\t\t\t\tif(dist[ny][nx][nd]>ncosts){\n\t\t\t\t\tdist[ny][nx][nd]=ncosts;\n\t\t\t\t\tq.push(make_tuple(ncosts,ny,nx,nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\twhile(cin >> w >> h){\n\t\tif(w==0)\n\t\t\tbreak;\n\t\trep(i,h)rep(j,w) cin >> table[i][j];\n\t\trep(i,4) cin >> c[i];\n\t\tdijkstra();\n\t\tint ans=inf;\n\t\trep(i,4) ans=min(ans,dist[h-1][w-1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <numeric>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nint d[30][30][4];\nint ops[30][30];\nint c[4];\nint move_h[4] = {-1, 0, 1, 0};\nint move_w[4] = {0, 1, 0, -1};\n\npair <pair <int, int>, int> get_next(int cur_h, int cur_w, int cur_dir, int op){\n  if(op == 0){\n    int next_h = cur_h + move_h[cur_dir];\n    int next_w = cur_w + move_w[cur_dir];\n    return make_pair(make_pair(next_h, next_w), cur_dir);\n  }\n\n  int next_dir;\n  if(op == 1){\n    next_dir = (cur_dir + 1) % 4;\n  } else if(op == 2){\n    next_dir = (cur_dir + 2) % 4;\n  } else if(op == 3) {\n    next_dir = (cur_dir + 3) % 4;\n  } else {\n    next_dir = cur_dir;\n  }\n  int next_h = cur_h;\n  int next_w = cur_w;\n  if(op < 4){\n    next_h += move_h[next_dir];\n    next_w += move_w[next_dir];\n  }\n  return make_pair(make_pair(next_h, next_w), next_dir);\n}\n\nvoid dijikstra(int s_h, int s_w, int s_dir, int h, int w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        for(int k = 0; k < 4; k++){\n          d[i][j][k] = INT_MAX;\n        }\n      }\n    }\n\n    priority_queue < pair <int, pair<pair<int, int> , int> > , vector <pair <int, pair<pair<int, int> , int> > >, greater<pair <int, pair< pair<int, int> , int> > > > pq;\n    d[s_h][s_w][s_dir] = 0;\n    pq.push(make_pair(0, make_pair(make_pair(s_h, s_w), s_dir)));\n    while(!pq.empty()){\n        auto cur = pq.top();\n        auto cur_cost = cur.first;\n        auto cur_h = cur.second.first.first;\n        auto cur_w = cur.second.first.second;\n        auto cur_dir = cur.second.second;\n        pq.pop();\n        if(d[cur_h][cur_w][cur_dir] < cur_cost){\n            continue;\n        }\n\n        auto tmp = get_next(cur_h, cur_w, cur_dir, ops[cur_h][cur_w]);\n        int next_h = tmp.first.first;\n        int next_w = tmp.first.second;\n        int next_dir = tmp.second;\n        int next_d = d[cur_h][cur_w][cur_dir];\n        if(0 <= next_h && next_h < h && 0 <= next_w && next_w < w && d[next_h][next_w][next_dir] > next_d){\n          d[next_h][next_w][next_dir] = next_d;\n          pq.push(make_pair(next_d, make_pair(make_pair(next_h, next_w), next_dir)));\n        }\n        for(int i = 0; i < 4; i++){\n            auto tmp = get_next(cur_h, cur_w, cur_dir, i);\n            int next_h = tmp.first.first;\n            int next_w = tmp.first.second;\n            int next_dir = tmp.second;\n            int next_d = d[cur_h][cur_w][cur_dir] + c[i];\n            if(0 <= next_h && next_h < h && 0 <= next_w && next_w < w && d[next_h][next_w][next_dir] > next_d){\n              d[next_h][next_w][next_dir] = next_d;\n              pq.push(make_pair(next_d, make_pair(make_pair(next_h, next_w), next_dir)));\n            }\n        }\n    }\n}\n\n\nint main(){\n  while(true){\n    int w;\n    int h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){\n      break;\n    }\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> ops[i][j];\n      }\n    }\n\n    for(int i = 0; i < 4; i++){\n      cin >> c[i];\n    }\n\n    dijikstra(0, 0, 1, h, w);\n    cout << min(d[h - 1][w - 1][0], min(d[h - 1][w - 1][1], min(d[h - 1][w - 1][2], d[h - 1][w - 1][3]))) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint dx,dy,dd;\n\nbool op(int n){\n  dd = (dd+n)%4;\n  if(dd==0)dx++;\n  if(dd==1)dy++;\n  if(dd==2)dx--;\n  if(dd==3)dy--;\n  if(n==4)return false;\n  return true;\n}\n    \n\nint main(){\n  int w,h;\n  bool dp[540][30][30][4];\n  int grid[30][30];\n  int c[4];\n\n  while(1){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> grid[i][j];\n    }\n    for(int i=0;i<4;i++)cin >> c[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<4;k++){\n\t  for(int l=0;l<540;l++)dp[l][i][j][k] = false;\n\t}\n      }\n    }\n\n    int ans = -1;\n\n    while(1){\n      ans++;\n      queue<int> y,x,d;\n\n      if(!ans){\n\ty.push(0);\n\tx.push(0);\n\td.push(0);\n      }else{\n\tfor(int i=0;i<4;i++){\n\t  if(c[i] <= ans){\n\t    for(int j=0;j<h;j++){\n\t      for(int k=0;k<w;k++){\n\t\tfor(int l=0;l<4;l++){\n\t\t  if(dp[ans-c[i]][j][k][l]){\n\t\t    dp[ans][j][k][l] = true;\n\t\t    dy = j;\n\t\t    dx = k;\n\t\t    dd = l;\n\t\t    if(op(i)){\n\t\t      if( dx<=w-1 && dy<=h-1 && dx>=0 && dy>=0){\n\t\t\ty.push(dy);\n\t\t\tx.push(dx);\n\t\t\td.push(dd);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    \n      while(!x.empty()){\n\tdy = y.front();\n\ty.pop();\n\tdx = x.front();\n\tx.pop();\n\tdd = d.front();\n\td.pop();\n\tif(!dp[ans][dy][dx][dd]){\n\t  dp[ans][dy][dx][dd] = true;\n\t  if(op(grid[dy][dx])){\n\t    if( dx<=w-1 && dy<=h-1 && dx>=0 && dy>=0 ){\n\t      y.push(dy);\n\t      x.push(dx);\n\t      d.push(dd);\n\t    }\n\t  }\n\t}\n      }\n\n      bool f = false;\n      for(int i=0;i<4;i++)f |= dp[ans][h-1][w-1][i];\n      if(f)break;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main(void){\n\tint w, h, s[30][30], c[4], f[30][30][4], i, j, nx, ny, nc, nd, dir;\n\tconst int ctrl[4] = {0,1,2,-1}, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) scanf(\"%d\",&s[i][j]);\n\t\tfor(i = 0;i < 4;i++) scanf(\"%d\",&c[i]);\n\t\tmemset(f,-1,sizeof(f));\n\t\tque.push(PP(P(0,1),P(0,0)));\n\t\twhile(que.size()){\n\t\t\tnx = que.top().second.second, ny = que.top().second.first, nc = que.top().first.first,nd = que.top().first.second;\n\t\t\tif(ny == h - 1 && nx == w - 1) break;\n\t\t\tque.pop();\n\t\t\tf[ny][nx][nd] = 0;\n\t\t\tfor(j = 0;j < 4;j++){ // 行う操作\n\t\t\t\tdir = (nd + ctrl[j] + 4) % 4;\n\t\t\t\tif(ny + dy[dir] >= 0 && ny + dy[dir] < h && nx + dx[dir] >= 0 && nx + dx[dir] < w && f[ny + dy[dir]][nx + dx[dir]][dir])\n\t\t\t\t\tque.push(PP(P(s[ny][nx]==j?nc:nc+c[j],dir),P(ny + dy[dir],nx + dx[dir])));\n\t\t\t}\n\t\t}\n\t\twhile(que.size()) que.pop();\n\t\tprintf(\"%d\\n\",nc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int MAX_V = 4000;\nconst int INF = 9999999;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nint h, w;\n\nbool in(int i, int j){\n\treturn 0 <= i && i < h && 0 <= j && j < w;\n}\n\nint toV(int i, int j, int dir){\n\treturn 4 * (i * w + j) + dir;\n}\n\nvoid calc(){\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[0] = 0;\n\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t}\n\n\t\tif (v == -1)break;\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tvvi s = vvi(h, vi(w, 0));\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> s[i][j];\n\t\tint c[4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tcin >> c[i];\n\n\t\tV = 4 * w * h;\n\t\tfill_n(cost, MAX_V * MAX_V, INF);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\t\tcost[toV(i, j, dir)][toV(i, j, dir)] = 0;\n\t\t\t\t\tfor (int ndir = 0; ndir < 4; ndir++) {\n\t\t\t\t\t\tint ni = i + dy[ndir], nj = j + dx[ndir];\n\t\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\t\tif (s[i][j] != 4 && (dir + s[i][j]) % 4 == ndir)\n\t\t\t\t\t\t\tcost[toV(i, j, dir)][toV(ni, nj, ndir)] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcost[toV(i, j, dir)][toV(ni, nj, ndir)] = c[(ndir - dir + 4) % 4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalc();\n\n\t\tint ans = INF;\n\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\tans = min(ans, d[toV(h - 1, w - 1, dir)]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\n#define FOR(a,b,c) for ( int a = b; a < (int)c; a++ )\n#define REP(a,b) FOR(a,0,b)\n\nclass Pos {\npublic:\n    int r, c;\n    bool operator == ( const Pos& p ) const {\n        return r == p.r && c == p.c;\n    }\n    bool operator < ( const Pos& p ) const {\n        return r == p.r ? c < p.c : r < p.r;\n    }\n    Pos() { r=0, c=0; }\n    Pos( int r_, int c_ ): r(r_), c(c_) {}\n};\n\nclass Node {\npublic:\n    int cost;\n    int a;\n    Pos p;\n    Node() { cost = 0, a = 0, p = Pos(0,0); }\n    Node( int cost_, int a_, int r, int c ) { cost = cost_, a = a_, p = Pos( r, c ); }\n    bool operator == ( const Node& node ) const {\n        return cost == node.cost;\n    }\n    bool operator < ( const Node& node ) const {\n        return cost < node.cost;\n    }\n    bool operator > ( const Node& node ) const {\n        return cost > node.cost;\n    }\n};\n\ntypedef priority_queue <Node, vector<Node>, greater<Node> > QUEUE;\n\n// global var\nconst int size = 31;\nint w, h;\nint s[size][size];\nint c[4];\nint D[4][size][size]; // min cost\n\nbool isValid( Pos p ) \n{\n    return p.r >= 0 && p.r < h && p.c >= 0 && p.c < w;\n}\n\n// a%b\nint getRem( int a, int b )\n{\n    int rem = a % b;\n    if ( rem < 0 ) rem = b + rem;\n    return rem;\n}\n\nint main( void )\n{\n    while ( cin >> w >> h && w && h ) {\n        // init\n        REP(i,size) REP(j,size) s[i][j]=0;\n        REP(i,size) REP(j,size) REP(k,4) D[k][i][j]=1<<24;\n        REP(i,4) c[i] = 0;\n\n        // input\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                cin >> s[i][j];\n            }\n        }\n        for ( int i = 0; i < 4; i++ ) {\n            cin >> c[i];\n        }\n\n        // proc\n        int answer = 1<<24;\n        QUEUE Q;\n        Node start;\n        Pos goal( h-1, w-1 );\n        Q.push( start );\n        D[0][start.p.r][start.p.c] = 0;\n\n        while ( !Q.empty() ) {\n            Node node = Q.top();\n            Q.pop();\n\n            if ( node.p == goal ) {\n                answer = min( answer, D[node.a][node.p.r][node.p.c] );\n                break;\n            }\n            // proc\n            for ( int i = 0; i < 4; i++ ) {\n                int cost = node.cost;\n                int a = node.a;\n                Pos p = node.p;\n                Node next_node = node;\n\n                // cost\n                if ( i != s[p.r][p.c] ) {\n                    cost += c[i];\n                }\n\n                // operation\n                if ( i == 1 ) {\n                    a = getRem( a+1, 4 );\n                } else if ( i == 2 ) {\n                    a = getRem( a+2, 4 );\n                } else if ( i == 3 ) {\n                    a = getRem( a-1, 4 );\n                }\n\n                // move\n                if ( a == 0 ) {\n                    p.c++;\n                } else if ( a == 1 ) {\n                    p.r++;\n                } else if ( a == 2 ) {\n                    p.c--;\n                } else if ( a == 3 ) {\n                    p.r--;\n                }\n\n                if ( !isValid( p ) ) {\n                    continue;\n                }\n\n                if ( cost >= D[a][p.r][p.c] ) continue;\n                D[a][p.r][p.c] = cost;\n                next_node.cost = cost;\n                next_node.a = a;\n                next_node.p = p;\n                Q.push( next_node );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <limits.h>\n#include <bitset>\n\n#include <tuple>\n#include <unordered_map>\n\n#define mp       make_pair\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint w,h;\nint board[40][40];\nint cost[5];\nint dir;\nint cboard[40][40][4];\nint main(){\n\twhile(cin >> w >> h){\n\t\tdir = 0;\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 0; i < 40; i++){\n\t\t\tfor (int j = 0; j < 40; j++){\n\t\t\t\tboard[i][j] = -1;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tcboard[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcboard[1][1][0] = 0;\n\t\tif (w == 0 || h == 0)break;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tcin >> cost[i];\n\t\t}\n\t\tint cnt = 0;\n\t\twhile(cnt <= 50000){\n\t\tfor (int i = 1; i <= h; i++){//y\n\t\t\tfor (int j = 1; j <= w; j++){//x\n\t\t\t\tfor (int k = 0; k < 4; k++){//dir\n\t\t\t\t\tif (i == h && j == w){\n\t\t\t\t\t\tans = min(ans, cboard[i][j][k]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//no\n\t\t\t\t\t\tif (board[i][j] == 0){\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 1){//right\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 2){//back\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (board[i][j] == 3){//left\n\t\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][3]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//straight\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][0] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][1] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][2] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][3] + cost[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//right\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][0] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][1] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][2] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][3] + cost[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//back\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][0] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][1] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][2] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][3] + cost[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//left\n\t\t\t\t\t\tif (k == 0){\n\t\t\t\t\t\t\tcboard[i - 1][j][1] = min(cboard[i - 1][j][1], cboard[i][j][0] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 1){\n\t\t\t\t\t\t\tcboard[i][j - 1][2] = min(cboard[i][j - 1][2], cboard[i][j][1] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 2){\n\t\t\t\t\t\t\tcboard[i + 1][j][3] = min(cboard[i + 1][j][3], cboard[i][j][2] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k == 3){\n\t\t\t\t\t\t\tcboard[i][j + 1][0] = min(cboard[i][j + 1][0], cboard[i][j][3] + cost[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\t// for (int k = 0; k < 4; k++){\n\t\t\t// \tans = min(ans, cboard[h][w][k]);\n\t\t\t// }\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n#define MAX_X 30\n#define MAX_Y 30\n\nint cost[4];\nint w, h;\n\nint dx[] = {-1,0,1,0}; int dy[] = {0,-1,0,1};\n\nstruct P {\n    int cost, x, y, way;\n    bool operator >(const P& p) const {\n        if (cost != p.cost) return cost > p.cost;\n        return y < p.y;\n    }\n};\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        vector<vi> field(h, vi(w));\n        REP(iy, h) REP(ix, w) {\n            cin >> field[iy][ix];\n        }\n        REP(i, 4) {\n            cin >> cost[i];\n        }\n\n        vector<vector<vi>> costs(4, vector<vi>(h, vi(w, INF)));\n        costs[2][0][0] = 0; // right\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push((P){0, 0, 0, 2});\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.x == w - 1 && p.y == h - 1) {\n                cout << p.cost << endl;\n                break;\n            }\n\n            int way = (p.way + field[p.y][p.x]) % 4;\n            int sx = p.x + dx[way];\n            int sy = p.y + dy[way];\n\n            if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                if (field[p.y][p.x] != 4) {\n                    if (costs[way][sy][sx] > p.cost) {\n                        costs[way][sy][sx] = p.cost;\n                        que.push((P){p.cost, sx, sy, way});\n                    }\n                }\n            }\n\n            REP(d, 4) {\n                way = (p.way + d) % 4;\n                sx = p.x + dx[way];\n                sy = p.y + dy[way];\n\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    if (costs[way][sy][sx] > p.cost + cost[d]) {\n                        costs[way][sy][sx] = p.cost + cost[d];\n                        que.push((P){p.cost + cost[d], sx, sy, way});\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nint stage[31][31];\nint costTable[31][31][4];\nint W,H;\n\nvoid dfs(int x,int y,int dir,int* c){\n\tfor(int i=0;i<=3;i++){\n\t\tint cost = c[i];\n\t\tif(stage[y][x] == i) cost = 0;\n\n\t\tint prev = dir;\n\t\tint next = (prev+i)%4;\n\t\tint dx = x + tx[next];\n\t\tint dy = y + ty[next];\n\n\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\tif(costTable[dy][dx][next] > costTable[y][x][prev] + cost){\n\t\t\tcostTable[dy][dx][next] = costTable[y][x][prev] + cost;\n\t\t\tdfs(dx,dy,next,c);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d\",&W,&H)){\n\t\tif(W==H && H==0) break;\n\n\t\tmemset(costTable,0x3f,sizeof(costTable));\n\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tint c[4];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d\",c+i);\n\t\t}\n\n\t\tcostTable[0][0][1] = 0;\n\t\tdfs(0,0,1,c);\n\n\t\tint minv = numeric_limits<int>::max();\n\t\tfor(int i=0;i<=3;i++){\n\t\t\tminv = min(minv,costTable[H-1][W-1][i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",minv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Info {\n    int ci, cj, cost, dir;\n    Info(int i, int j, int c, int d) : ci(i), cj(j), cost(c), dir(d) {}\n};\nbool operator<(const Info &a, const Info &b) { return a.cost >= b.cost; }\n\nint grid[35][35];\nint dist[6][35][35];\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, 1, 0, -1};\n\nint main() {\n    int w, h;\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        int c[4] = {};\n        cin >> c[0] >> c[1] >> c[2] >> c[3];\n        priority_queue<Info> que;\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 35; j++) {\n                for (int k = 0; k < 35; k++) {\n                    dist[i][j][k] = 1e9;\n                }\n            }\n        }\n        dist[1][0][0] = 0;\n        que.push(Info(0, 0, 0, 1));\n        while (!que.empty()) {\n            int ci = que.top().ci;\n            int cj = que.top().cj;\n            int cost = que.top().cost;\n            int dir = que.top().dir;\n            que.pop();\n            if (dist[dir][ci][cj] < cost) continue;\n            for (int i = 0; i < 4; i++) {\n                int ndir = (dir + i) % 4;\n                int ni = ci + di[ndir];\n                int nj = cj + dj[ndir];\n                if (ni < 0 || ni >= h || nj >= w || nj < 0) continue;\n                if (i == grid[ci][cj]) {\n                    if (dist[ndir][ni][nj] > cost) {\n                        dist[ndir][ni][nj] = cost;\n                        que.push(Info(ni, nj, cost, ndir));\n                    }\n                } else {\n                    if (dist[ndir][ni][nj] > cost + c[i]) {\n                        dist[ndir][ni][nj] = cost + c[i];\n                        que.push(Info(ni, nj, cost + c[i], ndir));\n                    }\n                }\n            }\n        }\n        int ans = 1e9;\n        for (int i = 0; i < 4; i++) {\n            ans = min(ans, dist[i][h - 1][w - 1]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// 位置\ntypedef pair<int,int> P;\n// ( コスト , (向き,位置) )\ntypedef pair<int, pair<int,P> > state;\n\nconst int INF = 1e+8;\nconst int MAX_N = 35;\nint w, h;\nint m[MAX_N][MAX_N];\nint C[4];\n\n// 初期状態の向きは 0 (右向き)\n// 0:→, 1:↓, 2:←, 3:↑\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1}; \n\n// 向きdir, 命令c の時の次の向きを返す\nint command(int dir, int c){\n\tif( c == 0 ){ // 直進\n\t\treturn dir;\n\t}else if( c == 1 ){ // 右折\n\t\tint f[4] = {1,2,3,0};\n\t\treturn f[dir];\n\t}else if( c == 2 ){ // 反転\n\t\treturn (dir + 2) % 4;\n\t}else if( c == 3 ){ // 左折\n\t\tint f[4] = {3,0,1,2};\n\t\treturn f[dir];\n\t}\n\treturn -1;\n}\n\nint bfs(){\n\t// 答え\n\tint ans = INF;\n\t// 初期位置 : (向き,位置)\n\tpair<int,P> start( 0 , P(0,0) );\n\t// p =(向き,位置), memo[p] := 最小コスト\n\tmap< pair<int,P> , int > memo;\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tfor(int d=0 ; d < 4 ; d++ ){\n\t\t\t\tpair<int,P> p( d , P(x,y) );\n\t\t\t\tmemo[p] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 優先度付きキュー\n\t// state : ( コスト , (向き,位置) )\n\tpriority_queue< state , vector<state> , greater<state> > q;\n\tstate s( 0 , start );\n\tq.push( s );\n\tmemo[start] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tint now_cost = q.top().first;\n\t\tint now_d = q.top().second.first;\n\t\tint px = q.top().second.second.first;\n\t\tint py = q.top().second.second.second;\n\t\tpair<int,P> now( now_d , P(px,py) );\n\t\tq.pop();\n\t\t\n\t\tif( px == w-1 && py == h-1 ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int c=0 ; c < 4 ; c++ ){\n\t\t\t// コストを払わず移動するとき\n\t\t\tif( m[py][px] == c ){\n\t\t\t\tint d = command( now_d , c );\n\t\t\t\tint mx = px + dx[d];\n\t\t\t\tint my = py + dy[d];\n\t\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\tpair<int,P> next( d , P(mx,my) );\n\t\t\t\tif( now_cost + 0 < memo[next] ){\n\t\t\t\t\tmemo[next] = now_cost;\n\t\t\t\t\tq.push( state(now_cost,next) );\n\t\t\t\t}\n\t\t\t}else{ // コストを払うとき\n\t\t\t\tint d = command( now_d , c );\n\t\t\t\tint mx = px + dx[d];\n\t\t\t\tint my = py + dy[d];\n\t\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\tpair<int,P> next( d , P(mx,my) );\n\t\t\t\tif( now_cost + C[c] < memo[next] ){\n\t\t\t\t\tmemo[next] = now_cost + C[c];\n\t\t\t\t\tq.push( state(memo[next],next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\t\n\t\tfor(int y = 0 ; y < h ; y++ ){\n\t\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tcin >> C[i];\n\t\t}\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long int64;\ntypedef int int32;\ntypedef char int8;\ntypedef int32 int__;\n#define rep(i,j) for(int__ i=0;i<j;i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);i++)\n#define repeat_eq(i,j,k) for(int__ i=(j);i<=(k);i++)\n#define all(v) (v).begin(),(v).end()\n\nconst int INF=1<<30;//=10E10\n\nenum Direction{U,R,D,L,None};\n\nstruct state{\n  int x,y;\n  Direction dir;\n  int cost;\n  state(int x_,int y_,Direction dir_,int c):x(x_),y(y_),dir(dir_),cost(c){;}\n  bool operator>(const state &r)const{\n    return cost>r.cost;\n  }\n};\n\nint main()\n{\n  int w,h;\n  while(true){\n    //input\n    cin>>w>>h;\n    if(!w&&!h)break;\n    int s[30][30];\n    rep(i,h)rep(j,w)cin>>s[i][j];\n    int cost[4];rep(i,4)cin>>cost[i];\n\n    //solve\n    int dijk[30][30][4];//[y][x][dir]\n    rep(i,h)rep(j,w)rep(k,4)dijk[i][j][k]=INF;\n    priority_queue<state,vector<state>,greater<state> > que;\n    que.push(state(0,0,R,0));\n    \n    while(!que.empty()){\n      state now =que.top();que.pop();\n      if(dijk[now.y][now.x][now.dir]!=INF)continue;\n      dijk[now.y][now.x][now.dir]=now.cost;\n\n      Direction afturn;\n      if(s[now.y][now.x]==4)\n\tafturn=None;\n      else\n\tafturn=(Direction)((now.dir+s[now.y][now.x])%4);\n      \n      if(now.x  >0)que.push(state(now.x-1,now.y,L,now.cost+(afturn==L?0:cost[(L-now.dir+4)%4])));\n      if(now.y  >0)que.push(state(now.x,now.y-1,U,now.cost+(afturn==U?0:cost[(U-now.dir+4)%4])));\n      if(now.x+1<w)que.push(state(now.x+1,now.y,R,now.cost+(afturn==R?0:cost[(R-now.dir+4)%4])));\n      if(now.y+1<h)que.push(state(now.x,now.y+1,D,now.cost+(afturn==D?0:cost[(D-now.dir+4)%4])));\n    }\n    \n    int ans=INF;\n    rep(i,4)\n      ans=min(ans,dijk[h-1][w-1][i]);\n    cout<<ans<<endl;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair< p , p > P;\n#define d first.first\n#define x first.second\n#define y second.first\n#define dir second.second\n#define INF 1000000000\nP Make(int a,int b,int c,int e){\n  return P( p( a,b) , p( c, e) );   \n}\n\nint w,h;\nint mp[30][30],dmp[4][30][30],f[4][30][30];\nint let[4];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint dijkstra(){\n\n  priority_queue <P,vector <P>,greater<P> >Q;\n  Q.push(Make(0,0,0,0));\n  dmp[0][0][0]=0;\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    if(t.x==w-1&&t.y==h-1)return t.d;\n    f[t.dir][t.y][t.x]=1;\n    for(int i=0;i<4;i++){\n      int ndir=(t.dir+i)%4;\n      int nx=t.x+dx[ndir];\n      int ny=t.y+dy[ndir];\n      int nd=t.d;\n      if(mp[t.y][t.x]!=i)nd+=let[i];\n      if(nx<0||w<=nx||ny<0||h<=ny||f[ndir][ny][nx]==1||dmp[ndir][ny][nx]<=nd)continue;\n      dmp[ndir][ny][nx]=nd;\n      Q.push(Make(nd,nx,ny,ndir));\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(w==0)break;  \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>mp[i][j];\n\tfor(int k=0;k<4;k++)dmp[k][i][j]=INF,f[k][i][j]=0;;\n      }\n    for(int i=0;i<4;i++)cin>>let[i];\n    cout<<dijkstra()<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nenum{STRAIGHT,RIGHT,BACK,LEFT,HALT,N};\nint dy[4]={0,1,0,-1};\nint dx[4]={1,0,-1,0};\n\nclass Robot{\npublic:\n  int y,x,dir,cost;\n  Robot(){};\n  Robot(int i,int j,int d,int c):y(i),x(j),dir(d),cost(c){}\n  void move(int d,int c){\n    switch(d){\n      case STRAIGHT:\n        break;\n      case RIGHT:\n        dir=(dir+1)%4;\n\tbreak;\n      case BACK:\n        dir=(dir+2)%4;\n\tbreak;\n      case LEFT:\n        dir=(dir+3)%4;\n\tbreak;\n    }\n    y+=dy[dir];\n    x+=dx[dir];\n    cost+=c;\n  }\n  bool operator<(const Robot &r)const{return cost>r.cost;}// {}ÌOÉconstªKv\n};\n\nint w,h;\nvector< vector<int> >s;\nvector<int>c(N);\nvector< vector< vector<int> > >visited;\n\nbool valid(Robot r){return 0<=r.y && r.y<h && 0<=r.x && r.x<w;}\n\nint Dijkstra(){\n  priority_queue<Robot>q;\n  q.push(Robot(0,0,0,0));\n  while(!q.empty()){\n    Robot current=q.top();\n    q.pop();\n    if(current.y==h-1 && current.x==w-1)return current.cost;\n    visited[current.y][current.x][current.dir]=1;\n    Robot next=current;\n    next.move(s[current.y][current.x],0);\n    if(s[current.y][current.x]!=HALT && valid(next) && visited[next.y][next.x][next.dir]==0)q.push(next);\n    for(int i=0;i<4;i++){\n      Robot next=current;\n      next.move(i,c[i]);\n      if(valid(next) && visited[next.y][next.x][next.dir]==0)q.push(next);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin>>w>>h,w|h){\n    // }XÌîñðüÍ\n    s.resize(h);\n    for(int i=0;i<h;i++){\n      s[i].resize(w);\n      for(int j=0;j<w;j++){\n\tcin>>s[i][j];\n      }\n    }\n    // â~ÈOÌRXgðüÍ\n    for(int i=0;i<N-1;i++){\n      cin>>c[i];\n    }\n    // ú»\n    visited.resize(h);\n    for(int i=0;i<h;i++){\n      visited[i].resize(w);\n      for(int j=0;j<w;j++){\n\tvisited[i][j].resize(4);\n\tfor(int k=0;k<4;k++){\n\t  visited[i][j][k]=0;\n\t}\n      }\n    }\n    // Tõ\n    cout<<Dijkstra()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> V;\ntypedef vector<vector<int> > VV;\ntypedef pair<int,pair<P,int> > PP;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\nconst int dx[] = {0, 1, 0,-1};\nconst int dy[] = {1, 0,-1, 0};\n\nint main()\n{\n    int n, m;\n    while (cin >> n >> m, m || n) {\n        VV d(m, V(n));\n        rep(i,m) rep(j,n) {\n            cin >> d[i][j];\n        }\n\n        V c(4);\n        rep (i, 4) {\n            cin >> c[i];\n        }\n\n        vector<vector<vector<int> > > v(m, VV(n, V(4, INF)));\n        VV dp (m, V(n, INF));\n        dp[0][0] = v[0][0][0] = 0;\n        priority_queue<PP, vector<PP>, greater<PP> >  que;\n        que.push(PP(0, pair<P,int>(P(0,0), 0)));\n\n        while (!que.empty()) {\n            PP pp = que.top(); que.pop();\n            int x = pp.second.first.first;\n            int y = pp.second.first.second;\n            int d_ = pp.second.second;\n\n            if (v[x][y][d_] < pp.first) continue;\n\n            rep (i,4) {\n                int dir = (i + d_) % 4;\n                int cost = (i == d[x][y] ? 0 : c[i]) + v[x][y][d_];\n                int nx = dx[dir] + x, ny = dy[dir] + y;\n                if (0 <= nx && nx < m && 0 <= ny && ny < n && v[nx][ny][dir] > cost) {\n                    v[nx][ny][dir] = cost;\n                    dp[nx][ny] = min(dp[nx][ny], cost);\n                    que.push(PP(cost, pair<P,int>(P(nx,ny), dir)));\n                }\n            }\n        }\n\n        cout << dp[m-1][n-1] << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define INF 1e9\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nstruct Node {\n\tint x, y, dir, cost;\n};\n\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W || H) {\n\t\tint op[30][30];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> op[y][x];\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tfor (int i = 0; i < 4; ++i) cin >> c[i];\n\n\t\tint ans = INF;\n\t\tbool gone[30][30][4] = {0};\n\t\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){0, 0, 1, 0} );\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.top(); Q.pop();\n\t\t\tint x = node.x, y = node.y, dir = node.dir, cost = node.cost;\n\t\t\tif (x < 0 || x >= W || y < 0 || y >= H) continue;\n\n\t\t\tif (gone[y][x][dir]) continue;\n\t\t\tgone[y][x][dir] = true;\n\n\t\t\tif (x == W-1 && y == H-1) {\n\t\t\t\tans = min(ans, cost);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint d = (dir + i) % 4;\n\t\t\t\tQ.push( (Node){x+dx[d], y+dy[d], d, cost+c[i]} );\n\t\t\t}\n\t\t\tif (op[y][x] != 4) {\n\t\t\t\tint d = (dir + op[y][x]) % 4;\n\t\t\t\tQ.push( (Node){x+dx[d], y+dy[d], d, cost} );\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Pos {\npublic:\n    int r, c;\n    Pos() {}\n    Pos( int r_, int c_ )\n    {\n        r = r_, c = c_;\n    }\n    bool operator == ( const Pos& right ) const\n    {\n        return r == right.r && c == right.c;\n    }\n    bool operator < ( const Pos& right ) const\n    {\n        return r == right.r ? c < right.c : r < right.r;\n    }\n};\n\nclass Node {\npublic:\n    int c, a;\n    Pos p;\n    bool operator < ( const Node& right ) const\n    {\n        return c < right.c;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return c > right.c;\n    }\n    Node(){}\n    Node( int c_, int a_, Pos p_ ) { c = c_, a = a_, p = p_; }\n};\n\n// globals\nconst int inf = 1<<24;\nconst int size = 31;\nint w, h;\nint s[size][size];\nint c[4];\n\ntypedef priority_queue <Node, vector <Node>, greater <Node> > QUEUE;\nint mc[4][size][size];\n\n// a % b\nint getrem( int a, int b )\n{\n    return a < 0 ? (b-(-a%b)) : a % b;\n}\n\nbool isValid( Pos p )\n{\n    return p.r >= 0 && p.r < h && p.c >= 0 && p.c < w;\n}\n\nint solve()\n{\n    QUEUE Q;\n    Node start( 0, 0, Pos(0,0) );\n    Q.push( start );\n    Pos goal( h-1, w-1 );\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        int cost = node.c;\n        int a = node.a;\n        Pos p = node.p;\n\n        if ( p == goal ) {\n            return cost;\n        }\n\n        for ( int i = 0; i < 4; i++ ) {\n            int next_cost = cost;\n            if ( i != s[p.r][p.c] ) {\n                next_cost += c[i];\n            }\n\n            int next_a = a;\n            if ( i == 1 ) {\n                next_a = getrem( a+1, 4 );\n            } else if ( i == 2 ) {\n                next_a = getrem( a+2, 4 );\n            } else if ( i == 3 ) {\n                next_a = getrem( a-1, 4 );\n            }\n\n            Pos next_p = p;\n            if ( next_a == 0 ) {\n                next_p.c++;\n            } else if ( next_a == 1 ) {\n                next_p.r++;\n            } else if ( next_a == 2 ) {\n                next_p.c--;\n            } else if ( next_a == 3 ) {\n                next_p.r--;\n            }\n            if ( !isValid( next_p ) ) continue;\n\n            if ( next_cost >= mc[next_a][next_p.r][next_p.c] ) continue;\n            mc[next_a][next_p.r][next_p.c] = next_cost;\n            Node next_node( next_cost, next_a, next_p );\n            Q.push( next_node );\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    while ( cin >> w >> h && w && h ) {\n        // init\n        for ( int k = 0; k < 4; k++ ) {\n            for( int i = 0; i < size; i++ ) {\n                for ( int j = 0; j < size; j++ ) {\n                    mc[k][i][j] = inf;\n                }\n            }\n        }\n\n        // input\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                cin >> s[i][j];\n            }\n        }\n        for ( int i = 0; i < 4; i++ ) {\n            cin >> c[i];\n        }\n\n        // proc\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\ntypedef pair<mp,mp> mmp;\nint dx[] = {0,1,0,-1};//h\nint dy[] = {1,0,-1,0};//w\n\nint main(){\n\twhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tpriority_queue<mmp,vector<mmp> ,greater<mmp> > q;\n\tvector<vector<vector<int> > > dp(h+2,vector<vector<int> >(w+2,vector<int>(4,inf ) ) );\n\tvector<vector<int> > s(h+2,vector<int>(w+2,0) );\n\tint c[4];\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)cin>>c[i];\n\n\t//dp[1][1] = 0;\n\tq.push(mmp(mp(0,0),mp(1,1) ));\n\tint res = inf;\n\twhile(!q.empty()){\n\t\tmmp now = q.top();\n\t\tq.pop();\n\t\tint cost = now.first.first;\n\t\tint dir = now.first.second;\n\t\tint x = now.second.first;\n\t\tint y = now.second.second;\n\t\tif(cost >= dp[x][y][dir])continue;\n\t\tdp[x][y][dir] = cost;\n\t\tif(s[x][y]!=4){\n\t\t\tint nd = (dir+s[x][y])%4;\n\t\t\tint nx = x+dx[nd];\n\t\t\tint ny = y+dy[nd];\n\t\t\tif(1<=nx&&nx<=h&&1<=ny&&ny<=w){\n\t\t\t\tq.push(mmp(mp(cost,nd),mp(nx,ny) ) );\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nc = cost+c[i];\n\t\t\tint nd = (dir+i)%4;\n\t\t\tint nx = x+dx[nd];\n\t\t\tint ny = y+dy[nd];\n\t\t\tif(1<=nx&&nx<=h&&1<=ny&&ny<=w){\n\t\t\t\tq.push(mmp(mp(nc,nd),mp(nx,ny) ) );\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tres = min(res,dp[h][w][i]);\n\t}\n\tcout<<res<<endl;\n\t/*\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcout<<dp[i][j]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\nusing ll = long long;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint dp[33][33][4];\nint W, H;\n\nvoid init() {\n    REP(i, H) {\n        REP(j, W) {\n            REP(k, 4) { dp[i][j][k] = 1e9; }\n        }\n    }\n    dp[0][0][0] = 0;\n}\n\nint A[55][55];\n\nusing arr4 = array<int, 4>;\nint C[5];\nbool solve() {\n    cin >> W >> H;\n    if (W == 0) return false;\n    init();\n    REP(i, H) {\n        REP(j, W) { cin >> A[i][j]; }\n    }\n    REP(i, 4) cin >> C[i];\n    priority_queue<arr4, vector<arr4>, greater<arr4>> que;\n    que.push({0, 0, 0, 0});\n    while (!que.empty()) {\n        arr4 ar = que.top();\n        que.pop();\n        int c = ar[0], x = ar[1], y = ar[2], dir = ar[3];\n        if (c > dp[x][y][dir]) continue;\n        if (A[x][y] != 4) {\n            int nx = x + dx[(dir + A[x][y]) % 4];\n            int ny = y + dy[(dir + A[x][y]) % 4];\n            if (nx < H && nx >= 0 && ny < W && ny >= 0) {\n                int nd = (dir + A[x][y]) % 4;\n                if (dp[nx][ny][nd] > dp[x][y][dir]) {\n                    dp[nx][ny][nd] = dp[x][y][dir];\n                    que.push({dp[nx][ny][nd], nx, ny, nd});\n                }\n            }\n        }\n        REP(i, 4) {\n            int nd = (dir + i) % 4;\n            int nx = x + dx[nd];\n            int ny = y + dy[nd];\n            if (nx < H && nx >= 0 && ny < W && ny >= 0) {\n                if (dp[nx][ny][nd] > dp[x][y][dir] + C[i]) {\n                    dp[nx][ny][nd] = dp[x][y][dir] + C[i];\n                    que.push({dp[nx][ny][nd], nx, ny, nd});\n                }\n            }\n        }\n        //\n    }\n    int ans = 1e9;\n    REP(i, 4) { ans = min(ans, dp[H - 1][W - 1][i]); }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\n// RDLU\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nstruct Elem {\n    int row, col, dir, cost;\n    Elem(int r, int c, int d, int co) : row(r), col(c), dir(d), cost(co) {}\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    };\n};\n\nint dist[35][35][4];\nint solve_testcase() {\n    int W, H; scanf(\"%d%d\", &W, &H);\n    if(H == 0 and W == 0) return 1;\n\n    vector< vector<int> > board(H, vector<int>(W));\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            scanf(\"%d\", &board[i][j]);\n        }\n    }\n\n    vector<int> C(4);\n    for(int i=0; i<4; i++) scanf(\"%d\", &C[i]);\n\n    fill(dist[0][0], dist[H][0], INF);\n    priority_queue<Elem> que;\n    que.emplace(0, 0, 0, 0);\n    dist[0][0][0] = 0;\n    while(que.size()) {\n        Elem e = que.top(); que.pop();\n        int r = e.row, c = e.col, d = e.dir, cost = e.cost;\n        for(int i=0; i<4; i++) {\n            int nr = r + dx[i], nc = c + dy[i], nd = i;\n            if(nr < 0 or nr >= H or nc < 0 or nc >= W) continue;\n\n            int ncost = cost;\n            int dd = (nd - d + 4) % 4;\n            if(board[r][c] != dd) ncost += C[dd];\n            if(dist[nr][nc][nd] > ncost) {\n                dist[nr][nc][nd] = ncost;\n                que.emplace(nr, nc, nd, ncost);\n            }\n        }\n    }\n\n    int ans = INF;\n    for(int i=0; i<4; i++) chmin(ans, dist[H-1][W-1][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1<<27\n\nint cost[4][30][30];\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nint G[30][30],C[4],W,H;\n\nclass P{\npublic:\n  P(){}\n  int x,y,d,cost;\n\n  P(int x,int y,int d,int cost):x(x),y(y),d(d),cost(cost){}\n\n  bool operator<(const P &p)const{\n    return cost > p.cost;\n  } \n};\n\nint solve ()\n{\n  priority_queue<P>pq;\n  pq.push(P(0,0,0,0));\n  fill(cost[0][0],cost[4][0],INF);\n  cost[0][0][0] = 0;\n  while(!pq.empty()){\n    P p = pq.top();pq.pop();\n    if(p.cost > cost[p.d][p.y][p.x])continue;\n    if(p.x == W-1 && p.y == H-1 )return p.cost;\n\n    for(int i = 0 ; i < 4 ; i++ ){\n\n      P t = p;\n      t.cost += (G[p.y][p.x] == i ? 0 : C[i]);\n      t.d = (p.d + i)%4;\n      t.x += dx[t.d],t.y += dy[t.d];\n      if(!(0<= t.x && t.x < W && 0<=t.y && t.y < H))continue;\n      if(t.cost < cost[t.d][t.y][t.x]){\n\tpq.push(t);\n\tcost[t.d][t.y][t.x] = t.cost;\n      }\n    }\n  }\n}\n\nvoid input()\n{\n  while(cin >> W >> H,W+H )\n{\n  for(int i = 0 ; i < H ; i++ )\n    for(int j = 0 ; j < W ; j++ )cin >> G[i][j];\n\n  for(int i = 0 ; i < 4 ; i++ )cin >> C[i];\n\n  cout << solve() << endl;\n }\n}\n\n\nint main()\n{\n  input();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state\n{\n\tint x, y, dir, cost;\n};\n\nstruct comp : public binary_function<state &, state &, bool>\n{\n\tbool operator() (const state &x, const state &y) const { return x.cost > y.cost; }\n};\n\n// dir = 0 を東向きとして dir が増加すると反時計回りに回転\nint D[4] = { 1, 0, -1, 0 };\n\nint W, H;\nbool det[31][31][4];\nint com[31][31];\nint C[4];\n\nbool ok(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\nint left(int dir) { return (dir + 1) % 4; }\nint right(int dir) { return (dir + 3) % 4; }\n\nint main()\n{\n\twhile(cin>>W>>H, W|H)\n\t{\n\t\tfor (int y = 0; y < H; y++)\n\t\t{\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t{\n\t\t\t\tcin >> com[y][x];\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tdet[y][x][i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++) cin >> C[i];\n\n\t\tstate init = { 0, 0, 0, 0 };\n\n\t\tpriority_queue<state, vector<state>, comp> Q;\n\t\tQ.push(init);\n\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tstate s = Q.top();\n\t\t\tQ.pop();\n\t\t\tif (det[s.y][s.x][s.dir]) continue;\n\t\t\tdet[s.y][s.x][s.dir] = true;\n\n\t\t\tif (s.x == W - 1 && s.y == H - 1)\n\t\t\t{\n\t\t\t\tcout << s.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint di[4] = { s.dir, s.dir + 3, s.dir + 2, s.dir + 1 };\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint dir = di[i] % 4, x = s.x + D[dir], y = s.y + D[(dir + 1) % 4];\n\t\t\t\tif (!ok(x, y)) continue;\n\t\t\t\tstate s2 = { x, y, dir, s.cost + (i == com[s.y][s.x] ? 0 : C[i]) };\n\t\t\t\tif (!det[s2.y][s2.x][s2.dir]) Q.push(s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nclass P{\npublic:\n  int i,j,dir, cost;\n  P(){};\n  P( int I,int J, int d, int c ){\n    i=I; j=J; dir=d; cost=c;\n  }\n  bool operator<(const P &p) const{\n    return cost > p.cost; // queue 用に greater で定義\n  }\n};\n\n\nint di[4] = { 0,1,0,-1 };\nint dj[4] = { 1,0,-1,0 };\n\nint main(){\n  int o[30][30]; // マスに割り当てられた命令\n  int c[4];      // 命令を与えた時のコスト\n  int cost[30][30][4];\n  int w,h;\n  priority_queue<P> qu;\n  P p;\n\n  while( cin>>w>>h && (w||h) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> o[i][j];\n\tfor( int k=0;k<4;k++ )\n\t  cost[i][j][k]=INT_MAX;\n      }\n    for( int i=0;i<4;i++ )\n      cin >> c[i];\n\n    while( !qu.empty() ) qu.pop();\n    qu.push( P(0,0,0,0) );\n\n    int ans=0;\n    while( !qu.empty() ){\n      p=qu.top(); qu.pop(); // cost が最小のものを取り出す\n\n      if( (p.i==h-1) && (p.j==w-1) ){\n\t//\tcout << \"***\"<<endl;\n\tans=p.cost;\n\tbreak;\n      }\n      if( (p.i<0) || (p.i>=h) ) continue;\n      if( (p.j<0) || (p.j>=w) ) continue;\n\n      \n      if( cost[p.i][p.j][p.dir] <= p.cost ) continue;\n      cost[p.i][p.j][p.dir] = p.cost;\n\n      /*\n      cout << p.i << \",\" << p.j << \" \"<<p.cost << endl;\n      cout << \"size=\"<<qu.size() << endl;\n      if( qu.size()>10 )break;\n      */\n\n      for( int i=0;i<4;i++ ){ // 直進・右・反転・左　への移動\n\tint nextD = (i+p.dir)%4;;\n\tint ni=p.i+di[nextD], nj=p.j+dj[nextD];\n\tif( i==o[p.i][p.j] )\t  qu.push( P(ni,nj,nextD,p.cost) );\n\telse                 \t  qu.push( P(ni,nj,nextD,p.cost+c[i]) );\n      }\n      \n    }\n    cout << ans << endl;\n\n    /*\n    for( int k=0;k<4;k++ ){\n      cout << \"k=\"<<k<<endl;\n      for( int i=0;i<h;i++ ){\n\tfor( int j=0;j<w;j++ )\n\t  cout << cost[i][j][k] << \"\\t\";\n\tcout << endl;\n      }\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<int> > ins(h, vector<int>(w));\n\t\tvector<vector<vector<int> > > d(h, vector<vector<int> >(w, vector<int>(4, INF)));\n\t\tvector<vector<vector<bool> > > moumita(h, vector<vector<bool> >(w, vector<bool>(4, false)));\n\t\tvector<int> c(4);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>ins[i][j];\n\t\t}\n\t\tREP(i, 4) cin>>c[i];\n\t\tpriority_queue<pair<ll, pair<P, ll> > > q;\n\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(0, 0), 1)));\n\t\tpair<P, ll> np = pair<P, ll>(P(0, 0), 1);\n\t\tREP(i, 4000) {\n\t\t\td[np.first.first][np.first.second][np.second] = 0;\n\t\t\tq.push(pair<ll, pair<P, ll> >(0, pair<P, ll>(P(np.first.first, np.first.second), np.second)));\n\t\t\tif(ins[np.first.first][np.first.second] == 4) break;\n\t\t\tll nh = np.first.first;\n\t\t\tll nw = np.first.second;\n\t\t\tll nr = np.second;\n\t\t\tswitch(ins[np.first.first][np.first.second]) {\n\t\t\t\tcase 0: {\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\tnr = (nr + 1) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tnr = (nr + 2) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tnr = (nr + 3) % 4;\n\t\t\t\t\tif(np.second == 0) {\n\t\t\t\t\t\t--nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 1) {\n\t\t\t\t\t\t--nh;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 2) {\n\t\t\t\t\t\t++nw;\n\t\t\t\t\t}\n\t\t\t\t\tif(np.second == 3) {\n\t\t\t\t\t\t++nh;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\tnp.first.first = nh;\n\t\t\t\tnp.first.second = nw;\n\t\t\t\tnp.second = nr;\n\t\t\t} else break;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\tq.pop();\n\t\t\t//if(moumita[p.second.first.first][p.second.first.second][p.second.second]) continue;\n\t\t\t//else moumita[p.second.first.first][p.second.first.second][p.second.second] = true;\n\t\t\tREP(i, 4) {\n\t\t\t\tll nh = p.second.first.first + dx[i];\n\t\t\t\tll nw = p.second.first.second + dy[i];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w) {\n\t\t\t\t\tll cost = INF;\n\t\t\t\t\tif(p.second.second == 0) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 1) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 2) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.second.second == 3) {\n\t\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 3) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[3];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 2) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[2];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 1) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\t\tif(ins[p.second.first.first][p.second.first.second] == 0) cost = 0;\n\t\t\t\t\t\t\t\telse cost = c[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tif(d[nh][nw][2] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][2] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][2], pair<P, ll>(P(nh, nw), 2)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][1], pair<P, ll>(P(nh, nw), 1)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][0], pair<P, ll>(P(nh, nw), 0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 3: {\n\t\t\t\t\t\t\tif(d[nh][nw][3] > d[p.second.first.first][p.second.first.second][p.second.second] + cost) {\n\t\t\t\t\t\t\t\td[nh][nw][3] = d[p.second.first.first][p.second.first.second][p.second.second] + cost;\n\t\t\t\t\t\t\t\tq.push(pair<ll, pair<P, ll> >(d[nh][nw][3], pair<P, ll>(P(nh, nw), 3)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(i, 4) {\n\t\t\tans = min(ans, (ll)d[h - 1][w - 1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n \n#define INF 100000000\n#define EPS 1e-9\n \nusing namespace std;\n \ntypedef long long ll;  \n\n#define MAX_H 30\n#define MAX_W 30\n\nint W, H;\n\nint s[MAX_H][MAX_W];\nint c[4];\n\n//dirx,yに依存\nint dp[4][MAX_H][MAX_W];\nint dirx[] = {1,-1,0,0};\nint diry[] = {0,0,-1,1};\n\nvector<int> ans_list;\n\ntypedef pair<int, int> P;\n\nint dirDec(int dir, int act){\n  \n  if(dir == 0){\n    if(act == 0)\n      return 0;\n    else if(act == 1)\n      return 3;\n    else if(act == 2)\n      return 1;\n    else\n      return 2;\n  }\n\n  else if(dir == 1){\n    if(act == 0)\n      return 1;\n    else if(act == 1)\n      return 2;\n    else if(act == 2)\n      return 0;\n    else\n      return 3;\n  }\n\n  else if(dir == 2){\n    if(act == 0)\n      return 2;\n    else if(act == 1)\n      return 0;\n    else if(act == 2)\n      return 3;\n    else\n      return 1;\n  }\n\n  else{\n    if(act == 0)\n      return 3;\n    else if(act == 1)\n      return 1;\n    else if(act == 2)\n      return 2;\n    else\n      return 0;\n  }\n\n}\n\n\nint solve(){\n\n  for(int i = 0; i < 4; i++){\n    for(int j = 0; j < H; j++){\n      for(int k = 0; k < W; k++){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n\n\n  dp[0][0][0] = 0;\n  \n  queue<P> que;\n  queue<int> D;\n  que.push(make_pair(0,0));\n  D.push(0);\n\n  while(que.size()){\n    \n    P p = que.front();\n    int dir = D.front();\n    que.pop();\n    D.pop();\n    int x = p.first;\n    int y = p.second;\n\n    if(s[y][x] != 4){\n      int dd = dirDec(dir, s[y][x]);\n      int nx = x + dirx[dd];\n      int ny = y + diry[dd];\n      if(nx >= 0 && nx < W && ny >= 0 && ny < H){\n\tif(dp[dd][ny][nx] > dp[dir][y][x]){\n\t  dp[dd][ny][nx] = dp[dir][y][x];\n\t  que.push(make_pair(nx, ny));\n\t  D.push(dd);\n\t}\n      }\n    }\n\n    for(int i = 0; i < 4; i++){\n      int dd = dirDec(dir, i);\n      int cost = c[i];\n      int nx = x + dirx[dd];\n      int ny = y + diry[dd];\n      if(nx >= 0 && nx < W && ny >= 0 && ny < H){\n\tif(dp[dd][ny][nx] > dp[dir][y][x] + cost){\n\t  dp[dd][ny][nx] = dp[dir][y][x] + cost;\n\t  que.push(make_pair(nx, ny));\n\t  D.push(dd);\n\t}\n      }\n    }\n\n  }\n  \n  /*\n  for(int i = 0; i < 4; i++){\n    cout << endl;\n    for(int j = 0; j < H; j++){\n      for(int k = 0; k < W; k++){\n\tcout << \" \" << dp[i][j][k];\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n  */\n\n  int ans = INF;\n  for(int i = 0; i < 4; i++){\n    ans = min(ans, dp[i][H-1][W-1]);\n  }\n\n  return ans;\n\n}\n\nint main(){\n\n  while(true){\n    cin >> W >> H;\n    if(W == 0)\n      break;\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> s[i][j];\n      }\n    }\n\n    for(int i = 0; i < 4; i++){\n      cin >> c[i];\n    }\n\n    ans_list.push_back(solve());\n\n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint W,H;\nint inf = 1e9;\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint dp[21][21][4] = {};\nint S[21][21] = {};\nint C[4] = {};\n\nstruct state{\n    int x,y,direction,dist;\n    bool operator<(const state& right)const{\n        return dist > right.dist;\n    }\n    void go(){\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void turn_right(){\n        direction--;\n        (direction += 4)%=4;\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void turn_back(){\n        (direction += 2)%=4;\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void turn_left(){\n        direction++;\n        direction %= 4;\n        x += dx[direction];\n        y += dy[direction];\n    }\n    void instruction(int i){\n        if(i==0) go();\n        if(i==1) turn_right();\n        if(i==2) turn_back();\n        if(i==3) turn_left();\n    }\n    bool in(){\n        return 1<=x && x<=H && 1<=y && y<=W;\n    }\n};\n\nint main(){\n    while(cin >> W >> H && W>0){\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> S[i][j];\n                for(int k=0;k<4;k++) dp[i][j][k] = inf;\n            }\n        }\n        for(int i=0;i<4;i++) cin >> C[i];\n        dp[1][1][0] = 0;\n        priority_queue<state> Q;\n        state init = {1,1,0,0};\n        Q.push(init);\n        while(!Q.empty()){\n            state now = Q.top(); Q.pop();\n            if(dp[now.x][now.y][now.direction]<now.dist) continue;\n            for(int i=0;i<4;i++){\n                state ne = now;\n                ne.instruction(i);\n                int c = now.dist+C[i]*(i!=S[now.x][now.y]);\n                if(!ne.in()) continue;\n                if(dp[ne.x][ne.y][ne.direction]>c){\n                    dp[ne.x][ne.y][ne.direction] = c;\n                    ne.dist = c;\n                    Q.push(ne);\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=0;i<4;i++) ans = min(ans,dp[H][W][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n#define MAX_COST 100\n#define INF 999999999\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP; // h, w, cost, direction\nstruct\n{\n\tint to;\n\tint cost;\n};\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nvoid solve()\n{\n\tint w, h;\n\twhile(cin >> w >> h, w || h)\n\t{\n\t\tvector< vector<int> > order(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tcin >> order[i][j];\n\t\t\t}\n\t\t}\n\t\tint c[4];\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tcin >> c[i];\n\t\t}\n\t\tint dist[31][31][4];\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < 4; ++k)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[0][0][1] = 0;\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > pq;\n\t\tpq.push(PP(P(0, 0), P(0, 1)));\n\t\twhile(!pq.empty())\n\t\t{\n\t\t\tPP pp = pq.top();\n\t\t\tint y = pq.top().first.first;\n\t\t\tint x = pq.top().first.second;\n\t\t\tint sum_cost = pq.top().second.first;\n\t\t\tint dir = pq.top().second.second;\n\t\t\tpq.pop();\n\t\t\tif(dist[y][x][dir] < sum_cost)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint cost = c[i];\n\t\t\t\tif(order[y][x] == i)\n\t\t\t\t{\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tint prev = dir;\n\t\t\t\tint next = (prev + i) % 4;\n\t\t\t\tint nx = x + dx[next];\n\t\t\t\tint ny = y + dy[next];\n\n\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}\n\t\t\t\tif(dist[ny][nx][next] > sum_cost + cost)\n\t\t\t\t{\n\t\t\t\t\tdist[ny][nx][next] = sum_cost + cost;\n\t\t\t\t\tpq.push(PP(P(ny, nx), P(sum_cost + cost, next)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_cost = INF;\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif(min_cost > dist[h - 1][w - 1][i])\n\t\t\t{\n\t\t\t\tmin_cost = dist[h - 1][w - 1][i];\n\t\t\t}\n\t\t}\n\t\tcout << min_cost << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "// ??????: http://d.hatena.ne.jp/simezi_tan/20140920/1411169324\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) cout<<(#_v)<<\":\";for(auto(_x):(_v)){cout<<\" \"<<(_x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// 14:30-15:00\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nint w, h;\nint a[30][30];\nint c[4];\nint d[30][30][4]; // d[i][j][k] = (i, j):pos, k:dir\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint dijkstra() {\n    using State = tuple<int, int, int, int>; // cost, i, j, k\n    priority_queue<State, vector<State>, greater<State>> pq;\n    rep(i, h) rep(j, w) rep(k, 4) d[i][j][k] = inf;\n    d[0][0][1] = 0;\n    pq.push(State(0, 0, 0, 1));\n\n    while (!pq.empty()) {\n        int cost, i, j, k;\n        tie(cost, i, j, k) = pq.top(); pq.pop();\n        if (d[i][j][k] < cost) continue;\n        rep(nk, 4) {\n            int ni = i + dx[nk], nj = j + dy[nk];\n            if (!inside(ni, nj)) continue;\n            int ncost = c[(nk - k + 4) % 4];\n            if (a[i][j] != 4 && nk == (k + a[i][j]) % 4) {\n                ncost = 0;\n            }\n            if (d[ni][nj][nk] > cost + ncost) {\n                d[ni][nj][nk] = cost + ncost;\n                pq.push(State(cost + ncost, ni, nj, nk));\n            }\n        }\n    }\n\n    int ret = inf;\n    rep(k, 4) chmin(ret, d[h-1][w-1][k]);\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    while (cin >> w >> h, w) {\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        rep(i, 4) cin >> c[i];\n        cout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nvector<vector<PLL>> G;\n\nint32 w, h;\n\nvoid add_edge(int32 y1, int32 x1, int32 d1, int32 y2, int32 x2, int32 d2, int32 v=0){\n\tG[y1*w+x1+d1*h*w].push_back(PLL(v, y2*w+x2+d2*h*w));\n}\n\nint32 dx[4] = {0, 1, 0, -1};\nint32 dy[4] = {1, 0, -1, 0};\n\nint main(void){\n\tauto in = [&](int32 y, int32 x){\n\t\treturn 0<=y&&y<h&&0<=x&&x<w;\n\t};\n\twhile(cin >> w >> h && w+h){\n\t\tvector<vector<int32>> s(h, vector<int32>(w));\n\t\tG.clear();\n\t\tG.resize(w*h*8);\n\t\tint32 c[4] = {};\n\t\tREP(i, h) REP(j, w) cin >> s[i][j];\n\t\tREP(i, 4) cin >> c[i];\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tREP(k, 4){\n\t\t\t\t\tREP(l, 4){\n\t\t\t\t\t\tint32 cost = (s[i][j] == (4-l)%4 ? 0 : c[(4-l)%4]);\n\t\t\t\t\t\tif(in(i+dy[(k+l)%4], j+dx[(k+l)%4])){\n\t\t\t\t\t\t\tadd_edge(i, j, k, i+dy[(k+l)%4], j+dx[(k+l)%4], (k+l)%4, cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int64> d(w*h*8, INF_LL);\n\t\tpriority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n\t\td[h*w] = 0;\n\t\tpq.push(PLL(0, h*w));\n\t\twhile(pq.size()){\n\t\t\tint32 v, dd;\n\t\t\ttie(dd, v) = pq.top(); pq.pop();\n\t\t\tif(dd > d[v]) continue;\n\t\t\tREP(i, G[v].size()){\n\t\t\t\tif(d[G[v][i].sc] > d[v]+G[v][i].fs){\n\t\t\t\t\td[G[v][i].sc] = d[v]+G[v][i].fs;\n\t\t\t\t\tpq.push(PLL(d[G[v][i].sc], G[v][i].sc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min({d[h*w-1], d[2*h*w-1], d[3*h*w-1], d[4*h*w-1]}) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> PII;\ntypedef pair<int,pair<int,PII>> State;\n\nint di[] = {-1,0,1,0};\nint dj[] = {0,1,0,-1};\nint w,h;\nint c[4];\nVVI board(31,VI(31));\nconst int INF = 1e9;\nint dijkstra(){\n  int dist[h][w][4];\n  rep(i,h)rep(j,w)rep(dir,4) dist[i][j][dir] = INF;\n  dist[0][0][1] = 0;\n  priority_queue< State, vector<State>, greater<State>> que;\n  que.push(State(0,{1,{0,0}}));\n\n  while(que.empty() == false){\n    State p = que.top();\n    que.pop();\n    int cdist = p.first;\n    int cdir = p.second.first;\n    int ci  = p.second.second.first;\n    int cj = p.second.second.second;\n    //cout << ci << \" \" << cj << \" \" << cdir << endl;\n    if(dist[ci][cj][cdir] < cdist) continue;\n    // 0: 直進\n    int ni = ci + di[cdir];\n    int nj = cj + dj[cdir];\n    int cost = c[0];\n    if(board[ci][cj] == 0) cost = 0;\n    if(ni >= 0 && nj >= 0 && ni < h && nj < w && dist[ni][nj][cdir] > (cdist + cost) ){\n      dist[ni][nj][cdir] = (cdist + cost);\n      que.push(State(dist[ni][nj][cdir],{cdir,{ni,nj}}));\n    }\n\n    //1「右折」命令\n    cost = c[1];\n    if(board[ci][cj] == 1) cost = 0;\n    int ndir =(cdir+1)%4;\n    ni = ci + di[ndir];\n    nj = cj + dj[ndir];\n    if(ni >= 0 && nj >= 0 && ni < h && nj < w && dist[ni][nj][ndir] > (cdist + cost) ){\n      dist[ni][nj][ndir] = (cdist + cost);\n      que.push(State(dist[ni][nj][ndir],{ndir,{ni,nj}}));\n    }\n\n    //2「反転」命令\n    cost = c[2];\n    if(board[ci][cj] == 2) cost = 0;\n    ndir =(cdir+2)%4;\n    ni = ci + di[ndir];\n    nj = cj + dj[ndir];\n    if(ni >= 0 && nj >= 0 && ni < h && nj < w && dist[ni][nj][ndir] > (cdist + cost) ){\n      dist[ni][nj][ndir] = (cdist + cost);\n      que.push(State(dist[ni][nj][ndir],{ndir,{ni,nj}}));\n    }\n\n   //「左折」命令\n   cost = c[3];\n   if(board[ci][cj] == 3) cost = 0;\n   ndir =(cdir+3)%4;\n   ni = ci + di[ndir];\n   nj = cj + dj[ndir];\n   if(ni >= 0 && nj >= 0 && ni < h && nj < w && dist[ni][nj][ndir] > (cdist + cost) ){\n     dist[ni][nj][ndir] = (cdist + cost);\n     que.push(State(dist[ni][nj][ndir],{ndir,{ni,nj}}));\n   }\n\n  }\n  int ans = INF;\n  // rep(i,h){\n  //   rep(j,w){\n  //     int tmp = INF;\n  //     rep(dir,4) tmp = min(dist[i][j][dir],tmp);\n  //     cout << tmp << \" \";\n  //   }\n  //   cout << endl;\n  // }\n\n  rep(dir,4) ans = min(dist[h-1][w-1][dir],ans);\n  return ans;\n}\n\n\n\nint main(){\n  while(true){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    rep(i,h)rep(j,w) cin >> board[i][j];\n    rep(i,4) cin >> c[i];\n    cout << dijkstra() << endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint dd[]={0,1,2,3};\ntypedef tuple<int,int,int,int>state;\n\nint H,W;\nint S[30][30];\nint C[4];\n\nconst int INF=1001001001;\nint dist[30][30][4];\nvoid solve(){\n    fill_n(**dist,30*30*4,INF);\n    dist[0][0][0]=0;\n    priority_queue<state,vector<state>,greater<state>>que;\n    que.push(make_tuple(0,0,0,0));\n    while(que.size()){\n        int c,y,x,d;\n        tie(c,y,x,d)=que.top();\n        que.pop();\n        if(dist[y][x][d]<c)continue;\n        rep(i,4){\n            int nd=(d+dd[i])%4;\n            int ny=y+dy[nd],nx=x+dx[nd];\n            if(ny<0||ny>=H||nx<0||nx>=W)continue;\n            int nc=c;\n            if(S[y][x]!=i)nc+=C[i];\n            if(dist[ny][nx][nd]<=nc)continue;\n            dist[ny][nx][nd]=nc;\n            que.push(make_tuple(nc,ny,nx,nd));\n        }\n    }\n\n    int mi=INF;\n    rep(i,4)chmin(mi,dist[H-1][W-1][i]);\n    cout<<mi<<endl;\n}\n\nsigned main(){\n    while(cin>>W>>H,W||H){\n        rep(i,H)rep(j,W)cin>>S[i][j];\n        rep(i,4)cin>>C[i];\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n\tint n = g.size();\n\tassert(s < n);\n\tenum { WHITE, GRAY, BLACK };\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>;\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tcolor[v] = BLACK; prev[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int w, h; cin >> w >> h && w;) {\n\t\tvector<vector<int>> v(h, vector<int>(w));\n\t\trep(i, 0, h) rep(j, 0, w) { cin >> v[i][j]; }\n\t\tGraph g(w*h * 4);\n\t\tauto index = [&](int i, int j, int d) {return i*w + j + d*w*h; };\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < h && j >= 0 && j < w; };\n\t\tvector<int> c(4); rep(i, 0, 4) {\n\t\t\tcin >> c[i];\n\t\t}\n\n\t\tstatic const int di[] = { 0,1,0,-1 };\n\t\tstatic const int dj[] = { 1,0,-1,0 };\n\t\trep(i, 0, h)rep(j, 0, w) {\n\t\t\trep(a, 0, 4) {\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint b = (a + k) % 4;\n\t\t\t\t\tint ni = i + di[b], nj = j + dj[b];\n\t\t\t\t\tif (!inrange(ni, nj))continue;\n\t\t\t\t\tif (k == v[i][j])\n\t\t\t\t\t\taddArc(g, index(i, j, a), index(ni, nj, b), 0);\n\t\t\t\t\telse\n\t\t\t\t\t\taddArc(g, index(i, j, a), index(ni, nj, b), c[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tArray dist;\n\t\tdijkstra(g, index(0, 0, 0), dist);\n\t\trep(b, 0, 4) {\n\t\t\tchmin(ans, dist[index(h - 1, w - 1, b)]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(!w) break;\n    vector<vector<int>> s(h,vector<int>(w));\n    for(int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> s[i][j];\n      }\n    }\n    int c[4];\n    for(int i = 0; i < 4; ++i) {\n      cin >> c[i];\n    }\n    using edge = vector<tuple<int,int,int>>;\n    vector<vector<vector<edge>>> to(h,vector<vector<edge>>(w,vector<edge>(4)));\n    vector<vector<vector<vector<int>>>> cost(h,vector<vector<vector<int>>>(w,vector<vector<int>>(4)));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int di[] = {1,0,-1,0};\n        int dj[] = {0,1,0,-1};\n        for (int k = 0; k < 4; ++k) {\n          int ni=i+di[k];\n          int nj=j+dj[k];\n          if(ni<0||nj<0||ni>=h||nj>=w)continue;\n          for (int l = 0; l < 4; ++l) {\n            to[i][j][l].push_back(make_tuple(ni,nj,k));\n            if ((l - k + 4) % 4 == s[i][j]) {\n              cost[i][j][l].push_back(0);\n            } else {\n              cost[i][j][l].push_back(c[(l - k + 4) % 4]);\n            }\n          }\n        }\n      }\n    }\n    priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, greater<tuple<int,int,int,int>>> q;\n    q.push(make_tuple(0,0,0,1));\n    vector<vector<vector<int>>> d(h,vector<vector<int>>(w,vector<int>(4,1000000000)));\n    d[0][0][1] = 0;\n    while(!q.empty()) {\n      auto p = q.top(); q.pop();\n      int c,i,j,k;\n      tie(c,i,j,k) = p;\n      if (c > d[i][j][k]) continue;\n      for (int l = 0; l < to[i][j][k].size(); ++l) {\n        int ni,nj,nk;\n        tie(ni,nj,nk) = to[i][j][k][l];\n        if (d[ni][nj][nk] > d[i][j][k] + cost[i][j][k][l]) {\n          d[ni][nj][nk] = d[i][j][k] + cost[i][j][k][l];\n          q.push(make_tuple(d[ni][nj][nk],ni,nj,nk));\n        }\n      }\n    }\n    int minc = 1000000000;\n    for (int i = 0; i < 4; ++i) {\n      minc = min(minc,d[h-1][w-1][i]);\n    }\n    cout << minc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int INF=12345678;\n\nstruct state{ int x,y,d; };\n\nint main()\n{\n    int dx[4]={0,1,0,-1}, dy[4]={-1,0,1,0};\n\n    int w,h;\n    while(cin >>w >>h,w)\n    {\n        int s[30][30];\n        int c[4];\n\n        rep(i,h)rep(j,w) scanf(\" %d\", &s[i][j]);\n        rep(i,4) scanf(\" %d\", &c[i]);\n\n        int dist[30][30][4];\n        rep(i,30)rep(j,30)rep(k,4) dist[i][j][k]=INF;\n        dist[0][0][1]=0;\n        queue<state> que;\n        que.push(state{0,0,1});\n        #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n        while(!que.empty())\n        {\n            state now=que.front();\n            que.pop();\n            if(now.x==w-1 && now.y==h-1) continue;\n\n            rep(i,4)\n            {\n                int cost=c[i];\n                if(s[now.y][now.x]==i) cost=0;\n\n                int nd=(now.d+i)%4;\n                int nx=now.x+dx[nd], ny=now.y+dy[nd];\n                if(IN(nx,ny) && dist[ny][nx][nd]>dist[now.y][now.x][now.d]+cost)\n                {\n                    dist[ny][nx][nd]=dist[now.y][now.x][now.d]+cost;\n                    que.push(state{nx,ny,nd});\n                }\n            }\n        }\n\n        int ans=INF;\n        rep(i,4) ans=min(ans,dist[h-1][w-1][i]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] % MOD * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\nint dist[35][35][4];\nint dxy[5] = {-1, 0, 1, 0, -1};\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  int w, h;\n  while (cin >> w >> h)\n  {\n    if (w == 0 && h == 0)\n      break;\n    vector<vector<int>> v(h, vector<int>(w));\n    REP(i, h)\n    {\n      REP(j, w)\n      {\n        cin >> v[i][j];\n      }\n    }\n\n    int c0, c1, c2, c3;\n    cin >> c0 >> c1 >> c2 >> c3;\n\n    //点(y, x)での最小コスト\n    REP(i, h)\n    {\n      REP(j, w)\n      {\n        dist[i][j][0] = dist[i][j][1] = dist[i][j][2] = dist[i][j][3] = INT_MAX;\n      }\n    }\n    dist[0][0][0] = 0;\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;\n    q.push(make_pair(0, make_pair(0, 0)));\n\n    while (q.size())\n    {\n      auto p = q.top();\n      q.pop();\n\n      int cost = p.first;\n      int y = p.second.first / w, x = p.second.first % w;\n      int dir = p.second.second;\n\n      if (y == h - 1 && x == w - 1)\n        break;\n      if (v[y][x] == 0)\n      {\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          nx++;\n        }\n        else if (dir == 1)\n        {\n          ny++;\n        }\n        else if (dir == 2)\n        {\n          nx--;\n        }\n        else\n        {\n          ny--;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir])\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir];\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n      else if (v[y][x] == 1)\n      {\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          ndir = 1;\n          ny++;\n        }\n        else if (dir == 1)\n        {\n          ndir = 2;\n          nx--;\n        }\n        else if (dir == 2)\n        {\n          ndir = 3;\n          ny--;\n        }\n        else\n        {\n          ndir = 0;\n          nx++;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir])\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir];\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n      else if (v[y][x] == 2)\n      {\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          ndir = 2;\n          nx--;\n        }\n        else if (dir == 1)\n        {\n          ndir = 3;\n          ny--;\n        }\n        else if (dir == 2)\n        {\n          ndir = 0;\n          nx++;\n        }\n        else\n        {\n          ndir = 1;\n          ny++;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir])\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir];\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n      else if (v[y][x] == 3)\n      {\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          ndir = 3;\n          ny--;\n        }\n        else if (dir == 1)\n        {\n          ndir = 0;\n          nx++;\n        }\n        else if (dir == 2)\n        {\n          ndir = 1;\n          ny++;\n        }\n        else\n        {\n          ndir = 2;\n          nx--;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir])\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir];\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n      else if (v[y][x] == 4)\n      {\n        //停止？何もしなくてよさそう\n      }\n\n      {\n        // 直進\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          nx++;\n        }\n        else if (dir == 1)\n        {\n          ny++;\n        }\n        else if (dir == 2)\n        {\n          nx--;\n        }\n        else\n        {\n          ny--;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir] + c0)\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir] + c0;\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n      {\n        //右折\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          ndir = 1;\n          ny++;\n        }\n        else if (dir == 1)\n        {\n          ndir = 2;\n          nx--;\n        }\n        else if (dir == 2)\n        {\n          ndir = 3;\n          ny--;\n        }\n        else\n        {\n          ndir = 0;\n          nx++;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir] + c1)\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir] + c1;\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n\n      {\n        //反転\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          ndir = 2;\n          nx--;\n        }\n        else if (dir == 1)\n        {\n          ndir = 3;\n          ny--;\n        }\n        else if (dir == 2)\n        {\n          ndir = 0;\n          nx++;\n        }\n        else\n        {\n          ndir = 1;\n          ny++;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir] + c2)\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir] + c2;\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n      {\n        //左折\n        int ny = y, nx = x, ndir = dir;\n        if (dir == 0)\n        {\n          ndir = 3;\n          ny--;\n        }\n        else if (dir == 1)\n        {\n          ndir = 0;\n          nx++;\n        }\n        else if (dir == 2)\n        {\n          ndir = 1;\n          ny++;\n        }\n        else\n        {\n          ndir = 2;\n          nx--;\n        }\n\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w)\n        {\n          if (dist[ny][nx][ndir] > dist[y][x][dir] + c3)\n          {\n            dist[ny][nx][ndir] = dist[y][x][dir] + c3;\n            q.push(make_pair(dist[ny][nx][ndir], make_pair(ny * w + nx, ndir)));\n          }\n        }\n      }\n    }\n    int mi = min({dist[h - 1][w - 1][0], dist[h - 1][w - 1][1], dist[h - 1][w - 1][2], dist[h - 1][w - 1][3]});\n    cout << mi << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint sdx[4] = {0, 1, 0, -1};\nint sdy[4] = {-1, 0, 1, 0};\n\nstruct Edge{\n  int src,dst,weight;\n  Edge(int src,int dst,int weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return (e.weight != f.weight) ? e.weight>f.weight :\n    (e.src != f.src) ? e.src<f.src : e.dst<f.src;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nconst int INF = 0x7fffffff;\nint w,h;\nvoid dijkstra(const Graph &g, int s, vector<int> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF);\n  dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q;\n\n  for(Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top();\n    Q.pop();\n    if(prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    //cout<<\"now \"<<(e.dst/4)/w<<\":\"<<(e.dst/4)%w<<endl;\n    for(Edges::const_iterator it = g[e.dst].begin(); it != g[e.dst].end(); ++it) {\n      if(dist[it->dst] > e.weight + it->weight) {\n\tdist[it->dst] = e.weight + it->weight;\n\tQ.push(Edge(it->src, it->dst, e.weight + it->weight));\n      }\n    }\n  }\n}\n\nvector<int> buildPath(const vector<int> &prev, int t) {\n  vector<int> path;\n  for(int u = t; u >= 0; u = prev[u])\n    path.push_back(u);\n  reverse(path.begin(), path.end());\n  return path;\n}\n\n/*\n * map[i][j][up] = g[(i*w+j)*4]\n * map[i][j][right] = g[(i*w+j)*4+1]\n * map[i][j][down] = g[(i*w+j)*4+2]\n * map[i][j][left] = g[(i*w+j)*4+3]\n */\n\nint main() {\n  while(cin>>w>>h, w||h) {\n    Graph g(w*h*4);\n    int t;\n\n    for(int i=0; i<h; ++i) {\n      for(int j=0; j<w; ++j) {\n\tcin>>t;\n\tif(t==4) continue;\n\tfor(int k=0; k<4; ++k) {\n\t  int tk = (k+t)%4;\n\t  int nx = j+sdx[tk], ny = i+sdy[tk];\n\t  if(nx >= 0 && nx < w && ny >= 0 && ny < h )\n\t  g[(i*w+j)*4+k].push_back( Edge((i*w+j)*4+k, (ny*w+nx)*4+tk%4, 0) );\n\t}\n      }\n    }\n\n    int c[4];\n    cin>>c[0]>>c[1]>>c[2]>>c[3];\n\n    for(int i=0; i<h; ++i) {\n      for(int j=0; j<w; ++j) {\n\tfor(int t=0; t<4; ++t) {\n\t  for(int k=0; k<4; ++k) {\n\t    int tk = (k+t)%4;\n\t    int nx = j+sdx[tk],ny = i+sdy[tk];\n\t    if(nx >= 0 && nx < w && ny >= 0 && ny < h)\n\t       g[(i*w+j)*4+k].push_back( Edge((i*w+j)*4+k, (ny*w+nx)*4+tk, c[t]) );\n\t  }\n\t}\n      }\n    }\n\n    vector<int> dist;\n    vector<int> prev;\n    dijkstra(g, 1, dist, prev);\n\n    int ans = min( dist[dist.size()-2], dist[dist.size()-3] );\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 100000000\nusing namespace std;\nstruct state { int dir, y, x, s; };\n\nint H, W, S[30][30], C[4], dp[30][30][4];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.s > b.s;\n  }\n};\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  while(cin >> W >> H, H) {\n    REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n    REP(i, 0, 4) cin >> C[i];\n\n    REP(i, 0, H) REP(j, 0, W) REP(k, 0, 4) dp[i][j][k] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { 0, 0, 0, 0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      dp[c.y][c.x][c.dir] = min(dp[c.y][c.x][c.dir], c.s);\n      if(c.y == H - 1 && c.x == W - 1) break;\n\n      REP(i, 0, 4) {\n        int dir = (c.dir + i) % 4;\n        int w = i == S[c.y][c.x] ? 0 : C[i];\n        struct state n = { dir, c.y + dd[dir], c.x + dd[dir + 1], c.s + w };\n        if(isin(n.y, n.x) && n.s < dp[n.y][n.x][n.dir]) q.push(n);\n      }\n    }\n\n    int ans = INF;\n    REP(i, 0, 4) ans = min(ans, dp[H - 1][W - 1][i]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint W, H, C[4];\nint board[35][35];\nint cost[35][35][4];\n\nstruct Elem {\n    int x, y, dir;\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nsigned main() {\n    while(cin >> W >> H, W || H) {\n        rep(i,0,H) rep(j,0,W) {\n            cin >> board[i][j];\n            rep(k,0,4) cost[i][j][k] = INF;\n        }\n        rep(i,0,4) cin >> C[i];\n\n        // North, East, South, West\n        cost[0][0][1] = 0;\n        queue<Elem> q;\n        q.push(Elem{0, 0, 1});\n\n        while(!q.empty()) {\n            Elem t = q.front(); q.pop();\n            int curcost = cost[t.x][t.y][t.dir];\n            int ndir = (board[t.x][t.y] + t.dir) % 4;\n            if(board[t.x][t.y] == 4) ndir = -1;\n\n            rep(i,0,4) {\n                int k = (t.dir + i) % 4;\n                int c = (ndir != k ? C[i] : 0);\n                int nx = t.x + dx[k], ny = t.y + dy[k];\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if(cost[nx][ny][k] > curcost + c) {\n                    cost[nx][ny][k] = curcost + c;\n                    q.push(Elem{nx, ny, k});\n                }\n            }\n        }\n\n        // rep(i,0,H) rep(j,0,W) rep(k,0,4) printf(\"debug: cost[%lld][%lld][%lld] = %lld\\n\", i, j, k, cost[i][j][k]);\n\n        int ans = INF;\n        rep(i,0,4) chmin(ans, cost[H-1][W-1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1e9\nchar v[31][31][4];\nint map[31][31];\nint dp[31][31][4];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h,c[4];\n\nclass State{\npublic:\n\tint cost;\n\tint x,y,d;\n\t\n\tState(){}\n\tState(int c, int a, int b, int e)\n\t:cost(c),x(a),y(b),d(e)\n\t{}\n\tbool operator < (const State &opp) const{\n\t\treturn cost > opp.cost;\n\t}\n};\n\nmain(){\n\tint i,j,k;\n\tchar *p,*q;\n\twhile(cin>>w>>h,w){\n\t\tfor(i=1;i<=h;i++) \n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\tdp[j][i][k] = INF;\n\t\t\t\t\tv[j][i][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\tfor(i=0;i<4;i++) cin>>c[i];\n\t\t\n\t\tpriority_queue<State> S;\n\t\tState t;\n\t\tS.push(State(0,1,1,0));\n\t\tdp[1][1][0] = 0;\n\t\twhile(!S.empty()){\n\t\t\tt = S.top();S.pop();\n\t\t\tif(t.x==w&&t.y==h) break;\n\t\t\tif(v[t.x][t.y][t.d]) continue;\n\t\t\tv[t.x][t.y][t.d] = 1;\n\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tint td = (t.d+i)%4;\n\t\t\t\tint tx=t.x+dx[td];\n\t\t\t\tint ty=t.y+dy[td];\n\t\t\t\tif(tx<1 || ty<1 || w<tx || h<ty) continue;\n\t\t\t\tint tc=(map[t.y][t.x]==i)?0:c[i];\n\t\t\t\tif(t.cost+tc < dp[tx][ty][td]){\n\t\t\t\t\tdp[tx][ty][td] = t.cost+tc;\n\t\t\t\t\tS.push(State(dp[tx][ty][td], tx, ty, td));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[w][h][t.d] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int x, y, c, d;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.c != r.c)\n    return l.c > r.c;\n  else if(l.x != r.x)\n    return l.x > r.x;\n  return l.y > r.y;\n}\n\nint w, h;\nvector<vector<int>> s;\nint c[4] = {0};\nint d[4] = {0, 1, 0, -1};\nint dis[33][33][4] = {0};\npriority_queue<data> pq;\n\nvoid reset();\nbool ch(int x, int y);\nint solve();\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w + h == 0) break;\n    reset();\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j) cin >> s[i][j];\n    for(int i = 0; i < 4; ++i) cin >> c[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nvoid reset() {\n  while(!pq.empty()) pq.pop();\n  s.resize(h);\n  for(int i = 0; i < h; ++i) s[i].assign(w, 0);\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      for(int k = 0; k < 4; ++k) dis[i][j][k] = 1e9;\n}\nbool ch(int x, int y) {\n  return x >= 0 && x < h && y >= 0 && y < w;\n}\n\nint solve() {\n  int ans = 1e9;\n  pq.push({0, 0, 0, 0});\n  while(!pq.empty()) {\n    data now, nextd;\n    now = pq.top();\n    pq.pop();\n    if(now.c >= dis[now.x][now.y][now.d]) continue;\n    dis[now.x][now.y][now.d] = now.c;\n    for(int i = 0; i < 4; ++i) {\n      nextd = now;\n      nextd.x += d[i];\n      nextd.y += d[i ^ 1];\n      if(!ch(nextd.x, nextd.y)) continue;\n      if(s[now.x][now.y] == 4 ||\n         (s[now.x][now.y] + now.d) % 4 != i)\n        nextd.c += c[(i + 4 - now.d) % 4];\n      nextd.d = i;\n      if(nextd.x == h - 1 && nextd.y == w - 1) {\n        ans = min(ans, nextd.c);\n        continue;\n      }\n      pq.push(nextd);\n    }\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(!w) break;\n    vector<vector<int>> s(h,vector<int>(w));\n    for(int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> s[i][j];\n      }\n    }\n    int c[4];\n    for(int i = 0; i < 4; ++i) {\n      cin >> c[i];\n    }\n    typedef vector<tuple<int,int,int>> edge;\n    vector<vector<vector<edge>>> to(h,vector<vector<edge>>(w,vector<edge>(4)));\n    vector<vector<vector<vector<int>>>> cost(h,vector<vector<vector<int>>>(w,vector<vector<int>>(4)));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        int di[] = {1,0,-1,0};\n        int dj[] = {0,1,0,-1};\n        for (int k = 0; k < 4; ++k) {\n          int ni=i+di[k];\n          int nj=j+dj[k];\n          if(ni<0||nj<0||ni>=h||nj>=w)continue;\n          for (int l = 0; l < 4; ++l) {\n            to[i][j][l].push_back(make_tuple(ni,nj,k));\n            if ((l - k + 4) % 4 == s[i][j]) {\n              cost[i][j][l].push_back(0);\n            } else {\n              cost[i][j][l].push_back(c[(l - k + 4) % 4]);\n            }\n          }\n        }\n      }\n    }\n    priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, greater<tuple<int,int,int,int>>> q;\n    q.push(make_tuple(0,0,0,1));\n    vector<vector<vector<int>>> d(h,vector<vector<int>>(w,vector<int>(4,1000000000)));\n    d[0][0][1] = 0;\n    while(!q.empty()) {\n      auto p = q.top(); q.pop();\n      int c,i,j,k;\n      tie(c,i,j,k) = p;\n      if (c > d[i][j][k]) continue;\n      for (int l = 0; l < to[i][j][k].size(); ++l) {\n        int ni,nj,nk;\n        tie(ni,nj,nk) = to[i][j][k][l];\n        if (d[ni][nj][nk] > d[i][j][k] + cost[i][j][k][l]) {\n          d[ni][nj][nk] = d[i][j][k] + cost[i][j][k][l];\n          q.push(make_tuple(d[ni][nj][nk],ni,nj,nk));\n        }\n      }\n    }\n    int minc = 1000000000;\n    for (int i = 0; i < 4; ++i) {\n      minc = min(minc,d[h-1][w-1][i]);\n    }\n    cout << minc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint V;\nint d[4000];\nint s;\nvector<vector<edge>> es;\n\nvoid dijkstra(int s)\n{\n\tfill(ALL(d), INF);\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tREP(i, es[v].size())\n\t\t{\n\t\t\tedge e = es[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint place(int x, int y, int w)\n{\n\treturn x*w + y;\n}\n\n//right 0, down 1, left 2, up 3\nint dx[] = { 0, 1, 0, -1 }; int dy[] = { 1, 0, -1, 0 };\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tes.clear();\n\t\tes.resize(w*h * 4);\n\t\tint fld[31][31];\n\t\tREP(i, h)REP(j, w) cin >> fld[i][j];\n\t\tint cost[4];\n\t\tREP(i, 4) cin >> cost[i];\n\t\tREP(i, 4)\n\t\t{\n\t\t\tREP(j, h)REP(k, w)\n\t\t\t{\n\t\t\t\tint tmp = place(j, k, w) + i*(w*h);\n\t\t\t\tREP(l, 4)\n\t\t\t\t{\n\t\t\t\t\tint nx = j + dx[l], ny = k + dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = place(nx, ny, w) + l*(w * h);\n\t\t\t\t\tif ((l - i + 4) % 4 == fld[j][k]) es[tmp].push_back(edge{ tmp, next, 0 });\n\t\t\t\t\telse es[tmp].push_back(edge{ tmp, next, cost[(l - i + 4) % 4] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tint goal = place(h - 1, w - 1, w);\n\t\tint ans = INF;\n\t\tREP(i, 4) ans = min(ans, d[i*(w * h) + goal]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\n#define INF 1e9\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\n\nint h, w;\nvvi field(30, vi(30));\nvi c_costs(4);\nint f_dir[2][4] = {{-1, 0, 1, 0}, {0, 1, 0, -1}};\nbool is_in_field(int y, int x, int h, int w){\n  return (y >= 0 && y < h && x >= 0 && x < w);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  while(cin >> w >> h && h){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> field[i][j];\n      }\n    }\n    for(int &i: c_costs) cin >> i;\n    vvvi cost(30, vvi(30, vi(4, INF)));\n    cost[0][0][1] = 0;\n    queue<ppi> q;\n    q.push({{0, 0}, 1});\n    auto ex = [](int i, int j){\n      if(j == i) return 0;\n      if(j == (i+1)%4) return 1;\n      if(j == (i+2)%4) return 2;\n      return 3;\n    };\n    while(!q.empty()){\n      ppi now = q.front(); q.pop();\n      int now_y = now.first.first, now_x = now.first.second, now_dir = now.second;\n      for(int j = 0; j < 4; j++){\n        int nx_y = now_y+f_dir[0][j], nx_x = now_x+f_dir[1][j], nx_dir = j;\n        if(!is_in_field(nx_y, nx_x, h, w)) continue;\n        int ex_dir = ex(now_dir, nx_dir);\n        int ex_cost = (field[now_y][now_x] == ex_dir) ? 0 : c_costs[ex_dir];\n        if(cost[nx_y][nx_x][nx_dir] > cost[now_y][now_x][now_dir] + ex_cost){\n          q.push({{nx_y, nx_x}, nx_dir});\n          cost[nx_y][nx_x][nx_dir] = cost[now_y][now_x][now_dir] + ex_cost;\n        }\n      }\n    }\n    cout << *min_element(cost[h-1][w-1].begin(), cost[h-1][w-1].end()) << endl;\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\nint memo[31][31][4];\nstruct E {P ps;int cost;int k;};\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint main(){\n    int w,h;\n    while(cin >> w >> h){\n        if(!w&&!h) break;\n        int s[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> s[i][j];\n            }\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 4; k++) {\n                    memo[i][j][k]=INF;\n                }\n            }\n        }\n        int C[4];\n        for (int i = 0; i < 4; i++) {\n            cin >> C[i];\n        }\n        queue<E> q;   \n        q.push({P(0,0),0,0});\n        while(!q.empty()){\n            E e=q.front();q.pop();\n            P p=e.ps;\n            int kk=e.k;\n            int c=e.cost;\n            if(memo[p.fs][p.sc][kk]<=e.cost) continue;\n            memo[p.fs][p.sc][kk]=e.cost;\n            for (int i = 0; i < 4; i++) {\n                int nx=p.sc+dx[(i+kk)%4],ny=p.fs+dy[(i+kk)%4];\n                int nc=c+(s[p.fs][p.sc]==i?0:C[i]);\n                if(0<=nx&&nx<w&&0<=ny&&ny<h){\n                    q.push({P(ny,nx),nc,(i+kk)%4});\n                }\n            }\n        }\n        int ans=INF;\n        for (int i = 0; i < 4; i++) {\n            ans=min(ans,memo[h-1][w-1][i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 32\n#define MAXW 32\ntypedef long long ll;\n\nstruct point {\n    int x, y, dir;\n};\n\nstruct edge {\n    point from, to;\n    int cost;\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n// 場所がh, wで方向が0~3の時のいろんな場所への遷移の仕方\n// 0:右 1:上 2:左 3:下\nvector<edge> es[MAXH][MAXW][4]; \n\nint s[MAXH][MAXW];\nint w, h;\nint c[4];\nint dist[MAXH][MAXW][4];\nbool used[MAXH][MAXW][4];\n\nint main(void) {\n    while (1) {\n        // input\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                cin >> s[y][x];\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            cin >> c[i];\n        }\n\n        // data arrange\n        for (int y = 0; y < 32; y++) \n            for (int x = 0; x < 32; x++) \n                for (int i = 0; i < 4; i++)\n                    es[y][x][i].clear();\n        edge e;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                // straight\n                for (int i = 0; i < 4; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                        e.from.x = x; e.from.y = y; e.from.dir = i;\n                        e.to.x = nx; e.to.y = ny; e.to.dir = i;\n                        if (s[y][x] == 0) e.cost = 0;\n                        else e.cost = c[0];\n                        es[y][x][i].push_back(e);\n                    }\n                }\n                // right\n                for (int i = 0; i < 4; i++) {\n                    int nx = x + dx[(i+1)%4];\n                    int ny = y + dy[(i+1)%4];\n                    if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                        e.from.x = x; e.from.y = y; e.from.dir = i;\n                        e.to.x = nx; e.to.y = ny; e.to.dir = (i+1) % 4;\n                        if (s[y][x] == 1) e.cost = 0;\n                        else e.cost = c[1];\n                        es[y][x][i].push_back(e);\n                    }\n                }\n                for (int i = 0; i < 4; i++) {\n                    int nx = x - dx[i];\n                    int ny = y - dy[i];\n                    if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                        e.from.x = x; e.from.y = y; e.from.dir = i;\n                        e.to.x = nx; e.to.y = ny; e.to.dir = (i+2) % 4;\n                        if (s[y][x] == 2) e.cost = 0;\n                        else e.cost = c[2];\n                        es[y][x][i].push_back(e);\n                    }\n                }\n                for (int i = 0; i < 4; i++) {\n                    int nx = x + dx[(i+3)%4];\n                    int ny = y + dy[(i+3)%4];\n                    if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                        e.from.x = x; e.from.y = y; e.from.dir = i;\n                        e.to.x = nx; e.to.y = ny; e.to.dir = (i+3) % 4;\n                        if (s[y][x] == 3) e.cost = 0;\n                        else e.cost = c[3];\n                        es[y][x][i].push_back(e);\n                    }\n                }\n            }\n        }\n        // data arrange check\n        //for (int y = 0; y < h; y++) {\n        //    for (int x = 0; x < w; x++) {\n        //        for (int i = 0; i < 4; i++) {\n        //            printf(\"(%d,%d,%d) check\\n\", x, y, i);\n        //            for (int j = 0; j < es[y][x][i].size(); j++) {\n        //                edge e = es[y][x][i][j];\n        //                printf(\"(%d,%d,%d):%d \\n\", e.to.x, e.to.y, e.to.dir, e.cost);\n        //            }\n        //        }\n        //    }\n        //}\n        \n        // dijkstra\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                for (int i = 0; i < 4; i++) {\n                    dist[y][x][i] = INF;\n                    used[y][x][i] = false;\n                }\n            }\n        }\n        dist[0][0][0] = 0;\n        while (1) {\n            int v = -1, u = -1, id = -1;\n            for (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n                    for (int i = 0; i < 4; i++) {\n                        if (!used[y][x][i] && (v == -1 || dist[y][x][i] < dist[v][u][id])) {\n                            v = y; u = x; id = i;\n                        }\n                    }\n                }\n            }\n            if (v == -1) break;\n            used[v][u][id] = true;\n            for (int i = 0; i < es[v][u][id].size(); i++) {\n                edge e = es[v][u][id][i];\n                dist[e.to.y][e.to.x][e.to.dir] = min(dist[v][u][id] + e.cost, dist[e.to.y][e.to.x][e.to.dir]);\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i < 4; i++) {\n            ans = min(dist[h-1][w-1][i], ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tpair<pii,int>\tppiii;\n\nconst int inf=1<<29,dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint inst[30][30],memo[30][30][4];\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tint cost[4];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",inst[i]+j),inst[i][j];\n\t\tfor(int i=0;i<4;i++)\tscanf(\"%d\",cost+i);\n\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<4;k++)\tmemo[i][j][k]=inf;\n\n\t\tpriority_queue< pair<int,ppiii> > pq;\n\t\tpq.push(mp(0,mp(mp(0,0),0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,ppiii> a=pq.top();\tpq.pop();\n\t\t\tint nowcost=-a.first;\n\t\t\tint y=a.second.first.first;\n\t\t\tint x=a.second.first.second;\n\t\t\tint dir=a.second.second;\n\t\t\tif(y==h-1 && x==w-1)\tcontinue;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nextdir=(dir+4-i)%4;\n\t\t\t\tint yy=y+dy[nextdir],xx=x+dx[nextdir];\n\t\t\t\tif(yy<0 || h<=yy || xx<0 || w<=xx)\tcontinue;\n\n\t\t\t\tint nextcost=nowcost+(inst[y][x]==i?0:cost[i]);\n\t\t\t\tif(nextcost<memo[yy][xx][nextdir]){\n\t\t\t\t\tmemo[yy][xx][nextdir]=nextcost;\n\t\t\t\t\tpq.push(mp(-nextcost,mp(mp(yy,xx),nextdir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",min(memo[h-1][w-1][0],memo[h-1][w-1][3]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Data{\npublic:\n\tint cost;\n\tint x;\n\tint y;\n\tint dir;\n\n\tData(int cost,int x,int y,int dir){\n\t\tthis->cost = cost;\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->dir = dir;\n\t}\n\tbool operator>(const Data& d1) const{\n\t\treturn cost > d1.cost;\n\t}\n};\n\nint stage[31][31];\nint costTable[31][31][4];\nint W,H;\n\nvoid dfs(int x,int y,int dir,int* c){\n\tfor(int i=0;i<=3;i++){\n\t\tint cost = c[i];\n\t\tif(stage[y][x] == i) cost = 0;\n\n\t\tint prev = dir;\n\t\tint next = (prev+i)%4;\n\t\tint dx = x + tx[next];\n\t\tint dy = y + ty[next];\n\n\n\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\tif(costTable[dy][dx][next] > costTable[y][x][prev] + cost){\n\t\t\tcostTable[dy][dx][next] = costTable[y][x][prev] + cost;\n\t\t\tdfs(dx,dy,next,c);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d\",&W,&H)){\n\t\tif(W==H && H==0) break;\n\n\t\tmemset(costTable,0x3f,sizeof(costTable));\n\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tint c[4];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d\",c+i);\n\t\t}\n\t\t//costTable[0][0][1] = 0;\n\n\t\tpriority_queue<Data,vector<Data>,greater<Data> > que;\n\n\t\tque.push(Data(0,0,0,1));\n\n\t\twhile(!que.empty()){\n\t\t\tint sum = que.top().cost;\n\t\t\tint x = que.top().x;\n\t\t\tint y = que.top().y;\n\t\t\tint dir = que.top().dir;\n\n\t\t\tque.pop();\n\t\t\tif(costTable[y][x][dir] != 0x3f3f3f3f) continue;\n\t\t\t\n\t\t\tcostTable[y][x][dir] = sum;\n\n\t\t\tfor(int i=0;i<=3;i++){\n\t\t\t\tint cost = c[i];\n\t\t\t\tif(stage[y][x] == i) cost = 0;\n\n\t\t\t\tint prev = dir;\n\t\t\t\tint next = (prev+i)%4;\n\t\t\t\tint dx = x + tx[next];\n\t\t\t\tint dy = y + ty[next];\n\n\t\t\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\t\t\tif(costTable[dy][dx][next] == 0x3f3f3f3f){\n\t\t\t\t\t//printf(\"dx:%d dy:%d \\n\",dx,dy);\n\t\t\t\t\t//printf(\"sum:%d prev:%d next:%d\\n\",sum,prev,next);\n\t\t\t\t\t//costTable[dy][dx][next] = sum;\n\t\t\t\t\tque.push(Data(sum+cost,dx,dy,next));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t//dfs(0,0,1,c);\n\n\t\tint minv = numeric_limits<int>::max();\n\t\tfor(int i=0;i<=3;i++){\n\t\t\tminv = min(minv,costTable[H-1][W-1][i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",minv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass position\n{\npublic:\n    position(int y0, int x0, int d0){\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n    int y, x, d;\n};\n\nvoid solve(vector<vector<int> > square, vector<int> cost)\n{\n    int goalY = square.size() - 2;\n    int goalX = square[0].size() - 2;\n    multimap<int, position> mmPosition;\n    mmPosition.insert(make_pair(0, position(1,1,1)));\n    vector<vector<vector<bool> > > check(square.size(), vector<vector<bool> >(square[0].size(), vector<bool>(4, false)));\n\n    int dx[] = {0,1,0,-1};\n    int dy[] = {-1,0,1,0};\n    for(;;){\n        multimap<int, position>::iterator it = mmPosition.begin();\n        int c = it->first;\n        int y = it->second.y;\n        int x = it->second.x;\n        int d = it->second.d;\n        mmPosition.erase(it);\n        if(square[y][x] == -1 || check[y][x][d])\n            continue;\n        check[y][x][d] = true;\n        if(y == goalY && x == goalX){\n            cout << c << endl;\n            return;\n        }\n\n        for(int i=0; i<4; ++i){\n            if(i == square[y][x])\n                mmPosition.insert(make_pair(c, position(y+dy[d], x+dx[d], d)));\n            else\n                mmPosition.insert(make_pair(c+cost[i], position(y+dy[d], x+dx[d], d)));\n            (++d) %= 4;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0 && h == 0)\n            break;\n\n        vector<vector<int> > square(h+2, vector<int>(w+2, -1));\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j)\n                cin >> square[i][j];\n        }\n        vector<int> cost(4);\n        for(int i=0; i<4; ++i)\n            cin >> cost[i];\n\n        solve(square, cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "//SPFA\n#include <stdio.h>\n#include <string.h>\n#define INF (9*900)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(struct Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(struct Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(struct Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(struct Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(struct Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\nint main(){\n\tstruct Node a,b,que[INF];\n\tint head,tail;\n\tint inQ[30][30][4],dst[30][30][4];\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(dst,-1,sizeof(dst));\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\thead=tail=0;\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque[tail++]=a;\n\t\twhile(head<tail){\n\t\t\ta=que[head++];\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4];\nint hsize;\nint d[30 * 30 * 4], idx[30 * 30 * 4];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tidx[heap[i].num] = i;\n\t}\n\theap[i] = last;\n\tidx[last.num] = i;\n\n\treturn root;\n}\n\ninline void decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = idx[num]; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tidx[heap[i].num] = i;\n\t}\n\theap[i] = (PNumDis){num, d};\n\tidx[num] = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PNumDis){i, INF};\n\t\td[i] = INF;\n\t\tidx[i] = i;\n\t}\n\thsize = n;\n\n\td[s] = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tdecreaseKey(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0}, dj[4] = {0, 1, 0, -1};\n\ntypedef struct {int to, w;} Edge;\ntypedef struct {Edge *elem; int cap, size;} VecEdge;\ntypedef struct {int num, d;} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[14400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//SPFA\n#include <stdio.h>\n#include <string.h>\n#define INF (9*900)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(struct Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(struct Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(struct Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(struct Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(struct Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\nint main(){\n\tstruct Node a,b,que[INF];\n\tint head,tail;\n\tint inQ[30][30][4],dst[30][30][4];\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(dst,-1,sizeof(dst));\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\thead=tail=0;\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque[tail++]=a;\n\t\twhile(head<tail){\n\t\t\ta=que[head++];\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0)que[tail++]=b;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0)que[tail++]=b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "//SPFA\n#include <stdio.h>\n#include <string.h>\n#define INF (9*900)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(struct Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(struct Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(struct Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(struct Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(struct Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\nint main(){\n\tstruct Node a,b,que[900];\n\tint head,tail;\n\tint inQ[30][30][4],dst[30][30][4];\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(dst,-1,sizeof(dst));\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\thead=tail=0;\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque[tail++]=a;\n\t\twhile(head<tail){\n\t\t\ta=que[head++];\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0)que[tail++]=b;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0)que[tail++]=b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "//SPFA\n#include <stdio.h>\n#include <string.h>\n#define INF (9*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(struct Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(struct Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(struct Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(struct Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(struct Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\n\nint main(){\n\tstatic struct Node que[INF];\n\tstatic int inQ[30][30][4],dst[30][30][4];\n\tint head,tail;\t\n\tstruct Node a,b;\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\thead=tail=0;\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque[tail++]=a;\n\t\twhile(head<tail){\n\t\t\ta=que[head++];\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n/* 命令 */\nint STRAIGHT = 0;\nint RIGHT = 1; /* 右に90度回転し直進 */\nint BACK = 2; /* 右に180度回転し直進 */\nint LEFT = 3; /* 右に270度回転し直進 */\nint HALT = 4;\nint OUT = 5; /* 盤面外 */\n/* 各方向を向いているときの移動ベクトル (dx,dy) (北, 東, 南, 西) */\nint MOVEMENT[4][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\n/* 入力された条件 */\nint w, h, s[30][30]; /* 盤面 */\nint c[4]; /* 定められたコスト */\n\n/* 指定された座標のブロックを返す */\nint getCell(int x, int y) {\n\tif (x < 0 || x >= w || y < 0 || y >= h) return OUT;\n\treturn s[y][x];\n}\n\n/* 幅優先探索 */\nint memo[30][30][4]; /* 探索のメモ (あるマスにある向きで到達するまでの最小コスト) */\nint UNREACHED = INT_MAX;\ntypedef struct { int cost; int x; int y; int angle; } Log; /* 探索状態 */\n\n/* FIFOキュー */\ntypedef Log Data;\nData queue[2000]; int queue_size = 2000; int queue_head; int queue_length;\nvoid initqueue() {\n\tqueue_length = 0;\n}\nvoid enqueue(Data d) {\n\tqueue[(queue_head + queue_length) % queue_size] = d;\n\tqueue_length++;\n}\nData dequeue() {\n\tData d = queue[queue_head];\n\tqueue_head = (queue_head + 1) % queue_size;\n\tqueue_length--;\n\treturn d;\n}\n\n/* 幅優先探索をしてゴールのマスに到達するまでに掛かったコストを返す */\nint search(Log l) {\n\tint min = UNREACHED;\n\tint i;\n\t/* この試行が現在いるブロックまでの最短経路か確認する */\n\tif (l.cost > memo[l.y][l.x][l.angle]) return UNREACHED;\n\n\t/* 次の動作 */\n\tfor (i = 0; i < 4; i++) {\n\t\t/* 次の動作を行った場合の状態を作る */\n\t\tLog next;\n\t\tnext.angle = (l.angle + i) % 4;\n\t\tnext.x = l.x + MOVEMENT[next.angle][0];\n\t\tnext.y = l.y + MOVEMENT[next.angle][1];\n\t\tnext.cost = l.cost;\n\t\tif (i != getCell(l.x, l.y)) next.cost += c[i]; /* マスの命令に従わない場合のみコストが掛かる */\n\n\t\tint cell = getCell(next.x, next.y); /* 次に踏むマス */\n\n\t\tif (/* cell == HALT && */ next.x == w - 1 && next.y == h - 1) {\n\t\t\t/* ゴールに到達 */\n\t\t\tif (next.cost < min) min = next.cost;\n\t\t} else if (cell == OUT) {\n\t\t\t/* 盤面外に前進し失格 */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* 次に探索する状態をキューに入れる */\n\t\t\tif (next.cost < memo[next.y][next.x][next.angle]) {\n\t\t\t\tmemo[next.y][next.x][next.angle] = next.cost;\n\t\t\t\tenqueue(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min;\n}\n\nint main(void) {\n\tint min, i, j, k;\n\n\t/* データセット毎の処理 */\n\twhile (scanf(\"%d%d\", &w, &h) == 2 && w > 0 && h > 0) {\n\t\t/* 各マスに割り当てられた命令を読み込む */\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) {\n\t\t\tscanf(\"%d\", &s[i][j]);\n\n\t\t\t/* メモを初期化する */\n\t\t\tfor (k = 0; k < 4; k++) memo[i][j][k] = UNREACHED;\n\t\t}\n\t\t/* コストを読み込む */\n\t\tfor (i = 0; i < 4; i++) scanf(\"%d\", &c[i]);\n\n\t\t/* 探索の始点をキューに入れる */\n\t\tLog l = {0, 0, 0, 1}; /* 北西隅のマスで東向き */\n\t\tenqueue(l);\n\n\t\t/* 幅優先探索する */\n\t\tmin = UNREACHED;\n\t\twhile (queue_length > 0) {\n\t\t\tint cost = search(dequeue());\n\t\t\tif (cost < min) min = cost;\n\t\t}\n\n\t\t/* 結果を出力する */\n\t\tprintf(\"%d\\n\", min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\t// if (field[fromP.num / 4 / w][fromP.num / 4 % w] == 4)\n\t\t// \tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//SPFA\n#include <stdio.h>\n#include <string.h>\n#define INF (10*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(struct Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(struct Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(struct Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(struct Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(struct Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\n\nint main(){\n\tstatic struct Node que[100000];\n\tint inQ[30][30][4],dst[30][30][4];\n\tint head,tail;\t\n\tstruct Node a,b;\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\thead=tail=0;\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque[tail++]=a;\n\t\twhile(head<tail){\n\t\t\ta=que[head++];\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint main(){\n  int Y[]={-1,0,1,0};\n  int X[]={0,1,0,-1};\n  int dp[4][40][40],w,h,i,j,k,l,mi,mj,mk,min,d[40][40],m,ny,nx,c[4];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int f[4][40][40]={0};\n    for(i=0;i<4;i++){\n      for(j=0;j<40;j++){\n\tfor(k=0;k<40;k++)dp[i][j][k]=M;\n      }\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)scanf(\"%d\",&d[i][j]);\n    }\n    for(i=0;i<4;i++)scanf(\"%d\",&c[i]);\n    dp[1][1][1]=0;\n    for(l=0;l<4*w*h;l++){\n      min=2000000000;\n      for(i=0;i<4;i++){\n\tfor(j=1;j<=h;j++){\n\t  for(k=1;k<=w;k++){\n\t    if(f[i][j][k])continue;\n\t    if(min>dp[i][j][k])min=dp[mi=i][mj=j][mk=k];\n\t  }\n\t}\n      }\n      f[mi][mj][mk]=1;\n      if(d[mj][mk]-4){\n\tm=(mi+d[mj][mk]+4)%4;\n\tny=mj+Y[m];\n\tnx=mk+X[m];\n\tif(dp[m][ny][nx]>dp[mi][mj][mk])dp[m][ny][nx]=dp[mi][mj][mk];\n      }\n      for(i=0;i<4;i++){\n\tny=mj+Y[(mi+i)%4];\n\tnx=mk+X[(mi+i)%4];\n\tif(dp[i][ny][nx]>dp[mi][mj][mk]+c[i])dp[i][ny][nx]=dp[mi][mj][mk]+c[i];\n      }\n    }\n    min=M;\n    for(i=0;i<4;i++){\n      if(min>dp[i][h][w])min=dp[i][h][w];\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0}, dj[4] = {0, 1, 0, -1};\n\ntypedef struct {int to, w;} Edge;\ntypedef struct {Edge *elem; int cap, size;} VecEdge;\ntypedef struct {int num, d;} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[14400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[65536];\nPNumDis heap[1048576];\nint hsize;\nint d[65536];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint n, t[16][17];\n\tint v;\n\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfor (j = 0; j <= n; j++)\n\t\t\t\tscanf(\"%d\", t[i] + j);\n\n\t\tv = 1;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tv <<= 1;\n\n\t\tinit(v);\n\t\tfor (i = 0; i < v - 1; i++)\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\tif (!(i & 1 << j)) {\n\t\t\t\t\tint min = t[j][0];\n\t\t\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\t\t\tif (i & 1 << k)\n\t\t\t\t\t\t\tmin = min(min, t[j][k + 1]);\n\t\t\t\t\tadd(i, i | 1 << j, min);\n\t\t\t\t}\n\n\t\tdijkstra(v, 0);\n\n\t\tprintf(\"%d\\n\", d[v - 1]);\n\n\t\tfreeAll(v);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint main(){\n  int Y[]={-1,0,1,0};\n  int X[]={0,1,0,-1};\n  int dp[4][40][40],w,h,i,j,k,l,mi,mj,mk,min,d[40][40],m,ny,nx,c[4];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int f[4][40][40]={0};\n    for(i=0;i<4;i++){\n      for(j=0;j<40;j++){\n\tfor(k=0;k<40;k++)dp[i][j][k]=M;\n      }\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)scanf(\"%d\",&d[i][j]);\n    }\n    for(i=0;i<4;i++)scanf(\"%d\",&c[i]);\n    dp[1][1][1]=0;\n    for(l=0;l<4*w*h;l++){\n      min=2000000000;\n      for(i=0;i<4;i++){\n\tfor(j=1;j<=h;j++){\n\t  for(k=1;k<=w;k++){\n\t    if(f[i][j][k])continue;\n\t    if(min>dp[i][j][k])min=dp[mi=i][mj=j][mk=k];\n\t  }\n\t}\n      }\n      f[mi][mj][mk]=1;\n      if(d[mj][mk]-4){\n\tm=(mi+d[mj][mk]+4)%4;\n\tny=mj+Y[m];\n\tnx=mk+X[m];\n\tif(dp[m][ny][nx]>dp[mi][mj][mk])dp[m][ny][nx]=dp[mi][mj][mk];\n      }\n      for(i=0;i<4;i++){\n\tny=mj+Y[(mi+i)%4];\n\tnx=mk+X[(mi+i)%4];\n\tif(dp[(mi+i)%4][ny][nx]>dp[mi][mj][mk]+c[i])\n\t   dp[(mi+i)%4][ny][nx]=dp[mi][mj][mk]+c[i];\n      }\n    }\n    min=M;\n    for(i=0;i<4;i++){\n      if(min>dp[i][h][w])min=dp[i][h][w];\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nclass S{\npublic:\n  int y, x, d, cost;\n  S(){}\n  S(int y, int x, int d, int cost) : y(y), x(x), d(d), cost(cost) {}\n};\n\nint h, w;\nint map[30][30];\nint cost[4];\nint vis[30][30][4];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool check(int y, int x){\n  if(y<0 || y>=h) return false;\n  if(x<0 || x>=w) return false;\n  return true;\n}\n\nint solve(){\n  S u, v;\n  queue<S> q;\n  q.push(S(0, 0, 1, 0));\n  fill(vis[0][0], vis[30][0], INF);\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    if(map[u.y][u.x] != 4){\n      v.d = (u.d+map[u.y][u.x])%4;\n      v.y = u.y + dy[v.d];\n      v.x = u.x + dx[v.d];\n      v.cost = u.cost;\n      if(check(v.y, v.x) && vis[v.y][v.x][v.d] > v.cost){\n        vis[v.y][v.x][v.d] = v.cost;\n        q.push(v);\n      }\n    }\n    for(int i=0;i<4;i++){\n      v.d = (u.d+i) % 4;\n      v.y = u.y + dy[v.d];\n      v.x = u.x + dx[v.d];\n      v.cost = u.cost + cost[i];\n      if(check(v.y, v.x) && vis[v.y][v.x][v.d] > v.cost){\n        vis[v.y][v.x][v.d] = v.cost;\n        q.push(v);\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++) res = min(res, vis[h-1][w-1][i]);\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (h|w)){\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> map[i][j];\n    for(int i=0;i<4;i++) cin >> cost[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PNumDis;\n\ntypedef struct {\n\tint d;\n\tint idx;\n} Node;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4];\nint hsize;\nNode node[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = last;\n\tnode[last.num].idx = i;\n\n\treturn root;\n}\n\ninline void decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = node[num].idx; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = (PNumDis){num, d};\n\tnode[num].idx = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PNumDis){i, INF};\n\t\tnode[i] = (Node){INF, i};\n\t}\n\thsize = n;\n\n\tnode[s].d = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < node[e.to].d) {\n\t\t\t\tnode[e.to].d = fromP.d + e.w;\n\t\t\t\tdecreaseKey(e.to, node[e.to].d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(node[(h - 1) * w * 4 + (w - 1) * 4 + 1].d, node[(h - 1) * w * 4 + (w - 1) * 4 + 2].d));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0}, dj[4] = {0, 1, 0, -1};\n\ntypedef struct {int to, w;} Edge;\ntypedef struct {Edge *elem; int cap, size;} VecEdge;\ntypedef struct {int num, d;} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[14400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tPNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tEdge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[65536];\nPNumDis heap[1048576];\nint hsize;\nint d[65536];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint n, t[16][17];\n\tint v;\n\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfor (j = 0; j <= n; j++)\n\t\t\t\tscanf(\"%d\", t[i] + j);\n\n\t\tv = 1;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tv <<= 1;\n\n\t\tinit(v);\n\t\tfor (i = 0; i < v - 1; i++)\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\tif (!(i & 1 << j)) {\n\t\t\t\t\tint min = t[j][0];\n\t\t\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\t\t\tif (i & 1 << k)\n\t\t\t\t\t\t\tmin = min(min, t[j][k + 1]);\n\t\t\t\t\tadd(i, i | 1 << j, min);\n\t\t\t\t}\n\n\t\tdijkstra(v, 0);\n\n\t\tprintf(\"%d\\n\", d[v - 1]);\n\n\t\tfreeAll(v);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//SPFA\n#include <stdio.h>\n#include <string.h>\n#define INF (9*900*4)\n#define rep(i,n) for(i=0;i<(n);i++)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct Node{\n\tint y,x,dir;\n};\n\nvoid _a(struct Node *a){a->y+=dy[a->dir];a->x+=dx[a->dir];}\nvoid _b(struct Node *a){a->dir=(a->dir+1)%4;_a(a);}\nvoid _c(struct Node *a){a->dir=(a->dir+2)%4;_a(a);}\nvoid _d(struct Node *a){a->dir=(a->dir-1+4)%4;_a(a);}\nvoid _e(struct Node *a){}\nvoid (*action[5])(struct Node *)={_a,_b,_c,_d,_e};\n\nint in(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\nint main(){\n\tstruct Node a,b,que[INF];\n\tint head,tail;\n\tint inQ[30][30][4],dst[30][30][4];\n\t\n\tint w,h,s[30][30],c[4];\n\tint i,j,k,ans;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w||h)){\n\t\trep(i,h)\n\t\t\trep(j,w)scanf(\"%d\",&s[i][j]);\n\t\trep(i,4)scanf(\"%d\",c+i);\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\trep(i,h)rep(j,w)rep(k,4)dst[i][j][k]=INF;\n\t\ta.y=a.x=a.dir=0;\n\t\thead=tail=0;\n\t\tdst[a.y][a.x][a.dir]=0;\n\t\tque[tail++]=a;\n\t\twhile(head<tail){\n\t\t\ta=que[head++];\n\t\t\tinQ[a.y][a.x][a.dir]=0;\n\t\t\tb=a;\n\t\t\taction[s[b.y][b.x]](&b);\n\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir] < dst[b.y][b.x][b.dir]){\n\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir];\n\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tb=a;\n\t\t\t\taction[i](&b);\n\t\t\t\tif(in(b.y,b.x,h,w) && dst[a.y][a.x][a.dir]+c[i] < dst[b.y][b.x][b.dir]){\n\t\t\t\t\tdst[b.y][b.x][b.dir] = dst[a.y][a.x][a.dir]+c[i];\n\t\t\t\t\tif(inQ[b.y][b.x][b.dir]==0){\n\t\t\t\t\t\tque[tail++]=b;\n\t\t\t\t\t\tinQ[b.y][b.x][b.dir]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=INF;\n\t\trep(i,4){\n\t\t\tif(dst[h-1][w-1][i] < ans)ans = dst[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0}, dj[4] = {0, 1, 0, -1};\n\ntypedef struct {int to, w;} Edge;\ntypedef struct {Edge *elem; int cap, size;} VecEdge;\ntypedef struct {int num, d;} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[14400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30], c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<map>\n#define INF 1000000000\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nint w,h;\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nbool inf(int y,int x){\n\tif(x>=0&&x<w&&y>=0&&y<h)\n\t\treturn true;\n\treturn false;\n}\nint dij(vector<vector<int> > f, vector<int> op){\n\tpriority_queue<PPP,vector<PPP> , greater<PPP> > que;\n\tint d[40][40][5];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++)\n\td[i][j][k]=INF;\n\tque.push(PPP(0,PP(1,P(0,0))));\n\td[0][0][1]=0;\n\twhile(!que.empty()){\n\t\tPPP p=que.top();\n\t\tint dit=p.second.first;\n\t\tP now=p.second.second;\n\t\tint nc=p.first;\n\t\tque.pop();\n\t\tif(d[now.first][now.second][dit]<nc){\n\t\t\tcontinue;\n\t\t}\n\t\tif(now.first==h-1&&now.second==w-1){\n\t\t\treturn nc;\n\t\t}\n\t\td[now.first][now.second][dit]=nc;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=dx[(i+dit)%4]+now.second,ny=dy[(i+dit)%4]+now.first;\n\t\t\tif(!inf(ny,nx))\n\t\t\t\tcontinue;\n\t\t\tif(f[now.first][now.second]==i&&nc<d[ny][nx][(i+dit)%4]){\n\t\t\t\tque.push(PPP(nc,PP((i+dit)%4,P(ny,nx))));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nc+op[i]<d[ny][nx][(i+dit)%4]){\n\t\t\t\tque.push(PPP(nc+op[i],PP((i+dit)%4,P(ny,nx))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t//return d[h-1][w-1][(i+dit)%4];\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tvector<vector<int> > f(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>f[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<int> op(4);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tcin>>op[i];\n\t\tcout<<dij(f,op)<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nint di[4] = {-1, 0, 1, 0}, dj[4] = {0, 1, 0, -1};\n\ntypedef struct {int to, w;} Edge;\ntypedef struct {Edge *elem; int cap, size;} VecEdge;\ntypedef struct {int num, d;} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[14400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tPNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tPNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tEdge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4];\nint hsize;\nint d[30 * 30 * 4], idx[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tidx[heap[i].num] = i;\n\t}\n\theap[i] = last;\n\tidx[last.num] = i;\n\n\treturn root;\n}\n\ninline void decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = idx[num]; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tidx[heap[i].num] = i;\n\t}\n\theap[i] = (PNumDis){num, d};\n\tidx[num] = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PNumDis){i, INF};\n\t\td[i] = INF;\n\t\tidx[i] = i;\n\t}\n\thsize = n;\n\n\td[s] = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tdecreaseKey(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 99999999\n#define N 10000000\n#define min(x,y) (x<y)?(x):(y)\ntypedef struct{\n    int w; int h; int dir;\n}Data;\nData queue[N];\nint head,num;\nvoid enqueue(int w,int h,int dir){\n    if(num<N){\n        queue[(head+num)%N].w=w;\n        queue[(head+num)%N].h=h;\n        queue[(head+num)%N].dir=dir;\n        num++;\n    }\n    else{\n        printf(\"エラー\\n\");\n        exit(1);\n    }\n}\nData dequeue(const int cost[31][31][4]){\n    int index=head;\n    int min=cost[queue[head].h][queue[head].w][queue[head].dir];\n    for(int i=head+1;i<head+num;i++){\n        if(min>cost[queue[i%N].h][queue[i%N].w][queue[i%N].dir]){\n            min=cost[queue[i%N].h][queue[i%N].w][queue[i%N].dir];\n            index=i%N;\n        }\n    }\n    Data tmp=queue[head]; queue[head]=queue[index]; queue[index]=tmp;\n    Data d={-1,-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nvoid direction(int x){\n    int tmpx,tmpy;\n    switch(x){\n        case 0: break;\n        case 1:\n            tmpx=dx[0]; tmpy=dy[0];\n            for(int i=0;i<3;i++) dx[i]=dx[i+1],dy[i]=dy[i+1];\n            dx[3]=tmpx; dy[3]=tmpy; break;\n        case 2:\n            for(int i=0;i<4;i++) dx[i]=-dx[i],dy[i]=-dy[i];\n            break;\n        case 3:\n            tmpx=dx[3]; tmpy=dy[3];\n            for(int i=3;i>0;i--) dx[i]=dx[i-1],dy[i]=dy[i-1];\n            dx[0]=tmpx; dy[0]=tmpy; break;\n    }\n}\nint main(void){\n    while(1){\n        head=num=0;\n        int w,h;\n        int cost[31][31][4];\n        rep(i,31) rep(j,31) rep(k,4) cost[i][j][k]=INF;\n        Data tmp;\n        scanf(\"%d%d\",&w,&h);\n        if(w+h==0) break;\n        int s[31][31]={0};\n        int c[4];\n        //int used[31][31][4]={0};\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                scanf(\"%d\",&s[i][j]);\n            }\n        }\n        for(int i=0;i<4;i++) scanf(\"%d\",&c[i]);\n        enqueue(1,1,0); cost[1][1][0]=0;\n        while(1){\n            tmp=dequeue(cost);\n            dx[0]=1; dx[1]=0; dx[2]=-1; dx[3]=0;\n            dy[0]=0; dy[1]=1; dy[2]=0;  dy[3]=-1;\n            int wi=tmp.w,hi=tmp.h,diri=tmp.dir;\n            //printf(\"h:%d w:%d d:%d cost:%d\\n\",hi,wi,diri,cost[hi][wi][diri]);\n            direction(diri);\n            if(wi==-1) break;\n            for(int i=0;i<4;i++){\n                int tmph=hi+dy[i],tmpw=wi+dx[i],tmpd=(diri+i)%4;\n                if(tmph<1||tmph>h||tmpw<1||tmpw>w) continue;\n                if(i==s[hi][wi]){\n                    if(cost[tmph][tmpw][tmpd]>cost[hi][wi][diri]){\n                        if(tmph!=h||tmpw!=w)\n                            enqueue(tmpw,tmph,tmpd);\n                        cost[tmph][tmpw][tmpd]=cost[hi][wi][diri];\n                    }\n                }\n                else{\n                    if(cost[tmph][tmpw][tmpd]>cost[hi][wi][diri]+c[i]){\n                        if(tmph!=h||tmpw!=w)\n                            enqueue(tmpw,tmph,tmpd);\n                        cost[tmph][tmpw][tmpd]=cost[hi][wi][diri]+c[i];\n                    }\n                }\n            }\n        }\n        /*for(int d=0;d<4;d++){\n         for(int i=1;i<=h;i++){\n         for(int j=1;j<=w;j++){\n         printf(\"%3d \",cost[i][j][d]);\n         }puts(\"\");\n         }puts(\"\");\n         }*/\n        printf(\"%d\\n\",min(cost[h][w][0],cost[h][w][1]));\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4];\nint hsize;\nint d[30 * 30 * 4], idx[30 * 30 * 4];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tidx[heap[i].num] = i;\n\t}\n\theap[i] = last;\n\tidx[last.num] = i;\n\n\treturn root;\n}\n\ninline void decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = idx[num]; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tidx[heap[i].num] = i;\n\t}\n\theap[i] = (PNumDis){num, d};\n\tidx[num] = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PNumDis){i, INF};\n\t\td[i] = INF;\n\t\tidx[i] = i;\n\t}\n\thsize = n;\n\n\td[s] = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tdecreaseKey(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint w, h;\nint s[35][35];\nint c[4];\nint vx[4][4] = {{1, 0, -1, 0}, {0, 1, 0, -1}, {-1, 0, 1, 0}, {0, -1, 0, 1}};\nint vy[4][4] = {{0, 1, 0, -1}, {-1, 0, 1, 0}, {0, -1, 0, 1}, {1, 0, -1, 0}};\nint vv[4][4] = {{0, 3, 2, 1}, {1, 0, 3, 2}, {2, 1, 0, 3}, {3, 2, 1, 0}};\n\nclass robot {\n\tpublic :\n\t\tint x;\n\t\tint y;\n\t\tint v; // 向き\n\t\tint c;\n\n\t\trobot() {\n\t\t\tx = 0; y = 0; v = 0; c = 0;\n\t\t}\n\n\t\tbool operator<(const robot& other) const{\n\t\t\treturn c > other.c;\n\t\t}\n\n\t\tbool operator>(const robot& other) const{\n\t\t\treturn c < other.c;\n\t\t}\n\n\t\tbool next(int o) {\n\t\t\tif(o != s[y][x])\n\t\t\t\tc += ::c[o];\n\t\t\tx += vx[v][o];\n\t\t\ty += vy[v][o];\n\t\t\tv = vv[v][o];\n\n\t\t\tif(x < 0 || y < 0 || x >= w || y >= h)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n}; \n\nbool input() {\n\tcin >> w >> h;\n\tif(w == 0 && h == 0)\n\t\treturn 0;\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++)\n\t\tcin >> c[i];\n\n\treturn 1;\n}\n\nint solve(void) {\n\tpriority_queue<robot> q;\n\tint use[35][35][4];\n\tmemset(use, -1, 35 * 35 * 4 * sizeof(int));\n\n\tq.push(robot());\n\twhile(!q.empty()) {\n\t\trobot now = q.top();\n\t\tq.pop();\n\n\t\tif(use[now.x][now.y][now.v] == -1) {\n\t\t\tuse[now.x][now.y][now.v] = now.c;\n\t\t}\n\n\t\telse\n\t\t\tcontinue;\n\n\t\tif(now.x == w - 1 && now.y == h - 1){\n\t\t\treturn now.c;\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\trobot temp = now;\n\t\t\tif(temp.next(i)){\n\t\t\t\t\tq.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void) {\n\twhile(input()){\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 100000000\n\n#define DIR_UP\t\t0\n#define DIR_RIGHT\t1\n#define DIR_DOWN\t2\n#define DIR_LEFT\t3\n\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={-1,0,1,0};\n\n/* [y][x[dir]][next_dir] */\nint node_cost[30][30][4];\nint node_rinsetu_cost[30][30][4][4];\nint kakutei[30][30][4];\n\nint w,h;\nint board[30][30];\nint c[4];\n\nint getboard(int y,int x) {\n\tif(y<0 || y>=h || x<0 || x>=w)return 5;\n\treturn board[y][x];\n}\n\nint main(void) {\n\tint i,j,k,l;\n\tint nx,ny,nd;\n\tint ans;\n\tfor(;;) {\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tfor(i=0;i<h;i++) {\n\t\t\tfor(j=0;j<w;j++)scanf(\"%d\",&board[i][j]);\n\t\t}\n\t\tfor(i=0;i<4;i++)scanf(\"%d\",&c[i]);\n\t\tfor(i=0;i<h;i++) {\n\t\t\tfor(j=0;j<w;j++) {\n\t\t\t\tfor(k=0;k<4;k++) {\n\t\t\t\t\tnode_rinsetu_cost[i][j][k][k]=c[0];\n\t\t\t\t\tnode_rinsetu_cost[i][j][k][(k+1)%4]=c[1];\n\t\t\t\t\tnode_rinsetu_cost[i][j][k][(k+2)%4]=c[2];\n\t\t\t\t\tnode_rinsetu_cost[i][j][k][(k+3)%4]=c[3];\n\t\t\t\t\tif(board[i][j]!=4) {\n\t\t\t\t\t\tnode_rinsetu_cost[i][j][k][(k+board[i][j])%4]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<h;i++) {\n\t\t\tfor(j=0;j<w;j++) {\n\t\t\t\tfor(k=0;k<4;k++) {\n\t\t\t\t\tnode_cost[i][j][k]=INF;\n\t\t\t\t\tkakutei[i][j][k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnode_cost[0][0][DIR_RIGHT]=0;\n\t\tnx=ny=0;nd=DIR_RIGHT;\n\t\tkakutei[0][0][DIR_RIGHT]=1;\n\t\tfor(i=0;i<w*h*4;i++) {\n\t\t\tint mincost=INF;\n\t\t\tfor(j=0;j<4;j++) {\n\t\t\t\tif(getboard(ny+dy[j],nx+dx[j])!=5) {\n\t\t\t\t\tif(node_cost[ny+dy[j]][nx+dx[j]][j]>\n\t\t\t\t\t\t\tnode_cost[ny][nx][nd]+node_rinsetu_cost[ny][nx][nd][j]) {\n\t\t\t\t\t\tnode_cost[ny+dy[j]][nx+dx[j]][j]=\n\t\t\t\t\t\t\tnode_cost[ny][nx][nd]+node_rinsetu_cost[ny][nx][nd][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<h;j++) {\n\t\t\t\tfor(k=0;k<w;k++) {\n\t\t\t\t\tfor(l=0;l<4;l++) {\n\t\t\t\t\t\tif(!kakutei[j][k][l] && node_cost[j][k][l]<mincost) {\n\t\t\t\t\t\t\tny=j;\n\t\t\t\t\t\t\tnx=k;\n\t\t\t\t\t\t\tnd=l;\n\t\t\t\t\t\t\tmincost=node_cost[j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tkakutei[ny][nx][nd]=1;\n\t\t}\n\t\tans=INF;\n\t\tfor(i=0;i<4;i++) {\n\t\t\tif(node_cost[h-1][w-1][i]<ans)ans=node_cost[h-1][w-1][i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1156: Twirling Robot\n// 2017.9.18 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 10000\ntypedef struct { int t, a, b, c; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n  int l, r;\n  int min;\n\n  l = LEFT(i), r = RIGHT(i);\n  if (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n  if (r < qsize && que[r].t < que[min].t) min = r;\n  if (min != i) {\n    QUE t = que[i]; que[i] = que[min]; que[min] = t;\n    min_heapify(min);\n  }\n}\n\nint deq(int *a, int *b, int *c)\n{\n  if (qsize == 0) return 0;\n  *a = que[0].a, *b = que[0].b, *c = que[0].c;\n  que[0] = que[--qsize];\n  min_heapify(0);\n  return 1;\n}\n\nvoid enq(int t, int a, int b, int c)\n{\n  int i, ii;\n\n  i = qsize++;\n  que[i].t = t, que[i].a = a, que[i].b = b, que[i].c = c;\n  while (i > 0 && que[ii = PARENT(i)].t > que[i].t) {\n    QUE tt = que[i]; que[i] = que[ii]; que[ii] = tt;\n    i = ii;\n  }\n}\n\nchar map[32][32]; int h, w;\nint node[32][32][4];\nint cost[4];\nint mv[4][2] = {{-1,0,},{0,1},{1,0},{0,-1}};\n\nint search()\n{\n\tint i, r, c, d, r2, c2, d2;\n\tint t;\n\n\tqsize = 0;\n\tmemset(node, -1, sizeof(node)); node[0][0][1] = 0;\n\tenq(0, 0, 0, 1);\n\twhile(deq(&r, &c, &d)) {\n\t\tif (r == h-1 && c == w-1) break;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\td2 = (d+i) % 4, r2 = r + mv[d2][0], c2 = c + mv[d2][1];\n\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\tt = node[r][c][d] + ((map[r][c] == i) ? 0 : cost[i]);\n\t\t\tif (node[r2][c2][d2] < 0 || t < node[r2][c2][d2])\n\t\t\t\tnode[r2][c2][d2] = t, enq(t, r2, c2, d2);\n\t\t}\n\t}\n\treturn node[h-1][w-1][d]; \n}\n\nint main()\n{\n\tint i, r, c, a;\n\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &a), map[r][c] = a;\n\t\tfor (i = 0; i < 4; i++) scanf(\"%d\", cost+i);\n\t\tprintf(\"%d\\n\", search());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nint di[4] = {-1, 0, 1, 0}, dj[4] = {0, 1, 0, -1};\n\ntypedef struct {int to, w;} Edge;\ntypedef struct {Edge *elem; int cap, size;} VecEdge;\ntypedef struct {int num, d;} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[14400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tPNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tPNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tEdge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint s[30][30];\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", s[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == s[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[30 * 30 * 4];\nPNumDis heap[30 * 30 * 4 * 4];\nint hsize;\nint d[30 * 30 * 4];\n\nint w, h;\nint field[30][30];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k, l;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint c[4];\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\"%d\", field[i] + j);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tscanf(\"%d\", c + i);\n\n\t\tinit(h * w * 4);\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tfor (l = 0; l < 4; l++) {\n\t\t\t\t\t\tint nd = k + l & 3;\n\t\t\t\t\t\tint ni = i + di[nd], nj = j + dj[nd];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\t\t\t\tadd(i * w * 4 + j * 4 + k, ni * w * 4 + nj * 4 + nd, l == field[i][j] ? 0 : c[l]);\n\t\t\t\t\t}\n\n\t\tdijkstra(h * w * 4, 1);\n\n\t\tprintf(\"%d\\n\", min(d[(h - 1) * w * 4 + (w - 1) * 4 + 1], d[(h - 1) * w * 4 + (w - 1) * 4 + 2]));\n\n\t\tfreeAll(h * w * 4);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\t\n\tclass State implements Comparable<State>{\n\t\tint x,y,dir,cost;\n\n\t\tpublic State(int x, int y,int dir, int cost) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.dir = dir;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", dir=\" + dir + \", cost=\"\n\t\t\t\t\t+ cost + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tint [][] data = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint [] costT = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tcostT[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(0, 0, 1, 0));\n\t\t\tint [][][] close = new int[h][w][4];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[0][0][1] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.x == w - 1 && now.y == h - 1){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sign = data[now.y][now.x];\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint ndir = (now.dir + i) % 4;\n\t\t\t\t\tint xx = now.x + vx[ndir];\n\t\t\t\t\tint yy = now.y + vy[ndir];\n\t\t\t\t\tif(isOK(xx,yy, w,h)){\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tif(sign != i){\n\t\t\t\t\t\t\tnextcost += costT[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(close[yy][xx][ndir] <= nextcost) continue;\n\t\t\t\t\t\topen.add(new State(xx, yy, ndir, nextcost));\n\t\t\t\t\t\tclose[yy][xx][ndir] = nextcost;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t}\n\tprivate boolean isOK(int xx, int yy, int w, int h) {\n\t\treturn (0 <= xx && xx < w && 0 <= yy && yy < h);\n\t}\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint n, m;\n\tint[][][] dp;\n\tint[][] map;\n\tint[] cost;\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, 1, 0, -1};\n\t\n\tvoid dijkstra(int dir, int x, int y) {\n\t\tif (dp[dir][y][x] == -1) return;\n\t\t//debug(dir);\n\t\tint order = map[y-1][x-1];\n\t\tint go = (order == 4) ? -1 : (order + dir) % 4;\n\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\tint nx = x + vx[i], ny = y + vy[i];\n\t\t\tint c = (go == i) ? 0 : cost[(dir - i + 4) % 4];\n\t\t\tif (dp[dir][y][x] != Integer.MAX_VALUE && dp[i][ny][nx] > dp[dir][y][x] + c) {\n\t\t\t\tdp[i][ny][nx] = dp[dir][y][x] + c;\n\t\t\t\tdijkstra(i, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tm = in.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\n\t\t\tmap = new int[m][n];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost = new int[4];\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tcost[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdp = new int[4][m+2][n+2];\t\t\t\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dp[i][j].length; k++) {\n\t\t\t\t\t\tif (j == 0 || j == m + 1 || k == 0 || k == n + 1) \n\t\t\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tdp[0][1][1] = 0;\n\t\t\tdijkstra(0, 1, 1);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t//debug(i);\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tres = Math.min(res, dp[i][m][n]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(int i) {\n\t\tSystem.out.println(\"dir = \" + i);\n\t\tfor (int j = 1; j < dp[i].length - 1; j++) {\n\t\t\tfor (int k = 1; k < dp[i][j].length - 1; k++) {\n\t\t\t\tSystem.out.print((dp[i][j][k] == Integer.MAX_VALUE ? \"F\" : dp[i][j][k]) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint cost,pose, x, y;\n\t\t\n\t\tpublic Walk(int cost, int pose, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.cost = cost;\n\t\t\tthis.pose = pose;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][] is_visited = new boolean[h][w][4];\n\t\t\t\n\t\t\tint[] ops = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tops[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[][] st = {\n\t\t\t\t\t{1,0},\n\t\t\t\t\t{0,-1},\n\t\t\t\t\t{-1,0},\n\t\t\t\t\t{0,1}\n\t\t\t};\n\t\t\t\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(0, 0, 0, 0));\n\t\t\t\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk wa = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(wa.x + \" \" + wa.y + \" \" + wa.cost);\n\t\t\t\t\n\t\t\t\tif(wa.x >= w || wa.x < 0 || wa.y >= h || wa.y < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_visited[wa.y][wa.x][wa.pose]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[wa.y][wa.x][wa.pose] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(wa.y == h-1 && wa.x == w-1){\n\t\t\t\t\tSystem.out.println(wa.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint cost = map[wa.y][wa.x] == i ? 0 : ops[i];\n\t\t\t\t\t\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tqueue.add(new Walk(wa.cost + cost, wa.pose, wa.x + st[wa.pose][0], wa.y + st[wa.pose][1]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tqueue.add(new Walk(wa.cost + cost, (wa.pose + 3) % 4, wa.x + st[(wa.pose + 3) % 4][0], wa.y + st[(wa.pose + 3) % 4][1]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tqueue.add(new Walk(wa.cost + cost, (wa.pose + 2) % 4, wa.x + st[(wa.pose + 2) % 4][0], wa.y + st[(wa.pose + 2) % 4][1]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tqueue.add(new Walk(wa.cost + cost, (wa.pose + 1) % 4, wa.x + st[(wa.pose + 1) % 4][0], wa.y + st[(wa.pose + 1) % 4][1]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic class State implements Comparable <State>{\n\t\tint dist, y, x, dir;\n\t\tState(int dist, int y, int x, int dir){\n\t\t\tthis.dist=dist;\n\t\t\tthis.y=y;\n\t\t\tthis.x=x;\n\t\t\tthis.dir=dir;\n\t\t}\n\t\tpublic int compareTo(State s) {\n\t\t\treturn this.dist-s.dist;\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tif(w==0) break;\n\t\t\t\tint inf=100000000;\n\t\t\t\tint[][] board=new int[h][w];\n\t\t\t\tint[] cost=new int[5];//命令に払うcost\n\t\t\t\tint[] dy= {0, 1, 0, -1};//進む方向\n\t\t\t\tint[] dx= {1, 0, -1, 0};\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tboard[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\tcost[i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint[][][] d=new int[h][w][5];//座標と向き\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\t\td[i][j][k]=inf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPriorityQueue<State> pq=new PriorityQueue<State>();\n\t\t\t\tpq.add(new State(0, 0, 0, 0));\n\t\t\t\twhile(! pq.isEmpty()) {\n\t\t\t\t\tState p=pq.poll();\n\t\t\t\t\tif(p.y==h-1 && p.x==w-1) {\n\t\t\t\t\t\tSystem.out.println(p.dist);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(d[p.y][p.x][p.dir]!=inf) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td[p.y][p.x][p.dir]=p.dist;\n\t\t\t\t\t//System.out.println(\"p.dir=\"+p.dir);\n\t\t\t\t\tfor(int k=0; k<4; k++) {//向きを全方向やる\n\t\t\t\t\t\tint ndir=(p.dir+k)%4;\n\t\t\t\t\t\tint ny=p.y+dy[ndir], nx=p.x+dx[ndir];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && d[ny][nx][ndir]==inf) {\n\t\t\t\t\t\t\tint ndist=p.dist+(board[p.y][p.x]==k ? 0:cost[k]);\n\t\t\t\t\t\t\t//System.out.println(\"ndist=\"+ndist+\" ny=\"+ny+\" nx=\"+nx+\" ndir=\"+ndir);\n\t\t\t\t\t\t\tpq.add(new State(ndist, ny, nx, ndir));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "// Twirling Robot\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\tint[] dy = { -1, 0, 1, 0 };\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] field = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\tint[] command = new int[4];\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\tcommand[i] = sc.nextInt();\n\t\t\tint[][][] costs = new int[4][h][w];\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tArrays.fill(costs[k][i], -1);\n\t\t\tPriorityQueue<Node> queue = new PriorityQueue<Node>();\n\t\t\tqueue.add(new Node(0, 0, 0, 'E'));\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tNode node = queue.poll();\n\t\t\t\tint x = node.x;\n\t\t\t\tint y = node.y;\n\t\t\t\tint cost = node.cost;\n\t\t\t\tif (node.dir == 'N') {\n\t\t\t\t\tif (costs[0][y][x] >= 0 && costs[0][y][x] <= cost)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcosts[0][y][x] = cost;\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint tcost = cost;\n\t\t\t\t\t\tif (field[y][x] != i)\n\t\t\t\t\t\t\ttcost += command[i];\n\t\t\t\t\t\tint tx = x + dx[i];\n\t\t\t\t\t\tint ty = y + dy[i];\n\t\t\t\t\t\tif (tx >= 0 && tx < w && ty >= 0 && ty < h)\n\t\t\t\t\t\t\tswitch (i) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'N'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'E'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'S'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'W'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (node.dir == 'E') {\n\t\t\t\t\tif (costs[1][y][x] >= 0 && costs[1][y][x] <= cost)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcosts[1][y][x] = cost;\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint tcost = cost;\n\t\t\t\t\t\tif (field[y][x] != i)\n\t\t\t\t\t\t\ttcost += command[i];\n\t\t\t\t\t\tint tx = x + dx[(1 + i) % 4];\n\t\t\t\t\t\tint ty = y + dy[(1 + i) % 4];\n\t\t\t\t\t\tif (tx >= 0 && tx < w && ty >= 0 && ty < h)\n\t\t\t\t\t\t\tswitch (i) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'E'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'S'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'W'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'N'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (node.dir == 'S') {\n\t\t\t\t\tif (costs[2][y][x] >= 0 && costs[2][y][x] <= cost)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcosts[2][y][x] = cost;\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint tcost = cost;\n\t\t\t\t\t\tif (field[y][x] != i)\n\t\t\t\t\t\t\ttcost += command[i];\n\t\t\t\t\t\tint tx = x + dx[(2 + i) % 4];\n\t\t\t\t\t\tint ty = y + dy[(2 + i) % 4];\n\t\t\t\t\t\tif (tx >= 0 && tx < w && ty >= 0 && ty < h)\n\t\t\t\t\t\t\tswitch (i) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'S'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'W'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'N'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'E'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (node.dir == 'W') {\n\t\t\t\t\tif (costs[3][y][x] >= 0 && costs[3][y][x] <= cost)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcosts[3][y][x] = cost;\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint tcost = cost;\n\t\t\t\t\t\tif (field[y][x] != i)\n\t\t\t\t\t\t\ttcost += command[i];\n\t\t\t\t\t\tint tx = x + dx[(3 + i) % 4];\n\t\t\t\t\t\tint ty = y + dy[(3 + i) % 4];\n\t\t\t\t\t\tif (tx >= 0 && tx < w && ty >= 0 && ty < h)\n\t\t\t\t\t\t\tswitch (i) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'W'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'N'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'E'));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tqueue.add(new Node(tx, ty, tcost, 'S'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint result = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\tif (costs[i][h - 1][w - 1] >= 0)\n\t\t\t\t\tresult = Math.min(result, costs[i][h - 1][w - 1]);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint x, y, cost;\n\t\tchar dir;\n\n\t\tNode(int i, int j, int c, char d) {\n\t\t\tx = i;\n\t\t\ty = j;\n\t\t\tcost = c;\n\t\t\tdir = d;\n\t\t}\n\n\t\tpublic int compareTo(Node anotherNode) {\n\t\t\tif (this.dir == anotherNode.dir)\n\t\t\t\treturn this.cost - anotherNode.cost;\n\t\t\treturn this.dir - anotherNode.dir;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n//Time Limit Exceeded case......\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tint n, m;\n\tint[][][] dp;\n\tint[][] map;\n\tint[] cost;\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, 1, 0, -1};\n\t\n\tvoid dijkstra(int dir, int x, int y) {\n\t\tif (dp[dir][y][x] == -1 || (x == n && y == m)) return;\n\t\t//debug(dir);\n\t\tint order = map[y-1][x-1];\n\t\tint go = (order == 4) ? -1 : (order + dir) % 4;\n\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\tint nx = x + vx[i], ny = y + vy[i];\n\t\t\tint c = (go == i) ? 0 : cost[(i - dir + 4) % 4];\n\t\t\tif (dp[dir][y][x] != Integer.MAX_VALUE && dp[i][ny][nx] > dp[dir][y][x] + c && dp[dir][y][x] + c <= Math.min(dp[0][m][n], dp[1][m][n])) {\n\t\t\t\tdp[i][ny][nx] = dp[dir][y][x] + c;\n\t\t\t\tdijkstra(i, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tm = in.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\n\t\t\tmap = new int[m][n];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost = new int[4];\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tcost[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdp = new int[4][m+2][n+2];\t\t\t\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dp[i][j].length; k++) {\n\t\t\t\t\t\tif (j == 0 || j == m + 1 || k == 0 || k == n + 1) \n\t\t\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tdp[0][1][1] = 0;\n\t\t\tdijkstra(0, 1, 1);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t//debug(i);\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tres = Math.min(res, dp[i][m][n]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(int i) {\n\t\tSystem.out.println(\"dir = \" + i);\n\t\tfor (int j = 1; j < dp[i].length - 1; j++) {\n\t\t\tfor (int k = 1; k < dp[i][j].length - 1; k++) {\n\t\t\t\tSystem.out.print((dp[i][j][k] == Integer.MAX_VALUE ? \"F\" : dp[i][j][k]) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\t\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int INF = Integer.MAX_VALUE;\n    static int ac[];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if ((w | h) == 0) {\n                break;\n            }\n\n            int en = 4 * 4 * w * h;\n\n            int[][] lib = new int[][]{\n                    {0, 1, 2, 3},\n                    {1, 2, 3, 0},\n                    {2, 3, 0, 1},\n                    {3, 0, 1, 2}\n            };\n\n            int vn = h * w * 4;\n\n            Edge[][] edges = new Edge[vn][4];\n\n            int[][] map = new int[h][w];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    map[i][j] = sc.nextInt();\n                }\n            }\n            ac = new int[4];\n            for (int i = 0; i < 4; i++) {\n                ac[i] = sc.nextInt();\n            }\n\n            int[] d = new int[]{-1, 0, 1, 0, -1};\n\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        int v1 = k + 4 * j + 4 * w * i;\n                        for (int l = 0; l < 4; l++) {\n                            int k2 = lib[k][l];\n                            int i2 = i + d[k2];\n                            int j2 = j + d[k2 + 1];\n                            if (i2 < 0 || i2 >= h || j2 < 0 || j2 >= w) {\n                                edges[v1][l] = new Edge(-1, -1, -1);\n                                continue;\n                            }\n                            int v2 = k2 + 4 * j2 + 4 * w * i2;\n                            int c = (map[i][j] == l) ? 0 : ac[l];\n                            edges[v1][l] = new Edge(v1, v2, c);\n                        }\n                    }\n                }\n            }\n\n            int[] distance = new int[vn];\n            Arrays.fill(distance, INF);\n            distance[1] = 0;\n            Queue<Edge> queue = new PriorityQueue<>();\n            queue.add(new Edge(1, 1, 0));\n\n            while (!queue.isEmpty()) {\n                Edge e1 = queue.poll();\n                if (distance[e1.target] < e1.cost) {\n                    continue;\n                }\n\n                for (Edge e2 : edges[e1.target]) {\n                    if (e2.source == -1) {\n                        continue;\n                    }\n                    if (distance[e2.target] > distance[e1.target] + e2.cost) {\n                        distance[e2.target] = distance[e1.target] + e2.cost;\n                        queue.add(new Edge(e1.target, e2.target, distance[e2.target]));\n                    }\n                }\n            }\n\n            // for (int i = 0; i < vn; i++) {\n            //     if (i % 4 == 0) {\n            //         System.out.println();\n            //     }\n            //     System.out.println(distance[i]);\n            // }\n            int res1 = distance[1 + 4 * (w - 1) + 4 * w * (h - 1)];\n            int res2 = distance[2 + 4 * (w - 1) + 4 * w * (h - 1)];\n            System.out.println(Math.min(res1, res2));\n        }\n\n    }\n\n    static class Edge implements Comparable<Edge> {\n        public int source;\n        public int target;\n        public int cost;\n\n        public Edge(int source, int target, int cost) {\n            this.source = source;\n            this.target = target;\n            this.cost = cost;\n        }\n\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.cost - o.cost;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\tstatic final int[] dd = { 0, 1, 0, -1 };\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint w = ir.nextInt();\n\t\t\tint h = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\ta[i] = ir.nextIntArray(w);\n\t\t\tint[] c = ir.nextIntArray(4);\n\t\t\tint[][] d = new int[h * w][4];\n\t\t\tfor (int i = 0; i < h * w; i++)\n\t\t\t\tArrays.fill(d[i], 1 << 30);\n\t\t\td[0][0] = 0;\n\t\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\t\treturn a[3] - b[3];\n\t\t\t\t}\n\t\t\t});\n\t\t\tpq.add(new int[] { 0, 0, 0, 0 });\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tint[] from = pq.poll();\n\t\t\t\tint cur = from[0] * w + from[1];\n\t\t\t\tint cmd = a[from[0]][from[1]];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = from[0] + dd[dir(from[2], i)], ny = from[1] + dd[dir(from[2], i) ^ 1];\n\t\t\t\t\tint cost = cmd == i ? 0 : c[i];\n\t\t\t\t\tif (nx >= 0 && ny >= 0 && nx < h && ny < w\n\t\t\t\t\t\t\t&& d[cur][from[2]] + cost < d[nx * w + ny][dir(from[2], i)]) {\n\t\t\t\t\t\td[nx * w + ny][dir(from[2], i)] = d[cur][from[2]] + cost;\n\t\t\t\t\t\tpq.add(new int[] { nx, ny, dir(from[2], i), d[nx * w + ny][dir(from[2], i)] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(Math.min(d[h * w - 1][0], d[h * w - 1][1]));\n\t\t}\n\t}\n\n\tstatic int dir(int cur, int cmd) {\n\t\treturn (cur + cmd) % 4;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Twirling Robot\npublic class Main{\n\n\tstatic int[][][] dist;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint[] cost = new int[4];\n\t\t\tfor(int i=0;i<4;i++)cost[i]=sc.nextInt();\n\t\t\tdist = new int[h][w][4];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<4;k++)dist[i][j][k]=Integer.MAX_VALUE;\n\t\t\tdist[0][0][1] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]]-dist[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0,0,1});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tint dir = a[2];\n\t\t\t\tif(i==h-1&&j==w-1){\n\t\t\t\t\tSystem.out.println(dist[i][j][dir]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nd = (dir+k)%4;\n\t\t\t\t\tint ni = i+move[nd][0];\n\t\t\t\t\tint nj = j+move[nd][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\t\tint c = dist[i][j][dir] + (m[i][j]==k?0:cost[k]);\n\t\t\t\t\t\tif(c < dist[ni][nj][nd]){\n\t\t\t\t\t\t\tdist[ni][nj][nd] = c;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj,nd});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int x;\n    int y;\n    int d;\n  }\n\n  static int[][] ofs = {\n      {1, 0},\n      {0, 1},\n      {-1, 0},\n      {0, -1}\n  };\n\n  void run() {\n    for (; ; ) {\n      int w, h;\n      w = ni();\n      h = ni();\n      if ((w | h) == 0) {\n        break;\n      }\n      int[][] s = new int[h + 2][w + 2];\n      for (int i = 0; i <= h + 1; ++i) Arrays.fill(s[i], -1);\n      for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n          s[i][j] = ni();\n        }\n      }\n      int[] c = new int[4];\n      for (int i = 0; i < 4; ++i) {\n        c[i] = ni();\n      }\n\n      int[][][] dp = new int[h + 2][w + 2][4];\n      for (int i = 0; i < h + 2; ++i) {\n        for (int j = 0; j < w + 2; ++j) {\n          for (int k = 0; k < 4; ++k) {\n            dp[i][j][k] = 1 << 28;\n          }\n        }\n      }\n      Node start = new Node();\n      start.x = 1;\n      start.y = 1;\n      start.d = 0;\n      dp[1][1][0] = 0;\n\n      Queue<Node> meu = new PriorityQueue<>(new Comparator<Node>() {\n        @Override\n        public int compare(Node o1, Node o2) {\n          if (dp[o2.y][o2.x][o2.d] == dp[o1.y][o1.x][o1.d]) {\n            return h - o2.y + w - o2.x + o1.y - h + o1.x - w;\n          } else {\n            return dp[o1.y][o1.x][o1.d] - dp[o2.y][o2.x][o2.d];\n          }\n        }\n      });\n      meu.add(start);\n      while (meu.size() > 0) {\n        Node node = meu.poll();\n//        debug(node.x, node.y, node.d, dp[node.y][node.x][node.d]);\n        if (node.x == w && node.y == h) {\n          break;\n        }\n        for (int i = 0; i < 4; ++i) {\n          int addi = i == s[node.y][node.x] ? 0 : c[i];\n          Node next = new Node();\n          next.d = (node.d + i) % 4;\n          next.x = node.x + ofs[next.d][0];\n          next.y = node.y + ofs[next.d][1];\n          if (s[next.y][next.x] == -1) {\n            continue;\n          }\n          if (dp[next.y][next.x][next.d] > dp[node.y][node.x][node.d] + addi) {\n            dp[next.y][next.x][next.d] = dp[node.y][node.x][node.d] + addi;\n            meu.add(next);\n          }\n        }\n      }\n\n      int ans = 1 << 28;\n      for (int i = 0; i < 4; ++i) {\n        ans = Math.min(ans, dp[h][w][i]);\n      }\n      System.out.println(ans);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tpublic int[] dx=new int[]{1,0,-1,0};\n\tpublic int[] dy=new int[]{0,1,0,-1};\n\n\tpublic void dfs(int y,int x,int d){\n\t\t//次の点に行く\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint _x=x+dx[i],_y=y+dy[i];\n\t\t\tif(!(0<=_x && _x <W && 0<=_y && _y<H))continue;\n\t\t\tint c=dp[y][x][d]+(map[y][x]==(i-d+4)%4?0:cost[(i-d+4)%4]);\n\t\t\tif(dp[_y][_x][i]>c){\n\t\t\t\tdp[_y][_x][i]=c;\n\t\t\t\tdfs(_y,_x,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint W,H;int[][] map;int[]  cost;\n\tint[][][] dp;\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tW=sc.nextInt();H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\t\t\tmap=new int[H][W];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tmap[h][w]=sc.nextInt();\n\t\t\t}\n\n\t\t\tcost=new int[4];\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tcost[i]=sc.nextInt();\n\n\t\t\tdp=new int[H][W][4];//上下左右どこから来たか\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tArrays.fill(dp[h][w],100000000);\n\t\t\t}\n\t\t\tdp[0][0][0]=0;\n\t\t\tdfs(0,0,0);\n\n\t\t\tint m=Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<4;i++)m=min(dp[H-1][W-1][i],m);\n\t\t\tln(m);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int[][] map;\n\tpublic static Node[] node;\n\tpublic static int w;\n\tpublic static int h;\n\tpublic static int[] c;\n\tpublic static HashMap<Integer, Integer> cost;\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static final int mask = (1<<12)-1;\n\tpublic static final int diff = 12;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = new Node[4*h*w];\n\t\t\t// id = dir*h*w + y*w + x\n\t\t\t// ID_MAX = 3600 < 2^12\n\t\t\tint size = 4*h*w;\n\t\t\tfor(int i=0; i<size; i++){\n\t\t\t\tnode[i] = new Node(i);\n\t\t\t}\n\t\t\tc = new int[4];\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tc[i] = in.nextInt();\n\t\t\t}\n\t\t\tcost = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tedge(i, j, map[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint goal = h*w-1;\n\t\t\tint res = 0;\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tBitSet used = new BitSet(4*h*w);\n\t\t\tqu.add(new Pos(0, 0));\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used.get(p.id)) continue;\n\t\t\t\tif(p.id%(w*h) == goal){\n\t\t\t\t\tres = p.dist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused.set(p.id);\n\t\t\t\tfor(Node v: node[p.id].edge){\n\t\t\t\t\tint c = cost.containsKey(v.id)\n\t\t\t\t\t\t\t? Math.min(cost.get(v.id), p.dist+cost.get(p.id<<diff|v.id))\n\t\t\t\t\t\t\t\t\t: p.dist+cost.get(p.id<<diff|v.id);\n\t\t\t\t\tcost.put(v.id, c);\n\t\t\t\t\tqu.add(new Pos(v.id, c));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void edge(int y, int x, int command){\n\t\tint base = h*w;\n\t\tfor(int i=0; i<4; i++){\n\t\t\t// 命令iをつかう\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// 階層jから階層j+iへ、yからy+dy[j+i]へ、xからx+dx[j+i]へコストc[i]の辺を張る\n\t\t\t\tint ny = y+dy[(j+i)%4];\n\t\t\t\tint nx = x+dx[(j+i)%4];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tint from = j*base + y*w + x;\n\t\t\t\tint to = ((j+i)%4)*base + ny*w + nx;\n\t\t\t\tnode[from].createEdge(node[to]);\n\t\t\t\tcost.put(from<<diff|to, i==command?0:c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id;\n\tint dist;\n\tpublic Pos(int id, int dist){\n\t\tthis.id = id;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn dist-o.dist;\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> edge = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n\t\n\tpublic String toString(){\n\t\treturn \"(depth:\"+(id/Main.w/Main.h)+\", x:\"+(id%Main.w)+\", y:\"+(id/Main.w)%Main.h+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tstatic int[][] map=new int[30][30];  //?????????\n\tstatic int ch, cw, cd;\n\tstatic int h, w;  //map?????????\n\tstatic Node[][][] node;  //?????????\n\tstatic PriorityQueue<Node> open_queue;\n\tstatic Node currentNode;  //?¨?????????????\n\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint c0,c1,c2,c3;  //??´????????????????????¢?????????\n\n\t\twhile(true){\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\n\t\t\tif(w==0 && h==0){break;}\n\n\t\t\tfor(int i=0;i<h;i++){  //??????????????±??????\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tc0=sc.nextInt();\n\t\t\tc1=sc.nextInt();\n\t\t\tc2=sc.nextInt();\n\t\t\tc3=sc.nextInt();\n\n\t\t\tnode=new Node[h][w][4];  //?????\\??????\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tnode[i][j][k]=new Node();\n\t\t\t\t\t\tnode[i][j][k].Nh=i;\n\t\t\t\t\t\tnode[i][j][k].Nw=j;\n\t\t\t\t\t\tnode[i][j][k].Nd=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tnode[0][0][k].Start=true;\n\t\t\t\tnode[h-1][w-1][k].Goal=true;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<h;i++){  //???????????\\??????\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(k==0){node[i][j][k].cost=c0;}\n\t\t\t\t\t\telse if(k==1){node[i][j][k].cost=c1;}\n\t\t\t\t\t\telse if(k==2){node[i][j][k].cost=c2;}\n\t\t\t\t\t\telse if(k==3){node[i][j][k].cost=c3;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<h;i++){   //map??¨?????´???????????????0\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(map[i][j]==0){node[i][j][0].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==1){node[i][j][1].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==2){node[i][j][2].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==3){node[i][j][3].cost=0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDykstra();\n\t\t}\n\t}\n\n\tstatic void Dykstra(){\n\t\topen_queue = new PriorityQueue<Node>(1, new MyComparator());\n\t\topen_queue.add(node[0][0][0]);\n\t\tnode[0][0][0].f=0;\n\t\twhile(true){\n\t\t\tcurrentNode=open_queue.poll();\n\t\t\tif(currentNode.Goal==true){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCalc();\n\t\t}\n\t\tSystem.out.println(currentNode.f);\n\t}\n\tstatic void Calc(){\n\t\tch=currentNode.Nh;\n\t\tcw=currentNode.Nw;\n\t\tcd=currentNode.Nd;  //0??? 1??? 2??? 3???\n\t\t//System.out.println(currentNode.f);\n\n\t\tif(ch>0){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][3].cost;  //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][1].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][0].cost; //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][2].cost; //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ch<h-1){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][1].cost;  //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][3].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][2].cost; //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][0].cost; //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cw>0){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][2].cost;  //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][0].cost; //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][3].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][1].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cw<w-1){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][0].cost;  //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][2].cost; //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][1].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][3].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nclass Node{\n\tint cost; //??´????????????????????¢?????????\n\tint f; //?????????\n\tint Nh, Nw, Nd;  //??´?????¨??????\n\tboolean Start;\n\tboolean Goal;\n\t\n\tpublic Node(){\n\t\tcost=Integer.MAX_VALUE;\n\t\tf=Integer.MAX_VALUE;\n\t\tNh=0;\n\t\tNw=0;\n\t\tNd=0;\n\t\tStart=false;\n\t\tGoal=false;\n\t}\n}\n\n\nclass MyComparator implements Comparator<Object>{\n    public int compare(Object obj1, Object obj2) {\n\n        Node num1 = (Node)obj1;\n        Node num2 = (Node)obj2;\n\n        if(num1.f>num2.f) {\n            return 1;\n        } else if(num1.f<num2.f) {\n            return -1;\n        } else{\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] c = new int[4];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] cost = new int[4][h][w];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\tcost[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost[0][0][0] = 0;\n\t\t\t\n\t\t\tLinkedList<Integer> x = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> y = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> d = new LinkedList<Integer>();\n\t\t\tx.offer(0);\n\t\t\ty.offer(0);\n\t\t\td.offer(0);\n\t\t\tint p, q, r, s;\n\t\t\tint[] e = new int[4];\n\t\t\twhile(d.size()!=0){\n\t\t\t\tp = x.poll();\n\t\t\t\tq = y.poll();\n\t\t\t\tr = d.poll();\n\t\t\t\ts = cost[r][q][p];\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\te[r] = c[i];\n\t\t\t\t\tif(map[q][p]==i) e[r] = 0;\n\t\t\t\t\tr++;\n\t\t\t\t\tif(r==4) r = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p!=w-1 && cost[0][q][p+1]>s+e[0]){\n\t\t\t\t\tcost[0][q][p+1] = s+e[0];\n\t\t\t\t\tx.offer(p+1);\n\t\t\t\t\ty.offer(q);\n\t\t\t\t\td.offer(0);\n\t\t\t\t}\n\t\t\t\tif(q!=h-1 && cost[1][q+1][p]>s+e[1]){\n\t\t\t\t\tcost[1][q+1][p] = s+e[1];\n\t\t\t\t\tx.offer(p);\n\t\t\t\t\ty.offer(q+1);\n\t\t\t\t\td.offer(1);\n\t\t\t\t}\n\t\t\t\tif(p!=0 && cost[2][q][p-1]>s+e[2]){\n\t\t\t\t\tcost[2][q][p-1] = s+e[2];\n\t\t\t\t\tx.offer(p-1);\n\t\t\t\t\ty.offer(q);\n\t\t\t\t\td.offer(2);\n\t\t\t\t}\n\t\t\t\tif(q!=0 && cost[3][q-1][p]>s+e[3]){\n\t\t\t\t\tcost[3][q-1][p] = s+e[3];\n\t\t\t\t\tx.offer(p);\n\t\t\t\t\ty.offer(q-1);\n\t\t\t\t\td.offer(3);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = Math.min(cost[0][h-1][w-1], cost[1][h-1][w-1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint w;\n\tint h;\n\tint[][] s;\n\tint[][][] visited;\n\n\tint cs[];\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tfinal int INF = 1 << 29;\n\n\tboolean init() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tif ((h | w) == 0)\n\t\t\treturn false;\n\t\ts = new int[w][h];\n\t\tvisited = new int[w][h][4];\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(visited[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcs = new int[4];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ts[j][i] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\twhile (init()) {\n\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\tq.add(new Node(0, 0, 0, 0));\n\t\t\tint ans = INF;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint x = n.x;\n\t\t\t\tint y = n.y;\n\t\t\t\t// System.out.println(n);\n\t\t\t\tint d = n.d;\n\t\t\t\tint c = n.c;\n\t\t\t\tif (visited[x][y][d] <= c)\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[x][y][d] = c;\n\t\t\t\tif (x == w - 1 && y == h - 1) {\n\t\t\t\t\tans = Math.min(ans, c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = x + dx[(d + i) % 4];\n\t\t\t\t\tint ny = y + dy[(d + i) % 4];\n\t\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tNode nn = new Node(nx, ny, (d + i) % 4, c + cs[i]);\n\t\t\t\t\tq.add(nn);\n\t\t\t\t}\n\t\t\t\tif (s[x][y] == 4)\n\t\t\t\t\tcontinue;\n\t\t\t\tint dd = (d + s[x][y]) % 4;\n\t\t\t\tint nx = x + dx[dd];\n\t\t\t\tint ny = y + dy[dd];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.add(new Node(nx, ny, dd, c));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n}\n\nclass Node {\n\tpublic int x;\n\tpublic int y;\n\tpublic int d;\n\tpublic int c;\n\n\tNode(int x, int y, int d, int c) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.d = d;\n\t\tthis.c = c;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"( \" + x + \" \" + y + \" \" + d + \" \" + c + \") \";\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    /*\n      .0.\n      3.1\n      .2.\n    */\n    int[][] dx = {{0,1,0,-1,0},\n                  {1,0,-1,0,0},\n                  {0,-1,0,1,0},\n                  {-1,0,1,0,0}};\n    int[][] dy = {{-1,0,1,0,0},\n                  {0,1,0,-1,0},\n                  {1,0,-1,0,0},\n                  {0,-1,0,1,0}};\n    int[][][] memo;\n    int w;\n    int h;\n    int[][] s;\n    int[] cost;\n\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        while(true){\n        w = sc.nextInt();\n        h = sc.nextInt();\n        if(w == 0 && h == 0){\n            break;\n        }\n        s = new int[h][w];\n        for(int i = 0; i < h; i++){\n            for(int ii = 0; ii < w; ii++){\n                s[i][ii] = sc.nextInt();\n            }\n        }\n        cost = new int[4];\n        for(int i = 0; i < 4; i++){\n            cost[i] = sc.nextInt();\n        }\n        memo = new int[h][w][4];\n        for(int i = 0; i < h; i++){\n            for(int ii = 0; ii < w; ii++){\n                Arrays.fill(memo[i][ii], Integer.MAX_VALUE);\n            }\n        }\n        DFS(0,0,1,0);\n        //System.out.println(Arrays.toString(memo[h-1][w-1]));\n        int ans = Integer.MAX_VALUE;\n        for(int m: memo[h-1][w-1]){\n            ans = Math.min(ans, m);\n        }\n        System.out.println(ans);\n        }\n    }\n    void DFS(int x, int y, int dir, int total_cost){\n        if(x < 0 || w <= x || y < 0 || h <= y){\n            return;\n        }\n        if(memo[y][x][dir] <= total_cost){\n            return;\n        }\n        memo[y][x][dir] = total_cost;\n        \n        //パネルに従う\n        int cur = s[y][x];\n        DFS(x + dx[dir][cur], y + dy[dir][cur], (dir + cur) % 4, total_cost);\n        \n        //指示を出す\n        for(int command = 0; command < 4; command++){\n            DFS(x + dx[dir][command], y + dy[dir][command], (dir + command) % 4, total_cost + cost[command]);\n        }\n    }   \n    public static void main(String[] args){\n        new Main().run();\n    }\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int x;\n    int y;\n    int d;\n  }\n\n  static int[][] ofs = {\n      {1, 0},\n      {0, 1},\n      {-1, 0},\n      {0, -1}\n  };\n\n  void run() {\n    for (; ; ) {\n      int w, h;\n      w = ni();\n      h = ni();\n      if ((w | h) == 0) {\n        break;\n      }\n      int[][] s = new int[h + 2][w + 2];\n      for (int i = 0; i <= h + 1; ++i) Arrays.fill(s[i], -1);\n      for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n          s[i][j] = ni();\n        }\n      }\n      int[] c = new int[4];\n      for (int i = 0; i < 4; ++i) {\n        c[i] = ni();\n      }\n\n      int[][][] dp = new int[h + 2][w + 2][4];\n      for (int i = 0; i < h + 2; ++i) {\n        for (int j = 0; j < w + 2; ++j) {\n          for (int k = 0; k < 4; ++k) {\n            dp[i][j][k] = 1 << 28;\n          }\n        }\n      }\n      Node start = new Node();\n      start.x = 1;\n      start.y = 1;\n      start.d = 0;\n      dp[1][1][0] = 0;\n\n      Queue<Node> meu = new PriorityQueue<>(new Comparator<Node>() {\n        @Override\n        public int compare(Node o1, Node o2) {\n          if (dp[o2.y][o2.x][o2.d] == dp[o1.y][o1.x][o1.d]) {\n            return h - o2.y + w - o2.x + o1.y - h + o1.x - w;\n          } else {\n            return dp[o2.y][o2.x][o2.d] - dp[o1.y][o1.x][o1.d];\n          }\n        }\n      });\n      meu.add(start);\n      while (meu.size() > 0) {\n        Node node = meu.poll();\n//        debug(node.x, node.y, node.d, dp[node.y][node.x][node.d]);\n        for (int i = 0; i < 4; ++i) {\n          int addi = i == s[node.y][node.x] ? 0 : c[i];\n          Node next = new Node();\n          next.d = (node.d + i) % 4;\n          next.x = node.x + ofs[next.d][0];\n          next.y = node.y + ofs[next.d][1];\n          if (s[next.y][next.x] == -1) {\n            continue;\n          }\n          if (dp[next.y][next.x][next.d] > dp[node.y][node.x][node.d] + addi) {\n            dp[next.y][next.x][next.d] = dp[node.y][node.x][node.d] + addi;\n            meu.add(next);\n          }\n        }\n      }\n\n      int ans = 1 << 28;\n      for (int i = 0; i < 4; ++i) {\n        ans = Math.min(ans, dp[h][w][i]);\n      }\n      System.out.println(ans);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\n\t//0135 start\n\t//0157 cording end\n\t//dir is 0 = n, 1 = E, 2 = S, 3 = W\n\n\tint INF = 1 << 24;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\tint w,h;\n\n\tclass C implements Comparable<C>{\n\t\tint x,y,cost, dir;\n\n\n\t\tpublic C(int x, int y, int cost, int dir) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cost = cost;\n\t\t\tthis.dir = dir;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.cost < o.cost) return -1;\n\t\t\tif(this.cost > o.cost) return 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", cost=\" + cost + \", dir=\" + dir\n\t\t\t\t\t+ \"]\";\n\t\t}\n\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tint [][] data = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint [] option = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\toption[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.C>();\n\t\t\topen.add(new C(0, 0, 0, 1));\n\n\t\t\tint [][][] close = new int[h][w][4];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[0][0][1] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x == w - 1 && now.y == h - 1){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//マップの命令\n\t\t\t\tint op = data[now.y][now.x];\n\t\t\t\tif(op != 4){\n\t\t\t\t\tint nextdir = (now.dir + op) % 4;\n\t\t\t\t\tint xx = now.x + vx[nextdir];\n\t\t\t\t\tint yy = now.y + vy[nextdir];\n\t\t\t\t\t//System.out.println(\"dir = \" + nextdir + \" xx = \" + xx + \" x = \" + now.x + \"yy = \" + yy + \" y = \" + now.y);\n\t\t\t\t\tif(isOK(xx, yy)){\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tif(close[yy][xx][nextdir] > nextcost){\n\t\t\t\t\t\t\topen.add(new C(xx, yy, nextcost, nextdir));\n\t\t\t\t\t\t\tclose[yy][xx][nextdir] = nextcost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//オプション\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint nextdir = (now.dir + i) % 4;\n\t\t\t\t\tint xx = now.x + vx[nextdir];\n\t\t\t\t\tint yy = now.y + vy[nextdir];\n\t\t\t\t\t//System.out.println(\"adir = \" + nextdir + \" xx = \" + xx + \" x = \" + now.x + \"yy = \" + yy + \" y = \" + now.y);\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tint nextcost = now.cost + option[i];\n\t\t\t\t\tif(close[yy][xx][nextdir] <= nextcost) continue;\n\t\t\t\t\topen.add(new C(xx, yy, nextcost, nextdir));\n\t\t\t\t\tclose[yy][xx][nextdir] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0<= yy && yy < h){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int x;\n    int y;\n    int d;\n  }\n\n  static int[][] ofs = {\n      {1, 0},\n      {0, 1},\n      {-1, 0},\n      {0, -1}\n  };\n\n  void run() {\n    for (; ; ) {\n      int w, h;\n      w = ni();\n      h = ni();\n      if ((w | h) == 0) {\n        break;\n      }\n      int[][] s = new int[h + 2][w + 2];\n      for (int i = 0; i <= h + 1; ++i) Arrays.fill(s[i], -1);\n      for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n          s[i][j] = ni();\n        }\n      }\n      int[] c = new int[4];\n      for (int i = 0; i < 4; ++i) {\n        c[i] = ni();\n      }\n\n      int[][][] dp = new int[h + 2][w + 2][4];\n      for (int i = 0; i < h + 2; ++i) {\n        for (int j = 0; j < w + 2; ++j) {\n          for (int k = 0; k < 4; ++k) {\n            dp[i][j][k] = 1 << 28;\n          }\n        }\n      }\n      Node start = new Node();\n      start.x = 1;\n      start.y = 1;\n      start.d = 0;\n      dp[1][1][0] = 0;\n\n      Queue<Node> meu = new PriorityQueue<>(new Comparator<Node>() {\n        @Override\n        public int compare(Node o1, Node o2) {\n          if (dp[o2.y][o2.x][o2.d] == dp[o1.y][o1.x][o1.d]) {\n            return h - o1.y + w - o1.x + o2.y - h + o2.x - w;\n          } else {\n            return dp[o1.y][o1.x][o1.d] - dp[o2.y][o2.x][o2.d];\n          }\n        }\n      });\n      meu.add(start);\n      while (meu.size() > 0) {\n        Node node = meu.poll();\n//        debug(node.x, node.y, node.d, dp[node.y][node.x][node.d]);\n        if (node.x == w && node.y == h) {\n          break;\n        }\n        for (int i = 0; i < 4; ++i) {\n          int addi = i == s[node.y][node.x] ? 0 : c[i];\n          Node next = new Node();\n          next.d = (node.d + i) % 4;\n          next.x = node.x + ofs[next.d][0];\n          next.y = node.y + ofs[next.d][1];\n          if (s[next.y][next.x] == -1) {\n            continue;\n          }\n          if (dp[next.y][next.x][next.d] > dp[node.y][node.x][node.d] + addi) {\n            dp[next.y][next.x][next.d] = dp[node.y][node.x][node.d] + addi;\n            meu.add(next);\n          }\n        }\n      }\n\n      int ans = 1 << 28;\n      for (int i = 0; i < 4; ++i) {\n        ans = Math.min(ans, dp[h][w][i]);\n      }\n      System.out.println(ans);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint w;\n\tint h;\n\tint[][] s;\n\tshort[][][] visited;\n\n\tint cs[];\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tfinal short INF = 1 << 14;\n\n\tboolean init() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tif ((h | w) == 0)\n\t\t\treturn false;\n\t\ts = new int[w][h];\n\t\tvisited = new short[w][h][4];\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(visited[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcs = new int[4];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ts[j][i] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\twhile (init()) {\n\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\tq.add(new Node(0, 0, 0, (short) 0));\n\t\t\tint ans = INF;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint x = n.x;\n\t\t\t\tint y = n.y;\n\t\t\t\t// System.out.println(n);\n\t\t\t\tint d = n.d;\n\t\t\t\tshort c = n.c;\n\t\t\t\tvisited[x][y][d] = c;\n\t\t\t\tif (x == w - 1 && y == h - 1) {\n\t\t\t\t\tans = Math.min(ans, c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = x + dx[(d + i) % 4];\n\t\t\t\t\tint ny = y + dy[(d + i) % 4];\n\t\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (visited[nx][ny][(d + i) % 4] <= c + cs[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tNode nn = new Node(nx, ny, (d + i) % 4, (short) (c + cs[i]));\n\t\t\t\t\tq.add(nn);\n\t\t\t\t}\n\t\t\t\tif (s[x][y] == 4)\n\t\t\t\t\tcontinue;\n\t\t\t\tint dd = (d + s[x][y]) % 4;\n\t\t\t\tint nx = x + dx[dd];\n\t\t\t\tint ny = y + dy[dd];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.add(new Node(nx, ny, dd, c));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n}\n\nclass Node {\n\tpublic int x;\n\tpublic int y;\n\tpublic int d;\n\tpublic short c;\n\n\tNode(int x, int y, int d, short c) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.d = d;\n\t\tthis.c = c;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"( \" + x + \" \" + y + \" \" + d + \" \" + c + \") \";\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int H, W;\n\tstatic int[] C = new int[4];\n\tstatic int[][] map = new int[30][30];\n\tstatic boolean read() {\n\t\tW = sc.nextInt(); H = sc.nextInt();\n\t\tif (W == 0) return false;\n\t\t\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tC[i] = sc.nextInt();\n\t\t\t\t\n\t\treturn true;\n\t}\n\n\tstatic final int INF = 1 << 20;\n\tstatic int[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\tstatic void solve() {\n\t\tint[][][] dist = new int[30][30][4];\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tfor (int j = 0; j < 30; j++)\n\t\t\t\tfill(dist[i][j], INF);\n\t\t\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.add(new State(0, 0, 0, 0));\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\t\t\tint x = s.x, y = s.y, c = s.c, d = s.d;\n\t\t\tif (dist[y][x][d] != INF) continue;\n\t\t\tdist[y][x][d] = c;\n\t\t\t\n\t\t\tif (y == H - 1 && x == W - 1) {\n\t\t\t\t\n\t\t\t\tSystem.out.println(c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nd = (d + i) % 4;\n\t\t\t\tint nx = x + dx[nd], ny = y + dy[nd], nc = c + C[i];\n\t\t\t\t\t\n\t\t\t\tif (i == map[y][x])\n\t\t\t\t\tnc -= C[i];\n\t\t\t\t\n\t\t\t\tif (check(nx, ny) && dist[ny][nx][nd] > nc) \n\t\t\t\t\tque.add(new State(nx, ny, nd, nc));\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean check(int x, int y) {\n\t\treturn (x >= 0 && x < W && y >= 0 && y < H);\n\t}\n}\n\nclass State implements Comparable<State> {\n\tint x, y, c, d;\t// ツコツスツト ツ陛サツ古シ\n\tState(int x, int y, int d, int c) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.c - s.c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic final int INF = 1<<29;\n\tstatic final int[] dy = {0,1,0,-1};\n\tstatic final int[] dx = {1,0,-1,0};\n\n\tint W, H;\n\tint[][] board;\n\tint[] cost;\n\t\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW = in.nextInt(); H = in.nextInt();\n\t\t\tif(W==0) return ;\n\t\t\tboard = new int[H][W];\n\t\t\tcost = new int[4];\n\t\t\tfor(int i=0; i<H; i++)for(int j=0; j<W; j++){\n\t\t\t\tboard[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t\tcost[i] = in.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tclass State{\n\t\tint dist,y,x,dir;\n\t\tState(int _d, int _y, int _x, int _dir){\n\t\t\tthis.dist  = _d;\n\t\t\tthis.y = _y;\n\t\t\tthis.x = _x;\n\t\t\tthis.dir = _dir;\n\t\t}\n\t}\n\n\tclass Cmp implements Comparator<State>{\n\t\tpublic int compare(State a, State b){\n\t\t\treturn a.dist>b.dist?1:a.dist<b.dist?-1:0;\n\t\t}\n\t}\n\n\tint solve(){\n\t\tint[][][] dist = new int[H][W][4];\n\t\tfor(int i=0; i<H; i++)for(int j=0; j<W; j++)for(int k=0; k<4; k++){\n\t\t\tdist[i][j][k] = INF;\n\t\t}\n\t\tPriorityQueue<State> Q = new PriorityQueue<State>(11,new Cmp());\n\t\tQ.add(new State(0,0,0,0));\n\t\twhile(!Q.isEmpty()){\n\t\t\tState tp = Q.poll();\n\t\t\tif(tp.y == H-1 && tp.x == W-1) return tp.dist;\n\t\t\tif(dist[tp.y][tp.x][tp.dir] != INF) continue;\n\t\t\tdist[tp.y][tp.x][tp.dir] = tp.dist;\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tint ndir = (tp.dir + k)%4;\n\t\t\t\tint ny = tp.y + dy[ndir], nx = tp.x + dx[ndir];\n\t\t\t\tif(0<=ny && ny<H && 0<=nx && nx<W && dist[ny][nx][ndir] == INF){\n\t\t\t\t\tint ndist = tp.dist + (board[tp.y][tp.x]==k?0:cost[k]);\n\t\t\t\t\tQ.add(new State(ndist, ny, nx, ndir) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ5\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\n\t//AOJ1155\n\tString str;\n\tchar p,q,r;\n\tint ind;\n\t//AOJ1155\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ1156();\n\t}\n\tvoid AOJ1155(){\n\t\twhile(true){\n\t\t\t str = sc.next();\n\t\t\t \n\t\t\t if(str.equals(\".\")){\n\t\t\t\t break;\n\t\t\t }\n\t\t\t ind = 0;\n\t\t\t int count  = 0;\n\t\t\t for(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\tp = (char) (i + '0');\n\t\t\t\t\t\tq = (char) (j + '0');\n\t\t\t\t\t\tr = (char) (k + '0');\n\t\t\t\t\t\tchar res = formula();\n\t\t\t\t\t\tif(res == '2'){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tind = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t }\n\t\t\t System.out.println(count);\n\t\t}\n\t}\n\t\n\tprivate char formula() {\n\t\tchar now = str.charAt(ind++);\n\t\tif(now == '-'){\n\t\t\treturn rev(formula());\n\t\t}\n\t\telse if(now == '('){\n\t\t\tchar temp1 = formula();\n\t\t\tchar temp2 = str.charAt(ind++);\n\t\t\tchar temp3 = formula();\n\t\t\tstr.charAt(ind++);\n\t\t\tif(temp2 == '+'){\n\t\t\t\treturn add(temp1, temp3);\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn mul(temp1, temp3);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(now == 'P'){\n\t\t\treturn p;\n\t\t}\n\t\telse if(now == 'Q'){\n\t\t\treturn q;\n\t\t}\n\t\telse if(now == 'R'){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn now;\n\t\t}\n\t}\n\tprivate char mul(char c1, char c2) {\n\t\tint t1 = c1 - '0';\n\t\tint t2 = c2 - '0';\n\t\tint t3 = Math.min(t1, t2);\n\t\tchar ans = (char) (t3 + '0');\n\t\treturn ans;\n\t}\n\tprivate char add(char c1, char c2) {\n\t\tint t1 = c1 - '0';\n\t\tint t2 = c2 - '0';\n\t\tint t3 = Math.max(t1, t2);\n\t\tchar ans = (char) (t3 + '0');\n\t\treturn ans;\n\t}\n\tprivate char rev(char c) {\n\t\tswitch (c){\n\t\tcase '0': return '2';\n\t\tcase '1': return '1';\n\t\tcase '2': return '0';\n\t\t}\n\t\treturn '0';\n\t}\n\t\n\t\n\tvoid AOJ1156(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tint[] c=new int[4];\n\t\t\tfor(int i=0; i<4; i++)\tc[i]=sc.nextInt();\n\t\t\tLinkedList<C1156> open=new LinkedList<C1156>();\n\t\t\tint[][][] close=new int[W][H][4];\t// [x][y][v]\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int k=0; k<4; k++)\tclose[i][j][k]=Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1156(0,0,1,0));\n\t\t\tclose[0][0][1]=0;\n\t\t\tint ans=Integer.MAX_VALUE;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1156 now=open.poll();\n\t\t\t\tif(b[now.x][now.y]!=4){\n\t\t\t\t\tC1156 temp2=m(now,b[now.x][now.y]);\n\t\t\t\t\tif(Point.ok(temp2.x, temp2.y, W, H)){\n\t\t\t\t\t\tif(temp2.x==W-1 && temp2.y==H-1){\n\t\t\t\t\t\t\t// debug\n\t\t\t\t\t\t\t//out.println(\"#\"+now.cost);\n\t\t\t\t\t\t\tans=min(ans,now.cost);\n\t\t\t\t\t\t}else if(close[temp2.x][temp2.y][temp2.v]>temp2.cost){\n\t\t\t\t\t\t\topen.add(temp2);\n\t\t\t\t\t\t\tclose[temp2.x][temp2.y][temp2.v]=temp2.cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(i==b[now.x][now.y])\tcontinue;\n\t\t\t\t\tC1156 temp=m(now,i);\n\t\t\t\t\tif(temp==null)\tcontinue;\n\t\t\t\t\tif(!Point.ok(temp.x, temp.y, W, H))\tcontinue;\n\t\t\t\t\ttemp.cost+=c[i];\n\t\t\t\t\tif(temp.x==W-1 && temp.y==H-1){\n\t\t\t\t\t\t// debug\n\t\t\t\t\t\t//out.println(\"@\"+temp.cost);\n\t\t\t\t\t\tans=min(ans,temp.cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(close[temp.x][temp.y][temp.v]<=temp.cost)\tcontinue;\n\t\t\t\t\topen.add(temp);\n\t\t\t\t\tclose[temp.x][temp.y][temp.v]=temp.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tC1156 m(C1156 c1156,int m){\n\t\tC1156 now=new C1156(c1156);\n\t\tif(m==4)\treturn null;\n\t\t//else\tnow.v=4%(now.v+m);\n\t\telse if(m==1)\tnow.v=(now.v<3?now.v+1:0);\t// 右折\n\t\telse if(m==2)\tnow.v=(now.v==3?1:now.v==1?3:abs(2-now.v));\t// 反転\n\t\telse if(m==3)\tnow.v=(now.v>0?now.v-1:3);\t// 左折\n\t\t//else\treturn null;\n\t\tnow.x+=vx[now.v];\tnow.y+=vy[now.v];\n\t\treturn now;\n\t}\n\t// v: 0=上 1=右 2=下 3=左\n\tclass C1156 implements Comparable<C1156>{\n\t\tint x,y,v,cost;\n\t\tC1156(int x,int y,int v,int cost){this.x=x; this.y=y; this.v=v; this.cost=cost;}\n\t\tC1156(C1156 a){this.x=a.x; this.y=a.y; this.v=a.v; this.cost=a.cost;}\n\t\t@Override\n\t\tpublic int compareTo(C1156 o) {\n\t\t\tif(this.cost<o.cost)\treturn -1;\n\t\t\tif(this.cost>o.cost)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1154(){\n\t\tfinal int MAX=300000;\n\t\tboolean[] list=list(MAX);\n\t\t//debug\n\t\t//for(int i=6; i<=MAX; i++)\tif(list[i])\tout.print(\" \"+i);\n\t\t//out.println();\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==1)\tbreak;\n\t\t\tout.print(n+\":\");\n\t\t\tfor(int i=6; i<=n; i+=7){\n\t\t\t\tif(list[i] && n%i==0)\tout.print(\" \"+i);\n\t\t\t\tif(list[i+2] && n%(i+2)==0)\tout.print(\" \"+(i+2));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\tboolean[] list(int MAX){\n\t\tboolean[] b=new boolean[MAX+1];\n\t\tArrays.fill(b, false);\n\t\tfor(int i=6; i<=MAX; i+=7){\n\t\t\tb[i]=true;\tb[i+2]=true;\n\t\t}\n\t\tfor(int i=6; i<=MAX; i+=7){\n\t\t\tif(b[i])\tfor(int j=i+i; j<=MAX; j+=(i))\tb[j]=false;\n\t\t\tif(b[i+2])\tfor(int j=i+i+4; j<=MAX; j+=(i+2))\tb[j]=false;\n\t\t}\n\t\treturn b;\n\t}\n\t\n\tvoid A(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint [] taro = new int[n];\n\t\t\tint [] hanako = new int[m];\n\t\t\tint sum1 = 0,sum2 = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ttaro[i] = sc.nextInt();\n\t\t\t\tsum1 += taro[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < m ;i++){\n\t\t\t\thanako[i] = sc.nextInt();\n\t\t\t\tsum2 += hanako[i];\n\t\t\t}\n\t\t\tArrays.sort(taro);\n\t\t\tArrays.sort(hanako);\n\t\t\tboolean flg = true;\n\t\t\tfor(int i =0; i < n ;i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tint temp1 = sum1 - taro[i] + hanako[j];\n\t\t\t\t\tint temp2 = sum2 - hanako[j] + taro[i];\n\t\t\t\t\tif(temp1 ==  temp2){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tSystem.out.println(taro[i] + \" \" + hanako[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tif(! flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tint[][] map;\n\tint[][][] min;\n\tint[] c;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\t\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) \n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\n\t\t\tc = new int[4];\n\t\t\tfor(int i=0;i<4;i++) c[i] = sc.nextInt();\n\t\t\t\n\t\t\tmin = new int[h][w][4];\n\t\t\tfor(int[][] a: min) for(int[] b: a) fill(b, INF);\n\t\t\t\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint solve() {\n\t\tPriorityQueue<Element> que = new PriorityQueue<Element>();\n\t\tque.add(new Element(0,0,2,0));\n\t\tmin[0][0][2] = 0;\n\t\tfor(;;) {\n\t\t\tElement e = que.remove();\n\t\t\tif( e.x == w-1 && e.y == h-1) return e.c;\n\t\t\tif(min[e.y][e.x][e.d] != e.c) continue;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx = e.x + dx[(i+e.d)%4];\n\t\t\t\tint ny = e.y + dy[(i+e.d)%4];\n\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\tif(i == map[e.y][e.x]) {\n\t\t\t\t\tif(min[ny][nx][(i+e.d)%4] <= e.c )continue;\n\t\t\t\t\tque.add(new Element(nx, ny, (i+e.d)%4, e.c));\n\t\t\t\t\tmin[ny][nx][(i+e.d)%4] = e.c;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(min[ny][nx][(i+e.d)%4] <= e.c+c[i])continue;\n\t\t\t\t\tque.add(new Element(nx, ny, (i+e.d)%4, e.c+c[i]));\n\t\t\t\t\tmin[ny][nx][(i+e.d)%4] = e.c+c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass Element implements Comparable<Element>{\n\t\tint x, y, d, c;\n\t\tElement(int x, int y, int d, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.d = d;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Element o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn c-o.c;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1156();\n\t}\n\t\n\tclass AOJ1156{\n\t\tAOJ1156(){\n\t\t\twhile(true){\n\t\t\t\tint w=sc.nextInt(),h=sc.nextInt();\n\t\t\t\tif((w|h)==0)\tbreak;\n\t\t\t\tsolve(w,h);\n\t\t\t}\n\t\t}\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tvoid solve(int w,int h){\n\t\t\tint[][] b=new int[w][h];\n\t\t\tfor(int y=0; y<h; ++y)for(int x=0; x<w; ++x)b[x][y]=sc.nextInt();\n\t\t\tint[] c={sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt()};\n\t\t\t\n//\t\t\tLinkedList<State> open=new LinkedList<State>();\n\t\t\tPriorityQueue<State> open=new PriorityQueue<State>();\n\t\t\topen.add(new State(0,0,1,0));\n\t\t\t\n\t\t\tint[][][] closed=new int[w][h][4];\n\t\t\tfor(int i=0; i<w; ++i)for(int j=0; j<h; ++j)for(int k=0; k<4; ++k)closed[i][j][k]=INF;\n\t\t\tclosed[0][0][1]=0;\n\t\t\t\n\t\t\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(now.x==w-1 && now.y==h-1){\n\t\t\t\t\tSystem.out.println(now.c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint tmp=(now.z+v)%4;\n\t\t\t\t\tint xx=now.x+vx[tmp];\n\t\t\t\t\tint yy=now.y+vy[tmp];\n\t\t\t\t\tif(0<=xx&&xx<w && 0<=yy&&yy<h){\n\t\t\t\t\t\tint nc=now.c + (b[now.x][now.y]==v?0:c[v]);\n\t\t\t\t\t\tif(closed[xx][yy][tmp]>nc){\n\t\t\t\t\t\t\topen.add(new State(xx,yy,tmp,nc));\n\t\t\t\t\t\t\tclosed[xx][yy][tmp]=nc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,z,c;\n\t\t\tState(int x,int y,int z,int c){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.z=z;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(State o){\n\t\t\t\treturn this.c-o.c;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+z+\" \"+c;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1155{\n\t\tAOJ1155(){\n\t\t\twhile(true){\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\".\"))\tbreak;\n\t\t\t\tsolve(str);\n\t\t\t}\n\t\t}\n\t\tvoid solve(String str){\n\t\t\tint cnt=0;\n\t\t\tstr+=\"#\";\n\t\t\tfor(int p=0; p<=2; ++p)for(int q=0; q<=2; ++q)for(int r=0; r<=2; ++r){\n\t\t\t\tString tmp=str.replaceAll(\"P\", \"\"+p).replaceAll(\"Q\", \"\"+q).replaceAll(\"R\", \"\"+r);\n//\t\t\t\tSystem.out.println(tmp);\n\t\t\t\tthis.line=tmp.toCharArray();\n\t\t\t\tthis.pos=0;\n\t\t\t\tint ret=expr();\n//\t\t\t\tSystem.out.println(ret);\n\t\t\t\tcnt += (ret==2?1:0);\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tfinal int[][]\tand={{0,0,0},{0,1,1},{0,1,2}},\n\t\t\t\tor={{0,1,2},{1,1,2},{2,2,2}};\n\t\tfinal int[] m={2,1,0};\n\t\tchar[] line;\n\t\tint pos=0;\n\t\tprivate int expr(){\n\t\t\tint ret=term();\n\t\t\twhile(true){\n\t\t\t\tchar op=line[pos];\n\t\t\t\tif( op=='+' ){\n\t\t\t\t\tint old=ret;\n\t\t\t\t\t++pos;\n\t\t\t\t\tret=term();\n\t\t\t\t\tret=or[old][ret];\n//\t\t\t\t\tSystem.out.println(old+\"+\"+ret+\" = \"+or[old][ret]);\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tprivate int term(){\n\t\t\tint ret=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line[pos];\n\t\t\t\tif( op=='*' ){\n\t\t\t\t\tint old=ret;\n\t\t\t\t\t++pos;\n\t\t\t\t\tret=fact();\n\t\t\t\t\tret=and[old][ret];\n//\t\t\t\t\tSystem.out.println(old+\"*\"+ret+\" = \"+and[old][ret]);\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tprivate int fact(){\n\t\t\tif(line[pos]=='-'){\n\t\t\t\t++pos;\n\t\t\t\treturn m[fact()];\n\t\t\t}else if(Character.isDigit(line[pos])){\n\t\t\t\tint ret=line[pos]-'0';\n\t\t\t\t++pos;\n\t\t\t\treturn ret;\n\t\t\t}else if(line[pos]=='('){\n\t\t\t\t++pos;\n\t\t\t\tint ret=expr();\n\t\t\t\t++pos;\t// \")\"テ」ツ?古ヲツ敖・テ」ツつ凝」ツ?ィテ、ツサツョテ・ツョツ?\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tclass AOJ1153{\n\t\tAOJ1153(){\n\t\t\twhile(true){\n\t\t\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\t\t\tif((n|m)==0)\tbreak;\n\t\t\t\tsolve(n,m);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int n,int m){\n\t\t\tint[] nn=new int[n],\n\t\t\t\t\tmm=new int[m];\n\t\t\tint ns=0, ms=0;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tnn[i]=sc.nextInt();\n\t\t\t\tns+=nn[i];\n\t\t\t}\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tmm[i]=sc.nextInt();\n\t\t\t\tms+=mm[i];\n\t\t\t}\n\t\t\tArrays.sort(nn);\n\t\t\tArrays.sort(mm);\n\t\t\tint cand1=-1,cand2=-1,sum=Integer.MAX_VALUE/4;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfor(int j=0; j<m; ++j){\n\t\t\t\t\tif(ns-nn[i]+mm[j] == ms-mm[j]+nn[i] && sum>nn[i]+mm[j]){\n\t\t\t\t\t\tcand1=i;\n\t\t\t\t\t\tcand2=j;\n\t\t\t\t\t\tsum=nn[i]+mm[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cand1<0? \"-1\" : nn[cand1]+\" \"+mm[cand2]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ1158().doit();\n\t}\n\n\tclass AOJ1158{\n\t\tint w,h;\n\t\tint[][] controll;\n\t\tint[] cost;\n\t\tPoint2D go(int x,int y,int muki){\n\t\t\tPoint2D result = new Point2D.Double();\n\t\t\tif(muki==0)result = new Point2D.Double(x,y-1);\n\t\t\telse if(muki==1)result = new Point2D.Double(x+1, y);\n\t\t\telse if(muki==2)result = new Point2D.Double(x, y+1);\n\t\t\telse if(muki==3)result = new Point2D.Double(x-1, y);\n\t\t\treturn result;\n\t\t}\n\n\t\tint solve(){\n\t\t\tint result = 0;\n\t\t\tint[][][] map = new int[31][31][4];\n\t\t\tfor(int i=0;i<31;i++)for(int s=0;s<31;s++)Arrays.fill(map[i][s],Integer.MAX_VALUE/2);\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tq.add(new State(0, 0, 1, 0));\n\t\t\tmap[0][0][1] = 0;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tint x = now.x;\n\t\t\t\tint y = now.y;\n\t\t\t\tint muki = now.muki;\n//\t\t\t\tSystem.out.println(\"*******************\");\n//\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+muki+\" \"+now.step);\n\t\t\t\tif(x==w-1&&y==h-1){\n\t\t\t\t\tresult = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){//0=直進,1=右折,2=反転,3=左折\n\t\t\t\t\tint nmuki = (muki+i)%4;\n\t\t\t\t\tPoint2D nxy = go(x, y, nmuki);\n\t\t\t\t\tint nx = (int)nxy.getX();\n\t\t\t\t\tint ny = (int)nxy.getY();\n\t\t\t\t\tint nstep = now.step;\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\t\tif(controll[y][x]!=i)nstep += cost[i];\n//\t\t\t\t\tif(nx==7&&ny==0){\n//\t\t\t\t\t\tSystem.out.println(\"------\");\n//\t\t\t\t\t\tSystem.out.println(nx+\" \"+ny+\" \"+nmuki+\" \"+nstep+\" \"+i+\" \"+controll[ny][nx]);\n//\t\t\t\t\t}\n\t\t\t\t\tif(map[ny][nx][nmuki]<=nstep)continue;\n\t\t\t\t\tmap[ny][nx][nmuki] = nstep;\n\t\t\t\t\tq.add(new State(nx, ny, nmuki, nstep));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s][0]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s][1]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s][2]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s][3]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,muki,step;\n\t\t\tpublic State(int x,int y,int muki,int step) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.muki = muki;\n\t\t\t\tthis.step = step;\n\t\t\t}\n\t\t\tpublic int compareTo(State arg0) {\n\t\t\t\treturn this.step - arg0.step;\n\t\t\t}\n\t\t}\n\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tw = in.nextInt();\n\t\t\t\th = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tcontroll = new int[h][w];\n\t\t\t\tcost = new int[4];//直進、右折、反転、左折\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)controll[i][s] = in.nextInt();\n\t\t\t\tfor(int i=0;i<4;i++)cost[i] = in.nextInt();\n\t\t\t\tint ans = solve();\n//\t\t\t\tSystem.out.print(\"Answer= \" );\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\t//break;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int dist[][];\n    static final int INF = Integer.MAX_VALUE;\n    static int ac[];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if ((w | h) == 0) {\n                break;\n            }\n\n            int en = 4 * 4 * w * h;\n\n            int[][] lib = new int[][]{\n                    {0, 1, 2, 3},\n                    {1, 2, 3, 0},\n                    {2, 3, 0, 1},\n                    {3, 0, 1, 2}\n            };\n\n            List<Edge>[] edges = new List[en];\n\n            for (int i = 0; i < en; i++) {\n                edges[i] = new ArrayList<>();\n            }\n\n            int[][] map = new int[h][w];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    map[i][j] = sc.nextInt();\n                }\n            }\n            ac = new int[4];\n            for (int i = 0; i < 4; i++) {\n                ac[i] = sc.nextInt();\n            }\n\n            int vn = h * w * 4;\n\n            int[] d = new int[]{-1, 0, 1, 0, -1};\n\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        int v1 = k + 4 * j + 4 * w * i;\n                        for (int l = 0; l < 4; l++) {\n                            int k2 = lib[k][l];\n                            int i2 = i + d[k2];\n                            int j2 = j + d[k2 + 1];\n                            if (i2 < 0 || i2 >= h || j2 < 0 || j2 >= w) {\n                                edges[i].add(new Edge(-1, -1, -1));\n                                continue;\n                            }\n                            int v2 = k2 + 4 * j2 + 4 * w * i2;\n                            int c = (map[i][j] == l) ? 0 : ac[l];\n                            edges[v1].add(new Edge(v1, v2, c));\n                        }\n                    }\n                }\n            }\n\n            int[] distance = new int[vn];\n            Arrays.fill(distance, INF);\n            distance[1] = 0;\n            Queue<Edge> queue = new PriorityQueue<>();\n            queue.add(new Edge(1, 1, 0));\n\n            while (!queue.isEmpty()) {\n                Edge e1 = queue.poll();\n                if (distance[e1.target] < e1.cost) {\n                    continue;\n                }\n\n                for (Edge e2 : edges[e1.target]) {\n                    if (e2.source == -1) {\n                        continue;\n                    }\n                    if (distance[e2.target] > distance[e1.target] + e2.cost) {\n                        distance[e2.target] = distance[e1.target] + e2.cost;\n                        queue.add(new Edge(e1.target, e2.target, distance[e2.target]));\n                    }\n                }\n            }\n\n            // for (int i = 0; i < vn; i++) {\n            //     if (i % 4 == 0) {\n            //         System.out.println();\n            //     }\n            //     System.out.println(distance[i]);\n            // }\n            int res1 = distance[1 + 4 * (w - 1) + 4 * w * (h - 1)];\n            int res2 = distance[2 + 4 * (w - 1) + 4 * w * (h - 1)];\n            System.out.println(Math.min(res1, res2));\n        }\n\n    }\n\n    static class Edge implements Comparable<Edge> {\n        public int source;\n        public int target;\n        public int cost;\n\n        public Edge(int source, int target, int cost) {\n            this.source = source;\n            this.target = target;\n            this.cost = cost;\n        }\n\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.cost - o.cost;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint w;\n\tint h;\n\tint[][] s;\n\tint[][][] dis;\n\n\tint cs[];\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tfinal int INF = 1 << 29;\n\n\tboolean init() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tif ((h | w) == 0)\n\t\t\treturn false;\n\t\ts = new int[w][h];\n\t\tdis = new int[w][h][4];\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(dis[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcs = new int[5];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ts[j][i] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\tcs[4] = 0;\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\twhile (init()) {\n\t\t\tdis[0][0][0] = 0;\n\t\t\twhile (true) {\n\t\t\t\tboolean update = false;\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\t\t\t\t// コマンド0,1,2,3orパネルの命令\n\t\t\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\t\t\tif (s[x][y] == 4 && i == 4)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tint nd = ((i != 4 ? i : s[x][y]) + d) % 4;\n\t\t\t\t\t\t\t\tint nx = x + dx[nd];\n\t\t\t\t\t\t\t\tint ny = y + dy[nd];\n\t\t\t\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (dis[x][y][d] != INF\n\t\t\t\t\t\t\t\t\t\t&& dis[nx][ny][nd] > dis[x][y][d]\n\t\t\t\t\t\t\t\t\t\t\t\t+ cs[i]) {\n\t\t\t\t\t\t\t\t\tdis[nx][ny][nd] = dis[x][y][d] + cs[i];\n\t\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!update)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(dis[w - 1][h - 1][1],\n\t\t\t\t\tdis[w - 1][h - 1][0]));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tstatic int[][] map=new int[30][30];  //?????????\n\tstatic int ch, cw, cd;\n\tstatic int h, w;  //map?????????\n\tstatic Node[][][] node;  //?????????\n\tstatic PriorityQueue<Node> open_queue;\n\tstatic Node currentNode;  //?¨?????????????\n\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint c0,c1,c2,c3;  //??´????????????????????¢?????????\n\n\t\twhile(true){\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\n\t\t\tif(w==0 && h==0){break;}\n\n\t\t\tfor(int i=0;i<h;i++){  //??????????????±??????\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tc0=sc.nextInt();\n\t\t\tc1=sc.nextInt();\n\t\t\tc2=sc.nextInt();\n\t\t\tc3=sc.nextInt();\n\n\t\t\tnode=new Node[h][w][4];  //?????\\??????\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tnode[i][j][k]=new Node();\n\t\t\t\t\t\tnode[i][j][k].Nh=i;\n\t\t\t\t\t\tnode[i][j][k].Nw=j;\n\t\t\t\t\t\tnode[i][j][k].Nd=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tnode[0][0][k].Start=true;\n\t\t\t\tnode[h-1][w-1][k].Goal=true;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<h;i++){  //???????????\\??????\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(k==0){node[i][j][k].cost=c0;}\n\t\t\t\t\t\telse if(k==1){node[i][j][k].cost=c1;}\n\t\t\t\t\t\telse if(k==2){node[i][j][k].cost=c2;}\n\t\t\t\t\t\telse if(k==3){node[i][j][k].cost=c3;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<h;i++){   //map??¨?????´???????????????0\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(map[i][j]==0){node[i][j][0].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==1){node[i][j][1].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==2){node[i][j][2].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==3){node[i][j][3].cost=0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDykstra();\n\t\t}\n\t}\n\n\tstatic void Dykstra(){\n\t\topen_queue = new PriorityQueue<Node>(1, new MyComparator());\n\t\topen_queue.add(node[0][0][0]);\n\t\tnode[0][0][0].f=0;\n\t\twhile(true){\n\t\t\tcurrentNode=open_queue.poll();\n\t\t\tif(currentNode.Goal==true){\n\t\t\t\t//System.out.println(\"H:\"+currentNode.Nh+\" W:\"+currentNode.Nw+\" D:\"+currentNode.Nd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCalc();\n\t\t}\n\t\tSystem.out.println(currentNode.f);\n\t}\n\tstatic void Calc(){\n\t\tch=currentNode.Nh;\n\t\tcw=currentNode.Nw;\n\t\tcd=currentNode.Nd;  //0??? 1??? 2??? 3???\n\t\t//System.out.println(currentNode.f);\n\n\t\tif(ch>0){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][3].cost;  //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][1].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][0].cost; //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][2].cost; //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ch<h-1){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][1].cost;  //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][3].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][2].cost; //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][0].cost; //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cw>0){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][2].cost;  //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][0].cost; //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][3].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][1].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cw<w-1){  //??????\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][0].cost;  //???????????´???????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][2].cost; //??????????????¢????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][1].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][3].cost; //???????????????????????????\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nclass Node{\n\tint cost; //??´????????????????????¢?????????\n\tint f; //?????????\n\tint Nh, Nw, Nd;  //??´?????¨??????\n\tboolean Start;\n\tboolean Goal;\n\t\n\tpublic Node(){\n\t\tcost=Integer.MAX_VALUE;\n\t\tf=Integer.MAX_VALUE;\n\t\tNh=0;\n\t\tNw=0;\n\t\tNd=0;\n\t\tStart=false;\n\t\tGoal=false;\n\t}\n}\n\n\nclass MyComparator implements Comparator<Object>{\n    public int compare(Object obj1, Object obj2) {\n\n        Node num1 = (Node)obj1;\n        Node num2 = (Node)obj2;\n\n        if(num1.f>num2.f) {\n            return 1;\n        } else if(num1.f<num2.f) {\n            return -1;\n        } else{\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        new Main();\n    }\n \n    public Main() {\n        new AOJ1158().doit();\n    }\n \n    class AOJ1158{\n        int w,h;\n        int[][] controll;\n        int[] cost;\n        Point2D go(int x,int y,int muki){\n            Point2D result = new Point2D.Double();\n            if(muki==0)result = new Point2D.Double(x,y-1);\n            else if(muki==1)result = new Point2D.Double(x+1, y);\n            else if(muki==2)result = new Point2D.Double(x, y+1);\n            else if(muki==3)result = new Point2D.Double(x-1, y);\n            return result;\n        }\n        int solve(){\n            int result = 0;\n            int[][][] map = new int[31][31][4];\n            for(int i=0;i<31;i++)for(int s=0;s<31;s++)Arrays.fill(map[i][s],Integer.MAX_VALUE/2);\n            PriorityQueue<State> q = new PriorityQueue<State>();\n            q.add(new State(0, 0, 1, 0));\n            map[0][0][1] = 0;\n            while(q.size()>0){\n//                System.out.println(\"上\");\n//                for(int i=0;i<h;i++){\n//                    for(int s=0;s<w;s++)System.out.printf(map[i][s][0]+\" \");\n//                    System.out.println();\n//                }\n//                System.out.println(\"右\");\n//                for(int i=0;i<h;i++){\n//                    for(int s=0;s<w;s++)System.out.print(map[i][s][1]+\" \");\n//                    System.out.println();\n//                }\n//                System.out.println(\"下\");\n//                for(int i=0;i<h;i++){\n//                    for(int s=0;s<w;s++)System.out.print(map[i][s][2]+\" \");\n//                    System.out.println();\n//                }\n//                System.out.println(\"左\");\n//                for(int i=0;i<h;i++){\n//                    for(int s=0;s<w;s++)System.out.print(map[i][s][3]+\" \");\n//                    System.out.println();\n//                }\n                State now = q.remove();\n                int x = now.x;\n                int y = now.y;\n                int muki = now.muki;\n//              if(q.size()>10)break;\n//              System.out.println(x+\" \"+y+\" \"+muki+\" \"+now.step);\n//                if(map[y][x][muki]<now.step)continue;\n//                map[y][x][muki] = now.step;\n                //床の命令に従った場合\n                int c = controll[y][x];\n                Point2D np = new Point2D.Double(x,y);\n                int nmuki = 0;\n                if(c==0){\n                    nmuki = (muki+0)%4;\n                    np = go(x, y, nmuki);\n                }else if(c==1){\n                    nmuki = (muki+1)%4;\n                    np = go(x, y, nmuki);\n                }else if(c==2){\n                    nmuki = (muki+2)%4;\n                    np = go(x, y, nmuki);\n                }else if(c==3){\n                    nmuki = (muki+3)%4;\n                    np = go(x, y, nmuki);\n                }else if(c==4){\n                    if(x==w-1&&y==h-1){\n                        result = now.step;\n                        break;\n                    }\n                }\n                int nx = (int)np.getX();\n                int ny = (int)np.getY();\n                if((nx<0||nx>=w||ny<0||ny>=h)==false){\n                     if(now.step < map[ny][nx][nmuki]) {\n//                    System.out.println(\"A: \" + nx+\" \"+ny+\" \"+nmuki+\" \"+now.step+\" \");\n                    q.add(new State(nx, ny, nmuki, now.step));\n                    map[ny][nx][nmuki] = now.step;\n                     }\n                }\n                //自分で動く場合\n                for(int i=0;i<4;i++){\n                    nmuki = 0;\n                    if(i==0){//直進\n                        nmuki = (muki+0)%4;\n                        np = go(x, y, nmuki);\n//                        System.out.println(np+\" \"+nmuki+\" \"+muki);\n                    }else if(i==1){//右折\n                        nmuki = (muki+1)%4;\n                        np = go(x, y, nmuki);\n                    }else if(i==2){//反転\n                        nmuki = (muki+2)%4;\n                        np = go(x, y, nmuki);\n                    }else if(i==3){//左折\n                        nmuki = (muki+3)%4;\n                        np = go(x, y, nmuki);\n                    }\n                    nx = (int)np.getX();\n                    ny = (int)np.getY();\n//                  System.out.println(nx+\" \"+ny+\" \"+nmuki);\n                    if((nx<0||nx>=w||ny<0||ny>=h)==false){\n                         if(now.step + cost[i] < map[ny][nx][nmuki]) {\n//                        System.out.println(\"B: \" + nx+\" \"+ny+\" \"+nmuki+\" \"+now.step+\" \"+cost[i]+\" \"+i + \" \" + map[ny][nx][nmuki]);\n                        q.add(new State(nx, ny, nmuki, now.step+cost[i]));\n                        map[ny][nx][nmuki] = now.step + cost[i];\n                         }\n                    }\n                }\n            }\n//            System.out.println(\"上\");\n//            for(int i=0;i<h;i++){\n//                for(int s=0;s<w;s++)System.out.printf(map[i][s][0]+\" \");\n//                System.out.println();\n//            }\n//            System.out.println(\"右\");\n//            for(int i=0;i<h;i++){\n//                for(int s=0;s<w;s++)System.out.print(map[i][s][1]+\" \");\n//                System.out.println();\n//            }\n//            System.out.println(\"下\");\n//            for(int i=0;i<h;i++){\n//                for(int s=0;s<w;s++)System.out.print(map[i][s][2]+\" \");\n//                System.out.println();\n//            }\n//            System.out.println(\"左\");\n//            for(int i=0;i<h;i++){\n//                for(int s=0;s<w;s++)System.out.print(map[i][s][3]+\" \");\n//                System.out.println();\n//            }\n            return result;\n        }\n        class State implements Comparable<State>{\n            int x,y,muki,step;\n            public State(int x,int y,int muki,int step) {\n                this.x = x;\n                this.y = y;\n                this.muki = muki;\n                this.step = step;\n            }\n            public int compareTo(State arg0) {\n                 return this.step - arg0.step;\n            }\n        }\n \n        void doit(){\n            while(true){\n                w = in.nextInt();\n                h = in.nextInt();\n                if(w+h==0)break;\n                controll = new int[h][w];\n                cost = new int[4];//直進、右折、反転、左折\n                for(int i=0;i<h;i++)for(int s=0;s<w;s++)controll[i][s] = in.nextInt();\n                for(int i=0;i<4;i++)cost[i] = in.nextInt();\n               \n                int ans = solve();\n                //System.out.print(\"Answer= \" );\n                System.out.println(ans);\n                //break;\n            }\n        }\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int h,w;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tint M=100000;\n\t\tfor(;;)\n\t\t{\n\t\t\tw=in.nextInt();\n\t\t\th=in.nextInt();\n\t\t\tif((w|h)==0)\n\t\t\t\treturn;\n\t\t\tint field[][]=new int[h][w];\n\t\t\tint cost[]=new int[4];\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfield[i][j]=in.nextInt();\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tcost[i]=in.nextInt();\n\t\t\tint dp[][][]=new int[h][w][4];//現在置と向いてる方向\n\t\t\tboolean visit[][][]=new boolean[h][w][4];\n\t\t\tvisit[0][0][0]=true;\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\tdp[i][j][k]=M;\n\t\t\tdp[0][0][0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!visit[i][j][k])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint addcost=cost[l];\n\t\t\t\t\t\t\t\tint nextk=k;\n\t\t\t\t\t\t\t\tif(field[i][j]==l)\n\t\t\t\t\t\t\t\t\taddcost=0;\n\t\t\t\t\t\t\t\tnextk=(k+l)%4;\n\t\t\t\t\t\t\t\tint nexth=i+dy[nextk];\n\t\t\t\t\t\t\t\tint nextw=j+dx[nextk];\n\t\t\t\t\t\t\t\tif(nextw>=0&&nexth>=0&&nextw<w&&nexth<h)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(dp[nexth][nextw][nextk]>dp[i][j][k]+addcost)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[nexth][nextw][nextk] = dp[i][j][k] + addcost;\n\t\t\t\t\t\t\t\t\t\tflag=visit[nexth][nextw][nextk]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ans=M; \n\t\t\tfor(int k=0;k<4;k++) \n\t\t\t\tans= Math.min(ans, dp[h-1][w-1][k]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\n\npublic class Main {\n\tstatic int INF = 2 << 27;\n\tstatic int[] vx = {1,0,-1,0};\n\tstatic int[] vy = {0,1,0,-1};\n\tstatic int[] vd = {0,1,2,3};\n\tpublic static void main(String[] args) {\t\n\t\t//FastScanner sc = new FastScanner();\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif(W == 0 && H == 0) break;\n\t\t\tint[][] map = new int[H][W];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] cost = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][][] memo = new int[H][W][4];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t\tArrays.fill(memo[i][j], 2 << 28);\n\t\t\t}\n\t\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\t\tq.add(new Data(0,0,0,0));\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tData p = q.poll();\n\t\t\t\tint h = p.h;\n\t\t\t\tint w = p.w;\n\t\t\t\tif(memo[h][w][p.dir%4] <= p.cost) continue;\n\t\t\t\tmemo[h][w][p.dir%4] = p.cost;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tint td = (p.dir + vd[i]) % 4;\n\t\t\t\t\tint th = h + vy[td];\n\t\t\t\t\tint tw = w + vx[td];\n\t\t\t\t\tif(th < 0 || tw < 0 || th >= H || tw >= W) continue;\n\t\t\t\t\tif(map[h][w] == i) {\n\t\t\t\t\t\tq.add(new Data(th,tw,td,p.cost));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tq.add(new Data(th,tw,td,p.cost + cost[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MIN = 2 << 28;\n\t\t\tfor(int k = 0; k < 4; k++) MIN = Math.min(MIN, memo[H-1][W-1][k]);\n\n\t\t\tSystem.out.println(MIN);\n\t\t\t\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data> {\n\t\t\n\t\tint h;\n\t\tint w;\n\t\tint dir;\n\t\tint cost;\n\t\tData(int a, int b, int c, int e) {\n\t\t\th = a;\n\t\t\tw = b;\n\t\t\tdir = c;\n\t\t\tcost = e;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint m, n;\n\tint[][] a;\n\tint[] c;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=new int[4];\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tc[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint[][][] d=new int[n][m][4];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tfill(d[j][i], INF);\n\t\t\t}\n\t\t}\n\t\tint[] dx={1, 0, -1, 0};\n\t\tint[] dy={0, 1, 0, -1};\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tque.offer(new P(0, 0, 0));\n\t\td[0][0][0]=0;\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(p.d>d[p.y][p.x][p.v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] cost=c.clone();\n\t\t\tif(a[p.y][p.x]!=4){\n\t\t\t\tcost[a[p.y][p.x]]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x, p.y, (p.v+i)%4);\n\t\t\t\tq.x+=dx[q.v];\n\t\t\t\tq.y+=dy[q.v];\n\t\t\t\tif(q.x<0||q.x>=m||q.y<0||q.y>=n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(d[q.y][q.x][q.v]>d[p.y][p.x][p.v]+cost[i]){\n\t\t\t\t\tp.d=d[q.y][q.x][q.v]=d[p.y][p.x][p.v]+cost[i];\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t// debug(j, i, d[j][i]);\n\t\t\t}\n\t\t}\n\t\t// debug(d[n-1][m-1]);\n\t\tint ans=INF;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tans=min(ans, d[n-1][m-1][i]);\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint x, y, v;\n\t\tint d;\n\n\t\tP(int x, int y, int v){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.v=v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\treturn d-p.d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic class State implements Comparable <State>{\n\t\tint dist, y, x, dir;\n\t\tState(int dist, int y, int x, int dir){\n\t\t\tthis.dist=dist;\n\t\t\tthis.y=y;\n\t\t\tthis.x=x;\n\t\t\tthis.dir=dir;\n\t\t}\n\t\tpublic int compareTo(State s) {\n\t\t\treturn this.dist-s.dist;\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tif(w==0) break;\n\t\t\t\tint inf=100000000;\n\t\t\t\tint[][] board=new int[h][w];\n\t\t\t\tint[] cost=new int[5];//命令に払うcost\n\t\t\t\tint[] dy= {0, 1, 0, -1};//進む方向\n\t\t\t\tint[] dx= {1, 0, -1, 0};\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tboard[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\tcost[i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint[][][] d=new int[h][w][5];//座標と向き\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\t\td[i][j][k]=inf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPriorityQueue<State> pq=new PriorityQueue<State>();\n\t\t\t\tpq.add(new State(0, 0, 0, 0));\n\t\t\t\twhile(! pq.isEmpty()) {\n\t\t\t\t\tState p=pq.poll();\n\t\t\t\t\tif(p.y==h-1 && p.x==w-1) {\n\t\t\t\t\t\tSystem.out.println(p.dist);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(d[p.y][p.x][p.dir]!=inf) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td[p.y][p.x][p.dir]=p.dist;\n\t\t\t\t\tSystem.out.println(\"p.dir=\"+p.dir);\n\t\t\t\t\tfor(int k=0; k<4; k++) {//向きを全方向やる\n\t\t\t\t\t\tint ndir=(p.dir+k)%4;\n\t\t\t\t\t\tint ny=p.y+dy[ndir], nx=p.x+dx[ndir];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && d[ny][nx][ndir]==inf) {\n\t\t\t\t\t\t\tint ndist=p.dist+(board[p.y][p.x]==k ? 0:cost[k]);\n\t\t\t\t\t\t\tSystem.out.println(\"ndist=\"+ndist+\" ny=\"+ny+\" nx=\"+nx+\" ndir=\"+ndir);\n\t\t\t\t\t\t\tpq.add(new State(ndist, ny, nx, ndir));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Twirling Robot\npublic class Main{\n\n\tstatic int[][][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint[] cost = new int[4];\n\t\t\tfor(int i=0;i<4;i++)cost[i]=sc.nextInt();\n\t\t\tdist = new int[h][w][4];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<4;k++)dist[i][j][k]=Integer.MAX_VALUE;\n\t\t\tdist[0][0][1] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]] - dist[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0, 0, 1});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tint d = a[2];\n\t\t\t\tif(i==h-1&&j==w-1){\n\t\t\t\t\tSystem.out.println(dist[i][j][d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nd = (d+k)%4;\n\t\t\t\t\tint ni = i + move[nd][0];\n\t\t\t\t\tint nj = j + move[nd][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\t\tint c = dist[i][j][d] + (m[i][j]==k?0:cost[k]);\n\t\t\t\t\t\tif(c < dist[ni][nj][nd]){\n\t\t\t\t\t\t\tdist[ni][nj][nd] = c;\n\t\t\t\t\t\t\tq.add(new int[]{ni, nj, nd});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \npublic class Main {\n     \n\tstatic int W, H;\n\tstatic int[][] s;\n\tstatic int[] c;\n\t\n    static void start()\n    {\n    \tint[][][] cost = new int[H][W][4];\n    \tBoolean[][][] check = new Boolean[H][W][4];\n    \t\n    \tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\t\tcost[y][x][d] = Integer.MAX_VALUE;\n\t\t\t\t\tcheck[y][x][d] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \tcost[0][0][0] = 0;\n    \t\n    \tint[] dx = {1, 0, -1,  0};\n    \tint[] dy = {0, 1,  0, -1};\n    \t\n    \twhile(true)\n    \t{\n    \t\tint cx = 0, cy = 0, cd = 0;\n    \t\t\n    \t\t// 次のcx, cy, cdを探す\n    \t\tint min = Integer.MAX_VALUE;\n    \t\tfor (int y = 0; y < H; y++) {\n    \t\t\tfor (int x = 0; x < W; x++) {\n    \t\t\t\tfor (int d = 0; d < 4; d++) {\n    \t\t\t\t\tif(check[y][x][d] == true) continue;\n    \t\t\t\t\t\n    \t\t\t\t\tif(cost[y][x][d] < min)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tmin = cost[y][x][d];\n    \t\t\t\t\t\tcy = y;\n    \t\t\t\t\t\tcx = x;\n    \t\t\t\t\t\tcd = d;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif(min == Integer.MAX_VALUE) break;\n    \t\t\n    \t\tcheck[cy][cx][cd] = true;\n    \t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nd = (cd + i) % 4;\n\t\t\t\tint nx = cx + dx[nd];\n\t\t\t\tint ny = cy + dy[nd];\n\t\t\t\t\n\t\t\t\tif ( !( 0<=nx && nx <= W-1) ) continue;\n\t\t\t\tif ( !( 0<=ny && ny <= H-1) ) continue;\n\t\t\t\tif( check[ny][nx][nd] == true ) continue;\n\t\t\t\t\n\t\t\t\tif(s[cy][cx] == i)\n\t\t\t\t\tcost[ny][nx][nd] = Math.min(cost[ny][nx][nd], cost[cy][cx][cd]);\n\t\t\t\telse {\n\t\t\t\t\tcost[ny][nx][nd] = Math.min(cost[ny][nx][nd], cost[cy][cx][cd] + c[i]);\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \t\n    \tSystem.out.println(Math.min(cost[H-1][W-1][0], cost[H-1][W-1][1]));\n    \t\n//    \tSystem.out.println(\"-- cost ----------------------------------------------------\");\n//    \t\n//    \tfor (int y = 0; y < H; y++) {\n//\t\t\tfor (int x = 0; x < W; x++) {\n//\t\t\t\tfor (int d = 0; d < 4; d++) {\n//\t\t\t\t\tSystem.out.println(\"cost[\" + y + \"][\" + x + \"][\" + d + \"] = \" + cost[y][x][d]);\n//\t\t\t\t\tSystem.out.println(\"check[\" + y + \"][\" + x + \"][\" + d + \"] = \" + check[y][x][d]);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//    \t\n//    \tSystem.out.println(\"----------------------------------------------------------\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tW = sca.nextInt();\n        \tH = sca.nextInt();\n        \tif(W == 0) break;\n        \t\n        \ts = new int[H][W];\n        \tfor (int y = 0; y < H; y++) {\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\ts[y][x] = sca.nextInt();\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tc = new int[4];\n        \tfor (int i = 0; i < 4; i++) {\n\t\t\t\tc[i] = sca.nextInt();\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t/*\n\t0: 「直進」命令\n\t1: 「右折」命令\n\t2: 「反転」命令\n\t3: 「左折」命令\n\t4: 「停止」命令\n\t */\n\tstatic int H,W;\n\tstatic int[][] field;\n\tstatic int[][][] dp;\n\tstatic int[] cost;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tif(H+W==0)break;\n\t\t\tfield=new int[H][W];\n\t\t\tdp=new int[H][W][5];\n\t\t\tcost=new int[4];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t\tArrays.fill(dp[i][j], 1<<30);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tcost[i]=cin.nextInt();\n\t\t\t}\n\t\t\tdp(0,0,0,0);\n\t\t\tint min=1<<30;\n\t\t\tfor(int i=0;i<5;i++){\n//\t\t\t\tSystem.out.println(dp[H-1][W-1][i]);\n\t\t\t\tif(min>dp[H-1][W-1][i]){\n\t\t\t\t\t\n\t\t\t\t\tmin=dp[H-1][W-1][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tstatic int dp(int h,int w,int dir,int c){\n//\t\tSystem.out.println(h+\" \"+w+\" \"+dir+\" \"+c);\n\t\tif(dp[h][w][dir]<=c)\n\t\t\treturn dp[h][w][dir];\n\t\tint re=-1;\n\t\tdp[h][w][dir]=c;\n\t\t// 床に書いてあるまま動く\n\t\t if(field[h][w]!=4){\n\t\t\tint newDir=change(field[h][w],dir);\n\t\t\tint hh=h+v1[newDir];\n\t\t\tint ww=w+v2[newDir];\n\t\t\tif(hh<0||ww<0||hh>=H||ww>=W){\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp(hh,ww,newDir,c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 命令を実行\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(field[h][w]==i)continue;\n\t\t\tint newDir=change(i,dir);\n\t\t\tint hh=h+v1[newDir];\n\t\t\tint ww=w+v2[newDir];\n\t\t\tif(hh<0||ww<0||hh>=H||ww>=W){\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tre=Math.min(re,dp(hh,ww,newDir,c+cost[i]));\n\t\t\t}\n\t\t}\n\t\treturn re;\n\t}\n\t\n\tstatic int change(int command,int dir){\n\t\tif(command==0||command==4)return dir;\n\t\telse if(command==1){\n\t\t\treturn (dir+1)%4;\n\t\t}\n\t\telse if(command==2){\n\t\t\treturn (dir+2)%4;\n\t\t}\n\t\telse if(command==3){\n\t\t\treturn (dir+3)%4;\n\t\t}\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic class State implements Comparable <State>{\n\t\tint dist, y, x, dir;\n\t\tState(int dist, int y, int x, int dir){\n\t\t\tthis.dist=dist;\n\t\t\tthis.y=y;\n\t\t\tthis.x=x;\n\t\t\tthis.dir=dir;\n\t\t}\n\t\tpublic int compareTo(State s) {\n\t\t\treturn this.dist-s.dist;\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tif(w==0) break;\n\t\t\t\tint inf=100000000;\n\t\t\t\tint[][] board=new int[h][w];\n\t\t\t\tint[] cost=new int[5];//命令に払うcost\n\t\t\t\tint[] dy= {0, 1, 0, -1};//進む方向\n\t\t\t\tint[] dx= {1, 0, -1, 0};\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tboard[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\tcost[i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint[][][] d=new int[h][w][5];//座標と向き\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\t\td[i][j][k]=inf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPriorityQueue<State> pq=new PriorityQueue<State>();\n\t\t\t\tpq.add(new State(0, 0, 0, 0));\n\t\t\t\twhile(! pq.isEmpty()) {\n\t\t\t\t\tState p=pq.poll();\n\t\t\t\t\tif(p.y==h-1 && p.x==w-1) {\n\t\t\t\t\t\tSystem.out.println(p.dist);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(d[p.y][p.x][p.dir]!=inf) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td[p.y][p.x][p.dir]=p.dist;\n\t\t\t\t\t//System.out.println(\"p.dir=\"+p.dir);\n\t\t\t\t\tfor(int k=0; k<4; k++) {//向きを全方向やる\n\t\t\t\t\t\tint ndir=(p.dir+k)%4;\n\t\t\t\t\t\tint ny=p.y+dy[ndir], nx=p.x+dx[ndir];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && d[ny][nx][ndir]==inf) {\n\t\t\t\t\t\t\tint ndist=p.dist+(board[p.y][p.x]==k ? 0:cost[k]);\n\t\t\t\t\t\t\t//System.out.println(\"ndist=\"+ndist+\" ny=\"+ny+\" nx=\"+nx+\" ndir=\"+ndir);\n\t\t\t\t\t\t\tpq.add(new State(ndist, ny, nx, ndir));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int h,w;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint dx[]={1,0,0,-1};\n\t\tint dy[]={0,1,-1,0};\n\t\tint M=1000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tw=in.nextInt();\n\t\t\th=in.nextInt();\n\t\t\tif((w|h)==0)\n\t\t\t\treturn;\n\t\t\tint field[][]=new int[h][w];\n\t\t\tint cost[]=new int[4];\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfield[i][j]=in.nextInt();\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tcost[i]=in.nextInt();\n\n\t\t\tint dp[][][]=new int[h][w][4];//現在置と向いてる方向\n\t\t\tboolean visit[][][]=new boolean[h][w][4];\n\t\t\tvisit[0][0][0]=true;\n\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\tdp[i][j][k]=M;\n\t\t\tdp[0][0][0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!visit[i][j][k])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint addcost=cost[l];\n\t\t\t\t\t\t\t\tint nextk=k;\n\t\t\t\t\t\t\t\tif(field[i][j]==l)\n\t\t\t\t\t\t\t\t\taddcost=0;\n\t\t\t\t\t\t\t\tnextk=(k+l)%4;\n\t\t\t\t\t\t\t\tint nexth=i+dy[nextk];\n\t\t\t\t\t\t\t\tint nextw=j+dx[nextk];\n\t\t\t\t\t\t\t\tif(inner(nexth,nextw))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(dp[nexth][nextw][nextk]>dp[i][j][k]+addcost)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[nexth][nextw][nextk] = dp[i][j][k] + addcost;\n\t\t\t\t\t\t\t\t\t\tflag=visit[nexth][nextw][nextk]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ans=M; \n\t\t\tfor(int k=0;k<4;k++) \n\t\t\t\tans= Math.min(ans, dp[h-1][w-1][k]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic boolean inner(int y,int x)\n\t{\n\t\treturn x>=0 && y>=0 && x<w && y<h;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint w;\n\tint h;\n\tint[][] s;\n\tshort[][][] visited;\n\n\tint cs[];\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tfinal short INF = 1 << 14;\n\n\tboolean init() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tif ((h | w) == 0)\n\t\t\treturn false;\n\t\ts = new int[w][h];\n\t\tvisited = new short[w][h][4];\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(visited[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcs = new int[4];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ts[j][i] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\twhile (init()) {\n\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\tq.add(new Node(0, 0, 0, (short) 0));\n\t\t\tint ans = INF;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint x = n.x;\n\t\t\t\tint y = n.y;\n\t\t\t\t// System.out.println(n);\n\t\t\t\tint d = n.d;\n\t\t\t\tshort c = n.c;\n\t\t\t\tif (visited[x][y][d] <= c)\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[x][y][d] = c;\n\t\t\t\tif (x == w - 1 && y == h - 1) {\n\t\t\t\t\tans = Math.min(ans, c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = x + dx[(d + i) % 4];\n\t\t\t\t\tint ny = y + dy[(d + i) % 4];\n\t\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tNode nn = new Node(nx, ny, (d + i) % 4, (short) (c + cs[i]));\n\t\t\t\t\tq.add(nn);\n\t\t\t\t}\n\t\t\t\tif (s[x][y] == 4)\n\t\t\t\t\tcontinue;\n\t\t\t\tint dd = (d + s[x][y]) % 4;\n\t\t\t\tint nx = x + dx[dd];\n\t\t\t\tint ny = y + dy[dd];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.add(new Node(nx, ny, dd, c));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n}\n\nclass Node {\n\tpublic int x;\n\tpublic int y;\n\tpublic int d;\n\tpublic short c;\n\n\tNode(int x, int y, int d, short c) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.d = d;\n\t\tthis.c = c;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"( \" + x + \" \" + y + \" \" + d + \" \" + c + \") \";\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint w;\n\tint h;\n\tint[][] s;\n\tint[][][] dis;\n\n\tint cs[];\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tfinal int INF = 1 << 29;\n\n\tboolean init() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tif ((h | w) == 0)\n\t\t\treturn false;\n\t\ts = new int[w][h];\n\t\tdis = new int[w][h][4];\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(dis[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcs = new int[5];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ts[j][i] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\tcs[4] = 0;\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\twhile (init()) {\n\t\t\tdis[0][0][0] = 0;\n\t\t\twhile (true) {\n\t\t\t\tboolean update = false;\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\t\t\t\t// コマンド0,1,2,3orパネルの命令\n\t\t\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\t\t\tint nd = ((i != 4 ? i : s[x][y]) + d) % 4;\n\t\t\t\t\t\t\t\tif (nd == 4)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tint nx = x + dx[nd];\n\t\t\t\t\t\t\t\tint ny = y + dy[nd];\n\t\t\t\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (dis[x][y][d] != INF\n\t\t\t\t\t\t\t\t\t\t&& dis[nx][ny][nd] > dis[x][y][d]\n\t\t\t\t\t\t\t\t\t\t\t\t+ cs[i]) {\n\t\t\t\t\t\t\t\t\tdis[nx][ny][nd] = dis[x][y][d] + cs[i];\n\t\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!update)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(dis[w - 1][h - 1][1],\n\t\t\t\t\tdis[w - 1][h - 1][0]));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int h,w;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tint M=1000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tw=in.nextInt();\n\t\t\th=in.nextInt();\n\t\t\tif((w|h)==0)\n\t\t\t\treturn;\n\t\t\tint field[][]=new int[h][w];\n\t\t\tint cost[]=new int[4];\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfield[i][j]=in.nextInt();\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tcost[i]=in.nextInt();\n\n\t\t\tint dp[][][]=new int[h][w][4];//現在置と向いてる方向\n\t\t\tboolean visit[][][]=new boolean[h][w][4];\n\t\t\tvisit[0][0][0]=true;\n\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\tdp[i][j][k]=M;\n\t\t\tdp[0][0][0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!visit[i][j][k])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint addcost=cost[l];\n\t\t\t\t\t\t\t\tint nextk=k;\n\t\t\t\t\t\t\t\tif(field[i][j]==l)\n\t\t\t\t\t\t\t\t\taddcost=0;\n\t\t\t\t\t\t\t\tnextk=(k+l)%4;\n\t\t\t\t\t\t\t\tint nexth=i+dy[nextk];\n\t\t\t\t\t\t\t\tint nextw=j+dx[nextk];\n\t\t\t\t\t\t\t\tif(inner(nexth,nextw))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(dp[nexth][nextw][nextk]>dp[i][j][k]+addcost)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[nexth][nextw][nextk] = dp[i][j][k] + addcost;\n\t\t\t\t\t\t\t\t\t\tflag=visit[nexth][nextw][nextk]=true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ans=M; \n\t\t\tfor(int k=0;k<4;k++) \n\t\t\t\tans= Math.min(ans, dp[h-1][w-1][k]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic boolean inner(int y,int x)\n\t{\n\t\treturn x>=0 && y>=0 && x<w && y<h;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tint n, m;\n\tint[][][] dp;\n\tint[][] map;\n\tint[] cost;\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, 1, 0, -1};\n\t\n\tvoid dijkstra(int dir, int x, int y) {\n\t\tif (dp[dir][y][x] == -1 || (x == n && y == m)) return;\n\t\t//debug(dir);\n\t\tint order = map[y-1][x-1];\n\t\tint go = (order == 4) ? -1 : (order + dir) % 4;\n\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\tint nx = x + vx[i], ny = y + vy[i];\n\t\t\tint c = (go == i) ? 0 : cost[(i - dir + 4) % 4];\n\t\t\tif (dp[dir][y][x] != Integer.MAX_VALUE && dp[i][ny][nx] > dp[dir][y][x] + c) {\n\t\t\t\tdp[i][ny][nx] = dp[dir][y][x] + c;\n\t\t\t\tdijkstra(i, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tm = in.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\n\t\t\tmap = new int[m][n];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost = new int[4];\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tcost[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdp = new int[4][m+2][n+2];\t\t\t\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dp[i][j].length; k++) {\n\t\t\t\t\t\tif (j == 0 || j == m + 1 || k == 0 || k == n + 1) \n\t\t\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tdp[0][1][1] = 0;\n\t\t\tdijkstra(0, 1, 1);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t//debug(i);\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tres = Math.min(res, dp[i][m][n]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(int i) {\n\t\tSystem.out.println(\"dir = \" + i);\n\t\tfor (int j = 1; j < dp[i].length - 1; j++) {\n\t\t\tfor (int k = 1; k < dp[i][j].length - 1; k++) {\n\t\t\t\tSystem.out.print((dp[i][j][k] == Integer.MAX_VALUE ? \"F\" : dp[i][j][k]) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tFastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\t\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n  static int h,w;\n  static int dx[] = {0,1,0,-1};\n  static int dy[] = {-1,0,1,0};\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    while(true){\n      w = sc.nextInt();\n      h = sc.nextInt();\n      if(w == 0 && h == 0) break;\n\n      int[][] t = new int[h][w];\n\n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          t[i][j] = sc.nextInt();\n        }\n      }\n\n      int[] change = new int[4];\n      for(int i=0;i<4;i++){\n        change[i] = sc.nextInt();\n      }\n\n      PriorityQueue<State> open = new PriorityQueue<State>();\n      HashSet<State> closed = new HashSet<State>();\n      open.add(new State(0,0,1,0));\n\n      State ans = null;\n\n      while(!open.isEmpty()){\n        State st = open.poll();\n        if(closed.contains(st)) continue;\n        closed.add(st);\n\n        if(st.x == w-1 && st.y == h-1){\n          ans = st;\n          break;\n        }\n\n        for(int i=0;i<4;i++){\n          int nd = (st.d + i) % 4;\n          int nx = st.x + dx[nd];\n          int ny = st.y + dy[nd];\n\n          if(nx>=0 && w>nx && ny>=0 && h>ny){\n            if(t[st.y][st.x] == i){\n              open.add(new State(nx,ny,nd,st.cost));\n            }\n            else{\n              open.add(new State(nx,ny,nd,st.cost+change[i]));\n            }\n          }\n        }\n      }\n\n      System.out.println(ans.cost);\n    }\n  }\n}\n\nclass State implements Comparable<State>{\n  int x,y,d,cost;\n\n  State(int x,int y,int d,int cost){\n    this.x = x;\n    this.y = y;\n    this.d = d;\n    this.cost = cost;\n  }\n\n  public boolean equals(Object o){\n    State st = (State)o;\n    return x == st.x && y == st.y && d == st.d;\n  }\n\n  public int hashCode(){\n    return x + y * 100 + d * 10000;\n  }\n\n  public int compareTo(State st){\n    return this.cost - st.cost;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tpublic int[] dx=new int[]{1,0,-1,0};\n\tpublic int[] dy=new int[]{0,1,0,-1};\n\n\tpublic void dfs(int y,int x,int d){\n\t\t//次の点に行く\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint _x=x+dx[i],_y=y+dy[i];\n\t\t\tif(!(0<=_x && _x <W && 0<=_y && _y<H))continue;\n\t\t\tint c=dp[y][x][d]+(map[y][x]==(i-d+4)%4?0:cost[(i-d+4)%4]);\n\t\t\tif(dp[_y][_x][i]>c){\n\t\t\t\tdp[_y][_x][i]=c;\n\t\t\t\tdfs(_y,_x,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Task implements Comparable<Task>{\n\t\tint x,y,d;\n\t\tint cost;\n\t\tTask(int _x,int _y,int _d,int _cost){\n\t\t\tx=_x;y=_y;d=_d;cost=_cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(!(o instanceof Task))return false;\n\t\t\tTask t=(Task)o;\n\t\t\treturn x==t.x && y==t.y && d==t.d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Task o) {\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\n\tint W,H;int[][] map;int[]  cost;\n\tint[][][] dp;\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tW=sc.nextInt();H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\t\t\tmap=new int[H][W];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tmap[h][w]=sc.nextInt();\n\t\t\t}\n\n\t\t\tcost=new int[4];\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tcost[i]=sc.nextInt();\n\n\t\t\tdp=new int[H][W][4];//上下左右どこから来たか\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tArrays.fill(dp[h][w],100000000);\n\t\t\t}\n\t\t\tdp[0][0][0]=0;\n\t\t\t//dfs(0,0,0);\n\n\t\t\t//dijkstra\n\t\t\tboolean[][][] used=new boolean[H][W][4];\n\t\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\t\tque.add(new Task(0,0,0,0));\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tTask t=que.poll();\n\t\t\t\tif(used[t.y][t.x][t.d])continue;\n\n\t\t\t\t//次の点に行く\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint _x=t.x+dx[i],_y=t.y+dy[i];\n\t\t\t\t\tif(!(0<=_x && _x <W && 0<=_y && _y<H))continue;\n\t\t\t\t\tint c=dp[t.y][t.x][t.d]+(map[t.y][t.x]==(i-t.d+4)%4?0:cost[(i-t.d+4)%4]);\n\t\t\t\t\tif(dp[_y][_x][i]>c){\n\t\t\t\t\t\tdp[_y][_x][i]=c;\n\t\t\t\t\t\tque.add(new Task(_x,_y,i,c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused[t.y][t.x][t.d]=true;\n\t\t\t}\n\n\t\t\tint m=Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<4;i++)m=min(dp[H-1][W-1][i],m);\n\t\t\tln(m);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tstatic int[][] map=new int[30][30];  //マップ\n\tstatic int ch, cw, cd;\n\tstatic int h, w;  //mapサイズ\n\tstatic Node[][][] node;  //ノード\n\tstatic PriorityQueue<Node> open_queue;\n\tstatic Node currentNode;  //計算ノード\n\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint c0,c1,c2,c3;  //直進、右折、反転、左折\n\n\t\twhile(true){\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\n\t\t\tif(w==0 && h==0){break;}\n\n\t\t\tfor(int i=0;i<h;i++){  //マップ情報得る\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tc0=sc.nextInt();\n\t\t\tc1=sc.nextInt();\n\t\t\tc2=sc.nextInt();\n\t\t\tc3=sc.nextInt();\n\n\t\t\tnode=new Node[h][w][4];  //値入れる\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tnode[i][j][k]=new Node();\n\t\t\t\t\t\tnode[i][j][k].Nh=i;\n\t\t\t\t\t\tnode[i][j][k].Nw=j;\n\t\t\t\t\t\tnode[i][j][k].Nd=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tnode[0][0][k].Start=true;\n\t\t\t\tnode[h-1][w-1][k].Goal=true;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<h;i++){  //コスト入れる\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(k==0){node[i][j][k].cost=c0;}\n\t\t\t\t\t\telse if(k==1){node[i][j][k].cost=c1;}\n\t\t\t\t\t\telse if(k==2){node[i][j][k].cost=c2;}\n\t\t\t\t\t\telse if(k==3){node[i][j][k].cost=c3;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<h;i++){   //mapと一致ならコスト0\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(map[i][j]==0){node[i][j][0].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==1){node[i][j][1].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==2){node[i][j][2].cost=0;}\n\t\t\t\t\t\telse if(map[i][j]==3){node[i][j][3].cost=0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tDykstra();\n\t\t}\n\t}\n\n\tstatic void Dykstra(){\n\t\topen_queue = new PriorityQueue<Node>(1, new MyComparator());\n\t\topen_queue.add(node[0][0][0]);\n\t\tnode[0][0][0].f=0;\n\t\twhile(true){\n\t\t\tcurrentNode=open_queue.poll();\n\t\t\tif(currentNode.Goal==true){break;}\n\t\t\tCalc();\n\t\t}\n\t\tSystem.out.println(currentNode.f);\n\t}\n\tstatic void Calc(){\n\t\tch=currentNode.Nh;\n\t\tcw=currentNode.Nw;\n\t\tcd=currentNode.Nd;  //0右 1左 2上 3下\n\n\t\tif(ch>0){  //上へ\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][3].cost;  //右から左折して上へ\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][1].cost; //左から右折して上へ\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][0].cost; //上から直進して上へ\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch-1][cw][2].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch-1][cw][2].f=currentNode.f+node[ch][cw][2].cost; //下から反転して上へ\n\t\t\t\t\topen_queue.add(node[ch-1][cw][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ch<h-1){  //下へ\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][1].cost;  //右から右折して下へ\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][3].cost; //左から左折して下へ\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][2].cost; //上から反転して下へ\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch+1][cw][3].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch+1][cw][3].f=currentNode.f+node[ch][cw][0].cost; //下から直進して下へ\n\t\t\t\t\topen_queue.add(node[ch+1][cw][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cw>0){  //左へ\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][2].cost;  //右から反転して左へ\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][0].cost; //左から直進して左へ\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][3].cost; //上から左折して左へ\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch][cw-1][1].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch][cw-1][1].f=currentNode.f+node[ch][cw][1].cost; //下から右折して左へ\n\t\t\t\t\topen_queue.add(node[ch][cw-1][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cw<w-1){  //右へ\n\t\t\tif(cd==0){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][0].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][0].cost;  //右から直進して右へ\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==1){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][2].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][2].cost; //左から反転して右へ\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==2){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][1].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][1].cost; //上から右折して右へ\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cd==3){\n\t\t\t\tif(node[ch][cw+1][0].f>currentNode.f+node[ch][cw][3].cost){\n\t\t\t\t\tnode[ch][cw+1][0].f=currentNode.f+node[ch][cw][3].cost; //下から左折して右へ\n\t\t\t\t\topen_queue.add(node[ch][cw+1][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nclass Node{\n\tint cost; //直進、右折、反転、左折\n\tint f; //コスト\n\tint Nh, Nw, Nd;  //場所と向き\n\tboolean Start;\n\tboolean Goal;\n\t\n\tpublic Node(){\n\t\tcost=0;\n\t\tf=Integer.MAX_VALUE;\n\t\tNh=0;\n\t\tNw=0;\n\t\tNd=0;\n\t\tStart=false;\n\t\tGoal=false;\n\t}\n}\n\nclass MyComparator implements Comparator<Object>{\n    public int compare(Object obj1, Object obj2) {\n\n        Node num1 = (Node)obj1;\n        Node num2 = (Node)obj2;\n\n        if(num1.f>num2.f) {\n            return 1;\n        } else if(num1.f<num2.f) {\n            return -1;\n        } else{\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\nimport static java.lang.Math.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint[] cost = new int[4];\n\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tState st = null;\n\t\t\tQueue<State> open = new PriorityQueue<State>();\n\t\t\tMap<State, State> closed = new HashMap<State, State>();\n\n\t\t\topen.add(new State(0,new Robot(1,0,0)));\n\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tst = open.poll();\n\t\t\t\tif(closed.get(st) != null) continue;\n\t\t\t\tclosed.put(st, st);\n\t\t\t\tif(st.ans(w,h)){\n\t\t\t\t\tans = st.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.addAll(st.nexts(map,cost));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass State implements Comparable< State >{\n\tint cost;\n\tRobot robot;\n\n\tpublic State(int cost, Robot robot){\n\t\tthis.cost = cost;\n\t\tthis.robot = robot;\n\t}\n\n\tpublic List<State> nexts(int[][] map, int cost[]){\n\t\tList<State> next = new ArrayList<State>();\n\t\tint turn = map[this.robot.p.y][this.robot.p.x];\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tRobot r = this.robot.copy();\n\t\t\tif(r.move(i,map)){\n\t\t\t\tint c = this.cost;\n\t\t\t\tif(turn != i){\n\t\t\t\t\tc += cost[i];\n\t\t\t\t}\n\t\t\t\tnext.add(new State(c, r));\n\t\t\t}\n\t\t}\n\n\t\treturn next;\n\t}\n\n\tpublic boolean ans(int w, int h){\n\t\tif(robot.p.x == w-1 && robot.p.y == h-1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object anObject){\n\t\tState st = (State)anObject;\n\t\treturn this.robot.p.equals(st.robot.p) && this.robot.d==st.robot.d;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn robot.p.x + robot.p.y;\n\t}\n}\n\nclass Robot{\n\tint d;\n\tPoint p;\n\n\tpublic Robot(int d, int x, int y){\n\t\tthis.d = d;\n\t\tthis.p = new Point(x,y);\n\t}\n\n\tpublic boolean move(int turn, int[][] map){\n\t\tint w = map[0].length;\n\t\tint h = map.length;\n\n\t\td = (d+turn) % 4;\n\n\t\tswitch(d){\n\t\tcase 0: p.y--; break;\n\t\tcase 1: p.x++; break;\n\t\tcase 2: p.y++; break;\n\t\tcase 3: p.x--; break;\n\t\t}\n\n\t\tif(p.x < 0) return false;\n\t\tif(p.x >= w) return false;\n\t\tif(p.y < 0) return false;\n\t\tif(p.y >= h) return false;\n\n\t\treturn true;\n\t}\n\n\tpublic Robot copy(){\n\t\tRobot copy = new Robot(d, p.x, p.y);\n\t\treturn copy;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class TwirlingRobot {\n\tScanner in = new Scanner(System.in);\n\tint n, m;\n\tint[][][] dp;\n\tint[][] map;\n\tint[] cost;\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, 1, 0, -1};\n\t\n\tvoid dijkstra(int dir, int x, int y) {\n\t\tif (dp[dir][y][x] == -1) return;\n\t\t//debug(dir);\n\t\tint order = map[y-1][x-1];\n\t\tint go = (order == 4) ? -1 : (order + dir) % 4;\n\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\tint nx = x + vx[i], ny = y + vy[i];\n\t\t\tint c = (go == i) ? 0 : cost[(i - dir + 4) % 4];\n\t\t\tif (dp[dir][y][x] != Integer.MAX_VALUE && dp[i][ny][nx] > dp[dir][y][x] + c) {\n\t\t\t\tdp[i][ny][nx] = dp[dir][y][x] + c;\n\t\t\t\tdijkstra(i, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tm = in.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\n\t\t\tmap = new int[m][n];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost = new int[4];\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tcost[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdp = new int[4][m+2][n+2];\t\t\t\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dp[i][j].length; k++) {\n\t\t\t\t\t\tif (j == 0 || j == m + 1 || k == 0 || k == n + 1) \n\t\t\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tdp[0][1][1] = 0;\n\t\t\tdijkstra(0, 1, 1);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t//debug(i);\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tres = Math.min(res, dp[i][m][n]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(int i) {\n\t\tSystem.out.println(\"dir = \" + i);\n\t\tfor (int j = 1; j < dp[i].length - 1; j++) {\n\t\t\tfor (int k = 1; k < dp[i][j].length - 1; k++) {\n\t\t\t\tSystem.out.print((dp[i][j][k] == Integer.MAX_VALUE ? \"F\" : dp[i][j][k]) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew TwirlingRobot().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint n, m;\n\tint[][][] dp;\n\tint[][] map;\n\tint[] cost;\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, 1, 0, -1};\n\t\n\tvoid dijkstra(int dir, int x, int y) {\n\t\tif (dp[dir][y][x] == -1) return;\n\t\t//debug(dir);\n\t\tint order = map[y-1][x-1];\n\t\tint go = (order == 4) ? -1 : (order + dir) % 4;\n\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\tint nx = x + vx[i], ny = y + vy[i];\n\t\t\tint c = (go == i) ? 0 : cost[(i - dir + 4) % 4];\n\t\t\tif (dp[dir][y][x] != Integer.MAX_VALUE && dp[i][ny][nx] > dp[dir][y][x] + c) {\n\t\t\t\tdp[i][ny][nx] = dp[dir][y][x] + c;\n\t\t\t\tdijkstra(i, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tm = in.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\n\t\t\tmap = new int[m][n];\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost = new int[4];\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tcost[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdp = new int[4][m+2][n+2];\t\t\t\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < dp[i][j].length; k++) {\n\t\t\t\t\t\tif (j == 0 || j == m + 1 || k == 0 || k == n + 1) \n\t\t\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tdp[0][1][1] = 0;\n\t\t\tdijkstra(0, 1, 1);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t//debug(i);\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tres = Math.min(res, dp[i][m][n]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(int i) {\n\t\tSystem.out.println(\"dir = \" + i);\n\t\tfor (int j = 1; j < dp[i].length - 1; j++) {\n\t\t\tfor (int k = 1; k < dp[i][j].length - 1; k++) {\n\t\t\t\tSystem.out.print((dp[i][j][k] == Integer.MAX_VALUE ? \"F\" : dp[i][j][k]) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint m, n;\n\tint[][] a;\n\tint[] c;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=new int[4];\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tc[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint[][][] d=new int[n][m][4];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tfill(d[j][i], INF);\n\t\t\t}\n\t\t}\n\t\tint[] dx={1, 0, -1, 0};\n\t\tint[] dy={0, 1, 0, -1};\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tque.offer(new P(0, 0, 0));\n\t\td[0][0][0]=0;\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(p.d>d[p.y][p.x][p.v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] cost=c.clone();\n\t\t\tif(a[p.y][p.x]!=4){\n\t\t\t\tcost[a[p.y][p.x]]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x, p.y, (p.v+i)%4);\n\t\t\t\tq.x+=dx[q.v];\n\t\t\t\tq.y+=dy[q.v];\n\t\t\t\tif(q.x<0||q.x>=m||q.y<0||q.y>=n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(d[q.y][q.x][q.v]>d[p.y][p.x][p.v]+cost[i]){\n\t\t\t\t\tq.d=d[q.y][q.x][q.v]=d[p.y][p.x][p.v]+cost[i];\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t// debug(j, i, d[j][i]);\n\t\t\t}\n\t\t}\n\t\t// debug(d[n-1][m-1]);\n\t\tint ans=INF;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tans=min(ans, d[n-1][m-1][i]);\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint x, y, v;\n\t\tint d;\n\n\t\tP(int x, int y, int v){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.v=v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\treturn d-p.d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Twirling Robot\npublic class Main{\n\n\tstatic int[][][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint[] cost = new int[4];\n\t\t\tfor(int i=0;i<4;i++)cost[i]=sc.nextInt();\n\t\t\tdist = new int[h][w][4];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<4;k++)dist[i][j][k]=Integer.MAX_VALUE;\n\t\t\tdist[0][0][1] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]] - dist[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0, 0, 1});\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tint d = a[2];\n\t\t\t\tif(i==h-1&&j==w-1){\n\t\t\t\t\tmin = Math.min(min, dist[i][j][d]);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nd = (d+k)%4;\n\t\t\t\t\tint ni = i + move[nd][0];\n\t\t\t\t\tint nj = j + move[nd][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\t\tint c = dist[i][j][d] + (m[i][j]==k?0:cost[k]);\n\t\t\t\t\t\tif(c < dist[ni][nj][nd]){\n\t\t\t\t\t\t\tdist[ni][nj][nd] = c;\n\t\t\t\t\t\t\tq.add(new int[]{ni, nj, nd});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint w;\n\tint h;\n\tint[][] s;\n\tint[][][] dis;\n\n\tint cs[];\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tfinal int INF = 1 << 29;\n\n\tboolean init() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tif ((h | w) == 0)\n\t\t\treturn false;\n\t\ts = new int[w][h];\n\t\tdis = new int[w][h][4];\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(dis[i][j], INF);\n\t\t\t}\n\t\t}\n\t\tcs = new int[5];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ts[j][i] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\tcs[4] = 0;\n\t\treturn true;\n\t}\n\n\tvoid run() {\n\t\twhile (init()) {\n\t\t\tdis[0][0][0] = 0;\n\t\t\twhile (true) {\n\t\t\t\tboolean update = false;\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\t\t\t\t// コマンド0,1,2,3orパネルの命令\n\t\t\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\t\t\tint nd = ((i != 4 ? i : s[x][y]) + d) % 4;\n\t\t\t\t\t\t\t\tif (nd == 4)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tint nx = x + dx[nd];\n\t\t\t\t\t\t\t\tint ny = y + dy[nd];\n\t\t\t\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (dis[x][y][d] != INF\n\t\t\t\t\t\t\t\t\t\t&& dis[nx][ny][nd] > dis[x][y][d]\n\t\t\t\t\t\t\t\t\t\t\t\t+ cs[i]) {\n\t\t\t\t\t\t\t\t\tdis[nx][ny][nd] = dis[x][y][d] + cs[i];\n\t\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!update)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(dis[w - 1][h - 1][2],\n\t\t\t\t\tdis[w - 1][h - 1][0]));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint w, h;\n\tint[][] f;\n\tint[] cost;\n\n\tint STRAIGHT = 0;\n\tint RIGHT = 1;\n\tint BACK = 2;\n\tint LEFT = 3;\n\tint HALT = 4;\n\n\tint EAST = 0;\n\tint SOUTH = 1;\n\tint WEST = 2;\n\tint NORTH = 3;\n\n\tclass D implements Comparable<D> {\n\t\tint x, y;\n\t\tint dir;\n\t\tint min;\n\t\tD par;\n\n\t\tD(int x, int y, int dir, int min) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.dir = dir;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\tD(int x, int y, int dir, int min, D par) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.dir = dir;\n\t\t\tthis.min = min;\n\t\t\tthis.par = par;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.x != o.x) {\n\t\t\t\treturn this.x - o.x;\n\t\t\t}\n\t\t\tif (this.y != o.y) {\n\t\t\t\treturn this.y - o.y;\n\t\t\t}\n\t\t\tif (this.dir != o.dir) {\n\t\t\t\treturn this.dir - o.dir;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \", \" + y + \"), dir = \" + dir + \", cost = \" + min;\n\t\t}\n\t}\n\n\tD dijkstra() {\n\t\tPriorityQueue<D> que = new PriorityQueue<D>();\n\t\tque.add(new D(0, 0, EAST, 0, null));\n\t\tint[] dx = new int[4];\n\t\tint[] dy = new int[4];\n\t\tdx[EAST] = 1;\n\t\tdx[WEST] = -1;\n\t\tdy[NORTH] = -1;\n\t\tdy[SOUTH] = 1;\n\t\tboolean[][][] vis = new boolean[w][h][4];\n\n\t\twhile (!que.isEmpty()) {\n\t\t\tD d = que.poll();\n\t\t\tint x = d.x;\n\t\t\tint y = d.y;\n\t\t\tint dir = d.dir;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[x][y][dir]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[x][y][dir] = true;\n\t\t\tif (x == w - 1 && y == h - 1) {\n\t\t\t\t// return min;\n\t\t\t\treturn d;\n\t\t\t}\n\n\t\t\tint o = f[y][x];\n\t\t\tif (o != 4) {\n\t\t\t\tint ndir = (dir + o) % 4;\n\t\t\t\tint nx = x + dx[ndir];\n\t\t\t\tint ny = y + dy[ndir];\n\t\t\t\tif (!(nx < 0 || w <= nx || ny < 0 || h <= ny)) {\n\t\t\t\t\tif (!vis[nx][ny][ndir]) {\n\t\t\t\t\t\tque.add(new D(nx, ny, ndir, min, d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ndir = (dir + i) % 4;\n\t\t\t\tint nx = x + dx[ndir];\n\t\t\t\tint ny = y + dy[ndir];\n\t\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint nmin = min + cost[i];\n\t\t\t\tif (!vis[nx][ny][ndir]) {\n\t\t\t\t\tque.add(new D(nx, ny, ndir, nmin, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// return -1;\n\t\treturn null;\n\t}\n\n\tvoid print(D d) {\n\t\tif (d == null) {\n\t\t\treturn;\n\t\t}\n\t\tprint(d.par);\n\t\tSystem.out.println(d);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tf[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost = new int[4];\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tD ans = dijkstra();\n\t\t\tSystem.out.println(ans.min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tint[][] map;\n\tint[] pen;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) { \n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tpen = new int[4];\n\t\t\tfor(int i=0;i<4;i++) pen[i] = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\t\n\tint[] dx = {-1,0,1,0};\n\tint[] dy = {0,-1,0,1};\n\t\n\tint dijkstra() {\n\t\tPriorityQueue<E> que = new PriorityQueue<E>();\n\t\tint[][][] c = new int[h][w][4];\n\t\tque.add(new E( new P(0,0,2), 0));\n\t\tfor(int[][] a: c) for(int[] b: a) fill(b, INF);\n\t\tc[0][0][2] = 0;\n\t\t\n\t\tfor(;;) {\n\t\t\tE now = que.poll();\n\t\t\tP p = now.p;\n\t\t\tif( isG(p) ) return now.c;\n\t\t\tif( c[p.y][p.x][p.d] != now.c ) continue;\n\t\t\t\n\t\t\tfor(int d=0;d<4;d++) {\n\t\t\t\tint nd = (d + p.d) % 4;\n\t\t\t\tint nx = p.x + dx[nd];\n\t\t\t\tint ny = p.y + dy[nd];\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tint nc = now.c + (map[p.y][p.x] == d? 0: pen[d]);\n\t\t\t\tif( c[ny][nx][nd] > nc ) {\n\t\t\t\t\tc[ny][nx][nd] = nc;\n\t\t\t\t\tque.add(new E(new P(nx, ny, nd), nc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tboolean isG(P p) {\n\t\treturn p.x == w-1 && p.y == h-1;\n\t}\n\t\n\tclass P {\n\t\tint x, y, d;\n\t\tP(int x, int y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\tclass E implements Comparable<E> {\n\t\tP p;\n\t\tint c;\n\t\tE( P p, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c - o.c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ1158().doit();\n\t}\n\n\tclass AOJ1158{\n\t\tint w,h;\n\t\tint[][] controll;\n\t\tint[] cost;\n\t\tPoint2D go(int x,int y,int muki){\n\t\t\tPoint2D result = new Point2D.Double();\n\t\t\tif(muki==0)result = new Point2D.Double(x,y-1);\n\t\t\telse if(muki==1)result = new Point2D.Double(x+1, y);\n\t\t\telse if(muki==2)result = new Point2D.Double(x, y+1);\n\t\t\telse if(muki==3)result = new Point2D.Double(x-1, y);\n\t\t\treturn result;\n\t\t}\n\n\t\tint solve(){\n\t\t\tint result = 0;\n\t\t\tint[][][] map = new int[31][31][4];\n\t\t\tfor(int i=0;i<31;i++)for(int s=0;s<31;s++)Arrays.fill(map[i][s],Integer.MAX_VALUE/2);\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tq.add(new State(0, 0, 1, 0));\n\t\t\tmap[0][0][1] = 0;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tint x = now.x;\n\t\t\t\tint y = now.y;\n\t\t\t\tint muki = now.muki;\n\t\t\t\t//              System.out.println(x+\" \"+y+\" \"+muki+\" \"+now.step);\n\t\t\t\t//                if(map[y][x][muki]<now.step)continue;\n\t\t\t\t//                map[y][x][muki] = now.step;\n\t\t\t\t//床の命令に従った場合\n\t\t\t\tint c = controll[y][x];\n\t\t\t\tPoint2D np = new Point2D.Double(x,y);\n\t\t\t\tint nmuki = 0;\n\t\t\t\tif(c==0){\n\t\t\t\t\tnmuki = (muki+0)%4;\n\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t}else if(c==1){\n\t\t\t\t\tnmuki = (muki+1)%4;\n\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t}else if(c==2){\n\t\t\t\t\tnmuki = (muki+2)%4;\n\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t}else if(c==3){\n\t\t\t\t\tnmuki = (muki+3)%4;\n\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t}else if(c==4){\n\t\t\t\t\tif(x==w-1&&y==h-1){\n\t\t\t\t\t\tresult = now.step;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnmuki = muki;\n\t\t\t\t}\n\t\t\t\tint nx = (int)np.getX();\n\t\t\t\tint ny = (int)np.getY();\n\t\t\t\tif((nx<0||nx>=w||ny<0||ny>=h)==false){\n\t\t\t\t\tif(now.step < map[ny][nx][nmuki]){\n\t\t\t\t\t\tq.add(new State(nx, ny, nmuki, now.step));\n\t\t\t\t\t\tmap[ny][nx][nmuki] = now.step;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//自分で動く場合\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tnmuki = 0;\n\t\t\t\t\tif(i==0){//直進\n\t\t\t\t\t\tnmuki = (muki+0)%4;\n\t\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t\t\t//                        System.out.println(np+\" \"+nmuki+\" \"+muki);\n\t\t\t\t\t}else if(i==1){//右折\n\t\t\t\t\t\tnmuki = (muki+1)%4;\n\t\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t\t}else if(i==2){//反転\n\t\t\t\t\t\tnmuki = (muki+2)%4;\n\t\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t\t}else if(i==3){//左折\n\t\t\t\t\t\tnmuki = (muki+3)%4;\n\t\t\t\t\t\tnp = go(x, y, nmuki);\n\t\t\t\t\t}\n\t\t\t\t\tnx = (int)np.getX();\n\t\t\t\t\tny = (int)np.getY();\n\t\t\t\t\t//                  System.out.println(nx+\" \"+ny+\" \"+nmuki);\n\t\t\t\t\tif((nx<0||nx>=w||ny<0||ny>=h)==false){\n\t\t\t\t\t\tif(now.step + cost[i] < map[ny][nx][nmuki]) {\n\t\t\t\t\t\t\t//                        System.out.println(\"B: \" + nx+\" \"+ny+\" \"+nmuki+\" \"+now.step+\" \"+cost[i]+\" \"+i + \" \" + map[ny][nx][nmuki]);\n\t\t\t\t\t\t\tq.add(new State(nx, ny, nmuki, now.step+cost[i]));\n\t\t\t\t\t\t\tmap[ny][nx][nmuki] = now.step + cost[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//            System.out.println(\"上\");\n\t\t\t//            for(int i=0;i<h;i++){\n\t\t\t//                for(int s=0;s<w;s++)System.out.printf(map[i][s][0]+\" \");\n\t\t\t//                System.out.println();\n\t\t\t//            }\n\t\t\t//            System.out.println(\"右\");\n\t\t\t//            for(int i=0;i<h;i++){\n\t\t\t//                for(int s=0;s<w;s++)System.out.print(map[i][s][1]+\" \");\n\t\t\t//                System.out.println();\n\t\t\t//            }\n\t\t\t//            System.out.println(\"下\");\n\t\t\t//            for(int i=0;i<h;i++){\n\t\t\t//                for(int s=0;s<w;s++)System.out.print(map[i][s][2]+\" \");\n\t\t\t//                System.out.println();\n\t\t\t//            }\n\t\t\t//            System.out.println(\"左\");\n\t\t\t//            for(int i=0;i<h;i++){\n\t\t\t//                for(int s=0;s<w;s++)System.out.print(map[i][s][3]+\" \");\n\t\t\t//                System.out.println();\n\t\t\t//            }\n\t\t\treturn result;\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,muki,step;\n\t\t\tpublic State(int x,int y,int muki,int step) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.muki = muki;\n\t\t\t\tthis.step = step;\n\t\t\t}\n\t\t\tpublic int compareTo(State arg0) {\n\t\t\t\treturn this.step - arg0.step;\n\t\t\t}\n\t\t}\n\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tw = in.nextInt();\n\t\t\t\th = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tcontroll = new int[h][w];\n\t\t\t\tcost = new int[4];//直進、右折、反転、左折\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)controll[i][s] = in.nextInt();\n\t\t\t\tfor(int i=0;i<4;i++)cost[i] = in.nextInt();\n\n\t\t\t\tint ans = solve();\n\t\t\t\t//System.out.print(\"Answer= \" );\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\t//break;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*; \n \npublic class Main\n{\n\tpublic static void main(String args[]) throws Exception{\n\t\tnew Main().run();\n\t}\n\t\n\n\tint w,h;\n\t\n\tpublic void run()\n\t{\n\t\tint i,j,k,l;\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\t//ツ陳シツ進ツ　ツ右ツ静慊　ツ板スツ転\t ツ債カツ静慊　ツ津「ツ止\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w==0 && h ==0) break;\n\t\t\tint board[][] = new int[h][w];\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tboard[i][j] = cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] cost = new int[4];\n\t\t\tint MAXCOST = 99999999;\n\t\t\tint[][][] dp = new int[h][w][4];\n\t\t\tboolean[][][] flag = new boolean[h][w][4];\n\t\t\tflag[0][0][0] = true;\n\t\t\tfor(i=0;i<4;i++) cost[i] = cin.nextInt();\n\t\t\tint vx[] = {1,0,-1,0};\n\t\t\tint vy[] = {0,1,0,-1};\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tdp[i][j][k] = MAXCOST;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][0][0] = 0;\n\t\t\twhile(true){\n\t\t\t\tboolean loopflag = false;\n\t\t\t\tfor(i=0;i<h;i++){\n\t\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tif(!flag[i][j][k]) continue;\n\t\t\t\t\t\t\tfor(l=0;l<4;l++){\n\t\t\t\t\t\t\t\tint addcost = cost[l];\n\t\t\t\t\t\t\t\tint nextk = k;\n\t\t\t\t\t\t\t\tif(board[i][j] == l) addcost = 0;\n\t\t\t\t\t\t\t\tnextk = (k + l)%4;\n\t\t\t\t\t\t\t\tint nexty = i + vy[nextk];\n\t\t\t\t\t\t\t\tint nextx = j + vx[nextk];\n\t\t\t\t\t\t\t\tif(ok(nexty,nextx)){\n\t\t\t\t\t\t\t\t\tif(dp[nexty][nextx][nextk] > dp[i][j][k] + addcost){\n\t\t\t\t\t\t\t\t\t\tdp[nexty][nextx][nextk] = dp[i][j][k] + addcost;\n\t\t\t\t\t\t\t\t\t\tloopflag = flag[nexty][nextx][nextk] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!loopflag) break;\n\t\t\t}\n\t\t\tint res = MAXCOST; \n\t\t\tfor(k=0;k<4;k++) res = Math.min(res, dp[h-1][w-1][k]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tboolean ok(int y, int x){\n\t\treturn x>=0 && y>=0 && x<w && y<h;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint W, H;\n\tint[][] map;\n\tint[][][] dist;\n\tint[] cost = new int[4];\n\tPriorityQueue<State> pq;\n\t\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, 1, 0, -1};\n\t\n\tclass State implements Comparable<State> {\n\t\tint x, y, d;\n\t\t\n\t\tpublic State(int x, int y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State s) {\n\t\t\tint d1 = dist[y][x][d], d2 = dist[s.y][s.x][s.d];\n\t\t\tif (d1 < d2) return -1;\n\t\t\telse if (d1 > d2) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra() {\n\t\tif (pq.isEmpty()) return;\n\t\tState s = pq.poll();\n\t\tint cmd = map[s.y][s.x];\n\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\tint c = (cmd == i) ? 0 : cost[i];\n\t\t\tint dir = (s.d + i) % 4;\n\t\t\tint nx = s.x + vx[dir], ny = s.y + vy[dir];\n\t\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H) {\n\t\t\t\tif (dist[ny][nx][dir] > dist[s.y][s.x][s.d] + c) {\n\t\t\t\t\tdist[ny][nx][dir] = dist[s.y][s.x][s.d] + c;\n\t\t\t\t\tpq.add(new State(nx, ny, dir));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra();\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tW = in.nextInt();\n\t\t\tH = in.nextInt();\n\t\t\tif ((W|H) == 0) break;\n\t\t\tmap = new int[H][W];\n\t\t\tdist = new int[H][W][4];\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = in.nextInt();\n\t\t\t\t\tArrays.fill(dist[i][j], Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) \n\t\t\t\tcost[i] = in.nextInt();\n\t\t\t\n\t\t\tpq = new PriorityQueue<State>();\n\t\t\tdist[0][0][0] = 0;\n\t\t\tpq.add(new State(0, 0, 0));\n\t\t\t\n\t\t\tdijkstra();\n\t\t\t\n\t\t\tSystem.out.println(Math.min(dist[H-1][W-1][0], dist[H-1][W-1][1]));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOJ1158().doit();\n\t}\n\n\tclass AOJ1158{\n\t\tint w,h;\n\t\tint[][] controll;\n\t\tint[] cost;\n\t\tPoint2D go(int x,int y,int muki){\n\t\t\tPoint2D result = new Point2D.Double();\n\t\t\tif(muki==0)result = new Point2D.Double(x,y-1);\n\t\t\telse if(muki==1)result = new Point2D.Double(x+1, y);\n\t\t\telse if(muki==2)result = new Point2D.Double(x, y+1);\n\t\t\telse if(muki==3)result = new Point2D.Double(x-1, y);\n\t\t\treturn result;\n\t\t}\n\n\t\tint solve(){\n\t\t\tint result = 0;\n\t\t\tint[][][] map = new int[31][31][4];\n\t\t\tfor(int i=0;i<31;i++)for(int s=0;s<31;s++)Arrays.fill(map[i][s],Integer.MAX_VALUE/2);\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tq.add(new State(0, 0, 1, 0));\n\t\t\tmap[0][0][1] = 0;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tint x = now.x;\n\t\t\t\tint y = now.y;\n\t\t\t\tint muki = now.muki;\n\t\t\t\tif(x==w-1&&y==h-1){\n\t\t\t\t\tresult = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[y][x][muki] <= now.step)continue;\n\t\t\t\tfor(int i=0;i<4;i++){//0=直進,1=右折,2=反転,3=左折\n\t\t\t\t\tint nmuki = (muki+i)%4;\n\t\t\t\t\tPoint2D nxy = go(x, y, nmuki);\n\t\t\t\t\tint nx = (int)nxy.getX();\n\t\t\t\t\tint ny = (int)nxy.getY();\n\t\t\t\t\tint nstep = now.step;\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\t\tif(controll[ny][nx]!=i)nstep += cost[i];\n\t\t\t\t\tif(map[ny][nx][nmuki]<=nstep)continue;\n\t\t\t\t\tmap[ny][nx][nmuki] = nstep;\n\t\t\t\t\tq.add(new State(nx, ny, nmuki, nstep));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,muki,step;\n\t\t\tpublic State(int x,int y,int muki,int step) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.muki = muki;\n\t\t\t\tthis.step = step;\n\t\t\t}\n\t\t\tpublic int compareTo(State arg0) {\n\t\t\t\treturn this.step - arg0.step;\n\t\t\t}\n\t\t}\n\n\t\tvoid doit(){\n\t\t\twhile(true){\n\t\t\t\tw = in.nextInt();\n\t\t\t\th = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tcontroll = new int[h][w];\n\t\t\t\tcost = new int[4];//直進、右折、反転、左折\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)controll[i][s] = in.nextInt();\n\t\t\t\tfor(int i=0;i<4;i++)cost[i] = in.nextInt();\n\n\t\t\t\tint ans = solve();\n\t\t\t\t//System.out.print(\"Answer= \" );\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\t//break;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\n\npublic class Main {\n\tstatic int INF = 2 << 27;\n\tstatic int[] vx = {1,0,-1,0};\n\tstatic int[] vy = {0,1,0,-1};\n\tstatic int[] vd = {0,1,2,3};\n\tpublic static void main(String[] args) {\t\n\t\t//FastScanner sc = new FastScanner();\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif(W == 0 && H == 0) break;\n\t\t\tint[][] map = new int[H][W];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] cost = new int[4];\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcost[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][][] memo = new int[H][W][4];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t\tArrays.fill(memo[i][j], 2 << 28);\n\t\t\t}\n\t\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\t\tq.add(new Data(0,0,0,0));\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tData p = q.poll();\n\t\t\t\tint h = p.h;\n\t\t\t\tint w = p.w;\n\t\t\t\tif(memo[h][w][p.dir%4] <= p.cost) continue;\n\t\t\t\tmemo[h][w][p.dir%4] = p.cost;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tint td = (p.dir + vd[i]) % 4;\n\t\t\t\t\tint th = h + vy[td];\n\t\t\t\t\tint tw = w + vx[td];\n\t\t\t\t\tif(th < 0 || tw < 0 || th >= H || tw >= W) continue;\n\t\t\t\t\tif(map[h][w] == i) {\n\t\t\t\t\t\tq.add(new Data(th,tw,td,p.cost));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tq.add(new Data(th,tw,td,p.cost + cost[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MIN = 2 << 28;\n\t\t\tfor(int k = 0; k < 4; k++) MIN = Math.min(MIN, memo[H-1][W-1][k]);\n\n\t\t\tSystem.out.println(MIN);\n\t\t\t\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data> {\n\t\t\n\t\tint h;\n\t\tint w;\n\t\tint dir;\n\t\tint cost;\n\t\tData(int a, int b, int c, int e) {\n\t\t\th = a;\n\t\t\tw = b;\n\t\t\tdir = c;\n\t\t\tcost = e;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn o.cost - this.cost;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing static System.Math;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\n\npublic class Edge\n{\n    public int to { get; set; }\n    public long d { get; set; }\n}\npublic class Node : IComparable\n{\n    public int id { get; set; }\n    public long d { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (Node)obj;\n        if (this.d > x.d) return 1;\n        else if (this.d == x.d) return 0;\n        else return -1;\n    }\n}\n\npublic class hello\n{\n    public static int h, w, hw;\n    public static int[] dx, dy;\n\n    public static void Main()\n    {\n        dx = new int[] { 0, 1, 0, -1 };\n        dy = new int[] { 1, 0, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            w = int.Parse(line[0]);\n            h = int.Parse(line[1]);\n            hw = h * w;\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line[j]);\n            }\n            var cost = new int[4];\n            line = Console.ReadLine().Trim().Split(' ');\n            for (int i = 0; i < 4; i++) cost[i] = int.Parse(line[i]);\n            var aa = getEdge(map, cost);\n            var mind = new long[hw * 4];\n            for (int i = 0; i < hw * 4; i++) mind[i] = 9999999999999;\n            var pq = new PriorityQueue<Node>(hw * 8 + 100000, 0);\n            goDijk(pq, aa, 0, hw * 4, mind);\n            var ans = 9999999999999;\n            for (int i = 0; i < 4; i++)\n            {\n                var tt = getNode(h - 1, w - 1, i);\n                ans = Min(ans, mind[tt]);\n            }\n            Console.WriteLine(ans);\n        }\n    }\n    static List<Edge>[] getEdge(int[,] map, int[] cost)\n    {\n        var cn = new int[4, 4] { { 2, 1, 0, 3 }, { 3, 2, 1, 0 }, { 0, 3, 2, 1 }, { 1, 0, 3, 2 } };\n        var gnum = new int[] { 2, 3, 0, 1 };\n        var a = new List<Edge>[hw * 4];\n        for (int i = 0; i < hw * 4; i++) a[i] = new List<Edge>();\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n                for (int k = 0; k < 4; k++)\n                {\n                    var prex = i + dx[k];\n                    var prey = j + dy[k];\n                    if (!(prex >= 0 && prex < h && prey >= 0 && prey < w)) continue;\n                    var premap = map[prex, prey];\n                    for (int L = 0; L < 4; L++)\n                    {\n                        var prenode = getNode(prex, prey, L);\n                        var cnt = cn[k,L];\n                        var ncost = cost[cnt];\n                        if (premap == cnt) ncost = 0;\n                        var newnode = getNode(i, j, gnum[k]);\n                        a[prenode].Add(new Edge { to = newnode, d = ncost });\n                    }\n                }\n        return a;\n    }\n    static int getNode(int x, int y, int dir) => w * x + y + dir * h * w;\n\n    static void goDijk(PriorityQueue<Node> pq, List<Edge>[] aa, int r, int n, long[] mind)\n    {\n        pq.Push(new Node { id = r, d = 0 });\n        while (pq.Count() > 0)\n        {\n            var targ = pq.Pop();\n            var nowd = targ.d;\n            var nowid = targ.id;\n            if (mind[nowid] < nowd) continue;\n            mind[nowid] = nowd;\n            foreach (var x in aa[nowid])\n                if (nowd + x.d < mind[x.to])\n                {\n                    mind[x.to] = nowd + x.d;\n                    pq.Push(new Node { id = x.to, d = nowd + x.d });\n                }\n\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start, setting = {})\n\t\traise \"invalid setting\" if setting.class != Hash\n\t\traise \"invalid setting\" if setting.keys - [:goal, :multi_source, :multi_sink, :max_dist] != []\n\t\t\n\t\tstart = Set[start] if !setting[:multi_source]\n\t\tgoal = setting[:goal]\n\t\tgoal = Set[goal] if goal && !setting[:multi_sink]\n\t\tmax_dist = setting[:max_dist]\n\n\t\th = Heap.new\n\t\treached = Set.new\n\t\tstart.each{|v|\n\t\t\th.add(v, 0)\n\t\t\treached << v\n\t\t}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if setting[:goal] && goal.include?(u)\n\t\t\tbreak if max_dist && key > max_dist\n\t\t\tdist[u] = key\n\t\t\teach_to_node_of(u){|v|\n\t\t\t\td = dist[u] + edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tgoal ? nil : dist\n\tend\n\nend\n\n\nloop {\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\ta = (1..h).map{ gets.split.map &:to_i }\n\t$command = gets.split.map &:to_i\n\n\ta.extend Graphical\n\n\tdef a.each_to_node_of(u)\n\t\ty, x, dir = u\n\t\tyield [y-1, x, 0] if y > 0\n\t\tyield [y, x+1, 1] if x < self[0].size-1\n\t\tyield [y+1, x, 2] if y < self.size-1\n\t\tyield [y, x-1, 3] if x > 0\n\tend\n\t\n\tdef a.edge_length(u, v)\n\t\ty1, x1, d1 = u\n\t\ty2, x2, d2 = v\n\t\tif self[y1][x1] == 4\n\t\t\t$command[(d2 - d1) % 4]\n\t\telsif self[y1][x1] == (d2 - d1) % 4\n\t\t\t0\n\t\telse\n\t\t\t$command[(d2 - d1) % 4]\n\t\tend\n\tend\n\n\tp a.dijkstra([0, 0, 1], {\n\t\t:goal => (0..3).map{|dir| [h-1, w-1, dir]},\n\t\t:multi_sink => true\n\t\t})\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\nDXYS = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\nC_STRAIGHT = 0\nC_RIGHT = 1\nC_BACK = 2\nC_LEFT = 3\nC_HALT = 4\n\n### main\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if (w | h) == 0\n\n  brds = h.times.map{gets.split.map(&:to_i)}\n  costs = gets.split.map(&:to_i)\n  #p brds\n  #p costs\n\n  dists = h.times.map{w.times.map{4.times.map{INF}}}\n  dists[0][0][0] = 0\n  q = [[0, 0, 0]]\n\n  min_cost = INF\n  gx = w - 1\n  gy = h - 1\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a[1]][a[0]][a[2]] <=> dists[b[1]][b[0]][b[2]]}\n    q.delete(u)\n\n    ux, uy, ud = u\n    distu = dists[uy][ux][ud]\n    brdu = brds[uy][ux]\n\n    if ux == gx && uy == gy\n      min_cost = distu if min_cost > distu\n      next\n    end\n\n    for cmd in (0..3)\n      vd = (ud + cmd) & 3\n      dx, dy = DXYS[vd]\n      vx = ux + dx\n      vy = uy + dy\n\n      if vx >= 0 && vx < w && vy >= 0 && vy < h\n        cost = (brdu == cmd) ? 0 : costs[cmd]\n        distv = dists[vy][vx][vd]\n        ndistv = distu + cost\n\n        if distv > ndistv\n          q << [vx, vy, vd] if distv >= INF\n          dists[vy][vx][vd] = ndistv\n        end\n      end\n    end\n  end\n\n  puts min_cost\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nbool solve() {\n    auto s = readln.split.map!(to!int);\n    auto W = s[0];\n    auto H = s[1];\n    if (W == 0) return false;\n\n    auto A = H.iota.map!(_ => readln.split.map!(to!int).array).array;\n    auto C = readln.split.map!(to!int).array;\n\n    const int[] dr = [-1, 0, 1, 0]; // U, R, D, L\n    const int[] dc = [0, 1, 0, -1];\n\n\n    auto D = new int[][][](H, W, 4);\n    foreach (i; 0..H) foreach (j; 0..W) D[i][j][] = 1 << 29;\n\n    auto pq = new BinaryHeap!(Array!(Tuple!(int, int, int, int)), \"a[3] > b[3]\");\n    pq.insert(tuple(0, 0, 1, 0));\n\n    while (!pq.empty) {\n        auto r = pq.front[0];\n        auto c = pq.front[1];\n        auto dir = pq.front[2];\n        auto dist = pq.front[3];\n        pq.removeFront;\n        if (D[r][c][dir] <= dist) continue;\n        D[r][c][dir] = dist;\n\n        foreach (i; 0..4) {\n            auto nr = r + dr[(dir+i)%4];\n            auto nc = c + dc[(dir+i)%4];\n            auto ndir = (dir+i)%4;\n            auto ndist = i == A[r][c] ? dist : dist + C[i];\n            if (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;\n            if (D[nr][nc][ndir] <= ndist) continue;\n            pq.insert(tuple(nr, nc, ndir, ndist));\n        }\n    }\n\n    D[H-1][W-1].reduce!min.writeln;\n\n    return true;\n}\n\nvoid main() {\n    while (solve()) {}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\ndef main():\n  R, D, L, U = 0, 1, 2, 3\n  vector = ((1, 0), (0, 1), (-1, 0), (0, -1))\n  \n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n    mp = [[5] + list(map(int, input().split())) + [5] for _ in range(h)]\n    mp.insert(0, [5] * (w + 2))\n    mp.append([5] * (w + 2))\n    cost = list(map(int, input().split()))\n    que = []\n    heappush(que, (0, 1, 1, R))\n    dic = {}\n    dic[(1, 1, R)] = 0\n    while que:\n      total, x, y, direct = heappop(que)\n      ins = mp[y][x]\n      if ins == 5:\n        continue\n      if ins != 4:\n        new_direct = (direct + ins) % 4\n        vx, vy = vector[new_direct]\n        nx, ny = x + vx, y + vy\n        if not (nx, ny, new_direct) in dic or dic[nx, ny, new_direct] > total:\n          dic[(nx, ny, new_direct)] = total\n          heappush(que, (total, nx, ny, new_direct))\n  \n      for add_direct in range(4):\n        new_direct = (direct + add_direct) % 4\n        vx, vy = vector[new_direct]\n        nx, ny = x + vx, y + vy\n        if not (nx, ny, new_direct) in dic or dic[(nx, ny, new_direct)] > total + cost[add_direct]:\n          dic[(nx, ny, new_direct)] = total + cost[add_direct]\n          heappush(que, (total + cost[add_direct], nx, ny, new_direct))\n    print(min(dic[(w, h, D)], dic[(w, h, R)]))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n\n    while True:\n        w,h = LI()\n        if h == 0:\n            break\n        a = [LI() for _ in range(h)]\n        cs = LI()\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n                if u[0][0] == h-1 and u[0][1] == w-1:\n                    return d\n\n                for ui in range(4):\n                    ud = cs[ui]\n                    if a[u[0][0]][u[0][1]] == ui:\n                        ud = 0\n                    di,dj = dd[(u[1]+ui) % 4]\n                    ni = u[0][0] + di\n                    nj = u[0][1] + dj\n                    if ni < 0 or ni >= h or nj < 0 or nj >= w:\n                        continue\n                    uv = ((ni,nj), (u[1]+ui) % 4)\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n            return d\n\n        d = search(((0,0), 1))\n        r = inf\n        for i in range(4):\n            if r > d[((h-1,w-1),i)]:\n                r = d[((h-1,w-1),i)]\n        rr.append(r)\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\nclass Tuple:\n    def __init__(self, cost, y, x, dir):\n        self.cost = cost\n        self.y = y\n        self.x = x\n        self.dir = dir\n\n\n    def __cmp__(self, other):\n        return self.cost - other.cost\n\n\ndir_x = [1, 0, -1, 0]\ndir_y = [0, 1, 0, -1]\n\n\ndef solve():\n    X, Y = map(int, raw_input().split())\n    if X == 0 and Y == 0:\n        return -1\n\n    stage = [map(int, raw_input().split()) for _ in range(Y)]\n    C = map(int, raw_input().split())\n\n    costs = [[[float(\"inf\") for _ in xrange(4)] for _ in xrange(X)] for _ in xrange(Y)]\n\n    costs[0][0][0] = 0\n    queue = []\n\n    heapq.heappush(queue, Tuple(0, 0, 0, 0))\n\n    while len(queue) > 0:\n\n        current = heapq.heappop(queue)\n        if costs[current.y][current.x][current.dir] < current.cost:\n            continue\n\n        for operation in range(4):\n            if operation == 0:\n                # ????????? ?????£??´?????????\n\n                next_dir = current.dir\n            elif operation == 1:\n                # ????????? ??????\n\n                next_dir = (current.dir + 1) % 4\n            elif operation == 2:\n                # ????????? ?????¢\n\n                next_dir = (current.dir + 2) % 4\n            else:\n                # ????????? ??????\n\n                next_dir = (current.dir + 3) % 4\n            # ????????? ??´????????????????????¢?????????????????????????????????????????\\???????????¢??????????????????????????§???????????????\n\n            next_x = current.x + dir_x[next_dir]\n            next_y = current.y + dir_y[next_dir]\n            next_cost = costs[current.y][current.x][current.dir]\n            if stage[current.y][current.x] != operation:\n                next_cost += C[operation]\n            if 0 <= next_x < X and 0 <= next_y < Y:\n                if costs[next_y][next_x][next_dir] > next_cost:\n                    costs[next_y][next_x][next_dir] = next_cost\n                    data = Tuple(next_cost, next_y, next_x, next_dir)\n                    heapq.heappush(queue, data)\n\n    return min(costs[Y - 1][X - 1])\n\n\nif __name__ == '__main__':\n    while True:\n        result = solve()\n        if result < 0:\n            break\n\n        print result"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\ndef inpl(): return list(map(int, input().split()))\n\nW, H = inpl()\nINF = 10**6\n\nwhile W:\n    S = [[5]*(W+2)]\n    for _ in range(H):\n        S.append([5] + inpl() + [5])\n    S.append([5]*(W+2))\n    C = inpl()\n    D = [[0, -1], [1, 0], [0, 1], [-1, 0]]\n    E = [[[INF]*4 for _ in range(W+2)] for _ in range(H+2)]\n    E[1][1][1] = 0\n    Q = [[0, 1, (1, 1)]]\n    while Q:\n        e, d, (w, h) = heappop(Q)\n        order = S[h][w]\n        if e > E[h][w][d] or order == 5:\n            continue\n\n        dw, dh = D[d]\n        ne = e + C[0]*(order != 0)\n        if E[h+dh][w+dw][d] > ne:\n            E[h+dh][w+dw][d] = ne\n            heappush(Q, [ne, d, (w+dw, h+dh)])\n\n        nd = (d+1)%4\n        dw, dh = D[nd]\n        ne = e + C[1]*(order != 1)\n        if E[h+dh][w+dw][nd] > ne:\n            E[h+dh][w+dw][nd] = ne\n            heappush(Q, [ne, nd, (w+dw, h+dh)])\n\n        nd = (d+2)%4\n        dw, dh = D[nd]\n        ne = e + C[2]*(order != 2)\n        if E[h+dh][w+dw][nd] > ne:\n            E[h+dh][w+dw][nd] = ne\n            heappush(Q, [ne, nd, (w+dw, h+dh)])\n\n        nd = (d+3)%4\n        dw, dh = D[nd]\n        ne = e + C[3]*(order != 3)\n        if E[h+dh][w+dw][nd] > ne:\n            E[h+dh][w+dw][nd] = ne\n            heappush(Q, [ne, nd, (w+dw, h+dh)])\n\n    print(min(E[H][W]))\n    W, H = inpl()\n"
  },
  {
    "language": "Python",
    "code": "inf = 10**9\n\nwhile 1:\n    W,H = map(int,raw_input().split())\n    if W == 0: break\n    S = [map(int,raw_input().split()) for i in xrange(H)]\n    c = map(int,raw_input().split())\n\n    costs = [[[[inf]*W for i in xrange(H)] for j in xrange(3)] for k in xrange(3)]\n    costs[2][0][0][0] = 0\n    que = [[0,0,1,0,0]]\n    while que:\n        w,h,dw,dh,cost = que.pop(0)\n        if (w,h) == (W-1,H-1): continue\n        if costs[dw+1][dh+1][h][w] < cost: continue\n\n        dxy = [(dw,dh),(-dh,dw),(-dw,-dh),(dh,-dw)]\n\n        for i in xrange(4):\n            dx,dy = dxy[i]\n            nw,nh = w+dx,h+dy\n            if 0 <= nw < W and 0 <= nh < H:\n                ncost = cost+bool(i != S[h][w])*c[i]\n                if costs[dx+1][dy+1][nh][nw] <= ncost: continue\n                costs[dx+1][dy+1][nh][nw] = ncost\n                que.append([nw,nh,dx,dy,ncost])\n    print min(min(costs[i][j][H-1][W-1] for i in xrange(3)) for j in xrange(3))\n        "
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0:\n            break\n        board = [list(map(int, input().split())) for i in range(h)]\n        tmp = list(map(int, input().split()))\n        p_cost = [tmp[2], tmp[3], tmp[0], tmp[1]]\n        INF = int(1e5)\n        mincost = [[[INF] * 4 for i in range(w)] for j in range(h)]\n        q = deque()\n        q.append((0, 0, 0, 3))\n        while len(q) > 0:\n            x, y, cost, from_ = q.popleft()\n            # コストなしで進める方向\n            if board[y][x] == 0:# 直進: (from_ + 2) % 4\n                no_cost = (from_ + 2) % 4\n            elif board[y][x] == 1:# 右折: (from_ + 3) % 4\n                no_cost = (from_ + 3) % 4\n            elif board[y][x] == 2:# 反転: from_\n                no_cost = from_\n            elif board[y][x] == 3:# 左折: (from_ + 1) % 4\n                no_cost = (from_ + 1) % 4\n            else:# 停止: なし\n                no_cost = -1\n            for i, (nx, ny) in enumerate([(x, y-1), (x+1, y), (x, y+1), (x-1, y)]):\n                if i == no_cost:\n                    next_cost = cost\n                else:\n                    next_cost = cost + p_cost[(i+4-from_)%4]\n                if mincost[y][x][i] > next_cost:# 最小値を更新\n                    mincost[y][x][i] = next_cost\n                    # マスが存在する場合はqに入れる\n                    if 0 <= nx and nx < w and 0 <= ny and ny < h:\n                        q.append((nx, ny, next_cost, (i + 2) % 4))\n        # print(mincost)\n        print(min(mincost[h-2][w-1][2], mincost[h-1][w-2][1]))\n\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1156: Twirling Robot\n# Python3 2018.7.15 bal4u\n\nmv = [[-1,0,],[0,1],[1,0],[0,-1]]\n\nINF = 0x7fffffff\nimport heapq\ndef dijkstra(h, w, cost):\n\tQ = []\n\tnode = [[[INF for d in range(4)] for c in range(w)] for r in range(h)]\n\tnode[0][0][1] = 0\n\theapq.heappush(Q, (0, 0, 0, 1))\n\twhile Q:\n\t\tt, r, c, d = heapq.heappop(Q)\n\t\tif r == h-1 and c == w-1: break\n\t\tfor i in range(4):\n\t\t\tnd = (d+i)%4\n\t\t\tnr, nc = r + mv[nd][0], c + mv[nd][1]\n\t\t\tif nr < 0 or nr >= h or nc < 0 or nc >= w: continue\n\t\t\tnt = node[r][c][d]\n\t\t\tif arr[r][c] != i: nt += cost[i]\n\t\t\tif nt < node[nr][nc][nd]:\n\t\t\t\tnode[nr][nc][nd] = nt\n\t\t\t\theapq.heappush(Q, (nt, nr, nc, nd))\n\treturn node[h-1][w-1][d]\n\t\nwhile True:\n\tw, h = map(int, input().split())\n\tif w == 0: break\n\tarr = [[] for r in range(h)]\n\tfor r in range(h): arr[r] = list(map(int, input().split()))\n\tcost = list(map(int, input().split()))\n\tprint(dijkstra(h, w, cost))\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\nclass Tuple:\n    def __init__(self, cost, y, x, dir):\n        self.cost = cost\n        self.y = y\n        self.x = x\n        self.dir = dir\n\n    def __str__(self):\n        return \"y=\" + str(self.y) + \" : \" + \"x=\" + str(self.x) + \" : \" + \"dir=\" + str(self.dir)\n\n\ndir_x = [1, 0, -1, 0]\ndir_y = [0, 1, 0, -1]\n\n\ndef solve():\n    X, Y = map(int, raw_input().split())\n    if X == 0 and Y == 0:\n        return -1\n\n    stage = [map(int, raw_input().split()) for _ in range(Y)]\n    C = map(int, raw_input().split())\n\n    costs = [[[float(\"inf\") for _ in xrange(4)] for _ in xrange(X)] for _ in xrange(Y)]\n\n    costs[0][0][0] = 0\n    queue = []\n\n    heapq.heappush(queue, Tuple(0, 0, 0, 0))\n\n    while len(queue) > 0:\n\n        current = heapq.heappop(queue)\n        if costs[current.y][current.x][current.dir] < current.cost:\n            continue\n\n        for operation in range(4):\n            if operation == 0:\n                # ????????? ?????£??´?????????\n\n                next_dir = current.dir\n            elif operation == 1:\n                # ????????? ??????\n\n                next_dir = (current.dir + 1) % 4\n            elif operation == 2:\n                # ????????? ?????¢\n\n                next_dir = (current.dir + 2) % 4\n            else:\n                # ????????? ??????\n\n                next_dir = (current.dir + 3) % 4\n            # ????????? ??´????????????????????¢?????????????????????????????????????????\\???????????¢??????????????????????????§???????????????\n\n            next_x = current.x + dir_x[next_dir]\n            next_y = current.y + dir_y[next_dir]\n            next_cost = costs[current.y][current.x][current.dir]\n            if stage[current.y][current.x] != operation:\n                next_cost += C[operation]\n            if 0 <= next_x < X and 0 <= next_y < Y:\n                if costs[next_y][next_x][next_dir] > next_cost:\n                    costs[next_y][next_x][next_dir] = next_cost\n                    data = Tuple(next_cost, next_y, next_x, next_dir)\n                    heapq.heappush(queue, data)\n\n\n    return min(costs[Y - 1][X - 1])\n\nif __name__ == '__main__':\n    while True:\n        result = solve()\n        if result < 0:\n            break\n\n        print result"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef main():\n\n    w,h = 0,0\n    grid = []\n    c = []\n    inf = 1000000007\n    y = [0,1,0,-1]\n    x = [1,0,-1,0]\n\n    def inside(i,j):\n        return 0<=i and i<h and 0<=j and j<w\n\n    def solve():\n        d = [[[inf]*4 for _ in range(w)] for _ in range(h)]\n        d[0][0][0] = 0\n        pq = [[0,0,0,0]]\n        heapq.heapify(pq)\n        while pq:\n            ccost,cy,cx,cd = heapq.heappop(pq)\n            if d[cy][cx][cd] < ccost: continue\n            if cy==h-1 and cx==w-1:return ccost\n            for i in range(4):\n                nd = (cd+i)%4\n                ny = cy+y[nd]\n                nx = cx+x[nd]\n                if not inside(ny,nx):continue \n                if i == grid[cy][cx]:ncost = ccost\n                else                :ncost = ccost+c[i]\n                if ncost<d[ny][nx][nd]:\n                    d[ny][nx][nd] = ncost\n                    heapq.heappush(pq,[ncost,ny,nx,nd])\n        return inf\n\n    while True:\n        w,h = map(int,input().split())\n        if w == 0:break\n        grid = []\n        for i in range(h):\n            grid.append(list(map(int,input().split())))\n        c = list(map(int,input().split()))\n        print (solve())\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\nclass Tuple:\n    def __init__(self, cost, y, x, dir):\n        self.cost = cost\n        self.y = y\n        self.x = x\n        self.dir = dir\n\n    def __str__(self):\n        return \"y=\" + str(self.y) + \" : \" + \"x=\" + str(self.x) + \" : \" + \"dir=\" + str(self.dir)\n\n    def __cmp__(self, other):\n        return self.cost - other.cost\n\n\ndir_x = [1, 0, -1, 0]\ndir_y = [0, 1, 0, -1]\n\n\ndef solve():\n    X, Y = map(int, raw_input().split())\n    if X == 0 and Y == 0:\n        return -1\n\n    stage = [map(int, raw_input().split()) for _ in range(Y)]\n    C = map(int, raw_input().split())\n\n    costs = [[[float(\"inf\") for _ in xrange(4)] for _ in xrange(X)] for _ in xrange(Y)]\n\n    costs[0][0][0] = 0\n    queue = []\n\n    heapq.heappush(queue, Tuple(0, 0, 0, 0))\n\n    while len(queue) > 0:\n\n        current = heapq.heappop(queue)\n        if costs[current.y][current.x][current.dir] < current.cost:\n            continue\n\n        for operation in range(4):\n            if operation == 0:\n                # ????????? ?????£??´?????????\n\n                next_dir = current.dir\n            elif operation == 1:\n                # ????????? ??????\n\n                next_dir = (current.dir + 1) % 4\n            elif operation == 2:\n                # ????????? ?????¢\n\n                next_dir = (current.dir + 2) % 4\n            else:\n                # ????????? ??????\n\n                next_dir = (current.dir + 3) % 4\n            # ????????? ??´????????????????????¢?????????????????????????????????????????\\???????????¢??????????????????????????§???????????????\n\n            next_x = current.x + dir_x[next_dir]\n            next_y = current.y + dir_y[next_dir]\n            next_cost = costs[current.y][current.x][current.dir]\n            if stage[current.y][current.x] != operation:\n                next_cost += C[operation]\n            if 0 <= next_x < X and 0 <= next_y < Y:\n                if costs[next_y][next_x][next_dir] > next_cost:\n                    costs[next_y][next_x][next_dir] = next_cost\n                    data = Tuple(next_cost, next_y, next_x, next_dir)\n                    heapq.heappush(queue, data)\n\n    return min(costs[Y - 1][X - 1])\n\n\nif __name__ == '__main__':\n    while True:\n        result = solve()\n        if result < 0:\n            break\n\n        print result"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef cal(x,y,a):\n    return (x+y*W)*4 + a\n\ndef uncal(val):\n    a = val%4\n    vxy = val//4\n    x,y = vxy%W, vxy//W\n    return x,y,a\n\ndef dijkstra(lines,N,s):\n    weight = [INF]*N\n    weight[s] = 0\n    def search(s,w_0,q,weight):\n        for t,w in lines[s]:\n            w += w_0\n            if weight[t] > w:\n                heapq.heappush(q,[w,t])\n                weight[t] = w\n    q = [[0,s]]\n    heapq.heapify(q)\n    while q:\n        w,n = heapq.heappop(q)\n        search(n,w,q,weight)\n    return weight\n\n\n\nwhile True:\n    W,H = inpl()\n    if W==0 and H==0:\n        break\n\n    ss = [inpl() for _ in range(H)]\n    cc = inpl() # 直進，右折，反転，左折\n\n    dx = [0,1,0,-1]\n    dy = [-1,0,1,0]\n    lines = defaultdict(set)\n    for x in range(W):\n        for y in range(H):\n            for a in range(4): # 向いてる方向\n                s = cal(x,y,a)\n                costs = cc[:]\n                if ss[y][x] <= 3:\n                    costs[ss[y][x]] = 0\n\n                for st in range(4): # 進む向き (直進，右折，反転，左折)\n                    ar = (a + st)%4\n                    tx,ty = x+dx[ar],y+dy[ar]\n                    if (0<=tx<W) and (0<=ty<H):\n                        t = cal(tx,ty,ar)\n                        lines[s].add((t,costs[st]))\n\n    weights = dijkstra(lines,H*W*4,cal(0,0,1))\n    #for y in range(H):\n    #    for x in range(W):\n    #        print(x,y,weights[cal(x,y,0):cal(x,y,3)+1])\n\n    print(min(weights[cal(x,y,0):cal(x,y,3)+1]))\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport heapq\n\n\nclass Tuple:\n    def __init__(self, cost, y, x, dir):\n        self.cost = cost\n        self.y = y\n        self.x = x\n        self.dir = dir\n\n    def __str__(self):\n        return \"y=\" + str(self.y) + \" : \" + \"x=\" + str(self.x) + \" : \" + \"dir=\" + str(self.dir) + \": cost=\" + str(\n            self.cost)\n\n\ndef solve():\n    X, Y = map(int, raw_input().split())\n    if X == 0 and Y == 0:\n        return -1\n\n    stage = [map(int, raw_input().split()) for _ in range(Y)]\n    C = map(int, raw_input().split())\n\n    memo = [[[10 ** 10 for _ in xrange(4)] for _ in xrange(X)] for _ in xrange(Y)]\n\n    queue = []\n\n    heapq.heappush(queue, Tuple(0, 0, 0, 0))\n\n    dir_x = [1, 0, -1, 0]\n    dir_y = [0, 1, 0, -1]\n\n    while len(queue) > 0:\n\n        current = heapq.heappop(queue)\n        if memo[current.y][current.x][current.dir] > current.cost:\n            memo[current.y][current.x][current.dir] = current.cost\n\n            for operation in range(4):\n                if operation == 0:\n                    # ????????? ?????£??´?????????\n\n                    next_dir = current.dir\n                elif operation == 1:\n                    # ????????? ??????\n\n                    next_dir = (current.dir + 1) % 4\n                elif operation == 2:\n                    # ????????? ?????¢\n\n                    next_dir = (current.dir + 2) % 4\n                else:\n                    # ????????? ??????\n\n                    next_dir = (current.dir + 3) % 4\n                # ????????? ??´????????????????????¢?????????????????????????????????????????\\???????????¢??????????????????????????§???????????????\n\n                next_x = current.x + dir_x[next_dir]\n                next_y = current.y + dir_y[next_dir]\n                next_cost = current.cost\n                if stage[current.y][current.x] != operation:\n                    next_cost += C[operation]\n                if 0 <= next_x < X and 0 <= next_y < Y:\n                    heapq.heappush(queue, Tuple(next_cost, next_y, next_x, next_dir))\n\n    return min(memo[Y - 1][X - 1])\n\n\nif __name__ == '__main__':\n    while True:\n        result = solve()\n        if result < 0:\n            break\n\n        print result"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nfrom heapq import heappush,heappop\n\nd = [(0,1),(1,0),(0,-1),(-1,0)]\ndef bfs():\n    dist = [[[float(\"inf\")]*4 for i in range(w)] for j in range(h)]\n    dist[0][0][0] = 0\n    q = [(0,0,0,0)]\n    while q:\n        dn,y,x,c = heappop(q)\n        for di in range(4):\n            c_ = ro[di][c]\n            y_ = y+d[c_][0]\n            x_ = x+d[c_][1]\n            if 0 <= y_ < h and 0 <= x_ < w:\n                if dist[y_][x_][c_] > dn+co[y][x][di]:\n                    dist[y_][x_][c_] = dn+co[y][x][di]\n                    heappush(q,(dist[y_][x_][c_],y_,x_,c_))\n    return dist\n\nwhile 1:\n    w,h = map(int, sys.stdin.readline().split())\n    if w == 0:\n        break\n    s = [list(map(int, sys.stdin.readline().split())) for i in range(h)]\n    cost = list(map(int, sys.stdin.readline().split()))\n    co = [[[cost[i] for i in range(4)] for x in range(w)] for y in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if s[y][x] < 4:\n                co[y][x][s[y][x]] = 0\n    ro = [[0]*4 for i in range(4)]\n    for c in range(4):\n        for i in range(4):\n            if c == 0:\n                ro[c][i] = i\n            elif c == 1:\n                ro[c][i] = (i+1)%4\n            elif c == 2:\n                ro[c][i] = (i+2)%4\n            else:\n                ro[c][i] = (i+3)%4\n\n    dist = bfs()\n    print(min(dist[h-1][w-1]))\n\n"
  }
]