[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int cost;\n    char command;\n} Square;\n\nSquare board[MAX_SIZE][MAX_SIZE];\nint minCost[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nint rows, cols;\n\ntypedef struct {\n    int row;\n    int col;\n} Position;\n\nPosition queue[MAX_SIZE * MAX_SIZE];\nint front, rear;\n\nvoid enqueue(int row, int col) {\n    queue[rear].row = row;\n    queue[rear].col = col;\n    rear++;\n}\n\nPosition dequeue() {\n    Position p = queue[front];\n    front++;\n    return p;\n}\n\nbool isEmpty() {\n    return front == rear;\n}\n\nvoid initialize() {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            minCost[i][j] = INT_MAX;\n            visited[i][j] = false;\n        }\n    }\n    front = rear = 0;\n}\n\nbool isValid(int row, int col) {\n    return row >= 0 && row < rows && col >= 0 && col < cols;\n}\n\nvoid updateNeighbor(int currentRow, int currentCol, int newRow, int newCol, int currentCost, int additionalCost) {\n    if (isValid(newRow, newCol)) {\n        int totalCost = currentCost + additionalCost;\n        if (totalCost < minCost[newRow][newCol]) {\n            minCost[newRow][newCol] = totalCost;\n            if (!visited[newRow][newCol]) {\n                visited[newRow][newCol] = true;\n                enqueue(newRow, newCol);\n            }\n        }\n    }\n}\n\nvoid bfs() {\n    initialize();\n    minCost[0][0] = board[0][0].cost;\n    enqueue(0, 0);\n    visited[0][0] = true;\n\n    while (!isEmpty()) {\n        Position current = dequeue();\n        int currentRow = current.row;\n        int currentCol = current.col;\n        visited[currentRow][currentCol] = false;\n\n        char cmd = board[currentRow][currentCol].command;\n        int currentCost = minCost[currentRow][currentCol];\n\n        if (cmd == 'H') {\n            continue;\n        }\n\n        if (cmd == 'R') {\n            updateNeighbor(currentRow, currentCol, currentRow, currentCol + 1, currentCost, board[currentRow][currentCol + 1].cost);\n        } else if (cmd == 'D') {\n            updateNeighbor(currentRow, currentCol, currentRow + 1, currentCol, currentCost, board[currentRow + 1][currentCol].cost);\n        } else if (cmd == 'L') {\n            updateNeighbor(currentRow, currentCol, currentRow, currentCol - 1, currentCost, board[currentRow][currentCol - 1].cost);\n        } else if (cmd == 'U') {\n            updateNeighbor(currentRow, currentCol, currentRow - 1, currentCol, currentCost, board[currentRow - 1][currentCol].cost);\n        } else {\n            updateNeighbor(currentRow, currentCol, currentRow, currentCol + 1, currentCost, board[currentRow][currentCol + 1].cost);\n            updateNeighbor(currentRow, currentCol, currentRow + 1, currentCol, currentCost, board[currentRow + 1][currentCol].cost);\n            updateNeighbor(currentRow, currentCol, currentRow, currentCol - 1, currentCost, board[currentRow][currentCol - 1].cost);\n            updateNeighbor(currentRow, currentCol, currentRow - 1, currentCol, currentCost, board[currentRow - 1][currentCol].cost);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d %c\", &board[i][j].cost, &board[i][j].command);\n        }\n    }\n\n    bfs();\n\n    if (minCost[rows - 1][cols - 1] != INT_MAX) {\n        printf(\"%d\\n\", minCost[rows - 1][cols - 1]);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RobotPathCost {\n    private int[][] board;\n    private int[][] costGrid;\n    private int rows, cols;\n    private static final int INF = Integer.MAX_VALUE;\n\n    public RobotPathCost(int[][] board) {\n        this.board = board;\n        this.rows = board.length;\n        this.cols = board[0].length;\n        this.costGrid = new int[rows][cols];\n    }\n\n    public int calculateMinCost() {\n        for (int[] row : costGrid) {\n            Arrays.fill(row, INF);\n        }\n        costGrid[0][0] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        pq.offer(new int[]{0, 0, 0});\n\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int x = current[0], y = current[1], cost = current[2];\n\n            if (x == rows - 1 && y == cols - 1) {\n                return cost;\n            }\n\n            for (int[] dir : directions) {\n                int nx = x + dir[0], ny = y + dir[1];\n\n                if (isValidMove(nx, ny)) {\n                    int newCost = cost + getSquareCost(nx, ny);\n\n                    if (newCost < costGrid[nx][ny]) {\n                        costGrid[nx][ny] = newCost;\n                        pq.offer(new int[]{nx, ny, newCost});\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean isValidMove(int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols;\n    }\n\n    private int getSquareCost(int x, int y) {\n        if (board[x][y] == -1) {\n            return INF;\n        }\n        return board[x][y];\n    }\n\n    public static void main(String[] args) {\n        int[][] board = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 0}\n        };\n        RobotPathCost robotPath = new RobotPathCost(board);\n        int minCost = robotPath.calculateMinCost();\n        System.out.println(\"Minimum Cost Path: \" + minCost);\n    }\n}",
    "timestamp": "2025-08-05 19:08:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct State {\n    int x, y;\n    bool explicit_command;\n    int cost;\n    \n    bool operator>(const State& other) const {\n        return cost > other.cost;\n    }\n};\n\nint minCostToGoal(vector<vector<char>>& board, vector<vector<int>>& command_costs, vector<vector<int>>& explicit_costs) {\n    int rows = board.size();\n    if (rows == 0) return -1;\n    int cols = board[0].size();\n    \n    priority_queue<State, vector<State>, greater<State>> pq;\n    unordered_map<string, int> visited;\n    \n    pq.push({0, 0, false, 0});\n    pq.push({0, 0, true, explicit_costs[0][0]});\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        string key = to_string(curr.x) + \",\" + to_string(curr.y) + \",\" + (curr.explicit_command ? \"1\" : \"0\");\n        if (visited.find(key) != visited.end() && visited[key] < curr.cost) {\n            continue;\n        }\n        visited[key] = curr.cost;\n        \n        if (curr.x == rows - 1 && curr.y == cols - 1) {\n            return curr.cost;\n        }\n        \n        if (curr.explicit_command) {\n            vector<pair<int, int>> moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            for (auto& move : moves) {\n                int nx = curr.x + move.first;\n                int ny = curr.y + move.second;\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                    string new_key = to_string(nx) + \",\" + to_string(ny) + \",0\";\n                    if (visited.find(new_key) == visited.end() || curr.cost < visited[new_key]) {\n                        pq.push({nx, ny, false, curr.cost});\n                    }\n                }\n            }\n        } else {\n            char cmd = board[curr.x][curr.y];\n            if (cmd == 'H') {\n                continue;\n            }\n            \n            int nx = curr.x, ny = curr.y;\n            if (cmd == 'R') ny++;\n            else if (cmd == 'D') nx++;\n            else if (cmd == 'L') ny--;\n            else if (cmd == 'U') nx--;\n            \n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                string new_key = to_string(nx) + \",\" + to_string(ny) + \",0\";\n                if (visited.find(new_key) == visited.end() || curr.cost + command_costs[curr.x][curr.y] < visited[new_key]) {\n                    pq.push({nx, ny, false, curr.cost + command_costs[curr.x][curr.y]});\n                }\n            }\n            \n            string new_key = to_string(curr.x) + \",\" + to_string(curr.y) + \",1\";\n            if (visited.find(new_key) == visited.end() || curr.cost + explicit_costs[curr.x][curr.y] < visited[new_key]) {\n                pq.push({curr.x, curr.y, true, curr.cost + explicit_costs[curr.x][curr.y]});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    \n    vector<vector<char>> board(rows, vector<char>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> board[i][j];\n        }\n    }\n    \n    vector<vector<int>> command_costs(rows, vector<int>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> command_costs[i][j];\n        }\n    }\n    \n    vector<vector<int>> explicit_costs(rows, vector<int>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> explicit_costs[i][j];\n        }\n    }\n    \n    int result = minCostToGoal(board, command_costs, explicit_costs);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\ntypedef struct {\n    int cost;\n    char command;\n} Square;\n\nint minCost(Square board[MAX_ROWS][MAX_COLS], int rows, int cols) {\n    int dp[MAX_ROWS][MAX_COLS];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n\n    dp[0][0] = 0;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (board[i][j].command == 'H') continue;\n\n            // Move right\n            if (j + 1 < cols && board[i][j+1].command != 'H') {\n                dp[i][j+1] = fmin(dp[i][j+1], dp[i][j] + board[i][j+1].cost);\n            }\n\n            // Move down\n            if (i + 1 < rows && board[i+1][j].command != 'H') {\n                dp[i+1][j] = fmin(dp[i+1][j], dp[i][j] + board[i+1][j].cost);\n            }\n        }\n    }\n\n    return dp[rows-1][cols-1] == INT_MAX ? -1 : dp[rows-1][cols-1];\n}\n\nint main() {\n    int rows, cols;\n    Square board[MAX_ROWS][MAX_COLS];\n\n    scanf(\"%d %d\", &rows, &cols);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\" %c %d\", &board[i][j].command, &board[i][j].cost);\n        }\n    }\n\n    int result = minCost(board, rows, cols);\n    if (result == -1) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:20:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nclass RobotPathSolver {\nprivate:\n    int rows, cols;\n    vector<vector<int>> board;\n    vector<vector<int>> dp;\n\npublic:\n    RobotPathSolver(int r, int c) : rows(r), cols(c), board(r, vector<int>(c)), dp(r, vector<int>(c, INT_MAX)) {}\n\n    void setSquareCost(int r, int c, int cost) {\n        board[r][c] = cost;\n    }\n\n    int calculateMinCost() {\n        dp[0][0] = 0;\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (r > 0 && dp[r-1][c] != INT_MAX) {\n                    dp[r][c] = min(dp[r][c], dp[r-1][c] + board[r][c]);\n                }\n                if (c > 0 && dp[r][c-1] != INT_MAX) {\n                    dp[r][c] = min(dp[r][c], dp[r][c-1] + board[r][c]);\n                }\n            }\n        }\n\n        return dp[rows-1][cols-1] == INT_MAX ? -1 : dp[rows-1][cols-1];\n    }\n};\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    RobotPathSolver solver(rows, cols);\n\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            int cost;\n            cin >> cost;\n            solver.setSquareCost(r, c, cost);\n        }\n    }\n\n    int minCost = solver.calculateMinCost();\n    \n    if (minCost == -1) {\n        cout << \"No path to goal\" << endl;\n    } else {\n        cout << \"Minimum cost: \" << minCost << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:20:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RobotPathCost {\n    static class Cell {\n        int row, col, cost;\n        String command;\n\n        Cell(int row, int col, int cost, String command) {\n            this.row = row;\n            this.col = col;\n            this.cost = cost;\n            this.command = command;\n        }\n    }\n\n    public static int minCost(String[][] board, int[][] commandCost) {\n        int rows = board.length;\n        if (rows == 0) return -1;\n        int cols = board[0].length;\n        if (cols == 0) return -1;\n\n        PriorityQueue<Cell> pq = new PriorityQueue<>((a, b) -> a.cost - b.cost);\n        boolean[][] visited = new boolean[rows][cols];\n        pq.add(new Cell(0, 0, 0, board[0][0]));\n\n        while (!pq.isEmpty()) {\n            Cell current = pq.poll();\n            if (current.row == rows - 1 && current.col == cols - 1) {\n                return current.cost;\n            }\n            if (visited[current.row][current.col]) continue;\n            visited[current.row][current.col] = true;\n\n            String cmd = current.command;\n            int newRow = current.row, newCol = current.col;\n            if (cmd.equals(\"South\")) {\n                newRow++;\n            } else if (cmd.equals(\"North\")) {\n                newRow--;\n            } else if (cmd.equals(\"East\")) {\n                newCol++;\n            } else if (cmd.equals(\"West\")) {\n                newCol--;\n            } else if (cmd.equals(\"Halt\")) {\n                continue;\n            }\n\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                int newCost = current.cost + commandCost[current.row][current.col];\n                pq.add(new Cell(newRow, newCol, newCost, board[newRow][newCol]));\n            }\n\n            for (String direction : new String[]{\"South\", \"North\", \"East\", \"West\"}) {\n                newRow = current.row;\n                newCol = current.col;\n                if (direction.equals(\"South\")) {\n                    newRow++;\n                } else if (direction.equals(\"North\")) {\n                    newRow--;\n                } else if (direction.equals(\"East\")) {\n                    newCol++;\n                } else if (direction.equals(\"West\")) {\n                    newCol--;\n                }\n\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                    int newCost = current.cost + commandCost[current.row][current.col] + 1;\n                    pq.add(new Cell(newRow, newCol, newCost, board[newRow][newCol]));\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        String[][] board = {\n            {\"South\", \"East\", \"East\"},\n            {\"South\", \"Halt\", \"South\"},\n            {\"East\", \"East\", \"Goal\"}\n        };\n        int[][] commandCost = {\n            {1, 2, 2},\n            {1, 0, 1},\n            {2, 2, 0}\n        };\n        System.out.println(minCost(board, commandCost));\n    }\n}",
    "timestamp": "2025-08-05 19:20:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_cost_to_goal(board, costs, player_commands):\n    n = len(board)\n    m = len(board[0])\n    directions = [(0, 1), (1, 0)]  # right, down\n    # Minimum cost to reach each cell\n    min_cost = [[float('inf')] * m for _ in range(n)]\n    min_cost[0][0] = 0\n    pq = [(0, 0, 0)]  # cost, row, col\n    while pq:\n        current_cost, x, y = heapq.heappop(pq)\n        if (x, y) == (n - 1, m - 1):\n            return current_cost\n        if current_cost > min_cost[x][y]:\n            continue\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m:\n                command = board[nx][ny]\n                cost = costs[command]\n                new_cost = current_cost + cost\n                if new_cost < min_cost[nx][ny]:\n                    min_cost[nx][ny] = new_cost\n                    heapq.heappush(pq, (new_cost, nx, ny))\n        # Try player commands\n        for command, cost in player_commands:\n            if command == 'right':\n                nx, ny = x, y + 1\n            elif command == 'down':\n                nx, ny = x + 1, y\n            else:\n                continue  # skip invalid command\n            if 0 <= nx < n and 0 <= ny < m:\n                new_cost = current_cost + cost\n                if new_cost < min_cost[nx][ny]:\n                    min_cost[nx][ny] = new_cost\n                    heapq.heappush(pq, (new_cost, nx, ny))\n    return float('inf')  # return inf if no path\n\n# Example usage\nboard = [\n    ['F', 'F', 'R'],\n    ['F', 'R', 'F'],\n    ['R', 'F', 'F']\n]\ncosts = {\n    'F': 1,\n    'R': 3,\n    'Halt': float('inf'),\n}\nplayer_commands = [('right', 2), ('down', 2)]  # Example player commands with cost\n\nprint(min_cost_to_goal(board, costs, player_commands))",
    "timestamp": "2025-08-13 02:39:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class RobotPathCost {\n    private static final int[] ROWS = {0, 1, 0, -1};\n    private static final int[] COLS = {1, 0, -1, 0};\n    private static final int MAX_COMMAND_COST = 100000;\n\n    static class Square {\n        int x, y, cost;\n\n        Square(int x, int y, int cost) {\n            this.x = x;\n            this.y = y;\n            this.cost = cost;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        int[][] board = new int[rows][cols];\n        String[][] commands = new String[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                board[i][j] = scanner.nextInt();\n                commands[i][j] = scanner.next();\n            }\n        }\n\n        int result = minCostToGoal(board, commands, rows, cols);\n        System.out.println(result != MAX_COMMAND_COST ? result : -1);\n    }\n\n    private static int minCostToGoal(int[][] board, String[][] commands, int rows, int cols) {\n        PriorityQueue<Square> pq = new PriorityQueue<>((a, b) -> a.cost - b.cost);\n        pq.add(new Square(0, 0, board[0][0]));\n        \n        boolean[][] visited = new boolean[rows][cols];\n        \n        while (!pq.isEmpty()) {\n            Square current = pq.poll();\n            int x = current.x, y = current.y, cost = current.cost;\n            \n            if (visited[x][y]) continue;\n            visited[x][y] = true;\n            \n            if (x == rows - 1 && y == cols - 1) return cost;\n            \n            String command = commands[x][y];\n            if (command.equals(\"Halt\")) continue;\n            \n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + ROWS[dir];\n                int ny = y + COLS[dir];\n                \n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny]) {\n                    pq.add(new Square(nx, ny, cost + board[nx][ny]));\n                }\n            }\n            \n            if (!command.equals(\"None\")) {\n                int nx = x, ny = y;\n                switch (command) {\n                    case \"N\": nx--; break;\n                    case \"E\": ny++; break;\n                    case \"S\": nx++; break;\n                    case \"W\": ny--; break;\n                }\n                \n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny]) {\n                    pq.add(new Square(nx, ny, cost + board[nx][ny]));\n                }\n            }\n        }\n        \n        return MAX_COMMAND_COST;\n    }\n}",
    "timestamp": "2025-08-13 02:39:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 100\n#define INFINITY INT_MAX\n\nint board[MAX][MAX];\nint cost[MAX][MAX];\nint minCost[MAX][MAX];\nint n, m;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid findMinCost() {\n    minCost[0][0] = cost[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i == 0 && j == 0) continue;\n            int left = j > 0 ? minCost[i][j - 1] + cost[i][j] : INFINITY;\n            int up = i > 0 ? minCost[i - 1][j] + cost[i][j] : INFINITY;\n            minCost[i][j] = min(left, up);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &cost[i][j]);\n        }\n    }\n\n    findMinCost();\n\n    if (board[n - 1][m - 1] == 'H')\n        printf(\"-1\\n\");\n    else\n        printf(\"%d\\n\", minCost[n - 1][m - 1]);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:39:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_minimum_cost(board):\n    rows, cols = len(board), len(board[0])\n    \n    # Initialize DP table with large values\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n    \n    # Populate DP table\n    for r in range(rows):\n        for c in range(cols):\n            # Try moving right\n            if c + 1 < cols:\n                move_cost = board[r][c+1].get('move_right', float('inf'))\n                dp[r][c+1] = min(dp[r][c+1], dp[r][c] + move_cost)\n            \n            # Try moving down\n            if r + 1 < rows:\n                move_cost = board[r+1][c].get('move_down', float('inf'))\n                dp[r+1][c] = min(dp[r+1][c], dp[r][c] + move_cost)\n    \n    # Check for Halt command\n    if board[rows-1][cols-1].get('command') == 'Halt':\n        return float('inf')\n    \n    return dp[rows-1][cols-1]",
    "timestamp": "2025-08-13 02:39:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_cost_to_goal(board, commands):\n    rows = len(board)\n    if rows == 0:\n        return -1\n    cols = len(board[0])\n    if cols == 0:\n        return -1\n    \n    # Directions: North, South, East, West\n    directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n    command_map = {'N': 0, 'S': 1, 'E': 2, 'W': 3, 'H': -1}\n    \n    # Priority queue: (cost, x, y)\n    heap = []\n    heapq.heappush(heap, (0, 0, 0))\n    \n    # Visited matrix to keep track of minimum cost to reach each cell\n    visited = [[float('inf')] * cols for _ in range(rows)]\n    visited[0][0] = 0\n    \n    while heap:\n        current_cost, x, y = heapq.heappop(heap)\n        \n        if x == rows - 1 and y == cols - 1:\n            return current_cost\n        \n        if current_cost > visited[x][y]:\n            continue\n        \n        # Check if there's an explicit command for this cell\n        if (x, y) in commands:\n            cmd = commands[(x, y)]\n            if cmd == 'H':\n                continue  # Halt command, cannot proceed\n            dx, dy = directions[command_map[cmd]]\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_cost = current_cost + 1  # Assuming cost 1 for explicit commands\n                if new_cost < visited[nx][ny]:\n                    visited[nx][ny] = new_cost\n                    heapq.heappush(heap, (new_cost, nx, ny))\n        else:\n            # Execute board commands\n            for cmd in board[x][y]:\n                if cmd == 'H':\n                    continue  # Halt command, skip this direction\n                dx, dy = directions[command_map[cmd]]\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols:\n                    new_cost = current_cost + 1  # Assuming cost 1 for board commands\n                    if new_cost < visited[nx][ny]:\n                        visited[nx][ny] = new_cost\n                        heapq.heappush(heap, (new_cost, nx, ny))\n    \n    return -1  # Goal not reachable",
    "timestamp": "2025-08-13 02:40:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <queue>\n\nstruct Command {\n    int cost;\n    bool halt;\n};\n\nstruct State {\n    int x, y, cost;\n    bool operator>(const State &other) const {\n        return cost > other.cost;\n    }\n};\n\nint minCostToReachGoal(std::vector<std::vector<Command>> &board) {\n    int rows = board.size();\n    int cols = board[0].size();\n    std::vector<std::vector<int>> minCost(rows, std::vector<int>(cols, std::numeric_limits<int>::max()));\n    std::priority_queue<State, std::vector<State>, std::greater<State>> pq;\n\n    pq.push({0, 0, board[0][0].cost});\n    minCost[0][0] = board[0][0].cost;\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.x == rows - 1 && current.y == cols - 1) {\n            return current.cost;\n        }\n        \n        if (board[current.x][current.y].halt || current.cost >= minCost[current.x][current.y]) {\n            continue;\n        }\n\n        std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}};\n        for (auto &[dx, dy] : directions) {\n            int nextX = current.x + dx;\n            int nextY = current.y + dy;\n\n            if (nextX < rows && nextY < cols) {\n                int nextCost = current.cost + board[nextX][nextY].cost;\n                if (nextCost < minCost[nextX][nextY]) {\n                    minCost[nextX][nextY] = nextCost;\n                    pq.push({nextX, nextY, nextCost});\n                }\n            }\n        }\n    }\n\n    return -1; // No solution available\n}\n\nint main() {\n    int rows, cols;\n    std::cin >> rows >> cols;\n\n    std::vector<std::vector<Command>> board(rows, std::vector<Command>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            int cost;\n            bool halt;\n            std::cin >> cost >> halt;\n            board[i][j] = {cost, halt};\n        }\n    }\n\n    std::cout << minCostToReachGoal(board) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:07:06"
  }
]