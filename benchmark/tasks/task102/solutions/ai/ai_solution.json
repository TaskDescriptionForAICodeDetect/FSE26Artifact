[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int value;\n    int start;\n    int end;\n} Item;\n\ntypedef struct {\n    int rows;\n    int cols;\n    Item grid[MAX_SIZE][MAX_SIZE];\n} Supermarket;\n\nint maxDiscount;\nint visited[MAX_SIZE][MAX_SIZE];\nSupermarket supermarket;\n\nvoid dfs(int row, int col, int currentTime, int currentDiscount) {\n    if (row < 0 || row >= supermarket.rows || col < 0 || col >= supermarket.cols || visited[row][col]) {\n        return;\n    }\n\n    Item item = supermarket.grid[row][col];\n    if (item.value == 0) {\n        return;\n    }\n\n    if (currentTime >= item.start && currentTime <= item.end) {\n        currentDiscount += item.value;\n    }\n\n    if (currentDiscount > maxDiscount) {\n        maxDiscount = currentDiscount;\n    }\n\n    visited[row][col] = 1;\n\n    dfs(row + 1, col, currentTime + 1, currentDiscount);\n    dfs(row - 1, col, currentTime + 1, currentDiscount);\n    dfs(row, col + 1, currentTime + 1, currentDiscount);\n    dfs(row, col - 1, currentTime + 1, currentDiscount);\n\n    visited[row][col] = 0;\n}\n\nint main() {\n    while (1) {\n        int rows, cols;\n        scanf(\"%d %d\", &rows, &cols);\n        if (rows == 0 && cols == 0) {\n            break;\n        }\n\n        supermarket.rows = rows;\n        supermarket.cols = cols;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                scanf(\"%d %d %d\", &supermarket.grid[i][j].value, &supermarket.grid[i][j].start, &supermarket.grid[i][j].end);\n            }\n        }\n\n        maxDiscount = 0;\n        memset(visited, 0, sizeof(visited));\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (supermarket.grid[i][j].value != 0) {\n                    dfs(i, j, 0, 0);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", maxDiscount);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SupermarketDiscounts {\n    static int[][] grid;\n    static int[][] times;\n    static int rows, cols;\n    static int[][][] memo;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            rows = scanner.nextInt();\n            cols = scanner.nextInt();\n\n            if (rows == 0 && cols == 0) break;\n\n            grid = new int[rows][cols];\n            times = new int[rows][cols];\n            memo = new int[rows][cols][101];\n\n            for (int[][] layer : memo) {\n                for (int[] row : layer) {\n                    Arrays.fill(row, -1);\n                }\n            }\n\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    times[i][j] = scanner.nextInt();\n                }\n            }\n\n            int maxDiscount = findMaxDiscount(0, 0, 0);\n            System.out.println(maxDiscount);\n        }\n    }\n\n    static int findMaxDiscount(int row, int col, int time) {\n        if (row >= rows || col >= cols) return 0;\n        if (row == rows - 1 && col == cols - 1) {\n            return (time >= times[row][col]) ? grid[row][col] : 0;\n        }\n\n        if (memo[row][col][time] != -1) return memo[row][col][time];\n\n        int discount = 0;\n        if (time >= times[row][col]) {\n            discount = grid[row][col];\n        }\n\n        int moveRight = findMaxDiscount(row, col + 1, time + 1);\n        int moveDown = findMaxDiscount(row + 1, col, time + 1);\n\n        memo[row][col][time] = discount + Math.max(moveRight, moveDown);\n        return memo[row][col][time];\n    }\n}",
    "timestamp": "2025-08-05 18:37:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Item {\n    int x, y, value, start, end;\n};\n\nint main() {\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<int>> grid(H, vector<int>(W));\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        int N;\n        cin >> N;\n        vector<Item> items(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> items[i].y >> items[i].x >> items[i].value >> items[i].start >> items[i].end;\n            items[i].x--;\n            items[i].y--;\n        }\n\n        sort(items.begin(), items.end(), [](const Item& a, const Item& b) {\n            return a.start < b.start;\n        });\n\n        vector<vector<int>> dp(H, vector<int>(W, -1));\n        dp[0][0] = 0;\n        int max_discount = 0;\n        int current_item = 0;\n\n        for (int t = 0; t <= 10000; ++t) {\n            vector<vector<int>> new_dp = dp;\n            while (current_item < N && items[current_item].start == t) {\n                int x = items[current_item].x;\n                int y = items[current_item].y;\n                int value = items[current_item].value;\n                if (dp[y][x] != -1) {\n                    new_dp[y][x] = max(new_dp[y][x], dp[y][x] + value);\n                    max_discount = max(max_discount, new_dp[y][x]);\n                }\n                current_item++;\n            }\n\n            for (int y = 0; y < H; ++y) {\n                for (int x = 0; x < W; ++x) {\n                    if (dp[y][x] == -1) continue;\n                    if (y > 0 && grid[y-1][x] <= t+1) new_dp[y-1][x] = max(new_dp[y-1][x], dp[y][x]);\n                    if (y < H-1 && grid[y+1][x] <= t+1) new_dp[y+1][x] = max(new_dp[y+1][x], dp[y][x]);\n                    if (x > 0 && grid[y][x-1] <= t+1) new_dp[y][x-1] = max(new_dp[y][x-1], dp[y][x]);\n                    if (x < W-1 && grid[y][x+1] <= t+1) new_dp[y][x+1] = max(new_dp[y][x+1], dp[y][x]);\n                }\n            }\n            dp = new_dp;\n        }\n        cout << max_discount << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 20\n#define MAX_M 20\n\nint grid[MAX_N][MAX_M];\nint visited[MAX_N][MAX_M];\nint n, m;\n\nint max_discount;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y, int time, int current_discount) {\n    if (x < 0 || x >= n || y < 0 || y >= m || visited[x][y]) {\n        return;\n    }\n\n    visited[x][y] = 1;\n\n    if (grid[x][y] > 0) {\n        current_discount += grid[x][y];\n    }\n\n    max_discount = (current_discount > max_discount) ? current_discount : max_discount;\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        dfs(nx, ny, time + 1, current_discount);\n    }\n\n    visited[x][y] = 0;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &n, &m);\n        \n        if (n == 0 && m == 0) break;\n\n        memset(grid, 0, sizeof(grid));\n        memset(visited, 0, sizeof(visited));\n        max_discount = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                dfs(i, j, 0, 0);\n            }\n        }\n\n        printf(\"%d\\n\", max_discount);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:38:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int MAX_TIME = 200;\n\nint n, m, t;\nint grid[MAX_N][MAX_N];\nint sale_start[MAX_N][MAX_N];\nint sale_end[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N][MAX_TIME];\n\nint solve() {\n    memset(dp, -1, sizeof(dp));\n    \n    function<int(int, int, int)> dfs = [&](int x, int y, int cur_time) {\n        if (x < 0 || x >= n || y < 0 || y >= m) return 0;\n        \n        if (dp[x][y][cur_time] != -1) return dp[x][y][cur_time];\n        \n        int max_discount = 0;\n        \n        if (cur_time >= sale_start[x][y] && cur_time <= sale_end[x][y]) {\n            max_discount = grid[x][y];\n        }\n        \n        int down = dfs(x + 1, y, cur_time + 1);\n        int right = dfs(x, y + 1, cur_time + 1);\n        \n        max_discount += max(down, right);\n        \n        return dp[x][y][cur_time] = max_discount;\n    };\n    \n    return dfs(0, 0, 0);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m >> t;\n        \n        if (n == 0 && m == 0 && t == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> sale_start[i][j] >> sale_end[i][j];\n            }\n        }\n        \n        cout << solve() << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:38:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SupermarketDiscount {\n    static class Item {\n        int x, y, value, start, end;\n\n        Item(int x, int y, int value, int start, int end) {\n            this.x = x;\n            this.y = y;\n            this.value = value;\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int H = scanner.nextInt();\n            int W = scanner.nextInt();\n            if (H == 0 && W == 0) break;\n\n            int[][] grid = new int[H][W];\n            List<Item> items = new ArrayList<>();\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n\n            int N = scanner.nextInt();\n            for (int i = 0; i < N; i++) {\n                int x = scanner.nextInt() - 1;\n                int y = scanner.nextInt() - 1;\n                int value = scanner.nextInt();\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                items.add(new Item(x, y, value, start, end));\n            }\n\n            items.sort(Comparator.comparingInt(a -> a.end));\n\n            int[] dp = new int[N];\n            int maxDiscount = 0;\n            for (int i = 0; i < N; i++) {\n                Item current = items.get(i);\n                dp[i] = current.value;\n                for (int j = 0; j < i; j++) {\n                    Item prev = items.get(j);\n                    if (prev.end <= current.start) {\n                        int distance = Math.abs(prev.x - current.x) + Math.abs(prev.y - current.y);\n                        if (distance <= (current.start - prev.end)) {\n                            dp[i] = Math.max(dp[i], dp[j] + current.value);\n                        }\n                    }\n                }\n                maxDiscount = Math.max(maxDiscount, dp[i]);\n            }\n            System.out.println(maxDiscount);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:38:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_discount(grid, timings):\n    from collections import deque\n    \n    # Define movement directions (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def bfs(start_i, start_j, n, m, sale_start, sale_end):\n        queue = deque([(start_i, start_j, 0, 0)])  # (i, j, current_time, current_discount_sum)\n        visited = set((start_i, start_j))\n        max_discount = 0\n        \n        while queue:\n            i, j, current_time, current_discount = queue.popleft()\n            \n            # Update maximum discount obtained\n            max_discount = max(max_discount, current_discount)\n            \n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                \n                if 0 <= ni < n and 0 <= nj < m and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    if grid[ni][nj] > 0 and sale_start[ni][nj] <= current_time + 1 <= sale_end[ni][nj]:\n                        queue.append((ni, nj, current_time + 1, current_discount + grid[ni][nj]))\n                    else:\n                        queue.append((ni, nj, current_time + 1, current_discount))\n        \n        return max_discount\n    \n    n = len(grid)\n    m = len(grid[0])\n    max_total_discount = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] > 0:\n                max_total_discount = max(max_total_discount,\n                                         bfs(i, j, n, m, sale_start=sale_start, sale_end=sale_end))\n    \n    return max_total_discount\n\n\n# Read input and handle multiple datasets\nimport sys\n\ndef main():\n    datasets = sys.stdin.read().strip().split(\"\\n\")\n    index = 0\n    while index < len(datasets):\n        n, m = map(int, datasets[index].split())\n        if n == 0 and m == 0:\n            break\n        \n        grid = []\n        sale_start = []\n        sale_end = []\n        \n        for i in range(n):\n            grid.append(list(map(int, datasets[index + 1 + i].split())))\n        \n        for i in range(n):\n            sale_start.append(list(map(int, datasets[index + 1 + n + i].split())))\n        \n        for i in range(n):\n            sale_end.append(list(map(int, datasets[index + 1 + 2*n + i].split())))\n        \n        print(max_discount(grid, (sale_start, sale_end)))\n        index += 1 + 3 * n\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:14:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SupermarketDiscount {\n\n    static class Item {\n        int x, y, discount, startTime, endTime;\n        Item(int x, int y, int discount, int startTime, int endTime) {\n            this.x = x;\n            this.y = y;\n            this.discount = discount;\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        List<Integer> results = new ArrayList<>();\n\n        while (true) {\n            int n = scanner.nextInt(); // Number of items\n            int m = scanner.nextInt(); // Number of aisles\n\n            if (n == 0 && m == 0) break;\n\n            int[] aisleStart = new int[m];\n            int[] aisleEnd = new int[m];\n\n            for (int i = 0; i < m; i++) {\n                aisleStart[i] = scanner.nextInt();\n                aisleEnd[i] = scanner.nextInt();\n            }\n\n            List<Item> items = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                int discount = scanner.nextInt();\n                int saleStart = scanner.nextInt();\n                int saleEnd = scanner.nextInt();\n                items.add(new Item(x, y, discount, saleStart, saleEnd));\n            }\n\n            boolean[][] reachable = new boolean[m][];\n            for (int i = 0; i < m; i++) {\n                reachable[i] = new boolean[Math.max(aisleEnd[i] - aisleStart[i] + 1, 0)];\n                Arrays.fill(reachable[i], false);\n            }\n\n            // Initial position: (0,0)\n            int currentDiscount = 0;\n\n            Collections.sort(items, Comparator.comparingInt(item -> item.startTime));\n\n            for (Item item : items) {\n                if (canReach(item, aisleStart, aisleEnd, reachable, currentDiscount)) {\n                    visit(item, reachable, aisleStart, aisleEnd);\n                    currentDiscount += item.discount;\n                }\n            }\n\n            results.add(currentDiscount);\n        }\n\n        for (int result : results) {\n            System.out.println(result);\n        }\n    }\n\n    private static boolean canReach(Item item, int[] aisleStart, int[] aisleEnd, boolean[][] reachable, int currentDiscount) {\n        int aisle = item.x;\n        int pos = item.y - aisleStart[aisle];\n        if (aisle < 0 || aisle >= reachable.length || pos < 0 || pos >= reachable[aisle].length)\n            return false;\n        return true; // More complex checks would be implemented as needed.\n    }\n\n    private static void visit(Item item, boolean[][] reachable, int[] aisleStart, int[] aisleEnd) {\n        int aisle = item.x;\n        int pos = item.y - aisleStart[aisle];\n        if (aisle < 0 || aisle >= reachable.length || pos < 0 || pos >= reachable[aisle].length)\n            return;  // Error condition: invalid access.\n        reachable[aisle][pos] = true;\n    }\n}",
    "timestamp": "2025-08-13 00:14:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n#define MAX_ITEMS 1000\n#define INF 1000000\n\ntypedef struct {\n    int row, col, discount, start, end;\n} Item;\n\nint grid[MAX_ROWS][MAX_COLS];\nItem items[MAX_ITEMS];\nint item_count;\nint max_discount[MAX_ITEMS][MAX_ITEMS];\nint visited[MAX_ITEMS];\nint n, m;\n\nint is_adjacent(int i1, int i2) {\n    return (abs(items[i1].row - items[i2].row) + abs(items[i1].col - items[i2].col)) == 1;\n}\n\nint dfs(int curr_item_id, int current_time) {\n    if (visited[curr_item_id]) return -INF;\n    visited[curr_item_id] = 1;\n    int max_d = 0;\n    for (int i = 0; i < item_count; ++i) {\n        if (i == curr_item_id || current_time >= items[i].end || current_time + 1 < items[i].start) continue;\n        if (is_adjacent(curr_item_id, i)) {\n            max_d = fmax(max_d, items[i].discount + dfs(i, current_time + 1));\n        }\n    }\n    visited[curr_item_id] = 0;\n    return max_d;\n}\n\nint solve() {\n    int max_total_discount = 0;\n    for (int i = 0; i < item_count; ++i) {\n        if (items[i].start == 0) {\n            memset(visited, 0, sizeof(visited));\n            max_total_discount = fmax(max_total_discount, items[i].discount + dfs(i, items[i].start));\n        }\n    }\n    return max_total_discount;\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &m), n || m) {\n        item_count = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                scanf(\"%d\", &grid[i][j]);\n                if (grid[i][j] > 0) {\n                    items[item_count].row = i;\n                    items[item_count].col = j;\n                    items[item_count].discount = grid[i][j];\n                    scanf(\"%d %d\", &items[item_count].start, &items[item_count].end);\n                    item_count++;\n                }\n            }\n        }\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 00:15:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_supermarket_sale(grid, times):\n    rows, cols = len(grid), len(grid[0])\n    dp = [[[0] * (max(times) + 2) for _ in range(cols)] for _ in range(rows)]\n    \n    def is_valid_move(r, c, time):\n        return 0 <= r < rows and 0 <= c < cols and grid[r][c] != -1\n    \n    def dfs(r, c, time):\n        if time > max(times):\n            return 0\n        \n        if dp[r][c][time] != 0:\n            return dp[r][c][time]\n        \n        best = 0\n        if time in times:\n            best = grid[r][c]\n        \n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if is_valid_move(nr, nc, time + 1):\n                best = max(best, grid[r][c] + dfs(nr, nc, time + 1))\n        \n        dp[r][c][time] = best\n        return best\n    \n    max_discount = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != -1:\n                max_discount = max(max_discount, dfs(r, c, 0))\n    \n    return max_discount\n\ndef main():\n    while True:\n        rows, cols = map(int, input().split())\n        if rows == 0 and cols == 0:\n            break\n        \n        grid = []\n        for _ in range(rows):\n            grid.append(list(map(int, input().split())))\n        \n        num_times = int(input())\n        times = list(map(int, input().split()))\n        \n        print(solve_supermarket_sale(grid, times))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:15:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while True:\n        H, W = map(int, sys.stdin.readline().split())\n        if H == 0 and W == 0:\n            break\n        grid = []\n        items = []\n        for i in range(H):\n            row = list(map(int, sys.stdin.readline().split()))\n            grid.append(row)\n            for j in range(W):\n                if grid[i][j] > 0:\n                    items.append((i, j, grid[i][j]))\n        \n        S = int(sys.stdin.readline())\n        sales = []\n        for _ in range(S):\n            s, e, v = map(int, sys.stdin.readline().split())\n            sales.append((s, e, v))\n        sales.sort()\n        \n        # Preprocess sales: merge overlapping or adjacent intervals\n        merged_sales = []\n        for s, e, v in sales:\n            if not merged_sales:\n                merged_sales.append([s, e, v])\n            else:\n                last_s, last_e, last_v = merged_sales[-1]\n                if s <= last_e + 1:\n                    new_e = max(last_e, e)\n                    new_v = last_v + v\n                    merged_sales[-1] = [last_s, new_e, new_v]\n                else:\n                    merged_sales.append([s, e, v])\n        \n        # Now, merged_sales are non-overlapping and sorted\n        \n        # For each item, find the best sale interval it can fit into\n        item_values = []\n        for i, j, val in items:\n            best_v = 0\n            for s, e, v in merged_sales:\n                if s <= val <= e:\n                    if v > best_v:\n                        best_v = v\n            item_values.append((i, j, best_v))\n        \n        # Now, the problem reduces to picking items with maximum sum of best_v,\n        # with the constraint that you can move only to adjacent cells (up, down, left, right)\n        # and you can start anywhere, but must pick items in order of movement.\n        # This is similar to the maximum path sum in a grid with movement constraints.\n        \n        # We can model this as a BFS with DP, where dp[i][j] is the max value obtainable at (i,j)\n        dp = [[0]*W for _ in range(H)]\n        # We need to process cells in an order that allows DP to be updated correctly.\n        # Since movement is to adjacent cells, we can process cells in any order, but multiple passes may be needed.\n        # Alternatively, we can use a priority queue based on the best_v, but it's not straightforward.\n        \n        # Another approach: since the grid can be large, but the number of items is limited,\n        # we can consider only the item cells and compute the maximum path sum between them.\n        \n        # Extract item positions and values\n        if not item_values:\n            print(0)\n            continue\n        \n        # Sort items by their original value (time)\n        item_values.sort(key=lambda x: grid[x[0]][x[1]])\n        \n        # Now, the problem is to pick a subset of these items in increasing order of time,\n        # where movement between consecutive items is possible via adjacent steps,\n        # and maximize the sum of their best_v.\n        \n        # We can model this as a graph where edges exist if you can move from item i to item j (i < j in time)\n        # and the movement is possible via BFS.\n        \n        # Precompute adjacency: for each item, the next items it can reach\n        n = len(item_values)\n        adj = [[] for _ in range(n)]\n        for i in range(n):\n            xi, yi, vi = item_values[i]\n            for j in range(i+1, n):\n                xj, yj, vj = item_values[j]\n                # Check if we can move from (xi,yi) to (xj,yj) via adjacent steps\n                # Since time is increasing, we can BFS to see if it's reachable\n                # But for large grids, this is expensive. Instead, we can compute Manhattan distance,\n                # but movement is restricted to adjacent steps, so the time difference must be >= distance\n                time_i = grid[xi][yi]\n                time_j = grid[xj][yj]\n                if time_j < time_i:\n                    continue  # time must be non-decreasing\n                distance = abs(xi - xj) + abs(yi - yj)\n                if time_j - time_i >= distance:\n                    adj[i].append(j)\n        \n        # Now, perform DP on this DAG\n        dp_dag = [0]*n\n        for i in range(n):\n            dp_dag[i] = item_values[i][2]\n        \n        max_total = 0\n        for i in range(n):\n            if dp_dag[i] > max_total:\n                max_total = dp_dag[i]\n            for j in adj[i]:\n                if dp_dag[j] < dp_dag[i] + item_values[j][2]:\n                    dp_dag[j] = dp_dag[i] + item_values[j][2]\n        \n        print(max(dp_dag))\n\nsolve()",
    "timestamp": "2025-08-13 00:16:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct Item {\n    int x, y, start_time, end_time, discount;\n};\n\nconstexpr int MAX_N = 50;\nconstexpr int INF = 1e9;\n\nint n, m;\nint grid[MAX_N][MAX_N];\nbool visited[MAX_N][MAX_N][MAX_N * MAX_N];\nvector<Item> items;\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint bfs() {\n    queue<pair<int, pair<int, int>>> q; // time, (x, y)\n    q.push({0, {0, 0}});\n    memset(visited, false, sizeof(visited));\n    visited[0][0][0] = true;\n\n    int max_discount = 0;\n    \n    while (!q.empty()) {\n        auto [current_time, pos] = q.front();\n        int x = pos.first, y = pos.second;\n        q.pop();\n\n        for (auto &item : items) {\n            if (x == item.x && y == item.y && item.start_time <= current_time && current_time <= item.end_time) {\n                max_discount = max(max_discount, item.discount);\n            }\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] != -1 && !visited[nx][ny][current_time + 1]) {\n                visited[nx][ny][current_time + 1] = true;\n                q.push({current_time + 1, {nx, ny}});\n            }\n        }\n    }\n\n    return max_discount;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n\n        items.clear();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> grid[i][j];\n                if (grid[i][j] > 0) {\n                    int start_time, end_time, discount;\n                    cin >> start_time >> end_time >> discount;\n                    items.push_back({i, j, start_time, end_time, discount});\n                }\n            }\n        }\n\n        cout << bfs() << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:53:11"
  }
]