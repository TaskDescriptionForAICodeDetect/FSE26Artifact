[
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[20][20];\n\n// ツタツイツδ?セツーツδ仰づ個湘ョツ陛ア\nint n;\nint id[8],val[8],s[8],g[8];\nint val_sum[1<<8];\n\nint dp[101][20][20][1<<8];\nint dfs(int t,int y,int x,int S){\n\tint &res=dp[t][y][x][S];\n\tif(res!=-1) return res;\n\n\tif(t==100) return res=val_sum[S];\n\n\tint S_next=S;\n\trep(i,n) if(s[i]<=t && t<g[i] && (S&1<<i)==0){ // i ツ氾板姪堋づ個タツイツδ?セツーツδ?\n\t\tbool ok=false; // ツ療猟静堋マツスツづ可渉、ツ品 id[i] ツつェツつ?づゥツつゥツづ?つ、ツつゥ\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]==id[i]+'0') ok=true;\n\t\t}\n\t\tif(ok) S_next|=1<<id[i];\n\t}\n\n\tres=0;\n\trep(k,4){\n\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]=='.'){\n\t\t\tres=max(res,dfs(t+1,yy,xx,S_next));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) rep(j,w) scanf(\" %c\",B[i]+j);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n) scanf(\"%d%d%d%d\",id+i,val+i,s+i,g+i);\n\n\t\trep(S,1<<n){\n\t\t\tval_sum[S]=0;\n\t\t\trep(i,n) if(S&1<<i) val_sum[S]+=val[i];\n\t\t}\n\n\t\tint px,py;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='P') B[i][j]='.', px=j, py=i;\n\n\t\trep(t,101) rep(i,h) rep(j,w) rep(S,1<<n) dp[t][i][j][S]=-1;\n\t\tprintf(\"%d\\n\",dfs(0,py,px,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && sale[i].s<=d.t && d.t<sale[i].e)\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tif(visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 99)\n\t\t\t\tcontinue;\n\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.front().sum_discount);\n\n\t\tif(Q.front().time > dp[Q.front().state][Q.front().row][Q.front().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.front().row + diff_row[i];\n\t\t\t\tint adj_col = Q.front().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.front().state][adj_row][adj_col] > Q.front().time+1){\n\t\t\t\t\t\tdp[Q.front().state][adj_row][adj_col] = Q.front().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.front().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.front());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.front().visited[adj_item] == true || is_sale[adj_item] == false)continue;\n\n\t\t\t\t\tint next_state = Q.front().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.front().time >= info[adj_item].start && Q.front().time < info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] > Q.front().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.front().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.front());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.front().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.front());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N; cin >> N;\n        map<int, int> comp;\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            x.second = id++;\n        }\n        vector<int> inv(id);\n        for(auto x : comp) {\n            inv[x.second] = x.first;\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        int lim = 100, ans = 0;\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                bool ok = true;\n                int mx = x + dx[k], my = y + dy[k];\n                ok &= !(mx < 0 || mx >= H || my < 0 || my >= W);\n                ok &= ('0' <= board[mx][my] && board[mx][my] <= '9');\n\n                if(ok) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            // cand の部分集合\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost;\n                for(int i=0; i<id; i++) {\n                    int orig_id = inv[i]; // 復元する\n                    if(mask >> i & 1) ncost += disc[orig_id][time];\n                }\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                    if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n\n                    if(rec[nx][ny][ntime][nbit] < ncost) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n\n            for(int k=0; k<4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint dx[] = {0, 0, 0, +1, -1};\nint dy[] = {0, +1, -1, 0, 0};\n\nstruct Type\n{\n  int value, start, end;\n  Type(int value = 0, int start = 0, int end = 0) : value(value), start(start), end(end) {}\n};\n\nint H, W, N;\nType types[8];\nmap<char, int> table;\nchar board[20][20];\nint memo[20][20][101][1 << 8];\n\nint rec(int x, int y, int t, int used)\n{\n\tif(t == 101) return 0;\n\tif(used + 1 == 1 << N) return 0;\n\tif(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\t\n\tint res = 0;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\n\t\tif(0 <= nx && nx < W && 0 <= ny && ny <H)\n\t\t{\n\t\t\tchar data = board[nx][ny];\n\t\t\t\n\t\t\tif('0' <= data && data <= '9')\n\t\t\t{\n\t\t\t\tint idx = table[data];\n\t\t\t\tint s = types[idx].start;\n\t\t\t\tint e = types[idx].end;\n\t\t\t\t\n\t\t\t\tif(s <= t && t < e && (used & 1 << idx) == 0)\n\t\t\t\t\tres = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t\t}\n\t\t\telse res = max(res, rec(nx, ny, t + 1, used));\n\t\t}\n\t}\n\t\n\treturn memo[x][y][t][used] = res;\n}\t\n\nint solve()\n{\n\tmemset(memo, -1, sizeof memo);\n\t\n\tint X, Y;\n\t\n\tfor(int y = 0; y < H; y++)\n\t{\n\t\tfor(int x = 0; x < W; x++)\n\t\t{\n\t\t\tchar k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\tboard[x][y] = k;\n\t\t\t\n\t\t\tif(board[x][y] == 'P')\n\t\t\t{\n\t\t\t\tX = x;\n\t\t\t\tY = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tchar c;\n\t\tcin >> c >> types[i].value >> types[i].start >> types[i].end;\n\t\t\n\t\ttable[c] = i;\n\t}\n\t\n\treturn rec(X, Y, 0, 0);\n}\n\nint main()\n{\n  for(; cin >> W >> H && W;)\n  \tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nint x, y, dp[10][21][21][1 << 10];\nint g[10], d[10], s[10], e[10], n;\nchar c[21][21];\nint sale[10][105];\nint main(){\n    while(cin >> x >> y, x | y){\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++)\n\t\tfor(int k = 0;k < (1 << 8);k++)\n\t\t    dp[0][i][j][k] = -INF;\n\tfor(int i = 0;i < y;i++){\n\t    for(int j = 0;j < x;j++){\n\t\tcin >> c[i][j];\n\t\tif(c[i][j] == 'P'){\n\t\t    c[i][j] = '.';\n\t\t    dp[0][i][j][0] = 0;\n\t\t}\n\t    }\n\t}\n\tcin >> n;\n\tint used[10];\n\tfill(used, used + 10, 0);\n\tfor(int i = 0;i < 10;i++)\n\t    for(int j = 0;j < 105;j++)\n\t\tsale[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> g[i] >> d[i] >> s[i] >> e[i];\n\t    used[g[i]] = 1;\n\t}\n\tfor(int i = 1;i < 10;i++)used[i] += used[i - 1];\n\tfor(int i = 0;i < n;i++){\n\t    for(int j = s[i];j <= e[i];j++)\n\t\tsale[used[g[i]] - 1][j] = d[i];\n\t}\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++){\n\t\tif(c[i][j] != '.')c[i][j] = '0' + used[c[i][j] - '0'] - 1;\n\t    }\n\tint ans = 0;\n\tfor(int i = 0;i <= 100;i++){\n\t    for(int j = 0;j < y;j++){\n\t\tfor(int k = 0;k < x;k++){\n\t\t    if(c[j][k] != '.')continue;\n\t\t    int there = 0;\n\t\t    for(int l = 0;l < (1 << 8);l++){\n\t\t\tif(i){\n\t\t\t    dp[i & 1][j][k][l] = -INF;\n\t\t\t    for(int m = 0;m < 4;m++){\n\t\t\t\tint ty = j + ys[m], tx = k + xs[m];\n\t\t\t\tif(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t\tif(c[ty][tx] == '.')\n\t\t\t\t    dp[i & 1][j][k][l] = max(dp[(i + 1) & 1][ty][tx][l], dp[i & 1][j][k][l]);\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int m = 0;m < 4;m++){\n\t\t\t    int ty = j + ys[m], tx = k + xs[m];\n\t\t\t    if(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t    if(c[ty][tx] == '.')continue;\n\t\t\t    int pr = c[ty][tx] - '0';\n\t\t\t    if(l & (1 << pr)){\n\t\t\t\tdp[i & 1][j][k][l] = max(dp[i & 1][j][k][l], dp[i & 1][j][k][l - (1 << pr)] + sale[pr][i]);\n\n\t\t\t    }\n\t\t\t}\n\n\t\t\tans = max(dp[i & 1][j][k][l], ans);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <cstring>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nint st[32][32];\nint dp[32][32][1 << 8];\nint memo[1 << 8];\n\nconst int _dx[] = {0,0,1,0,-1};\nconst int _dy[] = {0,-1,0,1,0};\n\nint main(){\n  while(true){\n    const int w = getInt();\n    const int h = getInt();\n\n    if(w + h == 0) break;\n\n    int sx, sy;\n\n    REP(i,h) REP(j,w){\n      char c[2];\n      scanf(\"%s\", c);\n      if(c[0] == '.'){\n        st[i][j] = -1;\n      }else if(c[0] == 'P'){\n        st[i][j] = -1;\n        sx = j; sy = i;\n      }else{\n        st[i][j] = c[0] - '0';\n      }\n    }\n\n    const int n = getInt();\n\n    vector<int> g(n);\n    vector<int> d(n);\n    vector<int> s(n);\n    vector<int> e(n);\n\n    REP(i,n){\n      g[i] = getInt();\n      d[i] = getInt();\n      s[i] = getInt();\n      e[i] = getInt();\n    }\n\n    REP(i,h) REP(j,w) if(st[i][j] != -1){\n      REP(k,n) if(st[i][j] == g[k]){\n        st[i][j] = k;\n        break;\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    REP(i,1 << n){\n      memo[i] = 0;\n      REP(j,n) if(i & (1 << j))\n        memo[i] += d[j];\n    }\n\n    int sp = 0;\n    REP(i,5){\n      const int xx = sx + _dx[i];\n      const int yy = sy + _dy[i];\n      if(ISIN(xx, yy, w, h) && st[yy][xx] != -1){\n        const int p = st[yy][xx];\n        if(IN(0, s[p], e[p])){\n          sp |= (1 << p);\n        }\n      }\n    }\n\n    queue<pair<int, pair<int, int> > > q;\n    dp[sy][sx][sp] = 0;\n    q.push(make_pair(sp, make_pair(sx, sy)));\n\n    while(q.size()){\n      const pair<int, pair<int, int> > d = q.front(); q.pop();\n      const int f = d.first;\n      const int x = d.second.first;\n      const int y = d.second.second;\n      const int t = dp[y][x][f] + 1;\n\n      if(t == 100) break;\n\n      REP(i,5){\n        const int xx = x + _dx[i];\n        const int yy = y + _dy[i];\n\n        if(ISIN(xx, yy, w, h) && st[yy][xx] == -1){\n          int ff = f;\n          REP(j,5){\n            const int xxx = xx + _dx[j];\n            const int yyy = yy + _dy[j];\n\n            if(ISIN(xxx, yyy, w, h) && st[yyy][xxx] != -1){\n              const int p = st[yyy][xxx];\n              if(IN(t, s[p], e[p])){\n                ff |= (1 << p);\n              }\n            }\n          }\n\n          if(dp[yy][xx][ff] == -1 || i == 0){\n            dp[yy][xx][ff] = t;\n            q.push(make_pair(ff, make_pair(xx, yy)));\n          }\n        }\n      }\n    }\n\n    int ans = 0;\n    REP(i,h) REP(j,w) REP(k,1<<n)\n      if(dp[i][j][k] != -1)\n        ans = max(ans, memo[k]);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(p.t>100)continue;\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint w, h, n;\nchar mas[20][20];\n \ntypedef pair< int , int > Pi;\ntypedef pair< Pi , Pi > Piii;\nPi p;\n \nstruct sell{\n  int d; //値引き額\n  int s; //開始時刻\n  int e; //終了時刻\n};\nsell shop[10];\n \nint time_max;\n \nint min_cost[20][20][1 << 10];\n \nint bfs(){\n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)\n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n \n  memset( min_cost, -1, sizeof(min_cost));\n  que.push( Piii( Pi( 0, 0), p));\n  min_cost[p.second][p.first][0] = 0;\n \n  int ret = 0;\n \n  while(!que.empty()){\n \n    Piii p = que.front(); que.pop();\n \n    Pi point = p.second;\n    int bit = p.first.first, time = p.first.second;\n \n     \n    if(ret < min_cost[point.second][point.first][bit]){\n      ret = min_cost[point.second][point.first][bit];\n    }\n    if(time_max + 1 <= time /*|| bit == (1 << n) - 1 */){\n      continue;\n    }\n \n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n \n      int next_time = time + 1;\n \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n \n      if(isdigit(mas[ny][nx])){\n         \n        int time_sell = mas[ny][nx] - '0';\n \n        if(!((bit >> time_sell) & 1)){\n           \n          sell se = shop[time_sell];\n \n          if(se.s > next_time){ //待ってプッシュ\n \n            que.push( Piii( Pi( bit, se.s - 1), point));\n \n          } else if(se.s <= next_time && next_time <= se.e){ //時間内だったら買ってみる\n \n            int next_bit = bit | (1 << time_sell);\n            if(min_cost[point.second][point.first][bit] + se.d > min_cost[point.second][point.first][next_bit]){\n              que.push( Piii( Pi( next_bit, next_time - 1), point));\n              min_cost[point.second][point.first][next_bit] = min_cost[point.second][point.first][bit] + se.d;\n            }\n          }\n        }\n \n      } else {\n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){\n          que.push( Piii( Pi( bit, next_time), Pi( nx, ny)));\n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];\n        }\n      }\n    }\n  }\n  return ret;\n}\n \nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') p = Pi( j, i);\n      }\n    }\n    cin >> n;\n     \n    time_max = 0;\n \n    for(int i= 0; i < n; i++){\n      int g;\n      cin >> g;\n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;\n      time_max = max( shop[g].e, time_max);\n    }\n \n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n   int g, d, s, e;\n   S(){}\n   S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n   int y, x, used, t;\n   State(){}\n   State(int y, int x, int used, int t) : y(y), x(x), used(used), t(t) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n   bool vis[20][20][1<<10];\n   fill(vis[0][0], vis[20][0], false);\n   State u, v;\n   u = State(sy, sx, 0, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.y][u.x][u.used] = true;\n   while(!q.empty()){\n      u = q.front(); q.pop();\n      //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.'){\n            int num = conv[mapData[ny][nx] - '0'];\n            if(u.t < data[num].e && !((1 << num) & u.used)){\n               v.y = u.y;\n               v.x = u.x;\n               v.used = u.used | (1<<num);\n               v.t = max(u.t, data[num].s);\n               if(!vis[v.y][v.x][v.used]){\n                  vis[v.y][v.x][v.used] = true;\n                  q.push(v);\n               }\n            }\n         }\n      }\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.') continue;\n         if(!vis[ny][nx][u.used]){\n            vis[ny][nx][u.used] = true;\n            q.push(State(ny, nx, u.used, u.t+1));\n         }\n      }\n   }\n   int res = 0;\n   for(int k=0;k<(1<<n);k++){\n      bool f = false;\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            if(vis[i][j][k]){\n               f = true;\n               goto END;\n            }\n         }\n      }\n     END:;\n      if(f){\n         int sum = 0;\n         for(int i=0;i<n;i++){\n            if((1<<i) & k) sum += data[i].d;\n         }\n         res = max(res, sum);\n      }\n   }\n   return res;\n}\n\nmain(){\n   while(cin >> w >> h && (w|h)){\n      conv.clear();\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            cin >> mapData[i][j];\n            if(mapData[i][j] == 'P'){\n               mapData[i][j] = '.';\n               sy = i;\n               sx = j;\n            }\n         }\n      }\n      cin >> n;\n      for(int i=0;i<n;i++){\n         int a, b, c, d;\n         cin >> a >> b >> c >> d;\n         data[i] = S(a, b, c, d);\n         conv[a] = i;\n      }\n      cout << bfs() << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N, lim = 0, ans = 0; cin >> N;\n        map<int, int> comp;\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            chmax(lim, e + 1);\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            x.second = id++;\n        }\n        vector<int> inv(id);\n        for(auto x : comp) {\n            inv[x.second] = x.first;\n        }\n\n        // cand の部分集合\n        vector< vector<int> > sum(1 << id, vector<int>(lim));\n        for(int bit=0; bit<(1<<id); bit++) {\n            for(int i=0; i<id; i++) {\n                if(bit >> i & 1) {\n                    int orig_id = inv[i];\n                    for(int t=0; t<lim; t++) {\n                        sum[bit][t] += disc[orig_id][t];\n                    }\n                }\n            }\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                bool ok = true;\n                int mx = x + dx[k], my = y + dy[k];\n                ok &= !(mx < 0 || mx >= H || my < 0 || my >= W);\n                ok &= ('0' <= board[mx][my] && board[mx][my] <= '9');\n\n                if(ok) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost + sum[mask][time];\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                    if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n\n                    if(rec[nx][ny][ntime][nbit] < ncost) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n\n            for(int k=0; k<4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n#define create clear\n\ntypedef pair< int , int > Pi;\n\nint w, h, n, sx, sy;\nchar mas[20][20];\nstruct sell{\n  int d, s, e; //終了時刻  \n};\nsell shop[10];\nvector< vector< Pi > > hori_sensei;\nint dp[1 << 8][20][20][101];\nint cost[20][20][20][20];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nqueue< Pi > que;\nvoid bfs(int y, int x){\n  que.push( Pi( x, y));\n  cost[y][x][y][x] = 0;\n  while(!que.empty()){\n    Pi p = que.front();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int ny = p.second + dy[i], nx = p.first + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] != '.') continue;\n      if(cost[y][x][ny][nx]  > cost[y][x][p.second][p.first] + 1){\n        cost[y][x][ny][nx] = cost[y][x][p.second][p.first] + 1;\n        que.push( Pi( nx, ny));\n      }\n    }\n  } \n  return ;\n}\nint main(){\n\n  while(cin >> w >> h, w){\n\n    hori_sensei.create();\n    hori_sensei.resize(10);\n    int INF = 1 << 30;\n    fill_n( ***cost, 20 * 20 * 20 * 20, INF);\n    memset( dp, -1, sizeof(dp));\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P'){\n          mas[i][j] = '.';\n          sx = j, sy = i;\n        }\n      }\n    }\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(mas[i][j] == '.'){\n          for(int k = 0; k < 4; k++){\n            int ny = i + dy[k], nx = j + dx[k];\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] == '.') continue;\n            hori_sensei[mas[ny][nx] - '0'].push_back( Pi( i, j));\n          }\n          bfs(i,j);\n        }\n      }\n    }\n\n\n    cin >> n;\n    int change[10] = {};\n    for(int i = 0; i < 10; i++) shop[i].d = -1;\n    for(int i = 0; i < n; i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      shop[i] = (sell){ b, c, d};\n      change[i] = a;\n    }\n\n    dp[0][sy][sx][0] = 0;\n    for(int time = 0; time < 101; time++){\n      for(int i = 0; i < (1 << 8); i++){\n        for(int y = 0; y < h; y++){\n          for(int x = 0; x < w; x++){\n            if(dp[i][y][x][time] == -1 || mas[y][x] != '.') continue;\n            for(int j = 0; j < n; j++){\n              if((i >> j) & 1 || time >= shop[j].e) continue;\n              for(int k = 0; k < hori_sensei[j].size(); k++){\n                int res = cost[y][x][hori_sensei[change[j]][k].first][hori_sensei[change[j]][k].second];\n                if(time + res >= shop[j].e) continue;\n                int& ret = dp[i|(1 << j)][hori_sensei[j][k].first][hori_sensei[change[j]][k].second][max(time + res, shop[j].s)];\n                ret = max( ret, dp[i][y][x][time] + shop[j].d);\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << *max_element( dp[0][0][0], dp[1 << 8][0][0]) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N, lim = 0, ans = 0; cin >> N;\n        map<int, int> comp;\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            chmax(lim, e + 1);\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            x.second = id++;\n        }\n        vector<int> inv(id);\n        for(auto x : comp) {\n            inv[x.second] = x.first;\n        }\n\n        // cand の部分集合\n        vector< vector<int> > sum(1 << id, vector<int>(lim));\n        for(int bit=0; bit<(1<<id); bit++) {\n            for(int i=0; i<id; i++) {\n                if(bit >> i & 1) {\n                    int orig_id = inv[i];\n                    for(int t=0; t<lim; t++) {\n                        sum[bit][t] += disc[orig_id][t];\n                    }\n                }\n            }\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                bool ok = true;\n                int mx = x + dx[k], my = y + dy[k];\n                ok &= !(mx < 0 || mx >= H || my < 0 || my >= W);\n                ok &= ('0' <= board[mx][my] && board[mx][my] <= '9');\n\n                if(ok) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost + sum[mask][time];\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                    if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n\n                    if(rec[nx][ny][ntime][nbit] < ncost) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n     \nint w, h, n;  \nchar mas[20][20];  \nint change[10];\ntypedef pair< int , int > Pi;  \ntypedef pair< Pi , Pi > Piii;\ntypedef pair< Piii, int > Piiii;\nPi p;  \n     \nstruct sell{  \n  int d; //値引き額  \n  int s; //開始時刻  \n  int e; //終了時刻  \n};  \nsell shop[10];  \n     \nint min_cost[20][20][1 << 10];\n     \nint bfs(){  \n  priority_queue< Piiii, vector< Piiii >, greater< Piiii > > que; // Pii( (買った商品, 今の時間), 座標)  \n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};  \n     \n  memset( min_cost, -1, sizeof(min_cost));  \n  que.push( Piiii( Piii( Pi( 0, 0), p), 0));  \n  min_cost[p.second][p.first][0] = 0;  \n     \n  int ret = 0;  \n     \n  while(!que.empty()){  \n     \n    Piiii p = que.top(); que.pop();  \n     \n    Pi point = p.first.second;  \n    int bit = p.first.first.second, time = p.first.first.first;\n    int cost = p.second;\n\n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n      if(!isdigit(mas[ny][nx])) continue;\n      int pos = change[mas[ny][nx] - '0'];\n      if(pos == -1) continue;\n      if(shop[pos].s <= time && time <= shop[pos].e && !((bit >> pos) & 1)){\n        bit |= (1 << pos);\n        cost += shop[pos].d;\n      }\n    }\n    if(cost < min_cost[point.second][point.first][bit]){\n      continue;\n    }\n    min_cost[point.second][point.first][bit] = max( cost, min_cost[point.second][point.first][bit]);\n\n    \n    if(ret < min_cost[point.second][point.first][bit]){  \n      ret = min_cost[point.second][point.first][bit];  \n    }  \n     \n    for(int i = 0; i < 4; i++){  \n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;  \n     \n      if(isdigit(mas[ny][nx])){  \n        int time_sell = change[mas[ny][nx] - '0'];\n        if(time_sell == -1) continue;\n        if(!((bit >> time_sell) & 1)){\n          sell se = shop[time_sell];\n          if(se.s > time){\n            que.push( Piiii( Piii( Pi( se.s, bit), point), cost));\n          }\n        }    \n      } else {  \n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){ \n          que.push( Piiii( Piii( Pi( time + 1, bit), Pi( nx, ny)), cost));  \n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];  \n        }  \n      }  \n    }  \n  }  \n  return ret;  \n}  \n     \nint main(){  \n  while(cin >> w >> h, w){  \n    for(int i = 0; i < h; i++){  \n      for(int j = 0; j < w; j++){  \n        cin >> mas[i][j];  \n        if(mas[i][j] == 'P') p = Pi( j, i);  \n      }  \n    }  \n    cin >> n;  \n    memset( change, -1, sizeof(change));\n    for(int i= 0; i < n; i++){  \n      int g;  \n      cin >> g;  \n      cin  >> shop[i].d >> shop[i].s >> shop[i].e;\n      change[i] = g;\n    }\n     \n    cout << bfs() << endl;  \n  }  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvc grid(h,vc(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>grid[i][j];\n\t\tint n; cin>>n;\n\t\tvi gs(n),ds(n),ss(n),es(n);\n\t\trep(i,n)\n\t\t\tcin>>gs[i]>>ds[i]>>ss[i]>>es[i];\n\t\t\n\t\trep(i,h) rep(j,w){\n\t\t\tif(!isdigit(grid[i][j]))\n\t\t\t\tcontinue;\n\t\t\tgrid[i][j]=find(all(gs),grid[i][j]-'0')-gs.begin()+'0';\n\t\t}\n\t\t\n\t\tstatic int dp[101][10][10][1<<10]; // [t][i][j][bit]\n\t\tmemset(dp,0,sizeof dp);\n\t\t\n\t\t//rep(i,h) rep(j,w)\n\t\t//\tif(grid[i][j]=='P'){\n\t\t//\t\tdp[0][i][j][0]=1;\n\t\t//\t\tgrid[i][j]='.';\n\t\t//\t}\n\t\t//\n\t\t//rep(t,100) rep(i,h) rep(j,w) rep(k,1<<n){\n\t\t//\tif(dp[t][i][j][k]==0)\n\t\t//\t\tcontinue;\n\t\t//\trep(_,4){\n\t\t//\t\tint ni=i+\"\\xff\\x1\\0\\0\"[_],nj=j+\"\\0\\0\\xff\\x1\"[_];\n\t\t//\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t//\t\t\tcontinue;\n\t\t//\t\tif(isdigit(grid[ni][nj])){\n\t\t//\t\t\tint item=grid[ni][nj]-'0';\n\t\t//\t\t\tif(ss[item]<=t && t<es[item])\n\t\t//\t\t\t\tdp[t][i][j][k|1<<grid[ni][nj]-'0']=1;\n\t\t//\t\t}\n\t\t//\t\tif(grid[ni][nj]=='.')\n\t\t//\t\t\tdp[t+1][ni][nj][k]=1;\n\t\t//\t}\n\t\t//}\n\t\t\n\t\tvi ps(1<<n);\n\t\trep(i,1<<n) rep(j,n)\n\t\t\tif(i&1<<j)\n\t\t\t\tps[i]+=ds[j];\n\t\t\n\t\tint res=0;\n\t\trep(i,h) rep(j,w) rep(k,1<<n){\n\t\t\tif(dp[100][i][j][k])\n\t\t\t\tres=max(res,ps[k]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_T 150\n\nstruct Data{\n    int n,c,s,t;\n    Data(){}\n    Data(int n,int c,int s,int t) :\n        n(n),c(c),s(s),t(t) {}\n\n    bool operator < (const Data &d)const{\n        return n < d.n;\n    }\n};\n\nint H,W,LIMIT;\nint memo[MAX_H][MAX_W][MAX_T][1<<8];\nvector<Data> v;\nchar field[MAX_H][MAX_W];\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nbool check(int nt,int idx){\n    return (v[idx].s <= nt && nt < v[idx].t);\n}\n\nint solve(int x,int y,int t,int p){\n    if(t == LIMIT) return 0;\n    int &res = memo[x][y][t][p];\n    if(res != -1) return res;\n    int S = p,cost = 0;\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == '.') continue;\n        int x = field[ny][nx]-'0';\n        if(S >> x & 1) continue;\n        if(check(t,x)){\n            S |= (1<<x);\n            cost += v[x].c;\n        }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] != '.') continue;\n        res = max(res,solve(nx,ny,t+1,S)+cost);\n    }\n    return res;\n}\n\nint main(){\n    int sx,sy,N;\n    while(cin >> W >> H, W){\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                cin >> field[i][j];\n                if(field[i][j] == 'P'){\n                    sx = j; sy = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n        LIMIT = 0;\n        cin >> N;\n        v.clear(); v.resize(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].n >> v[i].c >> v[i].s >> v[i].t;\n            LIMIT = max(LIMIT,v[i].t);\n        }\n        LIMIT++;\n        memset(memo,-1,sizeof(memo));\n        cout << solve(sx,sy,0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n   int g, d, s, e;\n   S(){}\n   S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n   int y, x, used, t;\n   State(){}\n   State(int y, int x, int used, int t) : y(y), x(x), used(used), t(t) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n   bool vis[20][20][1<<10];\n   fill(vis[0][0], vis[20][0], false);\n   State u, v;\n   u = State(sy, sx, 0, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.y][u.x][u.used] = true;\n   while(!q.empty()){\n      u = q.front(); q.pop();\n      //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.'){\n            int num = conv[mapData[ny][nx] - '0'];\n            if(u.t < data[num].e && !((1 << num) & u.used)){\n               v = u;\n               v.used = u.used | (1<<num);\n               v.t = max(u.t, data[num].s);\n               if(!vis[v.y][v.x][v.used]){\n                  vis[v.y][v.x][v.used] = true;\n                  q.push(v);\n               }\n            }\n         }\n      }\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.') continue;\n         if(!vis[ny][nx][u.used]){\n            vis[ny][nx][u.used] = true;\n            q.push(State(ny, nx, u.used, u.t+1));\n         }\n      }\n   }\n   int res = 0;\n   for(int k=0;k<(1<<n);k++){\n      for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(vis[i][j][k]) goto END;\n      continue;\n     END:;\n      int sum = 0;\n      for(int i=0;i<n;i++) if((1<<i) & k) sum += data[i].d;\n      res = max(res, sum);\n   }\n   return res;\n}\n\nmain(){\n   while(cin >> w >> h && (w|h)){\n      conv.clear();\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            cin >> mapData[i][j];\n            if(mapData[i][j] == 'P'){\n               mapData[i][j] = '.';\n               sy = i;\n               sx = j;\n            }\n         }\n      }\n      cin >> n;\n      for(int i=0;i<n;i++){\n         int a, b, c, d;\n         cin >> a >> b >> c >> d;\n         data[i] = S(a, b, c, d);\n         conv[a] = i;\n      }\n      cout << bfs() << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[21][21];\nint dp[2][1 << 8][21][21];\nint good[21][21];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 21; k++) {\n        for (int l = 0; l < 21; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t//dp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t\tdp[state][row][col] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"row:%d col:%d time:%d sum:%d state:%d\\n\",Q.front().row,Q.front().col,Q.front().time,Q.front().sum_discount,Q.front().state);\n\n\t\tmax_value = max(max_value,Q.front().sum_discount);\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.front().row + diff_row[i];\n\t\t\tint adj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\tif(dp[Q.front().state][adj_row][adj_col] < Q.front().sum_discount){\n\t\t\t\t\tdp[Q.front().state][adj_row][adj_col] = Q.front().sum_discount;\n\n\t\t\t\t\tSALE next_sale;\n\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\tnext_sale.time = Q.front().time+1;\n\n\t\t\t\t\t//printf(\"?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t}\n\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\tif(Q.front().state & (1 << adj_item))continue;\n\t\t\t\tif(is_sale[adj_item] == false)continue;\n\n\t\t\t\tint next_state = Q.front().state + POW[adj_item];\n\n\t\t\t\tif(Q.front().time >= info[adj_item].start && Q.front().time < info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\tnext_sale.time = Q.front().time;\n\n\t\t\t\t\t\t//printf(\"?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t}\n\n\t\t\t\t}else if(Q.front().time < info[adj_item].start){\n\n\t\t\t\t\t/*if(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;*/\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\n\t\t\t\t\t\t//printf(\"?????\\?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && ((sale[i].s<=d.t && d.t<sale[i].e) || (sale[i].s==sale[i].e && sale[i].s==d.t)))\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 100 || visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\n\t\t\tQ.push(Data(d.y, d.x, d.t+1, d.mask));\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint W, H;\nchar map[20][20];\nint can_buy[20][20];\nint N;\nint G[8], D[8], S[8], E[8];\nint dp[1<<8][20][20][101];\n\nbool didGoSame(int state, int v){\n    REP(i, N){\n        if(state >> i & 1 && G[i] == G[v]){return true;}\n    }\n    return false;\n}\n\nint rec(int state, int x, int y, int t){\n    // printf(\"%d, %d, %d\\n\", x, y, t);\n    assert(!(x == 3 && y == 0 && t == 4));\n    if(t > 100){return 0;}\n    if(dp[state][x][y][t] != -1){return dp[state][x][y][t];}\n\n    int res = 0;\n    REP(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n            res = std::max(res, rec(state, nx, ny, t+1));\n            if(can_buy[y][x] != -1){\n                REP(j, N){\n                    // printf(\"%d, %d: %d\\n\", x, y, t);\n                    if(!(state >> j & 1) && !didGoSame(state, j) && G[j] == can_buy[y][x] && S[j] <= t && t < E[j]){\n                        res = std::max(res, D[j] + rec(state | 1 << j, nx, ny, t+1));\n                    }\n                }\n            }\n        }\n    }\n\n    return dp[state][x][y][t] = res;\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        REP(i, 20){\n            REP(j, 20){\n                can_buy[i][j] = -1;\n            }\n        }\n\n        REP(i, 1<<8){\n            REP(j, 20){\n                REP(k, 20){\n                    REP(l, 101){\n                        dp[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n\n        int sx, sy;\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n                if(map[i][j] == 'P'){\n                    map[i][j] = '.';\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        REP(y, H){\n            REP(x, W){\n                REP(k, 4){\n                    if(map[y][x] == '.'){continue;}\n                    int nx = x + dx[k], ny = y + dy[k];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n                        can_buy[ny][nx] = map[y][x] - '0';\n                    }\n                }\n            }\n        }\n\n        std::cin >> N;\n\n        REP(i, N){\n            std::cin >> G[i] >> D[i] >> S[i] >> E[i];\n        }\n\n        std::cout << rec(0, sx, sy, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\n\nclass S{\npublic:\n   lli g, d, s, e;\n   S(){}\n   S(lli g, lli d, lli s, lli e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n   lli y, x, used, t;\n   State(){}\n   State(lli y, lli x, lli used, lli t) : y(y), x(x), used(used), t(t) {}\n};\n\nlli w, h, n;\nchar mapData[20][20];\nmap<lli, lli> conv;\nS data[10];\nlli sy, sx;\nlli dy[] = {-1, 0, 1, 0};\nlli dx[] = {0, 1, 0, -1};\n\nlli bfs(){\n   bool vis[20][20][1<<10];\n   fill(vis[0][0], vis[20][0], false);\n   State u, v;\n   u = State(sy, sx, 0, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.y][u.x][u.used] = true;\n   while(!q.empty()){\n      u = q.front(); q.pop();\n      //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n      for(lli i=0;i<4;i++){\n         lli ny = u.y + dy[i];\n         lli nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.'){\n            lli num = conv[mapData[ny][nx] - '0'];\n            if(u.t < data[num].e && !((1 << num) & u.used)){\n               v = u;\n               v.used = u.used | (1<<num);\n               v.t = max(u.t, data[num].s);\n               if(!vis[v.y][v.x][v.used]){\n                  vis[v.y][v.x][v.used] = true;\n                  q.push(v);\n               }\n            }\n         }\n      }\n      for(lli i=0;i<4;i++){\n         lli ny = u.y + dy[i];\n         lli nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.') continue;\n         if(!vis[ny][nx][u.used]){\n            vis[ny][nx][u.used] = true;\n            q.push(State(ny, nx, u.used, u.t+1));\n         }\n      }\n   }\n   lli res = 0;\n   for(lli k=0;k<(1<<n);k++){\n      for(lli i=0;i<h;i++) for(lli j=0;j<w;j++) if(vis[i][j][k]) goto END;\n      continue;\n     END:;\n      lli sum = 0;\n      for(lli i=0;i<n;i++) if((1<<i) & k) sum += data[i].d;\n      res = max(res, sum);\n   }\n   return res;\n}\n\nmain(){\n   while(cin >> w >> h && (w|h)){\n      conv.clear();\n      for(lli i=0;i<h;i++){\n         for(lli j=0;j<w;j++){\n            cin >> mapData[i][j];\n            if(mapData[i][j] == 'P'){\n               mapData[i][j] = '.';\n               sy = i;\n               sx = j;\n            }\n         }\n      }\n      cin >> n;\n      for(lli i=0;i<n;i++){\n         lli a, b, c, d;\n         cin >> a >> b >> c >> d;\n         data[i] = S(a, b, c, d);\n         conv[a] = i;\n      }\n      cout << bfs() << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\t//return sum_discount < arg.sum_discount;\n\t\t\treturn sum_discount > arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t//dp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t\tdp[state][row][col] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"row:%d col:%d time:%d sum:%d state:%d\\n\",Q.front().row,Q.front().col,Q.front().time,Q.front().sum_discount,Q.front().state);\n\n\t\tmax_value = max(max_value,Q.front().sum_discount);\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.front().row + diff_row[i];\n\t\t\tint adj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\tif(dp[Q.front().state][adj_row][adj_col] < Q.front().sum_discount){\n\t\t\t\t\tdp[Q.front().state][adj_row][adj_col] = Q.front().sum_discount;\n\n\t\t\t\t\tSALE next_sale;\n\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\tnext_sale.time = Q.front().time+1;\n\n\t\t\t\t\t//printf(\"?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t}\n\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\tif(Q.front().state & (1 << adj_item))continue;\n\t\t\t\tif(is_sale[adj_item] == false)continue;\n\n\t\t\t\tint next_state = Q.front().state + POW[adj_item];\n\n\t\t\t\tif(Q.front().time >= info[adj_item].start && Q.front().time < info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\tnext_sale.time = Q.front().time;\n\n\t\t\t\t\t\t//printf(\"?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t}\n\n\t\t\t\t}else if(Q.front().time < info[adj_item].start){\n\n\t\t\t\t\t/*if(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;*/\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\n\t\t\t\t\t\t//printf(\"?????\\?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t/*}\n\t\t\t\t}*/\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[next][state | s][ny][nx] =\n                  max(dp[next][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    assert(false);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20][101];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0, 0};\n\tint dy[] = {0, 1, 0, -1, 0};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tv[0][st.ty][st.tx][0] = true;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y && ~map[my][mx]\n\t\t\t\t\t\t&& s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\tif (!((temp.bit >> map[my][mx]) & 1)){\n\t\t\t\t\t\ttemp.score += plus[map[my][mx]];\n\t\t\t\t\t}\n\t\t\t\t\ttemp.bit |= (1 << map[my][mx]);\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 5; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx][temp.time + 1] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tv[st.bit][st.ty][st.tx][st.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nint x, y, dp[10][21][21][1 << 10];\nint g, d, s, e, n;\nchar c[21][21];\nint sale[10][105];\nint main(){\n    while(cin >> x >> y, x | y){\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++)\n\t\tfor(int k = 0;k < (1 << 10);k++)\n\t\t    dp[0][i][j][k] = -INF;\n\tfor(int i = 0;i < y;i++){\n\t    for(int j = 0;j < x;j++){\n\t\tcin >> c[i][j];\n\t\tif(c[i][j] == 'P'){\n\t\t    c[i][j] = '.';\n\t\t    dp[0][i][j][0] = 0;\n\t\t}\n\t    }\n\t}\n\tcin >> n;\n\tfor(int i = 0;i < 10;i++)\n\t    for(int j = 0;j < 105;j++)\n\t\tsale[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> g >> d >> s >> e;\n\t    for(int j = s;j <= e;j++)\n\t\tsale[g][j] = d;\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i <= 100;i++){\n\t    for(int j = 0;j < y;j++){\n\t\tfor(int k = 0;k < x;k++){\n\t\t    if(c[j][k] != '.')continue;\n\t\t    int there = 0;\n\t\t    for(int l = 0;l < (1 << 10);l++){\n\t\t\tif(i){\n\t\t\t    dp[i & 1][j][k][l] = -INF;\n\t\t\t    for(int m = 0;m < 4;m++){\n\t\t\t\tint ty = j + ys[m], tx = k + xs[m];\n\t\t\t\tif(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t\tif(c[ty][tx] == '.')\n\t\t\t\t    dp[i & 1][j][k][l] = max(dp[(i + 1) & 1][ty][tx][l], dp[i & 1][j][k][l]);\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int m = 0;m < 4;m++){\n\t\t\t    int ty = j + ys[m], tx = k + xs[m];\n\t\t\t    if(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t    if(c[ty][tx] == '.')continue;\n\t\t\t    int pr = c[ty][tx] - '0';\n\t\t\t    if(l & (1 << pr)){\n\t\t\t\tdp[i & 1][j][k][l] = max(dp[i & 1][j][k][l], dp[i & 1][j][k][l - (1 << pr)] + sale[pr][i]);\n\n\t\t\t    }\n\t\t\t}\n\n\t\t\tans = max(dp[i & 1][j][k][l], ans);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N, lim = 0, ans = 0; cin >> N;\n        vector<int> comp(10, -1);\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            chmax(lim, e + 1);\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            if(x >= 0) x = id++;\n        }\n        vector<int> inv(id);\n        for(int i=0; i<10; i++) {\n            if(comp[i] < 0) continue;\n            inv[ comp[i] ] = i;\n        }\n\n        // cand の部分集合\n        vector< vector<int> > sum(1 << id, vector<int>(lim));\n        for(int bit=0; bit<(1<<id); bit++) {\n            for(int i=0; i<id; i++) {\n                if(bit >> i & 1) {\n                    int orig_id = inv[i];\n                    for(int t=0; t<lim; t++) {\n                        sum[bit][t] += disc[orig_id][t];\n                    }\n                }\n            }\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                int mx = x + dx[k], my = y + dy[k];\n                if(!(mx < 0 || mx >= H || my < 0 || my >= W) and ('0' <= board[mx][my] && board[mx][my] <= '9')) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost + sum[mask][time];\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(!(nx < 0 || nx >= H || ny < 0 || ny >= W) and !('0' <= board[nx][ny] && board[nx][ny] <= '9') and (rec[nx][ny][ntime][nbit] < ncost)) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cctype>\nusing namespace std;\ntypedef pair< int , int > Pt;\ntypedef pair< Pt , Pt > P; // Pt(cost,bit) , Pt(y,x)\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nconst int dx[] = { 0, 1, -1, 0}, dy[] = { 1, 0, 0, -1};\nstruct edge{\n  int prime,st,ed;\n  edge(){};\n  edge(int prime,int st,int ed):prime(prime),st(st),ed(ed){};\n};\nedge info[10];\nint x, y;\nchar mas[20][20];\nbool no_over(int ny,int nx){\n  return ny >= 0 && ny < y && nx >= 0 && nx < x;\n}\nint bfs(Pt& start){\n  int ret = 0;\n  int used[20][20][1<<10];\n  fill_n(used[0][0],20*20*(1<<10),INF);\n  queue< P > que;\n  que.push(P(Pt((1<<10)-1,0),start));\n  used[start.fr][start.sc][(1<<10)-1] = 0;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n      if(!no_over(ny,nx)) continue;\n      if(isdigit(mas[ny][nx])){\n        edge e = info[mas[ny][nx]-'0'];\n        int no = mas[ny][nx] - '0';\n        ny = p.sc.fr, nx = p.sc.sc;\n        if(!((p.fr.fr >> no) & 1)) continue;\n        if(!(used[ny][nx][p.fr.fr] >= e.st && used[ny][nx][p.fr.fr] <= e.ed)) continue; //時間外\n        if(used[ny][nx][p.fr.fr] < used[ny][nx][p.fr.fr&~(1<<no)]){\n          used[ny][nx][p.fr.fr&~(1<<no)] = used[ny][nx][p.fr.fr];\n          que.push(P(Pt(p.fr.fr&~(1<<no),p.fr.sc+e.prime),Pt(ny,nx)));\n          ret = max(ret,p.fr.sc+e.prime);\n        }\n      }else{\n        if(used[p.sc.fr][p.sc.sc][p.fr.fr] + 1 < used[ny][nx][p.fr.fr]){\n          used[ny][nx][p.fr.fr] = used[p.sc.fr][p.sc.sc][p.fr.fr] + 1;\n          que.push(P(Pt(p.fr.fr,p.fr.sc),Pt(ny,nx)));\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> x >> y , x){\n    Pt st;\n    for(int i = 0 ; i < y ; i++ ){\n      for(int j = 0 ; j < x ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') st = Pt(i,j) , mas[i][j] = '.';\n      }\n    }\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; i++ ){\n      int g,d,s,e;\n      cin >> g >> d >> s >> e;\n      info[g] = edge(d,s,e);\n    }\n    cout << bfs(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t//dp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t\tdp[state][row][col] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"row:%d col:%d time:%d sum:%d state:%d\\n\",Q.front().row,Q.front().col,Q.front().time,Q.front().sum_discount,Q.front().state);\n\n\t\tmax_value = max(max_value,Q.front().sum_discount);\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.front().row + diff_row[i];\n\t\t\tint adj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\tif(dp[Q.front().state][adj_row][adj_col] < Q.front().sum_discount){\n\t\t\t\t\tdp[Q.front().state][adj_row][adj_col] = Q.front().sum_discount;\n\n\t\t\t\t\tSALE next_sale;\n\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\tnext_sale.time = Q.front().time+1;\n\n\t\t\t\t\t//printf(\"?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t}\n\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\tif(Q.front().state & (1 << adj_item))continue;\n\t\t\t\tif(is_sale[adj_item] == false)continue;\n\n\t\t\t\tint next_state = Q.front().state + POW[adj_item];\n\n\t\t\t\tif(Q.front().time >= info[adj_item].start && Q.front().time < info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\tnext_sale.time = Q.front().time;\n\n\t\t\t\t\t\t//printf(\"?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t}\n\n\t\t\t\t}else if(Q.front().time < info[adj_item].start){\n\n\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\n\t\t\t\t\t\t//printf(\"?????\\?????? row:%d col:%d?????????%d state:%d??§????§?\\n\",adj_row,adj_col,Q.front().time+1,Q.front().state);\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nconst int NONE = -1;\n\nconst int DY[4] = {0, 1, 0, -1};\nconst int DX[4] = {1, 0, -1, 0};\n\nenum{TIME, Y, X, BOUGHT};\ntypedef tuple<int, int, int, unsigned long> Vertex;\nenum{COST, VERTEX};\ntypedef tuple<int, Vertex> Node;\n\nenum {GOODS, DISCOUNT, START, END};\ntypedef tuple<int, int, int, int> Sale;\n\nint h, w;\nvector<vector<int>> m;\nvector<Sale> sale;\n\nint bfs(const Vertex& start) {\n    int result = 0;\n    map<Vertex, int> memo;\n    queue<Node> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        int cost = get<COST>(q.front());\n        Vertex v = get<VERTEX>(q.front());\n        int time = get<TIME>(v);\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        unsigned long bought = get<BOUGHT>(v);\n        q.pop();\n        if(memo.count(v) && memo[v] >= cost) continue;\n        memo[v] = cost;\n        result = max(result, cost);\n        if(time > 100) continue;\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(m[ny][nx] == NONE) continue;\n            if(bought & (1 << m[ny][nx])) continue;\n            for(const auto& s: sale) {\n                if(get<GOODS>(s) != m[ny][nx]) continue;\n                if(time < get<START>(s) || get<END>(s) <= time) continue;\n                bought |= 1 << m[ny][nx];\n                cost += get<DISCOUNT>(s);\n            }\n        }\n        time += 1;\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(m[ny][nx] != NONE) continue;\n            q.push(Node(cost, Vertex(time, ny, nx, bought)));\n        }\n    }\n    return result;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        Vertex start;\n        m = vector<vector<int>>(h, vector<int>(w, NONE));\n        for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '.') continue;\n            else if(c == 'P') start = Vertex(0, i, j, 0);\n            else m[i][j] = c - '0';\n        }\n\n        sale.clear();\n        int n;\n        cin >> n;\n        for(int i = 0; i < n; ++i) {\n            int g, d, s, e;\n            cin >> g >> d >> s >> e;\n            sale.push_back(Sale(g, d, s, e));\n        }\n\n        cout << bfs(start) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 21; k++) {\n        for (int l = 0; l < 21; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 29\n#define EPS 1e-10\n\ntypedef pair<int, int> P;\ntypedef pair<int,P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint G[512][512], m[20][20], used[8];\nint X, Y;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nint N;\nint d[8], s[8], e[8];\nvector<vector<P> >shop(8);\nint dp[32][32][128][8];\n\nint dfs(int y, int x, int t, int n){\n  //  printf(\"%d %d %d %d\\n\", y, x, t, n);\n  if(n == N) return 0;\n  //  if(dp[y][x][t][n] >= 0) return dp[y][x][t][n];\n  int res = 0;\n  rep(i, N){\n    if(used[i]) continue;\n\n    used[i] = 1;\n    rep(j, shop[i].size()){\n      P p = shop[i][j];\n      int dis = G[y*X+x][p.F*X+p.S];\n      int time = dis + t;\n      if(s[i] > time || e[i] <= time) continue;\n      res = max(res, dfs(p.F, p.S, time, n+1) + d[i]);\n    }\n    used[i] = 0;\n  }\n  //  printf(\"%d\\n\", res);\n  //  return dp[y][x][t][n] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int y, x;\n    memset(dp, -1, sizeof(dp));\n    memset(used, 0, sizeof(used));\n    rep(i, Y*X) rep(j, Y*X) G[i][j] = INF;\n    rep(i, Y) rep(j, X){\n      char c[2];\n      scanf(\"%s\", c);\n      if(c[0] == 'P'){\n\ty = i;\n\tx = j;\n\tc[0] = '.';\n      }\n      m[i][j] = c[0];\n\n    }\n\n    rep(i, Y) rep(j, X){\n      if(!(m[i][j] == '.' || m[i][j] == 'P')) continue;\n      G[i*X+j][i*X+j] = 0;\n      rep(d, 4){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(ny < 0 || ny >= Y || nx < 0 || nx >= X) continue;\n\tif(!(m[ny][nx] == '.' || m[ny][nx] == 'P')) continue;\n\tG[i*X+j][ny*X+nx] = 1;\n      }\n    }\n\n\n    rep(k, Y*X) rep(i, Y*X) rep(j, Y*X){\n      G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    scanf(\"%d\", &N);\n    rep(i, N){\n      int g;\n      scanf(\"%d\", &g);\n      scanf(\"%d%d%d\",  &d[g], &s[g], &e[g]);\n    }\n\n    rep(i, Y) rep(j, X){\n      if(m[i][j] == '.') continue;\n      int item = m[i][j] - '0';\n      rep(d, 4){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(ny < 0 || ny >= Y || nx < 0 || nx >= X || m[ny][nx] != '.') continue;\n\tshop[item].PB(P(ny, nx));\n      }\n    }\n\n    /*    rep(i, Y*X){\n      rep(j, Y*X) if(G[i][j] == INF) printf(\" INF\"); else printf(\"%4d\", G[i][j]); \n      puts(\"\");\n      }*/\n\n    /*    rep(i, N){\n      printf(\"%d\\n\", d[i]);\n      }*/\n    //    printf(\"%d\\n\", N);\n    printf(\"%d\\n\", dfs(y, x, 0, 0));\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n     \nint w, h, n;  \nchar mas[20][20];  \nint change[10];\ntypedef pair< int , int > Pi;  \ntypedef pair< Pi , Pi > Piii;\ntypedef pair< Piii, int > Piiii;\nPi p;  \n     \nstruct sell{  \n  int d; //値引き額  \n  int s; //開始時刻  \n  int e; //終了時刻  \n};  \nsell shop[10];  \n     \nint min_cost[20][20][1 << 10];\n     \nint bfs(){  \n  priority_queue< Piiii, vector< Piiii >, greater< Piiii > > que; // Pii( (買った商品, 今の時間), 座標)  \n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};  \n     \n  memset( min_cost, -1, sizeof(min_cost));  \n  que.push( Piiii( Piii( Pi( 0, 0), p), 0));  \n  min_cost[p.second][p.first][0] = 0;  \n     \n  int ret = 0;  \n     \n  while(!que.empty()){  \n     \n    Piiii p = que.top(); que.pop();  \n     \n    Pi point = p.first.second;  \n    int bit = p.first.first.second, time = p.first.first.first;\n    int cost = p.second;\n\n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n      if(!isdigit(mas[ny][nx])) continue;\n      int pos = change[mas[ny][nx] - '0'];\n      if(pos == -1) continue;\n      if(shop[pos].s <= time && time < shop[pos].e && !((bit >> i) & 1)){\n        bit |= (1 << i);\n        cost += shop[pos].d;\n      }\n    }\n    if(cost < min_cost[point.second][point.first][bit]){\n      continue;\n    }\n    min_cost[point.second][point.first][bit] = max( cost, min_cost[point.second][point.first][bit]);\n\n    \n    if(ret < min_cost[point.second][point.first][bit]){  \n      ret = min_cost[point.second][point.first][bit];  \n    }  \n     \n    for(int i = 0; i < 4; i++){  \n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;  \n     \n      if(isdigit(mas[ny][nx])){  \n        int time_sell = change[mas[ny][nx] - '0'];\n        if(time_sell == -1) continue;\n        if(!((bit >> time_sell) & 1)){\n          sell se = shop[time_sell];\n          if(se.s > time){\n            que.push( Piiii( Piii( Pi( se.s, bit), point), cost));\n          }\n        }    \n      } else {  \n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){ \n          que.push( Piiii( Piii( Pi( time + 1, bit), Pi( nx, ny)), cost));  \n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];  \n        }  \n      }  \n    }  \n  }  \n  return ret;  \n}  \n     \nint main(){  \n  while(cin >> w >> h, w){  \n    for(int i = 0; i < h; i++){  \n      for(int j = 0; j < w; j++){  \n        cin >> mas[i][j];  \n        if(mas[i][j] == 'P') p = Pi( j, i);  \n      }  \n    }  \n    cin >> n;  \n    memset( change, -1, sizeof(change));\n    for(int i= 0; i < n; i++){  \n      int g;  \n      cin >> g;  \n      cin  >> shop[i].d >> shop[i].s >> shop[i].e;\n      change[i] = g;\n    }\n     \n    cout << bfs() << endl;  \n  }  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int S,y,x;\n  int t;\n  P(int S, int y, int x, int t) : S(S),y(y),x(x),t(t) {}\n  P() {}\n};\n\nstruct Sale {\n  int d,s,e;\n  Sale(int d, int s, int e) : d(d),s(s),e(e) {}\n  Sale() {}\n};\n\nbool visited[1<<8][20][20][101];           // dp[S][i][j][k] = 商品Sを買って(i,j)に時間kにいることができる\nchar ba[20][20];\nSale sale[10];\nint can[20][20][101];                // 購入可能な商品集合\nint get[1<<8];\n\nint main() {\n  int w,h;\n  while(cin>>w>>h,w||h) {\n    int sy,sx;\n\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ba[i][j];\n        if(ba[i][j] == 'P') {\n          ba[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    int n;cin >> n;\n    int id[n],rid[n];\n    REP(i,n) {\n      int d,s,e;\n      cin>>id[i]>>d>>s>>e;\n      sale[i] = Sale(d,s,e);\n      rid[id[i]] = i;\n    }\n    REP(S,1<<n) {\n      get[S] = 0;\n      REP(i,n) {\n        if (S>>i&1) {\n          get[S] += sale[i].d;\n        }\n      }\n    }\n    \n    const int dy[] = {-1,0,1,0,0};\n    const int dx[] = {0,1,0,-1,0};\n    \n    REP(i,h){\n      REP(j,w) {\n        if (ba[i][j] != '.') continue;\n        REP(l,101) {\n          can[i][j][l] = 0;\n          REP(k,4) {\n            int yy=i+dy[k];\n            int xx=j+dx[k];\n            if (yy<0||yy>=h||xx<0||xx>=w) continue;\n            if (isdigit(ba[yy][xx])) {\n              int a = ba[yy][xx]-'0';\n              if (sale[rid[a]].s <= l && l < sale[rid[a]].e) {\n                can[i][j][l] |= 1<<rid[a];\n              }\n            }\n          }\n          // if (l<10) {\n          //   cout << i << \",\" << j << \" \" << l << \" \" << bitset<5>(can[i][j][l]) << endl;\n          // }\n        }\n      }\n    }\n    \n    REP(S,1<<n) REP(i,h)REP(j,w)REP(k,101)\n      visited[S][i][j][k] = 0;\n    queue<P> Q;\n    Q.push(P(can[sy][sx][0],sy,sx,0));\n    visited[can[sy][sx][0]][sy][sx][0] = 1;\n    int ans = 0;\n    while(!Q.empty()) {\n      P p = Q.front(); Q.pop();\n\n      ans = max(ans, get[p.S]);\n      // if (p.t<=10) \n      //   cout << p.y << \",\" << p.x << \" \" << bitset<5>(p.S) << \" \" << p.t << endl;\n      if (p.t == 100) continue;\n      REP(i,5) {\n        int yy=p.y+dy[i];\n        int xx=p.x+dx[i];\n        if (yy<0||yy>=h||xx<0||xx>=w) continue;\n        if (ba[yy][xx] != '.') continue;\n        int nS = p.S|can[yy][xx][p.t+1];\n        if (!visited[nS][yy][xx][p.t+1]) {\n          visited[nS][yy][xx][p.t+1] = 1;\n          Q.push(P(nS,yy,xx,p.t+1));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V,ADJ_V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10],dist[20][20][20][20];\nint dp[256][101][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[number[buf[0]-'0']].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e,TIME_MAX = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tTIME_MAX = max(TIME_MAX,e);\n\t}\n\n\tfor(int i = 0; i < item_num; i++){\n\n\t\tfor(int k = 0; k < info[i].V.size(); k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\n\t\t\t\tint adj_row = info[i].V[k].row + diff_row[p];\n\t\t\t\tint adj_col = info[i].V[k].col + diff_col[p];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\n\t\t\t\tinfo[i].ADJ_V.push_back(Cell(adj_row,adj_col));\n\t\t\t}\n\t\t}\n\n\t\tif(info[i].ADJ_V.size() == 0)continue;\n\n\t\tsort(info[i].ADJ_V.begin(),info[i].ADJ_V.end());\n\n\t\tvector<Cell> tmp_adj;\n\n\t\tint pre_row = info[i].ADJ_V[0].row;\n\t\tint pre_col = info[i].ADJ_V[0].col;\n\n\t\ttmp_adj.push_back(info[i].ADJ_V[0]);\n\n\t\tfor(int a = 1; a < info[i].ADJ_V.size(); a++){\n\t\t\tif(pre_row != info[i].ADJ_V[a].row || pre_col != info[i].ADJ_V[a].col){\n\t\t\t\ttmp_adj.push_back(info[i].ADJ_V[a]);\n\t\t\t}\n\t\t\tpre_row = info[i].ADJ_V[a].row;\n\t\t\tpre_col = info[i].ADJ_V[a].col;\n\t\t}\n\n\t\tinfo[i].ADJ_V.clear();\n\n\t\tfor(int a = 0; a < tmp_adj.size(); a++){\n\t\t\tinfo[i].ADJ_V.push_back(tmp_adj[a]);\n\t\t}\n\n\t\t//info[i].ADJ_V.erase(unique(info[i].ADJ_V.begin(),info[i].ADJ_V.end()),info[i].ADJ_V.end());\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int time = 0; time <= TIME_MAX; time++){\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tdp[state][time][row][col] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tQ.push(SALE(0,0,start_row,start_col,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_discount < dp[Q.top().state][Q.top().time][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < item_num; loop++){\n\t\t\t\tif(Q.top().state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tint next_item = loop;\n\t\t\t\t\tint next_state = Q.top().state + POW[next_item];\n\t\t\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\t\t\tfor(int k = 0; k < info[next_item].ADJ_V.size(); k++){\n\n\t\t\t\t\t\tadj_row = info[next_item].ADJ_V[k].row;\n\t\t\t\t\t\tadj_col = info[next_item].ADJ_V[k].col;\n\n\t\t\t\t\t\tnext_time = Q.top().time + dist[Q.top().row][Q.top().col][adj_row][adj_col];\n\t\t\t\t\t\tif(next_time > TIME_MAX)continue;\n\n\t\t\t\t\t\tif(next_time > info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][Q.top().time][Q.top().row][Q.top().col] < Q.top().sum_discount){\n\n\t\t\t\t\t\t\t\tdp[next_state][Q.top().time][Q.top().row][Q.top().col] = Q.top().sum_discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,Q.top().time,Q.top().row,Q.top().col,Q.top().sum_discount));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][next_time][adj_row][adj_col] < Q.top().sum_discount+info[next_item].discount){\n\n\t\t\t\t\t\t\t\tdp[next_state][next_time][adj_row][adj_col] = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,next_time,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(next_time < info[next_item].start){\n\n\t\t\t\t\t\t\tif(dp[next_state][info[next_item].start][adj_row][adj_col] < Q.top().sum_discount+info[next_item].discount){\n\t\t\t\t\t\t\t\tdp[next_state][info[next_item].start][adj_row][adj_col] = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,info[next_item].start,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int time = 0; time <= TIME_MAX; time++){\n\t\tfor(int row = 0; row < H;row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tans = max(ans,dp[limit-1][time][row][col]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint w, h;\nchar m[20][20];\nint n, g[10], d[10], s[10], e[10];\nint dp[2][20][20][1 << 10];\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint y, x;\n\t\trep(i, h) rep(j, w){\n\t\t\tcin >> m[i][j];\n\t\t\tif(m[i][j] == 'P') y = i, x = j;\n\t\t}\n\t\tcin >> n;\n\t\trep(i, n) cin >> g[i] >> d[i] >> s[i] >> e[i];\n\t\t\n\t\tmemset(dp[0], -1, sizeof(dp[0]));\n\t\tdp[0][y][x][0] = 0;\n\t\t\n\t\tint ans = 0;\n\t\tint cur = 0, next = 1;\n\t\trep(t, 100){\n\t\t\tmemset(dp[next], -1, sizeof(dp[next]));\n\t\t\t\n\t\t\trep(y, h) rep(x, w) rep(k, 1 << 10) if(dp[cur][y][x][k] >= 0){\n\t\t\t\tvector<pi> item;\n\t\t\t\t\n\t\t\t\trep(dir, 4){\n\t\t\t\t\tint ny = y + dy[dir], nx = x + dx[dir];\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\t\tif(!isdigit(m[ny][nx])) continue;\n\t\t\t\t\t\n\t\t\t\t\tint mx = 0;\n\t\t\t\t\trep(l, n) if(g[l] == m[ny][nx] - '0' && s[l] <= t && t < e[l])\n\t\t\t\t\t\tmx = max(mx, d[l]);\n\t\t\t\t\tif(mx) item.pb(mp(m[ny][nx] - '0', mx));\n\t\t\t\t}\n\t\t\t\trep(b, 1 << item.size()){\n\t\t\t\t\tint ncost = dp[cur][y][x][k];\n\t\t\t\t\tint nk = k;\n\t\t\t\t\t\n\t\t\t\t\trep(l, item.size()) if(b & 1 << l){\n\t\t\t\t\t\tif(nk & 1 << item[l].first) goto FAIL;\n\t\t\t\t\t\tncost += item[l].second;\n\t\t\t\t\t\tnk |= 1 << item[l].first;\n\t\t\t\t\t}\n\t\t\t\t\trep(d, 4){\n\t\t\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\t\t\tif(isdigit(m[ny][nx])) continue;\n\t\t\t\t\t\tif(dp[next][ny][nx][nk] < 0 || dp[next][ny][nx][nk] > ncost){\n\t\t\t\t\t\t\tdp[next][ny][nx][nk] = ncost;\n\t\t\t\t\t\t\tans = max(ans, ncost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFAIL:;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int d,get,y,x;\n    bool operator<(const State& right) const{\n        return d > right.d;\n    }\n};\nconst int dx[] = {0,0,1,-1,0};\nconst int dy[] = {1,-1,0,0,0};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        int d[(1<<10)][20][20];\n        for(int i=0;i<(1<<10);i++)for(int j=0;j<20;j++)for(int k=0;k<20;k++) d[i][j][k] = INF;\n        d[0][sy][sx] = 0;\n        priority_queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.top(); que.pop();\n            //printf(\"p.d=%d p.get=%d p.y=%d p.x=%d\\n\",p.d,p.get,p.y,p.x);\n            if(d[p.get][p.y][p.x]<p.d) continue;\n            ans = max(ans, de_sum[p.get]);\n            if(p.d>=100)continue;\n            for(int i=0;i<5;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                int nget = p.get, nd = p.d + 1;\n                for(int j=0;j<4;j++){\n                    int ny2 = ny + dy[j], nx2 = nx + dx[j];\n                    if(ny2<0||h<=ny2||nx2<0||w<=nx2)continue;\n                    if('0'<=field[ny2][nx2]&&field[ny2][nx2]<='9'){\n                        int g_i = field[ny2][nx2] - '0';\n                        if(st_i[g_i] <= nd && nd < et_i[g_i]){\n                            nget |= (1<<g_i);\n                        }\n                    }\n                }\n                if(d[nget][ny][nx]>nd){\n                    d[nget][ny][nx] = nd;\n                    que.push((State){nd, nget, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cctype>\nusing namespace std;\ntypedef pair< int , int > Pt;\ntypedef pair< pair<int , Pt > , Pt > P; // Pt(cost,bit) , Pt(y,x)\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nconst int dx[] = { 0, 1, -1, 0}, dy[] = { 1, 0, 0, -1};\nstruct edge{\n  int prime,st,ed;\n  edge(){};\n  edge(int prime,int st,int ed):prime(prime),st(st),ed(ed){};\n};\nedge info[11];\nint x, y;\nchar mas[21][21];\nbool no_over(int ny,int nx){\n  return ny >= 0 && ny < y && nx >= 0 && nx < x;\n}\nint Dijkstra(Pt& start){\n  int ret = 0;\n  bool used[21][21][1<<11];\n  fill_n(used[0][0],20*20*(1<<11),false);\n  priority_queue< P , vector<P> , greater<P> > que;\n  que.push(P(make_pair(0,Pt((1<<10)-1,0)),start));\n  used[start.fr][start.sc][(1<<10)-1] = true;\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    //if(used[p.sc.fr][p.sc.sc][p.fr.sc.fr]++) continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n      if(!no_over(ny,nx)) continue;\n      if(isdigit(mas[ny][nx])){\n        edge e = info[mas[ny][nx]-'0'];\n        int no = mas[ny][nx] - '0';\n        ny = p.sc.fr, nx = p.sc.sc;\n        if( !(p.fr.sc.fr & (1 << no)) || p.fr.fr > e.ed) continue;\n        if(p.fr.fr >= e.st){\n          ret = max(ret,p.fr.sc.sc + e.prime);\n          if(used[ny][nx][p.fr.sc.fr&~(1<<no)]++) continue;\n          que.push(P(make_pair(p.fr.fr,Pt(p.fr.sc.fr&~(1<<no),p.fr.sc.sc+e.prime)),Pt(ny,nx)));\n        }else que.push(P(make_pair(e.st,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }else{\n        if(used[ny][nx][p.fr.sc.fr]++) continue;\n        que.push(P(make_pair(p.fr.fr+1,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> x >> y , x){\n    Pt st;\n    for(int i = 0 ; i < y ; i++ ){\n      for(int j = 0 ; j < x ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') st = Pt(i,j);\n      }\n    }\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; i++ ){\n      int g,d,s,e;\n      cin >> g >> d >> s >> e;\n      info[g] = edge(d,s,e);\n    }\n    cout << Dijkstra(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[next][state | s][ny][nx] =\n                  max(dp[next][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  fill(vis[0][0], vis[20][0], false);\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          v.y = u.y;\n          v.x = u.x;\n          v.used = u.used | (1<<num);\n          v.t = max(u.t, data[num].s);\n          v.sum = u.sum + data[num].d;\n          res = max(res, v.sum);\n          if(!vis[v.y][v.x][v.used]){\n            vis[v.y][v.x][v.used] = true;\n            q.push(v);\n          }\n        }\n      }else{\n        if(!vis[ny][nx][u.used]){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef pair<pr,pr> ppr;\nbool DP[2][257][22][22];\n\nint main() {\n\t// your code goes here\n\tint x,y,n;\n\tchar data;\n\twhile(cin >> x>>y && x!=0){\n\t\tint price[10]={};\n\t\tint start[10]={};\n\t\tint end[10]={};\n\t\tint maxim=0;\n\t\tint num,sx,sy,dx[]={0,0,1,-1,0},dy[]={1,-1,0,0,0};\n\t\tint maps[22][22]={};\n\t\tfor(int i=0;i<22;i++)\n\t\t\tfor(int j=0;j<22;j++)\n\t\t\t\tmaps[i][j]=-1;\n\t\tfor(int i=1;i<=y;i++)\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tcin >> data;\n\t\t\t\tif(data=='.')\n\t\t\t\tmaps[i][j]=-1;\n\t\t\t\telse if(data=='P'){\n\t\t\t\tmaps[i][j]=-1;\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tmaps[i][j]=data-'0';\n\t\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> num;\n\t\t\tcin >> price[num] >> start[num] >> end[num];\n\t\t}\n\t\tqueue<ppr>  qu;\n\t\tqu.push(ppr(pr(sx,sy),pr(0,0)));\n\t\twhile(!qu.empty()){\n\t\t\tint px=qu.front().first.first,py=qu.front().first.second,t=qu.front().second.second,p=qu.front().second.first;\n\t\t\tqu.pop();\n\t\t\tDP[t%2][p][px][py]=false;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=px+dx[i],ny=py+dy[i];\n\t\t\t\tif(maps[ny][nx]!=-1 && start[maps[ny][nx]]<=t && end[maps[ny][nx]]>t)\n\t\t\t\tp|=(int)pow(2,maps[ny][nx]);\n\t\t\t}\n\t\t\t\n\t\t\tif(t<100)\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tint nx=px+dx[i],ny=py+dy[i];\n\t\t\t\tif(nx>=1 && nx<=x && ny>=1 && ny<=y &&maps[ny][nx]==-1 && !DP[(t+1)%2][p][nx][ny]){\n\t\t\t\tqu.push(ppr(pr(nx,ny),pr(p,t+1)));\n\t\t\t\tDP[(t+1)%2][p][nx][ny]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t==100){\n\t\t\t\tint c=0;\n\t\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\t\tif(p&(int)pow(2,i))\n\t\t\t\t\tc+=price[i];\n\t\t\t\tmaxim=max(maxim,c);\n\t\t\t}\n\t\t}\n\t\tcout << maxim << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 5; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\ntypedef pair<int,pii> ppi;\nint used[1<<8][21][21];\nchar field[101][101];\nint T;\nint gs[101];\nint ds[101];\nint ss[101];\nint es[101];\nint ggs[101];\n\nvoid solve(){\n\tint W,H;\n\tint sy,sx;\n\twhile(cin>>W>>H&&(W|H)){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='P'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tcin>>gs[i];\n\t\t\tggs[gs[i]]=i;\n\t\t\tcin>>ds[i]>>ss[i]>>es[i];\n\t\t}\n\t\tqueue<ppi> q;\n\t\tint smask=0;\n\t\tint scost=0;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint ny=sy+dy[j];\n\t\t\tint nx=sx+dx[j];\n\t\t\tif(ny>=0&&nx>=0&&nx<W&&ny<H&&field[ny][nx]!='.'){\n\t\t\t\tint id=ggs[field[ny][nx]-'0'];\n\t\t\t\tif(ss[id]<=0&&es[id]>0){\n\t\t\t\t\tsmask|=(1<<id);\n\t\t\t\t\tscost+=ds[id];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push(make_pair(smask,pii(sy,sx)));\n\t\tmemset(used,-1,sizeof(used));\n\t\tused[smask][sy][sx]=0;\n\t\twhile(q.size()){\n\t\t\tppi p=q.front();q.pop();\n\t\t\tint cmask=p.first;\n\t\t\tint cy=p.second.first;\n\t\t\tint cx=p.second.second;\n\t\t\tint ctime=used[cmask][cy][cx];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=cy+dy[i];\n\t\t\t\tint nx=cx+dx[i];\n\t\t\t\tint nmask=cmask;\n\t\t\t\tint ntime=ctime+1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='.'){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tint nny=ny+dy[j];\n\t\t\t\t\t\tint nnx=nx+dx[j];\n\t\t\t\t\t\tif(nny>=0&&nnx>=0&&nny<H&&nnx<W&&field[nny][nnx]!='.'){\n\t\t\t\t\t\t\tint id=ggs[field[nny][nnx]-'0'];\n\t\t\t\t\t\t\tif(ss[id]<=ntime&&es[id]>ntime&&!((nmask>>id)&1)){\n\t\t\t\t\t\t\t\tnmask|=(1<<id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(used[nmask][ny][nx]==-1){\n\t\t\t\t\t\tused[nmask][ny][nx]=ntime;\n\t\t\t\t\t\tq.push(make_pair(nmask,pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int mask=0;mask<(1<<T);mask++){\n\t\t\t\t\tif(used[mask][i][j]==-1)continue;\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tfor(int k=0;k<T;k++){\n\t\t\t\t\t\tif((mask>>k)&1){\n\t\t\t\t\t\t\tsum+=ds[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres=max(res,sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            if(p.t>100)continue;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nclass Item{\npublic:\n\tint n,c,s,g;\n\tItem(int n=0,int c=0,int s=0,int g=0):n(n),c(c),s(s),g(g){}\n};\n\nclass State{\npublic:\n\tint x,y,cost,sum,visited;\n\tState(int x=0,int y=0,int c=0,int s=0,int v=0):x(x),y(y),cost(c),sum(s),visited(v){}\n};\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h && h && w){\n\t\tint a[20][20], n, ans = 0;\n        bool G[20][20];\n        int n_i[10]; //商品番号を配列の番号に変換\n\t\tbool f[20][20][(1<<8)];\n\t\tItem item[8];\n\t\tqueue<State> Q;\n\t\tState u,v;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<(1<<8);k++) f[i][j][k] = false;\n\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tG[i][j] = true;\n\t\t\t\ta[i][j] = -1;\n\t\t\t\tif(c == '.') G[i][j] = false;\n\t\t\t\telse if(c == 'P'){\n\t\t\t\t\tu.y = i;\n\t\t\t\t\tu.x = j;\n\t\t\t\t\tf[i][j][0] = true;\n\t\t\t\t\tG[i][j] = false;\n\t\t\t\t} else a[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> item[i].n >> item[i].c >> item[i].s >> item[i].g;\n            n_i[item[i].n] = i;\n\t\t}\n\n\t\tQ.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n            \n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tv = u;\n\t\t\t\tv.y += dy[i];\n\t\t\t\tv.x += dx[i];\n\t\t\t\tv.cost++;\n\t\t\t\tif(v.y >= 0 && v.y < h && v.x >= 0 && v.x < w && !f[v.y][v.x][v.visited]){\n                    if(!G[v.y][v.x]){\n                        f[v.y][v.x][v.visited] = true;\n                        Q.push(v);\n                    }\n                    else if((v.visited & (1<<n_i[a[v.y][v.x]])) == 0){\n                        if(u.cost >= item[n_i[a[v.y][v.x]]].s && u.cost < item[n_i[a[v.y][v.x]]].g){\n                            State v2 = u;\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.visited = v2.visited | (1<<n_i[a[v.y][v.x]]);\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.sum += item[n_i[a[v.y][v.x]]].c;\n                            ans = max(ans,v2.sum);\n                            if(v2.visited != ((1<<n)-1)) Q.push(v2);\n                        } else if(u.cost < item[n_i[a[v.y][v.x]]].s){\n                            //変更点\n                            State v2 = u;\n                            v2.cost += item[n_i[a[v.y][v.x]]].s - v2.cost;\n                            Q.push(v2);\n                            //ここまで\n                        }\n                    }\n                }\n            }\n            \n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint W, H;\nchar map[20][20];\nint can_buy[20][20];\nint N;\nint G[8], D[8], S[8], E[8];\nint dp[1<<8][20][20][101];\n\nbool didGoSame(int state, int v){\n    REP(i, N){\n        if(state >> i & 1 && G[i] == G[v]){return true;}\n    }\n    return false;\n}\n\nint rec(int state, int x, int y, int t){\n    // printf(\"%d, %d, %d\\n\", x, y, t);\n    if(t > 100){return 0;}\n    if(dp[state][x][y][t] != -1){return dp[state][x][y][t];}\n\n    int res = 0;\n    REP(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n            res = std::max(res, rec(state, nx, ny, t+1));\n            if(can_buy[y][x] != -1){\n                REP(j, N){\n                    // printf(\"%d, %d: %d\\n\", x, y, t);\n                    if(!(state >> j & 1) && !didGoSame(state, j) && G[j] == can_buy[y][x] && S[j] <= t && t < E[j]){\n                        res = std::max(res, D[j] + rec(state | 1 << j, nx, ny, t+1));\n                    }\n                }\n            }\n        }\n    }\n\n    return dp[state][x][y][t] = res;\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        REP(i, 20){\n            REP(j, 20){\n                can_buy[i][j] = -1;\n            }\n        }\n\n        REP(i, 1<<8){\n            REP(j, 20){\n                REP(k, 20){\n                    REP(l, 101){\n                        dp[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n\n        int sx, sy;\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n                if(map[i][j] == 'P'){\n                    map[i][j] = '.';\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        REP(y, H){\n            REP(x, W){\n                REP(k, 4){\n                    if(map[y][x] == '.'){continue;}\n                    int nx = x + dx[k], ny = y + dy[k];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n                        can_buy[ny][nx] = map[y][x] - '0';\n                    }\n                }\n            }\n        }\n\n        std::cin >> N;\n\n        REP(i, N){\n            std::cin >> G[i] >> D[i] >> S[i] >> E[i];\n        }\n\n        std::cout << rec(0, sx, sy, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\t//return sum_discount < arg.sum_discount;\n\t\t\treturn sum_discount > arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] < '9'){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_T 150\n\nstruct Data{\n    int n,c,s,t;\n    Data(){}\n    Data(int n,int c,int s,int t) :\n        n(n),c(c),s(s),t(t) {}\n\n    bool operator < (const Data &d)const{\n        return n < d.n;\n    }\n};\n\nint H,W,LIMIT;\nint memo[MAX_H][MAX_W][MAX_T][1<<8];\nvector<Data> v;\nchar field[MAX_H][MAX_W];\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nbool check(int nt,int idx){\n    return (v[idx].s <= nt && nt < v[idx].t);\n}\n\nint solve(int x,int y,int t,int p){\n    if(t == LIMIT) return 0;\n    int &res = memo[x][y][t][p];\n    if(res != -1) return res;\n    int S = p,cost = 0;\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == '.') continue;\n        int x = field[ny][nx]-'0';\n        if(S >> x & 1) continue;\n        if(check(t,x)){\n            S |= (1<<x);\n            cost += v[x].c;\n        }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] != '.') continue;\n        res = max(res,solve(nx,ny,t+1,S)+cost);\n    }\n    return res;\n}\n\nint main(){\n    int sx,sy,N;\n    while(cin >> W >> H, W){\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                cin >> field[i][j];\n                if(field[i][j] == 'P'){\n                    sx = j; sy = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n        LIMIT = 0;\n        cin >> N;\n        v.clear(); v.resize(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].n >> v[i].c >> v[i].s >> v[i].t;\n            LIMIT = max(LIMIT,v[i].t);\n        }\n        LIMIT++;\n        memset(memo,-1,sizeof(memo));\n        cout << solve(sx,sy,0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.front().sum_discount);\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.front().row + diff_row[i];\n\t\t\tint adj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\tif(base_map[adj_row][adj_col] == '.'){\n\n\t\t\t\tif(dp[Q.front().state][adj_row][adj_col] < Q.front().sum_discount){\n\t\t\t\t\tdp[Q.front().state][adj_row][adj_col] = Q.front().sum_discount;\n\n\t\t\t\t\tSALE next_sale;\n\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\tnext_sale.time = Q.front().time+1;\n\n\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t}\n\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\tif(Q.front().state & (1 << adj_item))continue;\n\t\t\t\tif(is_sale[adj_item] == false)continue;\n\n\t\t\t\tint next_state = Q.front().state + POW[adj_item];\n\n\t\t\t\tif(Q.front().time >= info[adj_item].start && Q.front().time < info[adj_item].end){\n\n\t\t\t\t\tif(dp[next_state][Q.front().row][Q.front().col] < Q.front().sum_discount+info[adj_item].discount){\n\n\t\t\t\t\t\tdp[next_state][Q.front().row][Q.front().col] = Q.front().sum_discount+info[adj_item].discount;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\tnext_sale.time = Q.front().time;\n\n\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t}\n\n\t\t\t\t}else if(Q.front().time < info[adj_item].start){\n\n\t\t\t\t\tSALE next_sale;\n\t\t\t\t\tnext_sale.row = Q.front().row;\n\t\t\t\t\tnext_sale.col = Q.front().col;\n\t\t\t\t\tnext_sale.state = Q.front().state;\n\t\t\t\t\tnext_sale.sum_discount = Q.front().sum_discount;\n\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\n\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define NMAX 20\n#define TMAX 100\nstatic const int dy[5] = {0, 0, -1, 0, 1};\nstatic const int dx[5] = {0, 1, 0, -1, 0};\nclass State{\npublic:\n  int y, x, t, s;\n  State(){}\n  State(int y, int x, int t, int s):y(y), x(x), t(t), s(s){}\n};\n\nstruct Item{ int disc, ts, te; };\n\nint W, H, sy, sx, n;\n\nbool T[NMAX][NMAX][TMAX+1][(1<<8)];\nchar G[NMAX][NMAX];\nItem I[10];\n\nbool valid(int ny, int nx){\n  if ( ny < 0 || nx < 0 || ny >= H || nx >= W ) return false;\n  return G[ny][nx] == '.';\n}\n\nint getAVPoint( int y, int x, int t ){\n  int u = 0;\n\n  for ( int r = 1; r < 5; r++ ){\n    int ny = y + dy[r];\n    int nx = x + dx[r];\n    if (ny < 0 || nx < 0 || ny >= H || nx >= W )  continue;\n    if ( G[ny][nx] == '.' ) continue;\n    int inum = G[ny][nx] - '0';\n    //if ( I[inum].ts  <= t && t <= I[inum].te ){\n    if ( I[inum].ts  <= t && t < I[inum].te ){\n      u = (u | (1<<inum));\n    }\n  }\n\n  return u;\n}\n\nint getPoint(int s){\n  int sum = 0;\n\n  for ( int i = 0; i < n; i++ ){\n    if ( (s & (1<<i)) > 0 ){\n      sum += I[i].disc;\n    }\n  }\n\n  return sum;\n}\n\nvoid compute(){\n  rep(i, H) rep(j, W) rep(k, TMAX+1) rep(l, (1<<n)){\n    T[i][j][k][l] = false;\n  }\n\n  T[sy][sx][0][getAVPoint(sy, sx, 0)] = true;\n\n  queue<State> Q;\n  Q.push(State(sy, sx, 0, getAVPoint(sy, sx, 0)));\n\n  State u, v;\n\n  int ans = 0;\n  while(!Q.empty() ){\n    u = Q.front(); Q.pop();\n    ans = max(ans, getPoint(u.s));\n    for ( int r = 0;  r < 5; r++ ){\n      int ny = u.y + dy[r];\n      int nx = u.x + dx[r];\n      if ( !valid(ny, nx) ) continue;\n      v = u;\n      v.y = ny;\n      v.x = nx;\n      v.t++;\n      if ( v.t > 100 ) continue;\n      v.s = (v.s | getAVPoint(v.y, v.x, v.t));\n      if ( !T[v.y][v.x][v.t][v.s] ){\n\tT[v.y][v.x][v.t][v.s] = true;\n\tQ.push(v);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nmain(){\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if ( G[i][j] == 'P' ){\n\tG[i][j] = '.';\n\tsy = i; sx = j;\n      }\n    }\n    cin >> n;\n    rep(i, n) {\n      int g; cin >> g;\n      cin >> I[g].disc >> I[g].ts >> I[g].te;\n    }\n    compute();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct comd { int sn,d,s,e; };\nint main() {\n  int x,y,i,j,k,g,n,t,a,b,e,h,dx[4]={1,0,-1,0},dy[4]={0,-1,0,1},d[2][20][20][256],m[20][20],f[20][20];\n  char c;\n  comd co[10];\n  while(cin >> x >> y && x>0) {\n\t  for (h=0;h<2;h++) for (j=0;j<20;j++) for (k=0;k<20;k++) for (g=0;g<256;g++) d[h][j][k][g]=-1;\n\t  for (i=0;i<y;i++) {\n\t\t  for (j=0;j<x;j++) {\n\t\t\t  cin >> c;  \n\t\t\t  f[i][j]=0;\n\t\t\t  if (c>='0' && c<='9') m[i][j]=c-'0'; else m[i][j]=-1;\n\t\t\t  if (c=='P') { f[i][j]=1; d[0][i][j][0]=0;}\n\t\t  }\n\t  }\n\t  cin >> n;\n\t  for (i=0; i<n; i++) {  cin >> g;  cin >> co[g].d >> co[g].s >> co[g].e; co[g].sn=(1 << i);}\n\t  for (t=0,h=0;t<100;t++) {\n\t\t  for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\t\t  if (f[i][j]==0) continue;\n\t\t      for (k=0;k<256;k++) {\n\t\t\t\tif (d[h][i][j][k]==-1) continue;\n\t\t\t\ta=k; b=d[h][i][j][k];\n\t\t\t\tfor (g=0;g<4;g++) {\n\t\t\t\t\tif (j+dx[g]<0 || j+dx[g]>=x || i+dy[g]<0 || i+dy[g]>=y) continue;\n\t\t\t\t\te=m[i+dy[g]][j+dx[g]];\n\t\t\t\t\tif (e>=0) if ((co[e].sn & a)==0 && co[e].s<=t && co[e].e>t) {b+=co[e].d; a=a | co[e].sn;}\n\t\t\t\t}\n\t\t\t\td[h][i][j][a]=b;\n\t\t\t\tfor (g=0;g<4;g++) if (j+dx[g]>=0 && j+dx[g]<x && i+dy[g]>=0 && i+dy[g]<y) if (m[i+dy[g]][j+dx[g]]<0) { d[h][i+dy[g]][j+dx[g]][a]=b;  f[i+dy[g]][j+dx[g]]=1;} \n\t\t\t\t}\n\t\t\t}\n\t\t\th=1-h;\n\t\t}\n\t\ta=-1;\n\t\tfor (i=0;i<y;i++) for (j=0;j<x;j++) for (k=0;k<256;k++) if (a<d[0][i][j][k]) a=d[0][i][j][k];\n\t\tcout << a << endl;\n\t  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nclass Item{\npublic:\n\tint n,c,s,g;\n\tItem(int n=0,int c=0,int s=0,int g=0):n(n),c(c),s(s),g(g){}\n};\n\nclass State{\npublic:\n\tint x,y,cost,sum,visited;\n\tState(int x=0,int y=0,int c=0,int s=0,int v=0):x(x),y(y),cost(c),sum(s),visited(v){}\n};\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h && h && w){\n\t\tint G[20][20], a[20][20], n, ans = 0;\n        int n_i[10]; //商品番号を配列の番号に変換\n\t\tbool f[20][20][(1<<8)];\n\t\tItem item[8];\n\t\tqueue<State> Q;\n\t\tState u,v;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<(1<<8);k++) f[i][j][k] = false;\n\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tG[i][j] = true;\n\t\t\t\ta[i][j] = -1;\n\t\t\t\tif(c == '.') G[i][j] = false;\n\t\t\t\telse if(c == 'P'){\n\t\t\t\t\tu.y = i;\n\t\t\t\t\tu.x = j;\n\t\t\t\t\tf[i][j][0] = true;\n\t\t\t\t\tG[i][j] = false;\n\t\t\t\t} else a[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> item[i].n >> item[i].c >> item[i].s >> item[i].g;\n            n_i[item[i].n] = i;\n\t\t}\n\n\t\tQ.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n            \n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tv = u;\n\t\t\t\tv.y += dy[i];\n\t\t\t\tv.x += dx[i];\n\t\t\t\tv.cost++;\n\t\t\t\tif(v.y >= 0 && v.y < h && v.x >= 0 && v.x < w && !f[v.y][v.x][v.visited]){\n                    if(!G[v.y][v.x]){\n                        f[v.y][v.x][v.visited] = true;\n                        Q.push(v);\n                    }\n                    else if((v.visited & (1<<a[v.y][v.x])) == 0){\n                        if(u.cost >= item[n_i[a[v.y][v.x]]].s && u.cost < item[n_i[a[v.y][v.x]]].g){\n                            State v2 = u;\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.visited = v2.visited | (1<<a[v.y][v.x]);\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.sum += item[n_i[a[v.y][v.x]]].c;\n                            ans = max(ans,v2.sum);\n                            if(v2.visited != ((1<<n)-1)) Q.push(v2);\n                        } else if(u.cost < item[n_i[a[v.y][v.x]]].s){\n                            //変更点\n                            State v2 = u;\n                            v2.cost += item[n_i[a[v.y][v.x]]].s - v2.cost;\n                            Q.push(v2);\n                            //ここまで\n                        }\n                    }\n                }\n            }\n            \n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tv[temp.bit][temp.ty][temp.tx] = true;\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!((temp.bit >> map[my][mx]) & 1) && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= 1 << map[my][mx];\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  fill(vis[0][0], vis[20][0], false);\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          v.y = u.y;\n          v.x = u.x;\n          v.used = u.used | (1<<num);\n          v.t = max(u.t, data[num].s);\n          v.sum = u.sum + data[num].d;\n          if(!vis[v.y][v.x][v.used]){\n            res = max(res, v.sum);\n            vis[v.y][v.x][v.used] = true;\n            q.push(v);\n          }\n        }\n      }else{\n        if(!vis[ny][nx][u.used]){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[100][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,INF);\n        fill(et_i,et_i+10,-INF);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx) continue;\n                if(field[ny][nx]=='.'||field[ny][nx]=='P'){\n                    if(p.t+1<100&&!visited[p.t+1][p.get][ny][nx]){\n                        que.push((State){p.t+1, p.get, ny, nx});\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            if(p.t>=100)continue;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint W, H;\nint d[400][400];\nstd::vector<P> ps[10];\nint N;\nint G[8], D[8], S[8], E[8];\nint dp[1<<10][20][20][101];\n\nint canGoNext(int state, int x, int y, int t){\n    REP(i, 8){\n        if(state >> G[i] & 1){continue;}\n        for(P &p : ps[G[i]]){\n            int nt = t + d[x+y*W][p.first+p.second*W];\n            if(S[i] <= nt && nt < E[i]){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint rec(int state, int x, int y, int t){\n    // printf(\"%d, %d, %d\\n\", x, y, t);\n    if(dp[state][x][y][t] != -1){return dp[state][x][y][t];}\n    if(!canGoNext(state, x, y, t)){return 0;}\n\n    int res = 0;\n    REP(i, 8){\n        if(state >> G[i] & 1){continue;}\n        for(P &p : ps[G[i]]){\n            int nt = t + d[x+y*W][p.first+p.second*W];\n            // printf(\"%d, (%d, %d)\\n\", nt, p.first, p.second);\n            if(S[i] <= nt && nt < E[i]){\n                res = std::max(res, D[i] + rec(state | 1 << G[i], p.first, p.second, nt));\n            }\n        }\n    }\n\n    return dp[state][x][y][t] = std::max(res, rec(state, x, y, t+1));\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        REP(i, 10){\n            ps[i].clear();\n        }\n\n        REP(i, 1<<10){\n            REP(j, 20){\n                REP(k, 20){\n                    REP(l, 101){\n                        dp[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n\n        char map[20][20];\n        int sx, sy;\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n                if(map[i][j] == 'P'){\n                    map[i][j] = '.';\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        REP(i, 400){\n            REP(j, 400){\n                if(i == j){d[i][j] = 0;}\n                else{d[i][j] = INF;}\n            }\n        }\n\n        REP(y, H){\n            REP(x, W){\n                REP(k, 4){\n                    int nx = x + dx[k], ny = y + dy[k];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n                        if(map[y][x] != '.'){\n                            ps[map[y][x]-'0'].push_back(mp(nx, ny));\n                        }else if(map[y][x] == '.'){\n                            d[x+y*W][nx+ny*W] = 1;\n                            d[nx+ny*W][x+y*W] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        REP(k, W*H){\n            REP(i, W*H){\n                REP(j, W*H){\n                    d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        std::cin >> N;\n\n        REP(i, N){\n            std::cin >> G[i] >> D[i] >> S[i] >> E[i];\n        }\n\n        std::cout << rec(0, sx, sy, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n     \nint w, h, n;  \nchar mas[20][20];  \n     \ntypedef pair< int , int > Pi;  \ntypedef pair< Pi , Pi > Piii;\ntypedef pair< Piii, int > Piiii;\nPi p;  \n     \nstruct sell{  \n  int d; //値引き額  \n  int s; //開始時刻  \n  int e; //終了時刻  \n};  \nsell shop[10];  \n     \nint min_cost[20][20][1 << 10];  \n     \nint bfs(){  \n  priority_queue< Piiii, vector< Piiii >, greater< Piiii > > que; // Pii( (買った商品, 今の時間), 座標)  \n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};  \n     \n  memset( min_cost, -1, sizeof(min_cost));  \n  que.push( Piiii( Piii( Pi( 0, 0), p), 0));  \n  min_cost[p.second][p.first][0] = 0;  \n     \n  int ret = 0;  \n     \n  while(!que.empty()){  \n     \n    Piiii p = que.top(); que.pop();  \n     \n    Pi point = p.first.second;  \n    int bit = p.first.first.second, time = p.first.first.first;\n    int cost = p.second;\n\n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n      if(!isdigit(mas[ny][nx])) continue;\n      int pos = mas[ny][nx] - '0';\n      if(isdigit(mas[ny][nx]) && shop[pos].s <= time && time < shop[pos].e && !((bit >> i) & 1)){\n        bit |= (1 << i);\n        cost += shop[pos].d;\n      }\n    }\n    if(cost < min_cost[point.second][point.first][bit]){\n      continue;\n    }\n    min_cost[point.second][point.first][bit] = max( cost, min_cost[point.second][point.first][bit]);\n\n    \n    if(ret < min_cost[point.second][point.first][bit]){  \n      ret = min_cost[point.second][point.first][bit];  \n    }  \n     \n    for(int i = 0; i < 4; i++){  \n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;  \n     \n      if(isdigit(mas[ny][nx])){  \n        int time_sell = mas[ny][nx] - '0';  \n        if(!((bit >> time_sell) & 1)){\n          sell se = shop[time_sell];\n          if(se.s > time){\n            que.push( Piiii( Piii( Pi( se.s, bit), point), cost));\n          }\n        }    \n      } else {  \n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){ \n          que.push( Piiii( Piii( Pi( time + 1, bit), Pi( nx, ny)), cost));  \n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];  \n        }  \n      }  \n    }  \n  }  \n  return ret;  \n}  \n     \nint main(){  \n  while(cin >> w >> h, w){  \n    for(int i = 0; i < h; i++){  \n      for(int j = 0; j < w; j++){  \n        cin >> mas[i][j];  \n        if(mas[i][j] == 'P') p = Pi( j, i);  \n      }  \n    }  \n    cin >> n;  \n     \n    for(int i= 0; i < n; i++){  \n      int g;  \n      cin >> g;  \n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;  \n    }  \n     \n    cout << bfs() << endl;  \n  }  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tv[temp.bit][temp.ty][temp.tx] = true;\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t\telse if (map[my][mx] != -1 && v[temp.bit][my][mx] == false && !((temp.bit >> map[my][mx]) & 1) && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= 1 << map[my][mx];\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> Vi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> Pip; \nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\n  int x, y;\n  while( cin >> x >> y, x+y ) {\n    int shop[y][x];\n    int max_sale[10]={0};\n    int n;\n    int sy, sx;\n    vector<Pip> G[10];\n    for(int i=0; i<y; i++) fill(shop[i], shop[i]+x, -1);\n    for(int i=0; i<y; i++) {\n      for(int j=0; j<x; j++) {\n\tchar c;\n\tcin >> c;\n\tif( c == 'P' ) { sy = i; sx = j; } \n\telse if( c != '.' ) shop[i][j] = c-'0';\n      }\n    }\n\n    cin >> n;\n    int last_time = 0;\n    for(int i=0; i<n; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      last_time = max(last_time, e);\n      G[g].pb(Pip(d, Pii(s, e)));\n    }\n    queue<Pip> q;\n    q.push(Pip(0, Pii(sy, sx)));\n    while( !q.empty() ) {\n      Pip p = q.front(); q.pop();\n      int time = p.fr;\n      int y_ = p.sc.fr, x_ = p.sc.sc;\n      if( last_time < time ) continue;\n      for(int i=0; i<4; i++) {\n\tint ny = y_ + dy[i], nx = x_ + dx[i];\n\tif( 0 <= ny && y > ny && 0 <= nx && x > nx && shop[ny][nx] > 0 ) {\n\t  int num = shop[ny][nx];\n\t  for(int j=0; j<G[num].size(); j++) {\n\t    Pip p = G[num][j];\n\t    int d = p.fr, s = p.sc.fr, e = p.sc.sc;\n\t    if( s < time && time <= e ) {\n\t      max_sale[num] = max(max_sale[num], d);\n\t    }\n\t  }\n\t}\n      }\n\n      for(int i=0; i<4; i++) {\n\tint ny = y_+dy[i], nx = x_ + dx[i];\n\tif( 0 <= ny && y > ny && 0 <= nx && x > nx && shop[ny][nx] == -1 ) {\n\t  q.push(Pip(time+1, Pii(ny, nx)));\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0; i<10; i++) {\n      ans += max_sale[i];\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V,ADJ_V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10],dist[20][20][20][20];\nint dp[256][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[number[buf[0]-'0']].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e,TIME_MAX = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tTIME_MAX = max(TIME_MAX,e);\n\t}\n\n\tfor(int i = 0; i < item_num; i++){\n\n\t\tfor(int k = 0; k < info[i].V.size(); k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\n\t\t\t\tint adj_row = info[i].V[k].row + diff_row[p];\n\t\t\t\tint adj_col = info[i].V[k].col + diff_col[p];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\n\t\t\t\tinfo[i].ADJ_V.push_back(Cell(adj_row,adj_col));\n\t\t\t}\n\t\t}\n\n\t\tif(info[i].ADJ_V.size() == 0)continue;\n\n\t\tsort(info[i].ADJ_V.begin(),info[i].ADJ_V.end());\n\n\t\tvector<Cell> tmp_adj;\n\n\t\tint pre_row = info[i].ADJ_V[0].row;\n\t\tint pre_col = info[i].ADJ_V[0].col;\n\n\t\ttmp_adj.push_back(info[i].ADJ_V[0]);\n\n\t\tfor(int a = 1; a < info[i].ADJ_V.size(); a++){\n\t\t\tif(pre_row != info[i].ADJ_V[a].row || pre_col != info[i].ADJ_V[a].col){\n\t\t\t\ttmp_adj.push_back(info[i].ADJ_V[a]);\n\t\t\t}\n\t\t\tpre_row = info[i].ADJ_V[a].row;\n\t\t\tpre_col = info[i].ADJ_V[a].col;\n\t\t}\n\n\t\tinfo[i].ADJ_V.clear();\n\n\t\tfor(int a = 0; a < tmp_adj.size(); a++){\n\t\t\tinfo[i].ADJ_V.push_back(tmp_adj[a]);\n\t\t}\n\n\t\t//info[i].ADJ_V.erase(unique(info[i].ADJ_V.begin(),info[i].ADJ_V.end()),info[i].ADJ_V.end());\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tQ.push(SALE(0,0,start_row,start_col,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().state == limit-1){\n\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_discount < dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < item_num; loop++){\n\t\t\t\tif(Q.top().state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tint next_item = loop;\n\t\t\t\t\tint next_state = Q.top().state + POW[next_item];\n\t\t\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\t\t\tfor(int k = 0; k < info[next_item].ADJ_V.size(); k++){\n\n\t\t\t\t\t\tadj_row = info[next_item].ADJ_V[k].row;\n\t\t\t\t\t\tadj_col = info[next_item].ADJ_V[k].col;\n\n\t\t\t\t\t\tnext_time = Q.top().time + dist[Q.top().row][Q.top().col][adj_row][adj_col];\n\t\t\t\t\t\tif(next_time > TIME_MAX)continue;\n\n\t\t\t\t\t\tif(next_time > info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] < Q.top().sum_discount){\n\n\t\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().sum_discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,Q.top().time,Q.top().row,Q.top().col,Q.top().sum_discount));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] < Q.top().sum_discount+info[next_item].discount){\n\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,next_time,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(next_time < info[next_item].start){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] < Q.top().sum_discount+info[next_item].discount){\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,info[next_item].start,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int time = 0; time <= TIME_MAX; time++){\n\t\tfor(int row = 0; row < H;row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tans = max(ans,dp[limit-1][row][col]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V,ADJ_V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10],dist[20][20][20][20];\nint dp[256][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[number[buf[0]-'0']].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e,TIME_MAX = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tTIME_MAX = max(TIME_MAX,e);\n\t}\n\n\tfor(int i = 0; i < item_num; i++){\n\n\t\tfor(int k = 0; k < info[i].V.size(); k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\n\t\t\t\tint adj_row = info[i].V[k].row + diff_row[p];\n\t\t\t\tint adj_col = info[i].V[k].col + diff_col[p];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\n\t\t\t\tinfo[i].ADJ_V.push_back(Cell(adj_row,adj_col));\n\t\t\t}\n\t\t}\n\n\t\tif(info[i].ADJ_V.size() == 0)continue;\n\n\t\tsort(info[i].ADJ_V.begin(),info[i].ADJ_V.end());\n\n\t\tvector<Cell> tmp_adj;\n\n\t\tint pre_row = info[i].ADJ_V[0].row;\n\t\tint pre_col = info[i].ADJ_V[0].col;\n\n\t\ttmp_adj.push_back(info[i].ADJ_V[0]);\n\n\t\tfor(int a = 1; a < info[i].ADJ_V.size(); a++){\n\t\t\tif(pre_row != info[i].ADJ_V[a].row || pre_col != info[i].ADJ_V[a].col){\n\t\t\t\ttmp_adj.push_back(info[i].ADJ_V[a]);\n\t\t\t}\n\t\t\tpre_row = info[i].ADJ_V[a].row;\n\t\t\tpre_col = info[i].ADJ_V[a].col;\n\t\t}\n\n\t\tinfo[i].ADJ_V.clear();\n\n\t\tfor(int a = 0; a < tmp_adj.size(); a++){\n\t\t\tinfo[i].ADJ_V.push_back(tmp_adj[a]);\n\t\t}\n\n\t\t//info[i].ADJ_V.erase(unique(info[i].ADJ_V.begin(),info[i].ADJ_V.end()),info[i].ADJ_V.end());\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tQ.push(SALE(0,0,start_row,start_col,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().state == limit-1){\n\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < item_num; loop++){\n\t\t\t\tif(Q.top().state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tint next_item = loop;\n\t\t\t\t\tint next_state = Q.top().state + POW[next_item];\n\t\t\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\t\t\tfor(int k = 0; k < info[next_item].ADJ_V.size(); k++){\n\n\t\t\t\t\t\tadj_row = info[next_item].ADJ_V[k].row;\n\t\t\t\t\t\tadj_col = info[next_item].ADJ_V[k].col;\n\n\t\t\t\t\t\tnext_time = Q.top().time + dist[Q.top().row][Q.top().col][adj_row][adj_col];\n\t\t\t\t\t\tif(next_time > TIME_MAX)continue;\n\n\t\t\t\t\t\tif(next_time > info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] < Q.top().sum_discount){\n\n\t\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().sum_discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,Q.top().time,Q.top().row,Q.top().col,Q.top().sum_discount));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] < Q.top().sum_discount+info[next_item].discount){\n\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,next_time,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(next_time < info[next_item].start){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] < Q.top().sum_discount+info[next_item].discount){\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,info[next_item].start,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int time = 0; time <= TIME_MAX; time++){\n\t\tfor(int row = 0; row < H;row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tans = max(ans,dp[limit-1][row][col]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N, lim = 0, ans = 0; cin >> N;\n        map<int, int> comp;\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            chmax(lim, e + 1);\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            x.second = id++;\n        }\n        vector<int> inv(id);\n        for(auto x : comp) {\n            inv[x.second] = x.first;\n        }\n\n        // cand の部分集合\n        vector< vector<int> > sum(1 << id, vector<int>(lim));\n        for(int bit=0; bit<(1<<id); bit++) {\n            for(int i=0; i<id; i++) {\n                if(bit >> i & 1) {\n                    int orig_id = inv[i];\n                    for(int t=0; t<lim; t++) {\n                        sum[bit][t] += disc[orig_id][t];\n                    }\n                }\n            }\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                int mx = x + dx[k], my = y + dy[k];\n                if(!(mx < 0 || mx >= H || my < 0 || my >= W) and ('0' <= board[mx][my] && board[mx][my] <= '9')) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost + sum[mask][time];\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(!(nx < 0 || nx >= H || ny < 0 || ny >= W) and !('0' <= board[nx][ny] && board[nx][ny] <= '9') and (rec[nx][ny][ntime][nbit] < ncost)) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tis_sale[number[g]] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\t//printf(\"row:%d col:%d time:%d state:%d\\n\",Q.top().row,Q.top().col,Q.top().time,Q.top().state);\n\n\t\t\t\t\tint adj_item = number[base_map[adj_row][adj_col]-'0'];\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cctype>\nusing namespace std;\ntypedef pair< int , int > Pt;\ntypedef pair< pair<int , Pt > , Pt > P; // Pt(cost,bit) , Pt(y,x)\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nconst int dx[] = { 0, 1, -1, 0}, dy[] = { 1, 0, 0, -1};\nstruct edge{\n  int prime,st,ed;\n  edge(){};\n  edge(int prime,int st,int ed):prime(prime),st(st),ed(ed){}\n};\nedge info[11];\nint x, y;\nchar mas[21][21];\nbool no_over(int ny,int nx){\n  return ny >= 0 && ny < y && nx >= 0 && nx < x;\n}\nint Dijkstra(Pt& start){\n  int ret = 0;\n  bool used[21][21][1<<11];\n  fill_n(used[0][0],20*20*(1<<11),false);\n  //  priority_queue< P , vector<P> , greater<P> > que;\n  queue< P >que;\n  que.push(P(make_pair(0,Pt((1<<10)-1,0)),start));\n  used[start.fr][start.sc][(1<<10)-1] = true;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    //if(used[p.sc.fr][p.sc.sc][p.fr.sc.fr]++) continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n      if(!no_over(ny,nx)) continue;\n      if(isdigit(mas[ny][nx])){\n        edge e = info[mas[ny][nx]-'0'];\n        int no = mas[ny][nx] - '0';\n        ny = p.sc.fr, nx = p.sc.sc;\n        if( !(p.fr.sc.fr & (1 << no)) || p.fr.fr >= e.ed) continue;\n        if(p.fr.fr >= e.st){\n          ret = max(ret,p.fr.sc.sc + e.prime);\n          if(used[ny][nx][p.fr.sc.fr&~(1<<no)]++) continue;\n          que.push(P(make_pair(p.fr.fr,Pt(p.fr.sc.fr&~(1<<no),p.fr.sc.sc + e.prime)),Pt(ny,nx)));\n        }else que.push(P(make_pair(e.st,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }else{\n        if(used[ny][nx][p.fr.sc.fr]++) continue;\n        que.push(P(make_pair(p.fr.fr+1,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> x >> y , x){\n    Pt st;\n    for(int i = 0 ; i < y ; i++ ){\n      for(int j = 0 ; j < x ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') st = Pt(i,j);\n      }\n    }\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; i++ ){\n      int g,d,s,e;\n      cin >> g >> d >> s >> e;\n      info[g] = edge(d,s,e);\n    }\n    cout << Dijkstra(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && sale[i].s<=d.t && d.t<sale[i].e)\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tif(visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 99)\n\t\t\t\tcontinue;\n\n\t\t\tQ.push(Data(d.y, d.x, d.t+1, d.mask));\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] = '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] = 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 5; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 29\n#define EPS 1e-10\n\ntypedef pair<int, int> P;\ntypedef pair<int,P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint G[512][512], m[20][20], used[8];\nint X, Y;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nint N;\nint d[8], s[8], e[8];\nvector<vector<P> >shop(8);\nint dp[32][32][128][8];\n\nint dfs(int y, int x, int t, int n){\n  //  printf(\"%d %d %d %d\\n\", y, x, t, n);\n  if(n == N) return 0;\n  if(dp[y][x][t][n] >= 0) return dp[y][x][t][n];\n  int res = 0;\n  rep(i, N){\n    if(used[i]) continue;\n\n    used[i] = 1;\n    rep(j, shop[i].size()){\n      P p = shop[i][j];\n      int dis = G[y*X+x][p.F*X+p.S];\n      int time = dis + t;\n      if(s[i] > time || e[i] <= time) continue;\n      res = max(res, dfs(p.F, p.S, time, n+1) + d[i]);\n    }\n    used[i] = 0;\n  }\n  //  printf(\"%d\\n\", res);\n  return dp[y][x][t][n] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int y, x;\n    memset(dp, -1, sizeof(dp));\n    memset(used, 0, sizeof(used));\n    rep(i, Y*X) rep(j, Y*X) G[i][j] = INF;\n    rep(i, Y) rep(j, X){\n      char c[2];\n      scanf(\"%s\", c);\n      if(c[0] == 'P'){\n\ty = i;\n\tx = j;\n\tc[0] = '.';\n      }\n      m[i][j] = c[0];\n\n    }\n\n    rep(i, Y) rep(j, X){\n      if(!(m[i][j] == '.' || m[i][j] == 'P')) continue;\n      G[i*X+j][i*X+j] = 0;\n      rep(d, 4){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(ny < 0 || ny >= Y || nx < 0 || nx >= X) continue;\n\tif(!(m[ny][nx] == '.' || m[ny][nx] == 'P')) continue;\n\tG[i*X+j][ny*X+nx] = 1;\n      }\n    }\n\n\n    rep(k, Y*X) rep(i, Y*X) rep(j, Y*X){\n      G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    scanf(\"%d\", &N);\n    rep(i, N){\n      int g;\n      scanf(\"%d\", &g);\n      scanf(\"%d%d%d\",  &d[g], &s[g], &e[g]);\n    }\n\n    rep(i, Y) rep(j, X){\n      if(m[i][j] == '.') continue;\n      int item = m[i][j] - '0';\n      rep(d, 4){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(ny < 0 || ny >= Y || nx < 0 || nx >= X || m[ny][nx] != '.') continue;\n\tshop[item].PB(P(ny, nx));\n      }\n    }\n\n    /*    rep(i, Y*X){\n      rep(j, Y*X) if(G[i][j] == INF) printf(\" INF\"); else printf(\"%4d\", G[i][j]); \n      puts(\"\");\n      }*/\n\n    /*    rep(i, N){\n      printf(\"%d\\n\", d[i]);\n      }*/\n    //    printf(\"%d\\n\", N);\n    printf(\"%d\\n\", dfs(y, x, 0, 0));\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n     \nint w, h, n;  \nchar mas[20][20];  \n     \ntypedef pair< int , int > Pi;  \ntypedef pair< Pi , Pi > Piii;  \nPi p;  \n     \nstruct sell{  \n  int d; //値引き額  \n  int s; //開始時刻  \n  int e; //終了時刻  \n};  \nsell shop[10];  \n     \nint min_cost[20][20][1 << 10][101];  \n     \nint bfs(){  \n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)  \n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};  \n     \n  memset( min_cost, -1, sizeof(min_cost));  \n  que.push( Piii( Pi( 0, 0), p));  \n  min_cost[p.second][p.first][0][0] = 0;  \n     \n  int ret = 0;  \n     \n  while(!que.empty()){  \n     \n    Piii p = que.front(); que.pop();  \n     \n    Pi point = p.second;  \n    int bit = p.first.first, time = p.first.second;  \n     \n         \n    if(ret < min_cost[point.second][point.first][bit][time]){  \n      ret = min_cost[point.second][point.first][bit][time];  \n    }  \n     \n    for(int i = 0; i < 4; i++){  \n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;  \n     \n      if(isdigit(mas[ny][nx])){  \n             \n        int time_sell = mas[ny][nx] - '0';  \n     \n        if(!((bit >> time_sell) & 1)){  \n               \n          sell se = shop[time_sell];  \n     \n          if(time < se.e){ //時間内だったら買ってみる  \n            int next_bit = bit | (1 << time_sell);  \n            if(min_cost[point.second][point.first][bit][time] + se.d > min_cost[point.second][point.first][next_bit][max( time, se.s)]){  \n              que.push( Piii( Pi( next_bit, max( time, se.s)), point));  \n              min_cost[point.second][point.first][next_bit][max(time, se.s)] = min_cost[point.second][point.first][bit][time] + se.d;  \n            }  \n          }  \n        }\n     \n      } else {  \n        if(min_cost[point.second][point.first][bit][time] > min_cost[ny][nx][bit][time + 1]){  \n          que.push( Piii( Pi( bit, time + 1), Pi( nx, ny)));  \n          min_cost[ny][nx][bit][time + 1] = min_cost[point.second][point.first][bit][time];  \n        }  \n      }  \n    }  \n  }  \n  return ret;  \n}  \n     \nint main(){  \n  while(cin >> w >> h, w){  \n    for(int i = 0; i < h; i++){  \n      for(int j = 0; j < w; j++){  \n        cin >> mas[i][j];  \n        if(mas[i][j] == 'P') p = Pi( j, i);  \n      }  \n    }  \n    cin >> n;  \n     \n    for(int i= 0; i < n; i++){  \n      int g;  \n      cin >> g;  \n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;  \n    }  \n     \n    cout << bfs() << endl;  \n  }  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\n\nint w, h;\nint sx, sy;\nint lastTime;\nint dc[10][102];\n\nchar t[22][22];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint dp[2][20][20][1<<10];\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0][sy][sx][0] = 0;\n\n  int to = (1 << 10);\n\n  for(int I = 0; I < lastTime; I++){\n    int i = I % 2;\n    int ni = (i + 1) % 2;\n\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n        for(int j = 0; j < to; j++){\n          dp[ni][y][x][j] = -1;\n        }\n      }\n    }\n\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n        if(t[y][x] != '.') continue;\n\n        for(int j = 0; j < to; j++){\n          if(dp[i][y][x][j] == -1) continue;\n\n          int ncost = dp[i][y][x][j];\n          int nj = j;\n\n          for(int k = 0; k < 4; k++){\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n            if(t[ny][nx] == '.') continue;\n\n            int id = t[ny][nx] - '0';\n\n            if(nj & (1 << id)) continue;\n            if(dc[id][I] == -1) continue;\n\n            ncost += dc[id][I];\n            nj |= (1 << id);\n          }\n\n          for(int k = 0; k < 4; k++){\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n            if(t[ny][nx] != '.') continue;\n\n            dp[ni][ny][nx][nj] = max(dp[ni][ny][nx][nj], ncost);\n          }\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n\n  for(int y = 0; y < h; y++){\n    for(int x = 0; x < w; x++){\n      for(int j = 0; j < to; j++){\n        ans = max(ans, dp[lastTime % 2][y][x][j]);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> t[i][j];\n\n        if(t[i][j] == 'P'){\n          t[i][j] = '.';\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n\n    lastTime = 0;\n    memset(dc, -1, sizeof(dc));\n\n    int n;\n    cin >> n;\n\n    while(n--){\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      lastTime = max(lastTime, e);\n\n      for(int i = s; i < e; i++){\n        dc[g][i] = d;\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V,ADJ_V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tint state,time,row,col,sum_discount;\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10],dist[20][20][20][20];\nint dp[256][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[number[buf[0]-'0']].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e,TIME_MAX = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tTIME_MAX = max(TIME_MAX,e);\n\t}\n\n\tfor(int i = 0; i < item_num; i++){\n\n\t\tfor(int k = 0; k < info[i].V.size(); k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\n\t\t\t\tint adj_row = info[i].V[k].row + diff_row[p];\n\t\t\t\tint adj_col = info[i].V[k].col + diff_col[p];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\n\t\t\t\tinfo[i].ADJ_V.push_back(Cell(adj_row,adj_col));\n\t\t\t}\n\t\t}\n\n\t\tif(info[i].ADJ_V.size() == 0)continue;\n\n\t\tsort(info[i].ADJ_V.begin(),info[i].ADJ_V.end());\n\n\t\tvector<Cell> tmp_adj;\n\n\t\tint pre_row = info[i].ADJ_V[0].row;\n\t\tint pre_col = info[i].ADJ_V[0].col;\n\n\t\ttmp_adj.push_back(info[i].ADJ_V[0]);\n\n\t\tfor(int a = 1; a < info[i].ADJ_V.size(); a++){\n\t\t\tif(pre_row != info[i].ADJ_V[a].row || pre_col != info[i].ADJ_V[a].col){\n\t\t\t\ttmp_adj.push_back(info[i].ADJ_V[a]);\n\t\t\t}\n\t\t\tpre_row = info[i].ADJ_V[a].row;\n\t\t\tpre_col = info[i].ADJ_V[a].col;\n\t\t}\n\n\t\tinfo[i].ADJ_V.clear();\n\n\t\tfor(int a = 0; a < tmp_adj.size(); a++){\n\t\t\tinfo[i].ADJ_V.push_back(tmp_adj[a]);\n\t\t}\n\n\t\t//info[i].ADJ_V.erase(unique(info[i].ADJ_V.begin(),info[i].ADJ_V.end()),info[i].ADJ_V.end());\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\tQ.push(SALE(0,0,start_row,start_col,0));\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < item_num; loop++){\n\t\t\t\tif(Q.top().state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tint next_item = loop;\n\t\t\t\t\tint next_state = Q.top().state + POW[next_item];\n\t\t\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\t\t\tfor(int k = 0; k < info[next_item].ADJ_V.size(); k++){\n\n\t\t\t\t\t\tadj_row = info[next_item].ADJ_V[k].row;\n\t\t\t\t\t\tadj_col = info[next_item].ADJ_V[k].col;\n\n\t\t\t\t\t\tnext_time = Q.top().time + dist[Q.top().row][Q.top().col][adj_row][adj_col];\n\t\t\t\t\t\tif(next_time > TIME_MAX)continue;\n\n\t\t\t\t\t\tif(next_time > info[next_item].end){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] > next_time){\n\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = next_time;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,next_time,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(next_time < info[next_item].start){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] > info[next_item].start){\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = info[next_item].start;\n\t\t\t\t\t\t\t\tQ.push(SALE(next_state,info[next_item].start,adj_row,adj_col,Q.top().sum_discount+info[next_item].discount));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nconst static int tx[4] = {+0,+1,+0,-1};\nconst static int ty[4] = {-1,+0,+1,+0};\n\nbool dp[21][21][101][1<<10];\n\nclass State{\npublic:\n  int x;\n  int y;\n  int time;\n  int got;\n  bool operator<(const State& s) const {\n    return time < s.time;\n  }\n  bool operator>(const State& s) const {\n    return time > s.time;\n  }\n  State(int x,int y,int time,int got) \n    : x(x), y(y), time(time), got(got){}\n};\n\nclass Goods{\npublic:\n  int item_id;\n  int discounted_price;\n  int sale_start_time;\n  int sale_end_time;\n  Goods(int item_id,int discounted_price, int sale_start_time,int sale_end_time)\n    : item_id(item_id),discounted_price(discounted_price),sale_start_time(sale_start_time), sale_end_time(sale_end_time){}\n  Goods(){}\n};\n\nint main(){\n  int W,H;\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    char stage[21][21];\n    memset(dp,false,sizeof(dp));\n    int sx,sy;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        char cell[8];\n        scanf(\"%s\",cell);\n        stage[y][x] = cell[0];\n        if(stage[y][x] == 'P'){\n          sy = y;\n          sx = x;\n        }\n      }\n    }\n    int total_time_sales;\n    scanf(\"%d\",&total_time_sales);\n\n    map<int,Goods> goods;\n    for(int i = 0; i < total_time_sales; i++){\n      int item_id;\n      int discounted_price;\n      int sale_start_time;\n      int sale_end_time;\n      scanf(\"%d %d %d %d\",\n            &item_id,\n            &discounted_price,\n            &sale_start_time,\n            &sale_end_time);\n      goods[item_id] = Goods(item_id,discounted_price,sale_start_time,sale_end_time);\n    }\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0));\n    dp[sx][sy][0][0] = true;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int i = 0; i < 4; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(stage[dy][dx] == '.' || stage[dy][dx] == 'P') continue;\n        const Goods& g = goods[stage[dy][dx] - '0'];\n        if(g.sale_start_time <= s.time && s.time < g.sale_end_time){\n          s.got |= (1 << g.item_id);\n        }\n      }\n\n      for(int i = 0; i < 4; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(stage[dy][dx] != '.') continue;\n        if(dp[dx][dy][s.time+1][s.got]) continue;\n        if(s.time+1 > 100) continue;\n        dp[dx][dy][s.time+1][s.got] = true;\n        que.push(State(dx,dy,s.time+1,s.got));\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        for(int S = 0; S < (1<<10); S++){\n          if(dp[x][y][100][S]){\n            int sum = 0;\n            for(int i = 0; i < 10; i++){\n              if(S & (1<<i)){\n                sum += goods[i].discounted_price;\n              }\n            }\n            res = max(res,sum);\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint W, H;\nint d[400][400];\nstd::vector<P> ps[10];\nint N;\nint G[8], D[8], S[8], E[8];\nint dp[1<<8][20][20][101];\n\nbool didGoSame(int state, int v){\n    REP(i, N){\n        if(state >> i & 1 && G[i] == G[v]){return true;}\n    }\n    return false;\n}\n\nbool canGoNext(int state, int x, int y, int t){\n    REP(i, N){\n        if(state >> i & 1){continue;}\n        if(didGoSame(state, i)){continue;}\n        for(P &p : ps[G[i]]){\n            int nt = t + d[x+y*W][p.first+p.second*W];\n            if(S[i] <= nt && nt < E[i]){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint rec(int state, int x, int y, int t){\n    // printf(\"%d, %d, %d\\n\", x, y, t);\n    if(dp[state][x][y][t] != -1){return dp[state][x][y][t];}\n    if(!canGoNext(state, x, y, t)){return 0;}\n\n    int res = 0;\n    REP(i, N){\n        if(state >> i & 1){continue;}\n        if(didGoSame(state, i)){continue;}\n        for(P &p : ps[G[i]]){\n            int nt = t + d[x+y*W][p.first+p.second*W];\n            // printf(\"%d, (%d, %d)\\n\", nt, p.first, p.second);\n            if(S[i] <= nt && nt < E[i]){\n                res = std::max(res, D[i] + rec(state | 1 << i, p.first, p.second, nt));\n            }\n        }\n    }\n\n    return dp[state][x][y][t] = std::max(res, rec(state, x, y, t+1));\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        REP(i, 10){\n            ps[i].clear();\n        }\n\n        REP(i, 1<<8){\n            REP(j, 20){\n                REP(k, 20){\n                    REP(l, 101){\n                        dp[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n\n        char map[20][20];\n        int sx, sy;\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n                if(map[i][j] == 'P'){\n                    map[i][j] = '.';\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        REP(i, 400){\n            REP(j, 400){\n                if(i == j){d[i][j] = 0;}\n                else{d[i][j] = INF;}\n            }\n        }\n\n        REP(y, H){\n            REP(x, W){\n                REP(k, 4){\n                    int nx = x + dx[k], ny = y + dy[k];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n                        if(map[y][x] != '.'){\n                            ps[map[y][x]-'0'].push_back(mp(nx, ny));\n                        }else if(map[y][x] == '.'){\n                            d[x+y*W][nx+ny*W] = 1;\n                            d[nx+ny*W][x+y*W] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        REP(k, W*H){\n            REP(i, W*H){\n                REP(j, W*H){\n                    d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        std::cin >> N;\n\n        REP(i, N){\n            std::cin >> G[i] >> D[i] >> S[i] >> E[i];\n        }\n\n        std::cout << rec(0, sx, sy, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int MAX_SIZE=20;\nconst int BIT=(1<<11)-1;\nconst int MAX_N=8;\n\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\n\nint H,W,N;\nint g[MAX_N],d[MAX_N],s[MAX_N],e[MAX_N];\n\nint fld[MAX_SIZE][MAX_SIZE];\nint dp[2][MAX_SIZE][MAX_SIZE][BIT];\n\nint main(){\n    while(scanf(\"%d%d\",&W,&H),W||H){\n        int sy,sx;\n        rep(i,H)rep(j,W){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='.')fld[i][j]=-1;\n            else if(c=='P'){sy=i;sx=j;fld[i][j]=-1;}\n\n            else fld[i][j]=c-'0';\n        }\n\n        scanf(\"%d\",&N);\n        rep(i,N)scanf(\"%d%d%d%d\",&g[i],&d[i],&s[i],&e[i]);\n\n\n        memset(dp,-1,sizeof(dp));\n        dp[0][sy][sx][0]=0;\n\n\n        rep(T,101)rep(i,H)rep(j,W)rep(bit,BIT+1)if(~dp[T&1][i][j][bit]){\n            rep(del,4){\n                int ny=i+dy[del],nx=j+dx[del];\n                if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]==-1)continue;\n                int ma=0;\n                int type=fld[ny][nx];\n                if((bit>>type)&1)continue;\n                rep(k,N){\n                    if(type==g[k]&&s[k]<=T&&T<e[k])ma=max(ma,d[k]);\n                }\n                dp[T&1][i][j][bit|(1<<type)]=max(dp[T&1][i][j][bit|(1<<type)],dp[T&1][i][j][bit]+ma);\n            }\n\n\n            dp[(T+1)&1][i][j][bit]=min(dp[(T+1)&1][i][j][bit],dp[T&1][i][j][bit]);\n            rep(del,4){\n                int ny=i+dy[del],nx=j+dx[del];\n                if(ny<0||ny>=H||nx<0||nx>=W||~fld[i][j])continue;\n                dp[(T+1)&1][ny][nx][bit]=max(dp[(T+1)&1][ny][nx][bit],dp[T&1][i][j][bit]);\n\n            }\n            dp[T&1][i][j][bit]=0;\n        }\n\n        int ans=0;\n        rep(i,H)rep(j,W)rep(bit,BIT+1)ans=max(ans,dp[1][i][j][bit]);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int W, H;\n  while(cin>>W>>H && W){\n    char grid[20][20];\n    REP(y, H)REP(x, W) cin>>grid[y][x];\n    int sx, sy;\n    REP(y, H)REP(x, W) if(grid[y][x] == 'P'){\n      sx = x; sy = y;\n      grid[y][x] = '.';\n      break;\n    }\n    int N;\n    cin>>N;\n    int G[8], D[8], S[8], E[8];\n    REP(i, N) cin >> G[i] >> D[i] >> S[i] >> E[i];\n    static bool used[20][20][1<<8][102] = {};\n    memset(used, 0, sizeof(used));\n    queue<int> qx, qy, qs, qt;\n    qx.push(sx);\n    qy.push(sy);\n    qs.push(0);\n    qt.push(0);\n    set<int> ans;\n    ans.insert(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      int s = qs.front(); qs.pop();\n      int t = qt.front(); qt.pop();\n      if(t >= 101) continue;\n      REP(r, 4) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H)){\n          if(grid[ny][nx] == '.'){\n            if(!used[ny][nx][s][t + 1]){\n              used[ny][nx][s][t + 1] = true;\n              qx.push(nx);\n              qy.push(ny);\n              qs.push(s);\n              qt.push(t + 1);\n            }\n          }else{\n            REP(i, N)if(0 == (s >> i & 1)){\n              if(G[i] == grid[ny][nx] - '0' && S[i] <= t && t < E[i]){\n                int ns = s | (1 << i);\n                if(!used[y][x][ns][t]){\n                  used[y][x][ns][t] = true;\n                  qx.push(x);\n                  qy.push(y);\n                  qs.push(ns);\n                  qt.push(t);\n                  ans.insert(ns);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    vector<int> v;\n    int out = 0;\n    FORIT(it, ans){\n      bool ok = true;\n      int s = *it;\n      REP(i, N) REP(j, N) if(i != j && s >> i & 1 && s >> j & 1 && G[i] == G[j]) ok = false;\n      if(!ok) continue;\n      int tmp = 0;\n      REP(i, N)if(s >> i & 1){\n        tmp += D[i];\n      }\n      out = max(out, tmp);\n    }\n    cout << out << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      for(int k=0;k<(1<<10);k++){\n        vis[i][j][k] = false;\n      }\n    }\n  }\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          if(u.t >= data[num].s){\n            v.y = u.y;\n            v.x = u.x;\n            v.used = u.used | (1<<num);\n            //v.t = max(u.t, data[num].s);\n            v.t = u.t;\n            v.sum = u.sum + data[num].d;\n            res = max(res, v.sum);\n            if(!vis[v.y][v.x][v.used]){\n              vis[v.y][v.x][v.used] = true;\n              q.push(v);\n            }\n          }else{\n            q.push(State(u.y, u.x, u.used, data[num].s, u.sum));\n          }\n        }\n      }else{\n        if(!vis[ny][nx][u.used]){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cassert>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n \nconst int INF = 1001001001;\n \n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n \nint W, H;\nchar map[20][20];\nint can_buy[20][20];\nint N;\nint G[8], D[8], S[8], E[8];\nint dp[1<<8][20][20][101];\n \nbool didGoSame(int state, int v){\n    REP(i, N){\n        if(state >> i & 1 && G[i] == G[v]){return true;}\n    }\n    return false;\n}\n \nint rec(int state, int x, int y, int t){\n    // printf(\"%d, %d, %d\\n\", x, y, t);\n    if(t > 100){return 0;}\n    if(dp[state][x][y][t] != -1){return dp[state][x][y][t];}\n \n    int res = 0;\n    REP(j, N){\n        // printf(\"%d, %d: %d\\n\", x, y, t);\n        if(!(state >> j & 1) && !didGoSame(state, j) && can_buy[y][x] >> G[j] & 1 && S[j] <= t && t < E[j]){\n            res = std::max(res, D[j] + rec(state | 1 << j, x, y, t));\n        }\n    }\n\n    REP(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n            res = std::max(res, rec(state, nx, ny, t+1));\n        }\n    }\n \n    return dp[state][x][y][t] = res;\n}\n \nint main(){\n    while(std::cin >> W >> H, W){\n        REP(i, 20){\n            REP(j, 20){\n                can_buy[i][j] = 0;\n            }\n        }\n \n        REP(i, 1<<8){\n            REP(j, 20){\n                REP(k, 20){\n                    REP(l, 101){\n                        dp[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n \n        int sx, sy;\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n                if(map[i][j] == 'P'){\n                    map[i][j] = '.';\n                    sx = j; sy = i;\n                }\n            }\n        }\n \n        REP(y, H){\n            REP(x, W){\n                REP(k, 4){\n                    if(map[y][x] == '.'){continue;}\n                    int nx = x + dx[k], ny = y + dy[k];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && map[ny][nx] == '.'){\n                        can_buy[ny][nx] |= 1 << (map[y][x] - '0');\n                    }\n                }\n            }\n        }\n \n        std::cin >> N;\n \n        REP(i, N){\n            std::cin >> G[i] >> D[i] >> S[i] >> E[i];\n        }\n \n        std::cout << rec(0, sx, sy, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tv[temp.bit][temp.ty][temp.tx] = true;\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t\telse if (map[my][mx] != -1 && !((temp.bit >> map[my][mx]) & 1) && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= 1 << map[my][mx];\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int d,get,y,x;\n    bool operator<(const State& right) const{\n        return d > right.d;\n    }\n};\nconst int dx[] = {0,0,1,-1,0};\nconst int dy[] = {1,-1,0,0,0};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,101);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        int d[(1<<10)][20][20];\n        for(int i=0;i<(1<<10);i++)for(int j=0;j<20;j++)for(int k=0;k<20;k++) d[i][j][k] = INF;\n        d[0][sy][sx] = 0;\n        priority_queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.top(); que.pop();\n            //printf(\"p.d=%d p.get=%d p.y=%d p.x=%d\\n\",p.d,p.get,p.y,p.x);\n            if(d[p.get][p.y][p.x]<p.d) continue;\n            ans = max(ans, de_sum[p.get]);\n            if(p.d>=100)continue;\n            for(int i=0;i<5;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                int nget = p.get, nd = p.d + 1;\n                for(int j=0;j<4;j++){\n                    int ny2 = ny + dy[j], nx2 = nx + dx[j];\n                    if(ny2<0||h<=ny2||nx2<0||w<=nx2)continue;\n                    if('0'<=field[ny2][nx2]&&field[ny2][nx2]<='9'){\n                        int g_i = field[ny2][nx2] - '0';\n                        if(st_i[g_i] <= nd && nd < et_i[g_i]){\n                            nget |= (1<<g_i);\n                        }\n                    }\n                }\n                if(d[nget][ny][nx]>nd){\n                    d[nget][ny][nx] = nd;\n                    que.push((State){nd, nget, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define NMAX 20\n#define TMAX 100\nstatic const int dy[5] = {0, 0, -1, 0, 1};\nstatic const int dx[5] = {0, 1, 0, -1, 0};\nclass State{\npublic:\n  int y, x, t, s;\n  State(){}\n  State(int y, int x, int t, int s):y(y), x(x), t(t), s(s){}\n};\n\nstruct Item{ int disc, ts, te; };\n\nint W, H, sy, sx, n;\n\nbool T[NMAX][NMAX][TMAX+1][(1<<8)];\nchar G[NMAX][NMAX];\nItem I[10];\n\nbool valid(int ny, int nx){\n  if ( ny < 0 || nx < 0 || ny >= H || nx >= W ) return false;\n  return G[ny][nx] == '.';\n}\n\nint getAVPoint( int y, int x, int t ){\n  int u = 0;\n\n  for ( int r = 1; r < 5; r++ ){\n    int ny = y + dy[r];\n    int nx = x + dx[r];\n    if (ny < 0 || nx < 0 || ny >= H || nx >= W )  continue;\n    if ( G[ny][nx] == '.' ) continue;\n    int inum = G[ny][nx] - '0';\n    //if ( I[inum].ts  <= t && t <= I[inum].te ){\n    if ( I[inum].ts  <= t && t < I[inum].te ){\n      u = (u | (1<<inum));\n    }\n  }\n\n  return u;\n}\n\nint getPoint(int s){\n  int sum = 0;\n\n  for ( int i = 0; i < n; i++ ){\n    if ( (s & (1<<i)) > 0 ){\n      sum += I[i].disc;\n    }\n  }\n\n  return sum;\n}\n\nvoid compute(){\n  rep(i, H) rep(j, W) rep(k, TMAX+1) rep(l, (1<<n)){\n    T[i][j][k][l] = false;\n  }\n\n  T[sy][sx][0][getAVPoint(sy, sx, 0)] = true;\n\n  queue<State> Q;\n  Q.push(State(sy, sx, 0, getAVPoint(sy, sx, 0)));\n\n  State u, v;\n\n  int ans = 0;\n  while(!Q.empty() ){\n    u = Q.front(); Q.pop();\n    ans = max(ans, getPoint(u.s));\n    for ( int r = 0;  r < 5; r++ ){\n      int ny = u.y + dy[r];\n      int nx = u.x + dx[r];\n      if ( !valid(ny, nx) ) continue;\n      v = u;\n      v.y = ny;\n      v.x = nx;\n      v.t++;\n      if ( v.t > 100 ) continue;\n      v.s = (v.s | getAVPoint(v.y, v.x, v.t));\n      if ( !T[v.y][v.x][v.t][v.s] ){\n\tT[v.y][v.x][v.t][v.s] = true;\n\tQ.push(v);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nmain(){\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if ( G[i][j] == 'P' ){\n\tG[i][j] = '.';\n\tsy = i; sx = j;\n      }\n    }\n    cin >> n;\n    rep(i, n) {\n      cin >> I[i].disc >> I[i].ts >> I[i].te;\n    }\n    compute();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20][101];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0, 0};\n\tint dy[] = {0, 1, 0, -1, 0};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tv[0][st.ty][st.tx][0] = true;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 5; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx][temp.time + 1] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tv[st.bit][st.ty][st.tx][st.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t\telse if (~map[my][mx] && !((temp.bit >> map[my][mx]) & 1) \n\t\t\t\t\t\t\t\t&& v[temp.bit | (1 << map[my][mx])][temp.ty][temp.tx][temp.time] == false\n\t\t\t\t\t\t\t\t  && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= (1 << map[my][mx]);\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tv[st.bit][st.ty][st.tx][st.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && sale[i].s<=d.t && d.t<sale[i].e)\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 100 || visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\n\t\t\tQ.push(Data(d.y, d.x, d.t+1, d.mask));\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\n\nint w, h;\nint sx, sy;\nint lastTime;\nint dc[10][102];\n\nchar t[22][22];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nshort dp[101][20][20][1<<10];\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0][sy][sx][0] = 0;\n\n  int to = (1 << 10);\n\n  for(int i = 0; i < lastTime; i++){\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n        if(t[y][x] != '.') continue;\n\n        for(int j = 0; j < to; j++){\n          if(dp[i][y][x][j] == -1) continue;\n\n          int ncost = dp[i][y][x][j];\n          int nj = j;\n\n          for(int k = 0; k < 4; k++){\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n            if(t[ny][nx] == '.') continue;\n\n            int id = t[ny][nx] - '0';\n\n            if(nj & (1 << id)) continue;\n            if(dc[id][i] == -1) continue;\n\n            ncost += dc[id][i];\n            nj |= (1 << id);\n          }\n\n          for(int k = 0; k < 4; k++){\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n            if(t[ny][nx] != '.') continue;\n\n            dp[i + 1][ny][nx][nj] = max((int)dp[i + 1][ny][nx][nj], ncost);\n          }\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n\n  for(int y = 0; y < h; y++){\n    for(int x = 0; x < w; x++){\n      for(int j = 0; j < to; j++){\n        ans = max(ans, (int)dp[lastTime][y][x][j]);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> t[i][j];\n\n        if(t[i][j] == 'P'){\n          t[i][j] = '.';\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n\n    lastTime = 0;\n    memset(dc, -1, sizeof(dc));\n\n    int n;\n    cin >> n;\n\n    while(n--){\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      lastTime = max(lastTime, e);\n\n      for(int i = s; i < e; i++){\n        dc[g][i] = d;\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n#include <assert.h>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nbool dp[2][20][20][1 << 10];\n\nint main() {\n    int h, w;\n    array<int, 5> dy{-1, 1, 0, 0, 0}, dx{0, 0, -1, 1, 0};\n    while(cin >> w >> h, w){\n        vector<vector<int>> grid(h+2, vector<int>(w+2, -1));\n        int sy = 0, sx = 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                char c; cin >> c;\n                if(c == 'P') sy = i, sx = j, grid[i+1][j+1] = 0;\n                else if(c == '.') grid[i+1][j+1] = 0;\n                else grid[i+1][j+1] = 1+(c-'0');\n            }\n        }\n        int n;\n        cin >> n;\n        vector<int> gs(n), ds(n), ss(n), es(n);\n        int M = 110;\n        vector<int> id(11, -1);\n        for (int i = 0; i < n; ++i) {\n            cin >> gs[i] >> ds[i] >> ss[i] >> es[i];\n            assert(id[gs[i]+1] == -1);\n            id[gs[i]+1] = i;\n        }\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                for (int k = 0; k < 1 << n; ++k) {\n                    dp[0][i][j][k] = 0;\n                }\n            }\n        }\n        dp[0][sy][sx][0] = 1;\n        for (int i = 0; i < M; ++i) {\n            int now = i&1, nxt = now^1;\n            for (int j = 0; j < h; ++j) {\n                for (int k = 0; k < w; ++k) {\n                    for (int l = 0; l < 1 << n; ++l) {\n                        dp[nxt][j][k][l] = 0;\n                    }\n                }\n            }\n            for (int j = 0; j < h; ++j) {\n                for (int k = 0; k < w; ++k) {\n                    for (int d = 0; d < 5; ++d) {\n                        if(grid[j+1+dy[d]][k+1+dx[d]]) continue;\n                        for (int l = 0; l < (1 << n); ++l) {\n                            if(!dp[now][j][k][l]) continue;\n                            int l2 = l;\n                            for (int dd = 0; dd < 4; ++dd) {\n                                if(!~grid[j+1+dy[dd]][k+1+dx[dd]] || !~id[grid[j+1+dy[dd]][k+1+dx[dd]]]) continue;\n                                int m = id[grid[j+1+dy[dd]][k+1+dx[dd]]];\n                                if(!(l2 & (1 << m)) && ss[m] <= i && i < es[m]) {\n                                    l2 |= (1 << m);\n                                }\n                            }\n                            dp[nxt][j+dy[d]][k+dx[d]][l2] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int j = 0; j < h; ++j) {\n            for (int k = 0; k < w; ++k) {\n                for (int l = 0; l < (1 << n); ++l) {\n                    if(!dp[M&1][j][k][l]) continue;\n                    int val = 0;\n                    for (int m = 0; m < n; ++m) {\n                        if(l & (1 << m)) val += ds[m];\n                    }\n                    ans = max(ans, val);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct node{\n\tint x,y,bit,t;\n\tnode(int x,int y,int bit,int t) : x(x) , y(y) , bit(bit) , t(t) {}\n};\n\nint x,y;\nint sx,sy;\nint n;\nchar c[22][22];\nint num[10],d[10],s[10],e[10];\nint value[1<<10];\nint done[22][22][1<<8][102];\nint dx[5]={0,0,1,-1,0},dy[5]={1,-1,0,0,0};\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tqueue<node> que;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j=0;j<=21;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tcin >> c[j][i];\n\t\t\t\tif(c[j][i]=='P'){\n\t\t\t\t\tque.push(node(j,i,0,0));\n\t\t\t\t\tc[j][i]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tscanf(\"%d%d%d\",&d[a],&s[a],&e[a]);\n\t\t}\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n                value[i]+=(i>>j&1)*d[j];\n            }\n            //cout << value[i] << \" \" << i << endl;\n        }\n\t\tmemset(done,0,sizeof(done));\n\t\tint ans=0;\n\t\twhile(que.size()){\n\t\t\tnode q=que.front();que.pop();\n\t\t\tif(q.t>100)continue;\n\t\t\tif(c[q.x][q.y]!='.')continue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint tx=q.x+dx[i];\n\t\t\t\tint ty=q.y+dy[i];\n\t\t\t\tif(c[tx][ty]>='0' && c[tx][ty]<='9'){\n\t\t\t\t\tint idx=c[tx][ty]-'0';\n\t\t\t\t\tif(s[idx]<=q.t && q.t<e[idx])q.bit |= 1<<idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(done[q.x][q.y][q.bit][q.t]++)continue;\n\t\t\tans=max(ans,value[q.bit]);\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tque.push(node(q.x+dx[i],q.y+dy[i],q.bit,q.t+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//とおしたいね\ntypedef long long int64;\n//同じ商品で何回かタイムせーるしてる？\n//うーん//\nstruct Sale{\n  int g;\n  int64 d;\n  int s, e;\n} sale[8];\nstruct State{\n  unsigned char x, y, time;\n  unsigned bit, used_pop; //used_pop: 使った商品\n  State( unsigned char x, unsigned char y, unsigned bit, unsigned char time, unsigned used_pop):x(x),y(y),bit(bit),time(time),used_pop(used_pop){};\n};\n\nint W, H, N, sy, sx;\nbool used[20][20][1 << 8][101];\nchar m[20][20];\nint64 cost[1 << 8];\nconst int dy[] = { 0, 1, 0, -1, 0}, dx[] = { 1, 0, -1, 0, 0};\nqueue< State > que;\nint64 BFS(){\n  que.push(State( sx, sy, 0, 0, 0));\n  used[sy][sx][0][0] = true;\n  memset( used, false, sizeof(used));\n  for(int i = 0; i < 1 << N; i++){\n    cost[i] = 0;\n    for(int j = 0; j < N; j++){\n      if((i >> j) & 1){\n        cost[i] += sale[j].d;\n      }\n    }\n  }\n  int64 ret = 0;\n  while(!que.empty()){\n    State p = que.front(); que.pop();\n    ret = max( ret, cost[p.bit]);\n    if(p.time > 100) continue;\n    for(int i = 0; i < 4; i++){\n      int ny = p.y + dy[i], nx = p.x + dx[i];\n      if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n      if(isdigit(m[ny][nx])){\n        for(int j = 0; j < N; j++){\n          if(m[ny][nx] - '0' == sale[j].g && !((p.bit >> j) & 1) && !((p.used_pop >> sale[j].g) & 1)){\n            if(sale[j].s <= p.time && p.time < sale[j].e){\n              if(used[p.y][p.x][p.bit|(1 << j)][p.time]++) continue;\n              que.push( State( p.x, p.y, p.bit|(1 << j), p.time,\n                               p.used_pop|(1 << sale[j].g)));\n            }\n          }\n        }\n      }\n    }\n    for(int i = 0; i < 5; i++){\n      int ny = p.y + dy[i], nx = p.x + dx[i];\n      if(ny < 0 || ny >= H || nx < 0 || nx >= W || m[ny][nx] != '.') continue;\n      if(used[ny][nx][p.bit][p.time + 1]++) continue;\n      que.push( State( nx, ny, p.bit, p.time + 1, p.used_pop));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> W >> H, W||H){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> m[i][j];\n        if(m[i][j] == 'P') m[i][j] = '.', sy = i, sx = j;\n      }\n    }\n    cin >> N;\n    for(int i = 0; i < N; i++){\n      cin >> sale[i].g >> sale[i].d >> sale[i].s >> sale[i].e;\n    }\n    cout << BFS() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t\tif(sale[i].s == 100){\n\t\t\t\tassert(false);\n\t\t\t\tfor(;;);\n\t\t\t}\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && sale[i].s<=d.t && d.t<sale[i].e)\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tif(visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 99)\n\t\t\t\tcontinue;\n\n\t\t\tQ.push(Data(d.y, d.x, d.t+1, d.mask));\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n#define create clear\n\ntypedef pair< int , int > Pi;\n\nint w, h, n, sx, sy;\nchar mas[20][20];\nstruct sell{\n  int d, s, e; //終了時刻  \n};\nsell shop[10];\nvector< vector< Pi > > hori_sensei;\nint dp[1 << 10][20][20][101];\nint cost[20][20][20][20];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\nvoid bfs(int y, int x){\n  queue< Pi > que;\n  que.push( Pi( x, y));\n  cost[y][x][y][x] = 0;\n  while(!que.empty()){\n    Pi p = que.front();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int ny = p.second + dy[i], nx = p.first + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] != '.') continue;\n      if(cost[y][x][ny][nx]  > cost[y][x][p.second][p.first] + 1){\n        cost[y][x][ny][nx] = cost[y][x][p.second][p.first] + 1;\n        que.push( Pi( nx, ny));\n      }\n    }\n  } \n  return ;\n}\nint main(){\n\n  while(cin >> w >> h, w){\n\n    hori_sensei.create();\n    hori_sensei.resize(10);\n    int INF = 1 << 30;\n    fill_n( ***cost, 20 * 20 * 20 * 20, INF);\n    memset( dp, -1, sizeof(dp));\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P'){\n          mas[i][j] = '.';\n          sx = j, sy = i;\n        }\n      }\n    }\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(mas[i][j] == '.'){\n          for(int k = 0; k < 4; k++){\n            int ny = i + dy[k], nx = j + dx[k];\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] == '.') continue;\n            hori_sensei[mas[ny][nx] - '0'].push_back( Pi( i, j));\n          }\n          bfs(i,j);\n        }\n      }\n    }\n\n\n    cin >> n;\n    for(int i = 0; i < 10; i++) shop[i].d = -1;\n    for(int i = 0; i < n; i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      shop[a] = (sell){ b, c, d};\n    }\n\n    dp[0][sy][sx][0] = 0;\n    for(int time = 0; time < 101; time++){\n      for(int i = 0; i < (1 << 10) - 1; i++){\n        for(int y = 0; y < h; y++){\n          for(int x = 0; x < w; x++){\n            if(dp[i][y][x][time] == -1 || mas[y][x] != '.') continue;\n            for(int j = 0; j < 10; j++){\n              if((i >> j) & 1 || shop[j].d == -1 || time >= shop[j].e) continue;\n              for(int k = 0; k < hori_sensei[j].size(); k++){\n                int res = cost[y][x][hori_sensei[j][k].first][hori_sensei[j][k].second];\n                if(time + res >= shop[j].e) continue;\n                int& ret = dp[i|(1 << j)][hori_sensei[j][k].first][hori_sensei[j][k].second][max(time + res, shop[j].s)];\n                ret = max( ret, dp[i][y][x][time] + shop[j].d);\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << *max_element( dp[0][0][0], dp[1 << 10][0][0]) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\nchar c[22][22];\n\n\nstruct NODE{\n\tint x,y,bit,time;\n\tNODE(int x,int y,int bit,int time) : x(x) , y(y) , bit(bit) , time(time) {}\n};\n\nint num[10] , d[10] , s[10] , e[10];\nint done[22][22][1<<8][102] = {};\n\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint main(){\n\tint W,H;\n\twhile(cin >> W >> H && W){\n\t\trep(i,22)rep(j,22) c[i][j] = '#';\n\t\tqueue<NODE> Q;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif( c[i+1][j+1] == 'P'){\n\t\t\t\t\tQ.push(NODE(j+1,i+1,0,0));\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint N;\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint g;\n\t\t\tcin >> g;\n\t\t\tnum[g] = i;\n\t\t\tcin >> d[i] >> s[i] >> e[i];\n\t\t}\n\t\tint value[1<<10] = {};\n\t\tfor(int i = 0 ; i < (1<<N) ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tvalue[i] += (i>>j&1) * d[j];\n\t\t\t}\n\t\t\t//cout << value[i] << \" \" << i << endl;\n\t\t}\n\t\t\n\t\tmemset(done,0,sizeof(done));\n\t\tint ans = 0;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\tif( q.time > 100 ) continue;\n\t\t\tif( c[q.y][q.x] != '.' ) continue;\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tint tx = q.x + dx[i];\n\t\t\t\tint ty = q.y + dy[i];\n\t\t\t\tif( c[ty][tx] >= '0' && c[ty][tx] <= '9' ){\n\t\t\t\t\tint idx = num[c[ty][tx]-'0'];\n\t\t\t\t\tif( s[idx] <= q.time && q.time < e[idx] ) q.bit |= 1<<idx;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( done[q.x][q.y][q.bit][q.time]++ ) continue;\n\t\t\tans = max( ans , value[q.bit] );\n\t\t\tfor(int i = 0 ; i < 5 ; i++){\n\t\t\t\tQ.push(NODE(q.x+dx[i],q.y+dy[i],q.bit,q.time+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nclass Item{\npublic:\n\tint n,c,s,g;\n\tItem(int n=0,int c=0,int s=0,int g=0):n(n),c(c),s(s),g(g){}\n};\n\nclass State{\npublic:\n\tint x,y,cost,sum,visited;\n\tState(int x=0,int y=0,int c=0,int s=0,int v=0):x(x),y(y),cost(c),sum(s),visited(v){}\n};\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h && h && w){\n\t\tint a[20][20], n, ans = 0;\n        bool G[20][20];\n        int n_i[10]; //商品番号を配列の番号に変換\n\t\tbool f[20][20][(1<<8)];\n\t\tItem item[8];\n\t\tqueue<State> Q;\n\t\tState u,v;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<(1<<8);k++) f[i][j][k] = false;\n\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tG[i][j] = true;\n\t\t\t\ta[i][j] = -1;\n\t\t\t\tif(c == '.') G[i][j] = false;\n\t\t\t\telse if(c == 'P'){\n\t\t\t\t\tu.y = i;\n\t\t\t\t\tu.x = j;\n\t\t\t\t\tf[i][j][0] = true;\n\t\t\t\t\tG[i][j] = false;\n\t\t\t\t} else a[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> item[i].n >> item[i].c >> item[i].s >> item[i].g;\n            n_i[item[i].n] = i;\n\t\t}\n\n\t\tQ.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n            \n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tv = u;\n\t\t\t\tv.y += dy[i];\n\t\t\t\tv.x += dx[i];\n\t\t\t\tv.cost++;\n\t\t\t\tif(v.y >= 0 && v.y < h && v.x >= 0 && v.x < w && !f[v.y][v.x][v.visited]){\n                    if(!G[v.y][v.x]){\n                        f[v.y][v.x][v.visited] = true;\n                        Q.push(v);\n                    }\n                    else if((v.visited & (1<<n_i[a[v.y][v.x]])) == 0){\n                        if(u.cost >= item[n_i[a[v.y][v.x]]].s && u.cost < item[n_i[a[v.y][v.x]]].g){\n                            State v2 = u;\n                            //f[v2.y][v2.x][v2.visited] = true;\n                            v2.visited = v2.visited | (1<<n_i[a[v.y][v.x]]);\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.sum += item[n_i[a[v.y][v.x]]].c;\n                            ans = max(ans,v2.sum);\n                            if(v2.visited != ((1<<n)-1)) Q.push(v2);\n                        } else if(u.cost < item[n_i[a[v.y][v.x]]].s){\n                            //変更点\n                            State v2 = u;\n                            v2.cost += item[n_i[a[v.y][v.x]]].s - v2.cost;\n                            Q.push(v2);\n                            //ここまで\n                        }\n                    }\n                }\n            }\n            \n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if (good[SY][SX] & (1 << g)) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[next][state | s][ny][nx] =\n                  max(dp[next][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nconst static int tx[4] = {+0,+1,+0,-1};\nconst static int ty[4] = {-1,+0,+1,+0};\n\nbool dp[21][21][101][1<<10];\n\nclass State{\npublic:\n  int x;\n  int y;\n  int time;\n  int got;\n  bool operator<(const State& s) const {\n    return time < s.time;\n  }\n  bool operator>(const State& s) const {\n    return time > s.time;\n  }\n  State(int x,int y,int time,int got) \n    : x(x), y(y), time(time), got(got){}\n};\n\nclass Goods{\npublic:\n  int item_id;\n  int discounted_price;\n  int sale_start_time;\n  int sale_end_time;\n  Goods(int item_id,int discounted_price, int sale_start_time,int sale_end_time)\n    : item_id(item_id),discounted_price(discounted_price),sale_start_time(sale_start_time), sale_end_time(sale_end_time){}\n  Goods(){}\n};\n\nint main(){\n  int W,H;\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    char stage[21][21];\n    memset(dp,false,sizeof(dp));\n    int sx,sy;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        char cell[8];\n        scanf(\"%s\",cell);\n        stage[y][x] = cell[0];\n        if(stage[y][x] == 'P'){\n          sy = y;\n          sx = x;\n        }\n      }\n    }\n    int total_time_sales;\n    scanf(\"%d\",&total_time_sales);\n\n    map<int,Goods> goods;\n    for(int i = 0; i < total_time_sales; i++){\n      int item_id;\n      int discounted_price;\n      int sale_start_time;\n      int sale_end_time;\n      scanf(\"%d %d %d %d\",\n            &item_id,\n            &discounted_price,\n            &sale_start_time,\n            &sale_end_time);\n      goods[item_id] = Goods(item_id,discounted_price,sale_start_time,sale_end_time);\n    }\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0));\n    dp[sx][sy][0][0] = true;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int i = 0; i < 4; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(stage[dy][dx] == '.' || stage[dy][dx] == 'P') continue;\n        const Goods& g = goods[stage[dy][dx] - '0'];\n        if(g.sale_start_time <= s.time && s.time < g.sale_end_time){\n          s.got |= (1 << g.item_id);\n        }\n      }\n\n      for(int i = 0; i < 4; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(stage[dy][dx] != '.') continue;\n        if(dp[dx][dy][s.time+1][s.got]) continue;\n        if(s.time+1 > 100) continue;\n        dp[dx][dy][s.time+1][s.got] = true;\n        que.push(State(dx,dy,s.time+1,s.got));\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        for(int time = 0; time <= 100; time++){\n          for(int S = 0; S < (1<<10); S++){\n            if(dp[x][y][time][S]){\n              int sum = 0;\n              for(int i = 0; i < 10; i++){\n                if(S & (1<<i)){\n                  sum += goods[i].discounted_price;\n                }\n              }\n              res = max(res,sum);\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tis_sale[number[g]] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\t//printf(\"row:%d col:%d time:%d state:%d\\n\",Q.top().row,Q.top().col,Q.top().time,Q.top().state);\n\n\t\t\t\t\tint adj_item = number[base_map[adj_row][adj_col]-'0'];\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tint adj_min_time = info[adj_item].start;\n\t\t\t\t\t\tint min_index = adj_item;\n\n\t\t\t\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\t\t\t\tint calc_adj_row = Q.top().row + diff_row[p];\n\t\t\t\t\t\t\tint calc_adj_col = Q.top().col + diff_col[p];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_adj_row,calc_adj_col) == false || base_map[calc_adj_row][calc_adj_col] == '.' || is_sale[number[base_map[calc_adj_row][calc_adj_col]-'0']] == false)continue;\n\n\t\t\t\t\t\t\tint calc_index = number[base_map[calc_adj_row][calc_adj_col]-'0'];\n\n\t\t\t\t\t\t\tif(info[calc_index].start >= Q.top().time && info[calc_index].start < adj_min_time && (Q.top().visited[calc_index] == false)){ //?????¨??????????????£??\\?????????????????????????????????\n\t\t\t\t\t\t\t\tadj_min_time = info[calc_index].start;\n\t\t\t\t\t\t\t\tmin_index = calc_index;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(min_index != adj_item)continue; //??£??\\????°?????????§????????????skip\n\n\t\t\t\t\t\tnext_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > adj_min_time){\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = adj_min_time;\n\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = adj_min_time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<string> grid(h, string(w, '0'));\n        int sy, sx;\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                cin >> grid[y][x];\n                if(grid[y][x] == 'P'){\n                    sy = y;\n                    sx = x;\n                    grid[y][x] = '.';\n                }\n            }\n        }\n\n        int n;\n        cin >> n;\n        int m = 0;\n        vector<int> change(10, -1);\n        vector<vector<int> > sale(8, vector<int>(100, 0));\n        for(int i=0; i<n; ++i){\n            int g, d, s, e;\n            cin >> g >> d >> s >> e;\n            if(change[g] == -1){\n                change[g] = m;\n                g = m;\n                ++ m;\n            }\n            for(int j=s; j<e; ++j)\n                sale[g][j] = d;\n        }\n        \n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                if(grid[y][x] != '.'){\n                    if(change[grid[y][x]-'0'] == -1)\n                        grid[y][x] = '#';\n                    else\n                        grid[y][x] = change[grid[y][x]-'0'] + '0';\n                }\n            }\n        }\n\n        vector<vector<vector<int> > > dp(h, vector<vector<int> >(w, vector<int>(1<<8, -1)));\n        dp[sy][sx][0] = 0;\n        int ret = 0;\n        for(int t=0; t<100; ++t){\n            vector<vector<vector<int> > > next(h, vector<vector<int> >(w, vector<int>(1<<8, -1)));\n            for(int y=0; y<h; ++y){\n                for(int x=0; x<w; ++x){\n                    for(int i=0; i<(1<<8); ++i){\n                        if(dp[y][x][i] == -1)\n                            continue;\n\n                        for(int j=0; j<(1<<4); ++j){\n                            bitset<8> bs(i);\n                            bitset<4> select(j);\n\n                            int add = 0;\n                            for(int k=0; k<4; ++k){\n                                int y2 = y + dy[k];\n                                int x2 = x + dx[k];\n                                if(y2 < 0 || y2 >= h || x2 < 0 || x2 >= w)\n                                    continue;\n                                if(select[k] && '0' <= grid[y2][x2] && grid[y2][x2] <= '9' && !bs[grid[y2][x2]-'0']){\n                                    bs[grid[y2][x2]-'0'] = true;\n                                    add += sale[grid[y2][x2]-'0'][t];\n                                }\n                            }\n\n                            for(int k=0; k<4; ++k){\n                                int y2 = y + dy[k];\n                                int x2 = x + dx[k];\n                                if(y2 < 0 || y2 >= h || x2 < 0 || x2 >= w)\n                                    continue;\n                                if(grid[y2][x2] == '.'){\n                                    next[y2][x2][bs.to_ulong()] = max(next[y2][x2][bs.to_ulong()], dp[y][x][i] + add);\n                                    ret = max(ret, next[y2][x2][bs.to_ulong()]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            dp.swap(next);\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvc grid(h,vc(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>grid[i][j];\n\t\tint n; cin>>n;\n\t\tvi gs(n),ds(n),ss(n),es(n);\n\t\trep(i,n)\n\t\t\tcin>>gs[i]>>ds[i]>>ss[i]>>es[i];\n\t\t\n\t\trep(i,h) rep(j,w){\n\t\t\tif(!isdigit(grid[i][j]))\n\t\t\t\tcontinue;\n\t\t\tgrid[i][j]=find(all(gs),grid[i][j]-'0')-gs.begin()+'0';\n\t\t}\n\t\t\n\t\tstatic bool dp[101][20][20][1<<10]; // [t][i][j][bit]\n\t\tmemset(dp,0,sizeof dp);\n\t\t\n\t\trep(i,h) rep(j,w)\n\t\t\tif(grid[i][j]=='P'){\n\t\t\t\tdp[0][i][j][0]=1;\n\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\n\t\trep(t,100) rep(i,h) rep(j,w) rep(k,1<<n){\n\t\t\tif(dp[t][i][j][k]==0)\n\t\t\t\tcontinue;\n\t\t\trep(_,4){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[_],nj=j+\"\\0\\0\\xff\\x1\"[_];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(isdigit(grid[ni][nj])){\n\t\t\t\t\tint item=grid[ni][nj]-'0';\n\t\t\t\t\tif(ss[item]<=t && t<es[item])\n\t\t\t\t\t\tdp[t][i][j][k|1<<grid[ni][nj]-'0']=1;\n\t\t\t\t}\n\t\t\t\tif(grid[ni][nj]=='.')\n\t\t\t\t\tdp[t+1][ni][nj][k]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi ps(1<<n);\n\t\trep(i,1<<n) rep(j,n)\n\t\t\tif(i&1<<j)\n\t\t\t\tps[i]+=ds[j];\n\t\t\n\t\tint res=0;\n\t\trep(i,h) rep(j,w) rep(k,1<<n){\n\t\t\tif(dp[100][i][j][k])\n\t\t\t\tres=max(res,ps[k]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n     \nint w, h, n;  \nchar mas[20][20];  \n     \ntypedef pair< int , int > Pi;  \ntypedef pair< Pi , Pi > Piii;  \nPi p;  \n     \nstruct sell{  \n  int d; //値引き額  \n  int s; //開始時刻  \n  int e; //終了時刻  \n};  \nsell shop[10];  \n     \nint min_cost[20][20][1 << 10];  \n     \nint bfs(){  \n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)  \n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};  \n     \n  memset( min_cost, -1, sizeof(min_cost));  \n  que.push( Piii( Pi( 0, 0), p));  \n  min_cost[p.second][p.first][0] = 0;  \n     \n  int ret = 0;  \n     \n  while(!que.empty()){  \n     \n    Piii p = que.front(); que.pop();  \n     \n    Pi point = p.second;  \n    int bit = p.first.first, time = p.first.second;  \n     \n         \n    if(ret < min_cost[point.second][point.first][bit]){  \n      ret = min_cost[point.second][point.first][bit];  \n    }  \n     \n    for(int i = 0; i < 4; i++){  \n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;  \n     \n      if(isdigit(mas[ny][nx])){  \n             \n        int time_sell = mas[ny][nx] - '0';  \n     \n        if(!((bit >> time_sell) & 1)){  \n               \n          sell se = shop[time_sell];  \n     \n          if(time < se.e){ //時間内だったら買ってみる  \n            int next_bit = bit | (1 << time_sell);  \n            if(min_cost[point.second][point.first][bit] + se.d > min_cost[point.second][point.first][next_bit]){  \n              que.push( Piii( Pi( next_bit, max( time, se.s)), point));  \n              min_cost[point.second][point.first][next_bit] = min_cost[point.second][point.first][bit] + se.d;  \n            }  \n          }  \n        }\n     \n      } else {  \n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){  \n          que.push( Piii( Pi( bit, time + 1), Pi( nx, ny)));  \n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];  \n        }  \n      }  \n    }  \n  }  \n  return ret;  \n}  \n     \nint main(){  \n  while(cin >> w >> h, w){  \n    for(int i = 0; i < h; i++){  \n      for(int j = 0; j < w; j++){  \n        cin >> mas[i][j];  \n        if(mas[i][j] == 'P') p = Pi( j, i);  \n      }  \n    }  \n    cin >> n;  \n     \n    for(int i= 0; i < n; i++){  \n      int g;  \n      cin >> g;  \n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;  \n    }  \n     \n    cout << bfs() << endl;  \n  }  \n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n     \nint w, h, n;  \nchar mas[20][20];  \nint change[10];\ntypedef pair< int , int > Pi;  \ntypedef pair< Pi , Pi > Piii;\ntypedef pair< Piii, int > Piiii;\nPi p;  \n     \nstruct sell{  \n  int d; //値引き額  \n  int s; //開始時刻  \n  int e; //終了時刻  \n};  \nsell shop[10];  \n     \nint min_cost[20][20][1 << 10];\n     \nint bfs(){  \n  priority_queue< Piiii, vector< Piiii >, greater< Piiii > > que; // Pii( (買った商品, 今の時間), 座標)  \n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};  \n     \n  memset( min_cost, -1, sizeof(min_cost));  \n  que.push( Piiii( Piii( Pi( 0, 0), p), 0));  \n  min_cost[p.second][p.first][0] = 0;  \n     \n  int ret = 0;  \n     \n  while(!que.empty()){  \n     \n    Piiii p = que.top(); que.pop();  \n     \n    Pi point = p.first.second;  \n    int bit = p.first.first.second, time = p.first.first.first;\n    int cost = p.second;\n\n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n      if(!isdigit(mas[ny][nx])) continue;\n      int pos = change[mas[ny][nx] - '0'];\n      if(pos == -1) continue;\n      if(shop[pos].s <= time && time < shop[pos].e && !((bit >> pos) & 1)){\n        bit |= (1 << pos);\n        cost += shop[pos].d;\n      }\n    }\n    if(cost < min_cost[point.second][point.first][bit]){\n      continue;\n    }\n    min_cost[point.second][point.first][bit] = max( cost, min_cost[point.second][point.first][bit]);\n\n    \n    if(ret < min_cost[point.second][point.first][bit]){  \n      ret = min_cost[point.second][point.first][bit];  \n    }  \n     \n    for(int i = 0; i < 4; i++){  \n      int ny = point.second + dy[i], nx = point.first + dx[i];  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;  \n     \n      if(isdigit(mas[ny][nx])){  \n        int time_sell = change[mas[ny][nx] - '0'];\n        if(time_sell == -1) continue;\n        if(!((bit >> time_sell) & 1)){\n          sell se = shop[time_sell];\n          if(se.s > time){\n            que.push( Piiii( Piii( Pi( se.s, bit), point), cost));\n          }\n        }    \n      } else {  \n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){ \n          que.push( Piiii( Piii( Pi( time + 1, bit), Pi( nx, ny)), cost));  \n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];  \n        }  \n      }  \n    }  \n  }  \n  return ret;  \n}  \n     \nint main(){  \n  while(cin >> w >> h, w){  \n    for(int i = 0; i < h; i++){  \n      for(int j = 0; j < w; j++){  \n        cin >> mas[i][j];  \n        if(mas[i][j] == 'P') p = Pi( j, i);  \n      }  \n    }  \n    cin >> n;  \n    memset( change, -1, sizeof(change));\n    for(int i= 0; i < n; i++){  \n      int g;  \n      cin >> g;  \n      cin  >> shop[i].d >> shop[i].s >> shop[i].e;\n      change[i] = g;\n    }\n     \n    cout << bfs() << endl;  \n  }  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvc grid(h,vc(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>grid[i][j];\n\t\tint n; cin>>n;\n\t\tvi gs(n),ds(n),ss(n),es(n);\n\t\trep(i,n)\n\t\t\tcin>>gs[i]>>ds[i]>>ss[i]>>es[i];\n\t\t\n\t\trep(i,h) rep(j,w){\n\t\t\tif(!isdigit(grid[i][j]))\n\t\t\t\tcontinue;\n\t\t\tgrid[i][j]=find(all(gs),grid[i][j]-'0')-gs.begin()+'0';\n\t\t}\n\t\t\n\t\tstatic int dp[101][10][10][1<<10]; // [t][i][j][bit]\n\t\tmemset(dp,0,sizeof dp);\n\t\t\n\t\trep(i,h) rep(j,w)\n\t\t\tif(grid[i][j]=='P'){\n\t\t\t\tdp[0][i][j][0]=1;\n\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\n\t\trep(t,100) rep(i,h) rep(j,w) rep(k,1<<n){\n\t\t\tif(dp[t][i][j][k]==0)\n\t\t\t\tcontinue;\n\t\t\trep(_,4){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[_],nj=j+\"\\0\\0\\xff\\x1\"[_];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(isdigit(grid[ni][nj])){\n\t\t\t\t\tint item=grid[ni][nj]-'0';\n\t\t\t\t\tif(ss[item]<=t && t<es[item])\n\t\t\t\t\t\tdp[t][i][j][k|1<<grid[ni][nj]-'0']=1;\n\t\t\t\t}\n\t\t\t\tif(grid[ni][nj]=='.')\n\t\t\t\t\tdp[t+1][ni][nj][k]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi ps(1<<n);\n\t\trep(i,1<<n) rep(j,n)\n\t\t\tif(i&1<<j)\n\t\t\t\tps[i]+=ds[j];\n\t\t\n\t\tint res=0;\n\t\trep(i,h) rep(j,w) rep(k,1<<n){\n\t\t\tif(dp[100][i][j][k])\n\t\t\t\tres=max(res,ps[k]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nconst int NONE = -1;\n\nconst int DY[4] = {0, 1, 0, -1};\nconst int DX[4] = {1, 0, -1, 0};\n\nenum{TIME, Y, X, BOUGHT};\ntypedef tuple<int, int, int, unsigned long> Vertex;\n\nenum {GOODS, DISCOUNT, START, END};\ntypedef tuple<int, int, int, int> Sale;\n\nint h, w;\nint n;\nvector<vector<int>> m;\nvector<Sale> sale;\n\nint sum(unsigned long bought) {\n    int result = 0;\n    bitset<8> b(bought);\n    for(int i = 0; i < n; ++i) if(b[i]) result += get<DISCOUNT>(sale[i]);\n    return result;\n}\n\nint bfs(const Vertex& start) {\n    int result = 0;\n    vector<vector<vector<vector<int>>>> memo(101, vector<vector<vector<int>>>(h, vector<vector<int>>(w, vector<int>(1 << 8, -1))));\n    queue<Vertex> q;\n    q.push(start);\n\n    while(!q.empty()) {\n        int time = get<TIME>(q.front());\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        unsigned long bought = get<BOUGHT>(q.front());\n        q.pop();\n\n        if(time > 100) break;\n        int cost = sum(bought);\n        if(memo[time][y][x][bought] >= cost) continue;\n        memo[time][y][x][bought] = cost;\n        result = max(result, cost);\n\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(m[ny][nx] == NONE) continue;\n            if(bought & (1 << m[ny][nx])) continue;\n            for(int i = 0; i < n; ++i) {\n                if(get<GOODS>(sale[i]) != m[ny][nx]) continue;\n                if(time < get<START>(sale[i]) || get<END>(sale[i]) <= time) continue;\n                bought |= 1 << i;\n            }\n        }\n\n        time += 1;\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(m[ny][nx] != NONE) continue;\n            q.push(Vertex(time, ny, nx, bought));\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        Vertex start;\n        m = vector<vector<int>>(h, vector<int>(w, NONE));\n        for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '.') continue;\n            else if(c == 'P') start = Vertex(0, i, j, 0);\n            else m[i][j] = c - '0';\n        }\n\n        sale.clear();\n        cin >> n;\n        for(int i = 0; i < n; ++i) {\n            int g, d, s, e;\n            cin >> g >> d >> s >> e;\n            sale.push_back(Sale(g, d, s, e));\n        }\n\n        cout << bfs(start) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint dx[] = {0, 0, 0, +1, -1};\nint dy[] = {0, +1, -1, 0, 0};\n\nstruct Type\n{\n  int value, start, end;\n  Type(int value = 0, int start = 0, int end = 0) : value(value), start(start), end(end) {}\n};\n\nint H, W, N;\nType types[8];\nmap<char, int> table;\nchar board[20][20];\nint memo[20][20][101][1 << 8];\n\nint rec(int x, int y, int t, int used)\n{\n\tif(t == 101) return 0;\n\tif(used + 1 == 1 << N) return 0;\n\tif(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\t\n\tint res = 0;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\n\t\tif(0 <= nx && nx < W && 0 <= ny && ny <H)\n\t\t{\n\t\t\tchar data = board[nx][ny];\n\t\t\t\n\t\t\tif('0' <= data && data <= '9')\n\t\t\t{\n\t\t\t\tint idx = table[data];\n\t\t\t\tint s = types[idx].start;\n\t\t\t\tint e = types[idx].end;\n\t\t\t\t\n\t\t\t\tif(s <= t && t < e && (used & 1 << idx) == 0)\n\t\t\t\t\tres = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t\t}\n\t\t\telse res = max(res, rec(nx, ny, t + 1, used));\n\t\t}\n\t}\n\t\n\treturn memo[x][y][t][used] = res;\n}\t\n\nint solve()\n{\n\tmemset(memo, -1, sizeof memo);\n\t\n\tint X, Y;\n\t\n\tfor(int y = 0; y < H; y++)\n\t{\n\t\tfor(int x = 0; x < W; x++)\n\t\t{\n\t\t\tchar k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\tboard[x][y] = k;\n\t\t\t\n\t\t\tif(board[x][y] == 'P')\n\t\t\t{\n\t\t\t\tX = x;\n\t\t\t\tY = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tchar c;\n\t\tcin >> c >> types[i].value >> types[i].start >> types[i].end;\n\t\t\n\t\ttable[c] = i;\n\t}\n\t\n\treturn rec(X, Y, 0, 0);\n}\n\nint main()\n{\n  for(; cin >> W >> H && W;)\n  \tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, s, t) for (int i = (int)(s); i <= (int)(t); i++)\n#define rep(i, n) Rep(i, 0, (n) - 1)\nconst int INF = 1 << 26;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint h, w;\nint sx, sy;\nchar grid[22][22];\nint sale[10][100];\nint dp[101][22][22][1 << 10];\nvector<int> salev;\nint toid[10];\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\tfill_n(*sale, 10 * 100, -INF);\n\t\tfill_n(*grid, 22 * 22, '\\0');\n\t\tfill_n(toid, 10, -1);\n\t\tsalev.clear();\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'P'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint g, d, s, e;\n\t\t\tscanf(\"%d %d %d %d\", &g, &d, &s, &e);\n\t\t\tfor (int j = s; j < e; j++){\n\t\t\t\tsale[g][j] = max(sale[g][j], d);\n\t\t\t}\n\t\t\tsalev.push_back(g);\n\t\t}\n\t\t\n\t\tsort(salev.begin(), salev.end());\n\t\tsalev.erase(unique(salev.begin(), salev.end()), salev.end());\n\t\t\n\t\tfor (int i = 0; i < salev.size(); i++){\n\t\t\ttoid[salev[i]] = i;\n\t\t}\n\t\t\n\t\tfill_n(***dp, 101 * 22 * 22 * (1 << 10), -INF);\n\t\tdp[0][sx][sy][0] = 0;\n\t\trep (t, 100) Rep (x, 1, h) Rep (y, 1, w){\n\t\t\trep (got, 1 << salev.size()){\n\t\t\t\tif (dp[t][x][y][got] == -INF) continue;\n\t\t\t\tif (grid[x][y] != '.') continue;\n\t\t\t\t//if (dp[t][x][y][got] > 0) printf(\"%d\\n\", dp[t][x][y][got]);\n\t\t\t\t//printf(\"%d %d %d %d\\n\", t, x, y, got);\n\t\t\t\t//dp[t + 1][x][y][got] = max(dp[t + 1][x][y][got], dp[t][x][y][got]);\n\t\t\t\trep (dir, 4){\n\t\t\t\t\tint nx = x + dx[dir];\n\t\t\t\t\tint ny = y + dy[dir];\n\t\t\t\t\tif (grid[nx][ny] >= '0' && grid[nx][ny] <= '9'){\n\t\t\t\t\t\tint g = grid[nx][ny] - '0';\n\t\t\t\t\t\tint id = toid[g];\n\t\t\t\t\t\tif (id != -1 && !(got & (1 << id))){\n\t\t\t\t\t\t\tdp[t][x][y][got | (1 << id)] = max(\n\t\t\t\t\t\t\t\tdp[t][x][y][got | (1 << id)],\n\t\t\t\t\t\t\t\tdp[t][x][y][got] + sale[g][t]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[t + 1][nx][ny][got] = max(\n\t\t\t\t\t\tdp[t + 1][nx][ny][got],\n\t\t\t\t\t\tdp[t][x][y][got]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\trep (t, 100) Rep (x, 1, h) Rep(y, 1, w) rep(st, 1 << salev.size()){\n\t\t\tres = max(res, dp[t][x][y][st]);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tis_sale[number[g]] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\t//printf(\"row:%d col:%d time:%d state:%d\\n\",Q.top().row,Q.top().col,Q.top().time,Q.top().state);\n\n\t\t\t\t\tint adj_item = number[base_map[adj_row][adj_col]-'0'];\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){ //??????\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \nint w, h, n;\nchar mas[20][20];\n  \ntypedef pair< int , int > Pi;\ntypedef pair< Pi , Pi > Piii;\nPi p;\n  \nstruct sell{\n  int d; //値引き額\n  int s; //開始時刻\n  int e; //終了時刻\n};\nsell shop[10];\n  \nint min_cost[20][20][1 << 10];\n  \nint bfs(){\n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)\n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n  \n  memset( min_cost, -1, sizeof(min_cost));\n  que.push( Piii( Pi( 0, 0), p));\n  min_cost[p.second][p.first][0] = 0;\n  \n  int ret = 0;\n  \n  while(!que.empty()){\n  \n    Piii p = que.front(); que.pop();\n  \n    Pi point = p.second;\n    int bit = p.first.first, time = p.first.second;\n  \n      \n    if(ret < min_cost[point.second][point.first][bit]){\n      ret = min_cost[point.second][point.first][bit];\n    }\n  \n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n  \n      int next_time = time + 1;\n  \n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n  \n      if(isdigit(mas[ny][nx])){\n          \n        int time_sell = mas[ny][nx] - '0';\n  \n        if(!((bit >> time_sell) & 1)){\n            \n          sell se = shop[time_sell];\n  \n          if(se.s > next_time){ //待ってプッシュ\n  \n            que.push( Piii( Pi( bit, se.s), point));\n  \n          } else if(se.s <= next_time && next_time <= se.e){ //時間内だったら買ってみる\n  \n            int next_bit = bit | (1 << time_sell);\n            if(min_cost[point.second][point.first][bit] + se.d > min_cost[point.second][point.first][next_bit]){\n              que.push( Piii( Pi( next_bit, next_time - 1), point));\n              min_cost[point.second][point.first][next_bit] = min_cost[point.second][point.first][bit] + se.d;\n            }\n          }\n        }\n  \n      } else {\n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){\n          que.push( Piii( Pi( bit, next_time), Pi( nx, ny)));\n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];\n        }\n      }\n    }\n  }\n  return ret;\n}\n  \nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') p = Pi( j, i);\n      }\n    }\n    cin >> n;\n  \n    for(int i= 0; i < n; i++){\n      int g;\n      cin >> g;\n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;\n    }\n  \n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<string> grid(h, string(w, '0'));\n        int sy, sx;\n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                cin >> grid[y][x];\n                if(grid[y][x] == 'P'){\n                    sy = y;\n                    sx = x;\n                    grid[y][x] = '.';\n                }\n            }\n        }\n\n        int n;\n        cin >> n;\n        int tmp = 0;\n        vector<int> change(10, -1);\n        vector<vector<int> > sale(8, vector<int>(100, 0));\n        for(int i=0; i<n; ++i){\n            int g, d, s, e;\n            cin >> g >> d >> s >> e;\n            if(change[g] == -1){\n                change[g] = tmp;\n                g = tmp;\n                ++ tmp;\n            }\n            for(int j=s; j<e; ++j)\n                sale[g][j] = d;\n        }\n        \n        for(int y=0; y<h; ++y){\n            for(int x=0; x<w; ++x){\n                if(grid[y][x] != '.'){\n                    if(change[grid[y][x]-'0'] == -1)\n                        grid[y][x] = '#';\n                    else\n                        grid[y][x] = change[grid[y][x]-'0'] + '0';\n                }\n            }\n        }\n\n        vector<vector<vector<int> > > dp(h, vector<vector<int> >(w, vector<int>(1<<8, -1)));\n        dp[sy][sx][0] = 0;\n        int ret = 0;\n        for(int t=0; t<100; ++t){\n            vector<vector<vector<int> > > next(h, vector<vector<int> >(w, vector<int>(1<<8, -1)));\n            for(int y=0; y<h; ++y){\n                for(int x=0; x<w; ++x){\n                    for(int i=0; i<(1<<8); ++i){\n                        if(dp[y][x][i] == -1)\n                            continue;\n\n                        bitset<8> bs(i);\n                        int add = 0;\n                        for(int j=0; j<4; ++j){\n                            int y2 = y + dy[j];\n                            int x2 = x + dx[j];\n                            if(y2 < 0 || y2 >= h || x2 < 0 || x2 >= w)\n                                continue;\n                            if(isdigit(grid[y2][x2]) && !bs[grid[y2][x2]-'0'] && sale[grid[y2][x2]-'0'][t] > 0){\n                                bs[grid[y2][x2]-'0'] = true;\n                                add += sale[grid[y2][x2]-'0'][t];\n                            }\n                        }\n\n                        for(int j=0; j<4; ++j){\n                            int y2 = y + dy[j];\n                            int x2 = x + dx[j];\n                            if(y2 < 0 || y2 >= h || x2 < 0 || x2 >= w)\n                                continue;\n                            if(grid[y2][x2] == '.'){\n                                next[y2][x2][bs.to_ulong()] = max(next[y2][x2][bs.to_ulong()], dp[y][x][i] + add);\n                                ret = max(ret, next[y2][x2][bs.to_ulong()]);\n                            }\n                        }\n                    }\n                }\n            }\n            dp.swap(next);\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nint x, y, dp[10][21][21][1 << 10];\nint g[10], d[10], s[10], e[10], n;\nchar c[21][21];\nint sale[10][105];\nint main(){\n    while(cin >> x >> y, x | y){\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++)\n\t\tfor(int k = 0;k < (1 << 8);k++)\n\t\t    dp[0][i][j][k] = -INF;\n\tfor(int i = 0;i < y;i++){\n\t    for(int j = 0;j < x;j++){\n\t\tcin >> c[i][j];\n\t\tif(c[i][j] == 'P'){\n\t\t    c[i][j] = '.';\n\t\t    dp[0][i][j][0] = 0;\n\t\t}\n\t    }\n\t}\n\tcin >> n;\n\tint used[10];\n\tfill(used, used + 10, 0);\n\tfor(int i = 0;i < 10;i++)\n\t    for(int j = 0;j < 105;j++)\n\t\tsale[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> g[i] >> d[i] >> s[i] >> e[i];\n\t    used[g[i]] = 1;\n\t}\n\tfor(int i = 1;i < 10;i++)used[i] += used[i - 1];\n\tfor(int i = 0;i < n;i++){\n\t    for(int j = s[i];j <= e[i];j++)\n\t\tsale[used[g[i]] - 1][j] = d[i];\n\t}\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++){\n\t\tif(c[i][j] != '.')c[i][j] = '0' + used[c[i][j] - '0'] - 1;\n\t    }\n\tint ans = 0;\n\tfor(int i = 0;i <= 100;i++){\n\t    for(int j = 0;j < y;j++){\n\t\tfor(int k = 0;k < x;k++){\n\t\t    if(c[j][k] != '.')continue;\n\t\t    int there = 0;\n\t\t    for(int l = 0;l < (1 << 8);l++){\n\t\t\tif(i){\n\t\t\t    dp[i & 1][j][k][l] = -INF;\n\t\t\t    for(int m = 0;m < 4;m++){\n\t\t\t\tint ty = j + ys[m], tx = k + xs[m];\n\t\t\t\tif(ty < 0 || ty >= y || tx < 0 || tx >= x)continue;\n\t\t\t\tif(c[ty][tx] == '.')\n\t\t\t\t    dp[i & 1][j][k][l] = max(dp[(i + 1) & 1][ty][tx][l], dp[i & 1][j][k][l]);\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int m = 0;m < 4;m++){\n\t\t\t    int ty = j + ys[m], tx = k + xs[m];\n\t\t\t    if(ty < 0 || ty >= y || tx < 0 || tx >= x)continue;\n\t\t\t    if(c[ty][tx] == '.')continue;\n\t\t\t    int pr = c[ty][tx] - '0';\n\t\t\t    if(l & (1 << pr)){\n\t\t\t\tdp[i & 1][j][k][l] = max(dp[i & 1][j][k][l], dp[i & 1][j][k][l - (1 << pr)] + sale[pr][i]);\n\t\t\t    }\n\t\t\t}\n\t\t\tans = max(dp[i & 1][j][k][l], ans);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20][101];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tv[temp.bit][temp.ty][temp.tx][temp.time] = true;\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx][temp.time + 1] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tv[temp.bit][my][mx][temp.time + 1] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t\telse if (map[my][mx] != -1 && v[temp.bit][my][mx][temp.time] == false && !((temp.bit >> map[my][mx]) & 1) && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= 1 << map[my][mx];\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tv[temp.bit][my][mx][temp.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(p.t>=100)continue;\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h,w,n,g[8],d[8],s[8],e[8];\nint v[8][101];\nchar m[20][20];\nint num,sy,sx;\nint c[20][20][101][1<<8];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  while(cin >> w >> h,w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin >> m[i][j];\n\tif(m[i][j] == 'P'){\n\t  sy = i; sx = j;\n\t}\n      }\n\n    cin >> n;\n    map<int,int> b;\n    for(int i=0;i<n;i++){\n      cin >> g[i] >> d[i] >> s[i] >> e[i];\n      if(b.find(g[i]) == b.end())b[g[i]] = (int)b.size()-1;\n    }\n    num = b.size();\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=100;j++)v[i][j] = 0;\n    for(int i=0;i<n;i++)\n      for(int j=s[i];j<e[i];j++)v[b[g[i]]][j] += d[i];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<=100;k++)\n\t  for(int l=0;l<(1<<num);l++)c[i][j][k][l] = -1;\n    c[sy][sx][0][0] = 0;\n\n    for(int k=0;k<100;k++){\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  for(int l=0;l<(1<<num);l++){\n\t    if(c[i][j][k][l]<0)continue;\n\t    for(int dir=0;dir<4;dir++){\n\t      int ty = i+dy[dir], tx = j+dx[dir];\n\t      if(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n\n\t      if('0'<=m[ty][tx] && m[ty][tx]<='9'){\n\t\tint x = b[m[ty][tx]-'0'];\n\t\tif((l>>x)&1)continue;\n\t\tif(!v[x][k])continue;\n\t\tint ts = l|(1<<x);\n\t\tc[i][j][k][ts] = max(c[i][j][k][ts],c[i][j][k][l]+v[x][k]);\n\t      }else c[ty][tx][k+1][l] = max(c[ty][tx][k+1][l],c[i][j][k][l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<(1<<num);k++)ans = max(ans,c[i][j][100][k]);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data {\n  int cur,time,bitmask,score;\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint maxi[20*20][1<<8],info[30][30][110];\nint w,h,sp,n,g[10],d[10],s[10],e[10],limit,trans[10];\nchar field[30][30];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nint getDiff(int bits1,int bits2){\n  int ret = 0;\n  int diff = bits1 ^ bits2;\n  diff = diff & bits2;\n  while( diff ){\n    int here = diff & -diff;\n    diff -= here;\n    int pos = log2(here);\n    ret += d[trans[pos]];\n  }\n  return ret;\n}\n\nvoid compute(){\n  rep(tm,limit) {\n    rep(i,h) rep(j,w) {\n      info[i][j][tm] = 0;\n      rep(k,4) {\n        int nx = j + dx[k], ny = i + dy[k];\n        if( !isValid(nx,ny) ) continue;\n        if( field[ny][nx] == '.' ) continue;\n        int index = field[ny][nx] - '0';\n        if( s[index] <= tm && tm < e[index] ) {\n          info[i][j][tm] |= (1<<(field[ny][nx]-'0'));\n        }\n      }\n    }\n  }\n\n  deque<Data> deq;\n  rep(i,h*w) rep(j,(1<<n)) maxi[i][j] = -1;\n  deq.push_back((Data){sp,0,0,0});\n  int answer = 0;\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    if( maxi[data.cur][data.bitmask] > data.score ) continue;\n    int x = data.cur % w, y = data.cur / w;\n    rep(i,4){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( !isValid(nx,ny) ) continue;\n      if( field[ny][nx] != '.' ) continue;\n      if( data.time + 1 >= limit ) continue;\n      int ntime = data.time + 1;\n      int nbitmask = data.bitmask | info[ny][nx][ntime];\n      int nscore = data.score + getDiff(data.bitmask,info[ny][nx][ntime]);\n      if( maxi[nx+ny*w][nbitmask] < nscore ) {\n        maxi[nx+ny*w][nbitmask] = nscore;\n        answer = max(answer,nscore);\n        deq.push_back((Data){nx+ny*w,ntime,nbitmask,nscore});\n      }\n    }\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  while( cin >> w >> h, w|h ){\n    rep(i,h) rep(j,w) {\n      cin >> field[i][j];\n      if( field[i][j] == 'P' ) {\n        field[i][j] = '.';\n        sp = j + i * w;\n      }\n    }\n    limit = 0;\n    cin >> n;\n    rep(i,n) {\n      cin >> g[i] >> d[i] >> s[i] >> e[i];\n      trans[g[i]] = i;\n      limit = max(limit,e[i]);\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint dx[] = {0, 0, 0, +1, -1};\nint dy[] = {0, +1, -1, 0, 0};\n\nstruct Type\n{\n  int value, start, end;\n  Type(int value = 0, int start = 0, int end = 0) : value(value), start(start), end(end) {}\n};\n\nint H, W, N;\nType types[8];\nmap<char, int> table;\nchar board[20][20];\nint memo[20][20][101][1 << 8];\n\nint rec(int x, int y, int t, int used)\n{\n\tif(t == 101) return 0;\n\tif(used + 1 == 1 << N) return 0;\n\tif(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\t\n\tint res = 0;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\n\t\tif(0 <= nx && nx < W && 0 <= ny && ny <H)\n\t\t{\n\t\t\tchar data = board[nx][ny];\n\t\t\t\n\t\t\tif('0' <= data && data <= '9')\n\t\t\t{\n\t\t\t\tint idx = table[data];\n\t\t\t\tint s = types[idx].start;\n\t\t\t\tint e = types[idx].end;\n\t\t\t\t\n\t\t\t\tif(s <= t && t < e && (used & 1 << idx) == 0)\n\t\t\t\t\tres = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t\t}\n\t\t\telse res = max(res, rec(nx, ny, t + 1, used));\n\t\t}\n\t}\n\t\n\treturn memo[x][y][t][used] = res;\n}\t\n\nint solve()\n{\n\tmemset(memo, -1, sizeof memo);\n\t\n\tint X, Y;\n\t\n\tfor(int y = 0; y < H; y++)\n\t{\n\t\tfor(int x = 0; x < W; x++)\n\t\t{\n\t\t\tchar k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\tboard[x][y] = k;\n\t\t\t\n\t\t\tif(board[x][y] == 'P')\n\t\t\t{\n\t\t\t\tX = x;\n\t\t\t\tY = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tchar c;\n\t\tcin >> c >> types[i].value >> types[i].start >> types[i].end;\n\t\t\n\t\ttable[c] = i;\n\t}\n\t\n\treturn rec(X, Y, 0, 0);\n}\n\nint main()\n{\n  for(; cin >> W >> H && W;)\n  \tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[21][21];\nint dp[2][1 << 8][21][21];\nint good[21][21];\nInfo info[10];\nint X, Y, N, SX, SY, E;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 21; k++) {\n        for (int l = 0; l < 21; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E - 1; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = (E - 1) % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (field[i][j] - '0'));\n          }\n        }\n      }\n    }\n    //    print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[g] = Info(d, s, e);\n      E = max(e, E);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[21][21];\nint dp[2][1 << 8][21][21];\nint good[21][21];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 21; i++) {\n    for (int j = 0; j < 21; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 21; k++) {\n        for (int l = 0; l < 21; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  dp[0][0][SY][SX] = 0;\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time &&\n                    time < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              dp[next][state | s][ny][nx] =\n                max(dp[next][state | s][ny][nx], v + t);\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      for(int k=0;k<(1<<10);k++){\n        vis[i][j][k] = false;\n      }\n    }\n  }\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(vis[ny][nx][u.used]) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          v.y = u.y;\n          v.x = u.x;\n          v.used = u.used | (1<<num);\n          v.t = max(u.t, data[num].s);\n          v.sum = u.sum + data[num].d;\n          res = max(res, v.sum);\n          if(!vis[v.y][v.x][v.used] && 1){\n            vis[v.y][v.x][v.used] = true;\n            q.push(v);\n          }\n        }\n      }else{\n        if(!vis[ny][nx][u.used] && 1){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n   int g, d, s, e;\n   S(){}\n   S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n   int y, x, used, t;\n   State(){}\n   State(int y, int x, int used, int t) : y(y), x(x), used(used), t(t) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n   bool vis[20][20][1<<8];\n   fill(vis[0][0], vis[20][0], false);\n   State u, v;\n   u = State(sy, sx, 0, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.y][u.x][u.used] = true;\n   while(!q.empty()){\n      u = q.front(); q.pop();\n      //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.'){\n            int num = conv[mapData[ny][nx] - '0'];\n            if(u.t < data[num].e && !((1 << num) & u.used)){\n               v.y = u.y;\n               v.x = u.x;\n               v.used = u.used | (1<<num);\n               v.t = max(u.t, data[num].s);\n               if(!vis[v.y][v.x][v.used]){\n                  vis[v.y][v.x][v.used] = true;\n                  q.push(v);\n               }\n            }\n         }\n      }\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.') continue;\n         if(!vis[ny][nx][u.used]){\n            vis[ny][nx][u.used] = true;\n            q.push(State(ny, nx, u.used, u.t+1));\n         }\n      }\n   }\n   int res = 0;\n   for(int k=0;k<(1<<8);k++){\n      bool f = false;\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            if(vis[i][j][k]){\n               f = true;\n               goto END;\n            }\n         }\n      }\n     END:;\n      if(f){\n         int sum = 0;\n         for(int i=0;i<8;i++){\n            if((1<<i) & k) sum += data[i].d;\n         }\n         res = max(res, sum);\n      }\n   }\n   return res;\n}\n\nmain(){\n   while(cin >> w >> h && (w|h)){\n      conv.clear();\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            cin >> mapData[i][j];\n            if(mapData[i][j] == 'P'){\n               mapData[i][j] = '.';\n               sy = i;\n               sx = j;\n            }\n         }\n      }\n      cin >> n;\n      for(int i=0;i<n;i++){\n         int a, b, c, d;\n         cin >> a >> b >> c >> d;\n         data[i] = S(a, b, c, d);\n         conv[a] = i;\n      }\n      cout << bfs() << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <cstring>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nint st[32][32];\nint dp[32][32][1 << 8];\nint memo[1 << 8];\n\nconst int _dx[] = {0,0,1,0,-1};\nconst int _dy[] = {0,-1,0,1,0};\n\nint main(){\n  while(true){\n    const int w = getInt();\n    const int h = getInt();\n\n    if(w + h == 0) break;\n\n    int sx, sy;\n\n    REP(i,h) REP(j,w){\n      char c[2];\n      scanf(\"%s\", c);\n      if(c[0] == '.'){\n        st[i][j] = -1;\n      }else if(c[0] == 'P'){\n        st[i][j] = -1;\n        sx = j; sy = i;\n      }else{\n        st[i][j] = c[0] - '0';\n      }\n    }\n\n    const int n = getInt();\n\n    vector<int> g(n);\n    vector<int> d(n);\n    vector<int> s(n);\n    vector<int> e(n);\n\n    REP(i,n){\n      g[i] = getInt();\n      d[i] = getInt();\n      s[i] = getInt();\n      e[i] = getInt();\n    }\n\n    REP(i,h) REP(j,w) if(st[i][j] != -1){\n      REP(k,n) if(st[i][j] == g[k]){\n        st[i][j] = k;\n        break;\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    REP(i,1 << n){\n      memo[i] = 0;\n      REP(j,n) if(i & (1 << j))\n        memo[i] += d[j];\n    }\n\n    int sp = 0;\n    REP(i,5){\n      const int xx = sx + _dx[i];\n      const int yy = sy + _dy[i];\n      if(ISIN(xx, yy, w, h) && st[yy][xx] != -1){\n        const int p = st[yy][xx];\n        if(IN(0, s[p], e[p])){\n          sp |= (1 << p);\n        }\n      }\n    }\n\n    queue<pair<int, pair<int, int> > > q;\n    dp[sy][sx][sp] = 0;\n    q.push(make_pair(sp, make_pair(sx, sy)));\n\n    while(q.size()){\n      const pair<int, pair<int, int> > d = q.front(); q.pop();\n      const int f = d.first;\n      const int x = d.second.first;\n      const int y = d.second.second;\n      const int t = dp[y][x][f] + 1;\n\n      if(t == 100) continue;\n\n      REP(i,5){\n        const int xx = x + _dx[i];\n        const int yy = y + _dy[i];\n\n        if(ISIN(xx, yy, w, h) && st[yy][xx] == -1){\n          int ff = f;\n          REP(j,5){\n            const int xxx = xx + _dx[j];\n            const int yyy = yy + _dy[j];\n\n            if(ISIN(xxx, yyy, w, h) && st[yyy][xxx] != -1){\n              const int p = st[yyy][xxx];\n              if(IN(t, s[p], e[p])){\n                ff |= (1 << p);\n              }\n            }\n          }\n\n          if(dp[yy][xx][ff] == -1 || i == 0){\n            dp[yy][xx][ff] = t;\n            q.push(make_pair(ff, make_pair(xx, yy)));\n          }\n        }\n      }\n    }\n\n    int ans = 0;\n    REP(i,h) REP(j,w) REP(k,1<<n)\n      if(dp[i][j][k] != -1)\n        ans = max(ans, memo[k]);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V,ADJ_V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[8];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10],dist[20][20][20][20];\nint dp[256][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[number[buf[0]-'0']].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e,TIME_MAX = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tTIME_MAX = max(TIME_MAX,e);\n\t}\n\n\tfor(int i = 0; i < item_num; i++){\n\n\t\tfor(int k = 0; k < info[i].V.size(); k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\n\t\t\t\tint adj_row = info[i].V[k].row + diff_row[p];\n\t\t\t\tint adj_col = info[i].V[k].col + diff_col[p];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\n\t\t\t\tinfo[i].ADJ_V.push_back(Cell(adj_row,adj_col));\n\t\t\t}\n\t\t}\n\n\t\tif(info[i].ADJ_V.size() == 0)continue;\n\n\t\tsort(info[i].ADJ_V.begin(),info[i].ADJ_V.end());\n\n\t\tvector<Cell> tmp_adj;\n\n\t\tint pre_row = info[i].ADJ_V[0].row;\n\t\tint pre_col = info[i].ADJ_V[0].col;\n\n\t\ttmp_adj.push_back(info[i].ADJ_V[0]);\n\n\t\tfor(int a = 1; a < info[i].ADJ_V.size(); a++){\n\t\t\tif(pre_row != info[i].ADJ_V[a].row || pre_col != info[i].ADJ_V[a].col){\n\t\t\t\ttmp_adj.push_back(info[i].ADJ_V[a]);\n\t\t\t}\n\t\t\tpre_row = info[i].ADJ_V[a].row;\n\t\t\tpre_col = info[i].ADJ_V[a].col;\n\t\t}\n\n\t\tinfo[i].ADJ_V.clear();\n\n\t\tfor(int a = 0; a < tmp_adj.size(); a++){\n\t\t\tinfo[i].ADJ_V.push_back(tmp_adj[a]);\n\t\t}\n\n\t\t//info[i].ADJ_V.erase(unique(info[i].ADJ_V.begin(),info[i].ADJ_V.end()),info[i].ADJ_V.end());\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < item_num; loop++){\n\t\t\t\tif(Q.top().visited[loop]){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tint next_item = loop;\n\t\t\t\t\tint next_state = Q.top().state + POW[next_item];\n\t\t\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\t\t\tfor(int k = 0; k < info[next_item].ADJ_V.size(); k++){\n\n\t\t\t\t\t\tadj_row = info[next_item].ADJ_V[k].row;\n\t\t\t\t\t\tadj_col = info[next_item].ADJ_V[k].col;\n\n\t\t\t\t\t\tnext_time = Q.top().time + dist[Q.top().row][Q.top().col][adj_row][adj_col];\n\t\t\t\t\t\tif(next_time > TIME_MAX)continue;\n\n\t\t\t\t\t\tif(next_time > info[next_item].end){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] > next_time){\n\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = next_time;\n\n\t\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tnext_sale.time = next_time;\n\t\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\t\tnext_sale.visited[next_item] = true;\n\n\t\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(next_time < info[next_item].start){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] > info[next_item].start){\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = info[next_item].start;\n\n\t\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tnext_sale.time = info[next_item].start;\n\t\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\t\tnext_sale.visited[next_item] = true;\n\n\t\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n   int g, d, s, e;\n   S(){}\n   S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n   int y, x, used, t, sum;\n   State(){}\n   State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n   bool vis[20][20][1<<10];\n   fill(vis[0][0], vis[20][0], false);\n   State u, v;\n   u = State(sy, sx, 0, 0, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.y][u.x][u.used] = true;\n   int res = 0;\n   while(!q.empty()){\n      u = q.front(); q.pop();\n      //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.'){\n            int num = conv[mapData[ny][nx] - '0'];\n            if(u.t < data[num].e && !((1 << num) & u.used)){\n               v = u;\n               v.used = u.used | (1<<num);\n               v.t = max(u.t, data[num].s);\n               v.sum = u.sum + data[num].d;\n               if(!vis[v.y][v.x][v.used]){\n                  res = max(res, v.sum);\n                  vis[v.y][v.x][v.used] = true;\n                  q.push(v);\n               }\n            }\n         }\n      }\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.') continue;\n         if(!vis[ny][nx][u.used]){\n            vis[ny][nx][u.used] = true;\n            q.push(State(ny, nx, u.used, u.t+1, u.sum));\n         }\n      }\n   }\n   /*int res = 0;\n   for(int k=0;k<(1<<n);k++){\n      for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(vis[i][j][k]) goto END;\n      continue;\n     END:;\n      int sum = 0;\n      for(int i=0;i<n;i++) if((1<<i) & k) sum += data[i].d;\n      res = max(res, sum);\n      }*/\n   return res;\n}\n\nmain(){\n   while(cin >> w >> h && (w|h)){\n      conv.clear();\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            cin >> mapData[i][j];\n            if(mapData[i][j] == 'P'){\n               mapData[i][j] = '.';\n               sy = i;\n               sx = j;\n            }\n         }\n      }\n      cin >> n;\n      for(int i=0;i<n;i++){\n         int a, b, c, d;\n         cin >> a >> b >> c >> d;\n         data[i] = S(a, b, c, d);\n         conv[a] = i;\n      }\n      cout << bfs() << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\ntypedef pair<int,pii> ppi;\nint used[1<<8][21][21];\nchar field[101][101];\nint T;\nint gs[101];\nint ds[101];\nint ss[101];\nint es[101];\nint ggs[101];\n\nvoid solve(){\n\tint W,H;\n\tint sy,sx;\n\twhile(cin>>W>>H&&(W|H)){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='P'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tcin>>gs[i];\n\t\t\tggs[gs[i]]=i;\n\t\t\tcin>>ds[i]>>ss[i]>>es[i];\n\t\t}\n\t\tqueue<ppi> q;\n\t\tint smask=0;\n\t\tint scost=0;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint ny=sy+dy[j];\n\t\t\tint nx=sx+dx[j];\n\t\t\tif(ny>=0&&nx>=0&&nx<W&&ny<H){\n\t\t\t\tint id=ggs[field[ny][nx]-'0'];\n\t\t\t\tif(field[ny][nx]!='.'&&ss[id]<=0&&es[id]>0){\n\t\t\t\t\tsmask|=(1<<id);\n\t\t\t\t\tscost+=ds[id];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push(make_pair(smask,pii(sy,sx)));\n\t\tmemset(used,-1,sizeof(used));\n\t\tused[0][sy][sx]=0;\n\t\twhile(q.size()){\n\t\t\tppi p=q.front();q.pop();\n\t\t\tint cmask=p.first;\n\t\t\tint cy=p.second.first;\n\t\t\tint cx=p.second.second;\n\t\t\tint ctime=used[cmask][cy][cx];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=cy+dy[i];\n\t\t\t\tint nx=cx+dx[i];\n\t\t\t\tint nmask=cmask;\n\t\t\t\tint ntime=ctime+1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='.'){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tint nny=ny+dy[j];\n\t\t\t\t\t\tint nnx=nx+dx[j];\n\t\t\t\t\t\tif(nny>=0&&nnx>=0&&nny<H&&nnx<W){\n\t\t\t\t\t\t\tint id=ggs[field[nny][nnx]-'0'];\n\t\t\t\t\t\t\tif(field[nny][nnx]!='.'&&ss[id]<=ntime&&es[id]>ntime&&!((nmask>>id)&1)){\n\t\t\t\t\t\t\t\tnmask|=(1<<id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(used[nmask][ny][nx]==-1){\n\t\t\t\t\t\tused[nmask][ny][nx]=ntime;\n\t\t\t\t\t\tq.push(make_pair(nmask,pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int mask=0;mask<(1<<T);mask++){\n\t\t\t\t\tif(used[mask][i][j]==-1)continue;\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tfor(int k=0;k<T;k++){\n\t\t\t\t\t\tif((mask>>k)&1){\n\t\t\t\t\t\t\tsum+=ds[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres=max(res,sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int d,get,y,x;\n    bool operator<(const State& right) const{\n        return d > right.d;\n    }\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,101);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        int d[(1<<10)][20][20];\n        for(int i=0;i<(1<<10);i++)for(int j=0;j<20;j++)for(int k=0;k<20;k++) d[i][j][k] = INF;\n        d[0][sy][sx] = 0;\n        priority_queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.top(); que.pop();\n            //printf(\"p.d=%d p.get=%d p.y=%d p.x=%d\\n\",p.d,p.get,p.y,p.x);\n            if(d[p.get][p.y][p.x]<p.d) continue;\n            ans = max(ans, de_sum[p.get]);\n            if(p.d==100)continue;\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                int nget = p.get, nd = p.d + 1;\n                for(int j=0;j<4;j++){\n                    int ny2 = ny + dy[j], nx2 = nx + dx[j];\n                    if(ny2<0||h<=ny2||nx2<0||w<=nx2||field[ny2][nx2]=='.') continue;\n                    int g_i = field[ny2][nx2] - '0';\n                    if(st_i[g_i] <= nd && nd < et_i[g_i]){\n                        nget |= (1<<g_i);\n                    }\n                }\n                if(d[nget][ny][nx]>nd){\n                    d[nget][ny][nx] = nd;\n                    que.push((State){nd, nget, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<algorithm>\n#include<bitset>\n#include<map>\nusing namespace std;\n\nconst int NONE = -1;\n\nconst int DY[4] = {0, 1, 0, -1};\nconst int DX[4] = {1, 0, -1, 0};\n\nenum{TIME, Y, X, BOUGHT};\ntypedef tuple<int, int, int, unsigned long> Vertex;\nenum{COST, VERTEX};\ntypedef tuple<int, Vertex> Node;\n\nenum {GOODS, DISCOUNT, START, END};\ntypedef tuple<int, int, int, int> Sale;\n\nint h, w;\nvector<vector<int>> m;\nvector<Sale> sale;\n\nint bfs(const Vertex& start) {\n    int result = 0;\n    map<Vertex, int> memo;\n    priority_queue<Node> q;\n//     queue<Node> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        int cost = get<COST>(q.top());\n        Vertex v = get<VERTEX>(q.top());\n//         int cost = get<COST>(q.front());\n//         Vertex v = get<VERTEX>(q.front());\n        int time = get<TIME>(v);\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        unsigned long bought = get<BOUGHT>(v);\n        q.pop();\n        if(memo.count(v) && memo[v] >= cost) continue;\n        memo[v] = cost;\n// cout<<time<<\"(\"<<y<<\",\"<<x<<\")\"<<bitset<10>(bought)<<\" cost: \"<<cost<<endl;\n// if(time > 10) break;\n        result = max(result, cost);\n        if(time > 100) continue;\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(m[ny][nx] == NONE) continue;\n            if(bought & (1 << m[ny][nx])) continue;\n            for(const auto& s: sale) {\n                if(get<GOODS>(s) != m[ny][nx]) continue;\n                if(time < get<START>(s) || get<END>(s) <= time) continue;\n                bought |= 1 << m[ny][nx];\n                cost += get<DISCOUNT>(s);\n            }\n        }\n        time += 1;\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(m[ny][nx] != NONE) continue;\n            q.push(Node(cost, Vertex(time, ny, nx, bought)));\n        }\n    }\n    return result;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        Vertex start;\n        m = vector<vector<int>>(h, vector<int>(w, NONE));\n        for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '.') continue;\n            else if(c == 'P') start = Vertex(0, i, j, 0);\n            else m[i][j] = c - '0';\n        }\n\n        sale.clear();\n        int n;\n        cin >> n;\n        for(int i = 0; i < n; ++i) {\n            int g, d, s, e;\n            cin >> g >> d >> s >> e;\n            sale.push_back(Sale(g, d, s, e));\n        }\n\n        cout << bfs(start) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tis_sale[number[g]] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\t//printf(\"row:%d col:%d time:%d state:%d\\n\",Q.top().row,Q.top().col,Q.top().time,Q.top().state);\n\n\t\t\t\t\tint adj_item = number[base_map[adj_row][adj_col]-'0'];\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{ //Q.top().time < info[adj_item].start\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] = '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] = 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 5; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct node{\n\tint x,y,bit,t;\n\tnode(int x,int y,int bit,int t) : x(x) , y(y) , bit(bit) , t(t) {}\n};\n\nint x,y;\nint sx,sy;\nint n;\nchar c[22][22];\nint num[10],d[10],s[10],e[10];\nint value[1<<10];\nint done[22][22][1<<8][102];\nint dx[5]={0,0,1,-1,0},dy[5]={1,-1,0,0,0};\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tqueue<node> que;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j=0;j<=21;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tcin >> c[j][i];\n\t\t\t\tif(c[j][i]=='P'){\n\t\t\t\t\tque.push(node(j,i,0,0));\n\t\t\t\t\tc[j][i]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tnum[a]=i;\n\t\t\tscanf(\"%d%d%d\",&d[i],&s[i],&e[i]);\n\t\t}\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n                value[i]+=(i>>j&1)*d[j];\n            }\n            //cout << value[i] << \" \" << i << endl;\n        }\n\t\tmemset(done,0,sizeof(done));\n\t\tint ans=0;\n\t\twhile(que.size()){\n\t\t\tnode q=que.front();que.pop();\n\t\t\tif(q.t>100)continue;\n\t\t\tif(c[q.x][q.y]!='.')continue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint tx=q.x+dx[i];\n\t\t\t\tint ty=q.y+dy[i];\n\t\t\t\tif(c[tx][ty]>='0' && c[tx][ty]<='9'){\n\t\t\t\t\tint idx=num[c[tx][ty]-'0'];\n\t\t\t\t\tif(s[idx]<=q.t && q.t<e[idx])q.bit |= 1<<idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(done[q.x][q.y][q.bit][q.t]++)continue;\n\t\t\tans=max(ans,value[q.bit]);\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tque.push(node(q.x+dx[i],q.y+dy[i],q.bit,q.t+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct pos {\n\tint x, y;\n\tint c;\n\n\tpos() {}\n\tpos(int x_, int y_, int c_) {\n\t\tx = x_; y = y_; c = c_;\n\t}\n};\n\nbool visited[22][22][105][1024];\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tvector<string> shop;\n\t\tstring str;\n\t\tint sale[10][3];\n\t\tint mx_t = 0;\n\t\tfor(int i = 0; i < 22*22*105*1024; i++)\n\t\t\tvisited[0][0][0][i] = false;\n\t\tfor(int i = 0; i < x+2; i++)\n\t\t\tstr += \"#\";\n\t\tshop.push_back(str);\n\t\tcin.ignore();\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tstring tmp;\n\t\t\ttmp = \"#\";\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tchar in;\n\t\t\t\tcin >> in; cin.ignore();\n\t\t\t\ttmp += in;\n\t\t\t}\n\t\t\ttmp += \"#\";\n\t\t\tshop.push_back(tmp);\n\t\t}\n\t\tshop.push_back(str);\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint g, d, s, e;\n\t\t\tcin >> g >> d >> s >> e;\n\t\t\tsale[g][0] = s; sale[g][1] = e; sale[g][2] = d;\n\t\t\tmx_t = max(mx_t, e);\n\t\t}\n\n\t\tpos P;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tif(shop[i+1][j+1] == 'P') {\n\t\t\t\t\tP = pos(j+1, i+1, 0);\n\t\t\t\t\tshop[i+1][j+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < shop.size(); i++) {\n\t\t\tfor(int j = 0; j < shop[i].size(); j++) {\n\t\t\t\tcout << shop[i][j];\n\t\t\t} cout << endl;\n\t\t}\n\t\t// */\n\n\t\tconst int dxy[] = {0, 1, 0, -1, 0};\n\t\tint res = 0;\n\t\tqueue<pos> q;\n\t\tq.push(P);\n\t\tfor(int t = 0; t <= mx_t; t++) {\n\t\t\tqueue<pos> nex;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tpos cur = q.front(); q.pop();\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tchar ca = shop[cur.y+dxy[i]][cur.x+dxy[i+1]];\n\t\t\t\t\tif(ca != '.' && ca != '#' && sale[ca-'0'][0] <= t && t < sale[ca-'0'][1]) {\n\t\t\t\t\t\tcur.c |= 1 << (ca - '0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tchar ca = shop[cur.y+dxy[i]][cur.x+dxy[i+1]];\n\t\t\t\t\tif(ca == '.' && !visited[cur.y+dxy[i]][cur.x+dxy[i+1]][t+1][cur.c]) {\n\t\t\t\t\t\tvisited[cur.y+dxy[i]][cur.x+dxy[i+1]][t+1][cur.c] = true;\n\t\t\t\t\t\tnex.push(pos(cur.x + dxy[i+1], cur.y + dxy[i], cur.c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t == mx_t) {\n\t\t\t\twhile(!nex.empty()) {\n\t\t\t\t\tpos cur = nex.front(); nex.pop();\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor(int i = 0; i < 10; i++) {\n\t\t\t\t\t\tif(cur.c & (1 << i)) {\n\t\t\t\t\t\t\ttmp += sale[i][2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres = max(res, tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq = nex;\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nmap<string,int> MAP;\n\nint W,H,item_num,limit;\nint number[10];\nint POW[10],dist[20][20][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint dfs(int state,int row,int col,int time){\n\n\tif(state == limit-1){\n\t\treturn 0;\n\t}\n\n\tstring tmp;\n\ttmp.append(to_string(state)).append(to_string('@')).append(to_string(row)).append(to_string('@')).append(to_string(col)).append(to_string('@')).append(to_string(time));\n\n\tauto at = MAP.find(tmp);\n\n\tif(at != MAP.end()){\n\t\treturn MAP[tmp];\n\t}\n\n\tint ret = 0;\n\n\tfor(int loop = 0; loop < item_num; loop++){\n\t\tif(state & (1 << loop)){\n\t\t\t//Do nothing\n\t\t}else{\n\n\t\t\tint next_item = loop;\n\t\t\tint next_state = state + POW[next_item];\n\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\tfor(int k = 0; k < info[next_item].V.size(); k++){\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\t\tadj_row = info[next_item].V[k].row + diff_row[i];\n\t\t\t\t\tadj_col = info[next_item].V[k].col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tnext_time = time + dist[row][col][adj_row][adj_col];\n\n\t\t\t\t\tif(next_time > info[next_item].end){\n\n\t\t\t\t\t\tret = max(ret,dfs(next_state,row,col,time));\n\n\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\tret = max(ret,info[next_item].discount+dfs(next_state,adj_row,adj_col,next_time));\n\n\t\t\t\t\t}else if(next_time < info[next_item].start){\n\t\t\t\t\t\tret = max(ret,info[next_item].discount+dfs(next_state,adj_row,adj_col,info[next_item].start));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMAP[tmp] = ret;\n\n\treturn ret;\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[buf[0]-'0'].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tMAP.clear();\n\n\tprintf(\"%d\\n\",dfs(0,start_row,start_col,0));\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\n\nint W,H,item_num,limit;\nint number[10];\nint POW[10],dist[20][20][20][20]; //dist[from_row][from_col][to_row][to_col]\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint dfs(int state,int row,int col,int time){\n\n\tif(state == limit-1){\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\tfor(int loop = 0; loop < item_num; loop++){\n\t\tif(state & (1 << loop)){ //??¢?????????number[loop]?????????????¨???????????????´???\n\t\t\t//Do nothing\n\t\t}else{\n\n\t\t\tint next_item = loop;\n\t\t\tint next_state = state + POW[next_item];\n\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\tfor(int k = 0; k < info[next_item].V.size(); k++){\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t//???????????£\n\t\t\t\t\tadj_row = info[next_item].V[k].row + diff_row[i];\n\t\t\t\t\tadj_col = info[next_item].V[k].col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tnext_time = time + dist[row][col][adj_row][adj_col];\n\n\t\t\t\t\tif(next_time > info[next_item].end){\n\n\t\t\t\t\t\tret = max(ret,dfs(next_state,row,col,time)); //??????(??£???)????????????????????????????¬????????????????????????????????????¨???????????????\n\n\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\tret = max(ret,info[next_item].discount+dfs(next_state,adj_row,adj_col,next_time));\n\n\t\t\t\t\t}else if(next_time < info[next_item].start){ //??????????????????????????´???????????????<??????????????§?¬??????????????????°???????????????????????????????????????????????????????§?????????§??????????§£????????????????????????>\n\t\t\t\t\t\tret = max(ret,info[next_item].discount+dfs(next_state,adj_row,adj_col,info[next_item].start));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???????????????????????????????????¢????¨??????????\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){ //????????´???????????§????????´???\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[buf[0]-'0'].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tprintf(\"%d\\n\",dfs(0,start_row,start_col,0));\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_T 150\n\nstruct Data{\n    int n,c,s,t;\n    Data(){}\n    Data(int n,int c,int s,int t) :\n        n(n),c(c),s(s),t(t) {}\n\n    bool operator < (const Data &d)const{\n        return n < d.n;\n    }\n};\n\nint H,W,LIMIT;\nint memo[MAX_H][MAX_W][MAX_T][1<<8];\nvector<Data> v;\nchar field[MAX_H][MAX_W];\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nbool check(int nt,int idx){\n    return (v[idx].s <= nt && nt <= v[idx].t);\n}\n\nint solve(int x,int y,int t,int p){\n    if(t == LIMIT) return 0;\n    int &res = memo[x][y][t][p];\n    if(res != -1) return res;\n    int S = p,cost = 0;\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == '.') continue;\n        int x = field[ny][nx]-'0';\n        if(S >> x & 1) continue;\n        if(check(t,x)){\n            S |= (1<<x);\n            cost += v[x].c;\n        }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] != '.') continue;\n        res = max(res,solve(nx,ny,t+1,S)+cost);\n    }\n    return res;\n}\n\nint main(){\n    int sx,sy,N;\n    while(cin >> W >> H, W){\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                cin >> field[i][j];\n                if(field[i][j] == 'P'){\n                    sx = j; sy = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n        LIMIT = 0;\n        cin >> N;\n        v.clear(); v.resize(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].n >> v[i].c >> v[i].s >> v[i].t;\n            LIMIT = max(LIMIT,v[i].t);\n        }\n        LIMIT++;\n        memset(memo,-1,sizeof(memo));\n        cout << solve(sx,sy,0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, s, t) for (int i = (int)(s); i <= (int)(t); i++)\n#define rep(i, n) Rep(i, 0, (n) - 1)\nconst int INF = 1 << 26;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint h, w;\nint sx, sy;\nchar grid[22][22];\nint sale[10][100];\nint dp[101][22][22][1 << 8];\nvector<int> salev;\nint toid[10];\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\tfill_n(*sale, 10 * 100, -INF);\n\t\tfill_n(*grid, 22 * 22, '\\0');\n\t\tfill_n(toid, 10, -1);\n\t\tsalev.clear();\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'P'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint g, d, s, e;\n\t\t\tscanf(\"%d %d %d %d\", &g, &d, &s, &e);\n\t\t\tfor (int j = s; j < e; j++){\n\t\t\t\tsale[g][j] = max(sale[g][j], d);\n\t\t\t}\n\t\t\tsalev.push_back(g);\n\t\t}\n\t\t\n\t\tsort(salev.begin(), salev.end());\n\t\tsalev.erase(unique(salev.begin(), salev.end()), salev.end());\n\t\t\n\t\tfor (int i = 0; i < salev.size(); i++){\n\t\t\ttoid[salev[i]] = i;\n\t\t}\n\t\t\n\t\tfill_n(***dp, 101 * 22 * 22 * (1 << 8), -INF);\n\t\tdp[0][sx][sy][0] = 0;\n\t\trep (t, 100) Rep (x, 1, h) Rep (y, 1, w){\n\t\t\trep (got, 1 << salev.size()){\n\t\t\t\tif (dp[t][x][y][got] == -INF) continue;\n\t\t\t\tif (grid[x][y] != '.') continue;\n\t\t\t\t//if (dp[t][x][y][got] > 0) printf(\"%d\\n\", dp[t][x][y][got]);\n\t\t\t\t//printf(\"%d %d %d %d\\n\", t, x, y, got);\n\t\t\t\t//dp[t + 1][x][y][got] = max(dp[t + 1][x][y][got], dp[t][x][y][got]);\n\t\t\t\trep (dir, 4){\n\t\t\t\t\tint nx = x + dx[dir];\n\t\t\t\t\tint ny = y + dy[dir];\n\t\t\t\t\tif (grid[nx][ny] >= '0' && grid[nx][ny] <= '9'){\n\t\t\t\t\t\tint g = grid[nx][ny] - '0';\n\t\t\t\t\t\tint id = toid[g];\n\t\t\t\t\t\tif (id != -1 && !(got & (1 << id))){\n\t\t\t\t\t\t\tdp[t][x][y][got | (1 << id)] = max(\n\t\t\t\t\t\t\t\tdp[t][x][y][got | (1 << id)],\n\t\t\t\t\t\t\t\tdp[t][x][y][got] + sale[g][t]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[t + 1][nx][ny][got] = max(\n\t\t\t\t\t\tdp[t + 1][nx][ny][got],\n\t\t\t\t\t\tdp[t][x][y][got]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\trep (t, 100) Rep (x, 1, h) Rep(y, 1, w) rep(st, 1 << salev.size()){\n\t\t\tres = max(res, dp[t][x][y][st]);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(isdigit(base_map[adj_row][adj_col])){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tmax_value = max(max_value,Q.top().sum_discount+info[adj_item].discount);\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tmax_value = max(max_value,Q.top().sum_discount+info[adj_item].discount);\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct comd { int sn,d,s,e; };\nint main() {\n  int x,y,i,j,k,g,n,t,a,b,e,h,dx[4]={1,0,-1,0},dy[4]={0,-1,0,1},d[2][20][20][256],m[20][20],f[20][20];\n  char c[20];\n  comd co[10];\n  while(cin >> x >> y && x>0) {\n\t  for (h=0;h<2;h++) for (j=0;j<20;j++) for (k=0;k<20;k++) for (g=0;g<256;g++) d[h][j][k][g]=-1;\n\t  for (i=0;i<y;i++) {  cin >> c;\n\t\t  for (j=0;j<x;j++) {  f[i][j]=0;\n\t\t\t  if (c[j]>='0' && c[j]<='9') m[i][j]=c[j]-'0'; else m[i][j]=-1;\n\t\t\t  if (c[j]=='P') { f[i][j]=1; d[0][i][j][0]=0;}\n\t\t  }\n\t  }\n\t  cin >> n;\n\t  for (i=0; i<n; i++) {  cin >> g;  cin >> co[g].d >> co[g].s >> co[g].e; co[g].sn=(1 << i);}\n\t  for (t=0,h=0;t<100;t++) {\n\t\t  for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\t\t  if (f[i][j]==0) continue;\n\t\t      for (k=0;k<256;k++) {\n\t\t\t\tif (d[h][i][j][k]==-1) continue;\n\t\t\t\ta=k; b=d[h][i][j][k];\n\t\t\t\tfor (g=0;g<4;g++) {\n\t\t\t\t\tif (j+dx[g]<0 || j+dx[g]>=x || i+dy[g]<0 || i+dy[g]>=y) continue;\n\t\t\t\t\te=m[i+dy[g]][j+dx[g]];\n\t\t\t\t\tif (e>=0) if ((co[e].sn & a)==0 && co[e].s<=t && co[e].e>t) {b+=co[e].d; a=a | co[e].sn;}\n\t\t\t\t}\n\t\t\t\td[h][i][j][a]=b;\n\t\t\t\tfor (g=0;g<4;g++) if (j+dx[g]>=0 && j+dx[g]<x && i+dy[g]>=0 && i+dy[g]<y) if (m[i+dy[g]][j+dx[g]]<0) { d[h][i+dy[g]][j+dx[g]][a]=b;  f[i+dy[g]][j+dx[g]]=1;} \n\t\t\t\t}\n\t\t\t}\n\t\t\th=1-h;\n\t\t}\n\t\ta=-1;\n\t\tfor (i=0;i<y;i++) for (j=0;j<x;j++) for (k=0;k<256;k++) if (a<d[0][i][j][k]) a=d[0][i][j][k];\n\t\tcout << a << endl;\n\t  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[next][state | s][ny][nx] =\n                  max(dp[next][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N, lim = 0, ans = 0; cin >> N;\n        map<int, int> comp;\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            chmax(lim, e);\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            x.second = id++;\n        }\n        vector<int> inv(id);\n        for(auto x : comp) {\n            inv[x.second] = x.first;\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                bool ok = true;\n                int mx = x + dx[k], my = y + dy[k];\n                ok &= !(mx < 0 || mx >= H || my < 0 || my >= W);\n                ok &= ('0' <= board[mx][my] && board[mx][my] <= '9');\n\n                if(ok) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            // cand の部分集合\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost;\n                for(int i=0; i<id; i++) {\n                    int orig_id = inv[i]; // 復元する\n                    if(mask >> i & 1) ncost += disc[orig_id][time];\n                }\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                    if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n\n                    if(rec[nx][ny][ntime][nbit] < ncost) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n\n            for(int k=0; k<4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      for(int k=0;k<(1<<10);k++){\n        vis[i][j][k] = false;\n      }\n    }\n  }\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  //vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          v.y = u.y;\n          v.x = u.x;\n          v.used = u.used | (1<<num);\n          v.t = max(u.t, data[num].s);\n          v.sum = u.sum + data[num].d;\n          res = max(res, v.sum);\n          if(!vis[v.y][v.x][v.used]){\n            vis[v.y][v.x][v.used] = true;\n            q.push(v);\n          }\n        }\n      }else{\n        if(!vis[ny][nx][u.used]){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool check(const vector<vector<pair<int, int>>>&humans, int x, int y) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto it=find(humans[i].begin(),humans[i].end(),make_pair(x,y));\n\t\tif(it!=humans[i].end())return false;\n\t}\n\treturn true;\n}\nint dx[] = { -1,0,1,0,0 };\nint dy[] = { 0,1,0,-1,0 };\n\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\nstruct sale {\n\tint id;\n\tint d;\n\tint s;\n\tint e;\n};\n\nstruct aa {\n\tint flag;\n\tint x;\n\tint y;\n\tint cost;\n};\n\n\nint main()\n{\n\twhile (true) {\n\t\tint W,H;cin>>W>>H;\n\t\tif(!W)break;\n\t\tvector<vector<int>>field(H,vector<int>(W,-1));\n\t\tvector<sale>aas;\n\t\tint sx,sy;\n\t\t{\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tchar ch;cin>>ch;\n\t\t\t\t\tif (ch == '.') {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch == 'P') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(isdigit(ch));\n\t\t\t\t\t\tfield[i][j] = ch - '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N; cin >> N;\n\t\t\tCompress<int> comp;\n\n\t\t\tvector<int>v;\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint g, d, s, e; cin >> g >> d >> s >> e;\n\t\t\t\tv.push_back(g);\n\t\t\t\taas.push_back(sale{ g,d,s,e });\n\t\t\t}\n\t\t\tcomp.setmp(v);\n\t\t\tfor (auto & line : field) {\n\t\t\t\tfor (auto&n : line) {\n\t\t\t\t\tif (n >= 0) {\n\t\t\t\t\t\tif (comp.mp.find(n) != comp.mp.end()) {\n\t\t\t\t\t\t\tn = comp.mp[n];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tn=-3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<sale>real_aas(comp.mp.size(), sale{ -1,0,0,0 });\n\t\t\tfor (auto aaa : aas) {\n\t\t\t\treal_aas[comp.mp[aaa.id]]=(sale{ aaa.id,aaa.d,aaa.s,aaa.e });\n\t\t\t}\n\t\t\taas=real_aas;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H,vector<vector<int>>(W,vector<int>(1<<aas.size(),-1e9)));\n\t\tmemo[sy][sx][0]=0;\n\n\t\tfor (int time = 0; time < 110; ++time) {\n\n\t\t\tvector<vector<vector<int>>>next_memo(H, vector<vector<int>>(W, vector<int>(1 << aas.size(), -1e9)));\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tfor (int flag = 0; flag < (1 << aas.size()); ++flag) {\n\n\t\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\t\tconst int next_y=y+dy[way];\n\t\t\t\t\t\t\tconst int next_x=x+dx[way];\n\t\t\t\t\t\t\tif(next_x<0||W<=next_x||next_y<0||H<=next_y)continue;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst int k=field[next_y][next_x];\n\t\t\t\t\t\t\t\tif (k >= 0&&(flag&(1<<k))==0) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsale asale(aas[k]);\n\t\t\t\t\t\t\t\t\tif (asale.s <= time&&time < asale.e) {\n\t\t\t\t\t\t\t\t\t\tmemo[y][x][flag|(1<<k)]=max(memo[y][x][flag|(1<<k)],memo[y][x][flag]+asale.d);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\tconst int next_y = y + dy[way];\n\t\t\t\t\t\t\tconst int next_x = x + dx[way];\n\t\t\t\t\t\t\tif (next_x<0 || W <= next_x || next_y<0 || H <= next_y)continue;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst int k = field[next_y][next_x];\n\t\t\t\t\t\t\t\tif (k == -1) {\n\t\t\t\t\t\t\t\t\tnext_memo[next_y][next_x][flag]=max(next_memo[next_y][next_x][flag],memo[y][x][flag]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo=next_memo;\n\t\t}\n\t\tint ans=0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tfor (int flag = 0; flag < (1 << aas.size()); ++flag) {\n\t\t\t\t\tans=max(ans,memo[y][x][flag]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[22][22],c[8],d[8],e[8],h[22][22][22][22],z[255][100][20][20],n;\nvector<pair<int,int> > f[8];\ninline void fi(int x,int y,int h[][22]){\n\tstatic const int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\tint i;\n\th[x][y]=0;\n\tqueue<pair<pair<int,int>,int> > p;\n\tp.push(make_pair(make_pair(x,y),0));\n\twhile(!p.empty()){\n\t\tint x=p.front().first.first;\n\t\tint y=p.front().first.second;\n\t\tint q=p.front().second;\n\t\tp.pop();\n\t\tfor(i=0;i<4;++i){\n\t\t\tif(a[x+dx[i]][y+dy[i]]>=0||h[x+dx[i]][y+dy[i]]>=0)\n\t\t\t\tcontinue;\n\t\t\th[x+dx[i]][y+dy[i]]=q+1;\n\t\t\tp.push(make_pair(make_pair(x+dx[i],y+dy[i]),q+1));\n\t\t}\n\t}\n}\nint fj(int p,int t,int x,int y){\n\tint i,j;\n\tif(p==255||t>=100)\n\t\treturn 0;\n\tif(z[p][t][x-1][y-1]>=0)\n\t\treturn z[p][t][x-1][y-1];\n\tint mx=0;\n\tfor(i=0;i<n;++i){\n\t\tif(p>>i&1)\n\t\t\tcontinue;\n\t\tfor(j=0;j<(int)f[i].size();++j){\n\t\t\tif(h[x][y][f[i][j].first][f[i][j].second]>=0&&t+h[x][y][f[i][j].first][f[i][j].second]<e[i])\n\t\t\t\tmx=max(mx,c[i]+fj(p|1<<i,max(d[i],t+h[x][y][f[i][j].first][f[i][j].second]),f[i][j].first,f[i][j].second));\n\t\t}\n\t}\n\treturn z[p][t][x-1][y-1]=mx;\n}\t\nint main(){\n\tint i,j,k;\n\tint w,he;\n\twhile(scanf(\"%d%d\",&w,&he),w||he){\n\t\tgetchar();\n\t\tint sx,sy;\n\t\tfill(a[0],a[0]+22*22,10);\n\t\tfor(i=0;i<he;++i){\n\t\t\tchar s[41];\n\t\t\tfgets(s,40,stdin);\n\t\t\tfor(j=0;j<w;++j){\n\t\t\t\tif('0'<=s[j*2]&&s[j*2]<='9'){\n\t\t\t\t\ta[j+1][i+1]=s[j*2]-'0';\n\t\t\t\t}else{\n\t\t\t\t\ta[j+1][i+1]=-1;\n\t\t\t\t\tif(s[j*2]=='P'){\n\t\t\t\t\t\tsx=j+1;\n\t\t\t\t\t\tsy=i+1;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tint b[8];\n\t\tfor(i=0;i<n;++i)\n\t\t\tscanf(\"%d%d%d%d\",b+i,c+i,d+i,e+i);\n\t\tfor(i=1;i<=he;++i){\n\t\t\tfor(j=1;j<=w;++j){\n\t\t\t\tif(a[j][i]>=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(k=0;k<n;++k){\n\t\t\t\t\tif(a[j-1][i]==b[k]||a[j+1][i]==b[k]||a[j][i-1]==b[k]||a[j][i+1]==b[k])\n\t\t\t\t\t\tf[k].push_back(make_pair(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool g[22][22]={};\n\t\tg[sx][sy]=true;\n\t\tmemset(h,-1,sizeof(h));\n\t\tfi(sx,sy,h[sx][sy]);\n\t\tfor(i=0;i<n;++i){\n\t\t\tfor(j=0;j<(int)f[i].size();++j){\n\t\t\t\tif(g[f[i][j].first][f[i][j].second])\n\t\t\t\t\tcontinue;\n\t\t\t\tg[f[i][j].first][f[i][j].second]=true;\n\t\t\t\tfi(f[i][j].first,f[i][j].second,h[f[i][j].first][f[i][j].second]);\n\t\t\t}\n\t\t}\n\t\tmemset(z,-1,sizeof(z));\n\t\tfor(i=0;i<(1<<n)-1;++i){\n\t\t\tint mn=100;\n\t\t\tfor(j=0;j<n;++j){\n\t\t\t\tif(!(i>>j&1))\n\t\t\t\t\tmn=min(mn,e[j]);\n\t\t\t}\n\t\t\tif(mn<100)\n\t\t\t\tmemset(z[i][mn],0,sizeof(int)*(100-mn)*20*20);\n\t\t}\n\t\tint mx=0;\n\t\tfor(i=0;i<(1<<n)-1;++i)\n\t\t\tmx=max(mx,fj(i,0,sx,sy));\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 29\n#define EPS 1e-10\n\ntypedef pair<int, int> P;\ntypedef pair<int,P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint G[512][512], m[20][20], used[8];\nint X, Y;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nint N;\nint g[8], d[8], s[8], e[8];\nvector<vector<P> >shop(8);\nint dp[32][32][128][8];\n\nint dfs(int y, int x, int t, int n){\n  //  printf(\"%d %d %d %d\\n\", y, x, t, n);\n  if(n == N) return 0;\n  if(dp[y][x][t][n] >= 0) return dp[y][x][t][n];\n  int res = 0;\n  rep(i, N){\n    if(used[i]) continue;\n\n    used[i] = 1;\n    rep(j, shop[g[i]].size()){\n      P p = shop[g[i]][j];\n      int dis = G[y*X+x][p.F*X+p.S];\n      int time = dis + t;\n      if(s[i] > time || e[i] <= time) continue;\n      res = max(res, dfs(p.F, p.S, time, n+1) + d[i]);\n    }\n    used[i] = 0;\n  }\n\n  return dp[y][x][t][n] = res;\n  //  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &X, &Y) && X+Y){\n    int y, x;\n    memset(dp, -1, sizeof(dp));\n    memset(used, 0, sizeof(used));\n    rep(i, Y*X) rep(j, Y*X) G[i][j] = INF;\n    rep(i, Y) rep(j, X){\n      char c[2];\n      scanf(\"%s\", c);\n      if(c[0] == 'P'){\n\ty = i;\n\tx = j;\n\tc[0] = '.';\n      }\n      m[i][j] = c[0];\n    }\n\n    rep(i, Y) rep(j, X){\n      if(!(m[i][j] == '.' || m[i][j] == 'P')) continue;\n      G[i*X+j][i*X+j] = 0;\n      rep(d, 4){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(ny < 0 || ny >= Y || nx < 0 || nx >= X) continue;\n\tif(!(m[ny][nx] == '.' || m[ny][nx] == 'P')) continue;\n\tG[i*X+j][ny*X+nx] = 1;\n      }\n    }\n\n\n    rep(k, Y*X) rep(i, Y*X) rep(j, Y*X){\n      G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    scanf(\"%d\", &N);\n    rep(i, N){\n      scanf(\"%d\", &g[i]);\n      scanf(\"%d%d%d\",  &d[i], &s[i], &e[i]);\n    }\n\n    rep(i, Y) rep(j, X){\n      if(m[i][j] == '.') continue;\n      int item = m[i][j] - '0';\n      rep(d, 4){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(ny < 0 || ny >= Y || nx < 0 || nx >= X || m[ny][nx] != '.') continue;\n\tshop[item].PB(P(ny, nx));\n      }\n    }\n\n    /*    rep(i, Y*X){\n      rep(j, Y*X) if(G[i][j] == INF) printf(\" INF\"); else printf(\"%4d\", G[i][j]); \n      puts(\"\");\n      }*/\n\n    printf(\"%d\\n\", dfs(y, x, 0, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar in[2];\nint m[30][30];\nint dp[101][21][21][1<<8];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint can[11][110];\nint lis[11];\nint con[11];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tint sr,sc;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='P'){sr=i;sc=j;}\n\t\t\tif(in[0]=='P'||in[0]=='.')m[i][j]=-1;\n\t\t\telse m[i][j]=in[0]-'0';\n\t\t}\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int i=0;i<11;i++)for(int j=0;j<110;j++)can[i][j]=0;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tfor(int j=r;j<s;j++)can[p][j]=max(can[p][j],q);\n\t\t}\n\t\tfor(int i=0;i<11;i++)lis[i]=-1;\n\t\tint sz=0;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<101;j++)if(can[i][j])ok=true;\n\t\t\tif(ok){\n\t\t\t\tcon[sz]=i;\n\t\t\t\tlis[i]=sz++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)for(int l=0;l<(1<<sz);l++){\n\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tdp[0][sr][sc][0]=0;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)for(int l=0;l<(1<<sz);l++){\n\t\t\t\tif(!~dp[i][j][k][l])continue;\n\t\t\t\tret=max(ret,dp[i][j][k][l]);\n\t\t\t\tfor(int x=0;x<4;x++){\n\t\t\t\t\tif(j+dx[x]<0||j+dx[x]>=a||k+dy[x]<0||k+dy[x]>=b)continue;\n\t\t\t\t\tif(~m[j+dx[x]][k+dy[x]]){\n\t\t\t\t\t\tif(!~lis[m[j+dx[x]][k+dy[x]]])continue;\n\t\t\t\t\t\tif(l&(1<<lis[m[j+dx[x]][k+dy[x]]]))continue;\n\t\t\t\t\t\tdp[i][j][k][l+(1<<lis[m[j+dx[x]][k+dy[x]]])]=max(dp[i][j][k][l+(1<<lis[m[j+dx[x]][k+dy[x]]])],dp[i][j][k][l]+can[m[j+dx[x]][k+dy[x]]][i]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][j+dx[x]][k+dy[x]][l]=max(dp[i+1][j+dx[x]][k+dy[x]][l],dp[i][j][k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h,w,n,g[8],d[8],s[8],e[8];\nint v[8][101];\nchar m[20][20];\nint num,sy,sx,end;\nint c[20][20][2][1<<8];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<int,int> b;\n\nint main(){\n  while(cin >> w >> h,w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin >> m[i][j];\n\tif(m[i][j] == 'P'){\n\t  sy = i; sx = j;\n\t}\n      }\n\n    cin >> n;\n    b.clear(); end = 0;\n    for(int i=0;i<n;i++){\n      cin >> g[i] >> d[i] >> s[i] >> e[i];\n      if(b.find(g[i]) == b.end())b[g[i]] = (int)b.size()-1;\n      end = max(end,e[i]);\n    }\n    num = b.size();\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=100;j++)v[i][j] = 0;\n    for(int i=0;i<n;i++)\n      for(int j=s[i];j<e[i];j++)v[b[g[i]]][j] += d[i];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\t  for(int l=0;l<(1<<num);l++)c[i][j][0][l] = -1;\n    c[sy][sx][0][0] = 0;\n\n    for(int k=0;k<end;k++){\n      int od = k&1;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  for(int l=0;l<(1<<num);l++)c[i][j][1-od][l] = -1;\n      \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  for(int l=0;l<(1<<num);l++){\n\t    if(c[i][j][od][l]<0)continue;\n\t    for(int dir=0;dir<4;dir++){\n\t      int ty = i+dy[dir], tx = j+dx[dir];\n\t      if(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n\n\t      if('0'<=m[ty][tx] && m[ty][tx]<='9'){\n\t\tint x = b[m[ty][tx]-'0'];\n\t\tif((l>>x)&1)continue;\n\t\tif(!v[x][k])continue;\n\t\tint ts = l|(1<<x);\n\t\tc[i][j][od][ts] = max(c[i][j][od][ts],c[i][j][od][l]+v[x][k]);\n\t      }else c[ty][tx][1-od][l] = max(c[ty][tx][1-od][l],c[i][j][od][l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<(1<<num);k++)ans = max(ans,c[i][j][end&1][k]);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n#define create clear\n\ntypedef pair< int , int > Pi;\n\nint w, h, n, sx, sy;\nchar mas[20][20];\nstruct sell{\n  int d, s, e; //終了時刻  \n};\nsell shop[10];\nvector< vector< Pi > > hori_sensei;\nint dp[1 << 8][20][20][101];\nint cost[20][20][20][20];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\nvoid bfs(int y, int x){\n  queue< Pi > que;\n  que.push( Pi( x, y));\n  cost[y][x][y][x] = 0;\n  while(!que.empty()){\n    Pi p = que.front();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int ny = p.second + dy[i], nx = p.first + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] != '.') continue;\n      if(cost[y][x][ny][nx]  > cost[y][x][p.second][p.first] + 1){\n        cost[y][x][ny][nx] = cost[y][x][p.second][p.first] + 1;\n        que.push( Pi( nx, ny));\n      }\n    }\n  } \n  return ;\n}\nint main(){\n\n  while(cin >> w >> h, w){\n\n    hori_sensei.create();\n    hori_sensei.resize(10);\n    int INF = 1 << 30;\n    fill_n( ***cost, 20 * 20 * 20 * 20, INF);\n    memset( dp, -1, sizeof(dp));\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P'){\n          mas[i][j] = '.';\n          sx = j, sy = i;\n        }\n      }\n    }\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(mas[i][j] == '.'){\n          for(int k = 0; k < 4; k++){\n            int ny = i + dy[k], nx = j + dx[k];\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] == '.') continue;\n            hori_sensei[mas[ny][nx] - '0'].push_back( Pi( i, j));\n          }\n          bfs(i,j);\n        }\n      }\n    }\n\n\n    cin >> n;\n    int change[10] = {};\n    for(int i = 0; i < 10; i++) shop[i].d = -1;\n    for(int i = 0; i < n; i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      shop[i] = (sell){ b, c, d};\n      change[i] = a;\n    }\n\n    dp[0][sy][sx][0] = 0;\n    for(int time = 0; time < 100; time++){\n        for(int y = 0; y < h; y++){\n          for(int x = 0; x < w; x++){\n            for(int i = 0; i < (1 << 8); i++){\n            if(dp[i][y][x][time] == -1 || mas[y][x] != '.') continue;\n            for(int j = 0; j < n; j++){\n              if((i >> j) & 1 || time >= shop[j].e) continue;\n              for(int k = 0; k < hori_sensei[j].size(); k++){\n                int res = cost[y][x][hori_sensei[change[j]][k].first][hori_sensei[change[j]][k].second];\n                if(time + res >= shop[j].e) continue;\n                int& ret = dp[i|(1 << j)][hori_sensei[j][k].first][hori_sensei[change[j]][k].second][max(time + res, shop[j].s)];\n                ret = max( ret, dp[i][y][x][time] + shop[j].d);\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << *max_element( dp[0][0][0], dp[1 << 8][0][0]) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[2][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    int cur = time % 2;\n    int next = (time + 1) % 2;\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[cur][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[next][state][ny][nx] =\n              max(dp[next][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[next][state | s][ny][nx] =\n                  max(dp[next][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  int last = E % 2;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[last][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nint x, y, dp[10][21][21][1 << 10];\nint g, d, s, e, n;\nchar c[21][21];\nint sale[10][105];\nint main(){\n    while(cin >> x >> y, x | y){\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++)\n\t\tfor(int k = 0;k < (1 << 8);k++)\n\t\t    dp[0][i][j][k] = -INF;\n\tfor(int i = 0;i < y;i++){\n\t    for(int j = 0;j < x;j++){\n\t\tcin >> c[i][j];\n\t\tif(c[i][j] == 'P'){\n\t\t    c[i][j] = '.';\n\t\t    dp[0][i][j][0] = 0;\n\t\t}\n\t    }\n\t}\n\tcin >> n;\n\tint used[10];\n\tfill(used, used + 10, 0);\n\tfor(int i = 0;i < 10;i++)\n\t    for(int j = 0;j < 105;j++)\n\t\tsale[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> g >> d >> s >> e;\n\t    used[g] = 1;\n\t    for(int j = s;j <= e;j++)\n\t\tsale[g][j] = d;\n\t}\n\tfor(int i = 1;i < 10;i++)used[i] += used[i - 1];\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++){\n\t\tif(c[i][j] != '.')c[i][j] = '0' + used[c[i][j] - '0'] - 1;\n\t    }\n\tint ans = 0;\n\tfor(int i = 0;i <= 100;i++){\n\t    for(int j = 0;j < y;j++){\n\t\tfor(int k = 0;k < x;k++){\n\t\t    if(c[j][k] != '.')continue;\n\t\t    int there = 0;\n\t\t    for(int l = 0;l < (1 << 8);l++){\n\t\t\tif(i){\n\t\t\t    dp[i & 1][j][k][l] = -INF;\n\t\t\t    for(int m = 0;m < 4;m++){\n\t\t\t\tint ty = j + ys[m], tx = k + xs[m];\n\t\t\t\tif(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t\tif(c[ty][tx] == '.')\n\t\t\t\t    dp[i & 1][j][k][l] = max(dp[(i + 1) & 1][ty][tx][l], dp[i & 1][j][k][l]);\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int m = 0;m < 4;m++){\n\t\t\t    int ty = j + ys[m], tx = k + xs[m];\n\t\t\t    if(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t    if(c[ty][tx] == '.')continue;\n\t\t\t    int pr = c[ty][tx] - '0';\n\t\t\t    if(l & (1 << pr)){\n\t\t\t\tdp[i & 1][j][k][l] = max(dp[i & 1][j][k][l], dp[i & 1][j][k][l - (1 << pr)] + sale[pr][i]);\n\n\t\t\t    }\n\t\t\t}\n\n\t\t\tans = max(dp[i & 1][j][k][l], ans);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      for(int k=0;k<(1<<10);k++){\n        vis[i][j][k] = false;\n      }\n    }\n  }\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          v.y = u.y;\n          v.x = u.x;\n          v.used = u.used | (1<<num);\n          v.t = max(u.t, data[num].s);\n          v.sum = u.sum + data[num].d;\n          res = max(res, v.sum);\n          if(!vis[v.y][v.x][v.used]){\n            vis[v.y][v.x][v.used] = true;\n            q.push(v);\n          }\n        }\n      }else{\n        if(!vis[ny][nx][u.used]){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\ntypedef pair<pii,pii> ppi;\nint used[110][1<<8][21][21];\nchar field[101][101];\nint T;\nint gs[101];\nint ds[101];\nint ss[101];\nint es[101];\nint ggs[101];\nint sums[1<<10];\n\nvoid solve(){\n\tint W,H;\n\tint sy,sx;\n\twhile(cin>>W>>H&&(W|H)){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='P'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tcin>>gs[i];\n\t\t\tggs[gs[i]]=i;\n\t\t\tcin>>ds[i]>>ss[i]>>es[i];\n\t\t}\n\t\tqueue<ppi> q;\n\t\tint smask=0;\n\t\tint scost=0;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint ny=sy+dy[j];\n\t\t\tint nx=sx+dx[j];\n\t\t\tif(ny>=0&&nx>=0&&nx<W&&ny<H&&field[ny][nx]!='.'){\n\t\t\t\tint id=ggs[field[ny][nx]-'0'];\n\t\t\t\tif(ss[id]<=0&&es[id]>0){\n\t\t\t\t\tsmask|=(1<<id);\n\t\t\t\t\tscost+=ds[id];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push(make_pair(pii(0,smask),pii(sy,sx)));\n\t\tmemset(used,-1,sizeof(used));\n\t\tused[0][smask][sy][sx]=0;\n\t\twhile(q.size()){\n\t\t\tppi p=q.front();q.pop();\n\t\t\tint cmask=p.first.second;\n\t\t\tint ctime=p.first.first;\n\t\t\tint cy=p.second.first;\n\t\t\tint cx=p.second.second;\n\t\t\t//int ctime=used[cmask][cy][cx];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=cy+dy[i];\n\t\t\t\tint nx=cx+dx[i];\n\t\t\t\tint nmask=cmask;\n\t\t\t\tint ntime=ctime+1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='.'){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tint nny=ny+dy[j];\n\t\t\t\t\t\tint nnx=nx+dx[j];\n\t\t\t\t\t\tif(nny>=0&&nnx>=0&&nny<H&&nnx<W&&field[nny][nnx]!='.'){\n\t\t\t\t\t\t\tint id=ggs[field[nny][nnx]-'0'];\n\t\t\t\t\t\t\tif(ss[id]<=ntime&&es[id]>ntime&&!((nmask>>id)&1)){\n\t\t\t\t\t\t\t\tnmask|=(1<<id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ntime<=100&&used[ntime][nmask][ny][nx]==-1){\n\t\t\t\t\t\tused[ntime][nmask][ny][nx]=1;\n\t\t\t\t\t\tq.push(make_pair(pii(ntime,nmask),pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<T);i++){\n\t\t\tsums[i]=0;\n\t\t\tfor(int j=0;j<T;j++){\n\t\t\t\tif((i>>j)&1)\n\t\t\t\t\tsums[i]+=ds[j];\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int time=0;time<=100;time++){\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfor(int mask=0;mask<(1<<T);mask++){\n\t\t\t\t\t\tif(used[time][mask][i][j]==-1)continue;\n\t\t\t\t\t\tres=max(res,sums[mask]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct node{\n\tint x,y,bit,t;\n\tnode(int x,int y,int bit,int t) : x(x) , y(y) , bit(bit) , t(t) {}\n};\n\nint x,y;\nint sx,sy;\nint n;\nchar c[22][22];\nint num[10],d[10],s[10],e[10];\nint value[1<<10];\nint done[22][22][1<<8][102];\nint dx[5]={0,0,1,-1,0},dy[5]={1,-1,0,0,0};\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tmemset(value,0,sizeof(value));\n\t\tqueue<node> que;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j=0;j<=21;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tcin >> c[j][i];\n\t\t\t\tif(c[j][i]=='P'){\n\t\t\t\t\tque.push(node(j,i,0,0));\n\t\t\t\t\tc[j][i]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tnum[a]=i;\n\t\t\tscanf(\"%d%d%d\",&d[i],&s[i],&e[i]);\n\t\t}\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n                value[i]+=(i>>j&1)*d[j];\n            }\n            //cout << value[i] << \" \" << i << endl;\n        }\n\t\tmemset(done,0,sizeof(done));\n\t\tint ans=0;\n\t\twhile(que.size()){\n\t\t\tnode q=que.front();que.pop();\n\t\t\tif(q.t>100)continue;\n\t\t\tif(c[q.x][q.y]!='.')continue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint tx=q.x+dx[i];\n\t\t\t\tint ty=q.y+dy[i];\n\t\t\t\tif(c[tx][ty]>='0' && c[tx][ty]<='9'){\n\t\t\t\t\tint idx=num[c[tx][ty]-'0'];\n\t\t\t\t\tif(s[idx]<=q.t && q.t<e[idx])q.bit |= 1<<idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(done[q.x][q.y][q.bit][q.t]++)continue;\n\t\t\tans=max(ans,value[q.bit]);\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tque.push(node(q.x+dx[i],q.y+dy[i],q.bit,q.t+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          dp[time + 1][state][y][x] =\n            max(dp[time + 1][state][y][x], v);\n          for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;  \n#define create clear\n\ntypedef pair< int , int > Pi;\n\nint w, h, n, sx, sy;\nchar mas[20][20];\nstruct sell{\n  int d, s, e; //終了時刻  \n};\nsell shop[10];\nint dp[2][1 << 8][20][20];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\nint main(){\n\n  while(cin >> w >> h, w){\n\n    memset( dp, -1, sizeof(dp));\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P'){\n          mas[i][j] = '.';\n          sx = j, sy = i;\n        }\n      }\n    }\n\n\n    cin >> n;\n    int change[10];\n    fill_n( change, 10, -1);\n    for(int i = 0; i < n; i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      shop[i] = (sell){ b, c, d};\n      change[a] = i;\n    }\n\n    int cur = 0, next = 1;\n    int ans = 0;\n    dp[cur][0][sy][sx] = 0;\n    for(int time = 0; time < 100; time++){\n      memset(dp[next], -1, sizeof(dp[next]));\n      for(int y = 0; y < h; y++){\n        for(int x = 0; x < w; x++){\n          for(int i = 0; i < (1 << 8); i++){\n            if(dp[cur][i][y][x] == -1) continue;\n            vector< int > item;\n#define rep(i,n) for(int i  =0; i < n; i++)\n            // item.clear();\n            int ret = -1;\n            for(int j = 0; j < 4; j++){\n              int ny = y + dy[j], nx = x + dx[j];\n              if(ny < 0 || ny >= h || nx < 0 || nx >= w || mas[ny][nx] == '.') continue;\n              int pos = change[mas[ny][nx] - '0'];\n              if(change[pos] == -1) continue;\n              if(shop[pos].s <= time && time < shop[pos].e) item.push_back(pos);\n            }\n\n            for(int k = 0; k < (1 << item.size()); k++){\n              int bit = i, next_cost = dp[cur][i][y][x];\n              bool flag = false;\n              for(int l = 0; l < item.size(); l++){\n                if((k >> l) & 1){\n                  if((bit >> item[l]) & 1){\n                    flag = true;\n                    break;\n                  }\n                  next_cost += shop[item[l]].d;\n                  bit |= 1 << item[l];\n                }\n              }\n              if(~flag)\n                for(int l = 0; l < 4; l++){\n                  int ny = y + dy[l], nx = x + dx[l];\n                  if(ny < 0 || ny >= h || nx < 0 || nx >= w || isdigit(mas[ny][nx])) continue;\n                  if(dp[next][bit][ny][nx] == -1 || dp[next][bit][ny][nx] > next_cost){\n                    dp[next][bit][ny][nx] = next_cost;\n                    ans = max( ans, next_cost);\n                  }\n                }\n            }\n          }\n        }\n      }\n      swap( next, cur);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cctype>\nusing namespace std;\ntypedef pair< int , int > Pt;\ntypedef pair< pair<int , Pt > , Pt > P; // Pt(cost,bit) , Pt(y,x)\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nconst int dx[] = { 0, 1, -1, 0}, dy[] = { 1, 0, 0, -1};\nstruct edge{\n  int prime,st,ed;\n  edge(){};\n  edge(int prime,int st,int ed):prime(prime),st(st),ed(ed){};\n};\nedge info[10];\nint x, y;\nchar mas[20][20];\nbool no_over(int ny,int nx){\n  return ny >= 0 && ny < y && nx >= 0 && nx < x;\n}\nint Dijkstra(Pt& start){\n  int ret = 0;\n  bool used[20][20][1<<10];\n  fill_n(used[0][0],20*20*(1<<10),false);\n  priority_queue< P , vector<P> , greater<P> > que;\n  que.push(P(make_pair(0,Pt((1<<10)-1,0)),start));\n  used[start.fr][start.sc][(1<<10)-1] = true;\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    //if(used[p.sc.fr][p.sc.sc][p.fr.sc.fr]++) continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n      if(!no_over(ny,nx)) continue;\n      if(isdigit(mas[ny][nx])){\n        edge e = info[mas[ny][nx]-'0'];\n        int no = mas[ny][nx] - '0';\n        ny = p.sc.fr, nx = p.sc.sc;\n        if( !(p.fr.sc.fr >> no & 1) || p.fr.fr > e.ed) continue;\n        if(p.fr.fr >= e.st){\n          ret = max(ret,p.fr.sc.sc + e.prime);\n          if(used[ny][nx][p.fr.sc.fr&~(1<<no)]++) continue;\n          que.push(P(make_pair(p.fr.fr,Pt(p.fr.sc.fr&~(1<<no),p.fr.sc.sc+e.prime)),Pt(ny,nx)));\n        }else que.push(P(make_pair(e.st,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }else{\n        if(used[ny][nx][p.fr.sc.fr]++) continue;\n        que.push(P(make_pair(p.fr.fr+1,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> x >> y , x){\n    Pt st;\n    for(int i = 0 ; i < y ; i++ ){\n      for(int j = 0 ; j < x ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') st = Pt(i,j);\n      }\n    }\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; i++ ){\n      int g,d,s,e;\n      cin >> g >> d >> s >> e;\n      info[g] = edge(d,s,e);\n    }\n    cout << Dijkstra(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20][101];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tv[temp.bit][temp.ty][temp.tx][temp.time] = true;\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx][temp.time + 1] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tv[temp.bit][my][mx][temp.time + 1] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t\telse if (map[my][mx] != -1 && !((temp.bit >> map[my][mx]) & 1) \n\t\t\t\t\t\t\t\t&& v[temp.bit | 1 << map[my][mx]][temp.ty][temp.tx][temp.time] == false\n\t\t\t\t\t\t\t\t  && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= 1 << map[my][mx];\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tv[st.bit][st.ty][st.tx][st.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cctype>\nusing namespace std;\ntypedef pair< int , int > Pt;\ntypedef pair< pair<int , Pt > , Pt > P; // Pt(cost,bit) , Pt(y,x)\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nconst int dx[] = { 0, 1, -1, 0}, dy[] = { 1, 0, 0, -1};\nstruct edge{\n  int prime,st,ed;\n  edge(){};\n  edge(int prime,int st,int ed):prime(prime),st(st),ed(ed){}\n};\nedge info[11];\nint x, y;\nchar mas[21][21];\nbool no_over(int ny,int nx){\n  return ny >= 0 && ny < y && nx >= 0 && nx < x;\n}\nint Dijkstra(Pt& start){\n  int ret = 0;\n  bool used[21][21][1<<11];\n  fill_n(used[0][0],20*20*(1<<11),false);\n  queue<P> que;\n  que.push(P(make_pair(0,Pt((1<<10)-1,0)),start));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(used[p.sc.fr][p.sc.sc][p.fr.sc.fr]++) continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n      if(!no_over(ny,nx)) continue;\n      if(isdigit(mas[ny][nx])){\n        edge e = info[mas[ny][nx]-'0'];\n        int no = mas[ny][nx] - '0';\n        ny = p.sc.fr, nx = p.sc.sc;\n        if( !(p.fr.sc.fr & (1 << no)) || p.fr.fr >= e.ed) continue; //売り切れた時刻は買えない(戒め)\n        que.push(P(make_pair(p.fr.fr>=e.st?p.fr.fr:e.st,Pt(p.fr.sc.fr&~(1<<no),p.fr.sc.sc+e.prime)),Pt(ny,nx)));\n        ret = max(ret,p.fr.sc.sc + e.prime);\n      }else que.push(P(make_pair(p.fr.fr+1,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> x >> y , x){\n    Pt st;\n    for(int i = 0 ; i < y ; i++ ){\n      for(int j = 0 ; j < x ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') st = Pt(i,j);\n      }\n    }\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; i++ ){\n      int g,d,s,e;\n      cin >> g >> d >> s >> e;\n      info[g] = edge(d,s,e);\n    }\n    cout << Dijkstra(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[100][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,INF);\n        fill(et_i,et_i+10,-INF);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(p.t+1<100&&!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nint x, y, dp[10][21][21][1 << 10];\nint g[10], d[10], s[10], e[10], n;\nchar c[21][21];\nint sale[10][105];\nint main(){\n    while(cin >> x >> y, x | y){\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++)\n\t\tfor(int k = 0;k < (1 << 8);k++)\n\t\t    dp[0][i][j][k] = -INF;\n\tfor(int i = 0;i < y;i++){\n\t    for(int j = 0;j < x;j++){\n\t\tcin >> c[i][j];\n\t\tif(c[i][j] == 'P'){\n\t\t    c[i][j] = '.';\n\t\t    dp[0][i][j][0] = 0;\n\t\t}\n\t    }\n\t}\n\tcin >> n;\n\tint used[10];\n\tfill(used, used + 10, 0);\n\tfor(int i = 0;i < 10;i++)\n\t    for(int j = 0;j < 105;j++)\n\t\tsale[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> g[i] >> d[i] >> s[i] >> e[i];\n\t    used[g[i]] = 1;\n\t}\n\tfor(int i = 1;i < 10;i++)used[i] += used[i - 1];\n\tfor(int i = 0;i < n;i++){\n\t    for(int j = s[i];j <= e[i];j++)\n\t\tsale[used[g[i]] - 1][j] = d[i];\n\t}\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++){\n\t\tif(c[i][j] != '.')c[i][j] = '0' + used[c[i][j] - '0'] - 1;\n\t    }\n\tint ans = 0;\n\tfor(int i = 0;i <= 100;i++){\n\t    for(int j = 0;j < y;j++){\n\t\tfor(int k = 0;k < x;k++){\n\t\t    if(c[j][k] != '.')continue;\n\t\t    int there = 0;\n\t\t    for(int l = 0;l < (1 << 8);l++){\n\t\t\tif(i){\n\t\t\t    dp[i & 1][j][k][l] = -INF;\n\t\t\t    for(int m = 0;m < 4;m++){\n\t\t\t\tint ty = j + ys[m], tx = k + xs[m];\n\t\t\t\tif(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t\tif(c[ty][tx] == '.')\n\t\t\t\t    dp[i & 1][j][k][l] = max(dp[(i + 1) & 1][ty][tx][l], dp[i & 1][j][k][l]);\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int m = 0;m < 4;m++){\n\t\t\t    int ty = j + ys[m], tx = k + xs[m];\n\t\t\t    if(ty < 0 || ty >= y || tx < 0 || tx > x)continue;\n\t\t\t    if(c[ty][tx] == '.')continue;\n\t\t\t    int pr = c[ty][tx] - '0';\n\t\t\t    if(pr > 8)return 1;\n\t\t\t    if(l & (1 << pr)){\n\t\t\t\tdp[i & 1][j][k][l] = max(dp[i & 1][j][k][l], dp[i & 1][j][k][l - (1 << pr)] + sale[pr][i]);\n\n\t\t\t    }\n\t\t\t}\n\n\t\t\tans = max(dp[i & 1][j][k][l], ans);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] < '9'){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\nstatic const int INF = (1 << 29);\nstatic const int dx[] = {1,-1,0,0};\nstatic const int dy[] = {0,0,1,-1};\n\nstruct State{\n   int x,y,t,sum,unvisit;\n   State(int x, int y, int t, int s, int v):x(x),y(y),t(t),sum(s),unvisit(v){};\n};\n\nstruct Goods{\n   int price,s,e;\n   Goods(){}\n   Goods(int p, int s, int e):price(p),s(s),e(e){};\n};\n\nint h,w,n;\nint sx,sy;\nint G[20][20];\nGoods goods[10];\nbool visited[20][20][(1 << 10)][101];\n\nint bfs(){\n   memset(visited,false,sizeof(visited));  int ans = 0;\n   queue<State> q;\n   q.push(State(sx, sy, 0, 0, (1<<10)-1));\n\n   while(!q.empty()){\n      State s = q.front(); q.pop();\n      if(s.t > 100)continue;\n      if(visited[s.x][s.y][s.unvisit][s.t])continue;\n      visited[s.x][s.y][s.unvisit][s.t] = true;\n      ans = max(ans, s.sum);\n      rep(k,4){\n    \t int nx = s.x + dx[k];int ny = s.y + dy[k];\n    \t if(0<=nx&&nx<h && 0<=ny&&ny<w && G[nx][ny]!=-1){\n\t     int num = G[nx][ny];\n\t     if((s.unvisit >> num) & 1){\n\t        if(goods[num].s <= s.t && s.t < goods[num].e){\n\t\t  s.sum += goods[num].price;\n\t\t  s.unvisit = s.unvisit & ~(1 << num);\n\t       }\n\t    }\n\t   }\n      }\n\n     rep(k,4){\n\t int nx = s.x + dx[k]; int ny = s.y + dy[k];\n\t if(0<=nx&&nx<h && 0<=ny&&ny<w && G[nx][ny]==-1){\n\t    q.push(State(nx, ny, s.t+1, s.sum, s.unvisit));\n\t }\n      }\n   }\n   return ans;\n}\n\nvoid input(){\n   rep(i,h){rep(j,w){char c;cin >> c;\n\t if(c=='P'){sx = i;sy = j;G[i][j] = -1;}\n\t else if(c=='.')G[i][j] = -1; else G[i][j] = (int)(c - '0');}\n   }\n   cin >> n;\n   rep(i,n){int g,d,s,e; cin >> g >> d >> s >> e;\n      goods[g] = Goods(d,s,e);\n   }\n}\n\nint main(){\n   while(cin >> w >> h){\n      if(w==0 && h==0)break;\n      input();\n      cout << bfs() << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cctype>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\nstruct state {\n  int x,y,u,t,c;\n  state(){}\n  state(int x,int y,int u,int t,int c):x(x),y(y),u(u),t(t),c(c){}\n};\n\nint cost[20][20][1<<8][100];\nchar g[20][20];\nint n,v[8],d[8],s[8],e[8];\nint w,h;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d\",&w,&h); if(w+h == 0)break;\n    int x,y; x = y = -1;\n    for( int i = 0; i < h; i++ ) {\n      for( int j = 0; j < w; j++ ) {\n        scanf(\" %c\",g[i]+j);\n        if( g[i][j] == 'P' ) {\n          g[i][j] = '.';\n          x = j;\n          y = i;\n        }\n      }\n    }\n    assert(x>=0 && y>=0);\n    scanf(\"%d\",&n);\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%d%d%d%d\",v+i,d+i,s+i,e+i);\n    }\n    int res = 0;\n    queue<state> q;\n    q.push(state(x,y,0,0,0));\n    memset(cost,-1,sizeof(cost));\n    while( !q.empty() ) {\n      state p = q.front(); q.pop();\n      //printf(\"%d %d %02x %d %d\\n\",p.x,p.y,p.u,p.t,p.c);\n      if( p.t >= 100 ) continue;\n      if( res < p.c ) res = p.c;\n      for( int i = 0; i < 4; i++ ) {\n        x = p.x+dx[i];\n        y = p.y+dy[i];\n        if( x < 0 || x >= w || y < 0 || y >= h ) continue;\n        if( isdigit(g[y][x]) ) {\n          int k = g[y][x]-'0';\n          if( !(p.u>>k&1) ) {\n            for( int j = 0; j < n; j++ ) {\n              if( s[j] <= p.t && p.t < e[j] && v[j] == k ) {\n                if( cost[p.y][p.x][p.u|1<<k][p.t] < p.c+d[j] ) {\n                  cost[p.y][p.x][p.u|1<<k][p.t] = p.c+d[j];\n                  q.push(state(p.x,p.y,p.u|1<<k,p.t,p.c+d[j]));\n                }\n              }\n            }\n          }\n        }\n        if( g[y][x] == '.' && cost[y][x][p.u][p.t+1] < p.c ) {\n          cost[y][x][p.u][p.t+1] = p.c;\n          q.push(state(x,y,p.u,p.t+1,p.c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool v[1024][20][20][101];\nchar map[20][21];\n\ntypedef struct {\n\tint tx, ty;\n\tint bit;\n\tint time;\n\tint score;\n} Move;\n\nint main(void)\n{\n\tint x, y;\n\tint ans;\n\tint n;\n\tint idx, plus[10], s[10], e[10];\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\tMove st;\n\t\n\twhile (scanf(\"%d %d\", &x, &y) && x){\n\t\tfor (int i = 0; i < y; i++){\n\t\t\tfor (int j = 0; j < x; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (map[i][j] == 'P'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tst.ty = i;\n\t\t\t\t\tst.tx = j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tscanf(\"%d %d %d\", &plus[idx], &s[idx], &e[idx]);\n\t\t}\n\t\t\n\t\tmemset(v, 0, sizeof(v));\n\t\tst.time = st.score = st.bit = 0;\n\t\tans = 0;\n\t\t\n\t\tqueue<Move> que;\n\t\t\n\t\tv[0][st.ty][st.tx][0] = true;\n\t\t\n\t\tque.push(st);\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tMove temp = que.front();\n\t\t\tque.pop();\n\t\t\tif (temp.time > 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tans = max(ans, temp.score);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint mx = temp.tx + dx[i], my = temp.ty + dy[i];\n\t\t\t\tif (0 <= mx && mx < x && 0 <= my && my < y){\n\t\t\t\t\tif (map[my][mx] == -1 && v[temp.bit][my][mx][temp.time + 1] == false){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.time++;\n\t\t\t\t\t\tst.tx = mx, st.ty = my;\n\t\t\t\t\t\tv[st.bit][st.ty][st.tx][st.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t\telse if (~map[my][mx] && !((temp.bit >> map[my][mx]) & 1) \n\t\t\t\t\t\t\t\t&& v[temp.bit | (1 << map[my][mx])][temp.ty][temp.tx][temp.time] == false\n\t\t\t\t\t\t\t\t  && s[map[my][mx]] <= temp.time && temp.time < e[map[my][mx]]){\n\t\t\t\t\t\tst = temp;\n\t\t\t\t\t\tst.bit |= (1 << map[my][mx]);\n\t\t\t\t\t\tst.score += plus[map[my][mx]];\n\t\t\t\t\t\tv[st.bit][st.ty][st.tx][st.time] = true;\n\t\t\t\t\t\tque.push(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data {\n  int cur,time,bitmask,score;\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint maxi[20*20][1<<8][110],info[30][30][110];\nint w,h,sp,n,g[10],d[10],s[10],e[10],limit,trans[10];\nchar field[30][30];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nint getDiff(int bits1,int bits2){\n  int ret = 0;\n  int diff = bits1 ^ bits2;\n  diff = diff & bits2;\n  while( diff ){\n    int here = diff & -diff;\n    diff -= here;\n    int pos = log2(here);\n    ret += d[trans[pos]];\n  }\n  return ret;\n}\n\nvoid compute(){\n  rep(tm,limit) {\n    rep(i,h) rep(j,w) {\n      info[i][j][tm] = 0;\n      rep(k,4) {\n        int nx = j + dx[k], ny = i + dy[k];\n        if( !isValid(nx,ny) ) continue;\n        if( field[ny][nx] == '.' ) continue;\n        int index = field[ny][nx] - '0';\n        if( s[index] <= tm && tm < e[index] ) {\n          info[i][j][tm] |= (1<<(field[ny][nx]-'0'));\n        }\n      }\n    }\n  }\n\n  deque<Data> deq;\n  rep(i,h*w) rep(j,(1<<n)) rep(k,limit) maxi[i][j][k] = -1;\n  deq.push_back((Data){sp,0,0,0});\n  int answer = 0;\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    if( maxi[data.cur][data.bitmask][data.time] > data.score ) continue;\n    int x = data.cur % w, y = data.cur / w;\n    rep(i,4){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( !isValid(nx,ny) ) continue;\n      if( field[ny][nx] != '.' ) continue;\n      if( data.time + 1 >= limit ) continue;\n      int ntime = data.time + 1;\n      int nbitmask = data.bitmask | info[ny][nx][ntime];\n      int nscore = data.score + getDiff(data.bitmask,info[ny][nx][ntime]);\n      if( maxi[nx+ny*w][nbitmask][ntime] < nscore ) {\n        maxi[nx+ny*w][nbitmask][ntime] = nscore;\n        answer = max(answer,nscore);\n        deq.push_back((Data){nx+ny*w,ntime,nbitmask,nscore});\n      }\n    }\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  while( cin >> w >> h, w|h ){\n    rep(i,h) rep(j,w) {\n      cin >> field[i][j];\n      if( field[i][j] == 'P' ) {\n        field[i][j] = '.';\n        sp = j + i * w;\n      }\n    }\n    limit = 0;\n    cin >> n;\n    rep(i,n) {\n      cin >> g[i] >> d[i] >> s[i] >> e[i];\n      trans[g[i]] = i;\n      limit = max(limit,e[i]);\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntemplate<class T> T gcd( T a, T b ) {\n\treturn !b ? a : gcd( b, a % b );\n}\ntemplate<class T> T lcm( T a, T b ) {\n\treturn a / gcd( a, b ) * b;\n}\ntemplate<class T> string print_v( vector<T> v ) {\n\tOSS oss;\n\tfor ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end();\n          ++it_i ) {\n\t\toss << *it_i << \", \";\n\t}\n\treturn oss.str();\n}\n\ntypedef pair <int, int> II;\ntypedef pair <II, II> NODE;\ntypedef queue <NODE> QUEUE;\ntypedef map <int, int> MII;\n\nconst int size = 11;\nconst int bsize = 1 << size;\nconst int msize = 21;\n\nchar G[size];\nint D[size], S[size], E[size];\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\n\nbool is_safe_pos( int w, int h, int r, int c ) {\n    if ( r < 0 || r >= h ) return false;\n    if ( c < 0 || c >= w ) return false;\n    return true;\n}\n\nint solve( int n, VS M ) {\n    int MC[bsize][msize][msize]; // MC[S][r][c] := (r,c)ツづ可湘ウツ妥粘ツづ可辿ツづィツ陳?つ「ツつスツ催?渉ャツづ個篠楪甘?\n    for ( int i = 0; i < bsize; ++ i )\n        for ( int j = 0; j < msize; ++ j )\n            for ( int k = 0; k < msize; ++ k )\n                MC[i][j][k] = INT_MAX;\n    MII mii;\n    for ( int i = 0; i < n; ++ i )\n        mii[G[i]-'0'] = i;\n    int w = M[0].size();\n    int h = M.size();\n    int sr, sc;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == 'P' ) {\n                sr = i;\n                sc = j;\n                M[i][j] = '.';\n            }\n        }\n    }\n    MC[0][sr][sc] = 0;\n    QUEUE Q;\n    Q.push( NODE( II( 0, 0 ), II( sr, sc ) ) ); // NODE( ツスツテツッツプツ青? ツ湘ウツ妥粘 )\n\n    int res = 0;\n    while ( ! Q.empty() ) {\n        NODE node = Q.front();\n        Q.pop();\n        int steps = node.first.first;\n        int state = node.first.second;\n        int r = node.second.first;\n        int c = node.second.second;\n\n        // cout << steps << \", \" << state << \", \" << r << \", \" << c << endl;\n        int sum = 0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( state & ( 1 << i ) ) sum += D[i];\n        }\n        res = max( res, sum );\n\n        int nstate = state;\n        for ( int i = 0; i < 4; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( ! is_safe_pos( w, h, nr, nc ) ) continue;\n            if ( M[nr][nc] == '.' ) continue;\n            int item_no = mii[ M[nr][nc] - '0' ];\n            if ( state & ( 1 << item_no ) ) continue;\n            if ( S[item_no] > steps || steps > E[item_no] ) continue;\n            nstate |= 1 << item_no;\n        }\n\n        int nsteps = steps + 1;\n        for ( int i = 0; i < 4; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( ! is_safe_pos( w, h, nr, nc ) ) continue;\n            if ( M[nr][nc] != '.' ) continue;\n            if ( nsteps >= MC[nstate][nr][nc] ) continue;\n            MC[nstate][nr][nc] = nsteps;\n            Q.push( NODE( II( nsteps, nstate ), II( nr, nc ) ) );\n        }\n    }\n    return res;\n}\n\nint main() {\n    int x, y;\n    while ( cin >> x >> y && x ) {\n        VS M(y, string( x, '.' ));\n        for ( int i = 0; i < y; ++ i ) {\n            for ( int j = 0; j < x; ++ j ) {\n                cin >> M[i][j];\n            }\n        }\n        int n;\n        cin >> n;\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> G[i] >> D[i] >> S[i] >> E[i];\n        }\n        cout << solve( n, M ) << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int MAX_W = 20;\nconst int MAX_N = 8;\n\nint dx[5] = {0,0,-1,1,0};\nint dy[5] = {-1,1,0,0,0};\nint w, h, n;\nint num[MAX_N], g[MAX_N], d[MAX_N], s[MAX_N], e[MAX_N];\nchar c[MAX_W][MAX_W];\n \nint place[256] = {0};\nint sx, sy, max_t;\nint memo[MAX_W][MAX_W][256][101] = {0};\n\nstruct State{\n\tint x, y, bits, t;\n\tState(int x_, int y_, int bits_, int t_){\n\t\tx = x_; y = y_; bits = bits_; t = t_;\n\t}\n};\n\nvoid debug(int bx, int by, int ax, int ay, int bits, int t){\n\tcout << \"[debug]\" << endl;\n\tcout << \"t:\" << t << \" bits:\";\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tcout << (( bits & (1<<i) )? \"1\" : \"0\");\n\t}\n\tcout << endl;\n\tcout << \"place:\" << place[bits] << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( ax == x && ay == y ){\n\t\t\t\tcout << 'P';\n\t\t\t}else if( bx == x && by == y ){\n\t\t\t\tcout << 'p';\n\t\t\t}else{\n\t\t\t\tcout << c[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint solve(){\n\t// place[bits] := 商品の状態 bits の値引きの合計\n\t// あらかじめ商品の状態を表す任意の bits について値引きを計算しておく (2^n通り)\n\tfor(int i=0 ; i < (1<<n) ; i++ ){\n\t\tplace[i] = 0;\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tif( i & (1<<j) ){\n\t\t\t\tplace[i] += d[j];\n\t\t\t}\n\t\t}\n\t}\n\t// memo[y][x][bits][t] := (x,y) の時刻t, 商品の状態bits のときの最大値引き\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tfor(int i=0 ; i < 256 ; i++ ){\n\t\t\t\tfor(int t=0 ; t < 101 ; t++ ){\n\t\t\t\t\tmemo[y][x][i][t] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// キューは (今いる座標,商品の状態,時間) を保持\n\tqueue<State> q;\n\tq.push( State(sx,sy,0,0) );\n\t\n\tint res = 0;\n\twhile( !q.empty() ){\n\t\tint x = q.front().x;\n\t\tint y = q.front().y;\n\t\tint bits = q.front().bits;\n\t\tint t = q.front().t;\n\t\tq.pop();\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( '0' <= c[my][mx] && c[my][mx] <= '9' ){\n\t\t\t\tint id = num[c[my][mx] - '0'];\n\t\t\t\t\n\t\t\t\tif( s[id] <= t && t < e[id] ){\n\t\t\t\t\tbits |= 1 << id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( memo[y][x][bits][t] == 0 ){\n\t\t\tmemo[y][x][bits][t] = 1;\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t\tres = max(res,place[bits]);\n\t\tfor(int i=0 ; i < 5 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( c[my][mx] == '.' && t+1 <= max_t ){\n\t\t\t\tState next = State(mx,my,bits,t+1);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> c[y][x];\n\t\t\t\tif( c[y][x] == 'P' ){\n\t\t\t\t\tc[y][x] = '.';\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tmax_t = 0;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> g[i] >> d[i] >> s[i] >> e[i];\n\t\t\tnum[g[i]] = i;\n\t\t\tmax_t = max( max_t , e[i] );\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define INF (1 << 30)\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nint x, y, dp[10][21][21][1 << 10];\nint g[10], d[10], s[10], e[10], n;\nchar c[21][21];\nint sale[10][105];\nint main(){\n    while(cin >> x >> y, x | y){\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++)\n\t\tfor(int k = 0;k < (1 << 8);k++)\n\t\t    dp[0][i][j][k] = -INF;\n\tfor(int i = 0;i < y;i++){\n\t    for(int j = 0;j < x;j++){\n\t\tcin >> c[i][j];\n\t\tif(c[i][j] == 'P'){\n\t\t    c[i][j] = '.';\n\t\t    dp[0][i][j][0] = 0;\n\t\t}\n\t    }\n\t}\n\tcin >> n;\n\tint used[10];\n\tfill(used, used + 10, 0);\n\tfor(int i = 0;i < 10;i++)\n\t    for(int j = 0;j < 105;j++)\n\t\tsale[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> g[i] >> d[i] >> s[i] >> e[i];\n\t    used[g[i]] = 1;\n\t}\n\tfor(int i = 1;i < 10;i++)used[i] += used[i - 1];\n\tfor(int i = 0;i < n;i++){\n\t    for(int j = s[i];j < e[i];j++)\n\t\tsale[used[g[i]] - 1][j] = d[i];\n\t}\n\tfor(int i = 0;i < y;i++)\n\t    for(int j = 0;j < x;j++){\n\t\tif(c[i][j] != '.')c[i][j] = '0' + used[c[i][j] - '0'] - 1;\n\t    }\n\tint ans = 0;\n\tfor(int i = 0;i <= 100;i++){\n\t    for(int j = 0;j < y;j++){\n\t\tfor(int k = 0;k < x;k++){\n\t\t    if(c[j][k] != '.')continue;\n\t\t    int there = 0;\n\t\t    for(int l = 0;l < (1 << 8);l++){\n\t\t\tif(i){\n\t\t\t    dp[i & 1][j][k][l] = -INF;\n\t\t\t    for(int m = 0;m < 4;m++){\n\t\t\t\tint ty = j + ys[m], tx = k + xs[m];\n\t\t\t\tif(ty < 0 || ty >= y || tx < 0 || tx >= x)continue;\n\t\t\t\tif(c[ty][tx] == '.')\n\t\t\t\t    dp[i & 1][j][k][l] = max(dp[(i + 1) & 1][ty][tx][l], dp[i & 1][j][k][l]);\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int m = 0;m < 4;m++){\n\t\t\t    int ty = j + ys[m], tx = k + xs[m];\n\t\t\t    if(ty < 0 || ty >= y || tx < 0 || tx >= x)continue;\n\t\t\t    if(c[ty][tx] == '.')continue;\n\t\t\t    int pr = c[ty][tx] - '0';\n\t\t\t    if(l & (1 << pr)){\n\t\t\t\tdp[i & 1][j][k][l] = max(dp[i & 1][j][k][l], dp[i & 1][j][k][l - (1 << pr)] + sale[pr][i]);\n\t\t\t    }\n\t\t\t}\n\t\t\tans = max(dp[i & 1][j][k][l], ans);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tis_sale[number[g]] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\n\t\t\t\t\t//printf(\"row:%d col:%d time:%d state:%d\\n\",Q.top().row,Q.top().col,Q.top().time,Q.top().state);\n\n\t\t\t\t\tint adj_item = number[base_map[adj_row][adj_col]-'0'];\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tint adj_min_time = info[adj_item].start;\n\t\t\t\t\t\tint min_index = adj_item;\n\n\t\t\t\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\t\t\t\tint calc_adj_row = Q.top().row + diff_row[p];\n\t\t\t\t\t\t\tint calc_adj_col = Q.top().col + diff_col[p];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_adj_row,calc_adj_col) == false || base_map[calc_adj_row][calc_adj_col] == '.')continue;\n\n\t\t\t\t\t\t\tint calc_index = number[base_map[calc_adj_row][calc_adj_col]-'0'];\n\n\t\t\t\t\t\t\tif(info[calc_index].start >= Q.top().time && info[calc_index].start < adj_min_time && (Q.top().visited[calc_index] == false)){ //?????¨??????????????£??\\?????????????????????????????????\n\t\t\t\t\t\t\t\tadj_min_time = info[calc_index].start;\n\t\t\t\t\t\t\t\tmin_index = calc_index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext_state = Q.top().state + POW[min_index];\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > adj_min_time){\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = adj_min_time;\n\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_min_time].discount;\n\t\t\t\t\t\t\tnext_sale.time = adj_min_time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[min_index] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 5; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e ) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct comd { int sn,d,s,e; };\nint main() {\n  int x,y,i,j,k,g,n,t,a,b,e,h,dx[4]={1,0,-1,0},dy[4]={0,-1,0,1},d[2][20][20][256],m[20][20],f[20][20];\n  char c;\n  comd co[10];\n  while(cin >> x >> y && x>0) {\n\t  for (h=0;h<2;h++) for (j=0;j<20;j++) for (k=0;k<20;k++) for (g=0;g<256;g++) d[h][j][k][g]=-1;\n\t  for (i=0;i<y;i++) {\n\t\t  for (j=0;j<x;j++) {\n\t\t\t  cin >> c;  \n\t\t\t  f[i][j]=0;\n\t\t\t  if (c>='0' && c<='9') m[i][j]=c-'0'; else m[i][j]=-1;\n\t\t\t  if (c=='P') { f[i][j]=1; d[0][i][j][0]=0;}\n\t\t  }\n\t  }\n\t  cin >> n;\n\t  for (i=0; i<n; i++) {  cin >> g;  cin >> co[g].d >> co[g].s >> co[g].e; co[g].sn=(1 << i);}\n\t  for (t=0,h=0;t<=100;t++) {\n\t\t  for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\t\t  if (f[i][j]==0) continue;\n\t\t      for (k=0;k<256;k++) {\n\t\t\t\tif (d[h][i][j][k]==-1) continue;\n\t\t\t\ta=k; b=d[h][i][j][k];\n\t\t\t\tfor (g=0;g<4;g++) {\n\t\t\t\t\tif (j+dx[g]<0 || j+dx[g]>=x || i+dy[g]<0 || i+dy[g]>=y) continue;\n\t\t\t\t\te=m[i+dy[g]][j+dx[g]];\n\t\t\t\t\tif (e>=0) if ((co[e].sn & a)==0 && co[e].s<=t && co[e].e>t) {b+=co[e].d; a=a | co[e].sn;}\n\t\t\t\t}\n\t\t\t\td[h][i][j][a]=b;\n\t\t\t\tfor (g=0;g<4;g++) if (j+dx[g]>=0 && j+dx[g]<x && i+dy[g]>=0 && i+dy[g]<y) if (m[i+dy[g]][j+dx[g]]<0) { d[1-h][i+dy[g]][j+dx[g]][a]=b;  f[i+dy[g]][j+dx[g]]=1;} \n\t\t\t\t}\n\t\t\t}\n\t\t\th=1-h;\n\t\t}\n\t\ta=-1;\n\t\tfor (i=0;i<y;i++) for (j=0;j<x;j++) for (k=0;k<256;k++) if (a<d[0][i][j][k]) a=d[0][i][j][k];\n\t\tcout << a << endl;\n\t  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            ans = max(ans, de_sum[p.get]);\n            if(p.t>=100)continue;\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//43\n#include<iostream>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int x,y;cin>>x>>y,x|y;){\n    char g[20][20];\n    int sx,sy;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tcin>>g[i][j];\n\tif(g[i][j]=='P'){\n\t  sy=i;\n\t  sx=j;\n\t  g[i][j]='.';\n\t}\n      }\n    }\n    int n;\n    cin>>n;\n    int d[8],s[8],e[8]={};\n    map<char,int> m;\n    for(int i=0;i<n;i++){\n      char gc;\n      cin>>gc;\n      int x=m.size();\n      m[gc]=x;\n      cin>>d[x]>>s[x]>>e[x];\n    }\n    static int dp[101][20][20][1<<8];\n    fill(dp[0][0][0],dp[101][0][0],1<<31);\n    dp[0][sy][sx][0]=0;\n    for(int i=0;i<100;i++){\n      for(int j=0;j<y;j++){\n\tfor(int k=0;k<x;k++){\n\t  for(int l=0;l<1<<n;l++){\n\t    int c=dp[i][j][k][l];\n\t    int t=l;\n\t    int dr[]={0,1,0,-1,0};\n\t    for(int o=0;o<4;o++){\n\t      int dy=j+dr[o];\n\t      int dx=k+dr[o+1];\n\t      if(dy<0||y<=dy||dx<0||x<=dx)continue;\n\t      if(g[dy][dx]!='.'){\n\t\tint gn=m[g[dy][dx]];\n\t\tif(!(t>>gn&1)&&s[gn]<=i&&i<e[gn]){\n\t\t  c+=d[gn];\n\t\t  t|=1<<gn;\n\t\t}\n\t      }\n\t    }\n\t    for(int o=0;o<4;o++){\n\t      int dy=j+dr[o];\n\t      int dx=k+dr[o+1];\n\t      if(dy<0||y<=dy||dx<0||x<=dx||g[dy][dx]!='.')continue;\n\t      dp[i+1][dy][dx][t]=max(dp[i+1][dy][dx][t],c);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<*max_element(dp[100][0][0],dp[101][0][0])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nclass Item{\npublic:\n\tint n,c,s,g;\n\tItem(int n=0,int c=0,int s=0,int g=0):n(n),c(c),s(s),g(g){}\n};\n\nclass State{\npublic:\n\tint x,y,cost,sum,visited;\n\tState(int x=0,int y=0,int c=0,int s=0,int v=0):x(x),y(y),cost(c),sum(s),visited(v){}\n};\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h && h && w){\n\t\tint a[20][20], n, ans = 0;\n        bool G[20][20];\n        int n_i[10]; //商品番号を配列の番号に変換\n\t\tbool f[20][20][(1<<8)];\n\t\tItem item[8];\n\t\tqueue<State> Q;\n\t\tState u,v;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=0;k<(1<<8);k++) f[i][j][k] = false;\n\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tG[i][j] = true;\n\t\t\t\ta[i][j] = -1;\n\t\t\t\tif(c == '.') G[i][j] = false;\n\t\t\t\telse if(c == 'P'){\n\t\t\t\t\tu.y = i;\n\t\t\t\t\tu.x = j;\n\t\t\t\t\tf[i][j][0] = true;\n\t\t\t\t\tG[i][j] = false;\n\t\t\t\t} else a[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> item[i].n >> item[i].c >> item[i].s >> item[i].g;\n            n_i[item[i].n] = i;\n\t\t}\n\n\t\tQ.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n            \n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tv = u;\n\t\t\t\tv.y += dy[i];\n\t\t\t\tv.x += dx[i];\n\t\t\t\tv.cost++;\n\t\t\t\tif(v.y >= 0 && v.y < h && v.x >= 0 && v.x < w && !f[v.y][v.x][v.visited]){\n                    if(!G[v.y][v.x]){\n                        f[v.y][v.x][v.visited] = true;\n                        Q.push(v);\n                    }\n                    else if((v.visited & (1<<n_i[a[v.y][v.x]])) == 0){\n                        if(u.cost >= item[n_i[a[v.y][v.x]]].s && u.cost < item[n_i[a[v.y][v.x]]].g){\n                            State v2 = u;\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.visited = v2.visited | (1<<a[v.y][v.x]);\n                            f[v2.y][v2.x][v2.visited] = true;\n                            v2.sum += item[n_i[a[v.y][v.x]]].c;\n                            ans = max(ans,v2.sum);\n                            if(v2.visited != ((1<<n)-1)) Q.push(v2);\n                        } else if(u.cost < item[n_i[a[v.y][v.x]]].s){\n                            //変更点\n                            State v2 = u;\n                            v2.cost += item[n_i[a[v.y][v.x]]].s - v2.cost;\n                            Q.push(v2);\n                            //ここまで\n                        }\n                    }\n                }\n            }\n            \n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end <= Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time < info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V,ADJ_V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H,item_num,limit;\nint number[10],rev_number[10];\nint POW[10],dist[20][20][20][20];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\trev_number[index] = buf[0] - '0';\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[number[buf[0]-'0']].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e,TIME_MAX = 0;\n\n\tfor(int i = 0; i < item_num; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\n\t\tis_sale[number[g]] = true;\n\n\t\tTIME_MAX = max(TIME_MAX,e);\n\t}\n\n\tfor(int i = 0; i < item_num; i++){\n\n\t\tfor(int k = 0; k < info[i].V.size(); k++){\n\t\t\tfor(int p = 0; p < 4; p++){\n\n\t\t\t\tint adj_row = info[i].V[k].row + diff_row[p];\n\t\t\t\tint adj_col = info[i].V[k].col + diff_col[p];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\n\t\t\t\tinfo[i].ADJ_V.push_back(Cell(adj_row,adj_col));\n\t\t\t}\n\t\t}\n\n\t\tif(info[i].ADJ_V.size() == 0)continue;\n\n\t\tsort(info[i].ADJ_V.begin(),info[i].ADJ_V.end());\n\n\t\tvector<Cell> tmp_adj;\n\n\t\tint pre_row = info[i].ADJ_V[0].row;\n\t\tint pre_col = info[i].ADJ_V[0].col;\n\n\t\ttmp_adj.push_back(info[i].ADJ_V[0]);\n\n\t\tfor(int a = 1; a < info[i].ADJ_V.size(); a++){\n\t\t\tif(pre_row != info[i].ADJ_V[a].row || pre_col != info[i].ADJ_V[a].col){\n\t\t\t\ttmp_adj.push_back(info[i].ADJ_V[a]);\n\t\t\t}\n\t\t\tpre_row = info[i].ADJ_V[a].row;\n\t\t\tpre_col = info[i].ADJ_V[a].col;\n\t\t}\n\n\t\tinfo[i].ADJ_V.clear();\n\n\t\tfor(int a = 0; a < tmp_adj.size(); a++){\n\t\t\tinfo[i].ADJ_V.push_back(tmp_adj[a]);\n\t\t}\n\n\t\t//info[i].ADJ_V.erase(unique(info[i].ADJ_V.begin(),info[i].ADJ_V.end()),info[i].ADJ_V.end());\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < item_num; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().state == limit-1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < item_num; loop++){\n\t\t\t\tif(Q.top().visited[loop] || is_sale[loop] == false){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\n\t\t\t\t\tint next_item = loop;\n\t\t\t\t\tint next_state = Q.top().state + POW[next_item];\n\t\t\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\t\t\tfor(int k = 0; k < info[next_item].ADJ_V.size(); k++){\n\n\t\t\t\t\t\tadj_row = info[next_item].ADJ_V[k].row;\n\t\t\t\t\t\tadj_col = info[next_item].ADJ_V[k].col;\n\n\t\t\t\t\t\tnext_time = Q.top().time + dist[Q.top().row][Q.top().col][adj_row][adj_col];\n\t\t\t\t\t\tif(next_time > TIME_MAX)continue;\n\n\t\t\t\t\t\tif(next_time > info[next_item].end){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] > next_time){\n\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = next_time;\n\n\t\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tnext_sale.time = next_time;\n\t\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\t\tnext_sale.visited[next_item] = true;\n\n\t\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(next_time < info[next_item].start){\n\n\t\t\t\t\t\t\tif(dp[next_state][adj_row][adj_col] > info[next_item].start){\n\t\t\t\t\t\t\t\tdp[next_state][adj_row][adj_col] = info[next_item].start;\n\n\t\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[next_item].discount;\n\t\t\t\t\t\t\t\tnext_sale.time = info[next_item].start;\n\t\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\t\tnext_sale.visited[next_item] = true;\n\n\t\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 99)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint nextmask = d.mask;\n\t\t\t\trep(i, n){\n\t\t\t\t\tif(((mask[py][px]>>i)&1) && sale[i].s<=d.t+1 && d.t+1<sale[i].e)\n\t\t\t\t\t\tnextmask |= 1 << i;\n\t\t\t\t}\n\t\t\t\tQ.push(Data(py, px, d.t+1, nextmask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            ans = max(ans, de_sum[p.get]);\n            if(p.t>=100)continue;\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                int nget = p.get, nt = p.t + 1;\n                for(int j=0;j<4;j++){\n                    int ny2 = ny + dy[j], nx2 = nx + dx[j];\n                    if(ny2<0||h<=ny2||nx2<0||w<=nx2)continue;\n                    if('0'<=field[ny2][nx2]&&field[ny2][nx2]<='9'){\n                        int g_i = field[ny2][nx2] - '0';\n                        if(st_i[g_i] <= nt && nt < et_i[g_i]){\n                            nget |= (1<<g_i);\n                        }\n                    }\n                }\n                if(!visited[nt][nget][ny][nx]){\n                    que.push((State){nt, nget, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Cell> V;\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nmap<string,int> MAP;\n\nint W,H,item_num,limit;\nint number[10];\nint POW[10],dist[20][20][20][20];\nInfo info[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint dfs(int state,int row,int col,int time){\n\n\tif(state == limit-1){\n\t\treturn 0;\n\t}\n\n\tstring tmp;\n\ttmp.append(to_string(state)).append(to_string('@')).append(to_string(row)).append(to_string('@')).append(to_string(col)).append(to_string('@')).append(to_string(time));\n\n\tauto at = MAP.find(tmp);\n\n\tif(at != MAP.end()){\n\t\treturn MAP[tmp];\n\t}\n\n\tint ret = 0;\n\n\tfor(int loop = 0; loop < item_num; loop++){\n\t\tif(state & (1 << loop)){\n\t\t\t//Do nothing\n\t\t}else{\n\n\t\t\tint next_item = loop;\n\t\t\tint next_state = state + POW[next_item];\n\t\t\tint adj_row,adj_col,next_time;\n\n\t\t\tfor(int k = 0; k < info[next_item].V.size(); k++){\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\t\tadj_row = info[next_item].V[k].row + diff_row[i];\n\t\t\t\t\tadj_col = info[next_item].V[k].col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tnext_time = time + dist[row][col][adj_row][adj_col];\n\n\t\t\t\t\tif(next_time > info[next_item].end){\n\n\t\t\t\t\t\tret = max(ret,dfs(next_state,row,col,time));\n\n\t\t\t\t\t}else if(next_time >= info[next_item].start && next_time <= info[next_item].end){\n\n\t\t\t\t\t\tret = max(ret,info[next_item].discount+dfs(next_state,adj_row,adj_col,next_time));\n\n\t\t\t\t\t}else if(next_time < info[next_item].start){\n\t\t\t\t\t\tret = max(ret,info[next_item].discount+dfs(next_state,adj_row,adj_col,info[next_item].start));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMAP[tmp] = ret;\n\n\treturn ret;\n}\n\n\nvoid calc_dist(){\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\t\t\tfor(int to_row = 0; to_row < H; to_row++){\n\t\t\t\tfor(int to_col = 0; to_col < W; to_col++){\n\t\t\t\t\tif(base_map[to_row][to_col] != '.')continue;\n\t\t\t\t\tdist[from_row][from_col][to_row][to_col] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tint adj_row,adj_col;\n\n\tfor(int from_row = 0; from_row < H; from_row++){\n\t\tfor(int from_col = 0; from_col < W; from_col++){\n\t\t\tif(base_map[from_row][from_col] != '.')continue;\n\n\t\t\tdist[from_row][from_col][from_row][from_col] = 0;\n\t\t\tQ.push(Data(from_row,from_col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row[k];\n\t\t\t\t\tadj_col = Q.front().col + diff_col[k];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tif(dist[from_row][from_col][adj_row][adj_col] > Q.front().total_dist+1){\n\t\t\t\t\t\tdist[from_row][from_col][adj_row][adj_col] = Q.front().total_dist+1;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().total_dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint index = 0;\n\n\tint start_row,start_col;\n\n\titem_num = 0;\n\n\tfor(int i = 0; i < 10; i++){\n\t\tnumber[i] = -1;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\n\t\t\t\tif(number[buf[0]-'0'] == -1){\n\t\t\t\t\tnumber[buf[0]-'0'] = index;\n\t\t\t\t\titem_num++;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tinfo[buf[0]-'0'].V.push_back(Cell(row,col));\n\n\t\t\t}else if(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[number[g]].discount = d;\n\t\tinfo[number[g]].start = s;\n\t\tinfo[number[g]].end = e;\n\t}\n\n\tcalc_dist();\n\n\tlimit = POW[item_num];\n\n\tMAP.clear();\n\n\tprintf(\"%d\\n\",dfs(0,start_row,start_col,0));\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \nint w, h, n;\nchar mas[20][20];\n  \ntypedef pair< int , int > Pi;\ntypedef pair< Pi , Pi > Piii;\nPi p;\n  \nstruct sell{\n  int d; //値引き額\n  int s; //開始時刻\n  int e; //終了時刻\n};\nsell shop[10];\n  \nint min_cost[20][20][1 << 10];\n  \nint bfs(){\n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)\n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n  \n  memset( min_cost, -1, sizeof(min_cost));\n  que.push( Piii( Pi( 0, 0), p));\n  min_cost[p.second][p.first][0] = 0;\n  \n  int ret = 0;\n  \n  while(!que.empty()){\n  \n    Piii p = que.front(); que.pop();\n  \n    Pi point = p.second;\n    int bit = p.first.first, time = p.first.second;\n  \n      \n    if(ret < min_cost[point.second][point.first][bit]){\n      ret = min_cost[point.second][point.first][bit];\n    }\n  \n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n  \n      if(isdigit(mas[ny][nx])){\n          \n        int time_sell = mas[ny][nx] - '0';\n  \n        if(!((bit >> time_sell) & 1)){\n            \n          sell se = shop[time_sell];\n  \n          if(se.s > time){ //待ってプッシュ\n            que.push( Piii( Pi( bit, se.s), point));\n          } else if(se.s <= time && time < se.e){ //時間内だったら買ってみる\n            int next_bit = bit | (1 << time_sell);\n            if(min_cost[point.second][point.first][bit] + se.d > min_cost[point.second][point.first][next_bit]){\n              que.push( Piii( Pi( next_bit, time), point));\n              min_cost[point.second][point.first][next_bit] = min_cost[point.second][point.first][bit] + se.d;\n            }\n          }\n        }\n  \n      } else {\n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){\n          que.push( Piii( Pi( bit, time + 1), Pi( nx, ny)));\n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];\n        }\n      }\n    }\n  }\n  return ret;\n}\n  \nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') p = Pi( j, i);\n      }\n    }\n    cin >> n;\n  \n    for(int i= 0; i < n; i++){\n      int g;\n      cin >> g;\n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;\n    }\n  \n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n  int g, d, s, e;\n  S(){}\n  S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n  int y, x, used, t, sum;\n  State(){}\n  State(int y, int x, int used, int t, int sum) : y(y), x(x), used(used), t(t), sum(sum) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n  bool vis[20][20][1<<10];\n  fill(vis[0][0], vis[20][0], false);\n  State u, v;\n  u = State(sy, sx, 0, 0, 0);\n  queue<State> q;\n  q.push(u);\n  vis[u.y][u.x][u.used] = true;\n  int res = 0;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(mapData[ny][nx] != '.'){\n        int num = conv[mapData[ny][nx] - '0'];\n        if(u.t < data[num].e && !((1 << num) & u.used)){\n          if(u.t >= data[num].s){\n            v.y = u.y;\n            v.x = u.x;\n            v.used = u.used | (1<<num);\n            v.t = u.t;\n            v.sum = u.sum + data[num].d;\n            res = max(res, v.sum);\n            if(!vis[v.y][v.x][v.used]){\n              vis[v.y][v.x][v.used] = true;\n              q.push(v);\n            }\n          }else q.push(State(u.y, u.x, u.used, data[num].s, u.sum));\n        }\n      }else{\n        if(!vis[ny][nx][u.used]){\n          vis[ny][nx][u.used] = true;\n          q.push(State(ny, nx, u.used, u.t+1, u.sum));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    conv.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'P'){\n          mapData[i][j] = '.';\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      data[i] = S(a, b, c, d);\n      conv[a] = i;\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cctype>\nusing namespace std;\ntypedef pair< int , int > Pt;\ntypedef pair< pair<int , Pt > , Pt > P; // Pt(cost,bit) , Pt(y,x)\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nconst int dx[] = { 0, 1, -1, 0}, dy[] = { 1, 0, 0, -1};\nstruct edge{\n  int prime,st,ed;\n  edge(){};\n  edge(int prime,int st,int ed):prime(prime),st(st),ed(ed){};\n};\nedge info[10];\nint x, y;\nchar mas[20][20];\nbool no_over(int ny,int nx){\n  return ny >= 0 && ny < y && nx >= 0 && nx < x;\n}\nint Dijkstra(Pt& start){\n  int ret = 0;\n  bool used[20][20][1<<10];\n  fill_n(used[0][0],20*20*(1<<10),false);\n  priority_queue< P , vector<P> , greater<P> > que;\n  que.push(P(make_pair(0,Pt((1<<10)-1,0)),start));\n  used[start.fr][start.sc][(1<<10)-1] = true;\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    //if(used[p.sc.fr][p.sc.sc][p.fr.sc.fr]++) continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n      if(!no_over(ny,nx)) continue;\n      if(isdigit(mas[ny][nx])){\n        edge e = info[mas[ny][nx]-'0'];\n        int no = mas[ny][nx] - '0';\n        ny = p.sc.fr, nx = p.sc.sc;\n        if( !(p.fr.sc.fr >> no & 1) || p.fr.fr > e.ed) continue;\n        if(p.fr.fr <= e.ed){\n          ret = max(ret,p.fr.sc.sc + e.prime);\n          if(used[ny][nx][p.fr.sc.fr&~(1<<no)]++) continue;\n          que.push(P(make_pair(p.fr.fr,Pt(p.fr.sc.fr&~(1<<no),p.fr.sc.sc+e.prime)),Pt(ny,nx)));\n        }else que.push(P(make_pair(e.st,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }else{\n        if(used[ny][nx][p.fr.sc.fr]++) continue;\n        que.push(P(make_pair(p.fr.fr+1,Pt(p.fr.sc.fr,p.fr.sc.sc)),Pt(ny,nx)));\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> x >> y , x){\n    Pt st;\n    for(int i = 0 ; i < y ; i++ ){\n      for(int j = 0 ; j < x ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') st = Pt(i,j);\n      }\n    }\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; i++ ){\n      int g,d,s,e;\n      cin >> g >> d >> s >> e;\n      info[g] = edge(d,s,e);\n    }\n    cout << Dijkstra(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nchar board[30][30];\nint H, W, disc[10][105], rec[20][20][105][1 << 8];\n\nstruct Elem {\n    int x, y, time, bit, cost;\n    bool operator<(const Elem &e) const {\n        return cost < e.cost;\n    }\n};\n \nsigned main() {\n    while(cin >> W >> H, H || W) {\n        memset(disc, 0, sizeof(disc));\n        memset(rec, -1, sizeof(rec));\n        int sx = -1, sy = -1;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                cin >> board[i][j];\n                if(board[i][j] == 'P') sx = i, sy = j;\n            }\n        }\n\n        int N, lim = 0, ans = 0; cin >> N;\n        map<int, int> comp;\n        for(int i=0; i<N; i++) {\n            int g, d, s, e; cin >> g >> d >> s >> e;\n            comp[g]++;\n            chmax(lim, e + 1);\n            for(int k=s; k<e; k++) {\n                chmax(disc[g][k], d);\n            }\n        }\n\n        // ざあつ\n        int id = 0;\n        for(auto &x : comp) {\n            x.second = id++;\n        }\n        vector<int> inv(id);\n        for(auto x : comp) {\n            inv[x.second] = x.first;\n        }\n\n        // cand の部分集合\n        vector< vector<int> > sum(1 << id, vector<int>(lim));\n        for(int bit=0; bit<(1<<id); bit++) {\n            for(int i=0; i<id; i++) {\n                if(bit >> i & 1) {\n                    int orig_id = inv[i];\n                    for(int t=0; t<lim; t++) {\n                        sum[bit][t] += disc[orig_id][t];\n                    }\n                }\n            }\n        }\n\n        priority_queue<Elem> que;\n        que.push(Elem{sx, sy, 0, 0, 0});\n        rec[sx][sy][0][0] = 0;\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.x, y = cur.y, bit = cur.bit, time = cur.time, cost = cur.cost;\n            chmax(ans, cost);\n            if(cost < rec[x][y][time][bit] || time >= lim) continue;\n\n            // 商品を取る\n            int cand = 0;\n            for(int k=0; k<4; k++) {\n                int mx = x + dx[k], my = y + dy[k];\n                if(!(mx < 0 || mx >= H || my < 0 || my >= W) and ('0' <= board[mx][my] && board[mx][my] <= '9')) {\n                    int c = comp[ board[mx][my] - '0' ]; // 圧縮する\n                    if(bit >> c & 1) continue;\n                    cand |= (1 << c);\n                }\n            }\n\n            for(int mask=cand; mask>=0; mask=(mask-1)&cand) {\n                int nbit = bit | mask;\n                int ncost = cost + sum[mask][time];\n\n                // 移動先\n                for(int k=0; k<4; k++) {\n                    int nx = x + dx[k], ny = y + dy[k], ntime = time + 1;\n                    if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                    if('0' <= board[nx][ny] && board[nx][ny] <= '9') continue;\n\n                    if(rec[nx][ny][ntime][nbit] < ncost) {\n                        rec[nx][ny][ntime][nbit] = ncost;\n                        que.push(Elem{nx, ny, ntime, nbit, ncost});\n                    }\n                }\n\n                if(mask == 0) break;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n#define in(x, y) (0 <= (x) && (x) < w && 0 <= (y) && (y) < h)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nchar v[25][25];\nint item[110][25][25];\nint dp[2][25][25][1<<10];\nbool ok[1<<10];\n\nint value[10];\nint s[10], e[10];\n\nint dx[] = {0, 1, 0, -1, 0};\nint dy[] = {1, 0, -1, 0, 0};\nint main(){\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tMEMSET(item, 0);\n\t\tMEMSET(dp, 0);\n\t\tMEMSET(ok, 0);\n\t\trep(i, h) rep(j, w) cin >> v[i][j];\n\t\tint k;\n\t\tcin >> k;\n\t\trep(i, k){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcin >> value[x] >> s[x] >> e[x];\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(v[i][j] == 'P'){\n\t\t\t\tdp[0][i][j][0] = 1;\n\t\t\t\tv[i][j] ='.';\n\t\t\t}else if(v[i][j] != '.'){\n\t\t\t\tint x = v[i][j]-'0';\n\t\t\t\trep(d, 4){\n\t\t\t\t\tint nx = j+dx[d], ny = i+dy[d];\n\t\t\t\t\tif(!in(nx, ny)) continue;\n\t\t\t\t\tfor(int t = s[x]; t < e[x]; ++t) item[t][ny][nx] |= 1<<x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(t, 101) rep(y, h) rep(x, w) rep(k, 1<<10) rep(d, 5){\n\t\t\tif(!dp[t&1][y][x][k]) continue;\n\t\t\tint nx = x+dx[d], ny = y+dy[d];\n\t\t\tif(in(nx, ny) && (v[ny][nx] == '.')){\n\t\t\t\tint bits = k|item[t+1][ny][nx]|item[t][y][x];\n\t\t\t\tdp[(t+1)&1][ny][nx][bits] = 1;\n\t\t\t\tok[bits] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, 1<<10){\n\t\t\tif(ok[i]){\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(j, 10){\n\t\t\t\t\tif(i&(1<<j)) tmp += value[j];\n\t\t\t\t}\n\t\t\t\tans = max(ans, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        visited[0][0][sy][sx] = 0;\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(p.t>100)continue;\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n \n\nstruct P\n{\n\tint x, y, t, S;\n\tP(int x, int y, int t, int S)\n\t\t: x(x), y(y), S(S) { }\n};\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint h, w;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tint sx, sy;\n\t\tchar c[32][32];\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tcin >> c[y][x];\n\t\t\t\tif (c[y][x] == 'P')\n\t\t\t\t\tsx = x, sy = y, c[y][x] = '.';\n\t\t\t}\n\t\t}\n\n\t\tint info[16][128];\t// item, time\n\t\tint g[16], d[16];\n\t\tCL(info, 0);\n\t\tint m;\n\t\tcin >> m;\n\t\tint last_e = -1;\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint s, e;\n\t\t\tcin >> g[i] >> d[i] >> s >> e;\n\t\t\tmax_swap(last_e, e);\n\t\t\tfor (int t = s; t < e; ++t)\n\t\t\t\tinfo[g[i]][t] |= 1 << i;\n\t\t}\n\n\t\tstatic bool dp[101][20][20][1 << 8];\n\t\tfor (int i = 0; i <= last_e; ++i)\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t\tfor (int s = 0; s < 1 << m; ++s)\n\t\t\t\t\t\tdp[i][y][x][s] = false;\n\n\t\tconst int dx[] = { 0, 1, 0, -1, 0 };\n\t\tconst int dy[] = { 1, 0, -1, 0, 0 };\n\n\t\tdp[0][sy][sx][0] = true;\n\t\tfor (int t = 0; t < last_e; ++t)\n\t\t{\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t{\n\t\t\t\t\tint add_S = 0;\n\t\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\t\t\tif (valid_pos(tx, ty, w, h) && isdigit(c[ty][tx]))\n\t\t\t\t\t\t\tadd_S |= info[c[ty][tx] - '0'][t];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < 5; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\t\t\tif (valid_pos(nx, ny, w, h) && !isdigit(c[ny][nx]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int S = 0; S < 1 << m; ++S)\n\t\t\t\t\t\t\t\tdp[t + 1][ny][nx][S | add_S] |= dp[t][y][x][S];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tfor (int S = 0; S < 1 << m; ++S)\n\t\t\t\t{\n\t\t\t\t\tif (dp[last_e][y][x][S])\n\t\t\t\t\t{\n\t\t\t\t\t\tint dis[16];\n\t\t\t\t\t\tCL(dis, 0);\n\t\t\t\t\t\tfor (int i = 0; i < m; ++i)\n\t\t\t\t\t\t\tif (S >> i & 1)\n\t\t\t\t\t\t\t\tmax_swap(dis[g[i]], d[i]);\n\n\t\t\t\t\t\tmax_swap(res, accumulate(dis, dis + 16, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cctype>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\nstruct state {\n  int x,y,u,t,c;\n  state(){}\n  state(int x,int y,int u,int t,int c):x(x),y(y),u(u),t(t),c(c){}\n};\n\nint cost[20][20][1<<8][100];\nchar g[20][20],gt[20][20];\nint n,v[8],d[8],s[8],e[8];\nint w,h;\nint dx[]={0,1,0,-1,0},dy[]={1,0,-1,0,0};\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d\",&w,&h); if(w+h == 0)break;\n    int x,y; x = y = -1;\n    for( int i = 0; i < h; i++ ) {\n      for( int j = 0; j < w; j++ ) {\n        scanf(\" %c\",g[i]+j);\n        if( g[i][j] == 'P' ) {\n          g[i][j] = '.';\n          x = j;\n          y = i;\n        }\n      }\n    }\n    memcpy(gt,g,sizeof(gt));\n    for( int i = 0; i < h; i++ ) {\n      for( int j = 0; j < w; j++ ) {\n        if( isdigit(g[i][j]) ) {\n          g[i][j] = '#';\n        }\n      }\n    }\n    assert(x>=0 && y>=0);\n    scanf(\"%d\",&n);\n    int id[10],ct=0; memset(id,-1,sizeof(id));\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%d%d%d%d\",v+i,d+i,s+i,e+i);\n      if( id[v[i]] < 0 ) {\n        id[v[i]] = ct;\n        for( int j = 0; j < h; j++ ) {\n          for( int k = 0; k < w; k++ ) {\n            if( gt[j][k] == v[i]+'0' ) g[j][k] = ct+'0';\n          }\n        }\n        ct += 1;\n      }\n      v[i] = id[v[i]];\n    }\n    int res = 0;\n    queue<state> q;\n    q.push(state(x,y,0,0,0));\n    memset(cost,-1,sizeof(cost));\n    while( !q.empty() ) {\n      state p = q.front(); q.pop();\n      //printf(\"%d %d %02x %d %d\\n\",p.x,p.y,p.u,p.t,p.c);\n      if( p.t >= 100 ) continue;\n      if( res < p.c ) res = p.c;\n      for( int i = 0; i < 4; i++ ) {\n        x = p.x+dx[i];\n        y = p.y+dy[i];\n        if( x < 0 || x >= w || y < 0 || y >= h ) continue;\n        if( isdigit(g[y][x]) ) {\n          int k = g[y][x]-'0';\n          if( !(p.u>>k&1) ) {\n            for( int j = 0; j < n; j++ ) {\n              if( s[j] <= p.t && p.t < e[j] && v[j] == k ) {\n                if( cost[p.y][p.x][p.u|1<<k][p.t] < p.c+d[j] ) {\n                  cost[p.y][p.x][p.u|1<<k][p.t] = p.c+d[j];\n                  q.push(state(p.x,p.y,p.u|1<<k,p.t,p.c+d[j]));\n                }\n              }\n            }\n          }\n        }\n        if( g[y][x] == '.' && cost[y][x][p.u][p.t+1] < p.c ) {\n          cost[y][x][p.u][p.t+1] = p.c;\n          q.push(state(x,y,p.u,p.t+1,p.c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct node{\n\tint x,y,bit,t;\n\tnode(int x,int y,int bit,int t) : x(x) , y(y) , bit(bit) , t(t) {}\n};\n\nint x,y;\nint sx,sy;\nint n;\nchar c[22][22];\nint num[10],d[10],s[10],e[10];\nint value[1<<10];\nint done[22][22][1<<10][102];\nint dx[5]={0,0,1,-1,0},dy[5]={1,-1,0,0,0};\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tqueue<node> que;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j=0;j<=21;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tcin >> c[j][i];\n\t\t\t\tif(c[j][i]=='P'){\n\t\t\t\t\tque.push(node(j,i,0,0));\n\t\t\t\t\tc[j][i]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tscanf(\"%d%d%d\",&d[a],&s[a],&e[a]);\n\t\t}\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n                value[i]+=(i>>j&1)*d[j];\n            }\n            //cout << value[i] << \" \" << i << endl;\n        }\n\t\tmemset(done,0,sizeof(done));\n\t\tint ans=0;\n\t\twhile(que.size()){\n\t\t\tnode q=que.front();que.pop();\n\t\t\tif(q.t>100)continue;\n\t\t\tif(c[q.x][q.y]!='.')continue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint tx=q.x+dx[i];\n\t\t\t\tint ty=q.y+dy[i];\n\t\t\t\tif(c[tx][ty]>='0' && c[tx][ty]<='9'){\n\t\t\t\t\tint idx=c[tx][ty]-'0';\n\t\t\t\t\tif(s[idx]<=q.t && q.t<e[idx])q.bit |= 1<<idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(done[q.x][q.y][q.bit][q.t]++)continue;\n\t\t\tans=max(ans,value[q.bit]);\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tque.push(node(q.x+dx[i],q.y+dy[i],q.bit,q.t+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\trep(y, h) rep(x, w) rep(t, 100) rep(m, 1<<n)\n\t\t\tvisited[y][x][t][m] = false;\n\t\t\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && sale[i].s<=d.t && d.t<sale[i].e)\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 100 || visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\n\t\t\tQ.push(Data(d.y, d.x, d.t+1, d.mask));\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nstruct node{\n\tint x,y,bit,t;\n\tnode(int x,int y,int bit,int t) : x(x) , y(y) , bit(bit) , t(t) {}\n};\n\nint x,y;\nint sx,sy;\nint n;\nchar c[22][22];\nint num[10],d[10],s[10],e[10];\nint value[1<<10];\nint done[22][22][1<<10][102];\nint dx[5]={0,0,1,-1,0},dy[5]={1,-1,0,0,0};\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tqueue<node> que;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j=0;j<=21;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tcin >> c[j][i];\n\t\t\t\tif(c[j][i]=='P'){\n\t\t\t\t\tque.push(node(j,i,0,0));\n\t\t\t\t\tc[j][i]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tscanf(\"%d%d%d\",&d[a],&s[a],&e[a]);\n\t\t}\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n                value[i]+=(i>>j&1)*d[j];\n            }\n            //cout << value[i] << \" \" << i << endl;\n        }\n\t\tmemset(done,0,sizeof(done));\n\t\tint ans=0;\n\t\twhile(que.size()){\n\t\t\tnode q=que.front();que.pop();\n\t\t\tif(q.t>100)continue;\n\t\t\tif(c[q.x][q.y]!='.')continue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint tx=q.x+dx[i];\n\t\t\t\tint ty=q.y+dy[i];\n\t\t\t\tif(c[tx][ty]>='0' && c[tx][ty]<='9'){\n\t\t\t\t\tint idx=c[tx][ty]-'0';\n\t\t\t\t\tif(s[idx]<=q.t && q.t<e[idx])q.bit |= 1<<idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(done[q.x][q.y][q.bit][q.t]++)continue;\n\t\t\tans=max(ans,value[q.bit]);\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tque.push(node(q.x+dx[i],q.y+dy[i],q.bit,q.t+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nstruct Info {\n  int d, s, e;\n  Info(int d, int s, int e) : d(d), s(s), e(e) {}\n  Info() {}\n};\n\nchar field[22][22];\nint dp[101][1 << 8][22][22];\nint good[22][22];\nInfo info[10];\nint X, Y, N, SX, SY, E;\nint mp[10];\n\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nvoid init() {\n  E = 0;\n  for (int i = 0; i < 10; i++) {\n    mp[i] = -1;\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      field[i][j] == '*';\n    }\n  }\n  for (int i = 0; i < 22; i++) {\n    for (int j = 0; j < 22; j++) {\n      good[i][j] == 0;\n    }\n  }\n  \n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < (1 << 8); j++) {\n      for (int k = 0; k < 22; k++) {\n        for (int l = 0; l < 22; l++) {\n          dp[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve() {\n  {\n    int t = 0;\n    int s = 0;\n    for (int g = 0; g < N; g++) {\n      if ((good[SY][SX] & (1 << g)) &&\n          info[g].s <= 0 &&\n          0 < info[g].e ) {\n        t += info[g].d;\n        s |= (1 << g);\n      }\n    }\n    dp[0][s][SY][SX] = t;\n  }\n  for (int time = 0; time < E; time++) {\n    for (int y = 1; y <= Y; y++) {\n      for (int x = 1; x <= X; x++) {\n        for (int state = 0; state < (1 << N); state++) {\n          int v = dp[time][state][y][x];\n          if (v < 0) {\n            continue;\n          }\n          for (int i = 0; i < 5; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (field[ny][nx] != '.') {continue;}\n            dp[time + 1][state][ny][nx] =\n              max(dp[time + 1][state][ny][nx], v);\n\n            if (good[ny][nx] != 0) {\n              int t = 0;\n              int s = 0;\n              for (int g = 0; g < N; g++) {\n                if ((good[ny][nx] & (1 << g)) &&\n                    !(state & (1 << g)) &&\n                    info[g].s <= time + 1 &&\n                    time + 1 < info[g].e) {\n                  t += info[g].d;\n                  s |= (1 << g);\n                }\n              }\n              assert(!(state & s));\n              if (t != 0) {\n                dp[time + 1][state | s][ny][nx] =\n                  max(dp[time + 1][state | s][ny][nx], v + t);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int mx = 0;\n  for (int y = 1; y <= Y; y++) {\n    for (int x = 1; x <= X; x++) {\n      for (int s = 0; s < (1 << N); s++) {\n        mx = max(mx, dp[E][s][y][x]);\n      }\n    }\n  }\n  cout << mx << endl;\n}\n\nvoid print() {\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%d \", good[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for (int i = 1; i <= Y; i++) {\n    for (int j = 1; j <= X; j++) {\n      printf(\"%c \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> X >> Y;\n    if (X == 0 && Y == 0) {\n      return 0;\n    }\n    init();\n    int cur = 0;\n    for (int i = 1; i <= Y; i++) {\n      for (int j = 1; j <= X; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == 'P') {\n          SX = j;\n          SY = i;\n          field[i][j] = '.';\n        }\n        else if (field[i][j] != '.') {\n          int num = field[i][j] - '0';\n          if (mp[num] == -1) {\n            mp[num] = cur++;\n          }\n          field[i][j] = mp[num] + '0';\n          for (int k = 0; k < 4; k++) {\n            int nx = dx[k] + j;\n            int ny = dy[k] + i;\n            if (field[ny][nx] == '*') {continue;}\n            good[ny][nx] |= (1 << (mp[num]));\n          }\n        }\n\n      }\n    }\n    //print();\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int g, d, s, e;\n      cin >> g >> d >> s >> e;\n      info[mp[g]] = Info(d, s, e);\n      E = max(e, E);\n    }\n    assert(N == cur);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w, h, n;\nchar mas[20][20];\n\ntypedef pair< int , int > Pi;\ntypedef pair< Pi , Pi > Piii;\nPi p;\n\nstruct sell{\n  int g; //番号\n  int d; //値引き額\n  int s; //開始時刻\n  int e; //終了時刻\n};\nsell shop[10];\n\nint time_max;\n\nint min_cost[20][20][1 << 10];\n\nint bfs(){\n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)\n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n\n  memset( min_cost, -1, sizeof(min_cost));\n  que.push( Piii( Pi( 0, 0), p));\n  min_cost[p.second][p.first][0] = 0;\n\n  int ret = 0;\n\n  while(!que.empty()){\n\n    Piii p = que.front(); que.pop();\n\n    Pi point = p.second;\n    int bit = p.first.first, time = p.first.second;\n\n    \n    if(ret < min_cost[point.second][point.first][bit]){\n      ret = min_cost[point.second][point.first][bit];\n    }\n    if(time_max + 1 <= time /*|| bit == (1 << n) - 1 */){\n      continue;\n    }\n\n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n\n      int next_time = time + 1;\n\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\n      if(isdigit(mas[ny][nx])){\n        \n        int time_sell = mas[ny][nx] - '0';\n\n        if(!((bit >> time_sell) & 1)){\n          \n          sell se = shop[time_sell];\n\n          if(se.s > next_time){ //待ってプッシュ\n\n            que.push( Piii( Pi( bit, se.s - 1), point));\n\n          } else if(se.s <= next_time && next_time <= se.e){ //時間内だったら買ってみる\n\n            int next_bit = bit | (1 << time_sell);\n            if(min_cost[point.second][point.first][bit] + se.d > min_cost[point.second][point.first][next_bit]){\n              que.push( Piii( Pi( next_bit, next_time - 1), point));\n              min_cost[point.second][point.first][next_bit] = min_cost[point.second][point.first][bit] + se.d;\n            }\n          }\n        }\n\n      } else {\n        if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){\n          que.push( Piii( Pi( bit, next_time), Pi( nx, ny)));\n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') p = Pi( j, i);\n      }\n    }\n    cin >> n;\n    \n    time_max = 0;\n\n    for(int i= 0; i < n; i++){\n      cin >> shop[i].g >> shop[i].d >> shop[i].s >> shop[i].e;\n      time_max = max( shop[i].e, time_max);\n    }\n\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \nint w, h, n;\nchar mas[20][20];\n  \ntypedef pair< int , int > Pi;\ntypedef pair< Pi , Pi > Piii;\nPi p;\n  \nstruct sell{\n  int d; //値引き額\n  int s; //開始時刻\n  int e; //終了時刻\n};\nsell shop[10];\n  \nint min_cost[20][20][1 << 10];\n  \nint bfs(){\n  queue< Piii > que; // Pii( (買った商品, 今の時間), 座標)\n  const int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n  \n  memset( min_cost, -1, sizeof(min_cost));\n  que.push( Piii( Pi( 0, 0), p));\n  min_cost[p.second][p.first][0] = 0;\n  \n  int ret = 0;\n  \n  while(!que.empty()){\n  \n    Piii p = que.front(); que.pop();\n  \n    Pi point = p.second;\n    int bit = p.first.first, time = p.first.second;\n  \n    \n    if(ret < min_cost[point.second][point.first][bit]){\n      ret = min_cost[point.second][point.first][bit];\n    }\n  \n    for(int i = 0; i < 4; i++){\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n  \n      if(isdigit(mas[ny][nx])){\n          \n        int time_sell = mas[ny][nx] - '0';\n  \n        if(!((bit >> time_sell) & 1)){\n            \n          sell& se = shop[time_sell];\n  \n          if(time < se.e){ //時間内だったら買ってみる\n            int next_bit = bit | (1 << time_sell);\n            if(min_cost[point.second][point.first][bit] + se.d > min_cost[point.second][point.first][next_bit]){\n              que.push( Piii( Pi( next_bit, max( time, se.s)), point));\n              min_cost[point.second][point.first][next_bit] = min_cost[point.second][point.first][bit] + se.d;\n            }\n          }\n        }\n      } else if(min_cost[point.second][point.first][bit] > min_cost[ny][nx][bit]){\n          que.push( Piii( Pi( bit, time + 1), Pi( nx, ny)));\n          min_cost[ny][nx][bit] = min_cost[point.second][point.first][bit];\n      }\n    }\n  }\n  return ret;\n}\n  \nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'P') p = Pi( j, i);\n      }\n    }\n    cin >> n;\n  \n    for(int i= 0; i < n; i++){\n      int g;\n      cin >> g;\n      cin  >> shop[g].d >> shop[g].s >> shop[g].e;\n    }\n  \n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nstruct Data {\n\tint y, x, t, mask;\n\tData(int y, int x, int t, int m) : y(y), x(x), t(t), mask(m) {}\n};\n\nstruct Sale {\n\tint d, s, e;\n};\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nbool visited[20][20][100][1<<8];\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tchar field[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar c[4];\n\t\t\tscanf(\"%s\", c);\n\t\t\tfield[i][j] = c[0];\n\t\t}\n\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tint dict[10];\n\t\tfill(dict, dict+10, -1);\n\t\tSale sale[8];\n\t\trep(i, n){\n\t\t\tint g;\n\t\t\tscanf(\"%d%d%d%d\", &g, &sale[i].d, &sale[i].s, &sale[i].e);\n\t\t\tdict[g] = i;\n\t\t\tif(sale[i].s == 100){\n\t\t\t\tassert(false);\n\t\t\t\tfor(;;);\n\t\t\t}\n\t\t}\n\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j])){\n\t\t\t\tint v = dict[field[i][j] - '0'];\n\t\t\t\tif(v == -1)\n\t\t\t\t\tfield[i][j] = 'x';\n\t\t\t\telse\n\t\t\t\t\tfield[i][j] = v + '0';\n\t\t\t}\n\t\t}\n\n\t\tint mask[20][20];\n\t\trep(i, h) rep(j, w){\n\t\t\tif(isdigit(field[i][j]) || field[i][j] == 'x')\n\t\t\t\tmask[i][j] = -1;\n\t\t\telse{\n\t\t\t\tmask[i][j] = 0;\n\t\t\t\trep(k, 4){\n\t\t\t\t\tint py = i + dy[k];\n\t\t\t\t\tint px = j + dx[k];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(isdigit(field[py][px]))\n\t\t\t\t\t\tmask[i][j] |= 1 << (field[py][px] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint money[1<<8];\n\t\trep(m, 1<<n){\n\t\t\tmoney[m] = 0;\n\t\t\trep(i, n){\n\t\t\t\tif((m>>i)&1)\n\t\t\t\t\tmoney[m] += sale[i].d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Data> Q;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 'P'){\n\t\t\t\tQ.push(Data(i, j, 0, 0));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n){\n\t\t\t\tif(((mask[d.y][d.x]>>i)&1) && sale[i].s<=d.t && d.t<sale[i].e)\n\t\t\t\t\td.mask |= 1 << i;\n\t\t\t}\n\t\t\tif(visited[d.y][d.x][d.t][d.mask])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.y][d.x][d.t][d.mask] = true;\n\t\t\tans = max(ans, money[d.mask]);\n\t\t\tif(d.t == 99)\n\t\t\t\tcontinue;\n\n\t\t\tQ.push(Data(d.y, d.x, d.t+1, d.mask));\n\t\t\trep(k, 4){\n\t\t\t\tint py = d.y + dy[k];\n\t\t\t\tint px = d.x + dx[k];\n\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || mask[py][px]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\tQ.push(Data(py, px, d.t+1, d.mask));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int d,get,y,x;\n    bool operator<(const State& right) const{\n        return d > right.d;\n    }\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,101);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        int d[(1<<10)][20][20];\n        for(int i=0;i<(1<<10);i++)for(int j=0;j<20;j++)for(int k=0;k<20;k++) d[i][j][k] = INF;\n        d[0][sy][sx] = 0;\n        priority_queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.top(); que.pop();\n            //printf(\"p.d=%d p.get=%d p.y=%d p.x=%d\\n\",p.d,p.get,p.y,p.x);\n            if(d[p.get][p.y][p.x]<p.d) continue;\n            ans = max(ans, de_sum[p.get]);\n            if(p.d==100)continue;\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                int nget = p.get, nd = p.d + 1;\n                for(int j=0;j<4;j++){\n                    int ny2 = ny + dy[j], nx2 = nx + dx[j];\n                    if(ny2<0||h<=ny2||nx2<0||w<=nx2||field[ny2][nx2]=='.'||field[ny2][nx2]=='P') continue;\n                    int g_i = field[ny2][nx2] - '0';\n                    if(st_i[g_i] <= nd && nd < et_i[g_i]){\n                        nget |= (1<<g_i);\n                    }\n                }\n                if(d[nget][ny][nx]>nd){\n                    d[nget][ny][nx] = nd;\n                    que.push((State){nd, nget, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[100][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,INF);\n        fill(et_i,et_i+10,-INF);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(p.t+1<100&&!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int t,get,y,x;\n};\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool visited[101][(1<<10)][20][20];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,0);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            //printf(\"p.t=%d p.get=%d p.y=%d p.x=%d\\n\",p.t,p.get,p.y,p.x);\n            if(visited[p.t][p.get][p.y][p.x]) continue;\n            visited[p.t][p.get][p.y][p.x] = true;\n            for(int j=0;j<4;j++){\n                int ny = p.y + dy[j], nx = p.x + dx[j];\n                if(ny<0||h<=ny||nx<0||w<=nx)continue;\n                if('0'<=field[ny][nx]&&field[ny][nx]<='9'){\n                    int g_i = field[ny][nx] - '0';\n                    if(st_i[g_i] <= p.t && p.t < et_i[g_i]){\n                        p.get |= (1<<g_i);\n                    }\n                }\n            }\n            ans = max(ans, de_sum[p.get]);\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                if(p.t+1<100&&!visited[p.t+1][p.get][ny][nx]){\n                    que.push((State){p.t+1, p.get, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n//typedef vector<int> vec;\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nstruct State{\n    int d,get,y,x;\n    bool operator<(const State& right) const{\n        return d > right.d;\n    }\n};\nconst int dx[] = {0,0,1,-1,0};\nconst int dy[] = {1,-1,0,0,0};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        mat field(h, vec(w));\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='P'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int de_sum[(1<<10)];\n        fill(de_sum, de_sum+(1<<10), 0);\n        int n;\n        cin >> n;\n        int st_i[10], et_i[10];\n        fill(st_i,st_i+10,101);\n        fill(et_i,et_i+10,101);\n        for(int i=0;i<n;i++){\n            int go, de, st, et;\n            scanf(\"%d%d%d%d\", &go, &de, &st, &et);\n            st_i[go] = st; et_i[go] = et;\n            for(int j=1;j<(1<<10);j++){\n                if((j>>go)&1){\n                    de_sum[j] += de;\n                }\n            }\n        }\n\n        int d[(1<<10)][20][20];\n        for(int i=0;i<(1<<10);i++)for(int j=0;j<20;j++)for(int k=0;k<20;k++) d[i][j][k] = INF;\n        d[0][sy][sx] = 0;\n        priority_queue<State> que;\n        que.push((State){0,0,sy,sx});\n        int ans = 0;\n        while(que.size()){\n            State p = que.top(); que.pop();\n            //printf(\"p.d=%d p.get=%d p.y=%d p.x=%d\\n\",p.d,p.get,p.y,p.x);\n            if(d[p.get][p.y][p.x]<p.d) continue;\n            ans = max(ans, de_sum[p.get]);\n            if(p.d==100)continue;\n            for(int i=0;i<5;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                if(ny<0||h<=ny||nx<0||w<=nx||field[ny][nx]!='.') continue;\n                int nget = p.get, nd = p.d + 1;\n                for(int j=0;j<4;j++){\n                    int ny2 = ny + dy[j], nx2 = nx + dx[j];\n                    if(ny2<0||h<=ny2||nx2<0||w<=nx2||field[ny2][nx2]=='.'||field[ny2][nx2]=='P') continue;\n                    int g_i = field[ny2][nx2] - '0';\n                    if(st_i[g_i] <= nd && nd < et_i[g_i]){\n                        nget |= (1<<g_i);\n                    }\n                }\n                if(d[nget][ny][nx]>nd){\n                    d[nget][ny][nx] = nd;\n                    que.push((State){nd, nget, ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nconst static int tx[4] = {+0,+1,+0,-1};\nconst static int ty[4] = {-1,+0,+1,+0};\n\nbool dp[21][21][101][1<<10];\n\nclass State{\npublic:\n  int x;\n  int y;\n  int time;\n  int got;\n  bool operator<(const State& s) const {\n    return time < s.time;\n  }\n  bool operator>(const State& s) const {\n    return time > s.time;\n  }\n  State(int x,int y,int time,int got) \n    : x(x), y(y), time(time), got(got){}\n};\n\nclass Goods{\npublic:\n  int item_id;\n  int discounted_price;\n  int sale_start_time;\n  int sale_end_time;\n  Goods(int item_id,int discounted_price, int sale_start_time,int sale_end_time)\n    : item_id(item_id),discounted_price(discounted_price),sale_start_time(sale_start_time), sale_end_time(sale_end_time){}\n  Goods(){}\n};\n\nint main(){\n  int W,H;\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    char stage[21][21];\n    memset(dp,false,sizeof(dp));\n    int sx,sy;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        char cell[8];\n        scanf(\"%s\",cell);\n        stage[y][x] = cell[0];\n        if(stage[y][x] == 'P'){\n          sy = y;\n          sx = x;\n        }\n      }\n    }\n    int total_time_sales;\n    scanf(\"%d\",&total_time_sales);\n\n    map<int,Goods> goods;\n    for(int i = 0; i < total_time_sales; i++){\n      int item_id;\n      int discounted_price;\n      int sale_start_time;\n      int sale_end_time;\n      scanf(\"%d %d %d %d\",\n            &item_id,\n            &discounted_price,\n            &sale_start_time,\n            &sale_end_time);\n      goods[item_id] = Goods(item_id,discounted_price,sale_start_time,sale_end_time);\n    }\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0));\n    dp[sx][sy][0][0] = true;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int i = 0; i < 4; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(stage[dy][dx] == '.' || stage[dy][dx] == 'P') continue;\n        const Goods& g = goods[stage[dy][dx] - '0'];\n        if(g.sale_start_time <= s.time && s.time < g.sale_end_time){\n          s.got |= (1 << g.item_id);\n        }\n      }\n\n      for(int i = 0; i < 4; i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if(stage[dy][dx] != '.' && stage[dy][dx] != 'P') continue;\n        if(dp[dx][dy][s.time+1][s.got]) continue;\n        if(s.time+1 > 100) continue;\n        dp[dx][dy][s.time+1][s.got] = true;\n        que.push(State(dx,dy,s.time+1,s.got));\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        for(int time = 0; time <= 100; time++){\n          for(int S = 0; S < (1<<10); S++){\n            if(dp[x][y][time][S]){\n              int sum = 0;\n              for(int i = 0; i < 10; i++){\n                if(S & (1<<i)){\n                  sum += goods[i].discounted_price;\n                }\n              }\n              res = max(res,sum);\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Cell{\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Cell &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Info{\n\tint discount,start,end;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_total_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttotal_dist = arg_total_dist;\n\t}\n\n\tint row,col,total_dist;\n};\n\nstruct SALE{\n\tSALE(){\n\t\tstate = time = row = col = sum_discount = 0;\n\t}\n\n\tSALE(int arg_state,int arg_time,int arg_row,int arg_col,int arg_sum_discount){\n\t\tstate = arg_state;\n\t\ttime = arg_time;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_discount = arg_sum_discount;\n\t}\n\tbool operator<(const struct SALE &arg) const{\n\t\tif(time != arg.time){\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn sum_discount < arg.sum_discount;\n\t\t}\n\t};\n\n\tvoid copyArray(SALE arg){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tvisited[i] = arg.visited[i];\n\t\t}\n\t}\n\n\tint state,time,row,col,sum_discount;\n\tbool visited[10];\n};\n\nint W,H;\nint POW[11];\nint dp[1024][20][20];\nInfo info[10];\nbool is_sale[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nchar base_map[20][21];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\n\nvoid func(){\n\n\tchar buf[2];\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tbase_map[row][col] = buf[0];\n\t\t\tif(buf[0] == 'P'){\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint g,d,s,e;\n\n\tfor(int i = 0; i < 10; i++)is_sale[i] = false;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d %d\",&g,&d,&s,&e);\n\n\t\tinfo[g].discount = d;\n\t\tinfo[g].start = s;\n\t\tinfo[g].end = e;\n\n\t\tis_sale[g] = true;\n\t}\n\n\t/*for(int i = 0; i < item_num; i++){\n\n\t\tprintf(\"??????%d(??????%d) \",i,rev_number[i]);\n\t\tif(is_sale[i]){\n\t\t\tprintf(\"???????????????\\n\");\n\t\t\tprintf(\"dis:%d start:%d end:%d\\n\",info[i].discount,info[i].start,info[i].end);\n\t\t}else{\n\t\t\tprintf(\"?????????????????????\\n\");\n\t\t}\n\n\t}\n*/\n\n\tint limit = POW[10];\n\n\tfor(int state = 0; state < limit; state++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tdp[state][row][col] = BIG_NUM; //????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<SALE> Q;\n\n\tdp[0][start_row][start_col] = 0;\n\n\tSALE first;\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.state = 0;\n\tfirst.sum_discount = 0;\n\tfirst.time = 0;\n\tfor(int i = 0; i < 10; i++)first.visited[i] = false;\n\n\tQ.push(first);\n\tint max_value = 0;\n\n\twhile(!Q.empty()){\n\n\t\tmax_value = max(max_value,Q.top().sum_discount);\n\n\t\tif(Q.top().time > dp[Q.top().state][Q.top().row][Q.top().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] == '.'){ //???????????´???\n\n\t\t\t\t\tif(dp[Q.top().state][adj_row][adj_col] > Q.top().time+1){\n\t\t\t\t\t\tdp[Q.top().state][adj_row][adj_col] = Q.top().time+1;\n\n\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\tnext_sale.row = adj_row;\n\t\t\t\t\t\tnext_sale.col = adj_col;\n\t\t\t\t\t\tnext_sale.state = Q.top().state;\n\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount;\n\t\t\t\t\t\tnext_sale.time = Q.top().time+1;\n\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\n\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t}\n\t\t\t\t}else if(base_map[adj_row][adj_col] >= '0' && base_map[adj_row][adj_col] <= '9'){\n\n\t\t\t\t\tint adj_item = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t\tif(Q.top().visited[adj_item] == true || is_sale[adj_item] == false || info[adj_item].end < Q.top().time)continue;\n\n\t\t\t\t\tint next_state = Q.top().state + POW[adj_item];\n\n\t\t\t\t\tif(Q.top().time >= info[adj_item].start && Q.top().time <= info[adj_item].end){ //??????????§??????????????????§?????????????????????\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > Q.top().time){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = Q.top().time;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = Q.top().time;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(Q.top().time < info[adj_item].start){\n\n\t\t\t\t\t\tif(dp[next_state][Q.top().row][Q.top().col] > info[adj_item].start){\n\n\t\t\t\t\t\t\tdp[next_state][Q.top().row][Q.top().col] = info[adj_item].start;\n\t\t\t\t\t\t\tSALE next_sale;\n\t\t\t\t\t\t\tnext_sale.row = Q.top().row;\n\t\t\t\t\t\t\tnext_sale.col = Q.top().col;\n\t\t\t\t\t\t\tnext_sale.state = next_state;\n\t\t\t\t\t\t\tnext_sale.sum_discount = Q.top().sum_discount+info[adj_item].discount;\n\t\t\t\t\t\t\tnext_sale.time = info[adj_item].start;\n\t\t\t\t\t\t\tnext_sale.copyArray(Q.top());\n\t\t\t\t\t\t\tnext_sale.visited[adj_item] = true;\n\n\t\t\t\t\t\t\tQ.push(next_sale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_value);\n}\n\n\nint main(){\n\n\tfor(int i = 0; i <= 10; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass S{\npublic:\n   int g, d, s, e;\n   S(){}\n   S(int g, int d, int s, int e) : g(g), d(d), s(s), e(e) {}\n};\n\nclass State{\npublic:\n   int y, x, used, t;\n   State(){}\n   State(int y, int x, int used, int t) : y(y), x(x), used(used), t(t) {}\n};\n\nint w, h, n;\nchar mapData[20][20];\nmap<int, int> conv;\nS data[10];\nint sy, sx;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint bfs(){\n   bool vis[20][20][1<<8];\n   fill(vis[0][0], vis[20][0], false);\n   State u, v;\n   u = State(sy, sx, 0, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.y][u.x][u.used] = true;\n   while(!q.empty()){\n      u = q.front(); q.pop();\n      //cout << u.y << ' ' << u.x << ' ' << u.used << ' ' << u.t << endl;\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.'){\n            int num = conv[mapData[ny][nx] - '0'];\n            if(u.t < data[num].e && !((1 << num) & u.used)){\n               v.y = u.y;\n               v.x = u.x;\n               v.used = u.used | (1<<num);\n               v.t = max(u.t, data[num].s);\n               if(!vis[v.y][v.x][v.used]){\n                  vis[v.y][v.x][v.used] = true;\n                  q.push(v);\n               }\n            }\n         }\n      }\n      for(int i=0;i<4;i++){\n         int ny = u.y + dy[i];\n         int nx = u.x + dx[i];\n         if(ny<0 || ny>=h) continue;\n         if(nx<0 || nx>=w) continue;\n         if(mapData[ny][nx] != '.') continue;\n         if(!vis[ny][nx][u.used]){\n            vis[ny][nx][u.used] = true;\n            q.push(State(ny, nx, u.used, u.t+1));\n         }\n      }\n   }\n   int res = 0;\n   for(int k=0;k<(1<<8);k++){\n      bool f = false;\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            if(vis[i][j][k]){\n               f = true;\n               goto END;\n            }\n         }\n      }\n     END:;\n      if(f){\n         int sum = 0;\n         for(int i=0;i<8;i++){\n            if((1<<i) & k) sum += data[i].d;\n         }\n         res = max(res, sum);\n      }\n   }\n   return res;\n}\n\nmain(){\n   while(cin >> w >> h && (w|h)){\n      for(int i=0;i<h;i++){\n         for(int j=0;j<w;j++){\n            cin >> mapData[i][j];\n            if(mapData[i][j] == 'P'){\n               mapData[i][j] = '.';\n               sy = i;\n               sx = j;\n            }\n         }\n      }\n      cin >> n;\n      for(int i=0;i<n;i++){\n         int a, b, c, d;\n         cin >> a >> b >> c >> d;\n         data[i] = S(a, b, c, d);\n         conv[a] = i;\n      }\n      cout << bfs() << endl;\n   }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[22][22];\nchar mk[22][22][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2, max;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (t >= max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] & COR) {\n\t\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\ntypedef struct { int d, s, e; } G;\nG sell[10];\nsigned char map[21][21];\nchar mk[21][21][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, max, ans;\n\tint d, t, b, r2, c2;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tfor (r = 0; r < Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 0; c < X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = -1;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = -1;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X) continue;\n\t\t\t\tif ((j = map[r2][c2]) >= 0) {\n\t\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\t\td += sell[j].d;\n\t\t\t\t\t\tb |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X || map[r2][c2] >= 0) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 400000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\ntypedef struct { int d, s, e; } G;\nG sell[10];\nsigned char map[21][21];\nchar mk[21][21][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, max, ans;\n\tint d, t, b, r2, c2;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tfor (r = 0; r < Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 0; c < X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = -1;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = -1;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X) continue;\n\t\t\t\tif ((j = map[r2][c2]) >= 0) {\n\t\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\t\td += sell[j].d;\n\t\t\t\t\t\tb |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X || map[r2][c2] >= 0) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y && sq[k].z>cp.z)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[21][21];\nchar mk[21][21][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2, max, lim;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0, lim = (1 << n) - 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (b == lim) break;\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] != COR) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y && sq[k].f==cp.f)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[22][22];\nchar mk[22][22][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] & COR) {\n\t\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=1;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt+1){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\t//if(sq[k].x==cp.x && sq[k].y==cp.y && (sq[k].z>cp.z || sq[k].f==cp.f))break;\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y){\n\t\t\t\t\t\t\t\tif(cp.f>sq[k].f && !((~cp.f)&sq[k].f)){\n\t\t\t\t\t\t\t\t\tsq[k]=cp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(cp.f==sq[k].f)break;\n\t\t\t\t\t\t\t\tif(cp.f<sq[k].f && !(cp.f&(~sq[k].f)))break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\t//printf(\"%d\\n\",sqn);\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[22][22];\nchar mk[22][22][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2, max;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (d > ans) ans = d;\n\t\t\tif (t >= max) continue;\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] & COR) {\n\t\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[50000]; int top, end;\ntypedef struct { int d, s, e; } G;\nG sell[10];\nsigned char map[21][21];\nchar mk[21][21][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, max, ans;\n\tint d, t, b, r2, c2;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tfor (r = 0; r < Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 0; c < X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = -1;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = -1;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top++].b;\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X) continue;\n\t\t\t\tif ((j = map[r2][c2]) >= 0) {\n\t\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\t\td += sell[j].d;\n\t\t\t\t\t\tb |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X || map[r2][c2] >= 0) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end++].b = b;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[22][22];\nchar mk[22][22][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2, max, lim;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0, lim = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tlim |= 1 << j; if (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] != COR) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[200000]; int top, end;\ntypedef struct { int d, s, e; } G;\nG sell[10];\nsigned char map[21][21];\nchar mk[21][21][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, max, ans;\n\tint d, t, b, r2, c2;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tfor (r = 0; r < Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 0; c < X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = -1;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = -1;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top++].b;\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X) continue;\n\t\t\t\tif ((j = map[r2][c2]) >= 0) {\n\t\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\t\td += sell[j].d;\n\t\t\t\t\t\tb |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= Y || c2 < 0 || c2 >= X || map[r2][c2] >= 0) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end++].b = b;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt+1){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\t//if(sq[k].x==cp.x && sq[k].y==cp.y && (sq[k].z>cp.z || sq[k].f==cp.f))break;\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y){\n\t\t\t\t\t\t\t\tif(cp.f>sq[k].f && !((~cp.f)&sq[k].f)){\n\t\t\t\t\t\t\t\t\tsq[k]=cp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(cp.f==sq[k].f)break;\n\t\t\t\t\t\t\t\tif(cp.f<sq[k].f && !(cp.f&(~sq[k].f)))break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\t//printf(\"%d\\n\",sqn);\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[1000],sq[1000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y && sq[k].f==cp.f)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\tprintf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\tfunc2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\t//if(sq[k].x==cp.x && sq[k].y==cp.y && (sq[k].z>cp.z || sq[k].f==cp.f))break;\n\t\t\t\t\t\t\t//0111000\n\t\t\t\t\t\t\t//0011000\n\t\t\t\t\t\t\t//1000111\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y){\n\t\t\t\t\t\t\t\tif(cp.f>sq[k].f && !((~cp.f)&sq[k].f)){\n\t\t\t\t\t\t\t\t\tsq[k]=cp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(sq[k].z>cp.z || sq[k].f==cp.f)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\tprintf(\"%d\\n\",sqn);\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint ff[25][25][102][1<<10+1];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\tmemset(ff,0,sizeof(ff));\n\t\twhile(t<=mt+1){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*for(k=0;k<sqn;k++){\n\t\t\t\t\t\t\t//if(sq[k].x==cp.x && sq[k].y==cp.y && (sq[k].z>cp.z || sq[k].f==cp.f))break;\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y){\n\t\t\t\t\t\t\t\tif(cp.f>sq[k].f && !((~cp.f)&sq[k].f)){\n\t\t\t\t\t\t\t\t\tsq[k]=cp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(cp.f==sq[k].f)break;\n\t\t\t\t\t\t\t\tif(cp.f<sq[k].f && !(cp.f&(~sq[k].f)))break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif(ff[cp.x][cp.y][t][cp.f]++)continue;\n\t\t\t\t\t\tsq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\t//printf(\"%d\\n\",sqn);\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[22][22];\nchar mk[22][22][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2, max, lim;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0, lim = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tlim |= 1 << j; if (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\t\t\tif (++top == QMAX) top = 0;\n\n\t\t\tif (b == lim) break;\n\t\t\tif (t > max) continue;\n\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\t\t\tif (d > ans) ans = d;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] != COR) continue;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t+1, q[end].d = d, q[end].b = b;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0245: Time Sale\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { char r, c, t; int d, b; } Q;\nQ q[QMAX+2]; int top, end;\n\n#define WALL 64\n#define COR  32\n\ntypedef struct { int d, s, e; } G;\nG sell[10];\nchar map[22][22];\nchar mk[22][22][101][1024];\nchar buf[50], *p;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, r, c, n, i, j, sr, sc, ans;\n\tint d, t, b, r2, c2, max;\n\n\twhile (fgets(p=buf, 10, stdin) && *p != '0') {\n\t\tX = in(), Y = in();\n\t\tmemset(map, WALL, sizeof(map));\n\t\tfor (r = 1; r <= Y; r++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tfor (c = 1; c <= X; c++) {\n\t\t\t\tif (*p == '.') map[r][c] = COR;\n\t\t\t\telse if (*p == 'P') sr = r, sc = c, map[r][c] = COR;\n\t\t\t\telse map[r][c] = *p & 0xf;\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t}\n\t\tfgets(p=buf, 5, stdin);\n\t\tn = *p & 0xf, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tj = in();\n\t\t\tsell[j].d = in(), sell[j].s = in(), sell[j].e = t = in();\n\t\t\tif (t > max) max = t;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = 0, q[0].d = 0, q[0].b = 0;\n\t\ttop = 1;\n\t\twhile (top) {\n\t\t\tr = q[--top].r, c = q[top].c, t = q[top].t, d = q[top].d, b = q[top].b;\n\n\t\t\tif (d > ans) ans = d;\n\t\t\tif (t >= max) continue;\n\t\t\tif (mk[r][c][t][b]) continue;\n\t\t\tmk[r][c][t][b] = 1;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif ((j = map[r2][c2]) > 10) continue;\n\t\t\t\tif (!(b & (1 << j)) && sell[j].s <= t && t < sell[j].e) {\n\t\t\t\t\td += sell[j].d;\n\t\t\t\t\tb |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (map[r2][c2] & COR) {\n\t\t\t\t\tq[top].r = r2, q[top].c = c2, q[top].t = t+1, q[top].d = d, q[top++].b = b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX(x,y) ((x>y)?x:y)\ntypedef struct g{\n\tint d,s,e;\n}G;\nG a[12];\ntypedef struct p{\n\tint x,y,z,f;\n}P;\nP q[50000],sq[50000],cp;\nint qn,sqn;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar map[25][25];\nint func(int d,P p){\n\tp.x+=dx[d];p.y+=dy[d];\n\tint m=map[p.y][p.x]-'0';\n\tif(0<=m && m<=9 && !(p.f&(1<<m)))return m;\n\telse return -1;\n}\nvoid func2(int f){\n\tint i;\n\tfor(i=0;i<10;i++){\n\t\tif((f>>i)&1)printf(\"1\");\n\t\telse printf(\"0\");\n\t}\n\tprintf(\"\\n\");\n}\nint main(){\n\tint i,j,k,w,h,n,m,mt,t,ans;\n\tchar s;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\tfor(i=1;i<=w  ;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n\t\t\t\tif(map[i][j]=='P'){\n\t\t\t\t\tq[0]=(P){j,i,0,0};\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tmt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&m);\n\t\t\tscanf(\"%d%d%d\",&a[m].d,&a[m].s,&a[m].e);\n\t\t\tmt=MAX(mt,a[m].e);\n\t\t}\n\t\tqn=1;\n\t\tt=0;\n\t\tfor(i=0;i<4;i++){\n\t\t\tm=func(i,q[0]);\n\t\t\tif(m!=-1 && a[m].s<=0 && 0<a[m].e){\n\t\t\t\tq[0].z+=a[m].d;\n\t\t\t\tq[0].f=q[0].f|(1<<m);\n\t\t\t}\n\t\t}\n\t\twhile(t<=mt){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%2d %2d %3d \",q[i].x,q[i].y,q[i].z);\n\t\t\t\t//func2(q[i].f);\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tcp=q[i];\n\t\t\t\t\tcp.x+=dx[j];\n\t\t\t\t\tcp.y+=dy[j];\n\t\t\t\t\tif(map[cp.y][cp.x]=='.'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tm=func(k,cp);\n\t\t\t\t\t\t\tif(m!=-1 && a[m].s<=t && t<a[m].e){\n\t\t\t\t\t\t\t\tcp.z+=a[m].d;\n\t\t\t\t\t\t\t\tcp.f=cp.f|(1<<m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(k=0;k<sqn;k++){\n\t\t\t\t\t\t\t//if(sq[k].x==cp.x && sq[k].y==cp.y && (sq[k].z>cp.z || sq[k].f==cp.f))break;\n\t\t\t\t\t\t\tif(sq[k].x==cp.x && sq[k].y==cp.y){\n\t\t\t\t\t\t\t\tif(cp.f>sq[k].f && !((~cp.f)&sq[k].f)){\n\t\t\t\t\t\t\t\t\tsq[k]=cp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(cp.f==sq[k].f)break;\n\t\t\t\t\t\t\t\tif(cp.f<sq[k].f && !(cp.f&(~sq[k].f)))break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k==sqn)sq[sqn++]=cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t\tt++;\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tans=0;\n\t\t//printf(\"%d\\n\",sqn);\n\t\tfor(i=0;i<qn;i++)ans=MAX(ans,q[i].z);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint R, C;\n\tint[][] table;\n\n\tint[] gain;\n\tint[] start;\n\tint[] end;\n\n\tint[] totalGain;\n\n\tint startR;\n\tint startC;\n\n\tint[][][] item;\n\tboolean[][][][] vis;\n\n\tint[] dr = {0, 1, 0, -1, 0};\n\tint[] dc = {1, 0, -1, 0, 0};\n\n\tvoid solve() {\n\t\tC = sc.nextInt();\n\t\tR = sc.nextInt();\n\t\tif (R == 0) return;\n\t\ttable = new int[R][C];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ttable[i][j] = (ch - '0');\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif (ch == 'P') {\n\t\t\t\t\tstartR = i;\n\t\t\t\t\tstartC = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = sc.nextInt();\n\t\tgain = new int[m];\n\t\tstart = new int[m];\n\t\tend = new int[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint id = sc.nextInt();\n\t\t\tgain[id] = sc.nextInt();\n\t\t\tstart[id] = sc.nextInt();\n\t\t\tend[id] = sc.nextInt();\n\t\t}\n\n\t\titem = new int[R][C][101];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tif (table[i][j] != -1)\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tint ni = i + dr[k];\n\t\t\t\t\tint nj = j + dc[k];\n\t\t\t\t\tif (isin(ni, nj)) {\n\t\t\t\t\t\tint id = table[i][j];\n\t\t\t\t\t\tfor (int t = start[id]; t <= end[id]; t++)\n\t\t\t\t\t\t\titem[ni][nj][t] |= 1 << table[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\ttotalGain = new int[1 << m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ttotalGain[1 << i] = gain[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int s = 0; s < 1 << m; s++) {\n\t\t\t\tif ((s >> i & 1) == 1)\n\t\t\t\t\ttotalGain[s] += totalGain[s ^ (1<<i)];\n\t\t\t}\n\t\t}\n\t\tvis = new boolean[R][C][1 << m][101];\n\t\tQueue<State> q = new ArrayDeque<State>();\n\t\tState init = new State(startR, startC, item[startR][startC][0], 0);\n\t\tq.add(init);\n\t\tinit.vis(true);\n\t\tint ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tState s = q.poll();\n\t\t\tans = Math.max(ans, totalGain[s.set]);\n\t\t\tif (s.time >= 100) continue;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ni = s.r + dr[k];\n\t\t\t\tint nj = s.c + dc[k];\n\t\t\t\tif (isin(ni, nj) && table[ni][nj] == -1) {\n\t\t\t\t\tState next = new State(ni, nj, s.set | item[ni][nj][s.time+1], s.time + 1);\n\t\t\t\t\tif (!next.vis()) {\n\t\t\t\t\t\tnext.vis(true);\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tclass State {\n\t\tint r, c, set, time;\n\t\tpublic State(int r, int c, int set, int time) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.set = set;\n\t\t\tthis.time = time;\n\t\t}\n\t\tboolean vis() {\n\t\t\treturn vis[r][c][set][time];\n\t\t}\n\t\tvoid vis(boolean b) {\n\t\t\tvis[r][c][set][time] = b;\n\t\t}\n\t}\n\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> deque = new ArrayDeque<Main.State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, 0));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (state.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tint nextbit = state.bit;\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (((nextbit >> num) & 1) == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit = nextbit | (1<<num);\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextbit, nextvalue));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State {\n\t\tint y, x, step, bit, value;\n\n\t\tpublic State(int y, int x, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [y=\" + y + \", x=\" + x + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\t\t\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> deque = new ArrayDeque<Main.State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, 0));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (state.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tint nextbit = state.bit;\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (((nextbit >> num) & 1) == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit = nextbit | (1<<num);\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextbit, nextvalue));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State {\n\t\tint y, x, step, bit, value;\n\n\t\tpublic State(int y, int x, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [y=\" + y + \", x=\" + x + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\t\t\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State implements Comparable<State>{\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn o.value-this.value;\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> deque = new ArrayDeque<Main.State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, 0));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (state.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tint nextbit = state.bit;\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (((nextbit >> num) & 1) == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit = nextbit | num;\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextbit, nextvalue));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State {\n\t\tint y, x, step, bit, value;\n\n\t\tpublic State(int y, int x, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Time Sale\npublic class Main{\n\n\tint h, w, INF = 1<<29, n, si, sj;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[][] a, wf;\n\tint[][][] dp;\n\tint[] s, f, dis, sum;\n\tSet<Integer>[] set;\n\t\n\tint get(int i, int j, int S){\n\t\tif(dp[i][j][S]!=-1)return dp[i][j][S];\n\t\tif(S==0)return INF;\n\t\tint min = INF;\n\t\tfor(int last=0;last<10;last++)if(((S>>last)&1)>0){\n\t\t\tif(!set[last].contains(i*w+j))continue;\n\t\t\tint sub = S-(1<<last);\n\t\t\tif(sub==0){\n\t\t\t\tint m = wf[i*w+j][si*w+sj];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int p=0;p<h*w;p++){\n\t\t\t\tif(a[p/w][p%w]!=-1)continue;\n\t\t\t\tint m = get(p/w, p%w, sub) + wf[i*w+j][p];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = Math.min(min, m);\n\t\t\t}\n\t\t}\n\t\treturn dp[i][j][S] = min;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tsi = -1; sj = -1;\n\t\t\ta = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='P'){\n\t\t\t\t\tsi = i; sj = j; c = '.';\n\t\t\t\t}\n\t\t\t\ta[i][j] = c=='.'?-1:(c-'0');\n\t\t\t}\n\t\t\tdis = new int[10];\n\t\t\ts = new int[10];\n\t\t\tf = new int[10];\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\tdis[g] = sc.nextInt(); s[g] = sc.nextInt(); f[g] = sc.nextInt();\n\t\t\t}\n\t\t\tset = new Set[10];\n\t\t\tfor(int i=0;i<10;i++)set[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]!=-1)set[a[ni][nj]].add(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = new int[1024];\n\t\t\tfor(int S=0;S<1024;S++)for(int j=0;j<10;j++)if(((S>>j)&1)>0)sum[S]+=dis[j];\n\t\t\twf = new int[h*w][h*w];\n\t\t\tfor(int[]v:wf)Arrays.fill(v, INF);\n\t\t\tfor(int p=0;p<h*w;p++){\n\t\t\t\tint i = p/w, j = p%w;\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]==-1)wf[p][ni*w+nj]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<h*w;k++)for(int i=0;i<h*w;i++)for(int j=0;j<h*w;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tdp = new int[h][w][1024];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int S=0;S<1024;S++)dp[i][j][S]=-1;\n\t\t\tdp[si][sj][0] = 0;\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int S=1023;S>0;S--){\n\t\t\t\t\tif(sum[S]<=res)continue;\n\t\t\t\t\tif(get(i, j, S)<INF)res = sum[S];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> open = new ArrayDeque<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tboolean[][][][] close = new boolean[h][w][1 << n][maxT + 1];\n\t\t\tint ans = 0;\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (close[ny][nx][nextbit][nextstep])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t\tclose[ny][nx][nextbit][nextstep] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static class Walk{\n\t\tint x, y, bit, price, time;\n\n\t\tpublic Walk(int x, int y, int time, int bit, int price) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.bit = bit;\n\t\t\tthis.price = price;\n\t\t\tthis.time = time;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\t\n\t\t\t\t\tif('0' <= in[0] && in[0] <= '9'){\n\t\t\t\t\t\tmap[i][j] = (in[0] - '0');\n\t\t\t\t\t}else if(in[0] == 'P'){\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tint[] prices = new int[10];\n\t\t\tint[] start = new int[10];\n\t\t\tint[] end = new int[10];\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tint max_time = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tprices[g] = sc.nextInt();\n\t\t\t\tstart[g] = sc.nextInt();\n\t\t\t\tend[g] = sc.nextInt();\n\t\t\t\tset.add(g);\n\t\t\t\tlist.add(g);\n\t\t\t\t\n\t\t\t\tmax_time = Math.max(max_time, end[g]);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tboolean[][][] visited = new boolean[H][W][1 << n];\n\t\t\tboolean[][][] in_queue = new boolean[H][W][1 << n];\n\t\t\t\n\t\t\tQueue<Walk> queue = new LinkedList<Walk>();\n\t\t\tqueue.add(new Walk(sx, sy, 0, 0, 0));\n\t\t\tin_queue[sy][sx][0] = true;\n\t\t\t\n\t\t\tint max = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t//System.out.println(walk.x + \" \" + walk.y + \" \" + walk.price + \" \" + walk.time + \" \" + Integer.toBinaryString(walk.bit));\n\t\t\t\t\n\t\t\t\tin_queue[walk.y][walk.x][walk.bit] = false;\n\t\t\t\tif(visited[walk.y][walk.x][walk.bit]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[walk.y][walk.x][walk.bit] = true;\n\t\t\t\t\n\t\t\t\tif(walk.bit == (1 << n) - 1 || walk.time >= max_time){\n\t\t\t\t\tmax = Math.max(max, walk.price);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//buy\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = walk.x - move[0];\n\t\t\t\t\tfinal int ny = walk.y - move[1];\n\t\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(map[ny][nx] < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(!set.contains(map[ny][nx])){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinal int pos = Collections.binarySearch(list, map[ny][nx]);\n\t\t\t\t\t\n\t\t\t\t\tif(walk.time < start[pos]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(walk.time >= end[pos]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if((walk.bit & (1 << pos)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//buy\n\t\t\t\t\twalk.bit |= (1 << pos);\n\t\t\t\t\twalk.price += prices[pos];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, walk.price);\n\t\t\t\t\n\t\t\t\t//next\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = walk.x - move[0];\n\t\t\t\t\tfinal int ny = walk.y - move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(map[ny][nx] >= 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(visited[ny][nx][walk.bit]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(in_queue[ny][nx][walk.bit]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tqueue.add(new Walk(nx, ny, walk.time + 1, walk.bit, walk.price));\n\t\t\t\t\t\tin_queue[ny][nx][walk.bit] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\n\npublic class Main{\n\tScanner sc;\n\tint INF = 1<<27;\n\t\n\tint[][] map;\n\tint X, Y;\n\tint N;\n\tint[] start;\n\tint[] d_list;\n\tint[] s_list;\n\tint[] e_list;\n\t\n\tint[][] ofs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n\t\n\tint[][][] dp;\n\tint[] ans;\n\t\n\tvoid solve(){\n\t\tdp = new int[X][Y][1<<N];\n\t\tans = new int[1<<N];\n\t\t\n\t\tfor(int x=0; x<X; ++x)for(int y=0; y<Y; ++y)for(int n=0; n<1<<N; ++n){\n\t\t\tdp[x][y][n] = INF;\n\t\t}\n\t\tArrays.fill(ans, -1);\n\t\t\n\t\tdp[start[0]][start[1]][0] = 0;\n\t\tans[0] = 0;\n\t\tbfs(0, start[0], start[1], 0);\n\t\t\n\t\tfor( int from = 0; from < 1<<N; ++from ){\n\t\t\tfor( int to = 0; to < N; ++to ){\n\t\t\t\tif( ((from>>to)&0x01) == 0x00 ){\n\t\t\t\t\tLinkedList<ArrayList<Integer>> req = get_req( to );\n\t\t\t\t\tIterator<ArrayList<Integer>> ite = req.iterator();\n\t\t\t\t\t\n\t\t\t\t\twhile(ite.hasNext()){\n\t\t\t\t\t\tArrayList<Integer> e = ite.next();\n\t\t\t\t\t\tint x = e.get(0);\n\t\t\t\t\t\tint y = e.get(1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( dp[x][y][from] < e_list[to] ){\n\t\t\t\t\t\t\tif( s_list[to] <= dp[x][y][from] ){\n\t\t\t\t\t\t\t\tdp[x][y][from | (1<<to)] = Math.min(dp[x][y][from | (1<<to)], dp[x][y][from]);\n\t\t\t\t\t\t\t\tbfs(from | (1<<to), x, y, dp[x][y][from | (1<<to)]);\n\t\t\t\t\t\t\t\tans[from | (1<<to)] = ans[from] + d_list[to];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tassert( dp[x][y][from] < s_list[to] );\n\t\t\t\t\t\t\t\tint d = s_list[to] - dp[x][y][from];\n\t\t\t\t\t\t\t\tif( d%2==1 ) ++d;\n\t\t\t\t\t\t\t\tassert( s_list[to] <= d );\n\t\t\t\t\t\t\t\tif( d < e_list[to] ){\n\t\t\t\t\t\t\t\t\tdp[x][y][from | (1<<to)] = Math.min(dp[x][y][from | (1<<to)], dp[x][y][from] + d);\n\t\t\t\t\t\t\t\t\tbfs(from | (1<<to), x, y, dp[x][y][from | (1<<to)]);\n\t\t\t\t\t\t\t\t\tans[from | (1<<to)] = ans[from] + d_list[to];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max = -1;\n\t\tfor(int i=0; i<1<<N; ++i){\n\t\t\tmax = Math.max(max, ans[i]);\n\t\t}\n\t\tassert(max>=0);\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tvoid bfs(int n, int sx, int sy, int scost){\n\t\tQueue<Integer> qx = new LinkedList<>();\n\t\tQueue<Integer> qy = new LinkedList<>();\n\t\t\n\t\tqx.add(sx);\n\t\tqy.add(sy);\n\t\tboolean[][] done = new boolean[Y][X];\n\t\tdone[sy][sx] = true;\n\t\t\n\t\twhile(qx.size()>0){\n\t\t\tint[] p = new int[]{qx.poll(), qy.poll()};\n\t\t\tassert(qx.size() == qx.size());\n\t\t\t\n\t\t\tfor( int[] ope : ofs ){\n\t\t\t\tint[] e = new int[]{p[0], p[1]};\n\t\t\t\te[0] += ope[0];\n\t\t\t\te[1] += ope[1];\n\t\t\t\tif( isSafe(e[0], e[1]) ){\n\t\t\t\t\tif( !done[e[1]][e[0]] && map[e[1]][e[0]] == -1 ){\n\t\t\t\t\t\tdone[e[1]][e[0]] = true;\n\t\t\t\t\t\tdp[e[0]][e[1]][n] = Math.min(dp[e[0]][e[1]][n], dp[p[0]][p[1]][n] + 1);\n\t\t\t\t\t\tqx.add(e[0]);\n\t\t\t\t\t\tqy.add(e[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tX = ni();\n\t\t\tY = ni();\n\t\t\tif((X|Y)==0) break;\n\t\t\tmap = new int[Y][X];\n\t\t\t\n\t\t\tstart = new int[2];\n\t\t\tfor(int y=0; y<Y; ++y)for(int x=0; x<X; ++x){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='.'){\n\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t}else if(c=='P'){\n\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t\tstart[0] = x;\n\t\t\t\t\tstart[1] = y;\n\t\t\t\t}else{\n\t\t\t\t\tmap[y][x] = c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tN = ni();\n\t\t\td_list = new int[N];\n\t\t\ts_list = new int[N];\n\t\t\te_list = new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tint g = ni();\n\t\t\t\tint d = ni();\n\t\t\t\tint s = ni();\n\t\t\t\tint e = ni();\n\t\t\t\tassert(g==i);\n\t\t\t\t\n\t\t\t\td_list[i] = d;\n\t\t\t\ts_list[i] = s;\n\t\t\t\te_list[i] = e;\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tLinkedList<ArrayList<Integer>> get_req(int trg){\n\t\tHashSet<ArrayList<Integer>> set = new HashSet<>();\n\t\tfor(int y=0; y<Y; ++y)for(int x=0; x<X; ++x){\n\t\t\tint[] e = new int[]{x, y};\n\t\t\tif(map[e[1]][e[0]] == -1){\n\t\t\t\tfor(int[] ope : ofs){\n\t\t\t\t\tint[] buf = new int[]{e[0], e[1]};\n\t\t\t\t\tbuf[0] += ope[0];\n\t\t\t\t\tbuf[1] += ope[1];\n\t\t\t\t\t\n\t\t\t\t\tif(isSafe(buf[0], buf[1])){\n\t\t\t\t\t\tif( map[buf[1]][buf[0]] == trg ){\n\t\t\t\t\t\t\tArrayList<Integer> p = new ArrayList<>();\n\t\t\t\t\t\t\tp.add(e[0]);\n\t\t\t\t\t\t\tp.add(e[1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tset.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<ArrayList<Integer>> list = new LinkedList<>();\n\t\tIterator<ArrayList<Integer>> ite = set.iterator();\n\t\twhile(ite.hasNext()){\n\t\t\tlist.add(ite.next());\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tboolean isSafe(int x, int y){\n\t\treturn (0<=x && x<X) && (0<=y && y<Y);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint R, C;\n\tint[][] table;\n\n\tint[] gain;\n\tint[] start;\n\tint[] end;\n\n\tint[] totalGain;\n\n\tint startR;\n\tint startC;\n\n\tint[][][] item;\n\tint[][][][] vis;\n\n\tint[] dr = {0, 1, 0, -1, 0};\n\tint[] dc = {1, 0, -1, 0, 0};\n\n\tvoid solve() {\n\t\tC = sc.nextInt();\n\t\tR = sc.nextInt();\n\t\tif (R == 0) return;\n\t\ttable = new int[R][C];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ttable[i][j] = (ch - '0');\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif (ch == 'P') {\n\t\t\t\t\tstartR = i;\n\t\t\t\t\tstartC = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M = 8;\n\t\tint m = sc.nextInt();\n\t\tgain = new int[M];\n\t\tstart = new int[M];\n\t\tend = new int[M];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint id = sc.nextInt();\n\t\t\tgain[id] = sc.nextInt();\n\t\t\tstart[id] = sc.nextInt();\n\t\t\tend[id] = sc.nextInt();\n\t\t}\n\t\titem = new int[R][C][101];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tif (table[i][j] != -1)\n\t\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ni = i + dr[k];\n\t\t\t\t\t\tint nj = j + dc[k];\n\t\t\t\t\t\tif (isin(ni, nj)) {\n\t\t\t\t\t\t\tint id = table[i][j];\n\t\t\t\t\t\t\tfor (int t = start[id]; t < end[id]; t++)\n\t\t\t\t\t\t\t\titem[ni][nj][t] |= 1 << table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\ttotalGain = new int[1 << M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\ttotalGain[1 << i] = gain[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int s = 0; s < 1 << M; s++) {\n\t\t\t\tif ((s >> i & 1) == 1)\n\t\t\t\t\ttotalGain[s] += totalGain[s ^ (1<<i)];\n\t\t\t}\n\t\t}\n\t\tvis = new int[R][C][1 << M][4];\n\t\tQueue<State> q = new ArrayDeque<State>();\n\t\tState init = new State(startR, startC, item[startR][startC][0], 0);\n\t\tq.add(init);\n\t\tinit.vis(true);\n\t\tint ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tState s = q.poll();\n\t\t\tans = Math.max(ans, totalGain[s.set]);\n\t\t\tif (s.time >= 100) continue;\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tint ni = s.r + dr[k];\n\t\t\t\tint nj = s.c + dc[k];\n\t\t\t\tif (isin(ni, nj) && table[ni][nj] == -1) {\n\t\t\t\t\tState next = new State(ni, nj, s.set | item[ni][nj][s.time+1], s.time + 1);\n\t\t\t\t\tif (!next.vis()) {\n\t\t\t\t\t\tnext.vis(true);\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tclass State {\n\t\tint r, c, set, time;\n\t\tpublic State(int r, int c, int set, int time) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.set = set;\n\t\t\tthis.time = time;\n\t\t}\n\t\tboolean vis() {\n\t\t\treturn (vis[r][c][set][time>>5] >> (time & 31)) == 1;\n\t\t}\n\t\tvoid vis(boolean b) {\n\t\t\tif (b) {\n\t\t\t\tvis[r][c][set][time>>5] |= 1 << (time & 31);\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> deque = new ArrayDeque<Main.State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, 0));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (state.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tint nextbit = state.bit;\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (((nextbit >> num) & 1) == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit = nextbit | (1<<num);\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextbit, nextvalue));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State {\n\t\tint y, x, step, bit, value;\n\n\t\tpublic State(int y, int x, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [y=\" + y + \", x=\" + x + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\t\t\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> open = new ArrayDeque<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tint[][] bits = new int[h][w];\n\t\t\tfor (int[] bb : bits)\n\t\t\t\tArrays.fill(bb, -1);\n\t\t\tbits[sy][sx] = 0;\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (bits[ny][nx] != -1\n\t\t\t\t\t\t\t&& (bits[ny][nx] | nextbit) == bits[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbits[ny][nx] = nextbit;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Time Sale\npublic class Main{\n\n\tint h, w, INF = 1<<29, n, si, sj;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[][] a, wf;\n\tint[][][] dp;\n\tint[] s, f, dis, sum;\n\tSet<Integer>[] set;\n\t\n\tint get(int i, int j, int S){\n\t\tif(dp[i][j][S]!=-1)return dp[i][j][S];\n\t\tif(S==0)return INF;\n\t\tint min = INF;\n\t\tfor(int last=0;last<10;last++)if(((S>>last)&1)>0){\n\t\t\tif(!set[last].contains(i*w+j))continue;\n\t\t\tint sub = S-(1<<last);\n\t\t\tif(sub==0){\n\t\t\t\tint m = wf[i*w+j][si*w+sj];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int p=0;p<h*w;p++){\n\t\t\t\tif(a[p/w][p%w]!=-1)continue;\n\t\t\t\tint m = get(p/w, p%w, sub) + wf[i*w+j][p];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = Math.min(min, m);\n\t\t\t}\n\t\t}\n\t\treturn dp[i][j][S] = min;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tdp = new int[20][20][1024];\n\t\ta = new int[20][20];\n\t\tdis = new int[10];\n\t\ts = new int[10];\n\t\tf = new int[10];\n\t\twf = new int[400][400];\n\t\tsum = new int[1024];\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tsi = -1; sj = -1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='P'){\n\t\t\t\t\tsi = i; sj = j; c = '.';\n\t\t\t\t}\n\t\t\t\ta[i][j] = c=='.'?-1:(c-'0');\n\t\t\t}\n\t\t\tArrays.fill(dis, 0);\n\t\t\tArrays.fill(s, 0);\n\t\t\tArrays.fill(f, 0);\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\tdis[g] = sc.nextInt(); s[g] = sc.nextInt(); f[g] = sc.nextInt();\n\t\t\t}\n\t\t\tset = new Set[10];\n\t\t\tfor(int i=0;i<10;i++)set[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]!=-1)set[a[ni][nj]].add(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(sum, 0);\n\t\t\tfor(int S=0;S<1024;S++)for(int j=0;j<10;j++)if(((S>>j)&1)>0)sum[S]+=dis[j];\n\t\t\tfor(int[]v:wf)Arrays.fill(v, INF);\n\t\t\tfor(int p=0;p<h*w;p++){\n\t\t\t\tint i = p/w, j = p%w;\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]==-1)wf[p][ni*w+nj]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<h*w;k++)for(int i=0;i<h*w;i++)for(int j=0;j<h*w;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int S=0;S<1024;S++)dp[i][j][S]=-1;\n\t\t\tdp[si][sj][0] = 0;\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int S=1023;S>0;S--){\n\t\t\t\t\tif(sum[S]<=res)continue;\n\t\t\t\t\tif(get(i, j, S)<INF)res = sum[S];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\n\t\t\tDeque<State> open = new ArrayDeque<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\topen.push(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static class Walk{\n\t\tint x, y, bit, price, time;\n\n\t\tpublic Walk(int x, int y, int time, int bit, int price) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.bit = bit;\n\t\t\tthis.price = price;\n\t\t\tthis.time = time;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\tpublic static int[][] next_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {0, 0}};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\t\n\t\t\t\t\tif('0' <= in[0] && in[0] <= '9'){\n\t\t\t\t\t\tmap[i][j] = (in[0] - '0');\n\t\t\t\t\t}else if(in[0] == 'P'){\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tint[] prices = new int[10];\n\t\t\tint[] start = new int[10];\n\t\t\tint[] end = new int[10];\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tint max_time = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tprices[g] = sc.nextInt();\n\t\t\t\tstart[g] = sc.nextInt();\n\t\t\t\tend[g] = sc.nextInt();\n\t\t\t\tset.add(g);\n\t\t\t\tlist.add(g);\n\t\t\t\t\n\t\t\t\tmax_time = Math.max(max_time, end[g]);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tint[][][] visited = new int[H][W][max_time + 1];\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tfor(int t = 0; t <= max_time; t++){\n\t\t\t\t\t\tvisited[i][j][t] = 1 << n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tQueue<Walk> queue = new LinkedList<Walk>();\n\t\t\tqueue.add(new Walk(sx, sy, 0, 0, 0));\n\t\t\t\n\t\t\tint max = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t//System.out.println(walk.x + \" \" + walk.y + \" \" + walk.price + \" \" + walk.time + \" \" + Integer.toBinaryString(walk.bit));\n\t\t\t\t\n\t\t\t\t//in_queue[walk.y][walk.x][walk.bit] = false;\n\t\t\t\tif(visited[walk.y][walk.x][walk.time] == walk.bit){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisited[walk.y][walk.x][walk.time] = walk.bit;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//buy\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = walk.x - move[0];\n\t\t\t\t\tfinal int ny = walk.y - move[1];\n\t\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(map[ny][nx] < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(!set.contains(map[ny][nx])){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinal int pos = Collections.binarySearch(list, map[ny][nx]);\n\t\t\t\t\t\n\t\t\t\t\tif(walk.time < start[pos]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(walk.time >= end[pos]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if((walk.bit & (1 << pos)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//buy\n\t\t\t\t\twalk.bit |= (1 << pos);\n\t\t\t\t\twalk.price += prices[pos];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean can = false;\n\t\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif((walk.bit & (1 << i)) == 0){\n\t\t\t\t\t\tif(end[i] > walk.time){\n\t\t\t\t\t\t\tcan = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(!can){\n\t\t\t\t\tmax = Math.max(max, walk.price);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//next\n\t\t\t\tfor(int[] move : next_dir){\n\t\t\t\t\tfinal int nx = walk.x - move[0];\n\t\t\t\t\tfinal int ny = walk.y - move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(map[ny][nx] >= 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint next_price = 0;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tif((visited[ny][nx][walk.time + 1] & (1 << i)) != 0){\n\t\t\t\t\t\t\tnext_price += prices[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(next_price <= walk.price){\n\t\t\t\t\t\tqueue.add(new Walk(nx, ny, walk.time + 1, walk.bit, walk.price));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\t\n\t\t\tDeque<State> open = new ArrayDeque<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tboolean[][][][] b = new boolean[maxT+1][1<<n][h][w];\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif(b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> open = new ArrayDeque<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tint[][] bits = new int[h][w];\n\t\t\tfor (int[] bb : bits)\n\t\t\t\tArrays.fill(bb, -1);\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (bits[ny][nx] != -1\n\t\t\t\t\t\t\t&& (bits[ny][nx] | nextbit) == bits[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbits[ny][nx] = nextbit;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\n\npublic class Main{\n\tScanner sc;\n\tint INF = 1<<27;\n\t\n\tint[][] map;\n\tint X, Y;\n\tint N;\n\tint[] start;\n\tint[] d_list;\n\tint[] s_list;\n\tint[] e_list;\n\t\n\tint[][] ofs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n\t\n\tint[][][] dp;\n\tint[] ans;\n\t\n\tvoid solve(){\n\t\tdp = new int[X][Y][1<<N];\n\t\tans = new int[1<<N];\n\t\t\n\t\tfor(int x=0; x<X; ++x)for(int y=0; y<Y; ++y)for(int n=0; n<1<<N; ++n){\n\t\t\tdp[x][y][n] = INF;\n\t\t}\n\t\tArrays.fill(ans, -1);\n\t\t\n\t\tdp[start[0]][start[1]][0] = 0;\n\t\tans[0] = 0;\n\t\tbfs(0, start[0], start[1], 0);\n\t\t\n\t\tfor( int from = 0; from < 1<<N; ++from ){\n\t\t\tfor( int to = 0; to < N; ++to ){\n\t\t\t\tif( ((from>>to)&0x01) == 0x00 ){\n\t\t\t\t\tLinkedList<ArrayList<Integer>> req = get_req( to );\n\t\t\t\t\tIterator<ArrayList<Integer>> ite = req.iterator();\n\t\t\t\t\t\n\t\t\t\t\twhile(ite.hasNext()){\n\t\t\t\t\t\tArrayList<Integer> e = ite.next();\n\t\t\t\t\t\tint x = e.get(0);\n\t\t\t\t\t\tint y = e.get(1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( dp[x][y][from] < e_list[to] ){\n\t\t\t\t\t\t\tif( s_list[to] <= dp[x][y][from] ){\n\t\t\t\t\t\t\t\tdp[x][y][from | (1<<to)] = Math.min(dp[x][y][from | (1<<to)], dp[x][y][from]);\n\t\t\t\t\t\t\t\tbfs(from | (1<<to), x, y, dp[x][y][from | (1<<to)]);\n\t\t\t\t\t\t\t\tans[from | (1<<to)] = ans[from] + d_list[to];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tassert( dp[x][y][from] < s_list[to] );\n\t\t\t\t\t\t\t\tint d = s_list[to] - dp[x][y][from];\n\t\t\t\t\t\t\t\tif( d%2==1 ) ++d;\n\t\t\t\t\t\t\t\tassert( s_list[to] <= d );\n\t\t\t\t\t\t\t\tif( d < e_list[to] ){\n\t\t\t\t\t\t\t\t\tdp[x][y][from | (1<<to)] = Math.min(dp[x][y][from | (1<<to)], dp[x][y][from] + d);\n\t\t\t\t\t\t\t\t\tbfs(from | (1<<to), x, y, dp[x][y][from | (1<<to)]);\n\t\t\t\t\t\t\t\t\tans[from | (1<<to)] = ans[from] + d_list[to];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max = -1;\n\t\tfor(int i=0; i<1<<N; ++i){\n\t\t\tmax = Math.max(max, ans[i]);\n\t\t}\n\t\tassert(max>=0);\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tvoid bfs(int n, int sx, int sy, int scost){\n\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\t\n\t\tqx.add(sx);\n\t\tqy.add(sy);\n\t\tboolean[][] done = new boolean[Y][X];\n\t\tdone[sy][sx] = true;\n\t\t\n\t\twhile(qx.size()>0){\n\t\t\tint[] p = new int[]{qx.poll(), qy.poll()};\n\t\t\tassert(qx.size() == qx.size());\n\t\t\t\n\t\t\tfor( int[] ope : ofs ){\n\t\t\t\tint[] e = new int[]{p[0], p[1]};\n\t\t\t\te[0] += ope[0];\n\t\t\t\te[1] += ope[1];\n\t\t\t\tif( isSafe(e[0], e[1]) ){\n\t\t\t\t\tif( !done[e[1]][e[0]] && map[e[1]][e[0]] == -1 ){\n\t\t\t\t\t\tdone[e[1]][e[0]] = true;\n\t\t\t\t\t\tdp[e[0]][e[1]][n] = Math.min(dp[e[0]][e[1]][n], dp[p[0]][p[1]][n] + 1);\n\t\t\t\t\t\tqx.add(e[0]);\n\t\t\t\t\t\tqy.add(e[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tX = ni();\n\t\t\tY = ni();\n\t\t\tif((X|Y)==0) break;\n\t\t\tmap = new int[Y][X];\n\t\t\t\n\t\t\tstart = new int[2];\n\t\t\tfor(int y=0; y<Y; ++y)for(int x=0; x<X; ++x){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='.'){\n\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t}else if(c=='P'){\n\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t\tstart[0] = x;\n\t\t\t\t\tstart[1] = y;\n\t\t\t\t}else{\n\t\t\t\t\tmap[y][x] = c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tN = ni();\n\t\t\td_list = new int[N];\n\t\t\ts_list = new int[N];\n\t\t\te_list = new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tint g = ni();\n\t\t\t\tint d = ni();\n\t\t\t\tint s = ni();\n\t\t\t\tint e = ni();\n\t\t\t\tassert(g==i);\n\t\t\t\t\n\t\t\t\td_list[i] = d;\n\t\t\t\ts_list[i] = s;\n\t\t\t\te_list[i] = e;\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tLinkedList<ArrayList<Integer>> get_req(int trg){\n\t\tHashSet<ArrayList<Integer>> set = new HashSet<ArrayList<Integer>>();\n\t\tfor(int y=0; y<Y; ++y)for(int x=0; x<X; ++x){\n\t\t\tint[] e = new int[]{x, y};\n\t\t\tif(map[e[1]][e[0]] == -1){\n\t\t\t\tfor(int[] ope : ofs){\n\t\t\t\t\tint[] buf = new int[]{e[0], e[1]};\n\t\t\t\t\tbuf[0] += ope[0];\n\t\t\t\t\tbuf[1] += ope[1];\n\t\t\t\t\t\n\t\t\t\t\tif(isSafe(buf[0], buf[1])){\n\t\t\t\t\t\tif( map[buf[1]][buf[0]] == trg ){\n\t\t\t\t\t\t\tArrayList<Integer> p = new ArrayList<Integer>();\n\t\t\t\t\t\t\tp.add(e[0]);\n\t\t\t\t\t\t\tp.add(e[1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tset.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<ArrayList<Integer>> list = new LinkedList<ArrayList<Integer>>();\n\t\tIterator<ArrayList<Integer>> ite = set.iterator();\n\t\twhile(ite.hasNext()){\n\t\t\tlist.add(ite.next());\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tboolean isSafe(int x, int y){\n\t\treturn (0<=x && x<X) && (0<=y && y<Y);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Time Sale\npublic class Main{\n\n\tint h, w, INF = 1<<29, n, si, sj;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[][] a, wf;\n\tint[][][] dp;\n\tint[] s, f, dis, sum;\n\tSet<Integer>[] set;\n\t\n\tint get(int i, int j, int S){\n\t\tif(dp[i][j][S]!=-1)return dp[i][j][S];\n\t\tif(S==0)return INF;\n\t\tint min = INF;\n\t\tfor(int last=0;last<10;last++)if(((S>>last)&1)>0){\n\t\t\tif(!set[last].contains(i*w+j))continue;\n\t\t\tint sub = S-(1<<last);\n\t\t\tif(sub==0){\n\t\t\t\tint m = wf[i*w+j][si*w+sj];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int p=0;p<h*w;p++){\n\t\t\t\tif(a[p/w][p%w]!=-1)continue;\n\t\t\t\tint m = get(p/w, p%w, sub) + wf[i*w+j][p];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = Math.min(min, m);\n\t\t\t}\n\t\t}\n\t\treturn dp[i][j][S] = min;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tdp = new int[20][20][1024];\n\t\ta = new int[20][20];\n\t\tdis = new int[10];\n\t\ts = new int[10];\n\t\tf = new int[10];\n\t\twf = new int[400][400];\n\t\tsum = new int[1024];\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tsi = -1; sj = -1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='P'){\n\t\t\t\t\tsi = i; sj = j; c = '.';\n\t\t\t\t}\n\t\t\t\ta[i][j] = c=='.'?-1:(c-'0');\n\t\t\t}\n\t\t\tArrays.fill(dis, 0);\n\t\t\tArrays.fill(s, 0);\n\t\t\tArrays.fill(f, 0);\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\tdis[g] = sc.nextInt(); s[g] = sc.nextInt(); f[g] = sc.nextInt();\n\t\t\t}\n\t\t\tset = new Set[10];\n\t\t\tfor(int i=0;i<10;i++)set[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]!=-1)set[a[ni][nj]].add(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(sum, 0);\n\t\t\tfor(int S=0;S<1024;S++)for(int j=0;j<10;j++)if(((S>>j)&1)>0)sum[S]+=dis[j];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tint b = i*w+j;\n\t\t\t\tfor(int p=0;p<h*w;p++)wf[b][p] = INF;\n\t\t\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\t\t\twf[b][b] = 0;\n\t\t\t\tq.add(b);\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint V = q.poll();\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ni = V/w+d[k][0], nj = V%w+d[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]==-1&&wf[b][ni*w+nj]==INF){\n\t\t\t\t\t\t\twf[b][ni*w+nj] = wf[b][V]+1;\n\t\t\t\t\t\t\tq.add(ni*w+nj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int S=0;S<1024;S++)dp[i][j][S]=-1;\n\t\t\tdp[si][sj][0] = 0;\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int S=1023;S>0;S--){\n\t\t\t\t\tif(sum[S]<=res)continue;\n\t\t\t\t\tif(get(i, j, S)<INF)res = sum[S];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tPriorityQueue<State> deque = new PriorityQueue<State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, new BitSet()));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (state.bitSet.cardinality() == n)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tBitSet nextbit = (BitSet) state.bitSet.clone();\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (nextbit.get(num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit.set(num);\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\tfor (int i = 0; i < nextbit.length(); i++) {\n\t\t\t\t\t\tif (nextbit.get(i))\n\t\t\t\t\t\t\tbit |= (1 << i);\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][bit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][bit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextvalue, nextbit));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State implements Comparable<State> {\n\t\tint y, x, step, value;\n\t\tBitSet bitSet;\n\n\t\tpublic State(int y, int x, int step, int value, BitSet bitSet) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.value = value;\n\t\t\tthis.bitSet = bitSet;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [y=\" + y + \", x=\" + x + \", step=\" + step + \", value=\"\n\t\t\t\t\t+ value + \", bitSet=\" + bitSet + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn o.value - this.value;\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> open = new ArrayDeque<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tboolean[][][][] close = new boolean[h][w][1 << n][maxT + 1];\n\t\t\tint ans = 0;\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\t\t\t\t\t\n\t\t\t\t\tif (close[ny][nx][nextbit][nextstep])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (close[ny][nx][nextbit][nextstep])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t\tclose[ny][nx][nextbit][nextstep] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint R, C;\n\tint[][] table;\n\n\tint[] gain;\n\tint[] start;\n\tint[] end;\n\n\tint[] totalGain;\n\n\tint startR;\n\tint startC;\n\n\tint[][][] item;\n\tboolean[][][][] vis;\n\n\tint[] dr = {0, 1, 0, -1, 0};\n\tint[] dc = {1, 0, -1, 0, 0};\n\n\tvoid solve() {\n\t\tC = sc.nextInt();\n\t\tR = sc.nextInt();\n\t\tif (R == 0) return;\n\t\ttable = new int[R][C];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ttable[i][j] = (ch - '0');\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif (ch == 'P') {\n\t\t\t\t\tstartR = i;\n\t\t\t\t\tstartC = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M = 8;\n\t\tint m = sc.nextInt();\n\t\tgain = new int[M];\n\t\tstart = new int[M];\n\t\tend = new int[M];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint id = sc.nextInt();\n\t\t\tgain[id] = sc.nextInt();\n\t\t\tstart[id] = sc.nextInt();\n\t\t\tend[id] = sc.nextInt();\n\t\t}\n\t\titem = new int[R][C][101];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tif (table[i][j] != -1)\n\t\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ni = i + dr[k];\n\t\t\t\t\t\tint nj = j + dc[k];\n\t\t\t\t\t\tif (isin(ni, nj)) {\n\t\t\t\t\t\t\tint id = table[i][j];\n\t\t\t\t\t\t\tfor (int t = start[id]; t < end[id]; t++)\n\t\t\t\t\t\t\t\titem[ni][nj][t] |= 1 << table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\ttotalGain = new int[1 << M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\ttotalGain[1 << i] = gain[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int s = 0; s < 1 << M; s++) {\n\t\t\t\tif ((s >> i & 1) == 1)\n\t\t\t\t\ttotalGain[s] += totalGain[s ^ (1<<i)];\n\t\t\t}\n\t\t}\n\t\tvis = new boolean[R][C][1 << M][101];\n\t\tQueue<State> q = new ArrayDeque<State>();\n\t\tState init = new State(startR, startC, item[startR][startC][0], 0);\n\t\tq.add(init);\n\t\tinit.vis(true);\n\t\tint ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tState s = q.poll();\n\t\t\tans = Math.max(ans, totalGain[s.set]);\n\t\t\tif (s.time >= 100) continue;\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tint ni = s.r + dr[k];\n\t\t\t\tint nj = s.c + dc[k];\n\t\t\t\tif (isin(ni, nj) && table[ni][nj] == -1) {\n\t\t\t\t\tState next = new State(ni, nj, s.set | item[ni][nj][s.time+1], s.time + 1);\n\t\t\t\t\tif (!next.vis()) {\n\t\t\t\t\t\tnext.vis(true);\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tclass State {\n\t\tint r, c, set, time;\n\t\tpublic State(int r, int c, int set, int time) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.set = set;\n\t\t\tthis.time = time;\n\t\t}\n\t\tboolean vis() {\n\t\t\treturn vis[r][c][set][time];\n\t\t}\n\t\tvoid vis(boolean b) {\n\t\t\tvis[r][c][set][time] = b;\n\t\t}\n\t}\n\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State implements Comparable<State>{\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn o.step-this.step;\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\n\npublic class Main{\n\tScanner sc;\n\tint INF = 1<<27;\n\t\n\tint[][] map;\n\tint X, Y;\n\tint N;\n\tint[] start;\n\tint[] d_list;\n\tint[] s_list;\n\tint[] e_list;\n\t\n\tint[][] ofs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n\t\n\tint[][][] dp;\n\tint[] ans;\n\t\n\tvoid solve(){\n\t\tdp = new int[X][Y][1<<N];\n\t\tans = new int[1<<N];\n\t\t\n\t\tfor(int x=0; x<X; ++x)for(int y=0; y<Y; ++y)for(int n=0; n<1<<N; ++n){\n\t\t\tdp[x][y][n] = INF;\n\t\t}\n\t\tArrays.fill(ans, -1);\n\t\t\n\t\tdp[start[0]][start[1]][0] = 0;\n\t\tans[0] = 0;\n\t\tbfs(0, start[0], start[1], 0);\n\t\t\n\t\tfor( int from = 0; from < 1<<N; ++from ){\n\t\t\tfor( int to = 0; to < N; ++to ){\n\t\t\t\tif( ((from>>to)&0x01) == 0x00 ){\n\t\t\t\t\tLinkedList<ArrayList<Integer>> req = get_req( to );\n\t\t\t\t\tIterator<ArrayList<Integer>> ite = req.iterator();\n\t\t\t\t\t\n\t\t\t\t\twhile(ite.hasNext()){\n\t\t\t\t\t\tArrayList<Integer> e = ite.next();\n\t\t\t\t\t\tint x = e.get(0);\n\t\t\t\t\t\tint y = e.get(1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( dp[x][y][from] < e_list[to] ){\n\t\t\t\t\t\t\tif( s_list[to] <= dp[x][y][from] ){\n\t\t\t\t\t\t\t\tdp[x][y][from | (1<<to)] = Math.min(dp[x][y][from | (1<<to)], dp[x][y][from]);\n\t\t\t\t\t\t\t\tbfs(from | (1<<to), x, y, dp[x][y][from | (1<<to)]);\n\t\t\t\t\t\t\t\tans[from | (1<<to)] = ans[from] + d_list[to];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tassert( dp[x][y][from] < s_list[to] );\n\t\t\t\t\t\t\t\tint d = s_list[to] - dp[x][y][from];\n\t\t\t\t\t\t\t\tif( d%2==1 ) ++d;\n\t\t\t\t\t\t\t\tassert( s_list[to] <= dp[x][y][from] + d );\n\t\t\t\t\t\t\t\tif( dp[x][y][from] + d < e_list[to] ){\n\t\t\t\t\t\t\t\t\tdp[x][y][from | (1<<to)] = Math.min(dp[x][y][from | (1<<to)], dp[x][y][from] + d);\n\t\t\t\t\t\t\t\t\tbfs(from | (1<<to), x, y, dp[x][y][from | (1<<to)]);\n\t\t\t\t\t\t\t\t\tans[from | (1<<to)] = ans[from] + d_list[to];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max = -1;\n\t\tfor(int i=0; i<1<<N; ++i){\n\t\t\tmax = Math.max(max, ans[i]);\n\t\t}\n\t\tassert(max>=0);\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tvoid bfs(int n, int sx, int sy, int scost){\n\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\t\n\t\tqx.add(sx);\n\t\tqy.add(sy);\n\t\tboolean[][] done = new boolean[Y][X];\n\t\tdone[sy][sx] = true;\n\t\t\n\t\twhile(qx.size()>0){\n\t\t\tint[] p = new int[]{qx.poll(), qy.poll()};\n\t\t\tassert(qx.size() == qx.size());\n\t\t\t\n\t\t\tfor( int[] ope : ofs ){\n\t\t\t\tint[] e = new int[]{p[0], p[1]};\n\t\t\t\te[0] += ope[0];\n\t\t\t\te[1] += ope[1];\n\t\t\t\tif( isSafe(e[0], e[1]) ){\n\t\t\t\t\tif( !done[e[1]][e[0]] && map[e[1]][e[0]] == -1 ){\n\t\t\t\t\t\tdone[e[1]][e[0]] = true;\n\t\t\t\t\t\tdp[e[0]][e[1]][n] = Math.min(dp[e[0]][e[1]][n], dp[p[0]][p[1]][n] + 1);\n\t\t\t\t\t\tqx.add(e[0]);\n\t\t\t\t\t\tqy.add(e[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tX = ni();\n\t\t\tY = ni();\n\t\t\tif((X|Y)==0) break;\n\t\t\tmap = new int[Y][X];\n\t\t\t\n\t\t\tstart = new int[2];\n\t\t\tfor(int y=0; y<Y; ++y)for(int x=0; x<X; ++x){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='.'){\n\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t}else if(c=='P'){\n\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t\tstart[0] = x;\n\t\t\t\t\tstart[1] = y;\n\t\t\t\t}else{\n\t\t\t\t\tmap[y][x] = c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tN = ni();\n\t\t\td_list = new int[N];\n\t\t\ts_list = new int[N];\n\t\t\te_list = new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tint g = ni();\n\t\t\t\tint d = ni();\n\t\t\t\tint s = ni();\n\t\t\t\tint e = ni();\n\t\t\t\tassert(g==i);\n\t\t\t\t\n\t\t\t\td_list[i] = d;\n\t\t\t\ts_list[i] = s;\n\t\t\t\te_list[i] = e;\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tLinkedList<ArrayList<Integer>> get_req(int trg){\n\t\tHashSet<ArrayList<Integer>> set = new HashSet<ArrayList<Integer>>();\n\t\tfor(int y=0; y<Y; ++y)for(int x=0; x<X; ++x){\n\t\t\tint[] e = new int[]{x, y};\n\t\t\tif(map[e[1]][e[0]] == -1){\n\t\t\t\tfor(int[] ope : ofs){\n\t\t\t\t\tint[] buf = new int[]{e[0], e[1]};\n\t\t\t\t\tbuf[0] += ope[0];\n\t\t\t\t\tbuf[1] += ope[1];\n\t\t\t\t\t\n\t\t\t\t\tif(isSafe(buf[0], buf[1])){\n\t\t\t\t\t\tif( map[buf[1]][buf[0]] == trg ){\n\t\t\t\t\t\t\tArrayList<Integer> p = new ArrayList<Integer>();\n\t\t\t\t\t\t\tp.add(e[0]);\n\t\t\t\t\t\t\tp.add(e[1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tset.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<ArrayList<Integer>> list = new LinkedList<ArrayList<Integer>>();\n\t\tIterator<ArrayList<Integer>> ite = set.iterator();\n\t\twhile(ite.hasNext()){\n\t\t\tlist.add(ite.next());\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tboolean isSafe(int x, int y){\n\t\treturn (0<=x && x<X) && (0<=y && y<Y);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Time Sale\npublic class Main{\n\n\tint h, w, INF = 1<<29, n, si, sj;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[][] a, wf;\n\tint[][][] dp;\n\tint[] s, f, dis, sum;\n\tSet<Integer>[] set;\n\t\n\tint get(int i, int j, int S){\n\t\tif(dp[i][j][S]!=-1)return dp[i][j][S];\n\t\tif(S==0)return INF;\n\t\tint min = INF;\n\t\tfor(int last=0;last<10;last++)if(((S>>last)&1)>0){\n\t\t\tif(!set[last].contains(i*w+j))continue;\n\t\t\tint sub = S-(1<<last);\n\t\t\tif(sub==0){\n\t\t\t\tint m = wf[i*w+j][si*w+sj];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int p=0;p<h*w;p++){\n\t\t\t\tif(a[p/w][p%w]!=-1)continue;\n\t\t\t\tint m = get(p/w, p%w, sub) + wf[i*w+j][p];\n\t\t\t\twhile(m < f[last]){\n\t\t\t\t\tif(s[last]<=m)break;\n\t\t\t\t\tm+=2;\n\t\t\t\t}\n\t\t\t\tif(f[last]<=m)m = INF;\n\t\t\t\tmin = Math.min(min, m);\n\t\t\t}\n\t\t}\n\t\treturn dp[i][j][S] = min;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tdp = new int[20][20][1024];\n\t\ta = new int[20][20];\n\t\tdis = new int[10];\n\t\ts = new int[10];\n\t\tf = new int[10];\n\t\twf = new int[400][400];\n\t\tsum = new int[1024];\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tsi = -1; sj = -1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c=='P'){\n\t\t\t\t\tsi = i; sj = j; c = '.';\n\t\t\t\t}\n\t\t\t\ta[i][j] = c=='.'?-1:(c-'0');\n\t\t\t}\n\t\t\tArrays.fill(dis, 0);\n\t\t\tArrays.fill(s, 0);\n\t\t\tArrays.fill(f, 0);\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint g = sc.nextInt();\n\t\t\t\tdis[g] = sc.nextInt(); s[g] = sc.nextInt(); f[g] = sc.nextInt();\n\t\t\t}\n\t\t\tset = new Set[10];\n\t\t\tfor(int i=0;i<10;i++)set[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]!=-1)set[a[ni][nj]].add(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(sum, 0);\n\t\t\tfor(int S=0;S<1024;S++)for(int j=0;j<10;j++)if(((S>>j)&1)>0)sum[S]+=dis[j];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tint b = i*w+j;\n\t\t\t\tfor(int p=0;p<h*w;p++)wf[b][p] = INF;\n\t\t\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\t\t\twf[b][b] = 0;\n\t\t\t\tq.add(b);\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint V = q.poll();\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ni = V/w+d[k][0], nj = V%w+d[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]==-1&&wf[b][ni*w+nj]==INF){\n\t\t\t\t\t\t\twf[b][ni*w+nj] = wf[b][V]+1;\n\t\t\t\t\t\t\tq.add(ni*w+nj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int[]v:wf)Arrays.fill(v, INF);\n//\t\t\tfor(int p=0;p<h*w;p++){\n//\t\t\t\tint i = p/w, j = p%w;\n//\t\t\t\tif(a[i][j]!=-1)continue;\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n//\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&a[ni][nj]==-1)wf[p][ni*w+nj]=1;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tfor(int k=0;k<h*w;k++)for(int i=0;i<h*w;i++)for(int j=0;j<h*w;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int S=0;S<1024;S++)dp[i][j][S]=-1;\n\t\t\tdp[si][sj][0] = 0;\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]!=-1)continue;\n\t\t\t\tfor(int S=1023;S>0;S--){\n\t\t\t\t\tif(sum[S]<=res)continue;\n\t\t\t\t\tif(get(i, j, S)<INF)res = sum[S];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\tpublic static int[][] next_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {0, 0}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int n;\n\tpublic static int[] start;\n\tpublic static int[] end;\n\tpublic static Set<Integer> set;\n\tpublic static List<Integer> list;\n\tpublic static int[][] map;\n\tpublic static int[] price_table;\n\t\n\tpublic static int[][][][] memo = new int[20][20][101][1 << 10];\n\t\n\tpublic static int dps(int x, int y, int bit, int time){\n\t\tboolean over = true;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((bit & (1 << i)) == 0 && end[i] > time){\n\t\t\t\tover = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(over){\n\t\t\tmemo[y][x][time][bit] = price_table[bit];\n\t\t\treturn price_table[bit];\n\t\t}\n\t\t\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x - move[0];\n\t\t\tfinal int ny = y - move[1];\n\t\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] < 0){\n\t\t\t\tcontinue;\n\t\t\t}else if(!set.contains(map[ny][nx])){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int pos = Collections.binarySearch(list, map[ny][nx]);\n\t\t\t\n\t\t\tif(time < start[pos]){\n\t\t\t\tcontinue;\n\t\t\t}else if(time >= end[pos]){\n\t\t\t\tcontinue;\n\t\t\t}else if((bit & (1 << pos)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//buy\n\t\t\tbit |= (1 << pos);\n\t\t}\n\t\t\n\t\tif(memo[y][x][time][bit] >= 0){\n\t\t\treturn memo[y][x][time][bit];\n\t\t}\n\t\t\n\t\t//next\n\t\tint max = 0;\n\t\tfor(int[] move : next_dir){\n\t\t\tfinal int nx = x - move[0];\n\t\t\tfinal int ny = y - move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] >= 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(max, dps(nx, ny, bit, time + 1));\n\t\t}\n\t\t\n\t\tmemo[y][x][time][bit] = max;\n\t\treturn max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\t\n\t\t\t\t\tif('0' <= in[0] && in[0] <= '9'){\n\t\t\t\t\t\tmap[i][j] = (in[0] - '0');\n\t\t\t\t\t}else if(in[0] == 'P'){\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tn = sc.nextInt();\n\t\t\t\n\t\t\tint[] prices = new int[10];\n\t\t\tstart = new int[10];\n\t\t\tend = new int[10];\n\t\t\tset = new HashSet<Integer>();\n\t\t\tlist = new ArrayList<Integer>();\n\t\t\tint max_time = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int g = sc.nextInt();\n\t\t\t\t\n\t\t\t\tprices[g] = sc.nextInt();\n\t\t\t\tstart[g] = sc.nextInt();\n\t\t\t\tend[g] = sc.nextInt();\n\t\t\t\tset.add(g);\n\t\t\t\tlist.add(g);\n\t\t\t\t\n\t\t\t\tmax_time = Math.max(max_time, end[g]);\n\t\t\t}\n\t\t\t\n\t\t\tprice_table = new int[1 << n];\n\t\t\tfor(int i = 0; i < 1 << n; i++){\n\t\t\t\tint p = 0;\n\t\t\t\t\n\t\t\t\tfor(int b = 0; b < n; b++){\n\t\t\t\t\tif((i & (1 << b)) != 0){\n\t\t\t\t\t\tp += prices[b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprice_table[i] = p;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tfor(int t = 0; t <= 100; t++){\n\t\t\t\t\t\tfor(int b = 0; b < (1 << n); b++){\n\t\t\t\t\t\t\tmemo[y][x][t][b] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dps(sx, sy, 0, 0));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tPriorityQueue<State> deque = new PriorityQueue<State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, 0));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (state.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tint nextbit = state.bit;\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (((nextbit >> num) & 1) == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit = nextbit | (1<<num);\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextbit, nextvalue));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State implements Comparable<State> {\n\t\tint y, x, step, bit, value;\n\n\t\tpublic State(int y, int x, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [y=\" + y + \", x=\" + x + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn Integer.bitCount(o.bit)-Integer.bitCount(this.bit);\n\t\t}\n\t\t\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint w,h;\n\t\n\tclass Goods{\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\t\n\tclass State{\n\t\tint x,y,step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) ==0) break;\n\t\t\tchar [][] data = new char[h][w];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.next().charAt(0);\n\t\t\t\t\tif(data[i][j] == 'P'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = sc.nextInt(), maxT = 0;\n\t\t\tHashMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor(int i = 0; i < n;i++){\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint start = sc.nextInt();\n\t\t\t\tint end = sc.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, 0, 0));\n\t\t\tboolean [][][][] close = new boolean[h][w][1 << n][maxT + 1];\n\t\t\tclose[sy][sx][0][0] = true;\n\t\t\tint ans = 0;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif(now.step >= maxT){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.bit == (1 << n) - 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\tif(data[yy][xx] != '.') continue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tint xxx = xx + vx[j];\n\t\t\t\t\t\tint yyy = yy + vy[j];\n\t\t\t\t\t\tif(! isOK(xxx, yyy)) continue;\n\t\t\t\t\t\tif(data[yyy][xxx] != '.'){\n\t\t\t\t\t\t\tGoods g = map.get(data[yyy][xxx] - '0');\n\t\t\t\t\t\t\tif(g.start <= nextstep && nextstep < g.end){\n\t\t\t\t\t\t\t\tif((nextbit & (1 << g.num)) > 0) continue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(close[yy][xx][nextbit][nextstep]) continue;\n\t\t\t\t\topen.add(new State(xx, yy, nextstep, nextbit, nextvalue));\n\t\t\t\t\tclose[yy][xx][nextbit][nextstep] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint R, C;\n\tint[][] table;\n\n\tint[] gain;\n\tint[] start;\n\tint[] end;\n\n\tint[] totalGain;\n\n\tint startR;\n\tint startC;\n\n\tint[][][] item;\n\tboolean[][][][] vis;\n\n\tint[] dr = {0, 1, 0, -1, 0};\n\tint[] dc = {1, 0, -1, 0, 0};\n\n\tvoid solve() {\n\t\tC = sc.nextInt();\n\t\tR = sc.nextInt();\n\t\tif (R == 0) return;\n\t\ttable = new int[R][C];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ttable[i][j] = (ch - '0');\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif (ch == 'P') {\n\t\t\t\t\tstartR = i;\n\t\t\t\t\tstartC = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M = 8;\n\t\tint m = sc.nextInt();\n\t\tgain = new int[M];\n\t\tstart = new int[M];\n\t\tend = new int[M];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint id = sc.nextInt();\n\t\t\tgain[id] = sc.nextInt();\n\t\t\tstart[id] = sc.nextInt();\n\t\t\tend[id] = sc.nextInt();\n\t\t}\n\t\titem = new int[R][C][101];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tif (table[i][j] != -1)\n\t\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ni = i + dr[k];\n\t\t\t\t\t\tint nj = j + dc[k];\n\t\t\t\t\t\tif (isin(ni, nj)) {\n\t\t\t\t\t\t\tint id = table[i][j];\n\t\t\t\t\t\t\tfor (int t = start[id]; t <= end[id]; t++)\n\t\t\t\t\t\t\t\titem[ni][nj][t] |= 1 << table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\ttotalGain = new int[1 << M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\ttotalGain[1 << i] = gain[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int s = 0; s < 1 << M; s++) {\n\t\t\t\tif ((s >> i & 1) == 1)\n\t\t\t\t\ttotalGain[s] += totalGain[s ^ (1<<i)];\n\t\t\t}\n\t\t}\n\t\tvis = new boolean[R][C][1 << M][101];\n\t\tQueue<State> q = new ArrayDeque<State>();\n\t\tState init = new State(startR, startC, item[startR][startC][0], 0);\n\t\tq.add(init);\n\t\tinit.vis(true);\n\t\tint ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tState s = q.poll();\n\t\t\tans = Math.max(ans, totalGain[s.set]);\n\t\t\tif (s.time >= 100) continue;\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tint ni = s.r + dr[k];\n\t\t\t\tint nj = s.c + dc[k];\n\t\t\t\tif (isin(ni, nj) && table[ni][nj] == -1) {\n\t\t\t\t\tState next = new State(ni, nj, s.set | item[ni][nj][s.time+1], s.time + 1);\n\t\t\t\t\tif (!next.vis()) {\n\t\t\t\t\t\tnext.vis(true);\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tclass State {\n\t\tint r, c, set, time;\n\t\tpublic State(int r, int c, int set, int time) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.set = set;\n\t\t\tthis.time = time;\n\t\t}\n\t\tboolean vis() {\n\t\t\treturn vis[r][c][set][time];\n\t\t}\n\t\tvoid vis(boolean b) {\n\t\t\tvis[r][c][set][time] = b;\n\t\t}\n\t}\n\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint sy = -1;\n\t\t\tint sx = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = scanner.next().charAt(0);\n\t\t\t\t\tif (now == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = Character.getNumericValue(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tGoods[] goods = new Goods[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tgoods[num] = new Goods(c, start, end);\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\t\t\tDeque<State> deque = new ArrayDeque<Main.State>();\n\t\t\tdeque.offer(new State(sy, sx, 0, 0, 0));\n\t\t\tboolean[][][][] b = new boolean[maxT + 1][1 << n][h][w];\n\t\t\tb[2][0][sy][sx]=true;\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tState state = deque.poll();\n\t\t\t\tans = Math.max(ans, state.value);\n\t\t\t\tint y = state.y;\n\t\t\t\tint x = state.x;\n\t\t\t\tif (state.step == maxT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (state.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = m[0] + y;\n\t\t\t\t\tint nx = m[1] + x;\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = state.step + 1;\n\t\t\t\t\tint nextbit = state.bit;\n\t\t\t\t\tint nextvalue = state.value;\n\t\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\t\tint nny = mo[0] + ny;\n\t\t\t\t\t\tint nnx = mo[1] + nx;\n\t\t\t\t\t\tif (!isOK(nny, nnx))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (map[nny][nnx] == -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint num = map[nny][nnx];\n\t\t\t\t\t\tif (goods[num].start <= nextstep\n\t\t\t\t\t\t\t\t&& nextstep < goods[num].end) {\n\t\t\t\t\t\t\tif (((nextbit >> num) & 1) == 1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tnextbit = nextbit | (1<<num);\n\t\t\t\t\t\t\tnextvalue += goods[num].c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b[nextstep][nextbit][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tb[nextstep][nextbit][ny][nx] = true;\n\t\t\t\t\tdeque.offer(new State(ny, nx, nextstep, nextbit, nextvalue));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass State {\n\t\tint y, x, step, bit, value;\n\n\t\tpublic State(int y, int x, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [y=\" + y + \", x=\" + x + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\t\t\n\n\t}\n\n\tclass Goods {\n\t\tint c, start, end;\n\n\t\tpublic Goods(int c, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.c = c;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [c=\" + c + \", start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint R, C;\n\tint[][] table;\n\n\tint[] gain;\n\tint[] start;\n\tint[] end;\n\n\tint[] totalGain;\n\n\tint startR;\n\tint startC;\n\n\tint[][][] item;\n\tboolean[][][][] vis;\n\n\tint[] dr = {0, 1, 0, -1, 0};\n\tint[] dc = {1, 0, -1, 0, 0};\n\n\tvoid solve() {\n\t\tC = sc.nextInt();\n\t\tR = sc.nextInt();\n\t\tif (R == 0) return;\n\t\ttable = new int[R][C];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ttable[i][j] = (ch - '0');\n\t\t\t\t} else {\n\t\t\t\t\ttable[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif (ch == 'P') {\n\t\t\t\t\tstartR = i;\n\t\t\t\t\tstartC = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = sc.nextInt();\n\t\tgain = new int[m];\n\t\tstart = new int[m];\n\t\tend = new int[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint id = sc.nextInt();\n\t\t\tgain[id] = sc.nextInt();\n\t\t\tstart[id] = sc.nextInt();\n\t\t\tend[id] = sc.nextInt();\n\t\t}\n\n\t\titem = new int[R][C][101];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tif (table[i][j] != -1)\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tint ni = i + dr[k];\n\t\t\t\t\tint nj = j + dc[k];\n\t\t\t\t\tif (isin(ni, nj)) {\n\t\t\t\t\t\tint id = table[i][j];\n\t\t\t\t\t\tfor (int t = start[id]; t <= end[id]; t++)\n\t\t\t\t\t\t\titem[ni][nj][t] |= 1 << table[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\ttotalGain = new int[1 << m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ttotalGain[1 << i] = gain[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int s = 0; s < 1 << m; s++) {\n\t\t\t\tif ((s >> i & 1) == 1)\n\t\t\t\t\ttotalGain[s] += totalGain[s ^ (1<<i)];\n\t\t\t}\n\t\t}\n\t\tvis = new boolean[R][C][1 << m][101];\n\t\tQueue<State> q = new ArrayDeque<State>();\n\t\tState init = new State(startR, startC, item[startR][startC][0], 0);\n\t\tq.add(init);\n\t\tinit.vis(true);\n\t\tint ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tState s = q.poll();\n\t\t\tans = Math.max(ans, totalGain[s.set]);\n\t\t\tif (s.time >= 100) continue;\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tint ni = s.r + dr[k];\n\t\t\t\tint nj = s.c + dc[k];\n\t\t\t\tif (isin(ni, nj) && table[ni][nj] == -1) {\n\t\t\t\t\tState next = new State(ni, nj, s.set | item[ni][nj][s.time+1], s.time + 1);\n\t\t\t\t\tif (!next.vis()) {\n\t\t\t\t\t\tnext.vis(true);\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tclass State {\n\t\tint r, c, set, time;\n\t\tpublic State(int r, int c, int set, int time) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.set = set;\n\t\t\tthis.time = time;\n\t\t}\n\t\tboolean vis() {\n\t\t\treturn vis[r][c][set][time];\n\t\t}\n\t\tvoid vis(boolean b) {\n\t\t\tvis[r][c][set][time] = b;\n\t\t}\n\t}\n\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] data = new char[h][w];\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdata[i][j] = scanner.next().charAt(0);\n\t\t\t\t\tif (data[i][j] == 'P') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = scanner.nextInt();\n\t\t\tint maxT = 0;\n\t\t\tMap<Integer, Goods> map = new HashMap<Integer, Main.Goods>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint num = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint start = scanner.nextInt();\n\t\t\t\tint end = scanner.nextInt();\n\t\t\t\tmap.put(num, new Goods(i, d, start, end));\n\t\t\t\tmaxT = Math.max(maxT, end);\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.offer(new State(sx, sy, 0, 0, 0));\n\t\t\tint ans = 0;\n\t\t\tint[][][] bits = new int[maxT + 1][h][w];\n\t\t\twhile (!open.isEmpty()) {\n\t\t\t\tState now = open.poll();\n\t\t\t\tans = Math.max(ans, now.value);\n\t\t\t\tif (now.step >= maxT)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (now.bit == (1 << n) - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = now.x + vx[i];\n\t\t\t\t\tint ny = now.y + vy[i];\n\t\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (data[ny][nx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nextstep = now.step + 1;\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tint nextvalue = now.value;\n\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nnx = nx + vx[j];\n\t\t\t\t\t\tint nny = ny + vy[j];\n\t\t\t\t\t\tif (!isOK(nnx, nny))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (data[nny][nnx] != '.') {\n\t\t\t\t\t\t\tGoods g = map.get(data[nny][nnx] - '0');\n\t\t\t\t\t\t\tif (g.start <= nextstep && nextstep < g.end) {\n\t\t\t\t\t\t\t\tif ((nextbit & (1 << g.num)) > 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tnextbit = nextbit | (1 << g.num);\n\t\t\t\t\t\t\t\tnextvalue += g.d;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (nextbit != 0\n\t\t\t\t\t\t\t&& (bits[nextstep][ny][nx] | nextbit) == bits[nextstep][ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbits[nextstep][ny][nx] = nextbit;\n\t\t\t\t\topen.offer(new State(nx, ny, nextstep, nextbit, nextvalue));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[] vx = { 0, -1, 1, 0 };\n\tint[] vy = { -1, 0, 0, 1 };\n\n\tclass State implements Comparable<State> {\n\t\tint x, y, step, bit, value;\n\n\t\tpublic State(int x, int y, int step, int bit, int value) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.bit = bit;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [x=\" + x + \", y=\" + y + \", step=\" + step + \", bit=\"\n\t\t\t\t\t+ bit + \", value=\" + value + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn o.value - this.value;\n\t\t}\n\n\t}\n\n\tclass Goods {\n\t\tint num, d, start, end;\n\n\t\tpublic Goods(int num, int d, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.d = d;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Goods [num=\" + num + \", d=\" + d + \", start=\" + start\n\t\t\t\t\t+ \", end=\" + end + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int t { get; set; }\n\tpublic int d { get; set; }\n\tpublic int visited { get; set; }\n}\n\npublic class hello\n{\n\tpublic static int h, w;\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tvar map = new int[h, w];\n\t\t\tvar sx = 0; var sy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (line[j] == \"P\") { map[i, j] = -1; sx = i; sy = j; }\n\t\t\t\t\telse if (line[j] == \".\") map[i, j] = -1;\n\t\t\t\t\telse map[i, j] = int.Parse(line[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar data = new int[10, 3];\n\t\t\tvar tmax = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tvar id = int.Parse(line[0]);\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[id, j] = int.Parse(line[j + 1]);\n\t\t\t\t\tif (j == 2) tmax = Max(tmax, data[id, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = getAns(map, data, n, sx, sy, tmax);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic int getAns(int[,] map, int[,] data, int n, int sx, int sy, int tmax)\n\t{\n\t\tvar ans = 0;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar used = new bool[h, w, 1 << 10,tmax+2];\n\t\tused[sx, sy, 0,0] = true;\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { x = sx, y = sy , t = 0 });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\tvar www = Convert.ToString(a.visited, 2);\n\t\t\tif (a.t > tmax) { ans = Max(ans, a.d); continue; }\n\t\t\tvar nvisited = a.visited;\n\t\t\tvar nd = a.d;\n\t\t\tvar nt = a.t + 1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = a.x + dx[i];\n\t\t\t\tvar ny = a.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t\t{\n\t\t\t\t\tvar mp = map[nx, ny];\n\t\t\t\t\tif (mp != -1 && canGet(nvisited, mp, a.t, data))\n\t\t\t\t\t{\n\t\t\t\t\t\tnvisited |= 1 << mp;\n\t\t\t\t\t\tnd += data[mp, 0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = a.x + dx[i];\n\t\t\t\tvar ny = a.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t\t{\n\t\t\t\t\tvar mp = map[nx, ny];\n\t\t\t\t\tif (mp == -1 && !used[nx, ny, nvisited,nt])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.Enqueue(new P { x = nx, y = ny, d = nd, t = nt, visited = nvisited });\n\t\t\t\t\t\tused[nx, ny, nvisited,nt] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic bool canGet(int a, int mp, int t, int[,] data)\n\t\t=> (t >= data[mp, 1] && t < data[mp, 2]) && (((a >> mp) & 1) == 0);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0245\n{\n    class Program\n    {\n        const int BLANK_NUM = -1;\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        class State\n        {\n            public int I { get; set; }\n            public int J { get; set; }\n            public int Time { get; set; }\n            public int Amount { get; set; }\n            public int GotItem { get; set; }\n            public State(int i, int j, int time, int amount, int gotItem)\n            {\n                I = i;\n                J = j;\n                Time = time;\n                Amount = amount;\n                GotItem = gotItem;\n            }\n        }\n\n        class Item\n        {\n            public int Price { get; set; }\n            public int Start { get; set; }\n            public int End { get; set; }\n            public Item(int price, int start, int end)\n            {\n                Price = price;\n                Start = start;\n                End = end;\n            }\n        }\n\n        static int[,] map;\n        static Dictionary<int, Item> Items;\n        static int sI, sJ;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                Console.WriteLine(CalcMaxAmount());\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string[] ms = RArSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (ms[j] == \"P\")\n                    {\n                        map[i, j] = BLANK_NUM;\n                        sI = i; sJ = j;\n                    }\n                    else if (ms[j] == \".\") map[i, j] = BLANK_NUM;\n                    else map[i, j] = int.Parse(ms[j]);\n                }\n            }\n\n            Items = new Dictionary<int, Item>();\n            int n = RInt();\n            for (int i = 0; i < n; i++)\n            {\n                int[] vs = RArInt();\n                Items.Add(vs[0], new Item(vs[1], vs[2], vs[3]));\n            }\n        }\n\n        private static int CalcMaxAmount()\n        {\n            int res = 0;\n            int maxE = Items.Max(x => x.Value.End);\n            bool[,,,] visited = new bool[map.GetLength(0), map.GetLength(1), (int)Math.Pow(2, Items.Count()), maxE + 1];\n\n            Queue<State> q = new Queue<State>();\n            q.Enqueue(new State(sI, sJ, 0, 0, 0));\n\n            while (q.Count > 0)\n            {\n                State cur = q.Dequeue();\n                res = Math.Max(res, cur.Amount);\n\n                if (cur.GotItem == (int)Math.Pow(2, Items.Count()) - 1) break;\n                if (cur.Time >= maxE) continue;\n                if (visited[cur.I, cur.J, cur.GotItem, cur.Time]) continue;\n                visited[cur.I, cur.J, cur.GotItem, cur.Time] = true;\n\n                int nAmount = cur.Amount;\n                int nItems = cur.GotItem;\n                for (int i = 0; i < di.Length; i++)\n                {\n                    int nI = cur.I + di[i];\n                    int nJ = cur.J + dj[i];\n                    if (IsInArea(nI, nJ) && map[nI, nJ] != BLANK_NUM && ((nItems >> map[nI, nJ]) & 1) == 0)\n                    {\n                        if (Items[map[nI, nJ]].Start <= cur.Time && cur.Time < Items[map[nI, nJ]].End)\n                        {\n                            nAmount += Items[map[nI, nJ]].Price;\n                            nItems |= 1 << map[nI, nJ];\n                        }\n                    }\n                }\n\n                for (int i = 0; i < di.Length; i++)\n                {\n                    int nI = cur.I + di[i];\n                    int nJ = cur.J + dj[i];\n                    if (IsInArea(nI, nJ) && map[nI, nJ] == BLANK_NUM)\n                    {\n                        q.Enqueue(new State(nI, nJ, cur.Time + 1, nAmount, nItems));\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int t { get; set; }\n\tpublic int d { get; set; }\n\tpublic int visited { get; set; }\n}\n\npublic class hello\n{\n\tpublic static int h, w;\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tvar map = new int[h, w];\n\t\t\tvar sx = 0; var sy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (line[j] == \"P\") { map[i, j] = -1; sx = i; sy = j; }\n\t\t\t\t\telse if (line[j] == \".\") map[i, j] = -1;\n\t\t\t\t\telse map[i, j] = int.Parse(line[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar data = new int[10, 3];\n\t\t\tvar tmax = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tvar id = int.Parse(line[0]);\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[id, j] = int.Parse(line[j + 1]);\n\t\t\t\t\tif (j == 2) tmax = Max(tmax, data[id, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = getAns(map, data, n, sx, sy, tmax);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic int getAns(int[,] map, int[,] data, int n, int sx, int sy, int tmax)\n\t{\n\t\tvar ans = 0;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar used = new bool[h, w, 1 << 10];\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { x = sx, y = sy });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\tvar www = Convert.ToString(a.visited, 2);\n\t\t\tif (a.t > tmax) { ans = Max(ans, a.d); continue; }\n\t\t\tvar nvisited = a.visited;\n\t\t\tvar nd = a.d;\n\t\t\tvar nt = a.t + 1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = a.x + dx[i];\n\t\t\t\tvar ny = a.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t\t{\n\t\t\t\t\tvar mp = map[nx, ny];\n\t\t\t\t\tif (mp != -1 && canGet(nvisited, mp, a.t, data))\n\t\t\t\t\t{\n\t\t\t\t\t\tnvisited |= 1 << mp;\n\t\t\t\t\t\tnd += data[mp, 0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = a.x + dx[i];\n\t\t\t\tvar ny = a.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t\t{\n\t\t\t\t\tvar mp = map[nx, ny];\n\t\t\t\t\tif (mp == -1 && !used[nx, ny, nvisited])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.Enqueue(new P { x = nx, y = ny, d = nd, t = nt, visited = nvisited });\n\t\t\t\t\t\tused[nx, ny, nvisited] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic bool canGet(int a, int mp, int t, int[,] data)\n\t\t=> (t >= data[mp, 1] && t < data[mp, 2]) && (((a >> mp) & 1) == 0);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int t { get; set; }\n\tpublic int d { get; set; }\n\tpublic int visited { get; set; }\n}\n\npublic class hello\n{\n\tpublic static int h, w;\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tvar map = new int[h, w];\n\t\t\tvar sx = 0; var sy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tif (line[j] == \"P\") { map[i, j] = -1; sx = i; sy = j; }\n\t\t\t\t\telse if (line[j] == \".\") map[i, j] = -1;\n\t\t\t\t\telse map[i, j] = int.Parse(line[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tvar data = new int[10, 3];\n\t\t\tvar tmax = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tvar id = int.Parse(line[0]);\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tdata[id, j] = int.Parse(line[j + 1]);\n\t\t\t\t\tif (j == 2) tmax = Max(tmax, data[id, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = getAns(map, data, n, sx, sy, tmax);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic int getAns(int[,] map, int[,] data, int n, int sx, int sy, int tmax)\n\t{\n\t\tvar ans = 0;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar used = new bool[h, w, 1 << 10];\n\t\tused[sx, sy, 0] = true;\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { x = sx, y = sy });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\tvar www = Convert.ToString(a.visited, 2);\n\t\t\t//Console.WriteLine(\"x = {0} y = {1} d = {2} t = {3} v = {4}\", a.x, a.y, a.d, a.t, www);\n\t\t\tif (a.t > tmax) { ans = Max(ans, a.d); continue; }\n\t\t\tvar nvisited = a.visited;\n\t\t\tvar nd = a.d;\n\t\t\tvar nt = a.t + 1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = a.x + dx[i];\n\t\t\t\tvar ny = a.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t\t{\n\t\t\t\t\tvar mp = map[nx, ny];\n\t\t\t\t\tif (mp != -1 && canGet(nvisited, mp, a.t, data))\n\t\t\t\t\t{\n\t\t\t\t\t\tnvisited |= 1 << mp;\n\t\t\t\t\t\tnd += data[mp, 0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = a.x + dx[i];\n\t\t\t\tvar ny = a.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t\t{\n\t\t\t\t\tvar mp = map[nx, ny];\n\t\t\t\t\tif (mp == -1 && !used[nx, ny, nvisited])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.Enqueue(new P { x = nx, y = ny, d = nd, t = nt, visited = nvisited });\n\t\t\t\t\t\tused[nx, ny, nvisited] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic bool canGet(int a, int mp, int t, int[,] data)\n\t\t=> (t >= data[mp, 1] && t < data[mp, 2]) && (((a >> mp) & 1) == 0);\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      cache = {}\n      define_method(name) do |*args|\n        cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\n\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n  nbits = bits\n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      if (nbits & (1<<p)) != 0\n        sum += $sales[p][0]\n        nbits ^= (1<<p)\n      end\n    end\n  end\n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, nbits)\n    res = [res, tmp].max\n  end\n  sum + res\nend\n\n\n\ndef prepare(x, y, c)\n  [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n      unless c.nil? \n        $fld[ny][nx] += [c] unless $fld[ny][nx].include?(c)    \n      else $mv[y][x] += [[nx, ny]]\n      end\n    end\n  end\nend\n\nwhile true\n  include Memoizable\n  memoize :solve\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n\n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        prepare(x, y, c.to_i)\n        $fld[y][x] = nil\n      end\n    end\n  end\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        prepare(x, y, nil)\n      end\n    end\n  end\n  $n = gets.to_i\n  $max_t = 0\n  $sales = []\n  $n.times do\n    arr = gets.split(' ').map(&:to_i)\n    $sales[arr[0]] = arr[1..-1]\n    $max_t = [$max_t, arr[3]].max\n  end\n  p $max_t\n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "\nmodule Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      define_method(name) do |*args|\n        $cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\n\ninclude Memoizable\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n  nbits = bits\n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      if (nbits & (1<<p)) != 0\n        sum += $sales[p][0]\n        nbits ^= (1<<p)\n      end\n    end\n  end\n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, nbits)\n    res = [res, tmp].max\n  end\n  sum + res\nend\n\nmemoize :solve\n\ndef prepare(x, y, c)\n  [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n      unless c.nil? \n        $fld[ny][nx] += [c] unless $fld[ny][nx].include?(c)    \n      else $mv[y][x] += [[nx, ny]]\n      end\n    end\n  end\nend\n\nwhile true\n  $cache = {}\n\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n\n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        prepare(x, y, c.to_i)\n        $fld[y][x] = nil\n      end\n    end\n  end\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        prepare(x, y, nil)\n      end\n    end\n  end\n  $n = gets.to_i\n  $max_t = 0\n  $sales = []\n  $n.times do\n    arr = gets.split(' ').map(&:to_i)\n    $sales[arr[0]] = arr[1..-1]\n    $max_t = [$max_t, arr[3]].max\n  end\n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      cache = {}\n      define_method(name) do |*args|\n        cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\ninclude Memoizable\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n  nbits = bits\n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      if (nbits & (1<<p)) != 0\n        sum += $sales[p][0]\n        nbits ^= (1<<p)\n      end\n    end\n  end\n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, nbits)\n    res = [res, tmp].max\n  end\n  sum + res\nend\n\nmemoize :solve\n\ndef prepare(x, y, c)\n  [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n      unless c.nil? \n        $fld[ny][nx] += [c] unless $fld[ny][nx].include?(c)    \n      else $mv[y][x] += [[nx, ny]]\n      end\n    end\n  end\nend\n\nwhile true\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n  \n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        prepare(x, y, c.to_i)\n        $fld[y][x] = nil\n      end\n    end\n  end\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        prepare(x, y, nil)\n      end\n    end\n  end\n  $n = gets.to_i\n  $max_t = 0\n  $sales = []\n  $n.times do\n    arr = gets.split(' ').map(&:to_i)\n    $sales[arr[0]] = arr[1..-1]\n    $max_t = [$max_t, arr[3]].max\n  end\n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      cache = {}\n      define_method(name) do |*args|\n        cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\nD = [[1, 0], [0, -1], [-1, 0], [0, 1]]\ninclude Memoizable\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n \n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      b = (1 << p)\n      if (bits & b) != 0\n        sum += $sales[p][0]\n        bits ^= b\n      end\n    end\n  end\n \n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, bits)\n    res = [res, tmp].max\n  end\n  return sum + res\nend\n\nmemoize :solve\n\nwhile true\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n    \n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        c = c.to_i\n        D.each do |dx, dy|\n          nx, ny = x + dx, y + dy\n          if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n            $fld[ny][nx] += [c]\n          end\n        end\n        $fld[y][x] = nil\n      end\n    end\n  end\n  p $fld\n  $fld.each{|arr| arr.map{|a| a.uniq! unless a.nil?}}\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        D.each do |dx, dy|\n          nx, ny = x + dx, y + dy\n          if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n            $mv[ny][nx] += [[x, y]]\n          end\n        end\n      end\n    end\n  end\n  p $fld\n  p $mv\n  $n = gets.to_i\n  $max_t = 0\n\n  $sales = $n.times.each_with_object([]){ |_, arr| tmp = gets.split(\" \").map(&:to_i); arr << tmp[0]; arr << tmp[1,3]; $max_t = [$max_t, tmp[3]].max }\n  $sales = Hash[*$sales]\n \n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDIRCS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### subroutines\n\ndef neighbors(pos)\n  x = pos % $w\n  y = pos / $w\n  for dxy in DIRCS\n    x0 = x + dxy[0]\n    y0 = y + dxy[1]\n    if x0 >= 0 && x0 < $w && y0 >= 0 && y0 < $h\n      yield (y0 * $w + x0)\n    end\n  end\nend\n\ndef max_discount(t, pos, gbits)\n  return 0 if t >= $max_et\n  return $mdcache[t][pos][gbits] if ! $mdcache[t][pos][gbits].nil?\n\n  dsum = 0\n  gbits0 = gbits\n\n  for g in $brds[pos]\n    if t >= $goods[g][1] && t < $goods[g][2]\n      gb = (1 << g)\n      if (gbits0 & gb) != 0\n        dsum += $goods[g][0]\n        gbits0 ^= gb\n      end\n    end\n  end\n\n  max_d0 = 0\n\n  for pos0 in $npos[pos]\n    d0 = max_discount(t + 1, pos0, gbits0)\n    if max_d0 < d0\n      max_d0 = d0\n    end\n  end\n\n  $mdcache[t][pos][gbits] = dsum + max_d0\nend\n\n### main\n\nwhile true\n  $w, $h = gets.strip.split(' ').map{|s| s.to_i}\n  $wh = $w * $h\n  break if $wh == 0\n\n  start = nil\n  $brds = $wh.times.map{[]}\n\n  for y in (0...$h)\n    hl = gets.strip.split(' ')\n    for x in (0...$w)\n      pos = y * $w + x\n      case hl[x]\n      when 'P'\n        start = pos\n      when '0'..'9'\n        g = hl[x].to_i\n        neighbors(pos) do |pos0|\n          if ! $brds[pos0].nil? && ! $brds[pos0].include?(g)\n            $brds[pos0] << g\n          end\n        end\n        $brds[pos] = nil\n      end\n    end\n  end\n  #p pos\n  #p $brds\n\n  $npos = []\n  for pos in (0...$wh)\n    if ! $brds[pos].nil?\n      nbrs = []\n      neighbors(pos) do |pos0|\n        if ! $brds[pos0].nil?\n          nbrs << pos0\n        end\n      end\n      $npos[pos] = nbrs\n    end\n  end\n  #p $npos\n\n  $n = gets.strip.to_i\n  $goods = []\n  $max_et = 0\n\n  $n.times do\n    g, d, st, et = gets.strip.split(' ').map{|s| s.to_i}\n    $goods[g] = [d, st, et]\n    $max_et = et if $max_et < et\n  end\n  #p $goods\n  #p $max_et\n\n  $mdcache = $max_et.times.map{$wh.times.map{[]}}\n\n  max_d = max_discount(0, start, (1 << $n) - 1)\n  puts max_d\nend"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      cache = {}\n      define_method(name) do |*args|\n        cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\nD = [[1, 0], [0, -1], [-1, 0], [0, 1]]\ninclude Memoizable\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n \n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      b = (1 << p)\n      if (bits & b) != 0\n        sum += $sales[p][0]\n        bits ^= b\n      end\n    end\n  end\n \n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, bits)\n    res = [res, tmp].max\n  end\n  return sum + res\nend\n\nmemoize :solve\n\nwhile true\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n    \n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        c = c.to_i\n        D.each do |dx, dy|\n          nx, ny = x + dx, y + dy\n          if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n            $fld[ny][nx] += [c]\n          end\n        end\n        $fld[y][x] = nil\n      end\n    end\n  end\n  \n  $fld.each{|arr| arr.map{|a| a.uniq! unless a.nil?}}\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        D.each do |dx, dy|\n          nx, ny = x + dx, y + dy\n          if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n            $mv[ny][nx] += [[x, y]]\n          end\n        end\n      end\n    end\n  end\n\n  $n = gets.to_i\n  $max_t = 0\n\n  $sales = $n.times.each_with_object([]){ |_, arr| tmp = gets.split(\" \").map(&:to_i); arr << tmp[0]; arr << tmp[1,3]; $max_t = [$max_t, tmp[3]].max }\n  $sales = Hash[*$sales]\n \n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      cache = {}\n      define_method(name) do |*args|\n        cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\ninclude Memoizable\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      if (bits & (1<<p)) != 0\n        sum += $sales[p][0]\n        bits ^= (1<<p)\n      end\n    end\n  end\n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, bits)\n    res = [res, tmp].max\n  end\n  sum + res\nend\n\nmemoize :solve\n\ndef prepare(x, y, c)\n  [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n      unless c.nil? \n        $fld[ny][nx] += [c] unless $fld[ny][nx].include?(c)    \n      else $mv[y][x] += [[nx, ny]]\n      end\n    end\n  end\nend\n\nwhile true\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n  \n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        prepare(x, y, c.to_i)\n        $fld[y][x] = nil\n      end\n    end\n  end\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        prepare(x, y, nil)\n      end\n    end\n  end\n  $n = gets.to_i\n  $max_t = 0\n\n  $sales = $n.times.each_with_object([]){ |_, arr| tmp = gets.split(\" \").map(&:to_i); arr << tmp[0]; arr << tmp[1,3]; $max_t = [$max_t, tmp[3]].max }\n  $sales = Hash[*$sales]\n \n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      cache = {}\n      define_method(name) do |*args|\n        cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\ninclude Memoizable\n\ndef solve(t, px, py, bits)\n  return 0 if t >= $max_t \n  sum = 0\n  nbits = bits\n  for p in $fld[py][px]\n    if t >= $sales[p][1] && t < $sales[p][2]\n      if (nbits & (1<<p)) != 0\n        sum += $sales[p][0]\n        nbits ^= (1<<p)\n      end\n    end\n  end\n  res = 0\n  $mv[py][px].each do |x, y|\n    tmp = solve(t + 1, x, y, nbits)\n    res = [res, tmp].max\n  end\n  sum + res\nend\n\nmemoize :solve\n\ndef prepare(x, y, c)\n  [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[ny][nx].nil?\n      unless c.nil? \n        $fld[ny][nx] += [c] unless $fld[ny][nx].include?(c)    \n      else $mv[y][x] += [[nx, ny]]\n      end\n    end\n  end\nend\n\nwhile true\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = $h.times.map{ Array.new($w, []) }\n  \n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      sx, sy = x, y if c == 'P'\n      if ('0'..'9').include? c\n        prepare(x, y, c.to_i)\n        $fld[y][x] = nil\n      end\n    end\n  end\n  $mv = $h.times.map{ Array.new($w, []) }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y][x].nil?\n        prepare(x, y, nil)\n      end\n    end\n  end\n  $n = gets.to_i\n  $max_t = 0\n\n  $sales = $n.times.each_with_object([]){ |_, arr| tmp = gets.split(\" \").map(&:to_i); arr << tmp[0]; arr << tmp[1,3]; $max_t = [$max_t, tmp[3]].max }\n  $sales = Hash[*$sales]\n \n  p solve(0, sx, sy, (1 << $n) - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "\nmodule Memoizable\n  def memoize(name)\n    original = \"__original_#{name}__\"\n    self.class.class_eval do\n      alias_method original, name\n      private original\n      define_method(name) do |*args|\n        $cache[args] ||= send(original, *args)\n      end\n    end\n  end\nend\n\n\ninclude Memoizable\n\ndef solve(t, pos, bits)\n  return 0 if t >= $max_t \n  sum = 0\n  for s in $fld[pos]\n    if t >= $sales[s][1] && t < $sales[s][2]\n      if (bits & (1<<s)) != 0\n        sum += $sales[s][0]\n        bits ^= (1<<s)\n      end\n    end\n  end\n  res = 0\n  for p in $mv[pos].each\n    tmp = solve(t + 1, p, bits)\n    res = [res, tmp].max\n  end\n  sum + res\nend\n\nmemoize :solve\n\ndef prepare(pos, c)\n  y, x = pos.divmod $w\n  [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$fld[p = ny * $w + nx].nil?\n      unless c.nil? \n        $fld[p] += [c] unless $fld[p].include?(c)    \n      else $mv[pos] += [p]\n      end\n    end\n  end\nend\n\nwhile true\n  $cache = {}\n  $w, $h = gets.split(' ').map(&:to_i)\n  break if $w == 0\n  start = nil\n  $fld = ($h*$w).times.map{ [] }\n\n  for y in (0...$h)\n    tmp = gets.split(' ')\n    for x in (0...$w)\n      c = tmp[x]\n      start = y * $w + x if c == 'P'\n      if ('0'..'9').include? c\n        prepare(y * $w + x, c.to_i)\n        $fld[y * $w + x] = nil\n      end\n    end\n  end\n  $mv = ($h*$w).times.map{ [] }\n  for y in (0...$h)\n    for x in (0...$w)\n      unless $fld[y * $w + x].nil?\n        prepare(y * $w + x, nil)\n      end\n    end\n  end\n  $n = gets.to_i\n  $max_t = 0\n  $sales = []\n  $n.times do\n    arr = gets.split(' ').map(&:to_i)\n    $sales[arr[0]] = arr[1..-1]\n    $max_t = [$max_t, arr[3]].max\n  end\n  p solve(0, start, (1 << $n) - 1)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  types = new Type[](8);\n  board = new char[][](20, 20);\n  memo = new int[][][][](20, 20, 101, 1 << 8);\n\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\nimport std.bigint;\n\nint[21][21] map;\nint[int] d_list;\nint[int] s_list;\nint[int] e_list;\nint x, y;\nint[2] P;\nint n;\n\nint INF = 1<<28;\n\nint[][] ofs = [ [1, 0], [0, 1], [0, -1], [-1, 0] ];\n\nint[int[2]][int] memo;\nint dfs(int bits, int value, int[2] p, int time){\n\tif( bits == (1<<n) -1 ){\n\t\treturn value;\n\t}\n\tif((bits in memo)){\n\t\tint[ int[2] ] ptr = *(bits in memo);\n\t\tif( p in ptr ){\n\t\t\tif( time >= memo[ bits ][ p ] ){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_ = value;\n\tforeach(k, v; d_list){\n\t\tif( ((bits>>k)&0b1)==0b0 ){\n\t\t\tint[2][] req;\n\t\t\tint[] ped_list;\n\t\t\tbfs(p, k, req, ped_list);\n\t\t\tint length = cast(int)req.length;\n\t\t\tforeach(i; length.iota){\n\t\t\t\tint t = time + ped_list[i];\n\t\t\t\tif( s_list[k] <= t && t < e_list[k] ){\n\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], t);\n\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t}else if( t < s_list[k] ){\n\t\t\t\t\tif( (s_list[k] - t)%2 == 0b0 ){\n\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], s_list[k] );\n\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], s_list[k] + 1 );\n\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmemo[ bits ][ p ] = time;\n\treturn max_;\n}\n\nbool[21][21] done;\nint[21][21] foot;\nvoid bfs( int[2] p, int trg, ref int[2][] req, ref int[] ped_list){\n\tfoot = foot.init;\n\tdone = done.init;\n\t\n\tint[2][] res;\n\t\n\tint[2][] queue;\n\tdone[p[1]][p[0]] = true;\n\tfoot[p[1]][p[0]] = 0;\n\tqueue ~= p;\n\twhile(queue.length){\n\t\tint[2] e = queue.front;  queue.popFront;\n\t\t\n\t\tforeach(ite; ofs){\n\t\t\tint[2] buf = e;\n\t\t\tbuf[] += ite[];\n\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\tint imf = map[buf[1]][buf[0]];\n\t\t\t\tif( imf == -1 ){\n\t\t\t\t\tif(!done[buf[1]][buf[0]]){\n\t\t\t\t\t\tdone[buf[1]][buf[0]] = true;\n\t\t\t\t\t\tfoot[buf[1]][buf[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\t\tqueue ~= buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( imf == trg ){\n\t\t\t\t\treq ~= e;\n\t\t\t\t\tped_list ~= foot[e[1]][e[0]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid main(){\n\twhile(true){\n\t\tx = next!int;\n\t\ty = next!int;\n\t\tif(!(x|y)) break;\n\t\tmemo = memo.init;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tstring s = next!string;\n\t\t\t\tif(s==\".\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}else if(s==\"P\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tP[0] = j;\n\t\t\t\t\tP[1] = i;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = s.to!int;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tn = next!int;\n\t\tforeach(i; n.iota){\n\t\t\tint g = next!int;\n\t\t\tint d = next!int;\n\t\t\tint s = next!int;\n\t\t\tint e = next!int;\n\t\t\td_list[g] = d;\n\t\t\ts_list[g] = s;\n\t\t\te_list[g] = e;\n\t\t}\n\t\t\n\t\tdfs(0, 0, P, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nimport std.traits;\nstring[] input;\nstring delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\nimport std.bigint;\n\nint[21][21] map;\nint[int] d_list;\nint[int] s_list;\nint[int] e_list;\nint x, y;\nint[2] P;\nint n;\nbool[int] n_done;\n\nint INF = 1<<28;\n\nbool[21][21] done;\nint[21][21] foot;\nint dfs(int depth, int value, int[2] p, int time){\n\tif(depth == n){\n\t\treturn value;\n\t}\n\t\n\tint max_ = value;\n\tforeach(k, v; d_list){\n\t\tif( !n_done[k] ){\n\t\t\tint[2][] req;\n\t\t\tint ped;\n\t\t\tbfs(p, k, req, ped);\n\t\t\tif( s_list[k] <= time + ped && time + ped < e_list[k] ){\n\t\t\t\tn_done[k] = true;\n\t\t\t\tforeach(ite; req){\n\t\t\t\t\tint res = dfs( depth + 1, value + v, ite, time + ped );\n\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t}\n\t\t\t\tn_done[k] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid bfs( int[2] p, int trg, ref int[2][] req, ref int min_ped){\n\tfoot = foot.init;\n\tdone = done.init;\n\tint[][] ofs = [ [1, 0], [0, 1], [0, -1], [-1, 0] ];\n\t\n\tint min_ = INF;\n\tint[2][] res;\n\t\n\tint[2][] queue;\n\tdone[p[1]][p[0]] = true;\n\tfoot[p[1]][p[0]] = 0;\n\tqueue ~= p;\n\twhile(queue.length){\n\t\tint[2] e = queue.front;  queue.popFront;\n\t\t\n\t\tforeach(ite; ofs){\n\t\t\tint[2] buf = e;\n\t\t\tbuf[] += ite[];\n\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\tint imf = map[buf[1]][buf[0]];\n\t\t\t\tif( imf == -1 ){\n\t\t\t\t\tif(!done[buf[1]][buf[0]]){\n\t\t\t\t\t\tdone[buf[1]][buf[0]] = true;\n\t\t\t\t\t\tfoot[buf[1]][buf[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\t\tqueue ~= buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( imf == trg ){\n\t\t\t\t\tint ped = foot[e[1]][e[0]];\n\t\t\t\t\tif( min_ > ped ){\n\t\t\t\t\t\tres = res.init;\n\t\t\t\t\t\tres ~= e;\n\t\t\t\t\t\tmin_ = ped;\n\t\t\t\t\t}else if( min_ == ped ){\n\t\t\t\t\t\tres ~= e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treq = res;\n\tmin_ped = min_;\n}\n\nvoid main(){\n\twhile(true){\n\t\tx = next!int;\n\t\ty = next!int;\n\t\tif(!(x|y)) break;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tstring s = next!string;\n\t\t\t\tif(s==\".\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}else if(s==\"P\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tP[0] = j;\n\t\t\t\t\tP[1] = i;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = s.to!int;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tn = next!int;\n\t\tforeach(i; n.iota){\n\t\t\tint g = next!int;\n\t\t\tint d = next!int;\n\t\t\tint s = next!int;\n\t\t\tint e = next!int;\n\t\t\td_list[g] = d;\n\t\t\ts_list[g] = s;\n\t\t\te_list[g] = e;\n\t\t\tn_done[g] = false;\n\t\t}\n\t\tn_done[-1] = false;\n\t\t\n\t\tdfs(0, 0, P, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nimport std.traits;\nstring[] input;\nstring delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  types = new Type[](8);\n  board = new char[][](20, 20);\n  memo = new int[][][][](20, 20, 101, 1 << 8);\n\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\nimport std.bigint;\n\nint[21][21] map;\nint[int] d_list;\nint[int] s_list;\nint[int] e_list;\nint x, y;\nint[2] P;\nint n;\nbool[int] n_done;\n\nint INF = 1<<28;\n\nbool[21][21] done;\nint[21][21] foot;\nint dfs(int depth, int value, int[2] p, int time){\n\tif(depth == n){\n\t\treturn value;\n\t}\n\t\n\tint max_ = value;\n\tforeach(k, v; d_list){\n\t\tif( !n_done[k] ){\n\t\t\tn_done[k] = true;\n\t\t\tint[2][] req;\n\t\t\tint ped;\n\t\t\tbfs(p, k, req, ped);\n\t\t\tif( s_list[k] <= time + ped && time + ped < e_list[k] ){\n\t\t\t\tforeach(ite; req){\n\t\t\t\t\tint res = dfs( depth + 1, value + v, ite, time + ped );\n\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn_done[k] = false;\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid bfs( int[2] p, int trg, ref int[2][] req, ref int min_ped){\n\tfoot = foot.init;\n\tdone = done.init;\n\tint[][] ofs = [ [1, 0], [0, 1], [0, -1], [-1, 0] ];\n\t\n\tint min_ = INF;\n\tint[2][] res;\n\t\n\tint[2][] queue;\n\tdone[p[1]][p[0]] = true;\n\tfoot[p[1]][p[0]] = 0;\n\tqueue ~= p;\n\twhile(queue.length){\n\t\tint[2] e = queue.front;  queue.popFront;\n\t\t\n\t\tforeach(ite; ofs){\n\t\t\tint[2] buf = e;\n\t\t\tbuf[] += ite[];\n\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\tint imf = map[buf[1]][buf[0]];\n\t\t\t\tif( imf == -1 ){\n\t\t\t\t\tif(!done[buf[1]][buf[0]]){\n\t\t\t\t\t\tdone[buf[1]][buf[0]] = true;\n\t\t\t\t\t\tfoot[buf[1]][buf[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\t\tqueue ~= buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( imf == trg ){\n\t\t\t\t\tint ped = foot[e[1]][e[0]];\n\t\t\t\t\tif( min_ > ped ){\n\t\t\t\t\t\tres = res.init;\n\t\t\t\t\t\tres ~= e;\n\t\t\t\t\t\tmin_ = ped;\n\t\t\t\t\t}else if( min_ == ped ){\n\t\t\t\t\t\tres ~= e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treq = res;\n\tmin_ped = min_;\n}\n\nvoid main(){\n\twhile(true){\n\t\tx = next!int;\n\t\ty = next!int;\n\t\tif(!(x|y)) break;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tstring s = next!string;\n\t\t\t\tif(s==\".\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}else if(s==\"P\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tP[0] = j;\n\t\t\t\t\tP[1] = i;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = s.to!int;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tn = next!int;\n\t\tforeach(i; n.iota){\n\t\t\tint g = next!int;\n\t\t\tint d = next!int;\n\t\t\tint s = next!int;\n\t\t\tint e = next!int;\n\t\t\td_list[g] = d;\n\t\t\ts_list[g] = s;\n\t\t\te_list[g] = e;\n\t\t\tn_done[g] = false;\n\t\t}\n\t\tn_done[-1] = false;\n\t\t\n\t\tdfs(0, 0, P, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nimport std.traits;\nstring[] input;\nstring delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\nimport std.bigint;\n\nint[21][21] map;\nint[int] d_list;\nint[int] s_list;\nint[int] e_list;\nint x, y;\nint[2] P;\nint n;\n\nint INF = 1<<28;\n\nint[][] ofs = [ [1, 0], [0, 1], [0, -1], [-1, 0] ];\n\nint[int] memo;\nint dfs(int bits, int value, int[2] p, int time){\n\tif( bits == (1<<n) -1 ){\n\t\treturn value;\n\t}\n\tif( bits in memo ){\n\t\tif( time >= memo[ bits ] ){\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tint max_ = value;\n\tforeach(k, v; d_list){\n\t\tif( ((bits>>k)&0b1)==0b0 ){\n\t\t\tint[2][] req;\n\t\t\tint[] ped_list;\n\t\t\tbfs(p, k, req, ped_list);\n\t\t\tint length = cast(int)req.length;\n\t\t\tforeach(i; length.iota){\n\t\t\t\tint t = time + ped_list[i];\n\t\t\t\tif( s_list[k] <= t && t < e_list[k] ){\n\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], t);\n\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t}else if( t < s_list[k] ){\n\t\t\t\t\tif( (s_list[k] - t)%2 == 0b0 ){\n\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], s_list[k] );\n\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], s_list[k] + 1 );\n\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmemo[ bits ] = time;\n\treturn max_;\n}\n\nbool[21][21] done;\nint[21][21] foot;\nvoid bfs( int[2] p, int trg, ref int[2][] req, ref int[] ped_list){\n\tfoot = foot.init;\n\tdone = done.init;\n\t\n\tint[2][] res;\n\t\n\tint[2][] queue;\n\tdone[p[1]][p[0]] = true;\n\tfoot[p[1]][p[0]] = 0;\n\tqueue ~= p;\n\twhile(queue.length){\n\t\tint[2] e = queue.front;  queue.popFront;\n\t\t\n\t\tforeach(ite; ofs){\n\t\t\tint[2] buf = e;\n\t\t\tbuf[] += ite[];\n\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\tint imf = map[buf[1]][buf[0]];\n\t\t\t\tif( imf == -1 ){\n\t\t\t\t\tif(!done[buf[1]][buf[0]]){\n\t\t\t\t\t\tdone[buf[1]][buf[0]] = true;\n\t\t\t\t\t\tfoot[buf[1]][buf[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\t\tqueue ~= buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( imf == trg ){\n\t\t\t\t\treq ~= e;\n\t\t\t\t\tped_list ~= foot[e[1]][e[0]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid main(){\n\twhile(true){\n\t\tx = next!int;\n\t\ty = next!int;\n\t\tif(!(x|y)) break;\n\t\tmemo = memo.init;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tstring s = next!string;\n\t\t\t\tif(s==\".\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}else if(s==\"P\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tP[0] = j;\n\t\t\t\t\tP[1] = i;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = s.to!int;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tn = next!int;\n\t\tforeach(i; n.iota){\n\t\t\tint g = next!int;\n\t\t\tint d = next!int;\n\t\t\tint s = next!int;\n\t\t\tint e = next!int;\n\t\t\td_list[g] = d;\n\t\t\ts_list[g] = s;\n\t\t\te_list[g] = e;\n\t\t}\n\t\t\n\t\tdfs(0, 0, P, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nimport std.traits;\nstring[] input;\nstring delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  types = new Type[](8);\n  board = new char[][](20, 20);\n  memo = new int[][][][](20, 20, 101, 1 << 7);\n\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if((used & 1 << 7) == 0 && memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  if(used & 1 << 7) return res;\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  types = new Type[](N);\n  board = new char[][](20, 20);\n  memo = new int[][][][](20, 20, 101, 1 << 8);\n\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  board = new char[][](W, H);\n  memo = new int[][][][](20, 20, 101, 1 << 8);\n\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n  types = new Type[](N);\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\nimport std.bigint;\n\nint[21][21] map;\nint[int] d_list;\nint[int] s_list;\nint[int] e_list;\nint x, y;\nint[2] P;\nint n;\n\nint INF = 1<<28;\n\nint[][] ofs = [ [1, 0], [0, 1], [0, -1], [-1, 0] ];\n\nint[int] memo;\nint dfs(int bits, int value, int[2] p, int time){\n\tif( bits == (1<<n) -1 ){\n\t\treturn value;\n\t}\n\tif( bits in memo ){\n\t\tif( time >= memo[ bits ] ){\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tint max_ = value;\n\tforeach(k, v; d_list){\n\t\tif( ((bits>>k)&0b1)==0b0 ){\n\t\t\tint[2][] req;\n\t\t\tint ped;\n\t\t\tbfs(p, k, req, ped);\n\t\t\tif( s_list[k] <= time + ped && time + ped < e_list[k] ){\n\t\t\t\tforeach(ite; req){\n\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, ite, time + ped );\n\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t}\n\t\t\t}else if( time + ped < s_list[k] ){\n\t\t\t\tif( ( s_list[k] - (time + ped) )%2 == 0b0 ){\n\t\t\t\t\tforeach(ite; req){\n\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, ite, s_list[k] );\n\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tforeach(ite; req){\n\t\t\t\t\t\tforeach(ope; ofs){\n\t\t\t\t\t\t\tint[2] buf = ite;\n\t\t\t\t\t\t\tbuf[] += ope[];\n\t\t\t\t\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\t\t\t\t\tint res = dfs( bits, value, buf, s_list[k] );\n\t\t\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmemo[ bits ] = time;\n\treturn max_;\n}\n\nbool[21][21] done;\nint[21][21] foot;\nvoid bfs( int[2] p, int trg, ref int[2][] req, ref int min_ped){\n\tfoot = foot.init;\n\tdone = done.init;\n\t\n\tint min_ = INF;\n\tint[2][] res;\n\t\n\tint[2][] queue;\n\tdone[p[1]][p[0]] = true;\n\tfoot[p[1]][p[0]] = 0;\n\tqueue ~= p;\n\twhile(queue.length){\n\t\tint[2] e = queue.front;  queue.popFront;\n\t\t\n\t\tforeach(ite; ofs){\n\t\t\tint[2] buf = e;\n\t\t\tbuf[] += ite[];\n\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\tint imf = map[buf[1]][buf[0]];\n\t\t\t\tif( imf == -1 ){\n\t\t\t\t\tif(!done[buf[1]][buf[0]]){\n\t\t\t\t\t\tdone[buf[1]][buf[0]] = true;\n\t\t\t\t\t\tfoot[buf[1]][buf[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\t\tqueue ~= buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( imf == trg ){\n\t\t\t\t\tint ped = foot[e[1]][e[0]];\n\t\t\t\t\tif( min_ > ped ){\n\t\t\t\t\t\tres = res.init;\n\t\t\t\t\t\tres ~= e;\n\t\t\t\t\t\tmin_ = ped;\n\t\t\t\t\t}else if( min_ == ped ){\n\t\t\t\t\t\tres ~= e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treq = res;\n\tmin_ped = min_;\n}\n\nvoid main(){\n\twhile(true){\n\t\tx = next!int;\n\t\ty = next!int;\n\t\tif(!(x|y)) break;\n\t\tmemo = memo.init;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tstring s = next!string;\n\t\t\t\tif(s==\".\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}else if(s==\"P\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tP[0] = j;\n\t\t\t\t\tP[1] = i;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = s.to!int;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tn = next!int;\n\t\tforeach(i; n.iota){\n\t\t\tint g = next!int;\n\t\t\tint d = next!int;\n\t\t\tint s = next!int;\n\t\t\tint e = next!int;\n\t\t\td_list[g] = d;\n\t\t\ts_list[g] = s;\n\t\t\te_list[g] = e;\n\t\t}\n\t\t\n\t\tdfs(0, 0, P, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nimport std.traits;\nstring[] input;\nstring delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  memo = new int[][][][](20, 20, 101, 1 << 8);\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  board = new char[][](W, H);\n\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n  types = new Type[](N);\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\n\n\nint[] dx = [0, 0, 0, +1, -1];\nint[] dy = [0, +1, -1, 0, 0];\n\nalias Tuple!(int, \"value\", int, \"start\", int, \"end\") Type;\n\nint H, W, N;\nType[] types;\nint[int] table;\nchar[][] board;\nint[][][][] memo;\n\nvoid main()\n{\n  types = new Type[](8);\n  board = new char[][](20, 20);\n  memo = new int[][][][](20, 20, 101, 1 << 8);\n\n  for(string[] inputs; (inputs = readln.split)[0] != \"0\";){\n\tW = inputs[0].to!int;\n\tH = inputs[1].to!int;\n\t\n\twriteln( solve() );\n  }\n}\n\nint solve()\n{\n  foreach(x; 0..20) foreach(y; 0..20) foreach(t; 0..101) memo[x][y][t][] = -1;\n  \n  int X, Y;\n  \n  foreach(y; 0..H){\n\tauto inputs = readln.split;\n\t\n\tforeach(x; 0..W){\n\t  board[x][y] = inputs[x].to!char;\n\n\t  if(board[x][y] == 'P'){\n\t\tX = x;\n\t\tY = y;\n\t  }\n\t}\n  }\n\n  N = readln.chomp.to!int;\n\n  foreach(i; 0..N){\n\tauto inputs = readln.split.map!\"a.to!int\";\n\n\ttypes[i].value = inputs[1];\n\ttypes[i].start = inputs[2];\n\ttypes[i].end = inputs[3];\n\n\ttable[inputs[0]] = i;\n  }\n\n  return rec(X, Y, 0, 0);\n}\n\nint rec(int x, int y, int t, int used)\n{\n  if(t == 101) return 0;\n  if(used + 1 == 1 << N) return 0;\n  if(memo[x][y][t][used] != -1) return memo[x][y][t][used];\n\n  int res = 0;\n  \n  foreach(i; 0..5){\n\tint nx = x + dx[i], ny = y + dy[i];\n\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t  char data = board[nx][ny];\n\t  \n\t  if('0' <= data && data <= '9'){\n\t\tint idx = table[data - '0'];\n\t\tint s = types[idx].start;\n\t\tint e = types[idx].end;\n\n\t\tif(s <= t && t < e && (used & 1 << idx) == 0){\n\t\t  res = max(res, rec(x, y, t, used | 1 << idx) + types[idx].value);\n\t\t}\n\t  }else{\n\t\tres = max(res, rec(nx, ny, t + 1, used));\n\t  }\n\t}\n  }\n\n  return memo[x][y][t][used] = res;  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\nimport std.bigint;\n\nint[21][21] map;\nint[int] d_list;\nint[int] s_list;\nint[int] e_list;\nint x, y;\nint[2] P;\nint n;\n\nint INF = 1<<28;\n\nint[][] ofs = [ [1, 0], [0, 1], [0, -1], [-1, 0] ];\n\nint[int] memo;\nint dfs(int bits, int value, int[2] p, int time){\n\tif( bits == (1<<n) -1 ){\n\t\treturn value;\n\t}\n\tint b = bits&0xff;\n\tb |= (p[0]&0xff)<<8;\n\tb |= (p[1]&0xff)<<16;\n\tif(b in memo){\n\t\tif( time >= memo[ b ] ){\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tint max_ = value;\n\tforeach(k, v; d_list){\n\t\tif( ((bits>>k)&0b1)==0b0 ){\n\t\t\tint[2][] req;\n\t\t\tint[] ped_list;\n\t\t\tbfs(p, k, req, ped_list);\n\t\t\tint length = cast(int)req.length;\n\t\t\tforeach(i; length.iota){\n\t\t\t\tint t = time + ped_list[i];\n\t\t\t\tif( s_list[k] <= t && t < e_list[k] ){\n\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], t);\n\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t}else if( t < s_list[k] ){\n\t\t\t\t\tif( (s_list[k] - t)%2 == 0b0 ){\n\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], s_list[k] );\n\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif( s_list[k] + 2 < e_list[k] ){\n\t\t\t\t\t\t\tint res = dfs( bits | (1<<k), value + v, req[i], s_list[k] + 2 );\n\t\t\t\t\t\t\tmax_ = max(max_, res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmemo[ b ] = time;\n\treturn max_;\n}\n\nbool[21][21] done;\nint[21][21] foot;\nvoid bfs( int[2] p, int trg, ref int[2][] req, ref int[] ped_list){\n\tfoot = foot.init;\n\tdone = done.init;\n\t\n\tint[2][] res;\n\t\n\tint[2][] queue;\n\tdone[p[1]][p[0]] = true;\n\tfoot[p[1]][p[0]] = 0;\n\tqueue ~= p;\n\twhile(queue.length){\n\t\tint[2] e = queue.front;  queue.popFront;\n\t\t\n\t\tforeach(ite; ofs){\n\t\t\tint[2] buf = e;\n\t\t\tbuf[] += ite[];\n\t\t\tif( 0<=buf[0] && buf[0]<x && 0<=buf[1] && buf[1]<y){\n\t\t\t\tint imf = map[buf[1]][buf[0]];\n\t\t\t\tif( imf == -1 ){\n\t\t\t\t\tif(!done[buf[1]][buf[0]]){\n\t\t\t\t\t\tdone[buf[1]][buf[0]] = true;\n\t\t\t\t\t\tfoot[buf[1]][buf[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\t\tqueue ~= buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( imf == trg ){\n\t\t\t\t\treq ~= e;\n\t\t\t\t\tped_list ~= foot[e[1]][e[0]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid main(){\n\twhile(true){\n\t\tx = next!int;\n\t\ty = next!int;\n\t\tif(!(x|y)) break;\n\t\tmemo = memo.init;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tstring s = next!string;\n\t\t\t\tif(s==\".\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}else if(s==\"P\"){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\tP[0] = j;\n\t\t\t\t\tP[1] = i;\n\t\t\t\t}else{\n\t\t\t\t\tmap[i][j] = s.to!int;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tn = next!int;\n\t\tforeach(i; n.iota){\n\t\t\tint g = next!int;\n\t\t\tint d = next!int;\n\t\t\tint s = next!int;\n\t\t\tint e = next!int;\n\t\t\td_list[g] = d;\n\t\t\ts_list[g] = s;\n\t\t\te_list[g] = e;\n\t\t}\n\t\t\n\t\tdfs(0, 0, P, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln;\nimport std.conv : to;\nimport std.string : split, chomp;\nimport std.traits;\nstring[] input;\nstring delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom string import digits\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\nINF = 10**9\nwhile 1:\n    X, Y = map(int, readline().split())\n    if X == Y == 0:\n        break\n    MP = [readline().split() for i in range(Y)]\n    N = int(readline())\n    I = [[] for i in range(10)]\n    for i in range(N):\n        g, d, s, e = map(int, readline().split())\n        if s < e:\n            I[g].append((i, d, s, e))\n    for ss in I:\n        ss.sort(key=lambda x: x[1])\n    V = [0]*(1 << N)\n    for state in range(1 << N):\n        v = 0\n        for ss in I:\n            x = 0\n            for i, d, s, e in ss:\n                if state & (1 << i):\n                    x = d\n            v += x\n        V[state] = v\n\n    U = [[None]*X for i in range(Y)]\n    sx = sy = 0\n    for i in range(Y):\n        for j in range(X):\n            c = MP[i][j]\n            if c in digits:\n                continue\n            if c == 'P':\n                sy = i; sx = j\n            s = set()\n            for dx, dy in dd:\n                nx = j + dx; ny = i + dy\n                if not 0 <= nx < X or not 0 <= ny < Y:\n                    continue\n                c = MP[ny][nx]\n                if c in digits:\n                    for e in I[int(c)]:\n                        s.add(e)\n            U[i][j] = s\n\n    D = [[[INF]*(1 << N) for i in range(X)] for j in range(Y)]\n    que = [(0, 0, sx, sy)]\n    D[sy][sx][0] = 0\n    while que:\n        cost, state, x, y = heappop(que)\n        D0 = D[y][x]\n        t = D0[state]\n        if t < cost:\n            continue\n        for i, d, s, e in U[y][x]:\n            if t < e and state & (1 << i) == 0:\n                t0 = max(s, t)\n                n_state = state | (1 << i)\n                if t0 < D0[n_state]:\n                    D0[n_state] = t0\n                    heappush(que, (t0, n_state, x, y))\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < X or not 0 <= ny < Y or U[ny][nx] is None:\n                continue\n            if t+1 < D[ny][nx][state]:\n                D[ny][nx][state] = t+1\n                heappush(que, (t+1, state, nx, ny))\n    ans = 0\n    for x in range(X):\n        for y in range(Y):\n            D0 = D[y][x]\n            for state in range(1 << N):\n                if D0[state] < INF:\n                    ans = max(ans, V[state])\n    write(\"%d\\n\" % ans)\n\n"
  }
]